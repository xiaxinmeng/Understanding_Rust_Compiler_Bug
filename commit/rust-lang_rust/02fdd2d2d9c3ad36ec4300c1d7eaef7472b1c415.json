{"sha": "02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZmRkMmQyZDljM2FkMzZlYzQzMDBjMWQ3ZWFlZjc0NzJiMWM0MTU=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-12T23:51:22Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-13T02:22:28Z"}, "message": "Rename std.extfmt.CT to std.extfmt.RT to ct and rt\n\nTemporarily duplicate the entire RT module, leaving it with the old name to\naccomodate the stage0 compiler. Will be removed after the next snapshot.", "tree": {"sha": "36d397c3fe35140e422ca2ea3f8010c243b32c8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36d397c3fe35140e422ca2ea3f8010c243b32c8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "html_url": "https://github.com/rust-lang/rust/commit/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5295a4dabda8f49c1c148b17d13c9074291d45bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5295a4dabda8f49c1c148b17d13c9074291d45bc", "html_url": "https://github.com/rust-lang/rust/commit/5295a4dabda8f49c1c148b17d13c9074291d45bc"}], "stats": {"total": 322, "additions": 288, "deletions": 34}, "files": [{"sha": "df1b5e67f0a375ed49424b9984448058a735a067", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "patch": "@@ -13,36 +13,36 @@ import std::option;\n import std::option::none;\n import std::option::some;\n \n-import std::extfmt::CT::signedness;\n-import std::extfmt::CT::signed;\n-import std::extfmt::CT::unsigned;\n-import std::extfmt::CT::caseness;\n-import std::extfmt::CT::case_upper;\n-import std::extfmt::CT::case_lower;\n-import std::extfmt::CT::ty;\n-import std::extfmt::CT::ty_bool;\n-import std::extfmt::CT::ty_str;\n-import std::extfmt::CT::ty_char;\n-import std::extfmt::CT::ty_int;\n-import std::extfmt::CT::ty_bits;\n-import std::extfmt::CT::ty_hex;\n-import std::extfmt::CT::ty_octal;\n-import std::extfmt::CT::flag;\n-import std::extfmt::CT::flag_left_justify;\n-import std::extfmt::CT::flag_left_zero_pad;\n-import std::extfmt::CT::flag_space_for_sign;\n-import std::extfmt::CT::flag_sign_always;\n-import std::extfmt::CT::flag_alternate;\n-import std::extfmt::CT::count;\n-import std::extfmt::CT::count_is;\n-import std::extfmt::CT::count_is_param;\n-import std::extfmt::CT::count_is_next_param;\n-import std::extfmt::CT::count_implied;\n-import std::extfmt::CT::conv;\n-import std::extfmt::CT::piece;\n-import std::extfmt::CT::piece_string;\n-import std::extfmt::CT::piece_conv;\n-import std::extfmt::CT::parse_fmt_string;\n+import std::extfmt::ct::signedness;\n+import std::extfmt::ct::signed;\n+import std::extfmt::ct::unsigned;\n+import std::extfmt::ct::caseness;\n+import std::extfmt::ct::case_upper;\n+import std::extfmt::ct::case_lower;\n+import std::extfmt::ct::ty;\n+import std::extfmt::ct::ty_bool;\n+import std::extfmt::ct::ty_str;\n+import std::extfmt::ct::ty_char;\n+import std::extfmt::ct::ty_int;\n+import std::extfmt::ct::ty_bits;\n+import std::extfmt::ct::ty_hex;\n+import std::extfmt::ct::ty_octal;\n+import std::extfmt::ct::flag;\n+import std::extfmt::ct::flag_left_justify;\n+import std::extfmt::ct::flag_left_zero_pad;\n+import std::extfmt::ct::flag_space_for_sign;\n+import std::extfmt::ct::flag_sign_always;\n+import std::extfmt::ct::flag_alternate;\n+import std::extfmt::ct::count;\n+import std::extfmt::ct::count_is;\n+import std::extfmt::ct::count_is_param;\n+import std::extfmt::ct::count_is_next_param;\n+import std::extfmt::ct::count_implied;\n+import std::extfmt::ct::conv;\n+import std::extfmt::ct::piece;\n+import std::extfmt::ct::piece_string;\n+import std::extfmt::ct::piece_conv;\n+import std::extfmt::ct::parse_fmt_string;\n \n export expand_syntax_ext;\n \n@@ -163,7 +163,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n     fn make_path_vec(str ident) -> vec[str] {\n         // FIXME: #fmt can't currently be used from within std\n         // because we're explicitly referencing the 'std' crate here\n-        ret vec(\"std\", \"extfmt\", \"RT\", ident);\n+        ret vec(\"std\", \"extfmt\", \"rt\", ident);\n     }\n \n     fn make_rt_path_expr(parser p, common::span sp, str ident) -> @ast::expr {\n@@ -290,7 +290,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n \n     fn make_new_conv(parser p, conv cnv, @ast::expr arg) -> @ast::expr {\n \n-        // FIXME: Extract all this validation into extfmt::CT\n+        // FIXME: Extract all this validation into extfmt::ct\n         fn is_signed_type(conv cnv) -> bool {\n             alt (cnv.ty) {\n                 case (ty_int(?s)) {"}, {"sha": "93d4d7de8d048d26597307d5396ceee5af562dee", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 256, "deletions": 2, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=02fdd2d2d9c3ad36ec4300c1d7eaef7472b1c415", "patch": "@@ -28,7 +28,7 @@ import option::some;\n  */\n \n // Functions used by the fmt extension at compile time\n-mod CT {\n+mod ct {\n     tag signedness {\n         signed;\n         unsigned;\n@@ -305,8 +305,262 @@ mod CT {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n-mod RT {\n+mod rt {\n+\n+    tag flag {\n+        flag_left_justify;\n+        flag_left_zero_pad;\n+        flag_space_for_sign;\n+        flag_sign_always;\n+        flag_alternate;\n+        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n+        // which have some difficulty typechecking currently. See\n+        // comments in front::extfmt::make_flags\n+        flag_none;\n+    }\n+\n+    tag count {\n+        count_is(int);\n+        count_implied;\n+    }\n+\n+    tag ty {\n+        ty_default;\n+        ty_bits;\n+        ty_hex_upper;\n+        ty_hex_lower;\n+        ty_octal;\n+    }\n+\n+    // FIXME: May not want to use a vector here for flags;\n+    // instead just use a bool per flag\n+    type conv = rec(vec[flag] flags,\n+                    count width,\n+                    count precision,\n+                    ty ty);\n+\n+    fn conv_int(&conv cv, int i) -> str {\n+        auto radix = 10u;\n+        auto prec = get_int_precision(cv);\n+        auto s = int_to_str_prec(i, radix, prec);\n+        if (0 <= i) {\n+            if (have_flag(cv.flags, flag_sign_always)) {\n+                s = \"+\" + s;\n+            } else if (have_flag(cv.flags, flag_space_for_sign)) {\n+                s = \" \" + s;\n+            }\n+        }\n+        ret pad(cv, s, pad_signed);\n+    }\n \n+    fn conv_uint(&conv cv, uint u) -> str {\n+        auto prec = get_int_precision(cv);\n+        auto res;\n+        alt (cv.ty) {\n+            case (ty_default) {\n+                res = uint_to_str_prec(u, 10u, prec);\n+            }\n+            case (ty_hex_lower) {\n+                res = uint_to_str_prec(u, 16u, prec);\n+            }\n+            case (ty_hex_upper) {\n+                res = _str::to_upper(uint_to_str_prec(u, 16u, prec));\n+            }\n+            case (ty_bits) {\n+                res = uint_to_str_prec(u, 2u, prec);\n+            }\n+            case (ty_octal) {\n+                res = uint_to_str_prec(u, 8u, prec);\n+            }\n+        }\n+        ret pad(cv, res, pad_unsigned);\n+    }\n+\n+    fn conv_bool(&conv cv, bool b) -> str {\n+        auto s;\n+        if (b) {\n+            s = \"true\";\n+        } else {\n+            s = \"false\";\n+        }\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+        ret conv_str(cv, s);\n+    }\n+\n+    fn conv_char(&conv cv, char c) -> str {\n+        ret pad(cv, _str::from_char(c), pad_nozero);\n+    }\n+\n+    fn conv_str(&conv cv, str s) -> str {\n+        auto unpadded = s;\n+        alt (cv.precision) {\n+            case (count_implied) {\n+            }\n+            case (count_is(?max)) {\n+                // For strings, precision is the maximum characters displayed\n+                if (max as uint < _str::char_len(s)) {\n+                    // FIXME: substr works on bytes, not chars!\n+                    unpadded = _str::substr(s, 0u, max as uint);\n+                }\n+            }\n+        }\n+        ret pad(cv, unpadded, pad_nozero);\n+    }\n+\n+    // Convert an int to string with minimum number of digits. If precision is\n+    // 0 and num is 0 then the result is the empty string.\n+    fn int_to_str_prec(int num, uint radix, uint prec) -> str {\n+        if (num < 0) {\n+            ret \"-\" + uint_to_str_prec((-num) as uint, radix, prec);\n+        } else {\n+            ret uint_to_str_prec(num as uint, radix, prec);\n+        }\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to _uint: but it doesn't seem all that useful.\n+    fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n+        auto s;\n+\n+        if (prec == 0u && num == 0u) {\n+            s = \"\";\n+        } else {\n+            s = _uint::to_str(num, radix);\n+            auto len = _str::char_len(s);\n+            if (len < prec) {\n+                auto diff = prec - len;\n+                auto pad = str_init_elt('0', diff);\n+                s = pad + s;\n+            }\n+        }\n+\n+        ret s;\n+    }\n+\n+    fn get_int_precision(&conv cv) -> uint {\n+        alt (cv.precision) {\n+            case (count_is(?c)) {\n+                ret c as uint;\n+            }\n+            case (count_implied) {\n+                ret 1u;\n+            }\n+        }\n+    }\n+\n+    // FIXME: This might be useful in _str: but needs to be utf8 safe first\n+    fn str_init_elt(char c, uint n_elts) -> str {\n+        auto svec = _vec::init_elt[u8](c as u8, n_elts);\n+        // FIXME: Using unsafe_from_bytes because rustboot\n+        // can't figure out the is_utf8 predicate on from_bytes?\n+        ret _str::unsafe_from_bytes(svec);\n+    }\n+\n+    tag pad_mode {\n+        pad_signed;\n+        pad_unsigned;\n+        pad_nozero;\n+    }\n+\n+    fn pad(&conv cv, str s, pad_mode mode) -> str {\n+        auto uwidth;\n+        alt (cv.width) {\n+            case (count_implied) {\n+                ret s;\n+            }\n+            case (count_is(?width)) {\n+                // FIXME: Maybe width should be uint\n+                uwidth = width as uint;\n+            }\n+        }\n+\n+        auto strlen = _str::char_len(s);\n+        if (uwidth <= strlen) {\n+            ret s;\n+        }\n+\n+        auto padchar = ' ';\n+        auto diff = uwidth - strlen;\n+        if (have_flag(cv.flags, flag_left_justify)) {\n+            auto padstr = str_init_elt(padchar, diff);\n+            ret s + padstr;\n+        }\n+\n+        auto might_zero_pad = false;\n+        auto signed = false;\n+\n+        alt (mode) {\n+            case (pad_nozero) {\n+                // fallthrough\n+            }\n+            case (pad_signed) {\n+                might_zero_pad = true;\n+                signed = true;\n+            }\n+            case (pad_unsigned) {\n+                might_zero_pad = true;\n+            }\n+        }\n+\n+        fn have_precision(&conv cv) -> bool {\n+            alt (cv.precision) {\n+                case (count_implied) {\n+                    ret false;\n+                }\n+                case (_) {\n+                    ret true;\n+                }\n+            }\n+        }\n+\n+        auto zero_padding = false;\n+        if (might_zero_pad\n+            && have_flag(cv.flags, flag_left_zero_pad)\n+            && !have_precision(cv)) {\n+\n+            padchar = '0';\n+            zero_padding = true;\n+        }\n+\n+        auto padstr = str_init_elt(padchar, diff);\n+\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+        if (signed\n+            && zero_padding\n+            && _str::byte_len(s) > 0u) {\n+\n+            auto head = s.(0);\n+            if (head == '+' as u8\n+                || head == '-' as u8\n+                || head == ' ' as u8) {\n+\n+                auto headstr = _str::unsafe_from_bytes(vec(head));\n+                auto bytelen = _str::byte_len(s);\n+                auto numpart = _str::substr(s, 1u, bytelen - 1u);\n+                ret headstr + padstr + numpart;\n+            }\n+        }\n+        ret padstr + s;\n+    }\n+\n+    fn have_flag(vec[flag] flags, flag f) -> bool {\n+        for (flag candidate in flags) {\n+            if (candidate == f) {\n+                ret true;\n+            }\n+        }\n+        ret false;\n+    }\n+}\n+\n+// FIXME: This is a temporary duplication of the rt mod that only\n+// needs to exist to accomodate the stage0 compiler until the next snapshot\n+mod RT {\n     tag flag {\n         flag_left_justify;\n         flag_left_zero_pad;"}]}