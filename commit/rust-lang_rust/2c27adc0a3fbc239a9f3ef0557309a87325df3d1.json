{"sha": "2c27adc0a3fbc239a9f3ef0557309a87325df3d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjdhZGMwYTNmYmMyMzlhOWYzZWYwNTU3MzA5YTg3MzI1ZGYzZDE=", "commit": {"author": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-19T12:09:52Z"}, "committer": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-19T12:09:52Z"}, "message": "Remove `match_ast!` macro call\n\nAdd node about uncommenting tuple in macro call", "tree": {"sha": "5ec4530f1a184bbcfa930a912570d31a241d4086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ec4530f1a184bbcfa930a912570d31a241d4086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c27adc0a3fbc239a9f3ef0557309a87325df3d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJTdsK5zmAD3L8AFljIMXU7iI9loFAmEeSm8ACgkQjIMXU7iI\n9lpbqg//TY3QJ72EYbuNx+hDZPMNIJuRTlB91yvMm0ToxRLh9bpg0Sdz5wg4TRjm\nI0vghhnm3EQxFygawzFe7BTVuXEQbbWYET1BLnFb/XB+yCtEWuYq30KxE9PDykHD\ng6bRVzzfK/TqPFWiwM/ve7/l04A4e+ozfKKZrSBMi2cO64o+bkeM5l+GO+AxfLp9\n/CFFd6genS8sP67gA4oF295vIv8bCRXiBSXBqQeuXwMWmmQIoe+iH9GrLStrH7VK\nUdeUrqlyVQfL5Vw6gW/4u9cfOhlacIo4q1P2ld+czUNcHwgQtAlW9Nh+R7zOWeq2\nM+pdLr/f0G1a5dyvA4F0NKxycOsYCyW4xHivXIdKx6qLtJzGK3ZiJWziG5/5+PoR\ng80Ll4sUOLr90Jdf19JRJGyGDD6h2vx1+aOmAlz1DUHWRm+5ksDnSi6Ms2ECCQW9\n/2W6VoBtq2Fq0s9oGSYqmj4QEQkK/RZXhlws2Sepj9LS+dlgf4xX5TVJCJ/DxZQH\n1AZ8fGcTuoSKApZdEbP8bFjiIVZ7UQbLd3M3yvv5+2lrGT6gwp03qK3JJVf/pZLX\nUdvDTUFuLF8TnQKI+NUStYBiz3JzXsNUPGZM4qs7RU4Q5g/zJc1ZNqMFaj1bbxgx\n2izbTiraQ/G/RJ3OMX2Wj1Qi1zczxHEyfZ+8e/r1eD3TFIMx8Ps=\n=x+C1\n-----END PGP SIGNATURE-----", "payload": "tree 5ec4530f1a184bbcfa930a912570d31a241d4086\nparent b1ebb82f32a200480a5a35dbf961b07cf50df451\nauthor BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629374992 +0200\ncommitter BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629374992 +0200\n\nRemove `match_ast!` macro call\n\nAdd node about uncommenting tuple in macro call\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c27adc0a3fbc239a9f3ef0557309a87325df3d1", "html_url": "https://github.com/rust-lang/rust/commit/2c27adc0a3fbc239a9f3ef0557309a87325df3d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c27adc0a3fbc239a9f3ef0557309a87325df3d1/comments", "author": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ebb82f32a200480a5a35dbf961b07cf50df451", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ebb82f32a200480a5a35dbf961b07cf50df451", "html_url": "https://github.com/rust-lang/rust/commit/b1ebb82f32a200480a5a35dbf961b07cf50df451"}], "stats": {"total": 153, "additions": 80, "deletions": 73}, "files": [{"sha": "eebeb2c4a51535a83961600995dea2433da54121", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2c27adc0a3fbc239a9f3ef0557309a87325df3d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c27adc0a3fbc239a9f3ef0557309a87325df3d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=2c27adc0a3fbc239a9f3ef0557309a87325df3d1", "patch": "@@ -227,6 +227,11 @@ fn edit_tuple_usage(\n \n             // no index access -> make invalid -> requires handling by user\n             // -> put usage in block comment\n+            //\n+            // Note: For macro invocations this might result in still valid code:\n+            //   When a macro accepts the tuple as argument, as well as no arguments at all,\n+            //   uncommenting the tuple still leaves the macro call working (see `tests::in_macro_call::empty_macro`).\n+            //   But this is an unlikely case. Usually the resulting macro call will become erroneous.\n             builder.insert(usage.range.start(), \"/*\");\n             builder.insert(usage.range.end(), \"*/\");\n         }\n@@ -322,89 +327,91 @@ fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefDat\n     let mut ref_data =\n         RefData { range: s.text_range(), needs_deref: true, needs_parentheses: true };\n \n-    let parent = match s.parent() {\n-        Some(parent) => parent,\n+    let parent = match s.parent().map(ast::Expr::cast) {\n+        Some(Some(parent)) => parent,\n+        Some(None) => {\n+            ref_data.needs_parentheses = false;\n+            return ref_data;\n+        }\n         None => return ref_data,\n     };\n \n-    match_ast! {\n-        match parent {\n-            ast::ParenExpr(it) => {\n-                // already parens in place -> don't replace\n-                ref_data.needs_parentheses = false;\n-                // there might be a ref outside: `&(t.0)` -> can be removed\n-                if let Some(it) = it.syntax().parent().and_then(ast::RefExpr::cast) {\n-                    ref_data.needs_deref = false;\n-                    ref_data.range =  it.syntax().text_range();\n-                }\n-            },\n-            ast::RefExpr(it) => {\n-                // `&*` -> cancel each other out\n+    match parent {\n+        ast::Expr::ParenExpr(it) => {\n+            // already parens in place -> don't replace\n+            ref_data.needs_parentheses = false;\n+            // there might be a ref outside: `&(t.0)` -> can be removed\n+            if let Some(it) = it.syntax().parent().and_then(ast::RefExpr::cast) {\n                 ref_data.needs_deref = false;\n-                ref_data.needs_parentheses = false;\n-                // might be surrounded by parens -> can be removed too\n-                match it.syntax().parent().and_then(ast::ParenExpr::cast) {\n-                    Some(parent) => ref_data.range = parent.syntax().text_range(),\n-                    None => ref_data.range = it.syntax().text_range(),\n-                };\n-            },\n-            // higher precedence than deref `*`\n-            // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n-            // -> requires parentheses\n-            ast::PathExpr(_it) => {},\n-            ast::MethodCallExpr(it) => {\n-                // `field_expr` is `self_param` (otherwise it would be in `ArgList`)\n+                ref_data.range = it.syntax().text_range();\n+            }\n+        }\n+        ast::Expr::RefExpr(it) => {\n+            // `&*` -> cancel each other out\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+            // might be surrounded by parens -> can be removed too\n+            match it.syntax().parent().and_then(ast::ParenExpr::cast) {\n+                Some(parent) => ref_data.range = parent.syntax().text_range(),\n+                None => ref_data.range = it.syntax().text_range(),\n+            };\n+        }\n+        // higher precedence than deref `*`\n+        // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+        // -> requires parentheses\n+        ast::Expr::PathExpr(_it) => {}\n+        ast::Expr::MethodCallExpr(it) => {\n+            // `field_expr` is `self_param` (otherwise it would be in `ArgList`)\n+\n+            // test if there's already auto-ref in place (`value` -> `&value`)\n+            // -> no method accepting `self`, but `&self` -> no need for deref\n+            //\n+            // other combinations (`&value` -> `value`, `&&value` -> `&value`, `&value` -> `&&value`) might or might not be able to auto-ref/deref,\n+            // but there might be trait implementations an added `&` might resolve to\n+            // -> ONLY handle auto-ref from `value` to `&value`\n+            fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n+                fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n+                    let rec = call_expr.receiver()?;\n+                    let rec_ty = ctx.sema.type_of_expr(&rec)?.adjusted();\n+                    // input must be actual value\n+                    if rec_ty.is_reference() {\n+                        return Some(false);\n+                    }\n \n-                // test if there's already auto-ref in place (`value` -> `&value`)\n-                // -> no method accepting `self`, but `&self` -> no need for deref\n-                //\n-                // other combinations (`&value` -> `value`, `&&value` -> `&value`, `&value` -> `&&value`) might or might not be able to auto-ref/deref,\n-                // but there might be trait implementations an added `&` might resolve to\n-                // -> ONLY handle auto-ref from `value` to `&value`\n-                fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n-                    fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n-                        let rec = call_expr.receiver()?;\n-                        let rec_ty = ctx.sema.type_of_expr(&rec)?.adjusted();\n-                        // input must be actual value\n-                        if rec_ty.is_reference() {\n-                            return Some(false);\n-                        }\n-\n-                        // doesn't resolve trait impl\n-                        let f = ctx.sema.resolve_method_call(call_expr)?;\n-                        let self_param = f.self_param(ctx.db())?;\n-                        // self must be ref\n-                        match self_param.access(ctx.db()) {\n-                            hir::Access::Shared | hir::Access::Exclusive => Some(true),\n-                            hir::Access::Owned => Some(false),\n-                        }\n+                    // doesn't resolve trait impl\n+                    let f = ctx.sema.resolve_method_call(call_expr)?;\n+                    let self_param = f.self_param(ctx.db())?;\n+                    // self must be ref\n+                    match self_param.access(ctx.db()) {\n+                        hir::Access::Shared | hir::Access::Exclusive => Some(true),\n+                        hir::Access::Owned => Some(false),\n                     }\n-                    impl_(ctx, call_expr).unwrap_or(false)\n                 }\n+                impl_(ctx, call_expr).unwrap_or(false)\n+            }\n \n-                if is_auto_ref(ctx, &it) {\n-                    ref_data.needs_deref = false;\n-                    ref_data.needs_parentheses = false;\n-                }\n-            },\n-            ast::FieldExpr(_it) => {\n-                // `t.0.my_field`\n-                ref_data.needs_deref = false;\n-                ref_data.needs_parentheses = false;\n-            },\n-            ast::IndexExpr(_it) => {\n-                // `t.0[1]`\n+            if is_auto_ref(ctx, &it) {\n                 ref_data.needs_deref = false;\n                 ref_data.needs_parentheses = false;\n-            },\n-            ast::TryExpr(_it) => {\n-                // `t.0?`\n-                // requires deref and parens: `(*_0)`\n-            },\n-            // lower precedence than deref `*` -> no parens\n-            _ => {\n-                ref_data.needs_parentheses = false;\n-            },\n+            }\n+        }\n+        ast::Expr::FieldExpr(_it) => {\n+            // `t.0.my_field`\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+        }\n+        ast::Expr::IndexExpr(_it) => {\n+            // `t.0[1]`\n+            ref_data.needs_deref = false;\n+            ref_data.needs_parentheses = false;\n+        }\n+        ast::Expr::TryExpr(_it) => {\n+            // `t.0?`\n+            // requires deref and parens: `(*_0)`\n+        }\n+        // lower precedence than deref `*` -> no parens\n+        _ => {\n+            ref_data.needs_parentheses = false;\n         }\n     };\n "}]}