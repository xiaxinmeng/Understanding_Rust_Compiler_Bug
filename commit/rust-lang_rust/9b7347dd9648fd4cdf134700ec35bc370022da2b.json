{"sha": "9b7347dd9648fd4cdf134700ec35bc370022da2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNzM0N2RkOTY0OGZkNGNkZjEzNDcwMGVjMzViYzM3MDAyMmRhMmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-03T03:04:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-07T05:44:18Z"}, "message": "modify upcalls to take structs as args", "tree": {"sha": "95bc7ab0f50bea46d577d4f62d840bb9d2f550e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95bc7ab0f50bea46d577d4f62d840bb9d2f550e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b7347dd9648fd4cdf134700ec35bc370022da2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b7347dd9648fd4cdf134700ec35bc370022da2b", "html_url": "https://github.com/rust-lang/rust/commit/9b7347dd9648fd4cdf134700ec35bc370022da2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b7347dd9648fd4cdf134700ec35bc370022da2b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b608125ac2d59cace17fc3f177d13e2a0021716", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b608125ac2d59cace17fc3f177d13e2a0021716", "html_url": "https://github.com/rust-lang/rust/commit/8b608125ac2d59cace17fc3f177d13e2a0021716"}], "stats": {"total": 336, "additions": 252, "deletions": 84}, "files": [{"sha": "40cb35f0149d8b231f97316a766c13ca16890115", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 252, "deletions": 84, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/9b7347dd9648fd4cdf134700ec35bc370022da2b/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9b7347dd9648fd4cdf134700ec35bc370022da2b/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=9b7347dd9648fd4cdf134700ec35bc370022da2b", "patch": "@@ -6,7 +6,31 @@\n #include \"rust_upcall.h\"\n #include <stdint.h>\n \n-// Upcalls.\n+extern \"C\" void record_sp(void *limit);\n+\n+/**\n+ * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n+ */\n+extern \"C\" CDECL void\n+upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n+    rust_task *task = rust_scheduler::get_task();\n+\n+    // FIXME (1226) - The shim functions generated by rustc contain the\n+    // morestack prologue, so we need to let them know they have enough\n+    // stack.\n+    record_sp(0);\n+\n+    rust_scheduler *sched = task->sched;\n+    try {\n+        sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n+    } catch (...) {\n+        task = rust_scheduler::get_task();\n+        task->record_stack_limit();\n+        throw;\n+    }\n+    task = rust_scheduler::get_task();\n+    task->record_stack_limit();\n+}\n \n #if defined(__i386__) || defined(__x86_64__) || defined(_M_X64)\n void\n@@ -47,193 +71,221 @@ copy_elements(rust_task *task, type_desc *elem_t,\n     }\n }\n \n+struct s_fail_args {\n+    char const *expr;\n+    char const *file;\n+    size_t line;\n+};\n+\n extern \"C\" CDECL void\n-upcall_fail(char const *expr,\n-            char const *file,\n-            size_t line) {\n+upcall_s_fail(s_fail_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n+    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, \n+            args->expr, args->file, args->line);\n     task->fail();\n }\n \n+struct s_malloc_args {\n+    size_t nbytes;\n+    type_desc *td;\n+};\n+\n extern \"C\" CDECL uintptr_t\n-upcall_malloc(size_t nbytes, type_desc *td) {\n+upcall_s_malloc(s_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n-        nbytes, td);\n+        args->nbytes, args->td);\n \n     gc::maybe_gc(task);\n     cc::maybe_cc(task);\n \n     // TODO: Maybe use dladdr here to find a more useful name for the\n     // type_desc.\n \n-    void *p = task->malloc(nbytes, \"tdesc\", td);\n-    memset(p, '\\0', nbytes);\n+    void *p = task->malloc(args->nbytes, \"tdesc\", args->td);\n+    memset(p, '\\0', args->nbytes);\n \n-    task->local_allocs[p] = td;\n+    task->local_allocs[p] = args->td;\n     debug::maybe_track_origin(task, p);\n \n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \") = 0x%\" PRIxPTR,\n-        nbytes, td, (uintptr_t)p);\n+        args->nbytes, args->td, (uintptr_t)p);\n     return (uintptr_t) p;\n }\n \n+struct s_free_args {\n+    void *ptr;\n+    uintptr_t is_gc;\n+};\n+\n /**\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_free(void* ptr, uintptr_t is_gc) {\n+upcall_s_free(s_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n     DLOG(sched, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n-             (uintptr_t)ptr, is_gc);\n+             (uintptr_t)args->ptr, args->is_gc);\n \n-    task->local_allocs.erase(ptr);\n-    debug::maybe_untrack_origin(task, ptr);\n+    task->local_allocs.erase(args->ptr);\n+    debug::maybe_untrack_origin(task, args->ptr);\n \n-    task->free(ptr, (bool) is_gc);\n+    task->free(args->ptr, (bool) args->is_gc);\n }\n \n+struct s_shared_malloc_args {\n+    size_t nbytes;\n+    type_desc *td;\n+};\n+\n extern \"C\" CDECL uintptr_t\n-upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+upcall_s_shared_malloc(s_shared_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n-                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n-                   nbytes, td);\n-    void *p = task->kernel->malloc(nbytes, \"shared malloc\");\n-    memset(p, '\\0', nbytes);\n+        \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n+        args->nbytes, args->td);\n+    void *p = task->kernel->malloc(args->nbytes, \"shared malloc\");\n+    memset(p, '\\0', args->nbytes);\n     LOG(task, mem,\n-                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n-                   \") = 0x%\" PRIxPTR,\n-                   nbytes, td, (uintptr_t)p);\n+        \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n+        \") = 0x%\" PRIxPTR,\n+        args->nbytes, args->td, (uintptr_t)p);\n     return (uintptr_t) p;\n }\n \n+struct s_shared_free_args {\n+    void *ptr;\n+};\n+\n /**\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_shared_free(void* ptr) {\n+upcall_s_shared_free(s_shared_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n     DLOG(sched, mem,\n              \"upcall shared_free(0x%\" PRIxPTR\")\",\n-             (uintptr_t)ptr);\n-    task->kernel->free(ptr);\n+             (uintptr_t)args->ptr);\n+    task->kernel->free(args->ptr);\n }\n \n+struct s_get_type_desc_args {\n+    size_t size;\n+    size_t align;\n+    size_t n_descs;\n+    type_desc const **descs;\n+    uintptr_t n_obj_params;\n+};\n+\n extern \"C\" CDECL type_desc *\n-upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n-                     size_t size,\n-                     size_t align,\n-                     size_t n_descs,\n-                     type_desc const **descs,\n-                     uintptr_t n_obj_params) {\n+upcall_s_get_type_desc(s_get_type_desc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     check_stack(task);\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n-        \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n-        n_descs);\n+        \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", args->size, args->align,\n+        args->n_descs);\n     rust_crate_cache *cache = task->get_crate_cache();\n-    type_desc *td = cache->get_type_desc(size, align, n_descs, descs,\n-                                         n_obj_params);\n+    type_desc *td = cache->get_type_desc(args->size, args->align, args->n_descs,\n+                                         args->descs, args->n_obj_params);\n     LOG(task, cache, \"returning tydesc 0x%\" PRIxPTR, td);\n     return td;\n }\n \n+struct s_vec_grow_args {\n+    rust_vec** vp;\n+    size_t new_sz;\n+};\n+\n extern \"C\" CDECL void\n-upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+upcall_s_vec_grow(s_vec_grow_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    reserve_vec(task, vp, new_sz);\n-    (*vp)->fill = new_sz;\n+    reserve_vec(task, args->vp, args->new_sz);\n+    (*args->vp)->fill = args->new_sz;\n }\n \n+struct s_vec_push_args {\n+    rust_vec** vp;\n+    type_desc* elt_ty;\n+    void* elt;\n+};\n+\n extern \"C\" CDECL void\n-upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+upcall_s_vec_push(s_vec_push_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    size_t new_sz = (*vp)->fill + elt_ty->size;\n-    reserve_vec(task, vp, new_sz);\n-    rust_vec* v = *vp;\n-    copy_elements(task, elt_ty, &v->data[0] + v->fill, elt, elt_ty->size);\n-    v->fill += elt_ty->size;\n+    size_t new_sz = (*args->vp)->fill + args->elt_ty->size;\n+    reserve_vec(task, args->vp, new_sz);\n+    rust_vec* v = *args->vp;\n+    copy_elements(task, args->elt_ty, &v->data[0] + v->fill, \n+                  args->elt, args->elt_ty->size);\n+    v->fill += args->elt_ty->size;\n }\n \n /**\n  * Returns a token that can be used to deallocate all of the allocated space\n  * space in the dynamic stack.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_mark() {\n+upcall_s_dynastack_mark() {\n     return rust_scheduler::get_task()->dynastack.mark();\n }\n \n+struct s_dynastack_alloc_args {\n+    size_t sz;\n+};\n+\n /**\n  * Allocates space in the dynamic stack and returns it.\n  *\n  * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc(size_t sz) {\n+upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n+    size_t sz = args->sz;\n     return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n+struct s_dynastack_alloc_2_args {\n+    size_t sz;\n+    type_desc *ty;\n+};\n+\n /**\n  * Allocates space associated with a type descriptor in the dynamic stack and\n  * returns it.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n+    size_t sz = args->sz;\n+    type_desc *ty = args->ty;\n     return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n+struct s_dynastack_free_args {\n+    void *ptr;\n+};\n+\n /** Frees space in the dynamic stack. */\n extern \"C\" CDECL void\n-upcall_dynastack_free(void *ptr) {\n-    return rust_scheduler::get_task()->dynastack.free(ptr);\n-}\n-\n-extern \"C\" void record_sp(void *limit);\n-\n-/**\n- * Switch to the C stack and call the given function, passing a single pointer\n- * argument.\n- */\n-extern \"C\" CDECL void\n-upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_scheduler::get_task();\n-\n-    // FIXME (1226) - The shim functions generated by rustc contain the\n-    // morestack prologue, so we need to let them know they have enough\n-    // stack.\n-    record_sp(0);\n-\n-    rust_scheduler *sched = task->sched;\n-    try {\n-        sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n-    } catch (...) {\n-        task = rust_scheduler::get_task();\n-        task->record_stack_limit();\n-        throw;\n-    }\n-    task = rust_scheduler::get_task();\n-    task->record_stack_limit();\n+upcall_s_dynastack_free(s_dynastack_free_args *args) {\n+    return rust_scheduler::get_task()->dynastack.free(args->ptr);\n }\n \n struct rust_new_stack2_args {\n@@ -275,17 +327,134 @@ __gxx_personality_v0(int version,\n                      _Unwind_Exception *ue_header,\n                      _Unwind_Context *context);\n \n+struct s_rust_personality_args {\n+    int version;\n+    _Unwind_Action actions;\n+    uint64_t exception_class;\n+    _Unwind_Exception *ue_header;\n+    _Unwind_Context *context;\n+};\n+\n+extern \"C\" _Unwind_Reason_Code\n+upcall_s_rust_personality(s_rust_personality_args *args) {\n+    return __gxx_personality_v0(args->version,\n+                                args->actions,\n+                                args->exception_class,\n+                                args->ue_header,\n+                                args->context);\n+}\n+\n+// ______________________________________________________________________________\n+// Upcalls in original format: deprecated and should be removed once snapshot\n+// transitions them away.\n+\n+extern \"C\" CDECL void\n+upcall_fail(char const *expr,\n+            char const *file,\n+            size_t line) {\n+    s_fail_args args = {expr,file,line};\n+    upcall_s_fail(&args);\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_malloc(size_t nbytes, type_desc *td) {\n+    s_malloc_args args = {nbytes, td};\n+    return upcall_s_malloc(&args);\n+}\n+\n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_free(void* ptr, uintptr_t is_gc) {\n+    s_free_args args = {ptr, is_gc};\n+    upcall_s_free(&args);\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+    s_shared_malloc_args args = {nbytes, td};\n+    return upcall_s_shared_malloc(&args);\n+}\n+\n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_shared_free(void* ptr) {\n+    s_shared_free_args args = {ptr};\n+    upcall_s_shared_free(&args);\n+}\n+\n+extern \"C\" CDECL type_desc *\n+upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n+                     size_t size,\n+                     size_t align,\n+                     size_t n_descs,\n+                     type_desc const **descs,\n+                     uintptr_t n_obj_params) {\n+    s_get_type_desc_args args = {size,align,n_descs,descs,n_obj_params};\n+    return upcall_s_get_type_desc(&args);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+    s_vec_grow_args args = {vp, new_sz};\n+    upcall_s_vec_grow(&args);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+    s_vec_push_args args = {vp, elt_ty, elt};\n+    upcall_s_vec_push(&args);\n+}\n+\n+/**\n+ * Returns a token that can be used to deallocate all of the allocated space\n+ * space in the dynamic stack.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_mark() {\n+    return upcall_s_dynastack_mark();\n+}\n+\n+/**\n+ * Allocates space in the dynamic stack and returns it.\n+ *\n+ * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc(size_t sz) {\n+    s_dynastack_alloc_args args = {sz};\n+    return upcall_s_dynastack_alloc(&args);\n+}\n+\n+/**\n+ * Allocates space associated with a type descriptor in the dynamic stack and\n+ * returns it.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+    s_dynastack_alloc_2_args args = {sz, ty};\n+    return upcall_s_dynastack_alloc_2(&args);\n+}\n+\n+/** Frees space in the dynamic stack. */\n+extern \"C\" CDECL void\n+upcall_dynastack_free(void *ptr) {\n+    s_dynastack_free_args args = {ptr};\n+    return upcall_s_dynastack_free(&args);\n+}\n+\n extern \"C\" _Unwind_Reason_Code\n upcall_rust_personality(int version,\n                         _Unwind_Action actions,\n                         uint64_t exception_class,\n                         _Unwind_Exception *ue_header,\n                         _Unwind_Context *context) {\n-    return __gxx_personality_v0(version,\n-                                actions,\n-                                exception_class,\n-                                ue_header,\n-                                context);\n+    s_rust_personality_args args = {version, actions, exception_class, ue_header, \n+                                    context};\n+    return upcall_s_rust_personality(&args);\n }\n \n //\n@@ -295,6 +464,5 @@ upcall_rust_personality(int version,\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}]}