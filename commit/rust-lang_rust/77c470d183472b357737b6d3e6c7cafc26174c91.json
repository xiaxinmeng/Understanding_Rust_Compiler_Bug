{"sha": "77c470d183472b357737b6d3e6c7cafc26174c91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YzQ3MGQxODM0NzJiMzU3NzM3YjZkM2U2YzdjYWZjMjYxNzRjOTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-02T04:54:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-02T17:08:04Z"}, "message": "Allow rcvrs to be borrowed; check rcvrs in borrowck properly", "tree": {"sha": "cffbc400b4814df5fc610e0616c82927cc5db843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cffbc400b4814df5fc610e0616c82927cc5db843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77c470d183472b357737b6d3e6c7cafc26174c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77c470d183472b357737b6d3e6c7cafc26174c91", "html_url": "https://github.com/rust-lang/rust/commit/77c470d183472b357737b6d3e6c7cafc26174c91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77c470d183472b357737b6d3e6c7cafc26174c91/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfac9b6833be05a476b5694f855089b48c53697b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfac9b6833be05a476b5694f855089b48c53697b", "html_url": "https://github.com/rust-lang/rust/commit/cfac9b6833be05a476b5694f855089b48c53697b"}], "stats": {"total": 454, "additions": 362, "deletions": 92}, "files": [{"sha": "615a6737c8344bb7c2eb729f49cda8f72ec61b6f", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 86, "deletions": 39, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -145,12 +145,22 @@ impl methods for check_loan_ctxt {\n \n     // when we are in a pure context, we check each call to ensure\n     // that the function which is invoked is itself pure.\n-    fn check_pure_callee_or_arg(pc: purity_cause, expr: @ast::expr) {\n+    //\n+    // note: we take opt_expr and expr_id separately because for\n+    // overloaded operators the callee has an id but no expr.\n+    // annoying.\n+    fn check_pure_callee_or_arg(pc: purity_cause,\n+                                opt_expr: option<@ast::expr>,\n+                                callee_id: ast::node_id,\n+                                callee_span: span) {\n         let tcx = self.tcx();\n \n-        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%s, ty=%s)\",\n-               pc, pprust::expr_to_str(expr),\n-               ty_to_str(self.tcx(), tcx.ty(expr))];\n+        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n+                callee_id=%d, ty=%s)\",\n+               pc,\n+               opt_expr.map({|e| pprust::expr_to_str(e)}),\n+               callee_id,\n+               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))];\n \n         // Purity rules: an expr B is a legal callee or argument to a\n         // call within a pure function A if at least one of the\n@@ -161,29 +171,35 @@ impl methods for check_loan_ctxt {\n         // (c) B is a pure fn;\n         // (d) B is not a fn.\n \n-        alt expr.node {\n-          ast::expr_path(_) if pc == pc_pure_fn {\n-            let def = self.tcx().def_map.get(expr.id);\n-            let did = ast_util::def_id_of_def(def);\n-            let is_fn_arg =\n-                did.crate == ast::local_crate &&\n-                self.fn_args.contains(did.node);\n-            if is_fn_arg { ret; } // case (a) above\n-          }\n-          ast::expr_fn_block(*) | ast::expr_fn(*) | ast::expr_loop_body(*) {\n-            if self.is_stack_closure(expr.id) { ret; } // case (b) above\n+        alt opt_expr {\n+          some(expr) {\n+            alt expr.node {\n+              ast::expr_path(_) if pc == pc_pure_fn {\n+                let def = self.tcx().def_map.get(expr.id);\n+                let did = ast_util::def_id_of_def(def);\n+                let is_fn_arg =\n+                    did.crate == ast::local_crate &&\n+                    self.fn_args.contains(did.node);\n+                if is_fn_arg { ret; } // case (a) above\n+              }\n+              ast::expr_fn_block(*) | ast::expr_fn(*) |\n+              ast::expr_loop_body(*) {\n+                if self.is_stack_closure(expr.id) { ret; } // case (b) above\n+              }\n+              _ {}\n+            }\n           }\n-          _ {}\n+          none {}\n         }\n \n-        let expr_ty = tcx.ty(expr);\n-        alt ty::get(expr_ty).struct {\n+        let callee_ty = ty::node_id_to_type(tcx, callee_id);\n+        alt ty::get(callee_ty).struct {\n           ty::ty_fn(fn_ty) {\n             alt fn_ty.purity {\n               ast::pure_fn { ret; } // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::crust_fn {\n                 self.report_purity_error(\n-                    pc, expr.span,\n+                    pc, callee_span,\n                     #fmt[\"access to %s function\",\n                          pprust::purity_to_str(fn_ty.purity)]);\n               }\n@@ -429,6 +445,39 @@ impl methods for check_loan_ctxt {\n             ret;\n         }\n     }\n+\n+    fn check_call(expr: @ast::expr,\n+                  callee: option<@ast::expr>,\n+                  callee_id: ast::node_id,\n+                  callee_span: span,\n+                  args: [@ast::expr]) {\n+        alt self.purity(expr.id) {\n+          none {}\n+          some(pc) {\n+            self.check_pure_callee_or_arg(\n+                pc, callee, callee_id, callee_span);\n+            for args.each { |arg|\n+                self.check_pure_callee_or_arg(\n+                    pc, some(arg), arg.id, arg.span);\n+            }\n+          }\n+        }\n+        let arg_tys =\n+            ty::ty_fn_args(\n+                ty::node_id_to_type(self.tcx(), callee_id));\n+        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_move {\n+                self.check_move_out(arg);\n+              }\n+              ast::by_mutbl_ref {\n+                self.check_assignment(at_mutbl_ref, arg);\n+              }\n+              ast::by_ref | ast::by_copy | ast::by_val {\n+              }\n+            }\n+        }\n+    }\n }\n \n fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n@@ -521,26 +570,24 @@ fn check_loans_in_expr(expr: @ast::expr,\n         }\n       }\n       ast::expr_call(f, args, _) {\n-        alt self.purity(expr.id) {\n-          none {}\n-          some(pc) {\n-            self.check_pure_callee_or_arg(pc, f);\n-            for args.each { |arg| self.check_pure_callee_or_arg(pc, arg) }\n-          }\n-        }\n-        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n-        vec::iter2(args, arg_tys) { |arg, arg_ty|\n-            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_move {\n-                self.check_move_out(arg);\n-              }\n-              ast::by_mutbl_ref {\n-                self.check_assignment(at_mutbl_ref, arg);\n-              }\n-              ast::by_ref | ast::by_copy | ast::by_val {\n-              }\n-            }\n-        }\n+        self.check_call(expr, some(f), f.id, f.span, args);\n+      }\n+      ast::expr_index(_, rval) |\n+      ast::expr_binary(_, _, rval)\n+      if self.bccx.method_map.contains_key(expr.id) {\n+        self.check_call(expr,\n+                        none,\n+                        ast_util::op_expr_callee_id(expr),\n+                        expr.span,\n+                        [rval]);\n+      }\n+      ast::expr_unary(_, _)\n+      if self.bccx.method_map.contains_key(expr.id) {\n+        self.check_call(expr,\n+                        none,\n+                        ast_util::op_expr_callee_id(expr),\n+                        expr.span,\n+                        []);\n       }\n       _ { }\n     }"}, {"sha": "1b18ff3f94b1b1f78607115f1dd76d645009085e", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -112,19 +112,33 @@ fn req_loans_in_expr(ex: @ast::expr,\n         }\n       }\n \n-      ast::expr_field(rcvr, _, _) |\n+      ast::expr_index(rcvr, _) |\n       ast::expr_binary(_, rcvr, _) |\n       ast::expr_unary(_, rcvr) if self.bccx.method_map.contains_key(ex.id) {\n         // Receivers in method calls are always passed by ref.\n         //\n-        // FIXME--this scope is both too large and too small.  We make\n-        // the scope the enclosing block, which surely includes any\n-        // immediate call (a.b()) but which is too big.  OTOH, in the\n-        // case of a naked field `a.b`, the value is copied\n-        // anyhow. This is probably best fixed if we address the\n-        // syntactic ambiguity.\n-\n-        // let scope_r = ty::re_scope(ex.id);\n+        // Here, in an overloaded operator, the call is this expression,\n+        // and hence the scope of the borrow is this call.\n+        //\n+        // FIXME/NOT REALLY---technically we should check the other\n+        // argument and consider the argument mode.  But how annoying.\n+        // And this problem when goes away when argument modes are\n+        // phased out.  So I elect to leave this undone.\n+        let scope_r = ty::re_scope(ex.id);\n+        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n+        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n+      }\n+\n+      ast::expr_field(rcvr, _, _)\n+      if self.bccx.method_map.contains_key(ex.id) {\n+        // Receivers in method calls are always passed by ref.\n+        //\n+        // Here, the field a.b is in fact a closure.  Eventually, this\n+        // should be an fn&, but for now it's an fn@.  In any case,\n+        // the enclosing scope is either the call where it is a rcvr\n+        // (if used like `a.b(...)`), the call where it's an argument\n+        // (if used like `x(a.b)`), or the block (if used like `let x\n+        // = a.b`).\n         let scope_r = ty::re_scope(self.tcx().region_map.get(ex.id));\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);"}, {"sha": "df1f21ce7350887067d4697ba6e47a1bb898b968", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -2883,7 +2883,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n       none { trans_temp_lval(cx, e) }\n     };\n     #debug(\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n-    let lv = adapt_borrowed_value(lv, arg, e);\n+    let {lv, arg} = adapt_borrowed_value(lv, arg, e);\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n     #debug(\"   adapted value: %s\", val_str(bcx.ccx().tn, val));\n@@ -2897,6 +2897,8 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n         let mut copied = false;\n         let imm = ty::type_is_immediate(arg.ty);\n+        #debug[\"   arg.ty=%s, imm=%b, arg_mode=%?, lv.kind=%?\",\n+               ty_to_str(bcx.tcx(), arg.ty), imm, arg_mode, lv.kind];\n         if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n@@ -2953,29 +2955,29 @@ fn load_value_from_lval_result(lv: lval_result) -> ValueRef {\n     }\n }\n \n-fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n-                        e: @ast::expr) -> lval_result {\n+// when invoking a method, an argument of type @T or ~T can be implicltly\n+// converted to an argument of type &T. Similarly, [T] can be converted to\n+// [T]/& and so on.  If such a conversion (called borrowing) is necessary,\n+// then the borrowings table will have an appropriate entry inserted.  This\n+// routine consults this table and performs these adaptations.  It returns a\n+// new location for the borrowed result as well as a new type for the argument\n+// that reflects the borrowed value and not the original.\n+fn adapt_borrowed_value(lv: lval_result, arg: ty::arg,\n+                        e: @ast::expr) -> {lv: lval_result,\n+                                           arg: ty::arg} {\n     let bcx = lv.bcx;\n-    if !expr_is_borrowed(bcx, e) { ret lv; }\n+    if !expr_is_borrowed(bcx, e) {\n+        ret {lv:lv, arg:arg};\n+    }\n \n     let e_ty = expr_ty(bcx, e);\n     alt ty::get(e_ty).struct {\n-      ty::ty_box(mt) {\n+      ty::ty_uniq(mt) | ty::ty_box(mt) {\n         let box_ptr = load_value_from_lval_result(lv);\n         let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n-        ret lval_temp(bcx, body_ptr);\n-      }\n-\n-      ty::ty_uniq(_) {\n-        let box_ptr = {\n-            alt lv.kind {\n-              temporary { lv.val }\n-              owned { Load(bcx, lv.val) }\n-              owned_imm { lv.val }\n-            }\n-        };\n-        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n-        ret lval_temp(bcx, body_ptr);\n+        let rptr_ty = ty::mk_rptr(bcx.tcx(), ty::re_static, mt);\n+        ret {lv: lval_temp(bcx, body_ptr),\n+             arg: {ty: rptr_ty with arg}};\n       }\n \n       ty::ty_str | ty::ty_vec(_) |\n@@ -2999,7 +3001,16 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n \n         Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n-        ret lval_temp(bcx, p);\n+\n+        // this isn't necessarily the type that rust would assign but it's\n+        // close enough for trans purposes, as it will have the same runtime\n+        // representation\n+        let slice_ty = ty::mk_evec(bcx.tcx(),\n+                                   {ty: unit_ty, mutbl: ast::m_imm},\n+                                   ty::vstore_slice(ty::re_static));\n+\n+        ret {lv: lval_temp(bcx, p),\n+             arg: {ty: slice_ty with arg}};\n       }\n \n       _ {"}, {"sha": "f8c2f1c36ebd3074d4f471fcbb0bcf343e0b7ce0", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -515,6 +515,18 @@ impl methods for @fn_ctxt {\n         infer::can_mk_subty(self.infcx, sub, sup)\n     }\n \n+    fn mk_assignty(expr: @ast::expr, borrow_scope: ast::node_id,\n+                   sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+        infer::mk_assignty(self.infcx, anmnt, sub, sup)\n+    }\n+\n+    fn can_mk_assignty(expr: @ast::expr, borrow_scope: ast::node_id,\n+                      sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+        infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n+    }\n+\n     fn mk_eqty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx, sub, sup)\n     }\n@@ -867,12 +879,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ { none }\n         }\n     }\n-    fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n+    fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n+                        self_ex: @ast::expr, self_t: ty::t,\n                         opname: str, args: [option<@ast::expr>])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         let lkup = method::lookup({fcx: fcx,\n                                    expr: op_ex,\n+                                   self_expr: self_ex,\n+                                   borrow_scope: op_ex.id,\n                                    node_id: callee_id,\n                                    m_name: opname,\n                                    self_ty: self_t,\n@@ -950,18 +965,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n           (_, _) {\n             let (result, rhs_bot) =\n-                check_user_binop(fcx, expr, lhs_t, op, rhs);\n+                check_user_binop(fcx, expr, lhs, lhs_t, op, rhs);\n             fcx.write_ty(expr.id, result);\n             lhs_bot | rhs_bot\n           }\n         };\n     }\n-    fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr, lhs_resolved_t: ty::t,\n+    fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr,\n+                        lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n                         op: ast::binop, rhs: @ast::expr) -> (ty::t, bool) {\n         let tcx = fcx.ccx.tcx;\n         alt binop_method(op) {\n           some(name) {\n-            alt lookup_op_method(fcx, ex, lhs_resolved_t, name, [some(rhs)]) {\n+            alt lookup_op_method(fcx, ex,\n+                                 lhs_expr, lhs_resolved_t,\n+                                 name, [some(rhs)]) {\n               some(pair) { ret pair; }\n               _ {}\n             }\n@@ -977,8 +995,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         (lhs_resolved_t, false)\n     }\n     fn check_user_unop(fcx: @fn_ctxt, op_str: str, mname: str,\n-                       ex: @ast::expr, rhs_t: ty::t) -> ty::t {\n-        alt lookup_op_method(fcx, ex, rhs_t, mname, []) {\n+                       ex: @ast::expr,\n+                       rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n+        alt lookup_op_method(fcx, ex, rhs_expr, rhs_t, mname, []) {\n           some((ret_ty, _)) { ret_ty }\n           _ {\n             fcx.ccx.tcx.sess.span_err(\n@@ -1161,14 +1180,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(oper_t) ||\n                  ty::get(oper_t).struct == ty::ty_bool) {\n-                oper_t = check_user_unop(fcx, \"!\", \"!\", expr, oper_t);\n+                oper_t = check_user_unop(fcx, \"!\", \"!\", expr,\n+                                         oper, oper_t);\n             }\n           }\n           ast::neg {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(oper_t) ||\n                  ty::type_is_fp(oper_t)) {\n-                oper_t = check_user_unop(fcx, \"-\", \"unary-\", expr, oper_t);\n+                oper_t = check_user_unop(fcx, \"-\", \"unary-\", expr,\n+                                         oper, oper_t);\n             }\n           }\n         }\n@@ -1554,13 +1575,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         if !handled {\n             let tps = vec::map(tys) { |ty| fcx.to_ty(ty) };\n             let is_self_ref = self_ref(fcx, base.id);\n+\n+            // this will be the call or block that immediately\n+            // encloses the method call\n+            let borrow_scope = fcx.tcx().region_map.get(expr.id);\n+\n             let lkup = method::lookup({fcx: fcx,\n-                                      expr: expr,\n-                                      node_id: expr.id,\n-                                      m_name: field,\n-                                      self_ty: expr_t,\n-                                      supplied_tps: tps,\n-                                      include_private: is_self_ref});\n+                                       expr: expr,\n+                                       self_expr: base,\n+                                       borrow_scope: borrow_scope,\n+                                       node_id: expr.id,\n+                                       m_name: field,\n+                                       self_ty: expr_t,\n+                                       supplied_tps: tps,\n+                                       include_private: is_self_ref});\n             alt lkup.method() {\n               some(origin) {\n                 fcx.ccx.method_map.insert(id, origin);\n@@ -1591,7 +1619,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           none {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n-            alt lookup_op_method(fcx, expr, resolved, \"[]\",\n+            alt lookup_op_method(fcx, expr, base, resolved, \"[]\",\n                                  [some(idx)]) {\n               some((ret_ty, _)) { fcx.write_ty(id, ret_ty); }\n               _ {\n@@ -1611,6 +1639,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let lkup = method::lookup({fcx: fcx,\n                                    expr: p,\n+                                   self_expr: p,\n+                                   borrow_scope: expr.id,\n                                    node_id: alloc_id,\n                                    m_name: \"alloc\",\n                                    self_ty: p_ty,"}, {"sha": "d2fb60d51f2b9e6195b4db3de07c1962cd974e1d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -6,6 +6,8 @@ import middle::typeck::infer::methods; // next_ty_vars\n enum lookup = {\n     fcx: @fn_ctxt,\n     expr: @ast::expr, // expr for a.b in a.b()\n+    self_expr: @ast::expr, // a in a.b(...)\n+    borrow_scope: ast::node_id, // if we have to borrow the expr, what scope?\n     node_id: ast::node_id, // node id of call (not always expr.id)\n     m_name: ast::ident, // b in a.b(...)\n     self_ty: ty::t, // type of a in a.b(...)\n@@ -207,7 +209,9 @@ impl methods for lookup {\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n-                    alt self.fcx.can_mk_subty(self.self_ty, impl_ty) {\n+                    alt self.fcx.can_mk_assignty(\n+                        self.self_expr, self.borrow_scope,\n+                        self.self_ty, impl_ty) {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n                         results += [(impl_ty, impl_substs, m.n_tps, m.did)];\n@@ -243,12 +247,15 @@ impl methods for lookup {\n                 }\n \n                 let (impl_ty, impl_substs, n_tps, did) = results[0];\n-                alt self.fcx.mk_subty(self.self_ty, impl_ty) {\n+                alt self.fcx.mk_assignty(self.self_expr, self.borrow_scope,\n+                                         self.self_ty, impl_ty) {\n                   result::ok(_) {}\n                   result::err(_) {\n                     self.tcx().sess.span_bug(\n                         self.expr.span,\n-                        \"what was a subtype now is not?\");\n+                        #fmt[\"%s was assignable to %s but now is not?\",\n+                             self.fcx.infcx.ty_to_str(self.self_ty),\n+                             self.fcx.infcx.ty_to_str(impl_ty)]);\n                   }\n                 }\n                 let fty = self.ty_from_did(did);"}, {"sha": "2896e8875dae745a485d4853f807781c249b8aaf", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -164,13 +164,14 @@ export new_infer_ctxt;\n export mk_subty, can_mk_subty;\n export mk_subr;\n export mk_eqty;\n-export mk_assignty;\n+export mk_assignty, can_mk_assignty;\n export resolve_shallow;\n export resolve_deep;\n export resolve_deep_var;\n export methods; // for infer_ctxt\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n+export assignment;\n \n // Extra information needed to perform an assignment that may borrow.\n // The `expr_id` is the is of the expression whose type is being\n@@ -260,6 +261,21 @@ fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     } }.to_ures()\n }\n \n+fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n+                a: ty::t, b: ty::t) -> ures {\n+    #debug[\"can_mk_assignty(%? / %s <: %s)\",\n+           anmnt, a.to_str(cx), b.to_str(cx)];\n+\n+    // FIXME---this will not unroll any entries we make in the\n+    // borrowings table.  But this is OK for the moment because this\n+    // is only used in method lookup, and there must be exactly one\n+    // match or an error is reported. Still, it should be fixed.\n+\n+    indent {|| cx.probe {||\n+        cx.assign_tys(anmnt, a, b)\n+    } }.to_ures()\n+}\n+\n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n     mk_eqty(infcx, a, b)"}, {"sha": "7f45a50cbf40356a98de66c44461e3bf8cf1b8f5", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -0,0 +1,47 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+type point = { x: int, y: int };\n+\n+impl foo for point {\n+    pure fn +(z: int) -> int { self.x + self.y + z }\n+    fn *(z: int) -> int { self.x * self.y * z }\n+}\n+\n+fn a() {\n+    let mut p = {x: 3, y: 4};\n+\n+    // ok (we can loan out rcvr)\n+    p + 3;\n+    p * 3;\n+}\n+\n+fn b() {\n+    let mut p = {x: 3, y: 4};\n+\n+    // Here I create an outstanding loan and check that we get conflicts:\n+\n+    &mut p; //! NOTE prior loan as mutable granted here\n+    //!^ NOTE prior loan as mutable granted here\n+\n+    p + 3; //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    p * 3; //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+}\n+\n+fn c() {\n+    // Here the receiver is in aliased memory and hence we cannot\n+    // consider it immutable:\n+    let q = @mut {x: 3, y: 4};\n+\n+    // ...this is ok for pure fns\n+    *q + 3;\n+\n+\n+    // ...but not impure fns\n+    *q * 3; //! ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    //!^ NOTE impure due to access to impure function\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "1fba825d5aba207610ae63e2f89de9e9c4ea55fc", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -7,26 +7,31 @@ impl foo for point {\n     fn impurem() {\n     }\n \n+    fn blockm(f: fn()) { f() }\n+\n     pure fn purem() {\n     }\n }\n \n fn a() {\n     let mut p = {x: 3, y: 4};\n-    p.purem();\n-    p.impurem();\n-}\n \n-fn a2() {\n-    let mut p = {x: 3, y: 4};\n+    // Here: it's ok to call even though receiver is mutable, because we\n+    // can loan it out.\n     p.purem();\n     p.impurem();\n-    p.x = p.y;\n+\n+    // But in this case we do not honor the loan:\n+    p.blockm {||  //! NOTE loan of mutable local variable granted here\n+        p.x = 10; //! ERROR assigning to mutable field prohibited due to outstanding loan\n+    }\n }\n \n fn b() {\n     let mut p = {x: 3, y: 4};\n \n+    // Here I create an outstanding loan and check that we get conflicts:\n+\n     &mut p; //! NOTE prior loan as mutable granted here\n     //!^ NOTE prior loan as mutable granted here\n \n@@ -35,8 +40,14 @@ fn b() {\n }\n \n fn c() {\n+    // Here the receiver is in aliased memory and hence we cannot\n+    // consider it immutable:\n     let q = @mut {x: 3, y: 4};\n+\n+    // ...this is ok for pure fns\n     (*q).purem();\n+\n+    // ...but not impure fns\n     (*q).impurem(); //! ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //!^ NOTE impure due to access to impure function\n }"}, {"sha": "cb7bdeb6442b081ad402d25c65f66dd9254f7615", "filename": "src/test/compile-fail/pure-overloaded-op.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -0,0 +1,26 @@\n+type point = { x: int, y: int };\n+\n+impl foo for point {\n+    // expr_binary\n+    pure fn +(z: int) -> int { self.x + self.y + z }\n+    fn *(z: int) -> int { self.x * self.y * z }\n+\n+    // expr_index\n+    fn [](z: int) -> int { self.x * self.y * z }\n+\n+    // expr_unary\n+    fn unary-() -> int { -(self.x * self.y) }\n+}\n+\n+pure fn a(p: point) -> int { p + 3 }\n+\n+pure fn b(p: point) -> int { p * 3 }\n+//!^ ERROR access to impure function prohibited in pure context\n+\n+pure fn c(p: point) -> int { p[3] }\n+//!^ ERROR access to impure function prohibited in pure context\n+\n+pure fn d(p: point) -> int { -p }\n+//!^ ERROR access to impure function prohibited in pure context\n+\n+fn main() {}"}, {"sha": "cae6462ceb2a65a3d8fe5c532fa52f518a715794", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -0,0 +1,34 @@\n+// Note: impl on a slice\n+impl foo/& for &int {\n+    fn get() -> int {\n+        ret *self;\n+    }\n+}\n+\n+fn main() {\n+    /*\n+    let x = @mut 6;\n+    let y = x.get();\n+    assert y == 6;\n+    */\n+\n+    let x = @6;\n+    let y = x.get();\n+    #debug[\"y=%d\", y];\n+    assert y == 6;\n+\n+    let x = ~mut 6;\n+    let y = x.get();\n+    #debug[\"y=%d\", y];\n+    assert y == 6;\n+\n+    let x = ~6;\n+    let y = x.get();\n+    #debug[\"y=%d\", y];\n+    assert y == 6;\n+\n+    let x = &6;\n+    let y = x.get();\n+    #debug[\"y=%d\", y];\n+    assert y == 6;\n+}\n\\ No newline at end of file"}, {"sha": "38f9f68505006b9c9a1995da4d60c0e9a899da35", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c470d183472b357737b6d3e6c7cafc26174c91/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=77c470d183472b357737b6d3e6c7cafc26174c91", "patch": "@@ -0,0 +1,27 @@\n+// Note: impl on a slice\n+impl foo/& for [int]/& {\n+    fn sum() -> int {\n+        let mut sum = 0;\n+        for vec::each(self) { |e| sum += e; }\n+        ret sum;\n+    }\n+}\n+\n+fn call_sum(x: [int]/&) -> int { x.sum() }\n+\n+fn main() {\n+    let x = [1, 2, 3];\n+    let y = call_sum(x);\n+    #debug[\"y==%d\", y];\n+    assert y == 6;\n+\n+    let x = [mut 1, 2, 3];\n+    let y = x.sum();\n+    #debug[\"y==%d\", y];\n+    assert y == 6;\n+\n+    let x = [1, 2, 3];\n+    let y = x.sum();\n+    #debug[\"y==%d\", y];\n+    assert y == 6;\n+}\n\\ No newline at end of file"}]}