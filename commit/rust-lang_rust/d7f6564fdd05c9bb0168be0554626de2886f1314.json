{"sha": "d7f6564fdd05c9bb0168be0554626de2886f1314", "node_id": "C_kwDOAAsO6NoAKGQ3ZjY1NjRmZGQwNWM5YmIwMTY4YmUwNTU0NjI2ZGUyODg2ZjEzMTQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-03T20:08:01Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-22T11:04:52Z"}, "message": "Encode AdtDef in the def-id loop.", "tree": {"sha": "16802f00f28e8debc1cb8c812f15bf871cf425ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16802f00f28e8debc1cb8c812f15bf871cf425ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7f6564fdd05c9bb0168be0554626de2886f1314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f6564fdd05c9bb0168be0554626de2886f1314", "html_url": "https://github.com/rust-lang/rust/commit/d7f6564fdd05c9bb0168be0554626de2886f1314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7f6564fdd05c9bb0168be0554626de2886f1314/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b22aa57fd54c240131c9a31b78213de9f3bee64b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b22aa57fd54c240131c9a31b78213de9f3bee64b", "html_url": "https://github.com/rust-lang/rust/commit/b22aa57fd54c240131c9a31b78213de9f3bee64b"}], "stats": {"total": 141, "additions": 41, "deletions": 100}, "files": [{"sha": "772c99a07bc359268e1b16848c0cfa3d422555eb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 41, "deletions": 100, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d7f6564fdd05c9bb0168be0554626de2886f1314/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f6564fdd05c9bb0168be0554626de2886f1314/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d7f6564fdd05c9bb0168be0554626de2886f1314", "patch": "@@ -38,7 +38,6 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_target::abi::VariantIdx;\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -1178,8 +1177,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n-                let params_in_repr = self.tcx.params_in_repr(def_id);\n-                record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+                self.encode_info_for_adt(def_id);\n             }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n@@ -1199,9 +1197,38 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn encode_info_for_adt(&mut self, def_id: DefId) {\n+        let tcx = self.tcx;\n+        let adt_def = tcx.adt_def(def_id);\n+        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+\n+        let params_in_repr = self.tcx.params_in_repr(def_id);\n+        record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+\n+        if adt_def.is_enum() {\n+            record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                for variant in tcx.adt_def(def_id).variants() {\n+                    yield variant.def_id.index;\n+                    // Encode constructors which take a separate slot in value namespace.\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        yield ctor_def_id.index;\n+                    }\n+                }\n+            ));\n+        }\n+\n+        // In some cases, along with the item itself, we also\n+        // encode some sub-items. Usually we want some info from the item\n+        // so it's easier to do that here then to wait until we would encounter\n+        // normally in the visitor walk.\n+        for variant in adt_def.variants().iter() {\n+            self.encode_enum_variant_info(variant);\n+        }\n+    }\n+\n+    fn encode_enum_variant_info(&mut self, variant: &ty::VariantDef) {\n         let tcx = self.tcx;\n-        let variant = &def.variant(index);\n         let def_id = variant.def_id;\n         debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n \n@@ -1218,27 +1245,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             f.did.index\n         }));\n         if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n-        }\n-    }\n-\n-    fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n-        let variant = &def.variant(index);\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n+            debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", ctor_def_id);\n \n-        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+            self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n+            let fn_sig = tcx.fn_sig(ctor_def_id);\n+            record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n+            // FIXME(eddyb) encode signature only for `ctor_def_id`.\n+            record!(self.tables.fn_sig[def_id] <- fn_sig);\n         }\n     }\n \n@@ -1291,25 +1305,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        let variant = adt_def.non_enum_variant();\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n-\n-        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n-        }\n-    }\n-\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n@@ -1518,33 +1513,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     self.tables.is_type_alias_impl_trait.set(def_id.index, ());\n                 }\n             }\n-            hir::ItemKind::Enum(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                self.tables.constness.set(def_id.index, hir::Constness::Const);\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n@@ -1583,31 +1551,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n-                    for variant in tcx.adt_def(def_id).variants() {\n-                        yield variant.def_id.index;\n-                        // Encode constructors which take a separate slot in value namespace.\n-                        if let Some(ctor_def_id) = variant.ctor_def_id() {\n-                            yield ctor_def_id.index;\n-                        }\n-                    }\n-                ))\n-            }\n-            hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record_array!(self.tables.children[def_id] <-\n-                    self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    })\n-                )\n-            }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record_array!(self.tables.children[def_id] <-\n@@ -1635,17 +1587,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // so it's easier to do that here then to wait until we would encounter\n         // normally in the visitor walk.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                for (i, _) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-                    self.encode_enum_variant_ctor(def, i);\n-                }\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                self.encode_struct_ctor(def);\n-            }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n                     self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()"}]}