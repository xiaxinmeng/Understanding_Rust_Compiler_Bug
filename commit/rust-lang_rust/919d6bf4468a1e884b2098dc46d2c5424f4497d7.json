{"sha": "919d6bf4468a1e884b2098dc46d2c5424f4497d7", "node_id": "C_kwDOAAsO6NoAKDkxOWQ2YmY0NDY4YTFlODg0YjIwOThkYzQ2ZDJjNTQyNGY0NDk3ZDc", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-10-11T09:37:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-11T09:37:54Z"}, "message": "Rollup merge of #102589 - RalfJung:scoped-threads-dangling, r=m-ou-se\n\nscoped threads: pass closure through MaybeUninit to avoid invalid dangling references\n\nThe `main` function defined here looks roughly like this, if it were written as a more explicit stand-alone function:\n```rust\n// Not showing all the `'lifetime` tracking, the point is that\n// this closure might live shorter than `thread`.\nfn thread(control: ..., closure: impl FnOnce() + 'lifetime) {\n    closure();\n    control.signal_done();\n    // A lot of time can pass here.\n}\n```\nNote that `thread` continues to run even after `signal_done`! Now consider what happens if the `closure` captures a reference of lifetime `'lifetime`:\n- The type of `closure` is a struct (the implicit unnameable closure type) with a `&'lifetime mut T` field. References passed to a function are marked with `dereferenceable`, which is LLVM speak for *this reference will remain live for the entire duration of this function*.\n- The closure runs, `signal_done` runs. Then -- potentially -- this thread gets scheduled away and the main thread runs, seeing the signal and returning to the user. Now `'lifetime` ends and the memory the reference points to might be deallocated.\n- Now we have UB! The reference that as passed to `thread` with the promise of remaining live for the entire duration of the function, actually got deallocated while the function still runs. Oops.\n\nLong-term I think we should be able to use `ManuallyDrop` to fix this without `unsafe`, or maybe a new `MaybeDangling` type. I am working on an RFC for that. But in the mean time it'd be nice to fix this so that Miri with `-Zmiri-retag-fields` (which is needed for \"full enforcement\" of all the LLVM flags we generate) stops erroring on scoped threads.\n\nFixes https://github.com/rust-lang/rust/issues/101983\nr? `@m-ou-se`", "tree": {"sha": "6a125ac351c7851bcfa0caacda0b0a12d9420ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a125ac351c7851bcfa0caacda0b0a12d9420ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/919d6bf4468a1e884b2098dc46d2c5424f4497d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRTlyCRBK7hj4Ov3rIwAAgLQIAIYITNy8ldLkE6/wi/BXOXUJ\nTedPNnYscNPor2fYbbMo7hg/dRIB9KpKGKTyqx/NrBxOjaLQ8FCwP7FJ5QQjeZLM\nNsrQOxZ9Hn7juQxFa+EFydZntHWljGddi4LZ/62BOfopaR4Y1ZETCmrsYxHKW6+g\nsXuEuuutAIdg1g/MLH6bpV2EA2M2ZivNsWr5GYCAQMA5qZhVT4692kp2yG1P6bSt\nOEedrd54RALdhKkqeOD1Tjr03sXq4otB5B5I79NsO4Jje9uNKlxZ5UksRQHyDwae\nJAoILiifqbk/CsWK8V36/IrhKqhfjtOzI3rJeOHmmqIXox3qBTJVQwH4/+qhTbk=\n=4wuW\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a125ac351c7851bcfa0caacda0b0a12d9420ac2\nparent e0954cadc8a407bed951ff8d956b76236b7dd97c\nparent 78b577c065f71c7ad30a70c8c65c7ff561fee852\nauthor Yuki Okushi <jtitor@2k36.org> 1665481074 +0900\ncommitter GitHub <noreply@github.com> 1665481074 +0900\n\nRollup merge of #102589 - RalfJung:scoped-threads-dangling, r=m-ou-se\n\nscoped threads: pass closure through MaybeUninit to avoid invalid dangling references\n\nThe `main` function defined here looks roughly like this, if it were written as a more explicit stand-alone function:\n```rust\n// Not showing all the `'lifetime` tracking, the point is that\n// this closure might live shorter than `thread`.\nfn thread(control: ..., closure: impl FnOnce() + 'lifetime) {\n    closure();\n    control.signal_done();\n    // A lot of time can pass here.\n}\n```\nNote that `thread` continues to run even after `signal_done`! Now consider what happens if the `closure` captures a reference of lifetime `'lifetime`:\n- The type of `closure` is a struct (the implicit unnameable closure type) with a `&'lifetime mut T` field. References passed to a function are marked with `dereferenceable`, which is LLVM speak for *this reference will remain live for the entire duration of this function*.\n- The closure runs, `signal_done` runs. Then -- potentially -- this thread gets scheduled away and the main thread runs, seeing the signal and returning to the user. Now `'lifetime` ends and the memory the reference points to might be deallocated.\n- Now we have UB! The reference that as passed to `thread` with the promise of remaining live for the entire duration of the function, actually got deallocated while the function still runs. Oops.\n\nLong-term I think we should be able to use `ManuallyDrop` to fix this without `unsafe`, or maybe a new `MaybeDangling` type. I am working on an RFC for that. But in the mean time it'd be nice to fix this so that Miri with `-Zmiri-retag-fields` (which is needed for \"full enforcement\" of all the LLVM flags we generate) stops erroring on scoped threads.\n\nFixes https://github.com/rust-lang/rust/issues/101983\nr? `@m-ou-se`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/919d6bf4468a1e884b2098dc46d2c5424f4497d7", "html_url": "https://github.com/rust-lang/rust/commit/919d6bf4468a1e884b2098dc46d2c5424f4497d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/919d6bf4468a1e884b2098dc46d2c5424f4497d7/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0954cadc8a407bed951ff8d956b76236b7dd97c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0954cadc8a407bed951ff8d956b76236b7dd97c", "html_url": "https://github.com/rust-lang/rust/commit/e0954cadc8a407bed951ff8d956b76236b7dd97c"}, {"sha": "78b577c065f71c7ad30a70c8c65c7ff561fee852", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b577c065f71c7ad30a70c8c65c7ff561fee852", "html_url": "https://github.com/rust-lang/rust/commit/78b577c065f71c7ad30a70c8c65c7ff561fee852"}], "stats": {"total": 33, "additions": 33, "deletions": 0}, "files": [{"sha": "55110c44b6e98da742227bf25a6148f3ee7a2e20", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/919d6bf4468a1e884b2098dc46d2c5424f4497d7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919d6bf4468a1e884b2098dc46d2c5424f4497d7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=919d6bf4468a1e884b2098dc46d2c5424f4497d7", "patch": "@@ -499,13 +499,40 @@ impl Builder {\n         let output_capture = crate::io::set_output_capture(None);\n         crate::io::set_output_capture(output_capture.clone());\n \n+        // Pass `f` in `MaybeUninit` because actually that closure might *run longer than the lifetime of `F`*.\n+        // See <https://github.com/rust-lang/rust/issues/101983> for more details.\n+        // To prevent leaks we use a wrapper that drops its contents.\n+        #[repr(transparent)]\n+        struct MaybeDangling<T>(mem::MaybeUninit<T>);\n+        impl<T> MaybeDangling<T> {\n+            fn new(x: T) -> Self {\n+                MaybeDangling(mem::MaybeUninit::new(x))\n+            }\n+            fn into_inner(self) -> T {\n+                // SAFETY: we are always initiailized.\n+                let ret = unsafe { self.0.assume_init_read() };\n+                // Make sure we don't drop.\n+                mem::forget(self);\n+                ret\n+            }\n+        }\n+        impl<T> Drop for MaybeDangling<T> {\n+            fn drop(&mut self) {\n+                // SAFETY: we are always initiailized.\n+                unsafe { self.0.assume_init_drop() };\n+            }\n+        }\n+\n+        let f = MaybeDangling::new(f);\n         let main = move || {\n             if let Some(name) = their_thread.cname() {\n                 imp::Thread::set_name(name);\n             }\n \n             crate::io::set_output_capture(output_capture);\n \n+            // SAFETY: we constructed `f` initialized.\n+            let f = f.into_inner();\n             // SAFETY: the stack guard passed is the one for the current thread.\n             // This means the current thread's stack and the new thread's stack\n             // are properly set and protected from each other.\n@@ -518,6 +545,12 @@ impl Builder {\n             // same `JoinInner` as this closure meaning the mutation will be\n             // safe (not modify it and affect a value far away).\n             unsafe { *their_packet.result.get() = Some(try_result) };\n+            // Here `their_packet` gets dropped, and if this is the last `Arc` for that packet that\n+            // will call `decrement_num_running_threads` and therefore signal that this thread is\n+            // done.\n+            drop(their_packet);\n+            // Here, the lifetime `'a` and even `'scope` can end. `main` keeps running for a bit\n+            // after that before returning itself.\n         };\n \n         if let Some(scope_data) = &my_packet.scope {"}]}