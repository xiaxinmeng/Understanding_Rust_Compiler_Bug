{"sha": "f85bd249c0aec8df978aa1a87b3689a39d0231e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NWJkMjQ5YzBhZWM4ZGY5NzhhYTFhODdiMzY4OWEzOWQwMjMxZTk=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-02-16T07:27:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-16T07:27:42Z"}, "message": "Merge pull request #72 from rust-lang/feature/proptest\n\nproptest\r\nThis replaces most tests with proptest, and makes it easier to define tests generically over lane count.  This should provide much broader API coverage and give us more confidence in our implementation.", "tree": {"sha": "bf72a0461c5480ba0bdef26eca68b2ff7039dfe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf72a0461c5480ba0bdef26eca68b2ff7039dfe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f85bd249c0aec8df978aa1a87b3689a39d0231e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgK3PuCRBK7hj4Ov3rIwAAdHIIAITXoz1pOALO3nXlRcIYbA1h\n4mAq8RBaIY8zcy+81sG8d4pCUNaGX3+PU8Jn+YFOQglqo3F4TfJIKi4SXKUlNnfn\nn0Wh5vUybgJ581aT+Jf976iJfT1+oEU4JxyjDDafgmAETN02lU3NAvzAuwqY9EQK\nLSSEM2rhy1OPikD3vNq7EPX7XdMeGIZJgK1y2Pa8luD0Rs2SLFqx7oIE3Z/1yH1B\nE3SKiCqVN6y5fPvqMYmcZzcX3a/+husApYXC1davrbsREHyU16L9a1g0mHikf+qC\ncXZT6wrQD+Sx8eaNS5OyXVrYEyLz+SZo0nqrD8U06XJFAAaOWwrYOhZQ2OIRjY0=\n=v0XY\n-----END PGP SIGNATURE-----\n", "payload": "tree bf72a0461c5480ba0bdef26eca68b2ff7039dfe3\nparent d3c58daa9617bcb92798b672d56e556bb0f37faf\nparent 2b3f4b258ce59285d8cd556ac8803eefd716ba49\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1613460462 -0800\ncommitter GitHub <noreply@github.com> 1613460462 -0800\n\nMerge pull request #72 from rust-lang/feature/proptest\n\nproptest\r\nThis replaces most tests with proptest, and makes it easier to define tests generically over lane count.  This should provide much broader API coverage and give us more confidence in our implementation."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f85bd249c0aec8df978aa1a87b3689a39d0231e9", "html_url": "https://github.com/rust-lang/rust/commit/f85bd249c0aec8df978aa1a87b3689a39d0231e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f85bd249c0aec8df978aa1a87b3689a39d0231e9/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c58daa9617bcb92798b672d56e556bb0f37faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c58daa9617bcb92798b672d56e556bb0f37faf", "html_url": "https://github.com/rust-lang/rust/commit/d3c58daa9617bcb92798b672d56e556bb0f37faf"}, {"sha": "2b3f4b258ce59285d8cd556ac8803eefd716ba49", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3f4b258ce59285d8cd556ac8803eefd716ba49", "html_url": "https://github.com/rust-lang/rust/commit/2b3f4b258ce59285d8cd556ac8803eefd716ba49"}], "stats": {"total": 2681, "additions": 1042, "deletions": 1639}, "files": [{"sha": "a06fa62d50fd70a72093ac3adc14dc8989e2bce4", "filename": ".travis.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -1,3 +1,7 @@\n+branches:\n+  only:\n+    - master\n+\n language: rust\n rust:\n   - nightly"}, {"sha": "3f1abd73519bdd1bb02bf43787019bdb8b6c427c", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -2,4 +2,5 @@\n \n members = [\n     \"crates/core_simd\",\n+    \"crates/test_helpers\",\n ]"}, {"sha": "d76bd547cde68ac22ef4ea73a7021f5e0ae29e55", "filename": "crates/core_simd/Cargo.toml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2FCargo.toml?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -14,3 +14,11 @@ version = \"0.2\"\n \n [dev-dependencies.wasm-bindgen-test]\n version = \"0.3\"\n+\n+[dev-dependencies.proptest]\n+version = \"0.10\"\n+default-features = false\n+features = [\"alloc\"]\n+\n+[dev-dependencies.test_helpers]\n+path = \"../test_helpers\""}, {"sha": "db90c4e3149bf017ea170665b03dbbba7ba5348b", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -141,6 +141,12 @@ macro_rules! impl_vector {\n             }\n         }\n \n+        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where $name<LANES>: crate::LanesAtMost64 {\n+            fn from(vector: $name<LANES>) -> Self {\n+                vector.to_array()\n+            }\n+        }\n+\n         // splat\n         impl<const LANES: usize> From<$type> for $name<LANES> where Self: crate::LanesAtMost64 {\n             #[inline]"}, {"sha": "ac5499b7ffeb5661d0c62409a0e177024fbd3bbd", "filename": "crates/core_simd/tests/f32_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_float_tests! { SimdF32, f32, i32 }"}, {"sha": "dcdb2aa31522deeb8df8c0950d00b56954cf47f8", "filename": "crates/core_simd/tests/f64_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_float_tests! { SimdF64, f64, i64 }"}, {"sha": "9da2bdfce42e90b9eb3dcb38bb104c043935259c", "filename": "crates/core_simd/tests/helpers/biteq.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,120 +0,0 @@\n-pub(crate) trait BitEq {\n-    fn biteq(&self, other: &Self) -> bool;\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n-}\n-\n-macro_rules! impl_biteq {\n-    { integer impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                self == other\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                write!(f, \"{:?} ({:x})\", self, self)\n-            }\n-        }\n-        )*\n-    };\n-    { float impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                self.to_bits() == other.to_bits()\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n-            }\n-        }\n-        )*\n-    };\n-    { vector impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                let a: &[_] = self.as_ref();\n-                let b: &[_] = other.as_ref();\n-                if a.len() == b.len() {\n-                    a.iter().zip(b.iter()).fold(true, |value, (left, right)| {\n-                        value && left.biteq(right)\n-                    })\n-                } else {\n-                    false\n-                }\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                #[repr(transparent)]\n-                struct Wrapper<'a, T: BitEq>(&'a T);\n-\n-                impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        self.0.fmt(f)\n-                    }\n-                }\n-\n-                let slice: &[_] = self.as_ref();\n-\n-                f.debug_list()\n-                    .entries(slice.iter().map(|x| Wrapper(x)))\n-                    .finish()\n-            }\n-        }\n-        )*\n-    };\n-}\n-\n-impl_biteq! {\n-    integer impl BitEq for\n-        u8, u16, u32, u64, u128, usize,\n-        i8, i16, i32, i64, i128, isize,\n-}\n-\n-impl_biteq! {\n-    float impl BitEq for f32, f64,\n-}\n-\n-impl_biteq! {\n-    vector impl BitEq for\n-        core_simd::u8x8,    core_simd::u8x16,   core_simd::u8x32,   core_simd::u8x64,\n-        core_simd::i8x8,    core_simd::i8x16,   core_simd::i8x32,   core_simd::i8x64,\n-        core_simd::u16x4,   core_simd::u16x8,   core_simd::u16x16,  core_simd::u16x32,\n-        core_simd::i16x4,   core_simd::i16x8,   core_simd::i16x16,  core_simd::i16x32,\n-        core_simd::u32x2,   core_simd::u32x4,   core_simd::u32x8,   core_simd::u32x16,\n-        core_simd::i32x2,   core_simd::i32x4,   core_simd::i32x8,   core_simd::i32x16,\n-        core_simd::u64x2,   core_simd::u64x4,   core_simd::u64x8,\n-        core_simd::i64x2,   core_simd::i64x4,   core_simd::i64x8,\n-        core_simd::u128x2,  core_simd::u128x4,\n-        core_simd::i128x2,  core_simd::i128x4,\n-        core_simd::usizex2, core_simd::usizex4, core_simd::usizex8,\n-        core_simd::isizex2, core_simd::isizex4, core_simd::isizex8,\n-        core_simd::f32x2, core_simd::f32x4, core_simd::f32x8, core_simd::f32x16,\n-        core_simd::f64x2, core_simd::f64x4, core_simd::f64x8,\n-}\n-\n-pub(crate) struct BitEqWrapper<'a, T>(pub(crate) &'a T);\n-\n-impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.biteq(other.0)\n-    }\n-}\n-\n-impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-macro_rules! assert_biteq {\n-    { $a:expr, $b:expr } => {\n-        {\n-            use helpers::biteq::BitEqWrapper;\n-            let a = $a;\n-            let b = $b;\n-            assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n-        }\n-    }\n-}"}, {"sha": "3a9f479680804151180ec6327f477737e49d19dd", "filename": "crates/core_simd/tests/helpers/lanewise.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,61 +0,0 @@\n-//! These helpers provide a way to easily emulate a vectorized SIMD op on two SIMD vectors,\n-//! except using scalar ops that iterate through each lane, one at a time, so as to remove\n-//! the vagaries of compilation.\n-//!\n-//! Do note, however, that when testing that vectorized operations #[should_panic], these\n-//! \"scalarized SIMD ops\" will trigger scalar code paths that may also normally panic.\n-\n-pub fn apply_unary_lanewise<T1: Copy, T2: Copy, V1: AsRef<[T1]>, V2: AsMut<[T2]> + Default>(\n-    x: V1,\n-    f: impl Fn(T1) -> T2,\n-) -> V2 {\n-    let mut y = V2::default();\n-    assert_eq!(x.as_ref().len(), y.as_mut().len());\n-    for (x, y) in x.as_ref().iter().zip(y.as_mut().iter_mut()) {\n-        *y = f(*x);\n-    }\n-    y\n-}\n-\n-pub fn apply_binary_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n-    a: V,\n-    b: V,\n-    f: impl Fn(T, T) -> T,\n-) -> V {\n-    let mut out = V::default();\n-    let out_slice = out.as_mut();\n-    let a_slice = a.as_ref();\n-    let b_slice = b.as_ref();\n-    for (o, (a, b)) in out_slice.iter_mut().zip(a_slice.iter().zip(b_slice.iter())) {\n-        *o = f(*a, *b);\n-    }\n-    out\n-}\n-\n-pub fn apply_binary_scalar_rhs_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n-    a: V,\n-    b: T,\n-    f: impl Fn(T, T) -> T,\n-) -> V {\n-    let mut out = V::default();\n-    let out_slice = out.as_mut();\n-    let a_slice = a.as_ref();\n-    for (o, a) in out_slice.iter_mut().zip(a_slice.iter()) {\n-        *o = f(*a, b);\n-    }\n-    out\n-}\n-\n-pub fn apply_binary_scalar_lhs_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>(\n-    a: T,\n-    b: V,\n-    f: impl Fn(T, T) -> T,\n-) -> V {\n-    let mut out = V::default();\n-    let out_slice = out.as_mut();\n-    let b_slice = b.as_ref();\n-    for (o, b) in out_slice.iter_mut().zip(b_slice.iter()) {\n-        *o = f(a, *b);\n-    }\n-    out\n-}"}, {"sha": "b128f8251ca3202a6534e98569c48960caf2c75b", "filename": "crates/core_simd/tests/helpers/mod.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,4 +0,0 @@\n-#[macro_use]\n-pub mod biteq;\n-\n-pub mod lanewise;"}, {"sha": "3e3fa1d20682babba77f9798e009e80d6e1ebf40", "filename": "crates/core_simd/tests/i128_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi128_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi128_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi128_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdI128, i128 }"}, {"sha": "4d2a7b053b5c5c5a9f80c58028529054c950205e", "filename": "crates/core_simd/tests/i16_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdI16, i16 }"}, {"sha": "90079d727e4bd106433d554d170d070afc2d6922", "filename": "crates/core_simd/tests/i32_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdI32, i32 }"}, {"sha": "ebc3e194974b331ea7f196acdaa97b5df32aefd3", "filename": "crates/core_simd/tests/i64_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdI64, i64 }"}, {"sha": "082422b86d2900803fb6cb8cd76f474c90cddf5f", "filename": "crates/core_simd/tests/i8_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdI8, i8 }"}, {"sha": "1509d701c29a337eec8b62ba27a2b7473b962c81", "filename": "crates/core_simd/tests/isize_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { SimdIsize, isize }"}, {"sha": "96330550b40b268e35c9ed7cea2287cace0537fe", "filename": "crates/core_simd/tests/mask_ops.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1 @@\n+mod mask_ops_impl;"}, {"sha": "27ba4e2d29fe683b1cc3db9cfb03efe52c3446be", "filename": "crates/core_simd/tests/mask_ops_impl/mask128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask128.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask128.rs"}, {"sha": "0fe82fa680479a457a7e37852a2d5f0fed94e7bc", "filename": "crates/core_simd/tests/mask_ops_impl/mask16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask16.rs"}, {"sha": "66d987a43ce83c295a96e014c3fce7e839ee435a", "filename": "crates/core_simd/tests/mask_ops_impl/mask32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask32.rs"}, {"sha": "a1f1f67b23887641de455b53796d1e323e038c8b", "filename": "crates/core_simd/tests/mask_ops_impl/mask64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask64.rs"}, {"sha": "218fa9fe895e5a9706790ab25f94290a744c82b6", "filename": "crates/core_simd/tests/mask_ops_impl/mask8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask8.rs"}, {"sha": "795f9e27c4458fa1dcefeb5e23ece1f66d4d859e", "filename": "crates/core_simd/tests/mask_ops_impl/mask_macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/mask_macros.rs"}, {"sha": "e0a44d870ca56b9bdd2e73085e6f9e59e3ac14c1", "filename": "crates/core_simd/tests/mask_ops_impl/masksize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "previous_filename": "crates/core_simd/tests/ops_impl/masksize.rs"}, {"sha": "99d735be29356d718370be1f8aba14c549a33865", "filename": "crates/core_simd/tests/mask_ops_impl/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,9 @@\n+#[macro_use]\n+mod mask_macros;\n+\n+mod mask8;\n+mod mask16;\n+mod mask32;\n+mod mask64;\n+mod mask128;\n+mod masksize;"}, {"sha": "60aff06a76a65739f4848501754f543c8062672f", "filename": "crates/core_simd/tests/ops.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1 +0,0 @@\n-mod ops_impl;"}, {"sha": "1472822fe1fe559f935b5b1381c6ff0999d6ad2b", "filename": "crates/core_simd/tests/ops_impl/f32.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-float_tests! { f32x2, f32, i32x2, i32 }\n-float_tests! { f32x4, f32, i32x4, i32 }\n-float_tests! { f32x8, f32, i32x8, i32 }\n-float_tests! { f32x16, f32, i32x16, i32 }"}, {"sha": "8f573baa1ad222a20fe7a35ff7c13a6135750112", "filename": "crates/core_simd/tests/ops_impl/f64.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-float_tests! { f64x2, f64, i64x2, i64 }\n-float_tests! { f64x4, f64, i64x4, i64 }\n-float_tests! { f64x8, f64, i64x8, i64 }"}, {"sha": "fe347a5362daf85053e4f2d563390b9a92d15a94", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,418 +0,0 @@\n-macro_rules! float_tests {\n-    { $vector:ident, $scalar:ident, $int_vector:ident, $int_scalar:ident } => {\n-        #[cfg(test)]\n-        mod $vector {\n-            use super::*;\n-            use helpers::lanewise::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            use wasm_bindgen_test::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            wasm_bindgen_test_configure!(run_in_browser);\n-\n-            // TODO impl this as an associated fn on vectors\n-            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n-                let mut value = core_simd::$vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            fn slice_chunks(slice: &[$scalar]) -> impl Iterator<Item = core_simd::$vector> + '_ {\n-                let lanes = core::mem::size_of::<core_simd::$vector>() / core::mem::size_of::<$scalar>();\n-                slice.chunks_exact(lanes).map(from_slice)\n-            }\n-\n-            fn from_slice_int(slice: &[$int_scalar]) -> core_simd::$int_vector {\n-                let mut value = core_simd::$int_vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            fn slice_chunks_int(slice: &[$int_scalar]) -> impl Iterator<Item = core_simd::$int_vector> + '_ {\n-                let lanes = core::mem::size_of::<core_simd::$int_vector>() / core::mem::size_of::<$int_scalar>();\n-                slice.chunks_exact(lanes).map(from_slice_int)\n-            }\n-\n-            const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n-            const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n-            const C: [$scalar; 16] = [\n-                -0.0,\n-                0.0,\n-                -1.0,\n-                1.0,\n-                <$scalar>::MIN,\n-                <$scalar>::MAX,\n-                <$scalar>::INFINITY,\n-                <$scalar>::NEG_INFINITY,\n-                <$scalar>::MIN_POSITIVE,\n-                -<$scalar>::MIN_POSITIVE,\n-                <$scalar>::EPSILON,\n-                -<$scalar>::EPSILON,\n-                <$scalar>::NAN,\n-                -<$scalar>::NAN,\n-                // TODO: Would be nice to check sNaN...\n-                100.0 / 3.0,\n-                -100.0 / 3.0,\n-            ];\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn neg() {\n-                let v = from_slice(&A);\n-                let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n-                assert_biteq!(-v, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn neg_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n-                    assert_biteq!(-v, expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_negative() {\n-                let v = -from_slice(&A);\n-                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                assert_biteq!(v.abs(), expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_positive() {\n-                let v = from_slice(&B);\n-                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                assert_biteq!(v.abs(), expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                    assert_biteq!(v.abs(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn ceil_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::ceil);\n-                    assert_biteq!(v.ceil(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn floor_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::floor);\n-                    assert_biteq!(v.floor(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn to_int_unchecked() {\n-                // The maximum integer that can be represented by the equivalently sized float has\n-                // all of the mantissa digits set to 1, pushed up to the MSB.\n-                const ALL_MANTISSA_BITS: $int_scalar = ((1 << <$scalar>::MANTISSA_DIGITS) - 1);\n-                const MAX_REPRESENTABLE_VALUE: $int_scalar =\n-                    ALL_MANTISSA_BITS << (core::mem::size_of::<$scalar>() * 8 - <$scalar>::MANTISSA_DIGITS as usize - 1);\n-                const VALUES: [$scalar; 16] = [\n-                    -0.0,\n-                    0.0,\n-                    -1.0,\n-                    1.0,\n-                    ALL_MANTISSA_BITS as $scalar,\n-                    -ALL_MANTISSA_BITS as $scalar,\n-                    MAX_REPRESENTABLE_VALUE as $scalar,\n-                    -MAX_REPRESENTABLE_VALUE as $scalar,\n-                    (MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n-                    (-MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n-                    <$scalar>::MIN_POSITIVE,\n-                    -<$scalar>::MIN_POSITIVE,\n-                    <$scalar>::EPSILON,\n-                    -<$scalar>::EPSILON,\n-                    100.0 / 3.0,\n-                    -100.0 / 3.0,\n-                ];\n-\n-                for v in slice_chunks(&VALUES) {\n-                    let expected = apply_unary_lanewise(v, |x| unsafe { x.to_int_unchecked() });\n-                    assert_biteq!(unsafe { v.to_int_unchecked() }, expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn round_from_int() {\n-                const VALUES: [$int_scalar; 16] = [\n-                    0,\n-                    0,\n-                    1,\n-                    -1,\n-                    100,\n-                    -100,\n-                    200,\n-                    -200,\n-                    413,\n-                    -413,\n-                    1017,\n-                    -1017,\n-                    1234567,\n-                    -1234567,\n-                    <$int_scalar>::MAX,\n-                    <$int_scalar>::MIN,\n-                ];\n-\n-                for v in slice_chunks_int(&VALUES) {\n-                    let expected = apply_unary_lanewise(v, |x| x as $scalar);\n-                    assert_biteq!(core_simd::$vector::round_from_int(v), expected);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "8a0a279b8dce2e7f538f19c58911ef891104b3b3", "filename": "crates/core_simd/tests/ops_impl/i128.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi128.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,4 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { i128x2, i128 }\n-int_tests! { i128x4, i128 }"}, {"sha": "445436b77a8935dadf8b2b5ec9e33deae7d245c9", "filename": "crates/core_simd/tests/ops_impl/i16.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi16.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { i16x4, i16 }\n-int_tests! { i16x8, i16 }\n-int_tests! { i16x16, i16 }\n-int_tests! { i16x32, i16 }"}, {"sha": "f13ab833a33591027c9b6dce5dec07e07e624d62", "filename": "crates/core_simd/tests/ops_impl/i32.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi32.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { i32x2, i32 }\n-int_tests! { i32x4, i32 }\n-int_tests! { i32x8, i32 }\n-int_tests! { i32x16, i32 }"}, {"sha": "08479c4b994b34278a7fc85bc0989ab97daedb63", "filename": "crates/core_simd/tests/ops_impl/i64.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi64.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { i64x2, i64 }\n-int_tests! { i64x4, i64 }\n-int_tests! { i64x8, i64 }"}, {"sha": "2a7db7906ac1ef02f235b01cdc19fb8d997aacf6", "filename": "crates/core_simd/tests/ops_impl/i8.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fi8.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { i8x8, i8 }\n-int_tests! { i8x16, i8 }\n-int_tests! { i8x32, i8 }\n-int_tests! { i8x64, i8 }"}, {"sha": "43c75c6a9c4940af174c1457014456313c63903f", "filename": "crates/core_simd/tests/ops_impl/int_macros.rs", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,493 +0,0 @@\n-macro_rules! int_tests {\n-    { $vector:ident, $scalar:ident } => {\n-        #[cfg(test)]\n-        mod $vector {\n-            use super::*;\n-            use helpers::lanewise::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            use wasm_bindgen_test::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            wasm_bindgen_test_configure!(run_in_browser);\n-\n-            // TODO impl this as an associated fn on vectors\n-            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n-                let mut value = core_simd::$vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            const A: [$scalar; 64] = [\n-                7, 7, 7, 7, -7, -7, -7, -7,\n-                6, 6, 6, 6, -6, -6, -6, -6,\n-                5, 5, 5, 5, -5, -5, -5, -5,\n-                4, 4, 4, 4, -4, -4, -4, -4,\n-                3, 3, 3, 3, -3, -3, -3, -3,\n-                2, 2, 2, 2, -2, -2, -2, -2,\n-                1, 1, 1, 1, -1, -1, -1, -1,\n-                0, 0, 0, 0,  0,  0,  0,  0,\n-            ];\n-            const B: [$scalar; 64] = [\n-                 1,  2,  3,  4,  5,  6,  7,  8,\n-                 1,  2,  3,  4,  5,  6,  7,  8,\n-                 1,  2,  3,  4,  5,  6,  7,  8,\n-                 1,  2,  3,  4,  5,  6,  7,  8,\n-                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n-                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n-                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n-                 -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,\n-            ];\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[should_panic]\n-            fn div_min_panics() {\n-                let a = from_slice(&vec![$scalar::MIN; 64]);\n-                let b = from_slice(&vec![-1; 64]);\n-                let _ = a / b;\n-            }\n-\n-            #[test]\n-            #[should_panic]\n-            fn div_by_all_zeros_panics() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&vec![0 ; 64]);\n-                let _ = a / b;\n-            }\n-\n-            #[test]\n-            #[should_panic]\n-            fn div_by_one_zero_panics() {\n-                let a = from_slice(&A);\n-                let mut b = from_slice(&B);\n-                b[0] = 0 as _;\n-                let _ = a / b;\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_min_neg_one_no_panic() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&vec![-1; 64]);\n-                let _ = a / b;\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_min_neg_one_no_panic() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&vec![-1; 64]);\n-                let _ = a % b;\n-            }\n-\n-            #[test]\n-            #[should_panic]\n-            fn rem_min_panic() {\n-                let a = from_slice(&vec![$scalar::MIN; 64]);\n-                let b = from_slice(&vec![-1 ; 64]);\n-                let _ = a % b;\n-            }\n-\n-            #[test]\n-            #[should_panic]\n-            fn rem_min_zero_panic() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&vec![0 ; 64]);\n-                let _ = a % b;\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n-                a &= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                a &= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n-                a |= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                a |= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n-                a ^= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                a ^= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn neg() {\n-                let v = from_slice(&A);\n-                let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n-                assert_biteq!(-v, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn not() {\n-                let v = from_slice(&A);\n-                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n-                assert_biteq!(!v, expected);\n-            }\n-        }\n-    }\n-}"}, {"sha": "9943e9c357a458d9de84c71a5f259c4dc0480ee2", "filename": "crates/core_simd/tests/ops_impl/isize.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fisize.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-int_tests! { isizex2, isize }\n-int_tests! { isizex4, isize }\n-int_tests! { isizex8, isize }"}, {"sha": "814f2d04b59c315751b9f3a5c8deea391d51268a", "filename": "crates/core_simd/tests/ops_impl/mod.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,39 +0,0 @@\n-#[macro_use]\n-#[path = \"../helpers/mod.rs\"]\n-mod helpers;\n-\n-#[macro_use]\n-mod float_macros;\n-\n-mod r#f32;\n-mod r#f64;\n-\n-#[macro_use]\n-mod int_macros;\n-\n-mod r#i8;\n-mod r#i16;\n-mod r#i32;\n-mod r#i64;\n-mod r#i128;\n-mod r#isize;\n-\n-#[macro_use]\n-mod uint_macros;\n-\n-mod r#u8;\n-mod r#u16;\n-mod r#u32;\n-mod r#u64;\n-mod r#u128;\n-mod r#usize;\n-\n-#[macro_use]\n-mod mask_macros;\n-\n-mod mask8;\n-mod mask16;\n-mod mask32;\n-mod mask64;\n-mod mask128;\n-mod masksize;"}, {"sha": "cfd849640ffefe2615bcd418c5808bc414663440", "filename": "crates/core_simd/tests/ops_impl/u128.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu128.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,4 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { u128x2, u128 }\n-uint_tests! { u128x4, u128 }"}, {"sha": "50af4dd48b38293a429c5ef349165d56549c6a9c", "filename": "crates/core_simd/tests/ops_impl/u16.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu16.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { u16x4, u16 }\n-uint_tests! { u16x8, u16 }\n-uint_tests! { u16x16, u16 }\n-uint_tests! { u16x32, u16 }"}, {"sha": "8e7faa9d740385de0848fe914eb7382ed99e9b56", "filename": "crates/core_simd/tests/ops_impl/u32.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu32.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { u32x2, u32 }\n-uint_tests! { u32x4, u32 }\n-uint_tests! { u32x8, u32 }\n-uint_tests! { u32x16, u32 }"}, {"sha": "1a6385d37bae5b485ca4655382b5d30b04748c67", "filename": "crates/core_simd/tests/ops_impl/u64.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu64.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { u64x2, u64 }\n-uint_tests! { u64x4, u64 }\n-uint_tests! { u64x8, u64 }"}, {"sha": "31568b1eacbef01c07c18e3106a9c9a5907364f9", "filename": "crates/core_simd/tests/ops_impl/u8.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fu8.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { u8x8, u8 }\n-uint_tests! { u8x16, u8 }\n-uint_tests! { u8x32, u8 }\n-uint_tests! { u8x64, u8 }"}, {"sha": "bc8b3be74860ec350a62cd9d2392670586a76a13", "filename": "crates/core_simd/tests/ops_impl/uint_macros.rs", "status": "removed", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fuint_macros.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,428 +0,0 @@\n-macro_rules! uint_tests {\n-    { $vector:ident, $scalar:ident } => {\n-        #[cfg(test)]\n-        mod $vector {\n-            use super::*;\n-            use helpers::lanewise::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            use wasm_bindgen_test::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            wasm_bindgen_test_configure!(run_in_browser);\n-\n-            // TODO impl this as an associated fn on vectors\n-            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n-                let mut value = core_simd::$vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            const A: [$scalar; 64] = [\n-                16, 16, 16, 16, 16, 16, 16, 16,\n-                14, 14, 14, 14, 14, 14, 14, 14,\n-                12, 12, 12, 12, 12, 12, 12, 12,\n-                10, 10, 10, 10, 10, 10, 10, 10,\n-                 8,  8,  8,  8,  8,  8,  8,  8,\n-                 6,  6,  6,  6,  6,  6,  7,  8,\n-                 4,  4,  4,  4,  5,  6,  7,  8,\n-                 1,  2,  3,  4,  5,  6,  7,  8,\n-            ];\n-            const B: [$scalar; 64] = [\n-                1, 2, 3, 4, 1, 2, 3, 4,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-                1, 2, 3, 4, 5, 6, 7, 8,\n-            ];\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 1;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_lhs() {\n-                let a = 40;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 1;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n-                a &= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitand_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitAnd::bitand);\n-                a &= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n-                a |= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitor_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitOr::bitor);\n-                a |= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n-                a ^= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_scalar_lhs() {\n-                let a = 5;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn bitxor_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::BitXor::bitxor);\n-                a ^= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn not() {\n-                let v = from_slice(&A);\n-                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n-                assert_biteq!(!v, expected);\n-            }\n-        }\n-    }\n-}"}, {"sha": "13da57f15869b2eca9f1f2a0f56220be5e8239f6", "filename": "crates/core_simd/tests/ops_impl/usize.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fusize.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-uint_tests! { usizex2, usize }\n-uint_tests! { usizex4, usize }\n-uint_tests! { usizex8, usize }"}, {"sha": "58e80a8f277e0bc1291319ea6ce6d441d03c9963", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,328 @@\n+/// Implements a test on a unary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_unary_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n+        test_helpers::test_lanes! {\n+            fn $fn<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &<$vector as core::ops::$trait>::$fn,\n+                    &$scalar_fn,\n+                    &|_| true,\n+                );\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident } => {\n+        impl_unary_op_test! { $vector, $scalar, $trait::$fn, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_binary_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &<$vector as core::ops::$trait>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &<$vector as core::ops::$trait<$scalar>>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        &<$scalar as core::ops::$trait<$vector>>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &|mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &|mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n+        impl_binary_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Like `impl_binary_op_test`, but allows providing a function for rejecting particular inputs\n+/// (like the `proptest_assume` macro).\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_binary_checked_op_test {\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &<$vector as core::ops::$trait>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &<$vector as core::ops::$trait<$scalar>>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        &<$scalar as core::ops::$trait<$vector>>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &|mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    )\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &|mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    )\n+                }\n+            }\n+        }\n+    };\n+    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $check_fn:expr } => {\n+        impl_binary_nonzero_rhs_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn, $check_fn }\n+    };\n+}\n+\n+/// Implement tests for signed integers.\n+#[macro_export]\n+macro_rules! impl_signed_tests {\n+    { $vector:ident, $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+\n+            test_helpers::test_lanes! {\n+                fn neg<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &<Vector<LANES> as core::ops::Neg>::neg,\n+                        &<Scalar as core::ops::Neg>::neg,\n+                        &|x| !x.contains(&Scalar::MIN),\n+                    );\n+                }\n+            }\n+\n+            test_helpers::test_lanes_panic! {\n+                fn div_min_overflow_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a / b;\n+                }\n+\n+                fn div_by_all_zeros_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a / b;\n+                }\n+\n+                fn div_by_one_zero_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let mut b = Vector::<LANES>::splat(21);\n+                    b[0] = 0 as _;\n+                    let _ = a / b;\n+                }\n+\n+                fn rem_min_overflow_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a % b;\n+                }\n+\n+                fn rem_zero_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            test_helpers::test_lanes! {\n+                fn div_neg_one_no_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a / b;\n+                }\n+\n+                fn rem_neg_one_no_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+\n+            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+/// Implement tests for unsigned integers.\n+#[macro_export]\n+macro_rules! impl_unsigned_tests {\n+    { $vector:ident, $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+\n+            test_helpers::test_lanes_panic! {\n+                fn rem_zero_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n+            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n+\n+            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+/// Implement tests for floating point numbers.\n+#[macro_export]\n+macro_rules! impl_float_tests {\n+    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+            type IntScalar = $int_scalar;\n+\n+            impl_unary_op_test!(Vector<LANES>, Scalar, Neg::neg);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign);\n+            impl_binary_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign);\n+\n+            test_helpers::test_lanes! {\n+                fn abs<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::abs,\n+                        &Scalar::abs,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn ceil<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::ceil,\n+                        &Scalar::ceil,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn floor<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::floor,\n+                        &Scalar::floor,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn round_from_int<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round_from_int,\n+                        &|x| x as Scalar,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_int_unchecked<const LANES: usize>() {\n+                    // The maximum integer that can be represented by the equivalently sized float has\n+                    // all of the mantissa digits set to 1, pushed up to the MSB.\n+                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n+                    const MAX_REPRESENTABLE_VALUE: Scalar =\n+                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n+\n+                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    runner.run(\n+                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n+                        |x| {\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_2 = {\n+                                let mut result = [0; LANES];\n+                                for (i, o) in x.iter().zip(result.iter_mut()) {\n+                                    *o = unsafe { i.to_int_unchecked() };\n+                                }\n+                                result\n+                            };\n+                            test_helpers::prop_assert_biteq!(result_1, result_2);\n+                            Ok(())\n+                        },\n+                    ).unwrap();\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "4be7d751ffd8930fe517f030642da11193189774", "filename": "crates/core_simd/tests/u128_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu128_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu128_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu128_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdU128, u128 }"}, {"sha": "488e703d54fb623648390be1266264e2156d5ea3", "filename": "crates/core_simd/tests/u16_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdU16, u16 }"}, {"sha": "bf0631029e373c6d0f4329d84e3fd16d67215220", "filename": "crates/core_simd/tests/u32_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdU32, u32 }"}, {"sha": "e52fc3cfce1f9c50b72f91cb8291a6e985bf72d2", "filename": "crates/core_simd/tests/u64_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdU64, u64 }"}, {"sha": "45be3580ec3926c17d4b25be60436c5e400f6aaa", "filename": "crates/core_simd/tests/u8_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdU8, u8 }"}, {"sha": "1ce6e71800454e6155ed22315022f0568185fcca", "filename": "crates/core_simd/tests/usize_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,3 @@\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { SimdUsize, usize }"}, {"sha": "c9f6397b23b92a93a58791dc5f006e458f54ace7", "filename": "crates/test_helpers/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2FCargo.toml?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"test_helpers\"\n+version = \"0.1.0\"\n+authors = [\"Caleb Zulawski <caleb.zulawski@gmail.com>\"]\n+edition = \"2018\"\n+publish = false\n+\n+[dependencies.proptest]\n+version = \"0.10\"\n+default-features = false\n+features = [\"alloc\"]"}, {"sha": "c64bfee4f2d1f772a680f04d6c5bed4b84654cdb", "filename": "crates/test_helpers/src/array.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,100 @@\n+//! Generic-length array strategy.\n+\n+// Adapted from proptest's array code\n+// Copyright 2017 Jason Lingle\n+\n+use proptest::{\n+    strategy::{NewTree, Strategy, ValueTree},\n+    test_runner::TestRunner,\n+};\n+use core::{\n+    marker::PhantomData,\n+    mem::MaybeUninit,\n+};\n+\n+#[must_use = \"strategies do nothing unless used\"]\n+#[derive(Clone, Copy, Debug)]\n+pub struct UniformArrayStrategy<S, T> {\n+    strategy: S,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<S, T> UniformArrayStrategy<S, T> {\n+    pub const fn new(strategy: S) -> Self {\n+        Self {\n+            strategy,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+pub struct ArrayValueTree<T> {\n+    tree: T,\n+    shrinker: usize,\n+    last_shrinker: Option<usize>,\n+}\n+\n+impl<T, S, const LANES: usize> Strategy for UniformArrayStrategy<S, [T; LANES]>\n+where\n+    T: core::fmt::Debug,\n+    S: Strategy<Value = T>,\n+{\n+    type Tree = ArrayValueTree<[S::Tree; LANES]>;\n+    type Value = [T; LANES];\n+\n+    fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {\n+        let tree: [S::Tree; LANES] = unsafe {\n+            let mut tree: [MaybeUninit<S::Tree>; LANES] = MaybeUninit::uninit().assume_init();\n+            for t in tree.iter_mut() {\n+                *t = MaybeUninit::new(self.strategy.new_tree(runner)?)\n+            }\n+            core::mem::transmute_copy(&tree)\n+        };\n+        Ok(ArrayValueTree {\n+            tree,\n+            shrinker: 0,\n+            last_shrinker: None,\n+        })\n+    }\n+}\n+\n+impl<T: ValueTree, const LANES: usize> ValueTree for ArrayValueTree<[T; LANES]> {\n+    type Value = [T::Value; LANES];\n+\n+    fn current(&self) -> Self::Value {\n+        unsafe {\n+            let mut value: [MaybeUninit<T::Value>; LANES] = MaybeUninit::uninit().assume_init();\n+            for (tree_elem, value_elem) in self.tree.iter().zip(value.iter_mut()) {\n+                *value_elem = MaybeUninit::new(tree_elem.current());\n+            }\n+            core::mem::transmute_copy(&value)\n+        }\n+    }\n+\n+    fn simplify(&mut self) -> bool {\n+        while self.shrinker < LANES {\n+            if self.tree[self.shrinker].simplify() {\n+                self.last_shrinker = Some(self.shrinker);\n+                return true;\n+            } else {\n+                self.shrinker += 1;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn complicate(&mut self) -> bool {\n+        if let Some(shrinker) = self.last_shrinker {\n+            self.shrinker = shrinker;\n+            if self.tree[shrinker].complicate() {\n+                true\n+            } else {\n+                self.last_shrinker = None;\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "8c62806438034b0e00e38e01e90ecc3f93c5f84f", "filename": "crates/test_helpers/src/biteq.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,96 @@\n+//! Compare numeric types by exact bit value.\n+\n+pub trait BitEq {\n+    fn biteq(&self, other: &Self) -> bool;\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n+}\n+\n+macro_rules! impl_integer_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                self == other\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self)\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_integer_biteq! { u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize }\n+\n+macro_rules! impl_float_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                if self.is_nan() && other.is_nan() {\n+                    true // exact nan bits don't matter\n+                } else {\n+                    self.to_bits() == other.to_bits()\n+                }\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_float_biteq! { f32, f64 }\n+\n+impl<T: BitEq, const N: usize> BitEq for [T; N] {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self.iter()\n+            .zip(other.iter())\n+            .fold(true, |value, (left, right)| value && left.biteq(right))\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        #[repr(transparent)]\n+        struct Wrapper<'a, T: BitEq>(&'a T);\n+\n+        impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                self.0.fmt(f)\n+            }\n+        }\n+\n+        f.debug_list()\n+            .entries(self.iter().map(|x| Wrapper(x)))\n+            .finish()\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub struct BitEqWrapper<'a, T>(pub &'a T);\n+\n+impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.biteq(other.0)\n+    }\n+}\n+\n+impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! prop_assert_biteq {\n+    { $a:expr, $b:expr } => {\n+        {\n+            use $crate::biteq::BitEqWrapper;\n+            let a = $a;\n+            let b = $b;\n+            proptest::prop_assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n+        }\n+    }\n+}"}, {"sha": "2c74c02d48a0b842fc5fd2bb6c087b6eaee9d2cb", "filename": "crates/test_helpers/src/lib.rs", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,385 @@\n+pub mod array;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+pub mod wasm;\n+\n+#[macro_use]\n+pub mod biteq;\n+\n+/// Specifies the default strategy for testing a type.\n+///\n+/// This strategy should be what \"makes sense\" to test.\n+pub trait DefaultStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn default_strategy() -> Self::Strategy;\n+}\n+\n+macro_rules! impl_num {\n+    { $type:tt } => {\n+        impl DefaultStrategy for $type {\n+            type Strategy = proptest::num::$type::Any;\n+            fn default_strategy() -> Self::Strategy {\n+                proptest::num::$type::ANY\n+            }\n+        }\n+    }\n+}\n+\n+impl_num! { i8 }\n+impl_num! { i16 }\n+impl_num! { i32 }\n+impl_num! { i64 }\n+impl_num! { isize }\n+impl_num! { u8 }\n+impl_num! { u16 }\n+impl_num! { u32 }\n+impl_num! { u64 }\n+impl_num! { usize }\n+impl_num! { f32 }\n+impl_num! { f64 }\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl DefaultStrategy for u128 {\n+    type Strategy = proptest::num::u128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        proptest::num::u128::ANY\n+    }\n+}\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl DefaultStrategy for i128 {\n+    type Strategy = proptest::num::i128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        proptest::num::i128::ANY\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl DefaultStrategy for u128 {\n+    type Strategy = crate::wasm::u128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        crate::wasm::u128::ANY\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl DefaultStrategy for i128 {\n+    type Strategy = crate::wasm::i128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        crate::wasm::i128::ANY\n+    }\n+}\n+\n+impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy for [T; LANES] {\n+    type Strategy = crate::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn default_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::default_strategy())\n+    }\n+}\n+\n+/// Test a function that takes a single value.\n+pub fn test_1<A: core::fmt::Debug + DefaultStrategy>(\n+    f: &dyn Fn(A) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner.run(&A::default_strategy(), f).unwrap();\n+}\n+\n+/// Test a function that takes two values.\n+pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + DefaultStrategy>(\n+    f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(&(A::default_strategy(), B::default_strategy()), |(a, b)| {\n+            f(a, b)\n+        })\n+        .unwrap();\n+}\n+\n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n+    fv: &dyn Fn(Vector) -> VectorResult,\n+    fs: &dyn Fn(Scalar) -> ScalarResult,\n+    check: &dyn Fn([Scalar; LANES]) -> bool,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_1(&|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n+        let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector1,\n+    Vector2,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector1, Vector2) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n+                *o = fs(*i1, *i2);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_scalar_rhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector, Scalar2) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], Scalar2) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: [Scalar1; LANES], y: Scalar2| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i, y);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_scalar_lhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Scalar1, Vector) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn(Scalar1, [Scalar2; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: Scalar1, y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x, y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in y.iter().zip(result.iter_mut()) {\n+                *o = fs(x, *i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Expand a const-generic test into separate tests for each possible lane count.\n+#[macro_export]\n+macro_rules! test_lanes {\n+    {\n+        $(fn $test:ident<const $lanes:ident: usize>() $body:tt)*\n+    } => {\n+        $(\n+            mod $test {\n+                use super::*;\n+\n+                fn implementation<const $lanes: usize>()\n+                where\n+                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost64,\n+                $body\n+\n+                #[cfg(target_arch = \"wasm32\")]\n+                wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_1() {\n+                    implementation::<1>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_2() {\n+                    implementation::<2>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_4() {\n+                    implementation::<4>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_8() {\n+                    implementation::<8>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_16() {\n+                    implementation::<16>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_32() {\n+                    implementation::<32>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_64() {\n+                    implementation::<64>();\n+                }\n+            }\n+        )*\n+    }\n+}  \n+\n+/// Expand a const-generic `#[should_panic]` test into separate tests for each possible lane count.\n+#[macro_export]\n+macro_rules! test_lanes_panic {\n+    {\n+        $(fn $test:ident<const $lanes:ident: usize>() $body:tt)*\n+    } => {\n+        $(\n+            mod $test {\n+                use super::*;\n+\n+                fn implementation<const $lanes: usize>()\n+                where\n+                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost64,\n+                $body\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_1() {\n+                    implementation::<1>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_2() {\n+                    implementation::<2>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_4() {\n+                    implementation::<4>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_8() {\n+                    implementation::<8>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_16() {\n+                    implementation::<16>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_32() {\n+                    implementation::<32>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_64() {\n+                    implementation::<64>();\n+                }\n+            }\n+        )*\n+    }\n+}  "}, {"sha": "3f11d67cbf390bea2a93daaacaada98761e0a858", "filename": "crates/test_helpers/src/wasm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85bd249c0aec8df978aa1a87b3689a39d0231e9/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs?ref=f85bd249c0aec8df978aa1a87b3689a39d0231e9", "patch": "@@ -0,0 +1,51 @@\n+//! Strategies for `u128` and `i128`, since proptest doesn't provide them for the wasm target.\n+\n+macro_rules! impl_num {\n+    { $name:ident } => {\n+        pub(crate) mod $name {\n+            type InnerStrategy = crate::array::UniformArrayStrategy<proptest::num::u64::Any, [u64; 2]>;\n+            use proptest::strategy::{Strategy, ValueTree, NewTree};\n+\n+\n+            #[must_use = \"strategies do nothing unless used\"]\n+            #[derive(Clone, Copy, Debug)]\n+            pub struct Any {\n+                strategy: InnerStrategy,\n+            }\n+\n+            pub struct BinarySearch {\n+                inner: <InnerStrategy as Strategy>::Tree,\n+            }\n+\n+            impl ValueTree for BinarySearch {\n+                type Value = $name;\n+\n+                fn current(&self) -> $name {\n+                    unsafe { core::mem::transmute(self.inner.current()) }\n+                }\n+\n+                fn simplify(&mut self) -> bool {\n+                    self.inner.simplify()\n+                }\n+\n+                fn complicate(&mut self) -> bool {\n+                    self.inner.complicate()\n+                }\n+            }\n+\n+            impl Strategy for Any {\n+                type Tree = BinarySearch;\n+                type Value = $name;\n+\n+                fn new_tree(&self, runner: &mut proptest::test_runner::TestRunner) -> NewTree<Self> {\n+                    Ok(BinarySearch { inner: self.strategy.new_tree(runner)? })\n+                }\n+            }\n+\n+            pub const ANY: Any = Any { strategy: InnerStrategy::new(proptest::num::u64::ANY) };\n+        }\n+    }\n+}\n+\n+impl_num! { u128 }\n+impl_num! { i128 }"}]}