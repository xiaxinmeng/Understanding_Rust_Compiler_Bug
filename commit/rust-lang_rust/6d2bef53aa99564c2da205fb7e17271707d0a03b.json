{"sha": "6d2bef53aa99564c2da205fb7e17271707d0a03b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMmJlZjUzYWE5OTU2NGMyZGEyMDVmYjdlMTcyNzE3MDdkMGEwM2I=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-10T15:22:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-12T03:24:11Z"}, "message": "rename var_bindings to be less cryptic", "tree": {"sha": "40d329a0c28cc8a241e72acbcb2001478311c3ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40d329a0c28cc8a241e72acbcb2001478311c3ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d2bef53aa99564c2da205fb7e17271707d0a03b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d2bef53aa99564c2da205fb7e17271707d0a03b", "html_url": "https://github.com/rust-lang/rust/commit/6d2bef53aa99564c2da205fb7e17271707d0a03b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d2bef53aa99564c2da205fb7e17271707d0a03b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d5b8701b19b1e25c5a6522ae038ad3496e0c906", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d5b8701b19b1e25c5a6522ae038ad3496e0c906", "html_url": "https://github.com/rust-lang/rust/commit/6d5b8701b19b1e25c5a6522ae038ad3496e0c906"}], "stats": {"total": 101, "additions": 58, "deletions": 43}, "files": [{"sha": "770634dfe48ac248d4803f3c11227ebab4096a12", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6d2bef53aa99564c2da205fb7e17271707d0a03b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d2bef53aa99564c2da205fb7e17271707d0a03b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=6d2bef53aa99564c2da205fb7e17271707d0a03b", "patch": "@@ -308,14 +308,14 @@ enum infer_ctxt = @{\n     // We instantiate vals_and_bindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    tvb: vals_and_bindings<ty::tv_vid, bounds<ty::t>>,\n+    ty_var_bindings: vals_and_bindings<ty::tv_vid, bounds<ty::t>>,\n \n     // The types that might instantiate an integral type variable are\n     // represented by an int_ty_set.\n-    tvib: vals_and_bindings<ty::tvi_vid, int_ty_set>,\n+    ty_var_integral_bindings: vals_and_bindings<ty::tvi_vid, int_ty_set>,\n \n     // For region variables.\n-    rb: vals_and_bindings<ty::region_vid, bounds<ty::region>>,\n+    region_var_bindings: vals_and_bindings<ty::region_vid, bounds<ty::region>>,\n \n     // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n@@ -352,11 +352,15 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n type ures = result::result<(), ty::type_err>;\n type fres<T> = result::result<T, fixup_err>;\n \n+fn new_vals_and_bindings<V:copy, T:copy>() -> vals_and_bindings<V, T> {\n+    {vals: smallintmap::mk(), mut bindings: ~[]}\n+}\n+\n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n-                 tvb: {vals: smallintmap::mk(), mut bindings: ~[]},\n-                 tvib: {vals: smallintmap::mk(), mut bindings: ~[]},\n-                 rb: {vals: smallintmap::mk(), mut bindings: ~[]},\n+                 ty_var_bindings: new_vals_and_bindings(),\n+                 ty_var_integral_bindings: new_vals_and_bindings(),\n+                 region_var_bindings: new_vals_and_bindings(),\n                  ty_var_counter: @mut 0u,\n                  ty_var_integral_counter: @mut 0u,\n                  region_var_counter: @mut 0u,\n@@ -582,24 +586,24 @@ impl infer_ctxt {\n     /// Execute `f` and commit the bindings if successful\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        assert self.tvb.bindings.len() == 0u;\n-        assert self.rb.bindings.len() == 0u;\n+        assert self.ty_var_bindings.bindings.len() == 0u;\n+        assert self.region_var_bindings.bindings.len() == 0u;\n \n         let r <- self.try(f);\n \n         // FIXME (#2814)---could use a vec::clear() that ran destructors but\n         // kept the vec at its currently allocated length\n-        self.tvb.bindings = ~[];\n-        self.rb.bindings = ~[];\n+        self.ty_var_bindings.bindings = ~[];\n+        self.region_var_bindings.bindings = ~[];\n \n         return r;\n     }\n \n     /// Execute `f`, unroll bindings on failure\n     fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        let tvbl = self.tvb.bindings.len();\n-        let rbl = self.rb.bindings.len();\n+        let tvbl = self.ty_var_bindings.bindings.len();\n+        let rbl = self.region_var_bindings.bindings.len();\n         let bl = self.borrowings.len();\n \n         debug!{\"try(tvbl=%u, rbl=%u)\", tvbl, rbl};\n@@ -608,8 +612,8 @@ impl infer_ctxt {\n           result::ok(_) => debug!{\"try--ok\"},\n           result::err(_) => {\n             debug!{\"try--rollback\"};\n-            rollback_to(&self.tvb, tvbl);\n-            rollback_to(&self.rb, rbl);\n+            rollback_to(&self.ty_var_bindings, tvbl);\n+            rollback_to(&self.region_var_bindings, rbl);\n             while self.borrowings.len() != bl { self.borrowings.pop(); }\n           }\n         }\n@@ -618,11 +622,11 @@ impl infer_ctxt {\n \n     /// Execute `f` then unroll any bindings it creates\n     fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n-        assert self.tvb.bindings.len() == 0u;\n-        assert self.rb.bindings.len() == 0u;\n+        assert self.ty_var_bindings.bindings.len() == 0u;\n+        assert self.region_var_bindings.bindings.len() == 0u;\n         let r <- f();\n-        rollback_to(&self.tvb, 0u);\n-        rollback_to(&self.rb, 0u);\n+        rollback_to(&self.ty_var_bindings, 0u);\n+        rollback_to(&self.region_var_bindings, 0u);\n         return r;\n     }\n }\n@@ -631,7 +635,7 @@ impl infer_ctxt {\n     fn next_ty_var_id() -> tv_vid {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;\n-        self.tvb.vals.insert(id,\n+        self.ty_var_bindings.vals.insert(id,\n                              root({lb: none, ub: none}, 0u));\n         return tv_vid(id);\n     }\n@@ -648,7 +652,7 @@ impl infer_ctxt {\n         let id = *self.ty_var_integral_counter;\n         *self.ty_var_integral_counter += 1u;\n \n-        self.tvib.vals.insert(id,\n+        self.ty_var_integral_bindings.vals.insert(id,\n                               root(int_ty_set_all(), 0u));\n         return tvi_vid(id);\n     }\n@@ -660,7 +664,7 @@ impl infer_ctxt {\n     fn next_region_var_id(bnds: bounds<ty::region>) -> region_vid {\n         let id = *self.region_var_counter;\n         *self.region_var_counter += 1u;\n-        self.rb.vals.insert(id, root(bnds, 0));\n+        self.region_var_bindings.vals.insert(id, root(bnds, 0));\n         return region_vid(id);\n     }\n \n@@ -947,6 +951,7 @@ impl infer_ctxt {\n         uok()\n     }\n \n+    /// make variable a subtype of T\n     fn vart<V: copy vid, T: copy to_str st>(\n         vb: &vals_and_bindings<V, bounds<T>>,\n         a_id: V, b: T) -> ures {\n@@ -983,6 +988,7 @@ impl infer_ctxt {\n         uok()\n     }\n \n+    /// make T a subtype of variable\n     fn tvar<V: copy vid, T: copy to_str st>(\n         vb: &vals_and_bindings<V, bounds<T>>,\n         a: T, b_id: V) -> ures {\n@@ -1213,7 +1219,7 @@ impl resolve_state {\n         if !self.should(resolve_rvar) {\n             return ty::re_var(rid)\n         }\n-        let nde = self.infcx.get(&self.infcx.rb, rid);\n+        let nde = self.infcx.get(&self.infcx.region_var_bindings, rid);\n         let bounds = nde.possible_types;\n         match bounds {\n           { ub:_, lb:some(r) } => { self.assert_not_rvar(rid, r); r }\n@@ -1250,7 +1256,7 @@ impl resolve_state {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let nde = self.infcx.get(&self.infcx.tvb, vid);\n+            let nde = self.infcx.get(&self.infcx.ty_var_bindings, vid);\n             let bounds = nde.possible_types;\n \n             let t1 = match bounds {\n@@ -1274,7 +1280,7 @@ impl resolve_state {\n             return ty::mk_var_integral(self.infcx.tcx, vid);\n         }\n \n-        let nde = self.infcx.get(&self.infcx.tvib, vid);\n+        let nde = self.infcx.get(&self.infcx.ty_var_integral_bindings, vid);\n         let pt = nde.possible_types;\n \n         // If there's only one type in the set of possible types, then\n@@ -1286,7 +1292,7 @@ impl resolve_state {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n-                    &self.infcx.tvib, vid,\n+                    &self.infcx.ty_var_integral_bindings, vid,\n                     root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n                                                            ty),\n                         nde.rank));\n@@ -1372,8 +1378,8 @@ impl infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-            let nde_a = self.get(&self.tvb, a_id);\n-            let nde_b = self.get(&self.tvb, b_id);\n+            let nde_a = self.get(&self.ty_var_bindings, a_id);\n+            let nde_b = self.get(&self.ty_var_bindings, b_id);\n             let a_bounds = nde_a.possible_types;\n             let b_bounds = nde_b.possible_types;\n \n@@ -1383,15 +1389,15 @@ impl infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), _) => {\n-            let nde_a = self.get(&self.tvb, a_id);\n+            let nde_a = self.get(&self.ty_var_bindings, a_id);\n             let a_bounds = nde_a.possible_types;\n \n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) => {\n-            let nde_b = self.get(&self.tvb, b_id);\n+            let nde_b = self.get(&self.ty_var_bindings, b_id);\n             let b_bounds = nde_b.possible_types;\n \n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n@@ -1750,17 +1756,20 @@ fn super_tys<C:combine>(\n \n       // Have to handle these first\n       (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) => {\n-        self.infcx().vars_integral(&self.infcx().tvib, a_id, b_id)\n+        self.infcx().vars_integral(&self.infcx().ty_var_integral_bindings,\n+                                   a_id, b_id)\n             .then(|| ok(a) )\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) => {\n-        self.infcx().vart_integral(&self.infcx().tvib, a_id, b)\n+        self.infcx().vart_integral(&self.infcx().ty_var_integral_bindings,\n+                                   a_id, b)\n             .then(|| ok(a) )\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().tvar_integral(&self.infcx().tvib, a, b_id)\n+        self.infcx().tvar_integral(&self.infcx().ty_var_integral_bindings,\n+                                   a, b_id)\n             .then(|| ok(a) )\n       }\n \n@@ -1902,17 +1911,20 @@ impl sub: combine {\n         do indent {\n             match (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) => {\n-                do self.infcx().vars(&self.rb, a_id, b_id).then {\n+                do self.infcx().vars(&self.region_var_bindings,\n+                                     a_id, b_id).then {\n                     ok(a)\n                 }\n               }\n               (ty::re_var(a_id), _) => {\n-                do self.infcx().vart(&self.rb, a_id, b).then {\n+                do self.infcx().vart(&self.region_var_bindings,\n+                                     a_id, b).then {\n                       ok(a)\n                   }\n               }\n               (_, ty::re_var(b_id)) => {\n-                  do self.infcx().tvar(&self.rb, a, b_id).then {\n+                  do self.infcx().tvar(&self.region_var_bindings,\n+                                       a, b_id).then {\n                       ok(a)\n                   }\n               }\n@@ -1973,13 +1985,16 @@ impl sub: combine {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-                self.infcx().vars(&self.tvb, a_id, b_id).then(|| ok(a) )\n+                self.infcx().vars(&self.ty_var_bindings,\n+                                  a_id, b_id).then(|| ok(a) )\n               }\n               (ty::ty_var(a_id), _) => {\n-                self.infcx().vart(&self.tvb, a_id, b).then(|| ok(a) )\n+                self.infcx().vart(&self.ty_var_bindings,\n+                                  a_id, b).then(|| ok(a) )\n               }\n               (_, ty::ty_var(b_id)) => {\n-                self.infcx().tvar(&self.tvb, a, b_id).then(|| ok(a) )\n+                self.infcx().tvar(&self.ty_var_bindings,\n+                                  a, b_id).then(|| ok(a) )\n               }\n               (_, ty::ty_bot) => {\n                 err(ty::terr_sorts(b, a))\n@@ -2483,18 +2498,18 @@ fn lattice_tys<L:lattice_ops combine>(\n           (_, ty::ty_bot) => self.ty_bot(a),\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-            lattice_vars(self, &self.infcx().tvb,\n+            lattice_vars(self, &self.infcx().ty_var_bindings,\n                          a, a_id, b_id,\n                          |x, y| self.tys(x, y) )\n           }\n \n           (ty::ty_var(a_id), _) => {\n-            lattice_var_t(self, &self.infcx().tvb, a_id, b,\n+            lattice_var_t(self, &self.infcx().ty_var_bindings, a_id, b,\n                           |x, y| self.tys(x, y) )\n           }\n \n           (_, ty::ty_var(b_id)) => {\n-            lattice_var_t(self, &self.infcx().tvb, b_id, a,\n+            lattice_var_t(self, &self.infcx().ty_var_bindings, b_id, a,\n                           |x, y| self.tys(x, y) )\n           }\n           _ => {\n@@ -2510,13 +2525,13 @@ fn lattice_rvars<L:lattice_ops combine>(\n \n     match (a, b) {\n       (ty::re_var(a_id), ty::re_var(b_id)) => {\n-        lattice_vars(self, &self.infcx().rb,\n+        lattice_vars(self, &self.infcx().region_var_bindings,\n                      a, a_id, b_id,\n                      |x, y| self.regions(x, y) )\n       }\n \n       (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) => {\n-        lattice_var_t(self, &self.infcx().rb,\n+        lattice_var_t(self, &self.infcx().region_var_bindings,\n                       v_id, r,\n                       |x, y| self.regions(x, y) )\n       }"}]}