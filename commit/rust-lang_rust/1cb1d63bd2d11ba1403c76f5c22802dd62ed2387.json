{"sha": "1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "node_id": "C_kwDOAAsO6NoAKDFjYjFkNjNiZDJkMTFiYTE0MDNjNzZmNWMyMjgwMmRkNjJlZDIzODc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-11T02:54:52Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-13T00:54:02Z"}, "message": "Use `&{self.x}` for packed `Copy` structs.\n\nBecause it's more concise than the `let` form.", "tree": {"sha": "46640bc11bef8f01abf0d0893eb8a9a932afb3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46640bc11bef8f01abf0d0893eb8a9a932afb3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "html_url": "https://github.com/rust-lang/rust/commit/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10144e29afb432425fc88cd2534577b4efa05937", "url": "https://api.github.com/repos/rust-lang/rust/commits/10144e29afb432425fc88cd2534577b4efa05937", "html_url": "https://github.com/rust-lang/rust/commit/10144e29afb432425fc88cd2534577b4efa05937"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "076b627ca79f6bb6bcf68b052be82282de1c06ef", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "patch": "@@ -1013,20 +1013,25 @@ impl<'a> MethodDef<'a> {\n     /// }\n     /// ```\n     /// But if the struct is `repr(packed)`, we can't use something like\n-    /// `&self.x` on a packed type (as required for e.g. `Debug` and `Hash`)\n-    /// because that might cause an unaligned ref. So we use let-destructuring\n-    /// instead. If the struct impls `Copy`:\n+    /// `&self.x` because that might cause an unaligned ref. So for any trait\n+    /// method that takes a reference, if the struct impls `Copy` then we use a\n+    /// local block to force a copy:\n     /// ```\n     /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: __self_0_0, y: __self_0_1 } = *self;\n-    ///         let Self { x: __self_1_0, y: __self_1_1 } = *other;\n-    ///         __self_0_0 == __self_1_0 && __self_0_1 == __self_1_1\n+    ///         // Desugars to `{ self.x }.eq(&{ other.y }) && ...`\n+    ///         { self.x } == { other.y } && { self.y } == { other.y }\n+    ///     }\n+    /// }\n+    /// impl Hash for A {\n+    ///     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+    ///         ::core::hash::Hash::hash(&{ self.x }, state);\n+    ///         ::core::hash::Hash::hash(&{ self.y }, state)\n     ///     }\n     /// }\n     /// ```\n-    /// If it doesn't impl `Copy`:\n+    /// If the struct doesn't impl `Copy`, we use let-destructuring with `ref`:\n     /// ```\n     /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n@@ -1038,7 +1043,7 @@ impl<'a> MethodDef<'a> {\n     /// }\n     /// ```\n     /// This latter case only works if the fields match the alignment required\n-    /// by the `packed(N)` attribute.\n+    /// by the `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1065,9 +1070,14 @@ impl<'a> MethodDef<'a> {\n \n         if !is_packed {\n             let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def);\n+                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, false);\n+            mk_body(cx, selflike_fields)\n+        } else if always_copy {\n+            let selflike_fields =\n+                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n             mk_body(cx, selflike_fields)\n         } else {\n+            // Neither packed nor copy. Need to use ref patterns.\n             let prefixes: Vec<_> =\n                 (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n             let addr_of = always_copy;\n@@ -1536,6 +1546,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n+        copy: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1545,18 +1556,21 @@ impl<'a> TraitDef<'a> {\n                     // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n                     // \"field `0` of struct `Point` is private\" errors on tuple\n                     // structs.\n-                    cx.expr_addr_of(\n+                    let mut field_expr = cx.expr(\n                         sp,\n-                        cx.expr(\n-                            sp,\n-                            ast::ExprKind::Field(\n-                                selflike_arg.clone(),\n-                                struct_field.ident.unwrap_or_else(|| {\n-                                    Ident::from_str_and_span(&i.to_string(), struct_field.span)\n-                                }),\n-                            ),\n+                        ast::ExprKind::Field(\n+                            selflike_arg.clone(),\n+                            struct_field.ident.unwrap_or_else(|| {\n+                                Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                            }),\n                         ),\n-                    )\n+                    );\n+                    if copy {\n+                        field_expr = cx.expr_block(\n+                            cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n+                        );\n+                    }\n+                    cx.expr_addr_of(sp, field_expr)\n                 })\n                 .collect()\n         })"}, {"sha": "542911537be7e62300fd979466d67273937e5a42", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1cb1d63bd2d11ba1403c76f5c22802dd62ed2387/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=1cb1d63bd2d11ba1403c76f5c22802dd62ed2387", "patch": "@@ -441,9 +441,8 @@ impl ::core::marker::Copy for PackedCopy { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for PackedCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        let Self(__self_0_0) = *self;\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedCopy\",\n-            &&__self_0_0)\n+            &&{ self.0 })\n     }\n }\n #[automatically_derived]\n@@ -458,26 +457,17 @@ impl ::core::default::Default for PackedCopy {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for PackedCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        let Self(__self_0_0) = *self;\n-        ::core::hash::Hash::hash(&__self_0_0, state)\n+        ::core::hash::Hash::hash(&{ self.0 }, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for PackedCopy {}\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n-    fn eq(&self, other: &PackedCopy) -> bool {\n-        let Self(__self_0_0) = *self;\n-        let Self(__self_1_0) = *other;\n-        __self_0_0 == __self_1_0\n-    }\n+    fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n     #[inline]\n-    fn ne(&self, other: &PackedCopy) -> bool {\n-        let Self(__self_0_0) = *self;\n-        let Self(__self_1_0) = *other;\n-        __self_0_0 != __self_1_0\n-    }\n+    fn ne(&self, other: &PackedCopy) -> bool { { self.0 } != { other.0 } }\n }\n impl ::core::marker::StructuralEq for PackedCopy {}\n #[automatically_derived]\n@@ -496,19 +486,15 @@ impl ::core::cmp::PartialOrd for PackedCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedCopy)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let Self(__self_0_0) = *self;\n-        let Self(__self_1_0) = *other;\n-        ::core::cmp::PartialOrd::partial_cmp(&__self_0_0, &__self_1_0)\n+        ::core::cmp::PartialOrd::partial_cmp(&{ self.0 }, &{ other.0 })\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for PackedCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedCopy) -> ::core::cmp::Ordering {\n-        let Self(__self_0_0) = *self;\n-        let Self(__self_1_0) = *other;\n-        ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0)\n+        ::core::cmp::Ord::cmp(&{ self.0 }, &{ other.0 })\n     }\n }\n "}]}