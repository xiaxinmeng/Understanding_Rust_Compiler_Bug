{"sha": "69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YjZiYzVlZWU5MTc0ZDBmMmVmMWU0ZmY2MGE2ZWQwNmFlZGY0NTU=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-02T22:27:15Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T17:24:03Z"}, "message": "Convert lints to a trait-based infrastructure\n\nThe immediate benefits are\n\n* moving the state specific to a single lint out of Context, and\n* replacing the soup of function calls in the Visitor impl with\n  more structured control flow\n\nBut this is also a step towards loadable lints.", "tree": {"sha": "6932b07fbe6ed9531832ed1990098537e79b9fc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6932b07fbe6ed9531832ed1990098537e79b9fc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "html_url": "https://github.com/rust-lang/rust/commit/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d4c96a8f2c17d1d94349e0dee26a15b1aa0b5ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4c96a8f2c17d1d94349e0dee26a15b1aa0b5ab", "html_url": "https://github.com/rust-lang/rust/commit/5d4c96a8f2c17d1d94349e0dee26a15b1aa0b5ab"}], "stats": {"total": 2307, "additions": 1306, "deletions": 1001}, "files": [{"sha": "2ca4d3eb4e857b0268ab1e4440337944765cba1d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1100, "deletions": 817, "changes": 1917, "blob_url": "https://github.com/rust-lang/rust/blob/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "patch": "@@ -11,16 +11,15 @@\n //! Lints built in to rustc.\n \n use metadata::csearch;\n-use middle::def;\n use middle::def::*;\n-use middle::pat_util;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n-use middle::ty;\n use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n use middle::typeck::infer;\n-use middle::typeck;\n+use middle::privacy::ExportedItems;\n+use middle::{typeck, ty, def, pat_util};\n use util::ppaux::{ty_to_str};\n-use lint::Context;\n+use util::nodemap::NodeSet;\n+use lint::{Context, LintPass};\n use lint;\n \n use std::cmp;\n@@ -33,341 +32,413 @@ use std::u16;\n use std::u32;\n use std::u64;\n use std::u8;\n+use std::default::Default;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::visit::Visitor;\n use syntax::{ast, ast_util, visit};\n \n-pub fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        ast::ExprWhile(cond, _) => {\n-            match cond.node {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitBool(true) => {\n-                            cx.span_lint(lint::WhileTrue,\n-                                         e.span,\n-                                         \"denote infinite loops with loop \\\n-                                          { ... }\");\n+/// Doesn't actually warn; just gathers information for use by\n+/// checks in trans.\n+#[deriving(Default)]\n+pub struct GatherNodeLevels;\n+\n+impl LintPass for GatherNodeLevels {\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemEnum(..) => {\n+                match cx.cur.find(&(lint::VariantSizeDifference as uint)) {\n+                    Some(&(lvl, src)) if lvl != lint::Allow => {\n+                        cx.insert_node_level(it.id, lint::VariantSizeDifference, lvl, src);\n+                    },\n+                    _ => { }\n+                }\n+            },\n+            _ => { }\n+        }\n+    }\n+}\n+\n+#[deriving(Default)]\n+pub struct WhileTrue;\n+\n+impl LintPass for WhileTrue {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprWhile(cond, _) => {\n+                match cond.node {\n+                    ast::ExprLit(lit) => {\n+                        match lit.node {\n+                            ast::LitBool(true) => {\n+                                cx.span_lint(lint::WhileTrue,\n+                                             e.span,\n+                                             \"denote infinite loops with loop \\\n+                                              { ... }\");\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n+                    _ => ()\n                 }\n-                _ => ()\n             }\n+            _ => ()\n         }\n-        _ => ()\n     }\n }\n \n-pub fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprCast(expr, ty) => {\n-            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n-            if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n-                cx.span_lint(lint::UnnecessaryTypecast, ty.span,\n-                             \"unnecessary type cast\");\n+#[deriving(Default)]\n+pub struct UnusedCasts;\n+\n+impl LintPass for UnusedCasts {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprCast(expr, ty) => {\n+                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n+                if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n+                    cx.span_lint(lint::UnnecessaryTypecast, ty.span,\n+                                 \"unnecessary type cast\");\n+                }\n             }\n+            _ => ()\n         }\n-        _ => ()\n-    };\n+    }\n }\n \n-pub fn check_type_limits(cx: &Context, e: &ast::Expr) {\n-    return match e.node {\n-        ast::ExprUnary(ast::UnNeg, ex) => {\n-            match ex.node  {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitUint(..) => {\n-                            cx.span_lint(lint::UnsignedNegate, e.span,\n-                                         \"negation of unsigned int literal may be unintentional\");\n-                        },\n-                        _ => ()\n-                    }\n-                },\n-                _ => {\n-                    let t = ty::expr_ty(cx.tcx, ex);\n-                    match ty::get(t).sty {\n-                        ty::ty_uint(_) => {\n-                            cx.span_lint(lint::UnsignedNegate, e.span,\n-                                         \"negation of unsigned int variable may be unintentional\");\n-                        },\n-                        _ => ()\n+pub struct TypeLimits {\n+    /// Id of the last visited negated expression\n+    negated_expr_id: ast::NodeId,\n+}\n+\n+impl Default for TypeLimits {\n+    fn default() -> TypeLimits {\n+        TypeLimits {\n+            negated_expr_id: -1,\n+        }\n+    }\n+}\n+\n+impl LintPass for TypeLimits {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprUnary(ast::UnNeg, expr) => {\n+                match expr.node  {\n+                    ast::ExprLit(lit) => {\n+                        match lit.node {\n+                            ast::LitUint(..) => {\n+                                cx.span_lint(lint::UnsignedNegate, e.span,\n+                                             \"negation of unsigned int literal may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n+                    },\n+                    _ => {\n+                        let t = ty::expr_ty(cx.tcx, expr);\n+                        match ty::get(t).sty {\n+                            ty::ty_uint(_) => {\n+                                cx.span_lint(lint::UnsignedNegate, e.span,\n+                                             \"negation of unsigned int variable may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n                     }\n+                };\n+                // propagate negation, if the negation itself isn't negated\n+                if self.negated_expr_id != e.id {\n+                    self.negated_expr_id = expr.id;\n                 }\n-            }\n-        },\n-        ast::ExprBinary(binop, l, r) => {\n-            if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n-                cx.span_lint(lint::TypeLimits, e.span,\n-                             \"comparison is useless due to type limits\");\n-            }\n-        },\n-        ast::ExprLit(lit) => {\n-            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_int(t) => {\n-                    let int_type = if t == ast::TyI {\n-                        cx.tcx.sess.targ_cfg.int_type\n-                    } else { t };\n-                    let (min, max) = int_ty_range(int_type);\n-                    let mut lit_val: i64 = match lit.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => fail!()\n-                    };\n-                    if cx.negated_expr_id == e.id {\n-                        lit_val *= -1;\n-                    }\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(lint::TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n-                ty::ty_uint(t) => {\n-                    let uint_type = if t == ast::TyU {\n-                        cx.tcx.sess.targ_cfg.uint_type\n-                    } else { t };\n-                    let (min, max) = uint_ty_range(uint_type);\n-                    let lit_val: u64 = match lit.node {\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => fail!()\n-                    };\n-                    if  lit_val < min || lit_val > max {\n-                        cx.span_lint(lint::TypeOverflow, e.span,\n-                                     \"literal out of range for its type\");\n-                    }\n-                },\n+            },\n+            ast::ExprParen(expr) if self.negated_expr_id == e.id => {\n+                self.negated_expr_id = expr.id;\n+            },\n+            ast::ExprBinary(binop, l, r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n+                    cx.span_lint(lint::TypeLimits, e.span,\n+                                 \"comparison is useless due to type limits\");\n+                }\n+            },\n+            ast::ExprLit(lit) => {\n+                match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                    ty::ty_int(t) => {\n+                        let int_type = if t == ast::TyI {\n+                            cx.tcx.sess.targ_cfg.int_type\n+                        } else { t };\n+                        let (min, max) = int_ty_range(int_type);\n+                        let mut lit_val: i64 = match lit.node {\n+                            ast::LitInt(v, _) => v,\n+                            ast::LitUint(v, _) => v as i64,\n+                            ast::LitIntUnsuffixed(v) => v,\n+                            _ => fail!()\n+                        };\n+                        if self.negated_expr_id == e.id {\n+                            lit_val *= -1;\n+                        }\n+                        if  lit_val < min || lit_val > max {\n+                            cx.span_lint(lint::TypeOverflow, e.span,\n+                                         \"literal out of range for its type\");\n+                        }\n+                    },\n+                    ty::ty_uint(t) => {\n+                        let uint_type = if t == ast::TyU {\n+                            cx.tcx.sess.targ_cfg.uint_type\n+                        } else { t };\n+                        let (min, max) = uint_ty_range(uint_type);\n+                        let lit_val: u64 = match lit.node {\n+                            ast::LitInt(v, _) => v as u64,\n+                            ast::LitUint(v, _) => v,\n+                            ast::LitIntUnsuffixed(v) => v as u64,\n+                            _ => fail!()\n+                        };\n+                        if  lit_val < min || lit_val > max {\n+                            cx.span_lint(lint::TypeOverflow, e.span,\n+                                         \"literal out of range for its type\");\n+                        }\n+                    },\n \n-                _ => ()\n-            };\n-        },\n-        _ => ()\n-    };\n+                    _ => ()\n+                };\n+            },\n+            _ => ()\n+        };\n \n-    fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n-                            min: T, max: T) -> bool {\n-        match binop {\n-            ast::BiLt => v >  min && v <= max,\n-            ast::BiLe => v >= min && v <  max,\n-            ast::BiGt => v >= min && v <  max,\n-            ast::BiGe => v >  min && v <= max,\n-            ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail!()\n+        fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n+                                min: T, max: T) -> bool {\n+            match binop {\n+                ast::BiLt => v >  min && v <= max,\n+                ast::BiLe => v >= min && v <  max,\n+                ast::BiGt => v >= min && v <  max,\n+                ast::BiGe => v >  min && v <= max,\n+                ast::BiEq | ast::BiNe => v >= min && v <= max,\n+                _ => fail!()\n+            }\n         }\n-    }\n \n-    fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-        match binop {\n-            ast::BiLt => ast::BiGt,\n-            ast::BiLe => ast::BiGe,\n-            ast::BiGt => ast::BiLt,\n-            ast::BiGe => ast::BiLe,\n-            _ => binop\n+        fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n+            match binop {\n+                ast::BiLt => ast::BiGt,\n+                ast::BiLe => ast::BiGe,\n+                ast::BiGt => ast::BiLt,\n+                ast::BiGe => ast::BiLe,\n+                _ => binop\n+            }\n         }\n-    }\n \n-    // for int & uint, be conservative with the warnings, so that the\n-    // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n-        match int_ty {\n-            ast::TyI =>    (i64::MIN,        i64::MAX),\n-            ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-            ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-            ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-            ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+        // for int & uint, be conservative with the warnings, so that the\n+        // warnings are consistent between 32- and 64-bit platforms\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+            match int_ty {\n+                ast::TyI =>    (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+            }\n         }\n-    }\n \n-    fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n-        match uint_ty {\n-            ast::TyU =>   (u64::MIN,         u64::MAX),\n-            ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-            ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-            ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-            ast::TyU64 => (u64::MIN,         u64::MAX)\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+            match uint_ty {\n+                ast::TyU =>   (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 => (u64::MIN,         u64::MAX)\n+            }\n         }\n-    }\n \n-    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n-                    l: &ast::Expr, r: &ast::Expr) -> bool {\n-        let (lit, expr, swap) = match (&l.node, &r.node) {\n-            (&ast::ExprLit(_), _) => (l, r, true),\n-            (_, &ast::ExprLit(_)) => (r, l, false),\n-            _ => return true\n-        };\n-        // Normalize the binop so that the literal is always on the RHS in\n-        // the comparison\n-        let norm_binop = if swap { rev_binop(binop) } else { binop };\n-        match ty::get(ty::expr_ty(tcx, expr)).sty {\n-            ty::ty_int(int_ty) => {\n-                let (min, max) = int_ty_range(int_ty);\n-                let lit_val: i64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v,\n-                        ast::LitUint(v, _) => v as i64,\n-                        ast::LitIntUnsuffixed(v) => v,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n-            }\n-            ty::ty_uint(uint_ty) => {\n-                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                let lit_val: u64 = match lit.node {\n-                    ast::ExprLit(li) => match li.node {\n-                        ast::LitInt(v, _) => v as u64,\n-                        ast::LitUint(v, _) => v,\n-                        ast::LitIntUnsuffixed(v) => v as u64,\n-                        _ => return true\n-                    },\n-                    _ => fail!()\n-                };\n-                is_valid(norm_binop, lit_val, min, max)\n+        fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n+                        l: &ast::Expr, r: &ast::Expr) -> bool {\n+            let (lit, expr, swap) = match (&l.node, &r.node) {\n+                (&ast::ExprLit(_), _) => (l, r, true),\n+                (_, &ast::ExprLit(_)) => (r, l, false),\n+                _ => return true\n+            };\n+            // Normalize the binop so that the literal is always on the RHS in\n+            // the comparison\n+            let norm_binop = if swap { rev_binop(binop) } else { binop };\n+            match ty::get(ty::expr_ty(tcx, expr)).sty {\n+                ty::ty_int(int_ty) => {\n+                    let (min, max) = int_ty_range(int_ty);\n+                    let lit_val: i64 = match lit.node {\n+                        ast::ExprLit(li) => match li.node {\n+                            ast::LitInt(v, _) => v,\n+                            ast::LitUint(v, _) => v as i64,\n+                            ast::LitIntUnsuffixed(v) => v,\n+                            _ => return true\n+                        },\n+                        _ => fail!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                ty::ty_uint(uint_ty) => {\n+                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                    let lit_val: u64 = match lit.node {\n+                        ast::ExprLit(li) => match li.node {\n+                            ast::LitInt(v, _) => v as u64,\n+                            ast::LitUint(v, _) => v,\n+                            ast::LitIntUnsuffixed(v) => v as u64,\n+                            _ => return true\n+                        },\n+                        _ => fail!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                _ => true\n             }\n-            _ => true\n         }\n-    }\n \n-    fn is_comparison(binop: ast::BinOp) -> bool {\n-        match binop {\n-            ast::BiEq | ast::BiLt | ast::BiLe |\n-            ast::BiNe | ast::BiGe | ast::BiGt => true,\n-            _ => false\n+        fn is_comparison(binop: ast::BinOp) -> bool {\n+            match binop {\n+                ast::BiEq | ast::BiLt | ast::BiLe |\n+                ast::BiNe | ast::BiGe | ast::BiGt => true,\n+                _ => false\n+            }\n         }\n     }\n }\n \n-pub fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n-    fn check_ty(cx: &Context, ty: &ast::Ty) {\n-        match ty.node {\n-            ast::TyPath(_, _, id) => {\n-                match cx.tcx.def_map.borrow().get_copy(&id) {\n-                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                        cx.span_lint(lint::CTypes, ty.span,\n-                                \"found rust type `int` in foreign module, while \\\n-                                libc::c_int or libc::c_long should be used\");\n-                    }\n-                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                        cx.span_lint(lint::CTypes, ty.span,\n-                                \"found rust type `uint` in foreign module, while \\\n-                                libc::c_uint or libc::c_ulong should be used\");\n-                    }\n-                    def::DefTy(def_id) => {\n-                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n+#[deriving(Default)]\n+pub struct CTypes;\n+\n+impl LintPass for CTypes {\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        fn check_ty(cx: &Context, ty: &ast::Ty) {\n+            match ty.node {\n+                ast::TyPath(_, _, id) => {\n+                    match cx.tcx.def_map.borrow().get_copy(&id) {\n+                        def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+                            cx.span_lint(lint::CTypes, ty.span,\n+                                    \"found rust type `int` in foreign module, while \\\n+                                    libc::c_int or libc::c_long should be used\");\n+                        }\n+                        def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n                             cx.span_lint(lint::CTypes, ty.span,\n-                                         \"found enum type without foreign-function-safe \\\n-                                          representation annotation in foreign module\");\n-                            // hmm... this message could be more helpful\n+                                    \"found rust type `uint` in foreign module, while \\\n+                                    libc::c_uint or libc::c_ulong should be used\");\n+                        }\n+                        def::DefTy(def_id) => {\n+                            if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                                cx.span_lint(lint::CTypes, ty.span,\n+                                             \"found enum type without foreign-function-safe \\\n+                                              representation annotation in foreign module\");\n+                                // hmm... this message could be more helpful\n+                            }\n                         }\n+                        _ => ()\n                     }\n-                    _ => ()\n                 }\n+                ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n+                _ => {}\n             }\n-            ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n-            _ => {}\n         }\n-    }\n \n-    fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-        for input in decl.inputs.iter() {\n-            check_ty(cx, input.ty);\n+        fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n+            for input in decl.inputs.iter() {\n+                check_ty(cx, input.ty);\n+            }\n+            check_ty(cx, decl.output)\n         }\n-        check_ty(cx, decl.output)\n-    }\n \n-    match it.node {\n-      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-        for ni in nmod.items.iter() {\n-            match ni.node {\n-                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n-                ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n+        match it.node {\n+          ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+            for ni in nmod.items.iter() {\n+                match ni.node {\n+                    ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n+                    ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n+                }\n             }\n+          }\n+          _ => {/* nothing to do */ }\n         }\n-      }\n-      _ => {/* nothing to do */ }\n     }\n }\n \n-pub fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n-    let xs = [lint::ManagedHeapMemory, lint::OwnedHeapMemory, lint::HeapMemory];\n-    for &lint in xs.iter() {\n-        if cx.get_level(lint) == lint::Allow { continue }\n-\n-        let mut n_box = 0;\n-        let mut n_uniq = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n-                ty::ty_box(_) => {\n-                    n_box += 1;\n-                }\n-                ty::ty_uniq(_) |\n-                ty::ty_trait(box ty::TyTrait {\n-                    store: ty::UniqTraitStore, ..\n-                }) |\n-                ty::ty_closure(box ty::ClosureTy {\n-                    store: ty::UniqTraitStore,\n-                    ..\n-                }) => {\n-                    n_uniq += 1;\n-                }\n+#[deriving(Default)]\n+pub struct HeapMemory;\n+\n+impl HeapMemory {\n+    fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n+        let xs = [lint::ManagedHeapMemory, lint::OwnedHeapMemory, lint::HeapMemory];\n+        for &lint in xs.iter() {\n+            if cx.get_level(lint) == lint::Allow { continue }\n+\n+            let mut n_box = 0;\n+            let mut n_uniq = 0;\n+            ty::fold_ty(cx.tcx, ty, |t| {\n+                match ty::get(t).sty {\n+                    ty::ty_box(_) => {\n+                        n_box += 1;\n+                    }\n+                    ty::ty_uniq(_) |\n+                    ty::ty_trait(box ty::TyTrait {\n+                        store: ty::UniqTraitStore, ..\n+                    }) |\n+                    ty::ty_closure(box ty::ClosureTy {\n+                        store: ty::UniqTraitStore,\n+                        ..\n+                    }) => {\n+                        n_uniq += 1;\n+                    }\n \n-                _ => ()\n-            };\n-            t\n-        });\n+                    _ => ()\n+                };\n+                t\n+            });\n \n-        if n_uniq > 0 && lint != lint::ManagedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n-        }\n+            if n_uniq > 0 && lint != lint::ManagedHeapMemory {\n+                let s = ty_to_str(cx.tcx, ty);\n+                let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+                cx.span_lint(lint, span, m.as_slice());\n+            }\n \n-        if n_box > 0 && lint != lint::OwnedHeapMemory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m.as_slice());\n+            if n_box > 0 && lint != lint::OwnedHeapMemory {\n+                let s = ty_to_str(cx.tcx, ty);\n+                let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n+                cx.span_lint(lint, span, m.as_slice());\n+            }\n         }\n     }\n }\n \n-pub fn check_heap_item(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemFn(..) |\n-        ast::ItemTy(..) |\n-        ast::ItemEnum(..) |\n-        ast::ItemStruct(..) => check_heap_type(cx, it.span,\n-                                               ty::node_id_to_type(cx.tcx,\n-                                                                   it.id)),\n-        _ => ()\n-    }\n+impl LintPass for HeapMemory {\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemFn(..) |\n+            ast::ItemTy(..) |\n+            ast::ItemEnum(..) |\n+            ast::ItemStruct(..) => self.check_heap_type(cx, it.span,\n+                                                        ty::node_id_to_type(cx.tcx,\n+                                                                            it.id)),\n+            _ => ()\n+        }\n \n-    // If it's a struct, we also have to check the fields' types\n-    match it.node {\n-        ast::ItemStruct(struct_def, _) => {\n-            for struct_field in struct_def.fields.iter() {\n-                check_heap_type(cx, struct_field.span,\n-                                ty::node_id_to_type(cx.tcx,\n-                                                    struct_field.node.id));\n+        // If it's a struct, we also have to check the fields' types\n+        match it.node {\n+            ast::ItemStruct(struct_def, _) => {\n+                for struct_field in struct_def.fields.iter() {\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         ty::node_id_to_type(cx.tcx,\n+                                                             struct_field.node.id));\n+                }\n             }\n+            _ => ()\n         }\n-        _ => ()\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let ty = ty::expr_ty(cx.tcx, e);\n+        self.check_heap_type(cx, e.span, ty);\n     }\n }\n \n struct RawPtrDerivingVisitor<'a> {\n     cx: &'a Context<'a>\n }\n \n-impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n+impl<'a> visit::Visitor<()> for RawPtrDerivingVisitor<'a> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {\n@@ -381,450 +452,608 @@ impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n     fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n }\n \n-pub fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n-        return\n+pub struct RawPointerDeriving {\n+    checked_raw_pointers: NodeSet,\n+}\n+\n+impl Default for RawPointerDeriving {\n+    fn default() -> RawPointerDeriving {\n+        RawPointerDeriving {\n+            checked_raw_pointers: NodeSet::new(),\n+        }\n     }\n-    let did = match item.node {\n-        ast::ItemImpl(..) => {\n-            match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n-                ty::ty_enum(did, _) => did,\n-                ty::ty_struct(did, _) => did,\n-                _ => return,\n-            }\n+}\n+\n+impl LintPass for RawPointerDeriving {\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n+            return\n         }\n-        _ => return,\n-    };\n-    if !ast_util::is_local(did) { return }\n-    let item = match cx.tcx.map.find(did.node) {\n-        Some(ast_map::NodeItem(item)) => item,\n-        _ => return,\n-    };\n-    if !cx.checked_raw_pointers.insert(item.id) { return }\n-    match item.node {\n-        ast::ItemStruct(..) | ast::ItemEnum(..) => {\n-            let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-            visit::walk_item(&mut visitor, item, ());\n+        let did = match item.node {\n+            ast::ItemImpl(..) => {\n+                match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                    ty::ty_enum(did, _) => did,\n+                    ty::ty_struct(did, _) => did,\n+                    _ => return,\n+                }\n+            }\n+            _ => return,\n+        };\n+        if !ast_util::is_local(did) { return }\n+        let item = match cx.tcx.map.find(did.node) {\n+            Some(ast_map::NodeItem(item)) => item,\n+            _ => return,\n+        };\n+        if !self.checked_raw_pointers.insert(item.id) { return }\n+        match item.node {\n+            ast::ItemStruct(..) | ast::ItemEnum(..) => {\n+                let mut visitor = RawPtrDerivingVisitor { cx: cx };\n+                visit::walk_item(&mut visitor, item, ());\n+            }\n+            _ => {}\n         }\n-        _ => {}\n     }\n }\n \n-pub fn check_unused_attribute(cx: &Context, attr: &ast::Attribute) {\n-    static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n-        // FIXME: #14408 whitelist docs since rustdoc looks at them\n-        \"doc\",\n-\n-        // FIXME: #14406 these are processed in trans, which happens after the\n-        // lint pass\n-        \"address_insignificant\",\n-        \"cold\",\n-        \"inline\",\n-        \"link\",\n-        \"link_name\",\n-        \"link_section\",\n-        \"no_builtins\",\n-        \"no_mangle\",\n-        \"no_split_stack\",\n-        \"packed\",\n-        \"static_assert\",\n-        \"thread_local\",\n-\n-        // not used anywhere (!?) but apparently we want to keep them around\n-        \"comment\",\n-        \"desc\",\n-        \"license\",\n-\n-        // FIXME: #14407 these are only looked at on-demand so we can't\n-        // guarantee they'll have already been checked\n-        \"deprecated\",\n-        \"experimental\",\n-        \"frozen\",\n-        \"locked\",\n-        \"must_use\",\n-        \"stable\",\n-        \"unstable\",\n-    ];\n-\n-    static CRATE_ATTRS: &'static [&'static str] = &'static [\n-        \"crate_type\",\n-        \"feature\",\n-        \"no_start\",\n-        \"no_main\",\n-        \"no_std\",\n-        \"crate_id\",\n-        \"desc\",\n-        \"comment\",\n-        \"license\",\n-        \"copyright\",\n-        \"no_builtins\",\n-    ];\n-\n-    for &name in ATTRIBUTE_WHITELIST.iter() {\n-        if attr.check_name(name) {\n-            break;\n+#[deriving(Default)]\n+pub struct UnusedAttribute;\n+\n+impl LintPass for UnusedAttribute {\n+    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+        static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n+            // FIXME: #14408 whitelist docs since rustdoc looks at them\n+            \"doc\",\n+\n+            // FIXME: #14406 these are processed in trans, which happens after the\n+            // lint pass\n+            \"address_insignificant\",\n+            \"cold\",\n+            \"inline\",\n+            \"link\",\n+            \"link_name\",\n+            \"link_section\",\n+            \"no_builtins\",\n+            \"no_mangle\",\n+            \"no_split_stack\",\n+            \"packed\",\n+            \"static_assert\",\n+            \"thread_local\",\n+\n+            // not used anywhere (!?) but apparently we want to keep them around\n+            \"comment\",\n+            \"desc\",\n+            \"license\",\n+\n+            // FIXME: #14407 these are only looked at on-demand so we can't\n+            // guarantee they'll have already been checked\n+            \"deprecated\",\n+            \"experimental\",\n+            \"frozen\",\n+            \"locked\",\n+            \"must_use\",\n+            \"stable\",\n+            \"unstable\",\n+        ];\n+\n+        static CRATE_ATTRS: &'static [&'static str] = &'static [\n+            \"crate_type\",\n+            \"feature\",\n+            \"no_start\",\n+            \"no_main\",\n+            \"no_std\",\n+            \"crate_id\",\n+            \"desc\",\n+            \"comment\",\n+            \"license\",\n+            \"copyright\",\n+            \"no_builtins\",\n+        ];\n+\n+        for &name in ATTRIBUTE_WHITELIST.iter() {\n+            if attr.check_name(name) {\n+                break;\n+            }\n         }\n-    }\n \n-    if !attr::is_used(attr) {\n-        cx.span_lint(lint::UnusedAttribute, attr.span, \"unused attribute\");\n-        if CRATE_ATTRS.contains(&attr.name().get()) {\n-            let msg = match attr.node.style {\n-               ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                  attribute: add an exclamation mark: #![foo]\",\n-                ast::AttrInner => \"crate-level attribute should be in the \\\n-                                   root module\",\n-            };\n-            cx.span_lint(lint::UnusedAttribute, attr.span, msg);\n+        if !attr::is_used(attr) {\n+            cx.span_lint(lint::UnusedAttribute, attr.span, \"unused attribute\");\n+            if CRATE_ATTRS.contains(&attr.name().get()) {\n+                let msg = match attr.node.style {\n+                   ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                      attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                                       root module\",\n+                };\n+                cx.span_lint(lint::UnusedAttribute, attr.span, msg);\n+            }\n         }\n     }\n }\n \n-pub fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n-    let ty = ty::expr_ty(cx.tcx, e);\n-    check_heap_type(cx, e.span, ty);\n-}\n-\n-pub fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n-    match s.node {\n-        ast::StmtSemi(expr, _) => {\n-            match expr.node {\n-                ast::ExprPath(_) => {\n-                    cx.span_lint(lint::PathStatement,\n-                                 s.span,\n-                                 \"path statement with no effect\");\n+#[deriving(Default)]\n+pub struct PathStatement;\n+\n+impl LintPass for PathStatement {\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        match s.node {\n+            ast::StmtSemi(expr, _) => {\n+                match expr.node {\n+                    ast::ExprPath(_) => {\n+                        cx.span_lint(lint::PathStatement,\n+                                     s.span,\n+                                     \"path statement with no effect\");\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => ()\n         }\n-        _ => ()\n     }\n }\n \n-pub fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n-    let expr = match s.node {\n-        ast::StmtSemi(expr, _) => expr,\n-        _ => return\n-    };\n-    let t = ty::expr_ty(cx.tcx, expr);\n-    match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n-        _ => {}\n-    }\n-    match expr.node {\n-        ast::ExprRet(..) => return,\n-        _ => {}\n-    }\n+#[deriving(Default)]\n+pub struct UnusedMustUse;\n+\n+impl LintPass for UnusedMustUse {\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let expr = match s.node {\n+            ast::StmtSemi(expr, _) => expr,\n+            _ => return\n+        };\n+        let t = ty::expr_ty(cx.tcx, expr);\n+        match ty::get(t).sty {\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n+            _ => {}\n+        }\n+        match expr.node {\n+            ast::ExprRet(..) => return,\n+            _ => {}\n+        }\n \n-    let t = ty::expr_ty(cx.tcx, expr);\n-    let mut warned = false;\n-    match ty::get(t).sty {\n-        ty::ty_struct(did, _) |\n-        ty::ty_enum(did, _) => {\n-            if ast_util::is_local(did) {\n-                match cx.tcx.map.get(did.node) {\n-                    ast_map::NodeItem(it) => {\n-                        if attr::contains_name(it.attrs.as_slice(),\n-                                               \"must_use\") {\n+        let t = ty::expr_ty(cx.tcx, expr);\n+        let mut warned = false;\n+        match ty::get(t).sty {\n+            ty::ty_struct(did, _) |\n+            ty::ty_enum(did, _) => {\n+                if ast_util::is_local(did) {\n+                    match cx.tcx.map.get(did.node) {\n+                        ast_map::NodeItem(it) => {\n+                            if attr::contains_name(it.attrs.as_slice(),\n+                                                   \"must_use\") {\n+                                cx.span_lint(lint::UnusedMustUse, s.span,\n+                                             \"unused result which must be used\");\n+                                warned = true;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                } else {\n+                    csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n+                        if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                             cx.span_lint(lint::UnusedMustUse, s.span,\n                                          \"unused result which must be used\");\n                             warned = true;\n                         }\n-                    }\n-                    _ => {}\n+                    });\n                 }\n-            } else {\n-                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n-                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                        cx.span_lint(lint::UnusedMustUse, s.span,\n-                                     \"unused result which must be used\");\n-                        warned = true;\n-                    }\n-                });\n             }\n+            _ => {}\n+        }\n+        if !warned {\n+            cx.span_lint(lint::UnusedResult, s.span, \"unused result\");\n         }\n-        _ => {}\n-    }\n-    if !warned {\n-        cx.span_lint(lint::UnusedResult, s.span, \"unused result\");\n     }\n }\n \n-pub fn check_deprecated_owned_vector(cx: &Context, e: &ast::Expr) {\n-    let t = ty::expr_ty(cx.tcx, e);\n-    match ty::get(t).sty {\n-        ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_vec(_, None) => {\n-                cx.span_lint(lint::DeprecatedOwnedVector, e.span,\n-                             \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n-            }\n+#[deriving(Default)]\n+pub struct DeprecatedOwnedVector;\n+\n+impl LintPass for DeprecatedOwnedVector {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let t = ty::expr_ty(cx.tcx, e);\n+        match ty::get(t).sty {\n+            ty::ty_uniq(t) => match ty::get(t).sty {\n+                ty::ty_vec(_, None) => {\n+                    cx.span_lint(lint::DeprecatedOwnedVector, e.span,\n+                                 \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n+                }\n+                _ => {}\n+            },\n             _ => {}\n-        },\n-        _ => {}\n+        }\n     }\n }\n \n-pub fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n-    fn is_camel_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        // start with a non-lowercase letter rather than non-uppercase\n-        // ones (some scripts don't have a concept of upper/lowercase)\n-        !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n-    }\n+#[deriving(Default)]\n+pub struct NonCamelCaseTypes;\n \n-    fn to_camel_case(s: &str) -> String {\n-        s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-            if i == 0 { c.to_uppercase() }\n-            else { c }\n-        )).collect()\n-    }\n+impl LintPass for NonCamelCaseTypes {\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        fn is_camel_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            assert!(!ident.get().is_empty());\n+            let ident = ident.get().trim_chars('_');\n \n-    fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = token::get_ident(ident);\n-\n-        if !is_camel_case(ident) {\n-            cx.span_lint(lint::\n-                NonCamelCaseTypes, span,\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                    sort, s, to_camel_case(s.get())).as_slice());\n+            // start with a non-lowercase letter rather than non-uppercase\n+            // ones (some scripts don't have a concept of upper/lowercase)\n+            !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n         }\n-    }\n \n-    match it.node {\n-        ast::ItemTy(..) | ast::ItemStruct(..) => {\n-            check_case(cx, \"type\", it.ident, it.span)\n+        fn to_camel_case(s: &str) -> String {\n+            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+                if i == 0 { c.to_uppercase() }\n+                else { c }\n+            )).collect()\n         }\n-        ast::ItemTrait(..) => {\n-            check_case(cx, \"trait\", it.ident, it.span)\n+\n+        fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+            let s = token::get_ident(ident);\n+\n+            if !is_camel_case(ident) {\n+                cx.span_lint(lint::\n+                    NonCamelCaseTypes, span,\n+                    format!(\"{} `{}` should have a camel case name such as `{}`\",\n+                        sort, s, to_camel_case(s.get())).as_slice());\n+            }\n         }\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            check_case(cx, \"type\", it.ident, it.span);\n-            for variant in enum_definition.variants.iter() {\n-                check_case(cx, \"variant\", variant.node.name, variant.span);\n+\n+        match it.node {\n+            ast::ItemTy(..) | ast::ItemStruct(..) => {\n+                check_case(cx, \"type\", it.ident, it.span)\n+            }\n+            ast::ItemTrait(..) => {\n+                check_case(cx, \"trait\", it.ident, it.span)\n             }\n+            ast::ItemEnum(ref enum_definition, _) => {\n+                check_case(cx, \"type\", it.ident, it.span);\n+                for variant in enum_definition.variants.iter() {\n+                    check_case(cx, \"variant\", variant.node.name, variant.span);\n+                }\n+            }\n+            _ => ()\n         }\n-        _ => ()\n     }\n }\n \n-pub fn check_snake_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-    fn is_snake_case(ident: ast::Ident) -> bool {\n-        let ident = token::get_ident(ident);\n-        assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars('_');\n-\n-        let mut allow_underscore = true;\n-        ident.chars().all(|c| {\n-            allow_underscore = match c {\n-                c if c.is_lowercase() || c.is_digit() => true,\n-                '_' if allow_underscore => false,\n-                _ => return false,\n-            };\n-            true\n-        })\n+#[deriving(PartialEq)]\n+enum MethodContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n+fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n+    let did = ast::DefId {\n+        krate: ast::LOCAL_CRATE,\n+        node: m.id\n+    };\n+\n+    match cx.tcx.methods.borrow().find_copy(&did) {\n+        None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n+        Some(md) => {\n+            match md.container {\n+                ty::TraitContainer(..) => TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => TraitImpl,\n+                        None => PlainImpl\n+                    }\n+                }\n+            }\n+        }\n     }\n+}\n+\n+#[deriving(Default)]\n+pub struct NonSnakeCaseFunctions;\n+\n+impl NonSnakeCaseFunctions {\n+    fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_snake_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            assert!(!ident.get().is_empty());\n+            let ident = ident.get().trim_chars('_');\n+\n+            let mut allow_underscore = true;\n+            ident.chars().all(|c| {\n+                allow_underscore = match c {\n+                    c if c.is_lowercase() || c.is_digit() => true,\n+                    '_' if allow_underscore => false,\n+                    _ => return false,\n+                };\n+                true\n+            })\n+        }\n \n-    fn to_snake_case(str: &str) -> String {\n-        let mut words = vec![];\n-        for s in str.split('_') {\n-            let mut buf = String::new();\n-            if s.is_empty() { continue; }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && ch.is_uppercase() {\n-                    words.push(buf);\n-                    buf = String::new();\n+        fn to_snake_case(str: &str) -> String {\n+            let mut words = vec![];\n+            for s in str.split('_') {\n+                let mut buf = String::new();\n+                if s.is_empty() { continue; }\n+                for ch in s.chars() {\n+                    if !buf.is_empty() && ch.is_uppercase() {\n+                        words.push(buf);\n+                        buf = String::new();\n+                    }\n+                    buf.push_char(ch.to_lowercase());\n                 }\n-                buf.push_char(ch.to_lowercase());\n+                words.push(buf);\n             }\n-            words.push(buf);\n+            words.connect(\"_\")\n+        }\n+\n+        let s = token::get_ident(ident);\n+\n+        if !is_snake_case(ident) {\n+            cx.span_lint(lint::NonSnakeCaseFunctions, span,\n+                format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                    sort, s, to_snake_case(s.get())).as_slice());\n         }\n-        words.connect(\"_\")\n     }\n+}\n \n-    let s = token::get_ident(ident);\n+impl LintPass for NonSnakeCaseFunctions {\n+    fn check_fn(&mut self, cx: &Context,\n+                fk: &visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, span: Span, _: ast::NodeId) {\n+        match *fk {\n+            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n+                PlainImpl\n+                    => self.check_snake_case(cx, \"method\", ident, span),\n+                TraitDefaultImpl\n+                    => self.check_snake_case(cx, \"trait method\", ident, span),\n+                _ => (),\n+            },\n+            visit::FkItemFn(ident, _, _, _)\n+                => self.check_snake_case(cx, \"function\", ident, span),\n+            _ => (),\n+        }\n+    }\n \n-    if !is_snake_case(ident) {\n-        cx.span_lint(lint::NonSnakeCaseFunctions, span,\n-            format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                sort, s, to_snake_case(s.get())).as_slice());\n+    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n+        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n     }\n }\n \n-pub fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n-    match it.node {\n-        // only check static constants\n-        ast::ItemStatic(_, ast::MutImmutable, _) => {\n-            let s = token::get_ident(it.ident);\n-            // check for lowercase letters rather than non-uppercase\n-            // ones (some scripts don't have a concept of\n-            // upper/lowercase)\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(lint::NonUppercaseStatics, it.span,\n-                    format!(\"static constant `{}` should have an uppercase name \\\n-                        such as `{}`\", s.get(),\n-                        s.get().chars().map(|c| c.to_uppercase())\n-                            .collect::<String>().as_slice()).as_slice());\n+#[deriving(Default)]\n+pub struct NonUppercaseStatics;\n+\n+impl LintPass for NonUppercaseStatics {\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            // only check static constants\n+            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                let s = token::get_ident(it.ident);\n+                // check for lowercase letters rather than non-uppercase\n+                // ones (some scripts don't have a concept of\n+                // upper/lowercase)\n+                if s.get().chars().any(|c| c.is_lowercase()) {\n+                    cx.span_lint(lint::NonUppercaseStatics, it.span,\n+                        format!(\"static constant `{}` should have an uppercase name \\\n+                            such as `{}`\", s.get(),\n+                            s.get().chars().map(|c| c.to_uppercase())\n+                                .collect::<String>().as_slice()).as_slice());\n+                }\n             }\n+            _ => {}\n         }\n-        _ => {}\n     }\n-}\n \n-pub fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n-    // Lint for constants that look like binding identifiers (#7526)\n-    match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n-            // last identifier alone is right choice for this lint.\n-            let ident = path.segments.last().unwrap().identifier;\n-            let s = token::get_ident(ident);\n-            if s.get().chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(lint::NonUppercasePatternStatics, path.span,\n-                    format!(\"static constant in pattern `{}` should have an uppercase \\\n-                        name such as `{}`\", s.get(),\n-                        s.get().chars().map(|c| c.to_uppercase())\n-                            .collect::<String>().as_slice()).as_slice());\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        // Lint for constants that look like binding identifiers (#7526)\n+        match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n+            (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n+                // last identifier alone is right choice for this lint.\n+                let ident = path.segments.last().unwrap().identifier;\n+                let s = token::get_ident(ident);\n+                if s.get().chars().any(|c| c.is_lowercase()) {\n+                    cx.span_lint(lint::NonUppercasePatternStatics, path.span,\n+                        format!(\"static constant in pattern `{}` should have an uppercase \\\n+                            name such as `{}`\", s.get(),\n+                            s.get().chars().map(|c| c.to_uppercase())\n+                                .collect::<String>().as_slice()).as_slice());\n+                }\n             }\n+            _ => {}\n         }\n-        _ => {}\n     }\n }\n \n-pub fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n-    match &p.node {\n-        &ast::PatIdent(_, ref path, _) => {\n-            match cx.tcx.def_map.borrow().find(&p.id) {\n-                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n-                        Some(&def::DefArg(_, _)) => {\n-                    // last identifier alone is right choice for this lint.\n-                    let ident = path.segments.last().unwrap().identifier;\n-                    let s = token::get_ident(ident);\n-                    if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                        cx.span_lint(lint::\n-                            UppercaseVariables,\n-                            path.span,\n-                            \"variable names should start with a lowercase character\");\n+#[deriving(Default)]\n+pub struct UppercaseVariables;\n+\n+impl LintPass for UppercaseVariables {\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        match &p.node {\n+            &ast::PatIdent(_, ref path, _) => {\n+                match cx.tcx.def_map.borrow().find(&p.id) {\n+                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n+                            Some(&def::DefArg(_, _)) => {\n+                        // last identifier alone is right choice for this lint.\n+                        let ident = path.segments.last().unwrap().identifier;\n+                        let s = token::get_ident(ident);\n+                        if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n+                            cx.span_lint(lint::\n+                                UppercaseVariables,\n+                                path.span,\n+                                \"variable names should start with a lowercase character\");\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n-        _ => {}\n     }\n-}\n \n-pub fn check_struct_uppercase_variable(cx: &Context, s: &ast::StructDef) {\n-    for sf in s.fields.iter() {\n-        match sf.node {\n-            ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n-                let s = token::get_ident(ident);\n-                if s.get().char_at(0).is_uppercase() {\n-                    cx.span_lint(lint::\n-                        UppercaseVariables,\n-                        sf.span,\n-                        \"structure field names should start with a lowercase character\");\n+    fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n+            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+        for sf in s.fields.iter() {\n+            match sf.node {\n+                ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n+                    let s = token::get_ident(ident);\n+                    if s.get().char_at(0).is_uppercase() {\n+                        cx.span_lint(lint::UppercaseVariables,\n+                            sf.span,\n+                            \"structure field names should start with a lowercase character\");\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n         }\n     }\n }\n \n-pub fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n-    match value.node {\n-        ast::ExprParen(_) => {\n-            cx.span_lint(lint::UnnecessaryParens, value.span,\n-                         format!(\"unnecessary parentheses around {}\",\n-                                 msg).as_slice())\n+#[deriving(Default)]\n+pub struct UnnecessaryParens;\n+\n+impl UnnecessaryParens {\n+    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n+        match value.node {\n+            ast::ExprParen(_) => {\n+                cx.span_lint(lint::UnnecessaryParens, value.span,\n+                             format!(\"unnecessary parentheses around {}\",\n+                                     msg).as_slice())\n+            }\n+            _ => {}\n         }\n-        _ => {}\n     }\n }\n \n-pub fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n-    let (value, msg) = match e.node {\n-        ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n-        ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n-        ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n-        ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n-        ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-        ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, value, msg);\n-}\n+impl LintPass for UnnecessaryParens {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let (value, msg) = match e.node {\n+            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n+            ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n+            ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n+            ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n+            ast::ExprAssign(_, value) => (value, \"assigned value\"),\n+            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n+            _ => return\n+        };\n+        self.check_unnecessary_parens_core(cx, value, msg);\n+    }\n \n-pub fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n-    let (value, msg) = match s.node {\n-        ast::StmtDecl(decl, _) => match decl.node {\n-            ast::DeclLocal(local) => match local.init {\n-                Some(value) => (value, \"assigned value\"),\n-                None => return\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let (value, msg) = match s.node {\n+            ast::StmtDecl(decl, _) => match decl.node {\n+                ast::DeclLocal(local) => match local.init {\n+                    Some(value) => (value, \"assigned value\"),\n+                    None => return\n+                },\n+                _ => return\n             },\n             _ => return\n-        },\n-        _ => return\n-    };\n-    check_unnecessary_parens_core(cx, value, msg);\n+        };\n+        self.check_unnecessary_parens_core(cx, value, msg);\n+    }\n }\n \n-pub fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) => {\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                cx.span_lint(lint::UnusedUnsafe, blk.span,\n-                             \"unnecessary `unsafe` block\");\n+#[deriving(Default)]\n+pub struct UnusedUnsafe;\n+\n+impl LintPass for UnusedUnsafe {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            ast::ExprBlock(ref blk) => {\n+                if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                    !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                    cx.span_lint(lint::UnusedUnsafe, blk.span,\n+                                 \"unnecessary `unsafe` block\");\n+                }\n             }\n+            _ => ()\n         }\n-        _ => ()\n     }\n }\n \n-pub fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n-    match e.node {\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-            cx.span_lint(lint::UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n+#[deriving(Default)]\n+pub struct UnsafeBlock;\n+\n+impl LintPass for UnsafeBlock {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n+                cx.span_lint(lint::UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n+            }\n+            _ => ()\n         }\n-        _ => ()\n     }\n }\n \n-pub fn check_unused_mut_pat(cx: &Context, pats: &[@ast::Pat]) {\n-    // collect all mutable pattern and group their NodeIDs by their Identifier to\n-    // avoid false warnings in match arms with multiple patterns\n-    let mut mutables = HashMap::new();\n-    for &p in pats.iter() {\n-        pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path| {\n-            match mode {\n-                ast::BindByValue(ast::MutMutable) => {\n-                    if path.segments.len() != 1 {\n-                        cx.tcx.sess.span_bug(p.span,\n-                                             \"mutable binding that doesn't consist \\\n-                                              of exactly one segment\");\n+#[deriving(Default)]\n+pub struct UnusedMut;\n+\n+impl UnusedMut {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[@ast::Pat]) {\n+        // collect all mutable pattern and group their NodeIDs by their Identifier to\n+        // avoid false warnings in match arms with multiple patterns\n+        let mut mutables = HashMap::new();\n+        for &p in pats.iter() {\n+            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path| {\n+                match mode {\n+                    ast::BindByValue(ast::MutMutable) => {\n+                        if path.segments.len() != 1 {\n+                            cx.tcx.sess.span_bug(p.span,\n+                                                 \"mutable binding that doesn't consist \\\n+                                                  of exactly one segment\");\n+                        }\n+                        let ident = path.segments.get(0).identifier;\n+                        if !token::get_ident(ident).get().starts_with(\"_\") {\n+                            mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n+                                old.push(id);\n+                            });\n+                        }\n                     }\n-                    let ident = path.segments.get(0).identifier;\n-                    if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n-                            old.push(id);\n-                        });\n+                    _ => {\n                     }\n                 }\n-                _ => {\n+            });\n+        }\n+\n+        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+        for (_, v) in mutables.iter() {\n+            if !v.iter().any(|e| used_mutables.contains(e)) {\n+                cx.span_lint(lint::UnusedMut, cx.tcx.map.span(*v.get(0)),\n+                             \"variable does not need to be mutable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedMut {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprMatch(_, ref arms) => {\n+                for a in arms.iter() {\n+                    self.check_unused_mut_pat(cx, a.pats.as_slice())\n                 }\n             }\n-        });\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        match s.node {\n+            ast::StmtDecl(d, _) => {\n+                match d.node {\n+                    ast::DeclLocal(l) => {\n+                        self.check_unused_mut_pat(cx, &[l.pat]);\n+                    },\n+                    _ => {}\n+                }\n+            },\n+            _ => {}\n+        }\n     }\n \n-    let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-    for (_, v) in mutables.iter() {\n-        if !v.iter().any(|e| used_mutables.contains(e)) {\n-            cx.span_lint(lint::UnusedMut, cx.tcx.map.span(*v.get(0)),\n-                         \"variable does not need to be mutable\");\n+    fn check_fn(&mut self, cx: &Context,\n+                _: &visit::FnKind, decl: &ast::FnDecl,\n+                _: &ast::Block, _: Span, _: ast::NodeId) {\n+        for a in decl.inputs.iter() {\n+            self.check_unused_mut_pat(cx, &[a.pat]);\n         }\n     }\n }\n@@ -834,248 +1063,302 @@ enum Allocation {\n     BoxAllocation\n }\n \n-pub fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n-    // Warn if string and vector literals with sigils, or boxing expressions,\n-    // are immediately borrowed.\n-    let allocation = match e.node {\n-        ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n-            match e2.node {\n-                ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-                    VectorAllocation\n+#[deriving(Default)]\n+pub struct UnnecessaryAllocation;\n+\n+impl LintPass for UnnecessaryAllocation {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        // Warn if string and vector literals with sigils, or boxing expressions,\n+        // are immediately borrowed.\n+        let allocation = match e.node {\n+            ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n+                match e2.node {\n+                    ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n+                        VectorAllocation\n+                    }\n+                    ast::ExprVec(..) => VectorAllocation,\n+                    _ => return\n                 }\n-                ast::ExprVec(..) => VectorAllocation,\n-                _ => return\n             }\n-        }\n-        ast::ExprUnary(ast::UnUniq, _) |\n-        ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n+            ast::ExprUnary(ast::UnUniq, _) |\n+            ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n \n-        _ => return\n-    };\n+            _ => return\n+        };\n \n-    let report = |msg| {\n-        cx.span_lint(lint::UnnecessaryAllocation, e.span, msg);\n-    };\n+        let report = |msg| {\n+            cx.span_lint(lint::UnnecessaryAllocation, e.span, msg);\n+        };\n \n-    match cx.tcx.adjustments.borrow().find(&e.id) {\n-        Some(adjustment) => {\n-            match *adjustment {\n-                ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n-                    match (allocation, autoref) {\n-                        (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                            report(\"unnecessary allocation, the sigil can be \\\n-                                    removed\");\n-                        }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                            report(\"unnecessary allocation, use & instead\");\n+        match cx.tcx.adjustments.borrow().find(&e.id) {\n+            Some(adjustment) => {\n+                match *adjustment {\n+                    ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                        match (allocation, autoref) {\n+                            (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                                report(\"unnecessary allocation, the sigil can be \\\n+                                        removed\");\n+                            }\n+                            (BoxAllocation,\n+                             Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                                report(\"unnecessary allocation, use & instead\");\n+                            }\n+                            (BoxAllocation,\n+                             Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                                report(\"unnecessary allocation, use &mut \\\n+                                        instead\");\n+                            }\n+                            _ => ()\n                         }\n-                        (BoxAllocation,\n-                         Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                            report(\"unnecessary allocation, use &mut \\\n-                                    instead\");\n-                        }\n-                        _ => ()\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => ()\n         }\n+    }\n+}\n+\n+pub struct MissingDoc {\n+    /// Set of nodes exported from this module.\n+    exported_items: Option<ExportedItems>,\n+\n+    /// Stack of IDs of struct definitions.\n+    struct_def_stack: Vec<ast::NodeId>,\n+\n+    /// Stack of whether #[doc(hidden)] is set\n+    /// at each level which has lint attributes.\n+    doc_hidden_stack: Vec<bool>,\n+}\n \n-        _ => ()\n+impl Default for MissingDoc {\n+    fn default() -> MissingDoc {\n+        MissingDoc {\n+            exported_items: None,\n+            struct_def_stack: vec!(),\n+            doc_hidden_stack: vec!(false),\n+        }\n     }\n }\n \n-pub fn check_missing_doc_attrs(cx: &Context,\n-                           id: Option<ast::NodeId>,\n-                           attrs: &[ast::Attribute],\n-                           sp: Span,\n-                           desc: &'static str) {\n-    // If we're building a test harness, then warning about\n-    // documentation is probably not really relevant right now.\n-    if cx.tcx.sess.opts.test { return }\n-\n-    // `#[doc(hidden)]` disables missing_doc check.\n-    if cx.is_doc_hidden { return }\n-\n-    // Only check publicly-visible items, using the result from the privacy pass. It's an option so\n-    // the crate root can also use this function (it doesn't have a NodeId).\n-    match id {\n-        Some(ref id) if !cx.exported_items.contains(id) => return,\n-        _ => ()\n+impl MissingDoc {\n+    fn doc_hidden(&self) -> bool {\n+        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n-    let has_doc = attrs.iter().any(|a| {\n-        match a.node.value.node {\n-            ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n-            _ => false\n+    fn check_missing_doc_attrs(&self,\n+                               cx: &Context,\n+                               id: Option<ast::NodeId>,\n+                               attrs: &[ast::Attribute],\n+                               sp: Span,\n+                               desc: &'static str) {\n+        // If we're building a test harness, then warning about\n+        // documentation is probably not really relevant right now.\n+        if cx.tcx.sess.opts.test { return }\n+\n+        // `#[doc(hidden)]` disables missing_doc check.\n+        if self.doc_hidden() { return }\n+\n+        // Only check publicly-visible items, using the result from the privacy pass.\n+        // It's an option so the crate root can also use this function (it doesn't\n+        // have a NodeId).\n+        let exported = self.exported_items.as_ref().expect(\"exported_items not set\");\n+        match id {\n+            Some(ref id) if !exported.contains(id) => return,\n+            _ => ()\n+        }\n+\n+        let has_doc = attrs.iter().any(|a| {\n+            match a.node.value.node {\n+                ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n+                _ => false\n+            }\n+        });\n+        if !has_doc {\n+            cx.span_lint(lint::MissingDoc,\n+                         sp,\n+                         format!(\"missing documentation for {}\",\n+                                 desc).as_slice());\n         }\n-    });\n-    if !has_doc {\n-        cx.span_lint(lint::MissingDoc,\n-                     sp,\n-                     format!(\"missing documentation for {}\",\n-                             desc).as_slice());\n     }\n }\n \n-pub fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n-    let desc = match it.node {\n-        ast::ItemFn(..) => \"a function\",\n-        ast::ItemMod(..) => \"a module\",\n-        ast::ItemEnum(..) => \"an enum\",\n-        ast::ItemStruct(..) => \"a struct\",\n-        ast::ItemTrait(..) => \"a trait\",\n-        _ => return\n-    };\n-    check_missing_doc_attrs(cx,\n-                            Some(it.id),\n-                            it.attrs.as_slice(),\n-                            it.span,\n-                            desc);\n-}\n+impl LintPass for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+                None => false,\n+                Some(l) => attr::contains_name(l.as_slice(), \"hidden\"),\n+            }\n+        });\n+        self.doc_hidden_stack.push(doc_hidden);\n+    }\n \n-pub fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n-    // If the method is an impl for a trait, don't doc.\n-    if lint::method_context(cx, m) == lint::TraitImpl { return; }\n-\n-    // Otherwise, doc according to privacy. This will also check\n-    // doc for default methods defined on traits.\n-    check_missing_doc_attrs(cx,\n-                            Some(m.id),\n-                            m.attrs.as_slice(),\n-                            m.span,\n-                            \"a method\");\n-}\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+        self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n+    }\n \n-pub fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n-    check_missing_doc_attrs(cx,\n-                            Some(tm.id),\n-                            tm.attrs.as_slice(),\n-                            tm.span,\n-                            \"a type method\");\n-}\n+    fn check_struct_def(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        self.struct_def_stack.push(id);\n+    }\n \n-pub fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n-    match sf.node.kind {\n-        ast::NamedField(_, vis) if vis == ast::Public =>\n-            check_missing_doc_attrs(cx,\n-                                    Some(cx.cur_struct_def_id),\n-                                    sf.node.attrs.as_slice(),\n-                                    sf.span,\n-                                    \"a struct field\"),\n-        _ => {}\n+    fn check_struct_def_post(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n+        assert!(popped == id);\n     }\n-}\n \n-pub fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n-    check_missing_doc_attrs(cx,\n-                            Some(v.node.id),\n-                            v.node.attrs.as_slice(),\n-                            v.span,\n-                            \"a variant\");\n+    fn check_crate(&mut self, cx: &Context, exported: &ExportedItems, krate: &ast::Crate) {\n+        // FIXME: clone to avoid lifetime trickiness\n+        self.exported_items = Some(exported.clone());\n+\n+        self.check_missing_doc_attrs(cx, None, krate.attrs.as_slice(),\n+            krate.span, \"crate\");\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        let desc = match it.node {\n+            ast::ItemFn(..) => \"a function\",\n+            ast::ItemMod(..) => \"a module\",\n+            ast::ItemEnum(..) => \"an enum\",\n+            ast::ItemStruct(..) => \"a struct\",\n+            ast::ItemTrait(..) => \"a trait\",\n+            _ => return\n+        };\n+        self.check_missing_doc_attrs(cx, Some(it.id), it.attrs.as_slice(),\n+            it.span, desc);\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+            fk: &visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) {\n+        match *fk {\n+            visit::FkMethod(_, _, m) => {\n+                // If the method is an impl for a trait, don't doc.\n+                if method_context(cx, m) == TraitImpl { return; }\n+\n+                // Otherwise, doc according to privacy. This will also check\n+                // doc for default methods defined on traits.\n+                self.check_missing_doc_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+                    m.span, \"a method\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n+        self.check_missing_doc_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n+            tm.span, \"a type method\");\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n+        match sf.node.kind {\n+            ast::NamedField(_, vis) if vis == ast::Public => {\n+                let cur_struct_def = *self.struct_def_stack.last().expect(\"empty struct_def_stack\");\n+                self.check_missing_doc_attrs(cx, Some(cur_struct_def),\n+                    sf.node.attrs.as_slice(), sf.span, \"a struct field\")\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n+        self.check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n+            v.span, \"a variant\");\n+    }\n }\n \n /// Checks for use of items with #[deprecated], #[experimental] and\n /// #[unstable] (or none of them) attributes.\n-pub fn check_stability(cx: &Context, e: &ast::Expr) {\n-    let id = match e.node {\n-        ast::ExprPath(..) | ast::ExprStruct(..) => {\n-            match cx.tcx.def_map.borrow().find(&e.id) {\n-                Some(&def) => def.def_id(),\n-                None => return\n+#[deriving(Default)]\n+pub struct Stability;\n+\n+impl LintPass for Stability {\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let id = match e.node {\n+            ast::ExprPath(..) | ast::ExprStruct(..) => {\n+                match cx.tcx.def_map.borrow().find(&e.id) {\n+                    Some(&def) => def.def_id(),\n+                    None => return\n+                }\n             }\n-        }\n-        ast::ExprMethodCall(..) => {\n-            let method_call = typeck::MethodCall::expr(e.id);\n-            match cx.tcx.method_map.borrow().find(&method_call) {\n-                Some(method) => {\n-                    match method.origin {\n-                        typeck::MethodStatic(def_id) => {\n-                            // If this implements a trait method, get def_id\n-                            // of the method inside trait definition.\n-                            // Otherwise, use the current def_id (which refers\n-                            // to the method inside impl).\n-                            ty::trait_method_of_method(\n-                                cx.tcx, def_id).unwrap_or(def_id)\n+            ast::ExprMethodCall(..) => {\n+                let method_call = typeck::MethodCall::expr(e.id);\n+                match cx.tcx.method_map.borrow().find(&method_call) {\n+                    Some(method) => {\n+                        match method.origin {\n+                            typeck::MethodStatic(def_id) => {\n+                                // If this implements a trait method, get def_id\n+                                // of the method inside trait definition.\n+                                // Otherwise, use the current def_id (which refers\n+                                // to the method inside impl).\n+                                ty::trait_method_of_method(\n+                                    cx.tcx, def_id).unwrap_or(def_id)\n+                            }\n+                            typeck::MethodParam(typeck::MethodParam {\n+                                trait_id: trait_id,\n+                                method_num: index,\n+                                ..\n+                            })\n+                            | typeck::MethodObject(typeck::MethodObject {\n+                                trait_id: trait_id,\n+                                method_num: index,\n+                                ..\n+                            }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n                         }\n-                        typeck::MethodParam(typeck::MethodParam {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        })\n-                        | typeck::MethodObject(typeck::MethodObject {\n-                            trait_id: trait_id,\n-                            method_num: index,\n-                            ..\n-                        }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n                     }\n+                    None => return\n                 }\n-                None => return\n             }\n-        }\n-        _ => return\n-    };\n-\n-    let stability = if ast_util::is_local(id) {\n-        // this crate\n-        let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n-            attrs.map(|a| attr::find_stability(a.as_slice()))\n-        });\n-        match s {\n-            Some(s) => s,\n+            _ => return\n+        };\n \n-            // no possibility of having attributes\n-            // (e.g. it's a local variable), so just\n-            // ignore it.\n-            None => return\n-        }\n-    } else {\n-        // cross-crate\n-\n-        let mut s = None;\n-        // run through all the attributes and take the first\n-        // stability one.\n-        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n-            if s.is_none() {\n-                s = attr::find_stability(attrs.as_slice())\n+        let stability = if ast_util::is_local(id) {\n+            // this crate\n+            let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n+                attrs.map(|a| attr::find_stability(a.as_slice()))\n+            });\n+            match s {\n+                Some(s) => s,\n+\n+                // no possibility of having attributes\n+                // (e.g. it's a local variable), so just\n+                // ignore it.\n+                None => return\n             }\n-        });\n-        s\n-    };\n-\n-    let (lint, label) = match stability {\n-        // no stability attributes == Unstable\n-        None => (lint::Unstable, \"unmarked\"),\n-        Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                (lint::Unstable, \"unstable\"),\n-        Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                (lint::Experimental, \"experimental\"),\n-        Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                (lint::Deprecated, \"deprecated\"),\n-        _ => return\n-    };\n-\n-    let msg = match stability {\n-        Some(attr::Stability { text: Some(ref s), .. }) => {\n-            format!(\"use of {} item: {}\", label, *s)\n-        }\n-        _ => format!(\"use of {} item\", label)\n-    };\n+        } else {\n+            // cross-crate\n+\n+            let mut s = None;\n+            // run through all the attributes and take the first\n+            // stability one.\n+            csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n+                if s.is_none() {\n+                    s = attr::find_stability(attrs.as_slice())\n+                }\n+            });\n+            s\n+        };\n \n-    cx.span_lint(lint, e.span, msg.as_slice());\n-}\n+        let (lint, label) = match stability {\n+            // no stability attributes == Unstable\n+            None => (lint::Unstable, \"unmarked\"),\n+            Some(attr::Stability { level: attr::Unstable, .. }) =>\n+                    (lint::Unstable, \"unstable\"),\n+            Some(attr::Stability { level: attr::Experimental, .. }) =>\n+                    (lint::Experimental, \"experimental\"),\n+            Some(attr::Stability { level: attr::Deprecated, .. }) =>\n+                    (lint::Deprecated, \"deprecated\"),\n+            _ => return\n+        };\n \n-pub fn check_enum_variant_sizes(cx: &mut Context, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemEnum(..) => {\n-            match cx.cur.find(&(lint::VariantSizeDifference as uint)) {\n-                Some(&(lvl, src)) if lvl != lint::Allow => {\n-                    cx.node_levels.insert((it.id, lint::VariantSizeDifference), (lvl, src));\n-                },\n-                _ => { }\n+        let msg = match stability {\n+            Some(attr::Stability { text: Some(ref s), .. }) => {\n+                format!(\"use of {} item: {}\", label, *s)\n             }\n-        },\n-        _ => { }\n+            _ => format!(\"use of {} item\", label)\n+        };\n+\n+        cx.span_lint(lint, e.span, msg.as_slice());\n     }\n }"}, {"sha": "04d0e60cbf9afe793578000804e6764ebda28582", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 206, "deletions": 184, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "patch": "@@ -28,36 +28,94 @@\n //! upon.  As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n //!\n-//! To add a new lint warning, all you need to do is to either invoke `add_lint`\n-//! on the session at the appropriate time, or write a few linting functions and\n-//! modify the Context visitor appropriately. If you're adding lints from the\n-//! Context itself, span_lint should be used instead of add_lint.\n+//! Most of the lints built into `rustc` are structs implementing `LintPass`,\n+//! and are defined within `builtin.rs`. To add a new lint you can define such\n+//! a struct and add it to the `builtin_lints!` macro invocation in this file.\n+//! `LintPass` itself is not a subtrait of `Default`, but the `builtin_lints!`\n+//! macro requires `Default` (usually via `deriving`).\n+//!\n+//! Some lints are defined elsewhere in the compiler and work by calling\n+//! `add_lint()` on the overall `Session` object.\n+//!\n+//! If you're adding lints to the `Context` infrastructure itself, defined in\n+//! this file, use `span_lint` instead of `add_lint`.\n \n #![allow(non_camel_case_types)]\n \n use driver::session;\n use middle::dead::DEAD_CODE_LINT_STR;\n-use middle::privacy;\n+use middle::privacy::ExportedItems;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n-use util::nodemap::NodeSet;\n \n use std::collections::HashMap;\n use std::rc::Rc;\n use std::gc::Gc;\n use std::to_str::ToStr;\n+use std::cell::RefCell;\n+use std::default::Default;\n use std::collections::SmallIntMap;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::visit::Visitor;\n+use syntax::visit::{Visitor, FnKind};\n use syntax::{ast, ast_util, visit};\n \n mod builtin;\n \n+/// Trait for types providing lint checks. Each method checks a single syntax\n+/// node, and should not invoke methods recursively (unlike `Visitor`).  Each\n+/// method has a default do-nothing implementation. The trait also contains a\n+/// few lint-specific methods with no equivalent in `Visitor`.\n+//\n+// FIXME: eliminate the duplication with `Visitor`\n+trait LintPass {\n+    fn check_crate(&mut self, _: &Context, _: &ExportedItems, _: &ast::Crate) { }\n+    fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n+    fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_view_item(&mut self, _: &Context, _: &ast::ViewItem) { }\n+    fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n+    fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n+    fn check_local(&mut self, _: &Context, _: &ast::Local) { }\n+    fn check_block(&mut self, _: &Context, _: &ast::Block) { }\n+    fn check_stmt(&mut self, _: &Context, _: &ast::Stmt) { }\n+    fn check_arm(&mut self, _: &Context, _: &ast::Arm) { }\n+    fn check_pat(&mut self, _: &Context, _: &ast::Pat) { }\n+    fn check_decl(&mut self, _: &Context, _: &ast::Decl) { }\n+    fn check_expr(&mut self, _: &Context, _: &ast::Expr) { }\n+    fn check_expr_post(&mut self, _: &Context, _: &ast::Expr) { }\n+    fn check_ty(&mut self, _: &Context, _: &ast::Ty) { }\n+    fn check_generics(&mut self, _: &Context, _: &ast::Generics) { }\n+    fn check_fn(&mut self, _: &Context,\n+        _: &FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+    fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n+    fn check_trait_method(&mut self, _: &Context, _: &ast::TraitMethod) { }\n+    fn check_struct_def(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_def_post(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &Context, _: &ast::StructField) { }\n+    fn check_variant(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<ast::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &Context, _: &ast::Lifetime) { }\n+    fn check_lifetime_decl(&mut self, _: &Context, _: &ast::Lifetime) { }\n+    fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n+    fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n+    fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n+\n+    /// Called when entering a syntax node that can have lint attributes such\n+    /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n+    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+\n+    /// Counterpart to `enter_lint_attrs`.\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+}\n+\n+type LintPassObject = Box<LintPass + 'static>;\n+\n #[deriving(Clone, Show, PartialEq, PartialOrd, Eq, Ord, Hash)]\n pub enum LintId {\n     CTypes,\n@@ -438,30 +496,27 @@ struct Context<'a> {\n     cur: SmallIntMap<(Level, LintSource)>,\n     /// Context we're checking in (used to access fields like sess)\n     tcx: &'a ty::ctxt,\n-    /// Items exported by the crate; used by the missing_doc lint.\n-    exported_items: &'a privacy::ExportedItems,\n-    /// The id of the current `ast::StructDef` being walked.\n-    cur_struct_def_id: ast::NodeId,\n-    /// Whether some ancestor of the current node was marked\n-    /// #[doc(hidden)].\n-    is_doc_hidden: bool,\n \n     /// When recursing into an attributed node of the ast which modifies lint\n     /// levels, this stack keeps track of the previous lint levels of whatever\n     /// was modified.\n-    lint_stack: Vec<(LintId, Level, LintSource)>,\n-\n-    /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n-\n-    /// Ids of structs/enums which have been checked for raw_pointer_deriving\n-    checked_raw_pointers: NodeSet,\n+    level_stack: Vec<(LintId, Level, LintSource)>,\n \n     /// Level of lints for certain NodeIds, stored here because the body of\n     /// the lint needs to run in trans.\n-    node_levels: HashMap<(ast::NodeId, LintId), (Level, LintSource)>,\n+    node_levels: RefCell<HashMap<(ast::NodeId, LintId), (Level, LintSource)>>,\n+\n+    /// Trait objects for each lint.\n+    lints: Vec<RefCell<LintPassObject>>,\n }\n \n+/// Convenience macro for calling a `LintPass` method on every lint in the context.\n+macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => (\n+    for tl in $cx.lints.iter() {\n+        tl.borrow_mut().$f($cx, $($args),*);\n+    }\n+))\n+\n pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n                  lint_str: &str, tcx: &ty::ctxt) {\n     if level == Allow { return }\n@@ -581,7 +636,7 @@ impl<'a> Context<'a> {\n                                 lintname).as_slice());\n                     } else if now != level {\n                         let src = self.get_source(lint);\n-                        self.lint_stack.push((lint, now, src));\n+                        self.level_stack.push((lint, now, src));\n                         pushed += 1;\n                         self.set_level(lint, level, Node(meta.span));\n                     }\n@@ -590,26 +645,13 @@ impl<'a> Context<'a> {\n             true\n         });\n \n-        let old_is_doc_hidden = self.is_doc_hidden;\n-        self.is_doc_hidden =\n-            self.is_doc_hidden ||\n-            attrs.iter()\n-                 .any(|attr| {\n-                     attr.name().equiv(&(\"doc\")) &&\n-                     match attr.meta_item_list() {\n-                         None => false,\n-                         Some(l) => {\n-                             attr::contains_name(l.as_slice(), \"hidden\")\n-                         }\n-                     }\n-                 });\n-\n+        run_lints!(self, enter_lint_attrs, attrs);\n         f(self);\n+        run_lints!(self, exit_lint_attrs, attrs);\n \n         // rollback\n-        self.is_doc_hidden = old_is_doc_hidden;\n         for _ in range(0, pushed) {\n-            let (lint, lvl, src) = self.lint_stack.pop().unwrap();\n+            let (lint, lvl, src) = self.level_stack.pop().unwrap();\n             self.set_level(lint, lvl, src);\n         }\n     }\n@@ -622,6 +664,10 @@ impl<'a> Context<'a> {\n         };\n         f(&mut v);\n     }\n+\n+    fn insert_node_level(&self, id: ast::NodeId, lint: LintId, lvl: Level, src: LintSource) {\n+        self.node_levels.borrow_mut().insert((id, lint), (lvl, src));\n+    }\n }\n \n /// Check that every lint from the list of attributes satisfies `f`.\n@@ -680,35 +726,6 @@ pub fn contains_lint(attrs: &[ast::Attribute],\n     false\n }\n \n-#[deriving(PartialEq)]\n-enum MethodContext {\n-    TraitDefaultImpl,\n-    TraitImpl,\n-    PlainImpl\n-}\n-\n-fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n-    let did = ast::DefId {\n-        krate: ast::LOCAL_CRATE,\n-        node: m.id\n-    };\n-\n-    match cx.tcx.methods.borrow().find_copy(&did) {\n-        None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(md) => {\n-            match md.container {\n-                ty::TraitContainer(..) => TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => TraitImpl,\n-                        None => PlainImpl\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> AstConv for Context<'a>{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n@@ -728,175 +745,170 @@ impl<'a> AstConv for Context<'a>{\n impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            builtin::check_enum_variant_sizes(cx, it);\n-            builtin::check_item_ctypes(cx, it);\n-            builtin::check_item_non_camel_case_types(cx, it);\n-            builtin::check_item_non_uppercase_statics(cx, it);\n-            builtin::check_heap_item(cx, it);\n-            builtin::check_missing_doc_item(cx, it);\n-            builtin::check_raw_ptr_deriving(cx, it);\n-\n+            run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it, ()));\n-\n             visit::walk_item(cx, it, ());\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it, ());\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n         self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i, ()));\n-\n             visit::walk_view_item(cx, i, ());\n         })\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        builtin::check_pat_non_uppercase_statics(self, p);\n-        builtin::check_pat_uppercase_variable(self, p);\n-\n+        run_lints!(self, check_pat, p);\n         visit::walk_pat(self, p, ());\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n-        match e.node {\n-            ast::ExprUnary(ast::UnNeg, expr) => {\n-                // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n-                }\n-            },\n-            ast::ExprParen(expr) => if self.negated_expr_id == e.id {\n-                self.negated_expr_id = expr.id\n-            },\n-            ast::ExprMatch(_, ref arms) => {\n-                for a in arms.iter() {\n-                    builtin::check_unused_mut_pat(self, a.pats.as_slice());\n-                }\n-            },\n-            _ => ()\n-        };\n-\n-        builtin::check_while_true_expr(self, e);\n-        builtin::check_stability(self, e);\n-        builtin::check_unnecessary_parens_expr(self, e);\n-        builtin::check_unused_unsafe(self, e);\n-        builtin::check_unsafe_block(self, e);\n-        builtin::check_unnecessary_allocation(self, e);\n-        builtin::check_heap_expr(self, e);\n-\n-        builtin::check_type_limits(self, e);\n-        builtin::check_unused_casts(self, e);\n-\n+        run_lints!(self, check_expr, e);\n         visit::walk_expr(self, e, ());\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n-        builtin::check_path_statement(self, s);\n-        builtin::check_unused_result(self, s);\n-        builtin::check_unnecessary_parens_stmt(self, s);\n-\n-        match s.node {\n-            ast::StmtDecl(d, _) => {\n-                match d.node {\n-                    ast::DeclLocal(l) => {\n-                        builtin::check_unused_mut_pat(self, &[l.pat]);\n-                    },\n-                    _ => {}\n-                }\n-            },\n-            _ => {}\n-        }\n-\n+        run_lints!(self, check_stmt, s);\n         visit::walk_stmt(self, s, ());\n     }\n \n-    fn visit_fn(&mut self, fk: &visit::FnKind, decl: &ast::FnDecl,\n+    fn visit_fn(&mut self, fk: &FnKind, decl: &ast::FnDecl,\n                 body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n-        let recurse = |this: &mut Context| {\n-            visit::walk_fn(this, fk, decl, body, span, ());\n-        };\n-\n-        for a in decl.inputs.iter(){\n-            builtin::check_unused_mut_pat(self, &[a.pat]);\n-        }\n-\n         match *fk {\n-            visit::FkMethod(ident, _, m) => {\n+            visit::FkMethod(_, _, m) => {\n                 self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n-                    builtin::check_missing_doc_method(cx, m);\n-\n-                    match method_context(cx, m) {\n-                        PlainImpl\n-                            => builtin::check_snake_case(cx, \"method\", ident, span),\n-                        TraitDefaultImpl\n-                            => builtin::check_snake_case(cx, \"trait method\", ident, span),\n-                        _ => (),\n-                    }\n-\n+                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n                     });\n-                    recurse(cx);\n+                    visit::walk_fn(cx, fk, decl, body, span, ());\n                 })\n             },\n-            visit::FkItemFn(ident, _, _, _) => {\n-                builtin::check_snake_case(self, \"function\", ident, span);\n-                recurse(self);\n+            _ => {\n+                run_lints!(self, check_fn, fk, decl, body, span, id);\n+                visit::walk_fn(self, fk, decl, body, span, ());\n             }\n-            _ => recurse(self),\n         }\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n         self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n-            builtin::check_missing_doc_ty_method(cx, t);\n-            builtin::check_snake_case(cx, \"trait method\", t.ident, t.span);\n-\n+            run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t, ());\n         })\n     }\n \n     fn visit_struct_def(&mut self,\n                         s: &ast::StructDef,\n-                        _: ast::Ident,\n-                        _: &ast::Generics,\n+                        ident: ast::Ident,\n+                        g: &ast::Generics,\n                         id: ast::NodeId,\n                         _: ()) {\n-        builtin::check_struct_uppercase_variable(self, s);\n-\n-        let old_id = self.cur_struct_def_id;\n-        self.cur_struct_def_id = id;\n+        run_lints!(self, check_struct_def, s, ident, g, id);\n         visit::walk_struct_def(self, s, ());\n-        self.cur_struct_def_id = old_id;\n+        run_lints!(self, check_struct_def_post, s, ident, g, id);\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n         self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n-            builtin::check_missing_doc_struct_field(cx, s);\n-\n+            run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s, ());\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n         self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n-            builtin::check_missing_doc_variant(cx, v);\n-\n+            run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g, ());\n         })\n     }\n \n     // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        run_lints!(self, check_ty, t);\n+    }\n+\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n+        run_lints!(self, check_ident, sp, id);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId, _: ()) {\n+        run_lints!(self, check_mod, m, s, n);\n+        visit::walk_mod(self, m, ());\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+        run_lints!(self, check_local, l);\n+        visit::walk_local(self, l, ());\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+        run_lints!(self, check_block, b);\n+        visit::walk_block(self, b, ());\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm, _: ()) {\n+        run_lints!(self, check_arm, a);\n+        visit::walk_arm(self, a, ());\n+    }\n+\n+    fn visit_decl(&mut self, d: &ast::Decl, _: ()) {\n+        run_lints!(self, check_decl, d);\n+        visit::walk_decl(self, d, ());\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &ast::Expr, _: ()) {\n+        run_lints!(self, check_expr_post, e);\n+    }\n+\n+    fn visit_generics(&mut self, g: &ast::Generics, _: ()) {\n+        run_lints!(self, check_generics, g);\n+        visit::walk_generics(self, g, ());\n+    }\n+\n+    fn visit_trait_method(&mut self, m: &ast::TraitMethod, _: ()) {\n+        run_lints!(self, check_trait_method, m);\n+        visit::walk_trait_method(self, m, ());\n+    }\n+\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {\n+        run_lints!(self, check_opt_lifetime_ref, sp, lt);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_ref, lt);\n+    }\n+\n+    fn visit_lifetime_decl(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_decl, lt);\n+    }\n+\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf, _: ()) {\n+        run_lints!(self, check_explicit_self, es);\n+        visit::walk_explicit_self(self, es, ());\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac, _: ()) {\n+        run_lints!(self, check_mac, mac);\n+        visit::walk_mac(self, mac, ());\n+    }\n+\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId, _: ()) {\n+        run_lints!(self, check_path, p, id);\n+        visit::walk_path(self, p, ());\n+    }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n-        builtin::check_unused_attribute(self, attr);\n+        run_lints!(self, check_attribute, attr);\n     }\n }\n \n@@ -914,19 +926,33 @@ impl<'a> IdVisitingOperation for Context<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &privacy::ExportedItems,\n+                   exported_items: &ExportedItems,\n                    krate: &ast::Crate) {\n+    macro_rules! builtin_lints (( $($name:ident),*, ) => (\n+        vec!($(\n+            {\n+                let obj: builtin::$name = Default::default();\n+                RefCell::new(box obj as LintPassObject)\n+            }\n+        ),*)\n+    ))\n+\n+    let builtin_lints = builtin_lints!(\n+        GatherNodeLevels, WhileTrue, UnusedCasts, TypeLimits, CTypes,\n+        HeapMemory, RawPointerDeriving, UnusedAttribute,\n+        PathStatement, UnusedMustUse, DeprecatedOwnedVector,\n+        NonCamelCaseTypes, NonSnakeCaseFunctions, NonUppercaseStatics,\n+        UppercaseVariables, UnnecessaryParens, UnusedUnsafe, UnsafeBlock,\n+        UnusedMut, UnnecessaryAllocation, MissingDoc, Stability,\n+    );\n+\n     let mut cx = Context {\n         dict: get_lint_dict(),\n         cur: SmallIntMap::new(),\n         tcx: tcx,\n-        exported_items: exported_items,\n-        cur_struct_def_id: -1,\n-        is_doc_hidden: false,\n-        lint_stack: Vec::new(),\n-        negated_expr_id: -1,\n-        checked_raw_pointers: NodeSet::new(),\n-        node_levels: HashMap::new(),\n+        level_stack: Vec::new(),\n+        node_levels: RefCell::new(HashMap::new()),\n+        lints: builtin_lints,\n     };\n \n     // Install default lint levels, followed by the command line levels, and\n@@ -946,13 +972,9 @@ pub fn check_crate(tcx: &ty::ctxt,\n             visit::walk_crate(v, krate, ());\n         });\n \n-        // since the root module isn't visited as an item (because it isn't an item), warn for it\n-        // here.\n-        builtin::check_missing_doc_attrs(cx,\n-                                         None,\n-                                         krate.attrs.as_slice(),\n-                                         krate.span,\n-                                         \"crate\");\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_lints!(cx, check_crate, exported_items, krate);\n \n         visit::walk_crate(cx, krate, ());\n     });\n@@ -967,5 +989,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n     }\n \n     tcx.sess.abort_if_errors();\n-    *tcx.node_lint_levels.borrow_mut() = cx.node_levels;\n+    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.unwrap();\n }"}]}