{"sha": "9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODNlOTYyZGUyOWRlYzBlZWE3YzhhZTRhYzQwM2JiYzZhZDFmMTY=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-12-29T09:08:33Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:54:23Z"}, "message": "Fix build after rebase.\n\nMostly just rename stuff.\nVisibility checks use DefIds rather than NodeIds now.", "tree": {"sha": "925f86218c49bd596ed7229100570ce050c27273", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/925f86218c49bd596ed7229100570ce050c27273"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "html_url": "https://github.com/rust-lang/rust/commit/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4136ba072e1b8ff5c06de2c3dc4b72773ae1b3e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4136ba072e1b8ff5c06de2c3dc4b72773ae1b3e5", "html_url": "https://github.com/rust-lang/rust/commit/4136ba072e1b8ff5c06de2c3dc4b72773ae1b3e5"}], "stats": {"total": 247, "additions": 129, "deletions": 118}, "files": [{"sha": "6450ddaa532965d768abff0ffe48dcd84660bb1a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -33,7 +33,7 @@ use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n-use ty::inhabitedness::NodeForrest;\n+use ty::inhabitedness::DefIdForrest;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -460,7 +460,7 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n-    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, NodeForrest>>,\n+    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForrest>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n "}, {"sha": "dc21e848711339226e0640abddca2bc96e1c7103", "filename": "src/librustc/ty/inhabitedness.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -10,137 +10,139 @@\n \n use std::mem;\n use rustc_data_structures::small_vec::SmallVec;\n-use syntax::ast::{CRATE_NODE_ID, NodeId};\n+use syntax::ast::CRATE_NODE_ID;\n use util::nodemap::FxHashSet;\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, TyS};\n use ty::{DefId, Substs};\n-use ty::{AdtKind, Visibility, NodeIdTree};\n+use ty::{AdtKind, Visibility, DefIdTree};\n use ty::TypeVariants::*;\n \n-/// Represents a set of nodes closed under the ancestor relation. That is, if a\n-/// node is in this set then so are all its descendants.\n+/// Represents a set of DefIds closed under the ancestor relation. That is, if\n+/// a DefId is in this set then so are all its descendants.\n #[derive(Clone)]\n-pub struct NodeForrest {\n-    /// The minimal set of nodes required to represent the whole set.\n-    /// If A and B are nodes in the NodeForrest, and A is a desecendant\n-    /// of B, then only B will be in root_nodes.\n+pub struct DefIdForrest {\n+    /// The minimal set of DefIds required to represent the whole set.\n+    /// If A and B are DefIds in the DefIdForrest, and A is a desecendant\n+    /// of B, then only B will be in root_ids.\n     /// We use a SmallVec here because (for its use in this module) its rare\n-    /// that this will contain more than one or two nodes.\n-    root_nodes: SmallVec<[NodeId; 1]>,\n+    /// that this will contain even two ids.\n+    root_ids: SmallVec<[DefId; 1]>,\n }\n \n-impl<'a, 'gcx, 'tcx> NodeForrest {\n-    /// Create an empty set.\n-    pub fn empty() -> NodeForrest {\n-        NodeForrest {\n-            root_nodes: SmallVec::new(),\n+impl<'a, 'gcx, 'tcx> DefIdForrest {\n+    /// Create an empty forrest.\n+    pub fn empty() -> DefIdForrest {\n+        DefIdForrest {\n+            root_ids: SmallVec::new(),\n         }\n     }\n \n-    /// Create a set containing every node.\n+    /// Create a forrest consisting of a single tree representing the entire\n+    /// crate.\n     #[inline]\n-    pub fn full() -> NodeForrest {\n-        NodeForrest::from_node(CRATE_NODE_ID)\n+    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest {\n+        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n+        DefIdForrest::from_id(crate_id)\n     }\n \n-    /// Create a set containing a node and all its descendants.\n-    pub fn from_node(node: NodeId) -> NodeForrest {\n-        let mut root_nodes = SmallVec::new();\n-        root_nodes.push(node);\n-        NodeForrest {\n-            root_nodes: root_nodes,\n+    /// Create a forrest containing a DefId and all its descendants.\n+    pub fn from_id(id: DefId) -> DefIdForrest {\n+        let mut root_ids = SmallVec::new();\n+        root_ids.push(id);\n+        DefIdForrest {\n+            root_ids: root_ids,\n         }\n     }\n \n-    /// Test whether the set is empty.\n+    /// Test whether the forrest is empty.\n     pub fn is_empty(&self) -> bool {\n-        self.root_nodes.is_empty()\n+        self.root_ids.is_empty()\n     }\n \n-    /// Test whether the set conains a node.\n+    /// Test whether the forrest conains a given DefId.\n     pub fn contains(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    node: NodeId) -> bool\n+                    id: DefId) -> bool\n     {\n-        for root_node in self.root_nodes.iter() {\n-            if tcx.map.is_descendant_of(node, *root_node) {\n+        for root_id in self.root_ids.iter() {\n+            if tcx.is_descendant_of(id, *root_id) {\n                 return true;\n             }\n         }\n         false\n     }\n \n-    /// Calculate the intersection of a collection of sets.\n+    /// Calculate the intersection of a collection of forrests.\n     pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           iter: I) -> NodeForrest\n-            where I: IntoIterator<Item=NodeForrest>\n+                           iter: I) -> DefIdForrest\n+            where I: IntoIterator<Item=DefIdForrest>\n     {\n-        let mut ret = NodeForrest::full();\n+        let mut ret = DefIdForrest::full(tcx);\n         let mut next_ret = SmallVec::new();\n-        let mut old_ret: SmallVec<[NodeId; 1]> = SmallVec::new();\n-        for next_set in iter {\n-            for node in ret.root_nodes.drain(..) {\n-                if next_set.contains(tcx, node) {\n-                    next_ret.push(node);\n+        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        for next_forrest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if next_forrest.contains(tcx, id) {\n+                    next_ret.push(id);\n                 } else {\n-                    old_ret.push(node);\n+                    old_ret.push(id);\n                 }\n             }\n-            ret.root_nodes.extend(old_ret.drain(..));\n+            ret.root_ids.extend(old_ret.drain(..));\n \n-            for node in next_set.root_nodes {\n-                if ret.contains(tcx, node) {\n-                    next_ret.push(node);\n+            for id in next_forrest.root_ids {\n+                if ret.contains(tcx, id) {\n+                    next_ret.push(id);\n                 }\n             }\n \n-            mem::swap(&mut next_ret, &mut ret.root_nodes);\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain(..);\n         }\n         ret\n     }\n \n-    /// Calculate the union of a collection of sets.\n+    /// Calculate the union of a collection of forrests.\n     pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    iter: I) -> NodeForrest\n-            where I: IntoIterator<Item=NodeForrest>\n+                    iter: I) -> DefIdForrest\n+            where I: IntoIterator<Item=DefIdForrest>\n     {\n-        let mut ret = NodeForrest::empty();\n+        let mut ret = DefIdForrest::empty();\n         let mut next_ret = SmallVec::new();\n-        for next_set in iter {\n-            for node in ret.root_nodes.drain(..) {\n-                if !next_set.contains(tcx, node) {\n-                    next_ret.push(node);\n+        for next_forrest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if !next_forrest.contains(tcx, id) {\n+                    next_ret.push(id);\n                 }\n             }\n \n-            for node in next_set.root_nodes {\n-                if !next_ret.contains(&node) {\n-                    next_ret.push(node);\n+            for id in next_forrest.root_ids {\n+                if !next_ret.contains(&id) {\n+                    next_ret.push(id);\n                 }\n             }\n \n-            mem::swap(&mut next_ret, &mut ret.root_nodes);\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain(..);\n         }\n         ret\n     }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    /// Calculate the set of  nodes from which this adt is visibly uninhabited.\n+    /// Calculate the forrest of DefIds from which this adt is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>) -> NodeForrest\n+                substs: &'tcx Substs<'tcx>) -> DefIdForrest\n     {\n         if !visited.insert((self.did, substs)) {\n-            return NodeForrest::empty();\n+            return DefIdForrest::empty();\n         }\n \n-        let ret = NodeForrest::intersection(tcx, self.variants.iter().map(|v| {\n+        let ret = DefIdForrest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n         }));\n         visited.remove(&(self.did, substs));\n@@ -149,27 +151,27 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n-    /// Calculate the set of  nodes from which this variant is visibly uninhabited.\n+    /// Calculate the forrest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n-                adt_kind: AdtKind) -> NodeForrest\n+                adt_kind: AdtKind) -> DefIdForrest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n-                NodeForrest::intersection(tcx, self.fields.iter().map(|f| {\n+                DefIdForrest::intersection(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Struct => {\n-                NodeForrest::union(tcx, self.fields.iter().map(|f| {\n+                DefIdForrest::union(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Enum => {\n-                NodeForrest::union(tcx, self.fields.iter().map(|f| {\n+                DefIdForrest::union(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, true)\n                 }))\n             },\n@@ -178,24 +180,24 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n-    /// Calculate the set of  nodes from which this field is visibly uninhabited.\n+    /// Calculate the forrest of DefIds from which this field is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n-                is_enum: bool) -> NodeForrest\n+                is_enum: bool) -> DefIdForrest\n     {\n         let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n         if is_enum {\n             data_uninhabitedness()\n         } else {\n             match self.vis {\n-                Visibility::PrivateExternal => NodeForrest::empty(),\n+                Visibility::Invisible => DefIdForrest::empty(),\n                 Visibility::Restricted(from) => {\n-                    let node_set = NodeForrest::from_node(from);\n-                    let iter = Some(node_set).into_iter().chain(Some(data_uninhabitedness()));\n-                    NodeForrest::intersection(tcx, iter)\n+                    let forrest = DefIdForrest::from_id(from);\n+                    let iter = Some(forrest).into_iter().chain(Some(data_uninhabitedness()));\n+                    DefIdForrest::intersection(tcx, iter)\n                 },\n                 Visibility::Public => data_uninhabitedness(),\n             }\n@@ -204,58 +206,58 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n }\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n-    /// Calculate the set of  nodes from which this type is visibly uninhabited.\n+    /// Calculate the forrest of DefIds from which this type is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeForrest\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest\n     {\n         match tcx.lift_to_global(&self) {\n             Some(global_ty) => {\n                 {\n                     let cache = tcx.inhabitedness_cache.borrow();\n-                    if let Some(closed_node_set) = cache.get(&global_ty) {\n-                        return closed_node_set.clone();\n+                    if let Some(forrest) = cache.get(&global_ty) {\n+                        return forrest.clone();\n                     }\n                 }\n-                let node_set = global_ty.uninhabited_from_inner(visited, tcx);\n+                let forrest = global_ty.uninhabited_from_inner(visited, tcx);\n                 let mut cache = tcx.inhabitedness_cache.borrow_mut();\n-                cache.insert(global_ty, node_set.clone());\n-                node_set\n+                cache.insert(global_ty, forrest.clone());\n+                forrest\n             },\n             None => {\n-                let node_set = self.uninhabited_from_inner(visited, tcx);\n-                node_set\n+                let forrest = self.uninhabited_from_inner(visited, tcx);\n+                forrest\n             },\n         }\n     }\n \n     fn uninhabited_from_inner(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeForrest\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {\n                 def.uninhabited_from(visited, tcx, substs)\n             },\n \n-            TyNever => NodeForrest::full(),\n+            TyNever => DefIdForrest::full(tcx),\n             TyTuple(ref tys) => {\n-                NodeForrest::union(tcx, tys.iter().map(|ty| {\n+                DefIdForrest::union(tcx, tys.iter().map(|ty| {\n                     ty.uninhabited_from(visited, tcx)\n                 }))\n             },\n             TyArray(ty, len) => {\n                 if len == 0 {\n-                    NodeForrest::empty()\n+                    DefIdForrest::empty()\n                 } else {\n                     ty.uninhabited_from(visited, tcx)\n                 }\n             }\n             TyRef(_, ref tm) => tm.ty.uninhabited_from(visited, tcx),\n \n-            _ => NodeForrest::empty(),\n+            _ => DefIdForrest::empty(),\n         }\n     }\n }"}, {"sha": "fa62e893a2875215047b061d4b6324869ac80dca", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -227,6 +227,20 @@ pub enum Visibility {\n \n pub trait DefIdTree: Copy {\n     fn parent(self, id: DefId) -> Option<DefId>;\n+\n+    fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n+        if descendant.krate != ancestor.krate {\n+            return false;\n+        }\n+\n+        while descendant != ancestor {\n+            match self.parent(descendant) {\n+                Some(parent) => descendant = parent,\n+                None => return false,\n+            }\n+        }\n+        true\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n@@ -253,7 +267,7 @@ impl Visibility {\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: DefIdTree>(self, mut module: DefId, tree: T) -> bool {\n+    pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n@@ -264,14 +278,7 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        while module != restriction {\n-            match tree.parent(module) {\n-                Some(parent) => module = parent,\n-                None => return false,\n-            }\n-        }\n-\n-        true\n+        tree.is_descendant_of(module, restriction)\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility"}, {"sha": "92c616b8c71f13fbb7ff2e1a416fc66083509a97", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n use util::nodemap::FxHashSet;\n \n@@ -979,11 +979,11 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is visibly uninhabited from a particular node.\n-    pub fn is_uninhabited_from(&self, block: NodeId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        let node_set = self.uninhabited_from(&mut visited, tcx);\n-        node_set.contains(tcx, block)\n+        let forrest = self.uninhabited_from(&mut visited, tcx);\n+        forrest.contains(tcx, module)\n     }\n \n     /// Checks whether a type is uninhabited."}, {"sha": "f1bd659bd2d39ff0e7f0b9a49ce3eea651d66ab7", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -29,7 +29,8 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast::NodeId;\n+use syntax::ast::DUMMY_NODE_ID;\n+use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n@@ -145,30 +146,29 @@ impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    /// (roughly) where in the code the match occurs. This is necessary for\n+    /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n-    /// not. eg.\n-    ///     struct Foo { _private: ! }\n-    /// can not be seen to be empty outside it's module and should not\n-    /// be matchable with an empty match statement.\n-    pub node: NodeId,\n+    /// not. eg. `struct Foo { _private: ! }` cannot be seen to be empty\n+    /// outside it's module and should not be matchable with an empty match\n+    /// statement.\n+    pub module: DefId,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n     pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        node: NodeId,\n+        module: DefId,\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n     {\n         let pattern_arena = TypedArena::new();\n \n         f(MatchCheckCtxt {\n             tcx: tcx,\n-            node: node,\n+            module: module,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap(),\n         })\n@@ -379,14 +379,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.node, cx.tcx) {\n+            if sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !sub_ty.is_uninhabited_from(cx.node, cx.tcx) {\n+            if length == 0 || !sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n                 vec![Slice(length)]\n             } else {\n                 vec![]\n@@ -395,18 +395,18 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n                 let mut visited = FxHashSet::default();\n-                let node_set = v.uninhabited_from(&mut visited,\n+                let forrest = v.uninhabited_from(&mut visited,\n                                                   cx.tcx, substs,\n                                                   AdtKind::Enum);\n-                if node_set.contains(cx.tcx, cx.node) {\n+                if forrest.contains(cx.tcx, cx.module) {\n                     None\n                 } else {\n                     Some(Variant(v.did))\n                 }\n             }).collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.node, cx.tcx) {\n+            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx) {\n                 vec![]\n             } else {\n                 vec![Single]"}, {"sha": "824f1e3c975bdca735d5f1f8249d73bcb63ef9d6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=9f83e962de29dec0eea7c8ae4ac403bbc6ad1f16", "patch": "@@ -150,7 +150,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, scrut.id, |ref mut cx| {\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(scrut.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n@@ -192,7 +193,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, pat.id, |ref mut cx| {\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(pat.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx);\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;"}]}