{"sha": "8dd0e0086fc07422c9b1044b1db021cff6563214", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZDBlMDA4NmZjMDc0MjJjOWIxMDQ0YjFkYjAyMWNmZjY1NjMyMTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-18T16:54:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-18T16:54:28Z"}, "message": "Merge #2589 #2591\n\n2589: Touch up docs r=matklad a=matklad\n\n\n\n2591: Remove dead code r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e25767bfadf847f2b8964e33ddd16d2574a2991b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e25767bfadf847f2b8964e33ddd16d2574a2991b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dd0e0086fc07422c9b1044b1db021cff6563214", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd+lnECRBK7hj4Ov3rIwAAdHIIAISzTwatSdxxFyLJq/KQqbVD\nHBvfEELoyIy01DEE7LKrBPCS5BR+YA58k3M6wOfq7rJEztven15Gjnn6OK5MSSz9\nvNEvn/vzWXZIpdTLiO0aV0pq+VgIdw02eN03tWCANmMramLFKZpO4dx9TbuL+bTA\nI8h4ArdtHyBFyOWlNOkuh1gfKx7cJfWkmBxrP1fgkRJrjX+DzW+SGXU0qB1DL5br\nRBq/AWimVxbM4NIh4Ba7l038iRSntQBCBsSYMc2xqVKg4EhbhIuCQJEv7ff/ULgM\nE/prNrMqfWu2ELdson4jGqlNuQoXrI0RcE5RgoKTriINoOUA3cgZOBt7DvEOD0Y=\n=XYJy\n-----END PGP SIGNATURE-----\n", "payload": "tree e25767bfadf847f2b8964e33ddd16d2574a2991b\nparent b63c7ecab960ab4478b28bb3ea2b4f9a2e78a00f\nparent d33fc26e05c573f536e02afbffc354fa4f4a35f3\nparent afdeacf3c126b3e19bd1e50a912fee2b3f2d4aa9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576688068 +0000\ncommitter GitHub <noreply@github.com> 1576688068 +0000\n\nMerge #2589 #2591\n\n2589: Touch up docs r=matklad a=matklad\n\n\n\n2591: Remove dead code r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd0e0086fc07422c9b1044b1db021cff6563214", "html_url": "https://github.com/rust-lang/rust/commit/8dd0e0086fc07422c9b1044b1db021cff6563214", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dd0e0086fc07422c9b1044b1db021cff6563214/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b63c7ecab960ab4478b28bb3ea2b4f9a2e78a00f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b63c7ecab960ab4478b28bb3ea2b4f9a2e78a00f", "html_url": "https://github.com/rust-lang/rust/commit/b63c7ecab960ab4478b28bb3ea2b4f9a2e78a00f"}, {"sha": "d33fc26e05c573f536e02afbffc354fa4f4a35f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33fc26e05c573f536e02afbffc354fa4f4a35f3", "html_url": "https://github.com/rust-lang/rust/commit/d33fc26e05c573f536e02afbffc354fa4f4a35f3"}, {"sha": "afdeacf3c126b3e19bd1e50a912fee2b3f2d4aa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/afdeacf3c126b3e19bd1e50a912fee2b3f2d4aa9", "html_url": "https://github.com/rust-lang/rust/commit/afdeacf3c126b3e19bd1e50a912fee2b3f2d4aa9"}], "stats": {"total": 76, "additions": 40, "deletions": 36}, "files": [{"sha": "b8752cbad52aea70267acf22dd0e79a7f257aec9", "filename": "crates/ra_assists/src/assists/add_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -590,7 +590,7 @@ fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n             }\n             ps.push(chain.into());\n         }\n-        hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n+        hir::PathKind::DollarCrate(_) => return None,\n     }\n     ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n     Some(ps)"}, {"sha": "d4cab05614096cab4fa3d456ace3c1573628dc7e", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::{BuiltinShadowMode, CrateDefMap},\n-    path::Path,\n+    path::{ModPath, Path},\n     src::HasSource,\n     DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n@@ -44,7 +44,7 @@ impl Expander {\n             db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n         );\n \n-        if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n+        if let Some(path) = macro_call.path().and_then(|path| self.parse_mod_path(path)) {\n             if let Some(def) = self.resolve_path_as_macro(db, &path) {\n                 let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n                 let file_id = call_id.as_file();\n@@ -81,9 +81,13 @@ impl Expander {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n+    fn parse_mod_path(&mut self, path: ast::Path) -> Option<ModPath> {\n+        ModPath::from_src(path, &self.hygiene)\n+    }\n+\n+    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n         self.crate_def_map\n-            .resolve_path(db, self.module.local_id, path.mod_path(), BuiltinShadowMode::Other)\n+            .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n             .0\n             .take_macros()\n     }"}, {"sha": "2dd779b66e667bb65f3d68fc0016ad16f87682f1", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -145,11 +145,6 @@ impl CrateDefMap {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n         };\n \n         for (i, segment) in segments {"}, {"sha": "7302cf0f187f6a436f0ee8873a540593052c9dfe", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -18,6 +18,18 @@ pub struct ModPath {\n     pub segments: Vec<Name>,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum PathKind {\n+    Plain,\n+    /// `self::` is `Super(0)`\n+    Super(u8),\n+    Crate,\n+    /// Absolute path (::foo)\n+    Abs,\n+    /// `$crate` from macro expansion\n+    DollarCrate(CrateId),\n+}\n+\n impl ModPath {\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n         lower::lower_path(path, hygiene).map(|it| it.mod_path)\n@@ -70,6 +82,9 @@ impl ModPath {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n+    /// Type based path like `<T>::foo`.\n+    /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n+    type_anchor: Option<Box<TypeRef>>,\n     mod_path: ModPath,\n     /// Invariant: the same len as self.path.segments\n     generic_args: Vec<Option<Arc<GenericArgs>>>,\n@@ -97,19 +112,6 @@ pub enum GenericArg {\n     // or lifetime...\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum PathKind {\n-    Plain,\n-    Super(u8),\n-    Crate,\n-    // Absolute path\n-    Abs,\n-    // Type based path like `<T>::foo`\n-    Type(Box<TypeRef>),\n-    // `$crate` from macro expansion\n-    DollarCrate(CrateId),\n-}\n-\n impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// DEPRECATED: It does not handle `$crate` from macro call.\n@@ -125,18 +127,17 @@ impl Path {\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n     pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        Path { mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n-    }\n-\n-    /// `true` if this path is just a standalone `self`\n-    pub fn is_self(&self) -> bool {\n-        self.mod_path.is_self()\n+        Path { type_anchor: None, mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n         &self.mod_path.kind\n     }\n \n+    pub fn type_anchor(&self) -> Option<&TypeRef> {\n+        self.type_anchor.as_ref().map(|it| &**it)\n+    }\n+\n     pub fn segments(&self) -> PathSegments<'_> {\n         PathSegments {\n             segments: self.mod_path.segments.as_slice(),\n@@ -153,6 +154,7 @@ impl Path {\n             return None;\n         }\n         let res = Path {\n+            type_anchor: self.type_anchor.clone(),\n             mod_path: ModPath {\n                 kind: self.mod_path.kind.clone(),\n                 segments: self.mod_path.segments[..self.mod_path.segments.len() - 1].to_vec(),\n@@ -225,6 +227,7 @@ impl GenericArgs {\n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n+            type_anchor: None,\n             mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n             generic_args: vec![None],\n         }"}, {"sha": "62aafd508e14651d3bde1cd0e2d8fad9b9a36e4d", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -22,6 +22,7 @@ pub(super) use lower_use::lower_use_tree;\n /// It correctly handles `$crate` based path from macro call.\n pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n     let mut kind = PathKind::Plain;\n+    let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n     loop {\n@@ -63,7 +64,8 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                 match trait_ref {\n                     // <T>::foo\n                     None => {\n-                        kind = PathKind::Type(Box::new(self_type));\n+                        type_anchor = Some(Box::new(self_type));\n+                        kind = PathKind::Plain;\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n@@ -111,7 +113,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     segments.reverse();\n     generic_args.reverse();\n     let mod_path = ModPath { kind, segments };\n-    return Some(Path { mod_path, generic_args });\n+    return Some(Path { type_anchor, mod_path, generic_args });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {"}, {"sha": "402a89386ba60ce9a5f119a6638dff3f972205f2", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -3,7 +3,7 @@\n use std::iter;\n \n use hir_def::{\n-    path::{Path, PathKind, PathSegment},\n+    path::{Path, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     AssocItemId, ContainerId, Lookup,\n };\n@@ -32,7 +32,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let PathKind::Type(type_ref) = path.kind() {\n+        let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             if path.segments().is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;"}, {"sha": "2b84309d7aacf2f9936d1afb90b112004a6896b4", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd0e0086fc07422c9b1044b1db021cff6563214/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=8dd0e0086fc07422c9b1044b1db021cff6563214", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, Path, PathKind, PathSegment, PathSegments},\n+    path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n@@ -101,7 +101,7 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let PathKind::Type(_) = path.kind() {\n+        if path.type_anchor().is_some() {\n             return None;\n         }\n         if path.segments().len() > 1 {\n@@ -202,7 +202,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let PathKind::Type(type_ref) = path.kind() {\n+        if let Some(type_ref) = path.type_anchor() {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n             return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n         }"}]}