{"sha": "56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZDkwNGM0YmI0YTEwZTZkYTNmMDNkMTEyNzllOWEzZjNkMjBkOGI=", "commit": {"author": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-05-23T22:07:52Z"}, "committer": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-06-22T04:55:42Z"}, "message": "sys/unix: Consolidate signal-handling FFI bindings\n\nBoth c.rs and stack_overflow.rs had bindings of libc's signal-handling\nroutines. It looks like the split dated from #16388, when (what is now)\nc.rs was in libnative but not libgreen. Nobody is currently using the\nc.rs bindings, but they're a bit more accurate in some places.\n\nMove everything to c.rs (since I'll need signal handling in process.rs,\nand we should avoid duplication), clean up the bindings, and manually\ndouble-check everything against the relevant system headers (fixing a\nfew things in the process).", "tree": {"sha": "fc2cfc3ade9086e661a224b2db474c3380cb56ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc2cfc3ade9086e661a224b2db474c3380cb56ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "html_url": "https://github.com/rust-lang/rust/commit/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b/comments", "author": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "committer": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e13642163ab258c58295bcb1f2eaa27266724f73", "url": "https://api.github.com/repos/rust-lang/rust/commits/e13642163ab258c58295bcb1f2eaa27266724f73", "html_url": "https://github.com/rust-lang/rust/commit/e13642163ab258c58295bcb1f2eaa27266724f73"}], "stats": {"total": 467, "additions": 199, "deletions": 268}, "files": [{"sha": "17e40bca37527404216494c267d252b06052c7e3", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 194, "deletions": 132, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "patch": "@@ -8,14 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! C definitions used by libnative that don't belong in liblibc\n+//! C definitions used by std::sys that don't belong in liblibc\n+\n+// These are definitions sufficient for the users in this directory.\n+// This is not a general-purpose binding to this functionality, and in\n+// some cases (notably the definition of siginfo_t), we intentionally\n+// have incomplete bindings so that we don't need to fight with unions.\n+//\n+// Note that these types need to match the definitions from the platform\n+// libc (currently glibc on Linux), not the kernel definitions / the\n+// syscall interface.  This has a few weirdnesses, like glibc's sigset_t\n+// being 1024 bits on all platforms. If you're adding a new GNU/Linux\n+// port, check glibc's sysdeps/unix/sysv/linux, not the kernel headers.\n \n #![allow(dead_code)]\n #![allow(non_camel_case_types)]\n \n-pub use self::signal::{sigaction, siginfo, sigset_t};\n-pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};\n-pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n+pub use self::signal_os::{sigaction, siginfo, sigset_t, sigaltstack};\n+pub use self::signal_os::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIGSTKSZ};\n \n use libc;\n \n@@ -97,6 +107,12 @@ pub struct passwd {\n     pub pw_shell: *mut libc::c_char,\n }\n \n+// This is really a function pointer (or a union of multiple function\n+// pointers), except for constants like SIG_DFL.\n+pub type sighandler_t = *mut libc::c_void;\n+\n+pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n+\n extern {\n     pub fn getsockopt(sockfd: libc::c_int,\n                       level: libc::c_int,\n@@ -109,12 +125,15 @@ extern {\n     pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,\n                    options: libc::c_int) -> libc::pid_t;\n \n+    pub fn raise(signum: libc::c_int) -> libc::c_int;\n+\n     pub fn sigaction(signum: libc::c_int,\n                      act: *const sigaction,\n                      oldact: *mut sigaction) -> libc::c_int;\n \n-    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n-    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigaltstack(ss: *const sigaltstack,\n+                       oss: *mut sigaltstack) -> libc::c_int;\n+\n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n \n     #[cfg(not(target_os = \"ios\"))]\n@@ -133,123 +152,174 @@ extern {\n                     -> *mut libc::c_char;\n }\n \n-#[cfg(any(all(target_os = \"linux\",\n-              any(target_arch = \"x86\",\n-                  target_arch = \"x86_64\",\n-                  target_arch = \"arm\",\n-                  target_arch = \"aarch64\")),\n+#[cfg(any(target_os = \"linux\",\n           target_os = \"android\"))]\n-mod signal {\n+mod signal_os {\n+    pub use self::arch::{SA_ONSTACK, SA_SIGINFO, SIGBUS,\n+                         sigaction, sigaltstack};\n     use libc;\n \n-    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n-    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n-    pub const SIGCHLD: libc::c_int = 17;\n-\n-    // This definition is not as accurate as it could be, {pid, uid, status} is\n-    // actually a giant union. Currently we're only interested in these fields,\n-    // however.\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    pub const SIGSTKSZ: libc::size_t = 8192;\n+\n+    // This is smaller on musl and Android, but no harm in being generous.\n+    #[cfg(any(target_arch = \"aarch64\",\n+              target_arch = \"powerpc\"))]\n+    pub const SIGSTKSZ: libc::size_t = 16384;\n+\n+    // This definition is intentionally a subset of the C structure: the\n+    // fields after si_code are actually a giant union. We're only\n+    // interested in si_addr for this module, though.\n     #[repr(C)]\n     pub struct siginfo {\n-        si_signo: libc::c_int,\n-        si_errno: libc::c_int,\n-        si_code: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+        _signo: libc::c_int,\n+        _errno: libc::c_int,\n+        _code: libc::c_int,\n+        // This structure will need extra padding here for MIPS64.\n+        pub si_addr: *mut libc::c_void\n     }\n \n+    #[cfg(all(target_os = \"linux\", target_pointer_width = \"32\"))]\n     #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_ulong,\n-        sa_restorer: *mut libc::c_void,\n-    }\n-\n-    unsafe impl ::marker::Send for sigaction { }\n-    unsafe impl ::marker::Sync for sigaction { }\n-\n-    #[repr(C)]\n-    #[cfg(target_pointer_width = \"32\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 32],\n     }\n \n+    #[cfg(all(target_os = \"linux\", target_pointer_width = \"64\"))]\n     #[repr(C)]\n-    #[cfg(target_pointer_width = \"64\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 16],\n     }\n-}\n \n-#[cfg(all(target_os = \"linux\",\n-          any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\")))]\n-mod signal {\n-    use libc;\n-\n-    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00010000;\n-    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n-    pub const SIGCHLD: libc::c_int = 18;\n-\n-    // This definition is not as accurate as it could be, {pid, uid, status} is\n-    // actually a giant union. Currently we're only interested in these fields,\n-    // however.\n-    #[repr(C)]\n-    pub struct siginfo {\n-        si_signo: libc::c_int,\n-        si_code: libc::c_int,\n-        si_errno: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+    // Android for MIPS has a 128-bit sigset_t, but we don't currently\n+    // support it. Android for AArch64 technically has a structure of a\n+    // single ulong.\n+    #[cfg(target_os = \"android\")]\n+    pub type sigset_t = libc::c_ulong;\n+\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"arm\",\n+              target_arch = \"aarch64\"))]\n+    mod arch {\n+        use libc;\n+        use super::super::sighandler_t;\n+        use super::sigset_t;\n+\n+        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+        pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n+\n+        pub const SIGBUS: libc::c_int = 7;\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[cfg(all(target_os = \"android\", target_pointer_width = \"32\"))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+            pub sa_mask: sigset_t,\n+        }\n+\n+        #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_flags: libc::c_int,\n+            pub ss_size: libc::size_t\n+        }\n     }\n \n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_flags: libc::c_uint,\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        sa_restorer: *mut libc::c_void,\n-        sa_resv: [libc::c_int; 1],\n-    }\n-\n-    unsafe impl ::marker::Send for sigaction { }\n-    unsafe impl ::marker::Sync for sigaction { }\n-\n-    #[repr(C)]\n-    pub struct sigset_t {\n-        __val: [libc::c_ulong; 32],\n+    #[cfg(any(target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    mod arch {\n+        use libc;\n+        use super::super::sighandler_t;\n+        use super::sigset_t;\n+\n+        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+        pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n+\n+        pub const SIGBUS: libc::c_int = 10;\n+\n+        #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            _restorer: *mut libc::c_void,\n+            _resv: [libc::c_int; 1],\n+        }\n+\n+        #[cfg(target_env = \"musl\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[cfg(target_os = \"android\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_size: libc::size_t,\n+            pub ss_flags: libc::c_int,\n+        }\n     }\n }\n \n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n-mod signal {\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"openbsd\"))]\n+mod signal_os {\n     use libc;\n+    use super::sighandler_t;\n \n     pub const SA_ONSTACK: libc::c_int = 0x0001;\n-    pub const SA_RESTART: libc::c_int = 0x0002;\n-    pub const SA_RESETHAND: libc::c_int = 0x0004;\n-    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;\n-    pub const SA_NODEFER: libc::c_int = 0x0010;\n-    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;\n     pub const SA_SIGINFO: libc::c_int = 0x0040;\n-    pub const SIGCHLD: libc::c_int = 20;\n+\n+    pub const SIGBUS: libc::c_int = 10;\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub const SIGSTKSZ: libc::size_t = 131072;\n+    // FreeBSD's is actually arch-dependent, but never more than 40960.\n+    // No harm in being generous.\n+    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+    pub const SIGSTKSZ: libc::size_t = 40960;\n \n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\"))]\n@@ -259,61 +329,53 @@ mod signal {\n     pub struct sigset_t {\n         bits: [u32; 4],\n     }\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+    pub type sigset_t = libc::c_uint;\n \n     // This structure has more fields, but we're not all that interested in\n     // them.\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n+              target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    #[repr(C)]\n+    pub struct siginfo {\n+        pub _signo: libc::c_int,\n+        pub _errno: libc::c_int,\n+        pub _code: libc::c_int,\n+        pub _pid: libc::pid_t,\n+        pub _uid: libc::uid_t,\n+        pub _status: libc::c_int,\n+        pub si_addr: *mut libc::c_void\n+    }\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n     #[repr(C)]\n     pub struct siginfo {\n         pub si_signo: libc::c_int,\n-        pub si_errno: libc::c_int,\n         pub si_code: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+        pub si_errno: libc::c_int,\n+        pub si_addr: *mut libc::c_void\n     }\n \n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n+              target_os = \"bitrig\", target_os = \"openbsd\"))]\n     #[repr(C)]\n     pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_flags: libc::c_int,\n+        pub sa_sigaction: sighandler_t,\n         pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_int,\n     }\n-}\n-\n-#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-mod signal {\n-    use libc;\n \n-    pub const SA_ONSTACK: libc::c_int = 0x0001;\n-    pub const SA_RESTART: libc::c_int = 0x0002;\n-    pub const SA_RESETHAND: libc::c_int = 0x0004;\n-    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;\n-    pub const SA_NODEFER: libc::c_int = 0x0010;\n-    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;\n-    pub const SA_SIGINFO: libc::c_int = 0x0040;\n-    pub const SIGCHLD: libc::c_int = 20;\n-\n-    pub type sigset_t = libc::c_uint;\n-\n-    // This structure has more fields, but we're not all that interested in\n-    // them.\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n     #[repr(C)]\n-    pub struct siginfo {\n-        pub si_signo: libc::c_int,\n-        pub si_code: libc::c_int,\n-        pub si_errno: libc::c_int,\n-        // FIXME: Bitrig has a crazy union here in the siginfo, I think this\n-        // layout will still work tho.  The status might be off by the size of\n-        // a clock_t by my reading, but we can fix this later.\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+    pub struct sigaction {\n+        pub sa_sigaction: sighandler_t,\n+        pub sa_flags: libc::c_int,\n+        pub sa_mask: sigset_t,\n     }\n \n     #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_int,\n+    pub struct sigaltstack {\n+        pub ss_sp: *mut libc::c_void,\n+        pub ss_size: libc::size_t,\n+        pub ss_flags: libc::c_int,\n     }\n }"}, {"sha": "52494a17b9d24f314a44b4504d15fc1e8aa5ce4b", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 5, "deletions": 136, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "patch": "@@ -44,11 +44,12 @@ mod imp {\n     use mem;\n     use ptr;\n     use intrinsics;\n-    use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n-                       SA_SIGINFO, SA_ONSTACK, sigaltstack,\n-                       SIGSTKSZ};\n+    use sys::c::{siginfo, sigaction, SIGBUS, SIG_DFL,\n+                 SA_SIGINFO, SA_ONSTACK, sigaltstack,\n+                 SIGSTKSZ, sighandler_t, raise};\n     use libc;\n     use libc::funcs::posix88::mman::{mmap, munmap};\n+    use libc::funcs::posix01::signal::signal;\n     use libc::consts::os::posix88::{SIGSEGV,\n                                     PROT_READ,\n                                     PROT_WRITE,\n@@ -120,7 +121,7 @@ mod imp {\n \n     pub unsafe fn make_handler() -> Handler {\n         let alt_stack = mmap(ptr::null_mut(),\n-                             signal::SIGSTKSZ,\n+                             SIGSTKSZ,\n                              PROT_READ | PROT_WRITE,\n                              MAP_PRIVATE | MAP_ANON,\n                              -1,\n@@ -143,138 +144,6 @@ mod imp {\n     pub unsafe fn drop_handler(handler: &mut Handler) {\n         munmap(handler._data, SIGSTKSZ);\n     }\n-\n-    pub type sighandler_t = *mut libc::c_void;\n-\n-    #[cfg(any(all(target_os = \"linux\", target_arch = \"x86\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"x86_64\"),\n-              all(target_os = \"linux\", target_arch = \"arm\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"aarch64\"),\n-              all(target_os = \"linux\", target_arch = \"mips\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"mipsel\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"powerpc\"), // may not match\n-              target_os = \"android\"))] // may not match\n-    mod signal {\n-        use libc;\n-        pub use super::sighandler_t;\n-\n-        pub static SA_ONSTACK: libc::c_int = 0x08000000;\n-        pub static SA_SIGINFO: libc::c_int = 0x00000004;\n-        pub static SIGBUS: libc::c_int = 7;\n-\n-        pub static SIGSTKSZ: libc::size_t = 8192;\n-\n-        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n-\n-        // This definition is not as accurate as it could be, {si_addr} is\n-        // actually a giant union. Currently we're only interested in that field,\n-        // however.\n-        #[repr(C)]\n-        pub struct siginfo {\n-            si_signo: libc::c_int,\n-            si_errno: libc::c_int,\n-            si_code: libc::c_int,\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_int,\n-            sa_restorer: *mut libc::c_void,\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        #[repr(C)]\n-        pub struct sigset_t {\n-            __val: [libc::c_ulong; 32],\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        #[repr(C)]\n-        pub struct sigset_t {\n-            __val: [libc::c_ulong; 16],\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_flags: libc::c_int,\n-            pub ss_size: libc::size_t\n-        }\n-\n-    }\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n-    mod signal {\n-        use libc;\n-        pub use super::sighandler_t;\n-\n-        pub const SA_ONSTACK: libc::c_int = 0x0001;\n-        pub const SA_SIGINFO: libc::c_int = 0x0040;\n-        pub const SIGBUS: libc::c_int = 10;\n-\n-        #[cfg(target_os = \"macos\")]\n-        pub const SIGSTKSZ: libc::size_t = 131072;\n-        #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-        pub const SIGSTKSZ: libc::size_t = 40960;\n-\n-        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n-\n-        pub type sigset_t = u32;\n-\n-        // This structure has more fields, but we're not all that interested in\n-        // them.\n-        #[cfg(target_os = \"macos\")]\n-        #[repr(C)]\n-        pub struct siginfo {\n-            pub si_signo: libc::c_int,\n-            pub si_errno: libc::c_int,\n-            pub si_code: libc::c_int,\n-            pub pid: libc::pid_t,\n-            pub uid: libc::uid_t,\n-            pub status: libc::c_int,\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-        #[repr(C)]\n-        pub struct siginfo {\n-            pub si_signo: libc::c_int,\n-            pub si_code: libc::c_int,\n-            pub si_errno: libc::c_int,\n-            //union\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_size: libc::size_t,\n-            pub ss_flags: libc::c_int\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_int,\n-        }\n-    }\n-\n-    extern {\n-        pub fn signal(signum: libc::c_int, handler: sighandler_t) -> sighandler_t;\n-        pub fn raise(signum: libc::c_int) -> libc::c_int;\n-\n-        pub fn sigaction(signum: libc::c_int,\n-                         act: *const sigaction,\n-                         oldact: *mut sigaction) -> libc::c_int;\n-\n-        pub fn sigaltstack(ss: *const sigaltstack,\n-                           oss: *mut sigaltstack) -> libc::c_int;\n-    }\n }\n \n #[cfg(not(any(target_os = \"linux\","}]}