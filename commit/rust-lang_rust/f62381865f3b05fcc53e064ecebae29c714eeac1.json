{"sha": "f62381865f3b05fcc53e064ecebae29c714eeac1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MjM4MTg2NWYzYjA1ZmNjNTNlMDY0ZWNlYmFlMjljNzE0ZWVhYzE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-24T12:01:41Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-24T12:01:41Z"}, "message": "Better monomorphization", "tree": {"sha": "01dffb3180da7bb1b11c770a3de5a85ee9aaedaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01dffb3180da7bb1b11c770a3de5a85ee9aaedaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f62381865f3b05fcc53e064ecebae29c714eeac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f62381865f3b05fcc53e064ecebae29c714eeac1", "html_url": "https://github.com/rust-lang/rust/commit/f62381865f3b05fcc53e064ecebae29c714eeac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f62381865f3b05fcc53e064ecebae29c714eeac1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0479604be1a0ded845b8bb038318db0e92b0d11b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0479604be1a0ded845b8bb038318db0e92b0d11b", "html_url": "https://github.com/rust-lang/rust/commit/0479604be1a0ded845b8bb038318db0e92b0d11b"}], "stats": {"total": 81, "additions": 41, "deletions": 40}, "files": [{"sha": "51c715a2d1e4bd7748bc89534d82df2a0f043b5b", "filename": "src/base.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f62381865f3b05fcc53e064ecebae29c714eeac1", "patch": "@@ -150,13 +150,13 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n     }); // Dummy stack slot for debugging\n \n     let func_params = mir.args_iter().map(|local| {\n-        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(fx.monomorphize(&mir.local_decls[local].ty))).unwrap();\n+        let layout = fx.layout_of(mir.local_decls[local].ty);\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let ty = cton_type_from_ty(mir.local_decls[local].ty);\n+        let ty = fx.cton_type(mir.local_decls[local].ty);\n         (local, fx.bcx.append_ebb_param(start_ebb, ty.unwrap_or(types::I64)), ty, stack_slot)\n     }).collect::<Vec<(Local, Value, Option<Type>, StackSlot)>>();\n \n@@ -174,7 +174,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n     }\n \n     for local in mir.vars_and_temps_iter() {\n-        let layout = cx.tcx.layout_of(ParamEnv::reveal_all().and(mir.local_decls[local].ty)).unwrap();\n+        let layout = fx.layout_of(mir.local_decls[local].ty);\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n@@ -243,7 +243,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n                             .map(|arg| {\n                                 let ty = arg.ty(&fx.mir.local_decls, fx.tcx);\n                                 let arg = trans_operand(fx, arg);\n-                                if let Some(_) = cton_type_from_ty(ty) {\n+                                if let Some(_) = fx.cton_type(ty) {\n                                     arg.load_value(fx, ty)\n                                 } else {\n                                     arg.force_stack(fx, ty)\n@@ -416,9 +416,10 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                     lval.write_cvalue(fx, operand, &dest_ty);\n                 }\n                 Rvalue::Discriminant(place) => {\n+                    let dest_cton_ty = fx.cton_type(&dest_ty).unwrap();\n                     let place_ty = fx.monomorphize(&place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n-                    let cton_place_ty = cton_type_from_ty(&place_ty);\n-                    let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(place_ty)).unwrap();\n+                    let cton_place_ty = fx.cton_type(&place_ty);\n+                    let layout = fx.layout_of(place_ty);\n \n                     if layout.abi == layout::Abi::Uninhabited {\n                         fx.bcx.ins().trap(TrapCode::User(!0));\n@@ -457,11 +458,11 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                             niche_start,\n                             ..\n                         } => {\n-                            let niche_llty = cton_type_from_ty(discr_ty).unwrap();\n+                            let niche_llty = fx.cton_type(discr_ty).unwrap();\n                             if niche_variants.start() == niche_variants.end() {\n                                 let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n-                                let if_true = fx.bcx.ins().iconst(cton_type_from_ty(&dest_ty).unwrap(), *niche_variants.start() as u64 as i64);\n-                                let if_false = fx.bcx.ins().iconst(cton_type_from_ty(&dest_ty).unwrap(), dataful_variant as u64 as i64);\n+                                let if_true = fx.bcx.ins().iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n+                                let if_false = fx.bcx.ins().iconst(dest_cton_ty, dataful_variant as u64 as i64);\n                                 let val = fx.bcx.ins().select(b, if_true, if_false);\n                                 lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n                             } else {\n@@ -520,16 +521,18 @@ fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx\n         Operand::Constant(const_) => {\n             match const_.literal {\n                 Literal::Value { value } => {\n-                    let layout = fx.tcx.layout_of(ParamEnv::empty().and(const_.ty)).unwrap();\n+                    let layout = fx.layout_of(const_.ty);\n                     match const_.ty.sty {\n                         TypeVariants::TyUint(_) => {\n                             let bits = value.to_scalar().unwrap().to_bits(layout.size).unwrap();\n-                            let iconst = fx.bcx.ins().iconst(cton_type_from_ty(const_.ty).unwrap(), bits as u64 as i64);\n+                            let cton_ty = fx.cton_type(const_.ty).unwrap();\n+                            let iconst = fx.bcx.ins().iconst(cton_ty, bits as u64 as i64);\n                             CValue::ByVal(iconst)\n                         }\n                         TypeVariants::TyInt(_) => {\n                             let bits = value.to_scalar().unwrap().to_bits(layout.size).unwrap();\n-                            let iconst = fx.bcx.ins().iconst(cton_type_from_ty(const_.ty).unwrap(), bits as i128 as i64);\n+                            let cton_ty = fx.cton_type(const_.ty).unwrap();\n+                            let iconst = fx.bcx.ins().iconst(cton_ty, bits as i128 as i64);\n                             CValue::ByVal(iconst)\n                         }\n                         TypeVariants::TyFnDef(def_id, substs) => {"}, {"sha": "d753255bfa9b74b9503d20576955ff9eca87aa7c", "filename": "src/common.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f62381865f3b05fcc53e064ecebae29c714eeac1", "patch": "@@ -19,7 +19,7 @@ impl EntityRef for Variable {\n     }\n }\n \n-pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n+fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n     Some(match ty.sty {\n         TypeVariants::TyBool => types::I8,\n         TypeVariants::TyUint(size) => {\n@@ -56,22 +56,6 @@ pub fn fixup_cton_ty(ty: Type) -> Type {\n     }\n }\n \n-pub fn extend_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, ty: Ty) -> Value {\n-    let cton_ty = cton_type_from_ty(ty).unwrap();\n-    let to_ty = match cton_ty {\n-        types::I64 => return val,\n-        types::I32 => return val,\n-        _ => types::I32,\n-    };\n-    match ty.sty {\n-        TypeVariants::TyBool => fx.bcx.ins().uextend(to_ty, val),\n-        TypeVariants::TyUint(_) => fx.bcx.ins().uextend(to_ty, val),\n-        TypeVariants::TyInt(_) => fx.bcx.ins().sextend(to_ty, val),\n-        TypeVariants::TyFnPtr(_) => val,\n-        _ => unimplemented!(),\n-    }\n-}\n-\n // FIXME(cretonne) fix load.i8\n fn load_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, offset: i32) -> Value {\n     use cretonne::codegen::ir::types::*;\n@@ -106,7 +90,7 @@ impl CValue {\n         match self {\n             CValue::ByRef(value) => value,\n             CValue::ByVal(value) => {\n-                let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                let layout = fx.layout_of(ty);\n                 let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                     kind: StackSlotKind::ExplicitSlot,\n                     size: layout.size.bytes() as u32,\n@@ -125,7 +109,7 @@ impl CValue {\n     pub fn load_value<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n         match self {\n             CValue::ByRef(value) => {\n-                let cton_ty = cton_type_from_ty(fx.monomorphize(&ty)).expect(&format!(\"{:?}\", ty));\n+                let cton_ty = fx.cton_type(ty).expect(&format!(\"{:?}\", ty));\n                 load_workaround(fx, cton_ty, value, 0)\n             }\n             CValue::ByVal(value) => value,\n@@ -148,7 +132,7 @@ impl CValue {\n             CValue::ByRef(addr) => addr,\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n-        let layout = fx.tcx.layout_of(ParamEnv::empty().and(fx.monomorphize(&ty))).unwrap();\n+        let layout = fx.layout_of(ty);\n         let field_offset = layout.fields.offset(field.index());\n         if field_offset.bytes() > 0 {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n@@ -159,8 +143,8 @@ impl CValue {\n     }\n \n     pub fn const_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue {\n-        let ty = fx.monomorphize(&ty);\n-        CValue::ByVal(fx.bcx.ins().iconst(cton_type_from_ty(ty).unwrap(), const_val))\n+        let ty = fx.cton_type(ty).unwrap();\n+        CValue::ByVal(fx.bcx.ins().iconst(ty, const_val))\n     }\n }\n \n@@ -190,15 +174,15 @@ impl<'a, 'tcx: 'a> CPlace {\n     }\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n-        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(fx.monomorphize(&ty))).unwrap();\n+        let layout = fx.layout_of(ty);\n         let size = layout.size.bytes() as i32;\n         match self {\n             CPlace::Var(var) => {\n                 let data = from.load_value(fx, ty);\n                 fx.bcx.def_var(var, data)\n             },\n             CPlace::Addr(addr) => {\n-                if let Some(cton_ty) = cton_type_from_ty(ty) {\n+                if let Some(cton_ty) = fx.cton_type(ty) {\n                     let data = from.load_value(fx, ty);\n                     store_workaround(fx, cton_ty, addr, data, 0);\n                 } else {\n@@ -214,7 +198,7 @@ impl<'a, 'tcx: 'a> CPlace {\n \n     pub fn place_field(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field, ty: Ty<'tcx>) -> (CPlace, layout::TyLayout<'tcx>) {\n         let base = self.expect_addr();\n-        let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+        let layout = fx.layout_of(ty);\n         let field_offset = layout.fields.offset(field.index());\n         if field_offset.bytes() > 0 {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n@@ -255,8 +239,8 @@ pub fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signatur\n }\n \n pub fn cton_intcast<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, from: Ty<'tcx>, to: Ty<'tcx>, signed: bool) -> Value {\n-    let from = cton_type_from_ty(from).unwrap();\n-    let to = cton_type_from_ty(to).unwrap();\n+    let from = fx.cton_type(from).unwrap();\n+    let to = fx.cton_type(to).unwrap();\n     if from == to {\n         return val;\n     }\n@@ -283,6 +267,16 @@ pub struct FunctionCx<'a, 'tcx: 'a> {\n     pub local_map: HashMap<Local, CPlace>,\n }\n \n+impl<'a, 'tcx: 'a> LayoutOf for &'a FunctionCx<'a, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> TyLayout<'tcx> {\n+        let ty = self.monomorphize(&ty);\n+        self.tcx.layout_of(ParamEnv::reveal_all().and(&ty)).unwrap()\n+    }\n+}\n+\n impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n@@ -294,6 +288,10 @@ impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n         )\n     }\n \n+    pub fn cton_type(&self, ty: Ty<'tcx>) -> Option<Type> {\n+        cton_type_from_ty(self.monomorphize(&ty))\n+    }\n+\n     pub fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n         *self.ebb_map.get(&bb).unwrap()\n     }"}, {"sha": "39e7a8d82f5782145ae6dbb0558ee488f9260559", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62381865f3b05fcc53e064ecebae29c714eeac1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f62381865f3b05fcc53e064ecebae29c714eeac1", "patch": "@@ -42,7 +42,7 @@ mod prelude {\n     pub use rustc::mir;\n     pub use rustc::mir::*;\n     pub use rustc::session::Session;\n-    pub use rustc::ty::layout;\n+    pub use rustc::ty::layout::{self, LayoutOf, TyLayout};\n     pub use rustc::ty::{\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeFoldable, TypeVariants,"}]}