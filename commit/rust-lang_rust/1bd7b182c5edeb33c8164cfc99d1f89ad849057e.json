{"sha": "1bd7b182c5edeb33c8164cfc99d1f89ad849057e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZDdiMTgyYzVlZGViMzNjODE2NGNmYzk5ZDFmODlhZDg0OTA1N2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T19:36:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:25Z"}, "message": "dataflow -- do not consider the interprocedural case", "tree": {"sha": "2868457e7a1039f5143a7d0974908ae99d2f37f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2868457e7a1039f5143a7d0974908ae99d2f37f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bd7b182c5edeb33c8164cfc99d1f89ad849057e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd7b182c5edeb33c8164cfc99d1f89ad849057e", "html_url": "https://github.com/rust-lang/rust/commit/1bd7b182c5edeb33c8164cfc99d1f89ad849057e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bd7b182c5edeb33c8164cfc99d1f89ad849057e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b8b75142997b12baf374ef6c4721bec5df62849", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8b75142997b12baf374ef6c4721bec5df62849", "html_url": "https://github.com/rust-lang/rust/commit/6b8b75142997b12baf374ef6c4721bec5df62849"}], "stats": {"total": 143, "additions": 23, "deletions": 120}, "files": [{"sha": "5af5aa63e1de66f7e009447eddb829076e70e42a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 23, "deletions": 120, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/1bd7b182c5edeb33c8164cfc99d1f89ad849057e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd7b182c5edeb33c8164cfc99d1f89ad849057e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1bd7b182c5edeb33c8164cfc99d1f89ad849057e", "patch": "@@ -17,7 +17,6 @@\n  */\n \n \n-use std::cast;\n use std::io;\n use std::uint;\n use std::vec;\n@@ -72,9 +71,6 @@ pub trait DataFlowOperator {\n \n     /// Joins two predecessor bits together, typically either `|` or `&`\n     fn join(&self, succ: uint, pred: uint) -> uint;\n-\n-    /// True if we should propagate through closures\n-    fn walk_closures(&self) -> bool;\n }\n \n struct PropagationContext<'a, O> {\n@@ -373,8 +369,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n-               blk.id, bits_to_str(reslice(in_out)));\n+        debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n+               blk.id, bits_to_str(in_out));\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n@@ -425,99 +421,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n-               expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+               expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n         self.merge_with_entry_set(expr.id, in_out);\n \n         match expr.node {\n-            ast::ExprFnBlock(ref decl, body) |\n-            ast::ExprProc(ref decl, body) => {\n-                if self.dfcx.oper.walk_closures() {\n-                    // In the absence of once fns, we must assume that\n-                    // every function body will execute more than\n-                    // once. Thus we treat every function body like a\n-                    // loop.\n-                    //\n-                    // What is subtle and a bit tricky, also, is how\n-                    // to deal with the \"output\" bits---that is, what\n-                    // do we consider to be the successor of a\n-                    // function body, given that it could be called\n-                    // from any point within its lifetime? What we do\n-                    // is to add their effects immediately as of the\n-                    // point of creation. Of course we have to ensure\n-                    // that this is sound for the analyses which make\n-                    // use of dataflow.\n-                    //\n-                    // In the case of the initedness checker (which\n-                    // does not currently use dataflow, but I hope to\n-                    // convert at some point), we will simply not walk\n-                    // closures at all, so it's a moot point.\n-                    //\n-                    // In the case of the borrow checker, this means\n-                    // the loans which would be created by calling a\n-                    // function come into effect immediately when the\n-                    // function is created. This is guaranteed to be\n-                    // earlier than the point at which the loan\n-                    // actually comes into scope (which is the point\n-                    // at which the closure is *called*). Because\n-                    // loans persist until the scope of the loans is\n-                    // exited, it is always a safe approximation to\n-                    // have a loan begin earlier than it actually will\n-                    // at runtime, so this should be sound.\n-                    //\n-                    // We stil have to be careful in the region\n-                    // checker and borrow checker to treat function\n-                    // bodies like loops, which implies some\n-                    // limitations. For example, a closure cannot root\n-                    // a managed box for longer than its body.\n-                    //\n-                    // General control flow looks like this:\n-                    //\n-                    //  +- (expr) <----------+\n-                    //  |    |               |\n-                    //  |    v               |\n-                    //  |  (body) -----------+--> (exit)\n-                    //  |    |               |\n-                    //  |    + (break/loop) -+\n-                    //  |                    |\n-                    //  +--------------------+\n-                    //\n-                    // This is a bit more conservative than a loop.\n-                    // Note that we must assume that even after a\n-                    // `break` occurs (e.g., in a `for` loop) that the\n-                    // closure may be reinvoked.\n-                    //\n-                    // One difference from other loops is that `loop`\n-                    // and `break` statements which target a closure\n-                    // both simply add to the `break_bits`.\n-\n-                    // func_bits represents the state when the function\n-                    // returns\n-                    let mut func_bits = reslice(in_out).to_owned();\n-\n-                    loop_scopes.push(LoopScope {\n-                        loop_id: expr.id,\n-                        break_bits: reslice(in_out).to_owned()\n-                    });\n-                    for input in decl.inputs.iter() {\n-                        self.walk_pat(input.pat, func_bits, loop_scopes);\n-                    }\n-                    self.walk_block(body, func_bits, loop_scopes);\n-\n-                    // add the bits from any early return via `break`,\n-                    // `continue`, or `return` into `func_bits`\n-                    let loop_scope = loop_scopes.pop().unwrap();\n-                    join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n-\n-                    // add `func_bits` to the entry bits for `expr`,\n-                    // since we must assume the function may be called\n-                    // more than once\n-                    self.add_to_entry_set(expr.id, reslice(func_bits));\n-\n-                    // the final exit bits include whatever was present\n-                    // in the original, joined with the bits from the function\n-                    join_bits(&self.dfcx.oper, func_bits, in_out);\n-                }\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n             }\n \n             ast::ExprIf(cond, then, els) => {\n@@ -536,7 +445,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //\n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut then_bits = reslice(in_out).to_owned();\n+                let mut then_bits = in_out.to_owned();\n                 self.walk_block(then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n@@ -558,10 +467,10 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut body_bits = reslice(in_out).to_owned();\n+                let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: reslice(in_out).to_owned()\n+                    break_bits: in_out.to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -581,11 +490,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //    <--+ (break)\n                 //\n \n-                let mut body_bits = reslice(in_out).to_owned();\n+                let mut body_bits = in_out.to_owned();\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: reslice(in_out).to_owned()\n+                    break_bits: in_out.to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -609,7 +518,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //\n                 self.walk_expr(discr, in_out, loop_scopes);\n \n-                let mut guards = reslice(in_out).to_owned();\n+                let mut guards = in_out.to_owned();\n \n                 // We know that exactly one arm will be taken, so we\n                 // can start out with a blank slate and just union\n@@ -622,7 +531,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n-                    let mut body = reslice(guards).to_owned();\n+                    let mut body = guards.to_owned();\n                     self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n                     self.walk_block(arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n@@ -643,7 +552,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             ast::ExprAgain(label) => {\n                 let scope = self.find_scope(expr, label, loop_scopes);\n                 self.pop_scopes(expr, scope, in_out);\n-                self.add_to_entry_set(scope.loop_id, reslice(in_out));\n+                self.add_to_entry_set(scope.loop_id, in_out);\n                 self.reset(in_out);\n             }\n \n@@ -693,7 +602,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n-                let temp = reslice(in_out).to_owned();\n+                let temp = in_out.to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n@@ -756,7 +665,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n         debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n-               bits_to_str(reslice(in_out)));\n+               bits_to_str(in_out));\n \n         let mut id = from_expr.id;\n         while id != to_scope.loop_id {\n@@ -781,11 +690,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n-        debug!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n+        join_bits(&self.dfcx.oper, in_out, to_scope.break_bits);\n+        debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n-               bits_to_str(reslice(in_out)));\n+               bits_to_str(in_out));\n     }\n \n     fn walk_exprs(&mut self,\n@@ -830,10 +739,10 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n-               pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+               pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n         ast_util::walk_pat(pat, |p| {\n-            debug!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n+            debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n@@ -852,7 +761,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         // In the general case, the patterns in `pats` are\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n-        let initial_state = reslice(in_out).to_owned();\n+        let initial_state = in_out.to_owned();\n         for &pat in pats.iter() {\n             let mut temp = initial_state.clone();\n             self.walk_pat(pat, temp, loop_scopes);\n@@ -929,8 +838,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n-            copy_bits(reslice(on_entry), pred_bits);\n+            let changed = join_bits(&self.dfcx.oper, pred_bits, on_entry);\n+            copy_bits(on_entry, pred_bits);\n             changed\n         };\n         if changed {\n@@ -942,7 +851,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n }\n \n fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n-    bits_to_str(reslice(words))\n+    bits_to_str(words)\n }\n \n fn bits_to_str(words: &[uint]) -> ~str {\n@@ -1007,9 +916,3 @@ fn bit_str(bit: uint) -> ~str {\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n-fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {\n-    // bFIXME(#5074) this function should not be necessary at all\n-    unsafe {\n-        cast::transmute(v)\n-    }\n-}"}]}