{"sha": "bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYzMyZGQxMDZmMGZlMTkxYjhiY2Q5Yjc2MzQ4YTg4NzVjMzBhNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T06:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T06:14:52Z"}, "message": "Auto merge of #68505 - skinny121:canonicalize-const-eval-inputs, r=nikomatsakis\n\nCanonicalize inputs to const eval where needed\n\nCanonicalize inputs to const eval, so that they can contain inference variables. Which enables invoking const eval queries even if the current param env has inference variable within it, which can occur during trait selection.\n\nThis is a reattempt of #67717, in a far less invasive way.\n\nFixes #68477\n\nr? @nikomatsakis\ncc @eddyb", "tree": {"sha": "f61b69b4967e3cc831545668768cee807cf10d50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f61b69b4967e3cc831545668768cee807cf10d50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "html_url": "https://github.com/rust-lang/rust/commit/bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7497d93ef17d2b87fa8efb5c5de33f0bdc4155af", "url": "https://api.github.com/repos/rust-lang/rust/commits/7497d93ef17d2b87fa8efb5c5de33f0bdc4155af", "html_url": "https://github.com/rust-lang/rust/commit/7497d93ef17d2b87fa8efb5c5de33f0bdc4155af"}, {"sha": "ebfa2f448efcce8f8121b883ee876653fc098261", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebfa2f448efcce8f8121b883ee876653fc098261", "html_url": "https://github.com/rust-lang/rust/commit/ebfa2f448efcce8f8121b883ee876653fc098261"}], "stats": {"total": 156, "additions": 94, "deletions": 62}, "files": [{"sha": "46bf1d9695796a73caca4ca1e7f90d7462545b40", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -13,13 +13,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn const_eval_poly(self, def_id: DefId) -> ConstEvalResult<'tcx> {\n         // In some situations def_id will have substitutions within scope, but they aren't allowed\n         // to be used. So we can't use `Instance::mono`, instead we feed unresolved substitutions\n-        // into `const_eval` which will return `ErrorHandled::ToGeneric` if any og them are\n+        // into `const_eval` which will return `ErrorHandled::ToGeneric` if any of them are\n         // encountered.\n         let substs = InternalSubsts::identity_for_item(self, def_id);\n         let instance = ty::Instance::new(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n         let param_env = self.param_env(def_id).with_reveal_all();\n-        self.const_eval_validated(param_env.and(cid))\n+        self.const_eval_global_id(param_env, cid, None)\n     }\n \n     /// Resolves and evaluates a constant.\n@@ -41,11 +41,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> ConstEvalResult<'tcx> {\n         let instance = ty::Instance::resolve(self, param_env, def_id, substs);\n         if let Some(instance) = instance {\n-            if let Some(promoted) = promoted {\n-                self.const_eval_promoted(param_env, instance, promoted)\n-            } else {\n-                self.const_eval_instance(param_env, instance, span)\n-            }\n+            let cid = GlobalId { instance, promoted };\n+            self.const_eval_global_id(param_env, cid, span)\n         } else {\n             Err(ErrorHandled::TooGeneric)\n         }\n@@ -57,22 +54,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         instance: ty::Instance<'tcx>,\n         span: Option<Span>,\n     ) -> ConstEvalResult<'tcx> {\n-        let cid = GlobalId { instance, promoted: None };\n-        if let Some(span) = span {\n-            self.at(span).const_eval_validated(param_env.and(cid))\n-        } else {\n-            self.const_eval_validated(param_env.and(cid))\n-        }\n+        self.const_eval_global_id(param_env, GlobalId { instance, promoted: None }, span)\n     }\n \n-    /// Evaluate a promoted constant.\n-    pub fn const_eval_promoted(\n+    /// Evaluate a constant.\n+    pub fn const_eval_global_id(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n-        instance: ty::Instance<'tcx>,\n-        promoted: mir::Promoted,\n+        cid: GlobalId<'tcx>,\n+        span: Option<Span>,\n     ) -> ConstEvalResult<'tcx> {\n-        let cid = GlobalId { instance, promoted: Some(promoted) };\n-        self.const_eval_validated(param_env.and(cid))\n+        // Const-eval shouldn't depend on lifetimes at all, so we can erase them, which should\n+        // improve caching of queries.\n+        let inputs = self.erase_regions(&param_env.and(cid));\n+        if let Some(span) = span {\n+            self.at(span).const_eval_validated(inputs)\n+        } else {\n+            self.const_eval_validated(inputs)\n+        }\n     }\n }"}, {"sha": "69698eabac47b133f382670bea96ac03817c1d2b", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -513,7 +513,7 @@ rustc_queries! {\n         /// returns a proper constant that is usable by the rest of the compiler.\n         ///\n         /// **Do not use this** directly, use one of the following wrappers: `tcx.const_eval_poly`,\n-        /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_promoted`.\n+        /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_global_id`.\n         query const_eval_validated(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx> {\n             no_force"}, {"sha": "283333b6a3db2a3e5e4203a0aa023f9686e707db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -2484,8 +2484,8 @@ impl<'tcx> Const<'tcx> {\n                 // HACK(eddyb) when substs contain e.g. inference variables,\n                 // attempt using identity substs instead, that will succeed\n                 // when the expression doesn't depend on any parameters.\n-                // FIXME(eddyb) make `const_eval` a canonical query instead,\n-                // that would properly handle inference variables in `substs`.\n+                // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n+                // we can call `infcx.const_eval_resolve` which handles inference variables.\n                 if substs.has_local_value() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n                     // The `ParamEnv` needs to match the `identity_substs`."}, {"sha": "26998f0a33c2e00ab4fad7ae89d96170149cba69", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -15,6 +15,8 @@ use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToTy\n use rustc::middle::free_region::RegionRelations;\n use rustc::middle::lang_items;\n use rustc::middle::region;\n+use rustc::mir;\n+use rustc::mir::interpret::ConstEvalResult;\n use rustc::session::config::BorrowckMode;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n@@ -63,6 +65,7 @@ pub mod resolve;\n mod sub;\n pub mod type_variable;\n \n+use crate::infer::canonical::OriginalQueryValues;\n pub use rustc::infer::unify_key;\n \n #[must_use]\n@@ -1563,6 +1566,35 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.universe.set(u);\n         u\n     }\n+\n+    /// Resolves and evaluates a constant.\n+    ///\n+    /// The constant can be located on a trait like `<A as B>::C`, in which case the given\n+    /// substitutions and environment are used to resolve the constant. Alternatively if the\n+    /// constant has generic parameters in scope the substitutions are used to evaluate the value of\n+    /// the constant. For example in `fn foo<T>() { let _ = [0; bar::<T>()]; }` the repeat count\n+    /// constant `bar::<T>()` requires a substitution for `T`, if the substitution for `T` is still\n+    /// too generic for the constant to be evaluated then `Err(ErrorHandled::TooGeneric)` is\n+    /// returned.\n+    ///\n+    /// This handles inferences variables within both `param_env` and `substs` by\n+    /// performing the operation on their respective canonical forms.\n+    pub fn const_eval_resolve(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        promoted: Option<mir::Promoted>,\n+        span: Option<Span>,\n+    ) -> ConstEvalResult<'tcx> {\n+        let mut original_values = OriginalQueryValues::default();\n+        let canonical = self.canonicalize_query(&(param_env, substs), &mut original_values);\n+\n+        let (param_env, substs) = canonical.value;\n+        // The return value is the evaluated value which doesn't contain any reference to inference\n+        // variables, thus we don't need to substitute back the original values.\n+        self.tcx.const_eval_resolve(param_env, def_id, substs, promoted, span)\n+    }\n }\n \n pub struct ShallowResolver<'a, 'tcx> {"}, {"sha": "28d3f26918019d9b97744cbe393bb90ca5165d25", "filename": "src/librustc_infer/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -510,27 +510,15 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                if obligation.param_env.has_local_value() {\n-                    ProcessResult::Unchanged\n-                } else {\n-                    if !substs.has_local_value() {\n-                        match self.selcx.tcx().const_eval_resolve(\n-                            obligation.param_env,\n-                            def_id,\n-                            substs,\n-                            None,\n-                            Some(obligation.cause.span),\n-                        ) {\n-                            Ok(_) => ProcessResult::Changed(vec![]),\n-                            Err(err) => {\n-                                ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err)))\n-                            }\n-                        }\n-                    } else {\n-                        pending_obligation.stalled_on =\n-                            substs.types().map(|ty| infer_ty(ty)).collect();\n-                        ProcessResult::Unchanged\n-                    }\n+                match self.selcx.infcx().const_eval_resolve(\n+                    obligation.param_env,\n+                    def_id,\n+                    substs,\n+                    None,\n+                    Some(obligation.cause.span),\n+                ) {\n+                    Ok(_) => ProcessResult::Changed(vec![]),\n+                    Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n                 }\n             }\n         }"}, {"sha": "c6878fad2a405ce8b6ef8b6cff8c4ae67380aae1", "filename": "src/librustc_infer/traits/select.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fselect.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -532,20 +532,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                if !(obligation.param_env, substs).has_local_value() {\n-                    match self.tcx().const_eval_resolve(\n-                        obligation.param_env,\n-                        def_id,\n-                        substs,\n-                        None,\n-                        None,\n-                    ) {\n-                        Ok(_) => Ok(EvaluatedToOk),\n-                        Err(_) => Ok(EvaluatedToErr),\n-                    }\n-                } else {\n-                    // Inference variables still left in param_env or substs.\n-                    Ok(EvaluatedToAmbig)\n+                match self.tcx().const_eval_resolve(\n+                    obligation.param_env,\n+                    def_id,\n+                    substs,\n+                    None,\n+                    None,\n+                ) {\n+                    Ok(_) => Ok(EvaluatedToOk),\n+                    Err(_) => Ok(EvaluatedToErr),\n                 }\n             }\n         }"}, {"sha": "cce4b90e224e6f1f34c5b84d8c9e10af61ae6e8c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -768,11 +768,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             self.param_env\n         };\n-        let val = if let Some(promoted) = gid.promoted {\n-            self.tcx.const_eval_promoted(param_env, gid.instance, promoted)?\n-        } else {\n-            self.tcx.const_eval_instance(param_env, gid.instance, Some(self.tcx.span))?\n-        };\n+        let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.tcx.span))?;\n \n         // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not"}, {"sha": "925931bc4a635b80fc1848b27a1c93d8d5f25b80", "filename": "src/test/incremental/const-generics/issue-68477.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-68477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc32dd106f0fe191b8bcd9b76348a8875c30a60/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-68477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-68477.rs?ref=bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "patch": "@@ -0,0 +1,23 @@\n+// edition:2018\n+// revisions:rpass1\n+#![feature(const_generics)]\n+\n+const FOO: usize = 1;\n+\n+struct Container<T> {\n+    val: std::marker::PhantomData<T>,\n+    blah: [(); FOO]\n+}\n+\n+async fn dummy() {}\n+\n+async fn foo() {\n+    let a: Container<&'static ()>;\n+    dummy().await;\n+}\n+\n+fn is_send<T: Send>(_: T) {}\n+\n+fn main() {\n+    is_send(foo());\n+}"}]}