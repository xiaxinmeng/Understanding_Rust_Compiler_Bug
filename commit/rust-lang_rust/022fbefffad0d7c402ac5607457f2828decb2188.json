{"sha": "022fbefffad0d7c402ac5607457f2828decb2188", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmZiZWZmZmFkMGQ3YzQwMmFjNTYwNzQ1N2YyODI4ZGVjYjIxODg=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-06-11T20:06:58Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-06-18T07:15:43Z"}, "message": "Apply suggestions from code review", "tree": {"sha": "295bf5d6dfbec9b8eb3edbfce90e7c3748dd8f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/295bf5d6dfbec9b8eb3edbfce90e7c3748dd8f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022fbefffad0d7c402ac5607457f2828decb2188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022fbefffad0d7c402ac5607457f2828decb2188", "html_url": "https://github.com/rust-lang/rust/commit/022fbefffad0d7c402ac5607457f2828decb2188", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022fbefffad0d7c402ac5607457f2828decb2188/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b07c1e77515ae9198aae6275700aacd43181b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b07c1e77515ae9198aae6275700aacd43181b50", "html_url": "https://github.com/rust-lang/rust/commit/4b07c1e77515ae9198aae6275700aacd43181b50"}], "stats": {"total": 393, "additions": 328, "deletions": 65}, "files": [{"sha": "ffd5278ecb627c43f34d123554baea8480a7b7c0", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=022fbefffad0d7c402ac5607457f2828decb2188", "patch": "@@ -26,8 +26,8 @@ use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n     expr::ExprValidator,\n-    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, TraitRef,\n-    Ty, TyDefId, TypeCtor,\n+    method_resolution, ApplicationTy, Canonical, GenericPredicate, InEnvironment, Substs,\n+    TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -1379,8 +1379,17 @@ impl Type {\n         self.ty.value.dyn_trait().map(Into::into)\n     }\n \n-    pub fn as_impl_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n-        self.ty.value.impl_trait_ref(db).map(|it| it.trait_.into())\n+    pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n+        self.ty.value.impl_trait_bounds(db).map(|it| {\n+            it.into_iter()\n+                .filter_map(|pred| match pred {\n+                    hir_ty::GenericPredicate::Implemented(trait_ref) => {\n+                        Some(Trait::from(trait_ref.trait_))\n+                    }\n+                    _ => None,\n+                })\n+                .collect()\n+        })\n     }\n \n     pub fn as_associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n@@ -1410,71 +1419,77 @@ impl Type {\n     }\n \n     pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n-        // TypeWalk::walk does not preserve items order!\n-        fn walk_substs(db: &dyn HirDatabase, substs: &Substs, cb: &mut impl FnMut(Type)) {\n+        // TypeWalk::walk for a Ty at first visits parameters and only after that the Ty itself.\n+        // We need a different order here.\n+\n+        fn walk_substs(\n+            db: &dyn HirDatabase,\n+            type_: &Type,\n+            substs: &Substs,\n+            cb: &mut impl FnMut(Type),\n+        ) {\n             for ty in substs.iter() {\n-                walk_ty(db, ty, cb);\n+                walk_type(db, &type_.derived(ty.clone()), cb);\n             }\n         }\n \n-        fn walk_trait(\n+        fn walk_bounds(\n             db: &dyn HirDatabase,\n-            ty: Ty,\n-            trait_ref: &TraitRef,\n+            type_: &Type,\n+            bounds: &[GenericPredicate],\n             cb: &mut impl FnMut(Type),\n         ) {\n-            let def_db: &dyn DefDatabase = db.upcast();\n-            let resolver = trait_ref.trait_.resolver(def_db);\n-            let krate = trait_ref.trait_.lookup(def_db).container.module(def_db).krate;\n-            cb(Type::new_with_resolver_inner(db, krate, &resolver, ty));\n-            walk_substs(db, &trait_ref.substs, cb);\n+            for pred in bounds {\n+                match pred {\n+                    GenericPredicate::Implemented(trait_ref) => {\n+                        cb(type_.clone());\n+                        walk_substs(db, type_, &trait_ref.substs, cb);\n+                    }\n+                    _ => (),\n+                }\n+            }\n         }\n \n-        fn walk_ty(db: &dyn HirDatabase, ty: &Ty, cb: &mut impl FnMut(Type)) {\n-            let def_db: &dyn DefDatabase = db.upcast();\n-            let ty = ty.strip_references();\n+        fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n+            let ty = type_.ty.value.strip_references();\n             match ty {\n                 Ty::Apply(ApplicationTy { ctor, parameters }) => {\n                     match ctor {\n-                        TypeCtor::Adt(adt) => {\n-                            cb(Type::from_def(db, adt.module(def_db).krate, *adt));\n+                        TypeCtor::Adt(_) => {\n+                            cb(type_.derived(ty.clone()));\n                         }\n                         TypeCtor::AssociatedType(_) => {\n-                            if let Some(trait_id) = ty.associated_type_parent_trait(db) {\n-                                let resolver = trait_id.resolver(def_db);\n-                                let krate = trait_id.lookup(def_db).container.module(def_db).krate;\n-                                cb(Type::new_with_resolver_inner(db, krate, &resolver, ty.clone()));\n+                            if let Some(_) = ty.associated_type_parent_trait(db) {\n+                                cb(type_.derived(ty.clone()));\n                             }\n                         }\n                         _ => (),\n                     }\n \n                     // adt params, tuples, etc...\n-                    walk_substs(db, parameters, cb);\n+                    walk_substs(db, type_, parameters, cb);\n                 }\n                 Ty::Opaque(opaque_ty) => {\n-                    if let Some(trait_ref) = ty.impl_trait_ref(db) {\n-                        walk_trait(db, ty.clone(), &trait_ref, cb);\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n \n-                    walk_substs(db, &opaque_ty.parameters, cb);\n+                    walk_substs(db, type_, &opaque_ty.parameters, cb);\n                 }\n                 Ty::Placeholder(_) => {\n-                    if let Some(trait_ref) = ty.impl_trait_ref(db) {\n-                        walk_trait(db, ty.clone(), &trait_ref, cb);\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n                 }\n-                Ty::Dyn(_) => {\n-                    if let Some(trait_ref) = ty.dyn_trait_ref() {\n-                        walk_trait(db, ty.clone(), trait_ref, cb);\n-                    }\n+                Ty::Dyn(bounds) => {\n+                    walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n                 }\n \n                 _ => (),\n             }\n         }\n \n-        walk_ty(db, &self.ty.value, &mut cb);\n+        walk_type(db, self, &mut cb);\n     }\n }\n "}, {"sha": "f22232324928ebee62191ab2555b8a2b93518a30", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=022fbefffad0d7c402ac5607457f2828decb2188", "patch": "@@ -73,6 +73,7 @@ pub use lower::{\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n pub use chalk_ir::{BoundVar, DebruijnIndex};\n+use itertools::Itertools;\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n@@ -815,6 +816,11 @@ impl Ty {\n         }\n     }\n \n+    /// If this is a `dyn Trait`, returns that trait.\n+    pub fn dyn_trait(&self) -> Option<TraitId> {\n+        self.dyn_trait_ref().map(|it| it.trait_)\n+    }\n+\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -867,18 +873,7 @@ impl Ty {\n         }\n     }\n \n-    /// If this is a `dyn Trait`, returns that trait.\n-    pub fn dyn_trait(&self) -> Option<TraitId> {\n-        match self {\n-            Ty::Dyn(predicates) => predicates.iter().find_map(|pred| match pred {\n-                GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                _ => None,\n-            }),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn impl_trait_ref(&self, db: &dyn HirDatabase) -> Option<TraitRef> {\n+    pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<GenericPredicate>> {\n         match self {\n             Ty::Opaque(opaque_ty) => {\n                 let predicates = match opaque_ty.opaque_ty_id {\n@@ -892,25 +887,21 @@ impl Ty {\n                     }\n                 };\n \n-                predicates.and_then(|it| {\n-                    it.value.iter().find_map(|pred| match pred {\n-                        GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-                        _ => None,\n-                    })\n-                })\n+                predicates.map(|it| it.value)\n             }\n             Ty::Placeholder(id) => {\n                 let generic_params = db.generic_params(id.parent);\n                 let param_data = &generic_params.types[id.local_id];\n                 match param_data.provenance {\n-                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => db\n-                        .generic_predicates_for_param(*id)\n-                        .into_iter()\n-                        .map(|pred| pred.value.clone())\n-                        .find_map(|pred| match pred {\n-                            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-                            _ => None,\n-                        }),\n+                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n+                        let predicates = db\n+                            .generic_predicates_for_param(*id)\n+                            .into_iter()\n+                            .map(|pred| pred.value.clone())\n+                            .collect_vec();\n+\n+                        Some(predicates)\n+                    }\n                     _ => None,\n                 }\n             }\n@@ -926,6 +917,12 @@ impl Ty {\n                     _ => None,\n                 }\n             }\n+            Ty::Projection(projection_ty) => {\n+                match projection_ty.associated_ty.lookup(db.upcast()).container {\n+                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n+                    _ => None,\n+                }\n+            }\n             _ => None,\n         }\n     }\n@@ -1104,10 +1101,10 @@ pub enum OpaqueTyId {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ReturnTypeImplTraits {\n-    pub impl_traits: Vec<ReturnTypeImplTrait>,\n+    pub(crate) impl_traits: Vec<ReturnTypeImplTrait>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ReturnTypeImplTrait {\n+pub(crate) struct ReturnTypeImplTrait {\n     pub bounds: Binders<Vec<GenericPredicate>>,\n }"}, {"sha": "d870e4cbce63587f16ea696ef1d2df93d11c04fb", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 253, "deletions": 2, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022fbefffad0d7c402ac5607457f2828decb2188/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=022fbefffad0d7c402ac5607457f2828decb2188", "patch": "@@ -248,8 +248,8 @@ fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n                     push_new_def(adt.into());\n                 } else if let Some(trait_) = t.as_dyn_trait() {\n                     push_new_def(trait_.into());\n-                } else if let Some(trait_) = t.as_impl_trait(db) {\n-                    push_new_def(trait_.into());\n+                } else if let Some(traits) = t.as_impl_traits(db) {\n+                    traits.into_iter().for_each(|it| push_new_def(it.into()));\n                 } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n                     push_new_def(trait_.into());\n                 }\n@@ -1734,6 +1734,176 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \"###);\n     }\n \n+    #[test]\n+    fn test_hover_return_impl_traits_has_goto_type_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /main.rs\n+            trait Foo {}\n+            trait Bar {}\n+\n+            fn foo() -> impl Foo + Bar {}\n+\n+            fn main() {\n+                let s<|>t = foo();\n+            }\n+            \",\n+            &[\"impl Foo + Bar\"],\n+        );\n+        assert_debug_snapshot!(actions,\n+            @r###\"\n+            [\n+                GoToType(\n+                    [\n+                        HoverGotoTypeData {\n+                            mod_path: \"Foo\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 0..12,\n+                                name: \"Foo\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    6..9,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Foo\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"Bar\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 13..25,\n+                                name: \"Bar\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    19..22,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Bar\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                    ],\n+                ),\n+            ]\n+            \"###);\n+    }\n+\n+    #[test]\n+    fn test_hover_generic_return_impl_traits_has_goto_type_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /main.rs\n+            trait Foo<T> {}\n+            trait Bar<T> {}\n+            struct S1 {}\n+            struct S2 {}\n+\n+            fn foo() -> impl Foo<S1> + Bar<S2> {}\n+\n+            fn main() {\n+                let s<|>t = foo();\n+            }\n+            \",\n+            &[\"impl Foo<S1> + Bar<S2>\"],\n+        );\n+        assert_debug_snapshot!(actions,\n+            @r###\"\n+            [\n+                GoToType(\n+                    [\n+                        HoverGotoTypeData {\n+                            mod_path: \"Foo\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 0..15,\n+                                name: \"Foo\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    6..9,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Foo\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"Bar\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 16..31,\n+                                name: \"Bar\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    22..25,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Bar\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"S1\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 32..44,\n+                                name: \"S1\",\n+                                kind: STRUCT_DEF,\n+                                focus_range: Some(\n+                                    39..41,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"struct S1\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"S2\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 45..57,\n+                                name: \"S2\",\n+                                kind: STRUCT_DEF,\n+                                focus_range: Some(\n+                                    52..54,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"struct S2\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                    ],\n+                ),\n+            ]\n+               \"###);\n+    }\n+\n     #[test]\n     fn test_hover_arg_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n@@ -1774,6 +1944,87 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \"###);\n     }\n \n+    #[test]\n+    fn test_hover_arg_impl_traits_has_goto_type_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            trait Foo {}\n+            trait Bar<T> {}\n+            struct S{}\n+\n+            fn foo(ar<|>g: &impl Foo + Bar<S>) {}\n+            \",\n+            &[\"&impl Foo + Bar<S>\"],\n+        );\n+        assert_debug_snapshot!(actions,\n+            @r###\"\n+            [\n+                GoToType(\n+                    [\n+                        HoverGotoTypeData {\n+                            mod_path: \"Foo\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 0..12,\n+                                name: \"Foo\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    6..9,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Foo\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"Bar\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 13..28,\n+                                name: \"Bar\",\n+                                kind: TRAIT_DEF,\n+                                focus_range: Some(\n+                                    19..22,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"trait Bar\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                        HoverGotoTypeData {\n+                            mod_path: \"S\",\n+                            nav: NavigationTarget {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                full_range: 29..39,\n+                                name: \"S\",\n+                                kind: STRUCT_DEF,\n+                                focus_range: Some(\n+                                    36..37,\n+                                ),\n+                                container_name: None,\n+                                description: Some(\n+                                    \"struct S\",\n+                                ),\n+                                docs: None,\n+                            },\n+                        },\n+                    ],\n+                ),\n+            ]\n+            \"###);\n+    }\n+\n     #[test]\n     fn test_hover_arg_generic_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result("}]}