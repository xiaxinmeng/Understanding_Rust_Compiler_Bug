{"sha": "8a28c172a128dee00debcf828e2243e94d56fb5f", "node_id": "C_kwDOAAsO6NoAKDhhMjhjMTcyYTEyOGRlZTAwZGViY2Y4MjhlMjI0M2U5NGQ1NmZiNWY", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-13T04:23:55Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-13T05:48:46Z"}, "message": "Instead of checking for exact bounds, try to prove them", "tree": {"sha": "e0603a04a343460278779bc2756a71decf124c99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0603a04a343460278779bc2756a71decf124c99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a28c172a128dee00debcf828e2243e94d56fb5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a28c172a128dee00debcf828e2243e94d56fb5f", "html_url": "https://github.com/rust-lang/rust/commit/8a28c172a128dee00debcf828e2243e94d56fb5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a28c172a128dee00debcf828e2243e94d56fb5f/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7fd79ac1d485ab47b62146f6dafed4aad5d9c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7fd79ac1d485ab47b62146f6dafed4aad5d9c6d", "html_url": "https://github.com/rust-lang/rust/commit/f7fd79ac1d485ab47b62146f6dafed4aad5d9c6d"}], "stats": {"total": 290, "additions": 213, "deletions": 77}, "files": [{"sha": "e93cdf7942118033c722eb3e2b34976730a769ff", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n-pub struct RegionRelations<'a, 'tcx> {\n+pub(crate) struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The context used for debug messages"}, {"sha": "a5ec84a4f14469591e8fe8fc07b616d1a65cdf63", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -28,7 +28,7 @@ use std::fmt;\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n #[instrument(level = \"debug\", skip(region_rels, var_infos, data))]\n-pub fn resolve<'tcx>(\n+pub(crate) fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,"}, {"sha": "6fba3d3ad08dfa6749567725efee5d3daba906da", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 102, "deletions": 35, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -14,8 +14,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n+use rustc_infer::traits::TraitEngine;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -26,7 +27,9 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, TraitEngineExt, WellFormedLoc,\n+};\n \n use std::convert::TryInto;\n use std::iter;\n@@ -426,42 +429,105 @@ fn check_gat_where_clauses(\n         }\n     }\n \n-    // If there are any missing clauses, emit an error\n-    let mut clauses = clauses.unwrap_or_default();\n+    // If there are any clauses that aren't provable, emit an error\n+    let clauses = clauses.unwrap_or_default();\n     debug!(?clauses);\n     if !clauses.is_empty() {\n-        let written_predicates: ty::GenericPredicates<'_> =\n-            tcx.explicit_predicates_of(trait_item.def_id);\n-        let mut clauses: Vec<_> = clauses\n-            .drain_filter(|clause| !written_predicates.predicates.iter().any(|p| &p.0 == clause))\n-            .map(|clause| format!(\"{}\", clause))\n-            .collect();\n-        // We sort so that order is predictable\n-        clauses.sort();\n-        if !clauses.is_empty() {\n-            let mut err = tcx.sess.struct_span_err(\n-                trait_item.span,\n-                &format!(\"Missing required bounds on {}\", trait_item.ident),\n-            );\n+        let param_env = tcx.param_env(trait_item.def_id);\n \n-            let suggestion = format!(\n-                \"{} {}\",\n-                if !trait_item.generics.where_clause.predicates.is_empty() {\n-                    \",\"\n-                } else {\n-                    \" where\"\n-                },\n-                clauses.join(\", \"),\n-            );\n-            err.span_suggestion(\n-                trait_item.generics.where_clause.tail_span_for_suggestion(),\n-                \"add the required where clauses\",\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n+        // This shouldn't really matter, but we need it\n+        let cause = traits::ObligationCause::new(\n+            trait_item.span,\n+            trait_item.hir_id(),\n+            ObligationCauseCode::MiscObligation,\n+        );\n+        // Create an `InferCtxt` to try to prove the clauses we require\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(tcx);\n+\n+            // Register all the clauses as obligations\n+            clauses\n+                .clone()\n+                .into_iter()\n+                .map(|predicate| {\n+                    traits::Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        predicate,\n+                    )\n+                })\n+                .for_each(|obligation| {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation)\n+                });\n+\n+            // Convert these obligations into constraints by selecting\n+            let errors = fulfillment_cx.select_all_or_error(&infcx);\n+            if !errors.is_empty() {\n+                bug!(\"should have only registered region obligations, which get registerd as constraints\");\n+            }\n \n-            err.emit()\n-        }\n+            // FIXME(jackh726): some of this code is shared with `regionctxt`, but in a different\n+            // flow; we could probably better extract the shared logic\n+\n+            // Process the region obligations\n+            let body_id_map = infcx\n+                .inner\n+                .borrow()\n+                .region_obligations()\n+                .iter()\n+                .map(|&(id, _)| (id, vec![]))\n+                .collect();\n+\n+            infcx.process_registered_region_obligations(&body_id_map, None, param_env);\n+\n+            // Resolve the region constraints to find any constraints that we're provable\n+            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let errors = infcx.resolve_regions(trait_item.def_id.to_def_id(), &outlives_env, RegionckMode::default());\n+\n+            // Emit an error if there are non-provable constriants\n+            if !errors.is_empty() {\n+                let mut clauses: Vec<_> = errors.into_iter().map(|error| match error {\n+                    RegionResolutionError::ConcreteFailure(_, sup, sub) => format!(\"{}: {}\", sub, sup),\n+                    RegionResolutionError::GenericBoundFailure(_, sub, sup) => format!(\"{}: {}\", sub, sup),\n+                    _ => bug!(\"Unexpected region resolution error when resolving outlives lint\"),\n+                }).collect();\n+                clauses.sort();\n+\n+                let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n+                let mut err = tcx.sess.struct_span_err(\n+                    trait_item.span,\n+                    &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n+                );\n+\n+                let suggestion = format!(\n+                    \"{} {}\",\n+                    if !trait_item.generics.where_clause.predicates.is_empty() {\n+                        \",\"\n+                    } else {\n+                        \" where\"\n+                    },\n+                    clauses.join(\", \"),\n+                );\n+                err.span_suggestion(\n+                    trait_item.generics.where_clause.tail_span_for_suggestion(),\n+                    &format!(\"add the required where clause{}\", plural),\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+\n+                let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n+                err.note(\n+                    &format!(\"{} required to ensure that impls have maximum flexibility\", bound)\n+                );\n+                err.note(\n+                    \"see issue #87479 \\\n+                     <https://github.com/rust-lang/rust/issues/87479> \\\n+                     for more information\",\n+                );\n+\n+                err.emit()\n+            }\n+        });\n     }\n }\n \n@@ -541,7 +607,8 @@ fn region_known_to_outlive<'tcx>(\n         });\n \n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-        (&infcx).push_sub_region_constraint(origin, region_a, region_b);\n+        // `region_a: region_b` -> `region_b <= region_a`\n+        (&infcx).push_sub_region_constraint(origin, region_b, region_a);\n \n         let errors = infcx.resolve_regions(\n             id.expect_owner().to_def_id(),"}, {"sha": "5863bac2f9d0bdb19f7eb1a8840c7fb39b988bb9", "filename": "src/test/ui/generic-associated-types/issue-86787.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -9,7 +9,7 @@ enum Either<L, R> {\n pub trait HasChildrenOf {\n     type T;\n     type TRef<'a>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n \n     fn ref_children<'a>(&'a self) -> Vec<Self::TRef<'a>>;\n     fn take_children(self) -> Vec<Self::T>;"}, {"sha": "18b1c22685b0cfd19ec8044bc9c9912d5e3c5b23", "filename": "src/test/ui/generic-associated-types/issue-86787.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -1,10 +1,13 @@\n-error: Missing required bounds on TRef\n+error: missing required bound on `TRef`\n   --> $DIR/issue-86787.rs:11:5\n    |\n LL |     type TRef<'a>;\n    |     ^^^^^^^^^^^^^-\n    |                  |\n-   |                  help: add the required where clauses: `where Self: 'a`\n+   |                  help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n error: aborting due to previous error\n "}, {"sha": "37b3a6155d5aee89a1cb8854944039e2c4991fad", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n // We have a `&'a self`, so we need a `Self: 'a`\n trait Iterable {\n     type Item<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn iter<'a>(&'a self) -> Self::Item<'a>;\n }\n \n@@ -23,7 +23,7 @@ impl<T> Iterable for T {\n // We have a `&'a T`, so we need a `T: 'x`\n trait Deserializer<T> {\n     type Out<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a>;\n }\n \n@@ -37,14 +37,14 @@ impl<T> Deserializer<T> for () {\n // We have a `&'b T` and a `'b: 'a`, so it is implied that `T: 'a`. Therefore, we need a `T: 'x`\n trait Deserializer2<T> {\n     type Out<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize2<'a, 'b: 'a>(&self, input1: &'b T) -> Self::Out<'a>;\n }\n \n // We have a `&'a T` and a `&'b U`, so we need a `T: 'x` and a `U: 'y`\n trait Deserializer3<T, U> {\n     type Out<'x, 'y>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize2<'a, 'b>(&self, input: &'a T, input2: &'b U) -> Self::Out<'a, 'b>;\n }\n \n@@ -59,7 +59,7 @@ struct Wrap<T>(T);\n // We pass `Wrap<T>` and we see `&'z Wrap<T>`, so we require `D: 'x`\n trait Des {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n }\n /*\n@@ -75,7 +75,7 @@ impl Des for () {\n // implied bound that `T: 'z`, so we require `D: 'x`\n trait Des2 {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, T>;\n }\n /*\n@@ -90,7 +90,7 @@ impl Des2 for () {\n // We see `&'z T`, so we require `D: 'x`\n trait Des3 {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z T) -> Self::Out<'z, T>;\n }\n /*\n@@ -112,22 +112,22 @@ trait NoGat<'a> {\n // FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n trait TraitLifetime<'a> {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method(&'a self) -> Self::Bar<'a>;\n }\n \n // Like above, but we have a where clause that can prove what we want\n // FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n trait TraitLifetimeWhere<'a> where Self: 'a {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method(&'a self) -> Self::Bar<'a>;\n }\n \n // Explicit bound instead of implicit; we want to still error\n trait ExplicitBound {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method<'b>(&self, token: &'b ()) -> Self::Bar<'b> where Self: 'b;\n }\n \n@@ -141,14 +141,15 @@ trait NotInReturn {\n trait IterableTwo {\n     type Item<'a>;\n     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n }\n \n-// We also should report region outlives clauses\n+// We also should report region outlives clauses. Here, we know that `'y: 'x`,\n+// because of `&'x &'y`, so we require that `'b: 'a`.\n trait RegionOutlives {\n     type Bar<'a, 'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y>;\n }\n \n@@ -161,6 +162,17 @@ impl Foo for () {\n }\n */\n \n+// Similar to the above, except with explicit bounds\n+trait ExplicitRegionOutlives<'ctx> {\n+    type Fut<'out>;\n+    //~^ missing required\n+\n+    fn test<'out>(ctx: &'ctx i32) -> Self::Fut<'out>\n+    where\n+        'ctx: 'out;\n+}\n+\n+\n // If there are multiple methods that return the GAT, require a set of clauses\n // that can be satisfied by *all* methods\n trait MultipleMethods {\n@@ -170,4 +182,11 @@ trait MultipleMethods {\n     fn gimme_default(&self) -> Self::Bar<'static>;\n }\n \n+// We would normally require `Self: 'a`, but we can prove that `Self: 'static`\n+// because of the the bounds on the trait, so the bound is proven\n+trait Trait: 'static {\n+    type Assoc<'a>;\n+    fn make_assoc(_: &u32) -> Self::Assoc<'_>;\n+}\n+\n fn main() {}"}, {"sha": "c82dcdae20479b918ec3b1b65324f106121e3893", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a28c172a128dee00debcf828e2243e94d56fb5f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=8a28c172a128dee00debcf828e2243e94d56fb5f", "patch": "@@ -1,98 +1,145 @@\n-error: Missing required bounds on Item\n+error: missing required bound on `Item`\n   --> $DIR/self-outlives-lint.rs:9:5\n    |\n LL |     type Item<'x>;\n    |     ^^^^^^^^^^^^^-\n    |                  |\n-   |                  help: add the required where clauses: `where Self: 'x`\n+   |                  help: add the required where clause: `where Self: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:25:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where T: 'x`\n+   |                 help: add the required where clause: `where T: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:39:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where T: 'x`\n+   |                 help: add the required where clause: `where T: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bounds on `Out`\n   --> $DIR/self-outlives-lint.rs:46:5\n    |\n LL |     type Out<'x, 'y>;\n    |     ^^^^^^^^^^^^^^^^-\n    |                     |\n    |                     help: add the required where clauses: `where T: 'x, U: 'y`\n+   |\n+   = note: these bounds are required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:61:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:77:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:92:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bounds on `Bar`\n   --> $DIR/self-outlives-lint.rs:114:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n    |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+   |\n+   = note: these bounds are required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bound on `Bar`\n   --> $DIR/self-outlives-lint.rs:122:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+   |                 help: add the required where clause: `where Self: 'b`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bound on `Bar`\n   --> $DIR/self-outlives-lint.rs:129:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where Self: 'b`\n+   |                 help: add the required where clause: `where Self: 'b`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Iterator\n+error: missing required bound on `Iterator`\n   --> $DIR/self-outlives-lint.rs:143:5\n    |\n LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n    |                                                       |\n-   |                                                       help: add the required where clauses: `where Self: 'a`\n+   |                                                       help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n-  --> $DIR/self-outlives-lint.rs:150:5\n+error: missing required bound on `Bar`\n+  --> $DIR/self-outlives-lint.rs:151:5\n    |\n LL |     type Bar<'a, 'b>;\n    |     ^^^^^^^^^^^^^^^^-\n    |                     |\n-   |                     help: add the required where clauses: `where 'a: 'b`\n+   |                     help: add the required where clause: `where 'b: 'a`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n+error: missing required bound on `Fut`\n+  --> $DIR/self-outlives-lint.rs:167:5\n+   |\n+LL |     type Fut<'out>;\n+   |     ^^^^^^^^^^^^^^-\n+   |                   |\n+   |                   help: add the required where clause: `where 'ctx: 'out`\n+   |\n+   = note: this bound is required to ensure that impls have maximum flexibility\n+   = note: see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}]}