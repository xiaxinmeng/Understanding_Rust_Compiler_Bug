{"sha": "da2ac908126ec52e60e621416ce84284e7b77e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMmFjOTA4MTI2ZWM1MmU2MGU2MjE0MTZjZTg0Mjg0ZTdiNzdlNTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T05:37:22Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:57Z"}, "message": "libstd: Remove mutable fields from fileinput and net_tcp", "tree": {"sha": "d5ce8ad18f24bd27bd072739be1b026241545863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ce8ad18f24bd27bd072739be1b026241545863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da2ac908126ec52e60e621416ce84284e7b77e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da2ac908126ec52e60e621416ce84284e7b77e51", "html_url": "https://github.com/rust-lang/rust/commit/da2ac908126ec52e60e621416ce84284e7b77e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da2ac908126ec52e60e621416ce84284e7b77e51/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a65f51d666855d7685850808cc06e49c3d21c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a65f51d666855d7685850808cc06e49c3d21c72", "html_url": "https://github.com/rust-lang/rust/commit/5a65f51d666855d7685850808cc06e49c3d21c72"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "90774d19595abdcb6ef0756e3fc0ac233b841efa", "filename": "src/libstd/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ac908126ec52e60e621416ce84284e7b77e51/src%2Flibstd%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ac908126ec52e60e621416ce84284e7b77e51/src%2Flibstd%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffileinput.rs?ref=da2ac908126ec52e60e621416ce84284e7b77e51", "patch": "@@ -145,7 +145,7 @@ struct FileInput_ {\n // \"self.fi.\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    priv mut fi: FileInput_\n+    priv fi: @mut FileInput_\n }\n \n impl FileInput {\n@@ -170,7 +170,7 @@ impl FileInput {\n     pub fn from_vec_raw(files: ~[Option<Path>])\n                                          -> FileInput {\n         FileInput{\n-            fi: FileInput_ {\n+            fi: @mut FileInput_ {\n                 files: files,\n                 current_reader: None,\n                 state: FileInputState {"}, {"sha": "e8c38be74c7d24f62e3436cae68daafbaa55a942", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da2ac908126ec52e60e621416ce84284e7b77e51/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ac908126ec52e60e621416ce84284e7b77e51/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=da2ac908126ec52e60e621416ce84284e7b77e51", "patch": "@@ -71,14 +71,14 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n  * satisfy both the `io::Reader` and `io::Writer` traits.\n  */\n pub struct TcpSocketBuf {\n-    data: @TcpBufferedSocketData,\n-    mut end_of_stream: bool\n+    data: @mut TcpBufferedSocketData,\n+    end_of_stream: @mut bool\n }\n \n-pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n+pub fn TcpSocketBuf(data: @mut TcpBufferedSocketData) -> TcpSocketBuf {\n     TcpSocketBuf {\n         data: data,\n-        end_of_stream: false\n+        end_of_stream: @mut false\n     }\n }\n \n@@ -670,7 +670,7 @@ fn listen_common(host_ip: ip::IpAddr,\n             &ip::Ipv4(_) => { false }\n             &ip::Ipv6(_) => { true }\n         },\n-        mut active: true\n+        active: @mut true\n     };\n     let server_data_ptr: *TcpListenFcData = &server_data;\n \n@@ -751,7 +751,7 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\n                         \"tcp::listen post-kill recv hl interact %?\",\n                              loop_ptr);\n-                    (*server_data_ptr).active = false;\n+                    *(*server_data_ptr).active = false;\n                     uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n             };\n@@ -782,7 +782,7 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\n                         \"tcp::listen post-kill recv hl interact %?\",\n                              loop_ptr);\n-                    (*server_data_ptr).active = false;\n+                    *(*server_data_ptr).active = false;\n                     uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n             };\n@@ -816,8 +816,8 @@ fn listen_common(host_ip: ip::IpAddr,\n  * A buffered wrapper that you can cast as an `io::Reader` or `io::Writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@TcpBufferedSocketData {\n-        sock: sock, mut buf: ~[], buf_off: 0\n+    TcpSocketBuf(@mut TcpBufferedSocketData {\n+        sock: sock, buf: ~[], buf_off: 0\n     })\n }\n \n@@ -902,12 +902,13 @@ impl io::Reader for TcpSocketBuf {\n           // need to read in data from the socket. Note that the internal\n           // buffer is of no use anymore as we read all bytes from it,\n           // so we can throw it away.\n-          let read_result = read(&self.data.sock, 0u);\n+          let data = &*self.data;\n+          let read_result = read(&data.sock, 0u);\n           if read_result.is_err() {\n               let err_data = read_result.get_err();\n \n               if err_data.err_name == ~\"EOF\" {\n-                  self.end_of_stream = true;\n+                  *self.end_of_stream = true;\n                   break;\n               } else {\n                   debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n@@ -934,12 +935,13 @@ impl io::Reader for TcpSocketBuf {\n             return c as int\n           }\n \n-          let read_result = read(&self.data.sock, 0u);\n+          let data = &*self.data;\n+          let read_result = read(&data.sock, 0u);\n           if read_result.is_err() {\n               let err_data = read_result.get_err();\n \n               if err_data.err_name == ~\"EOF\" {\n-                  self.end_of_stream = true;\n+                  *self.end_of_stream = true;\n                   return -1\n               } else {\n                   debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n@@ -954,7 +956,7 @@ impl io::Reader for TcpSocketBuf {\n         }\n     }\n     fn eof(&self) -> bool {\n-        self.end_of_stream\n+        *self.end_of_stream\n     }\n     fn seek(&self, dist: int, seek: io::SeekStyle) {\n         debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n@@ -1204,7 +1206,7 @@ struct TcpListenFcData {\n     on_connect_cb: ~fn(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n-    mut active: bool,\n+    active: @mut bool,\n }\n \n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n@@ -1222,15 +1224,15 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n             as *TcpListenFcData;\n         let kill_ch = (*server_data_ptr).kill_ch.clone();\n-        if (*server_data_ptr).active {\n+        if *(*server_data_ptr).active {\n             match status {\n               0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n               _ => {\n                 let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n                 kill_ch.send(\n                            Some(uv::ll::get_last_err_data(loop_ptr)\n                                 .to_tcp_err()));\n-                (*server_data_ptr).active = false;\n+                *(*server_data_ptr).active = false;\n               }\n             }\n         }\n@@ -1430,8 +1432,8 @@ struct TcpSocketData {\n \n struct TcpBufferedSocketData {\n     sock: TcpSocket,\n-    mut buf: ~[u8],\n-    mut buf_off: uint\n+    buf: ~[u8],\n+    buf_off: uint\n }\n \n #[cfg(test)]"}]}