{"sha": "06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YTBlNGY3YWU2ZDJlMjNhZGZmMWZlODRlMmE5ODhmNmI3N2ZhNTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T23:16:02Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T23:24:25Z"}, "message": "rustc: move `expr_is_lval` to rustc_typeck and rename to `is_place_expr`.", "tree": {"sha": "e80640bd81570bbfb7866ef45e5e107c0f903cfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e80640bd81570bbfb7866ef45e5e107c0f903cfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "html_url": "https://github.com/rust-lang/rust/commit/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "html_url": "https://github.com/rust-lang/rust/commit/3f4a489f8fc73138cde77bcf10497d5f209d3b3a"}], "stats": {"total": 117, "additions": 58, "deletions": 59}, "files": [{"sha": "f52f2ea0f9fc8258b9d93964c6694a1da0cb9e9a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "patch": "@@ -2177,60 +2177,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n-         match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n-                    _ => false,\n-                }\n-            }\n-\n-            hir::ExprType(ref e, _) => {\n-                self.expr_is_lval(e)\n-            }\n-\n-            hir::ExprUnary(hir::UnDeref, _) |\n-            hir::ExprField(..) |\n-            hir::ExprTupField(..) |\n-            hir::ExprIndex(..) => {\n-                true\n-            }\n-\n-            // Partially qualified paths in expressions can only legally\n-            // refer to associated items which are always rvalues.\n-            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprCall(..) |\n-            hir::ExprMethodCall(..) |\n-            hir::ExprStruct(..) |\n-            hir::ExprTup(..) |\n-            hir::ExprIf(..) |\n-            hir::ExprMatch(..) |\n-            hir::ExprClosure(..) |\n-            hir::ExprBlock(..) |\n-            hir::ExprRepeat(..) |\n-            hir::ExprArray(..) |\n-            hir::ExprBreak(..) |\n-            hir::ExprAgain(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprWhile(..) |\n-            hir::ExprLoop(..) |\n-            hir::ExprAssign(..) |\n-            hir::ExprInlineAsm(..) |\n-            hir::ExprAssignOp(..) |\n-            hir::ExprLit(_) |\n-            hir::ExprUnary(..) |\n-            hir::ExprBox(..) |\n-            hir::ExprAddrOf(..) |\n-            hir::ExprBinary(..) |\n-            hir::ExprYield(..) |\n-            hir::ExprCast(..) => {\n-                false\n-            }\n-        }\n-    }\n-\n     pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n         self.associated_items(id)\n             .filter(|item| item.kind == AssociatedKind::Method && item.defaultness.has_value())"}, {"sha": "1313b86f7dc0b9555f5e20cb6cd4f162f902f2c1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "patch": "@@ -2221,6 +2221,60 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n+         match expr.node {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            hir::ExprType(ref e, _) => {\n+                self.is_place_expr(e)\n+            }\n+\n+            hir::ExprUnary(hir::UnDeref, _) |\n+            hir::ExprField(..) |\n+            hir::ExprTupField(..) |\n+            hir::ExprIndex(..) => {\n+                true\n+            }\n+\n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n+\n+            hir::ExprCall(..) |\n+            hir::ExprMethodCall(..) |\n+            hir::ExprStruct(..) |\n+            hir::ExprTup(..) |\n+            hir::ExprIf(..) |\n+            hir::ExprMatch(..) |\n+            hir::ExprClosure(..) |\n+            hir::ExprBlock(..) |\n+            hir::ExprRepeat(..) |\n+            hir::ExprArray(..) |\n+            hir::ExprBreak(..) |\n+            hir::ExprAgain(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprWhile(..) |\n+            hir::ExprLoop(..) |\n+            hir::ExprAssign(..) |\n+            hir::ExprInlineAsm(..) |\n+            hir::ExprAssignOp(..) |\n+            hir::ExprLit(_) |\n+            hir::ExprUnary(..) |\n+            hir::ExprBox(..) |\n+            hir::ExprAddrOf(..) |\n+            hir::ExprBinary(..) |\n+            hir::ExprYield(..) |\n+            hir::ExprCast(..) => {\n+                false\n+            }\n+        }\n+    }\n+\n     /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n@@ -3627,7 +3681,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n                     ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                        if self.tcx.expr_is_lval(&oprnd) {\n+                        if self.is_place_expr(&oprnd) {\n                             // Lvalues may legitimately have unsized types.\n                             // For example, dereferences of a fat pointer and\n                             // the last field of a struct can be unsized.\n@@ -3796,7 +3850,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {\n                     // Only check this if not in an `if` condition, as the\n                     // mistyped comparison help is more appropriate.\n-                    if !self.tcx.expr_is_lval(&lhs) {\n+                    if !self.is_place_expr(&lhs) {\n                         struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                          \"invalid left-hand side expression\")\n                             .span_label(expr.span, \"left-hand of expression not valid\")"}, {"sha": "0698e3ecb6eddb5000f412a1523beb7f06bca4b9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=06a0e4f7ae6d2e23adff1fe84e2a988f6b77fa53", "patch": "@@ -40,10 +40,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return_ty\n         };\n \n-        let tcx = self.tcx;\n-        if !tcx.expr_is_lval(lhs_expr) {\n+        if !self.is_place_expr(lhs_expr) {\n             struct_span_err!(\n-                tcx.sess, lhs_expr.span,\n+                self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")\n             .span_label(\n                 lhs_expr.span,"}]}