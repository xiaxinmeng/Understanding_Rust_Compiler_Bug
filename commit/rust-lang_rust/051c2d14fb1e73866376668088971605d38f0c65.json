{"sha": "051c2d14fb1e73866376668088971605d38f0c65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MWMyZDE0ZmIxZTczODY2Mzc2NjY4MDg4OTcxNjA1ZDM4ZjBjNjU=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-07-22T21:57:54Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-07-22T21:58:35Z"}, "message": "Implement rust_eh_personality in Rust, remove rust_eh_personality_catch.\n\nWell, not quite: ARM EHABI platforms still use the old scheme -- for now.", "tree": {"sha": "ac3b6af28a22ae22cfe83716f8f8c845454326ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac3b6af28a22ae22cfe83716f8f8c845454326ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/051c2d14fb1e73866376668088971605d38f0c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/051c2d14fb1e73866376668088971605d38f0c65", "html_url": "https://github.com/rust-lang/rust/commit/051c2d14fb1e73866376668088971605d38f0c65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/051c2d14fb1e73866376668088971605d38f0c65/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "html_url": "https://github.com/rust-lang/rust/commit/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355"}], "stats": {"total": 314, "additions": 176, "deletions": 138}, "files": [{"sha": "32fdf5c204801b168aa409c7de4972cb02dd87ba", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -45,16 +45,25 @@ pub const DW_EH_PE_aligned: u8 = 0x50;\n pub const DW_EH_PE_indirect: u8 = 0x80;\n \n #[derive(Copy, Clone)]\n-pub struct EHContext {\n+pub struct EHContext<'a> {\n     pub ip: usize, // Current instruction pointer\n     pub func_start: usize, // Address of the current function\n-    pub text_start: usize, // Address of the code section\n-    pub data_start: usize, // Address of the data section\n+    pub get_text_start: &'a Fn() -> usize, // Get address of the code section\n+    pub get_data_start: &'a Fn() -> usize, // Get address of the data section\n }\n \n-pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext) -> Option<usize> {\n+pub enum EHAction {\n+    None,\n+    Cleanup(usize),\n+    Catch(usize),\n+    Terminate,\n+}\n+\n+pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n+\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n     if lsda.is_null() {\n-        return None;\n+        return EHAction::None;\n     }\n \n     let func_start = context.func_start;\n@@ -77,32 +86,62 @@ pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext) -> Option<u\n     let call_site_encoding = reader.read::<u8>();\n     let call_site_table_length = reader.read_uleb128();\n     let action_table = reader.ptr.offset(call_site_table_length as isize);\n-    // Return addresses point 1 byte past the call instruction, which could\n-    // be in the next IP range.\n-    let ip = context.ip - 1;\n-\n-    while reader.ptr < action_table {\n-        let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_action = reader.read_uleb128();\n-        // Callsite table is sorted by cs_start, so if we've passed the ip, we\n-        // may stop searching.\n-        if ip < func_start + cs_start {\n-            break;\n+    let ip = context.ip;\n+\n+    if !USING_SJLJ_EXCEPTIONS {\n+        while reader.ptr < action_table {\n+            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_action = reader.read_uleb128();\n+            // Callsite table is sorted by cs_start, so if we've passed the ip, we\n+            // may stop searching.\n+            if ip < func_start + cs_start {\n+                break;\n+            }\n+            if ip < func_start + cs_start + cs_len {\n+                if cs_lpad == 0 {\n+                    return EHAction::None;\n+                } else {\n+                    let lpad = lpad_base + cs_lpad;\n+                    return interpret_cs_action(cs_action, lpad);\n+                }\n+            }\n         }\n-        if ip < func_start + cs_start + cs_len {\n-            if cs_lpad != 0 {\n-                return Some(lpad_base + cs_lpad);\n-            } else {\n-                return None;\n+        // If ip is not present in the table, call terminate.  This is for\n+        // a destructor inside a cleanup, or a library routine the compiler\n+        // was not expecting to throw\n+        EHAction::Terminate\n+    } else {\n+        // SjLj version:\n+        // The \"IP\" is an index into the call-site table, with two exceptions:\n+        // -1 means 'no-action', and 0 means 'terminate'.\n+        match ip as isize {\n+           -1 => return EHAction::None,\n+            0 => return EHAction::Terminate,\n+            _ => (),\n+        }\n+        let mut idx = ip;\n+        loop {\n+            let cs_lpad = reader.read_uleb128();\n+            let cs_action = reader.read_uleb128();\n+            idx -= 1;\n+            if idx == 0 {\n+                // Can never have null landing pad for sjlj -- that would have\n+                // been indicated by a -1 call site index.\n+                let lpad = (cs_lpad + 1) as usize;\n+                return interpret_cs_action(cs_action, lpad);\n             }\n         }\n     }\n-    // IP range not found: gcc's C++ personality calls terminate() here,\n-    // however the rest of the languages treat this the same as cs_lpad == 0.\n-    // We follow this suit.\n-    None\n+}\n+\n+fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n+    if cs_action == 0 {\n+        EHAction::Cleanup(lpad)\n+    } else {\n+        EHAction::Catch(lpad)\n+    }\n }\n \n #[inline]\n@@ -140,18 +179,16 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n         DW_EH_PE_pcrel => reader.ptr as usize,\n-        DW_EH_PE_textrel => {\n-            assert!(context.text_start != 0);\n-            context.text_start\n-        }\n-        DW_EH_PE_datarel => {\n-            assert!(context.data_start != 0);\n-            context.data_start\n-        }\n         DW_EH_PE_funcrel => {\n             assert!(context.func_start != 0);\n             context.func_start\n         }\n+        DW_EH_PE_textrel => {\n+            (*context.get_text_start)()\n+        }\n+        DW_EH_PE_datarel => {\n+            (*context.get_data_start)()\n+        }\n         _ => panic!(),\n     };\n "}, {"sha": "cdf772ad3b825481231305ff6ae887bbb9048566", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 72, "deletions": 93, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -106,117 +106,96 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     0x4d4f5a_00_52555354\n }\n \n-// We could implement our personality routine in Rust, however exception\n-// info decoding is tedious.  More importantly, personality routines have to\n-// handle various platform quirks, which are not fun to maintain.  For this\n-// reason, we attempt to reuse personality routine of the C language:\n-// __gcc_personality_v0.\n-//\n-// Since C does not support exception catching, __gcc_personality_v0 simply\n-// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n-// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n-//\n-// This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n-// So we have two versions of the personality routine:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n-//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n-//\n-// See also: rustc_trans::trans::intrinsic::trans_gnu_try\n-\n-#[cfg(all(not(target_arch = \"arm\"),\n-          not(all(windows, target_arch = \"x86_64\"))))]\n+// All targets, except ARM which uses a slightly different ABI (however, iOS goes here as it uses\n+// SjLj unwinding).  Also, 64-bit Windows implementation lives in seh64_gnu.rs\n+#[cfg(all(any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n pub mod eabi {\n     use unwind as uw;\n-    use libc::c_int;\n+    use libc::{c_int, uintptr_t};\n+    use dwarf::eh::{EHContext, EHAction, find_eh_action};\n \n-    extern \"C\" {\n-        fn __gcc_personality_v0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-                                -> uw::_Unwind_Reason_Code;\n-    }\n+    // Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n+    // and TargetLowering::getExceptionSelectorRegister() for each architecture,\n+    // then mapped to DWARF register numbers via register definition tables\n+    // (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n+    // See also http://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n \n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    extern \"C\" fn rust_eh_personality(version: c_int,\n-                                      actions: uw::_Unwind_Action,\n-                                      exception_class: uw::_Unwind_Exception_Class,\n-                                      ue_header: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n-    }\n+    #[cfg(target_arch = \"x86\")]\n+    const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n \n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                                actions: uw::_Unwind_Action,\n-                                                exception_class: uw::_Unwind_Exception_Class,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n+    #[cfg(target_arch = \"x86_64\")]\n+    const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n \n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n-        }\n-    }\n-}\n-\n-// iOS on armv7 is using SjLj exceptions and therefore requires to use\n-// a specialized personality routine: __gcc_personality_sj0\n+    #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n+    const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::c_int;\n+    #[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n+    const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n \n-    extern \"C\" {\n-        fn __gcc_personality_sj0(version: c_int,\n-                                 actions: uw::_Unwind_Action,\n-                                 exception_class: uw::_Unwind_Exception_Class,\n-                                 ue_header: *mut uw::_Unwind_Exception,\n-                                 context: *mut uw::_Unwind_Context)\n-                                 -> uw::_Unwind_Reason_Code;\n-    }\n+    #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+    const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n \n+    // Based on GCC's C and C++ personality routines.  For reference, see:\n+    // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n+    // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n     #[lang = \"eh_personality\"]\n     #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality(version: c_int,\n-                                          actions: uw::_Unwind_Action,\n-                                          exception_class: uw::_Unwind_Exception_Class,\n-                                          ue_header: *mut uw::_Unwind_Exception,\n-                                          context: *mut uw::_Unwind_Context)\n-                                          -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n+    #[allow(unused)]\n+    unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                                             actions: uw::_Unwind_Action,\n+                                             exception_class: uw::_Unwind_Exception_Class,\n+                                             exception_object: *mut uw::_Unwind_Exception,\n+                                             context: *mut uw::_Unwind_Context)\n+                                             -> uw::_Unwind_Reason_Code {\n+        if version != 1 {\n+            return uw::_URC_FATAL_PHASE1_ERROR;\n+        }\n+        let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n+        let mut ip_before_instr: c_int = 0;\n+        let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n+        let eh_context = EHContext {\n+            // The return address points 1 byte past the call instruction,\n+            // which could be in the next IP range in LSDA range table.\n+            ip: if ip_before_instr != 0 { ip } else { ip - 1 },\n+            func_start: uw::_Unwind_GetRegionStart(context),\n+            get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n+            get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n+        };\n+        let eh_action = find_eh_action(lsda, &eh_context);\n+\n+        if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+            match eh_action {\n+                EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n+                EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+                EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+            }\n+        } else {\n+            match eh_action {\n+                EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+                EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                    uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n+                    uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                    uw::_Unwind_SetIP(context, lpad);\n+                    return uw::_URC_INSTALL_CONTEXT;\n+                }\n+                EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n+            }\n+        }\n     }\n \n+    #[cfg(stage0)]\n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                                actions: uw::_Unwind_Action,\n-                                                exception_class: uw::_Unwind_Exception_Class,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n-        }\n+    pub unsafe extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                                       actions: uw::_Unwind_Action,\n+                                                       exception_class: uw::_Unwind_Exception_Class,\n+                                                       ue_header: *mut uw::_Unwind_Exception,\n+                                                       context: *mut uw::_Unwind_Context)\n+                                                       -> uw::_Unwind_Reason_Code {\n+        rust_eh_personality(version, actions, exception_class, ue_header, context)\n     }\n }\n \n-\n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]"}, {"sha": "11dd9befe0a82e940da630f68317591ef960187b", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -101,6 +101,7 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[no_mangle]\n+#[unwind]\n pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n     imp::panic(mem::transmute(raw::TraitObject {\n         data: data as *mut (),"}, {"sha": "7dc428871b387f2e83792d468706fa8b6c99675f", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -19,7 +19,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n use core::ptr;\n-use dwarf::eh;\n+use dwarf::eh::{EHContext, EHAction, find_eh_action};\n use windows as c;\n \n // Define our exception codes:\n@@ -81,6 +81,7 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n // This is considered acceptable, because the behavior of throwing exceptions\n // through a C ABI boundary is undefined.\n \n+#[cfg(stage0)]\n #[lang = \"eh_personality_catch\"]\n #[cfg(not(test))]\n unsafe extern \"C\" fn rust_eh_personality_catch(exceptionRecord: *mut c::EXCEPTION_RECORD,\n@@ -132,11 +133,17 @@ unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n }\n \n unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n-    let eh_ctx = eh::EHContext {\n-        ip: dc.ControlPc as usize,\n+    let eh_ctx = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        ip: dc.ControlPc as usize - 1,\n         func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n-        text_start: dc.ImageBase as usize,\n-        data_start: 0,\n+        get_text_start: &|| dc.ImageBase as usize,\n+        get_data_start: &|| unimplemented!(),\n     };\n-    eh::find_landing_pad(dc.HandlerData, &eh_ctx)\n+    match find_eh_action(dc.HandlerData, &eh_ctx) {\n+        EHAction::None => None,\n+        EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => Some(lpad),\n+        EHAction::Terminate => intrinsics::abort(),\n+    }\n }"}, {"sha": "f033b278fe7f07230600e79b6793344d70a66ba2", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -1193,11 +1193,17 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // managed by the standard library.\n \n         attributes::emit_uwtable(bcx.fcx.llfn, true);\n-        let catch_pers = match tcx.lang_items.eh_personality_catch() {\n-            Some(did) => {\n-                Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+        let target = &bcx.sess().target.target;\n+        let catch_pers = if target.arch == \"arm\" && target.target_os != \"ios\" {\n+            // Only ARM still uses a separate catch personality (for now)\n+            match tcx.lang_items.eh_personality_catch() {\n+                Some(did) => {\n+                    Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+                }\n+                None => bug!(\"eh_personality_catch not defined\"),\n             }\n-            None => bug!(\"eh_personality_catch not defined\"),\n+        } else {\n+            bcx.fcx.eh_personality()\n         };\n \n         let then = bcx.fcx.new_temp_block(\"then\");"}, {"sha": "d9b6c9ed74dd21b4fec9ec88ebbce37b27990ea3", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051c2d14fb1e73866376668088971605d38f0c65/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=051c2d14fb1e73866376668088971605d38f0c65", "patch": "@@ -58,6 +58,7 @@ pub enum _Unwind_Reason_Code {\n pub type _Unwind_Exception_Class = u64;\n \n pub type _Unwind_Word = libc::uintptr_t;\n+pub type _Unwind_Ptr = libc::uintptr_t;\n \n pub type _Unwind_Trace_Fn = extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut libc::c_void)\n                                           -> _Unwind_Reason_Code;\n@@ -156,6 +157,13 @@ extern \"C\" {\n                              ip_before_insn: *mut libc::c_int)\n                              -> libc::uintptr_t;\n \n+    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n+    pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n+    pub fn _Unwind_GetTextRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n+    pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n+    pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: libc::c_int, value: _Unwind_Ptr);\n+    pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Ptr);\n+\n     #[cfg(all(not(target_os = \"android\"),\n               not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n     pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void) -> *mut libc::c_void;"}]}