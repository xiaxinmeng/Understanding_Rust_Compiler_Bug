{"sha": "0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "node_id": "C_kwDOAAsO6NoAKDBlZTc5ZjJjNWExM2NhZTBmZmFhNDNhMjFiN2YxMWQxZDdhZDUzMTY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-01T11:05:01Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T23:34:54Z"}, "message": "Avoid the unnecessary innermost match in `partial_cmp`/`cmp`.\n\nWe currently do a match on the comparison of every field in a struct or\nenum variant. But the last field has a degenerate match like this:\n```\nmatch ::core::cmp::Ord::cmp(&self.y, &other.y) {\n    ::core::cmp::Ordering::Equal =>\n\t::core::cmp::Ordering::Equal,\n    cmp => cmp,\n},\n```\nThis commit changes it to this:\n```\n::core::cmp::Ord::cmp(&self.y, &other.y),\n```\nThis is fairly straightforward thanks to the existing `cs_fold1`\nfunction.\n\nThe commit also removes the `cs_fold` function which is no longer used.\n\n(Note: there is some repetition now in `cs_cmp` and `cs_partial_cmp`. I\nwill remove that in a follow-up PR.)", "tree": {"sha": "f55f884cc944008e167c8223a0baea2e94d18ae9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f55f884cc944008e167c8223a0baea2e94d18ae9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "html_url": "https://github.com/rust-lang/rust/commit/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33", "html_url": "https://github.com/rust-lang/rust/commit/2c911dc16f2ac3237fca7c7626982e6f6a4d0e33"}], "stats": {"total": 196, "additions": 57, "deletions": 139}, "files": [{"sha": "cb19107ae38f4131d010c02917863150ede7e728", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "patch": "@@ -70,7 +70,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n     // cmp => cmp\n     // }\n     //\n-    let expr = cs_fold(\n+    let expr = cs_fold1(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -79,15 +79,12 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n             //     ::std::cmp::Ordering::Equal => old,\n             //     cmp => cmp\n             // }\n-\n             let new = {\n                 let [other_f] = other_fs else {\n                     cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                 };\n-\n                 let args =\n                     vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n@@ -96,7 +93,21 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n-        cx.expr_path(equals_path.clone()),\n+        |cx, args| match args {\n+            Some((span, self_f, other_fs)) => {\n+                let new = {\n+                    let [other_f] = other_fs else {\n+                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                        };\n+                    let args =\n+                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    cx.expr_call_global(span, cmp_path.clone(), args)\n+                };\n+\n+                new\n+            }\n+            None => cx.expr_path(equals_path.clone()),\n+        },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")"}, {"sha": "10b34985f476ef513ab7a88a2179bead973657a2", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "patch": "@@ -2,7 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::MetaItem;\n+use rustc_ast::ptr::P;\n+use rustc_ast::{Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -51,7 +52,6 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n     let test_id = Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n-    let equals_expr = cx.expr_some(span, ordering_expr);\n \n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n@@ -68,7 +68,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n     // cmp => cmp\n     // }\n     //\n-    let expr = cs_fold(\n+    let expr = cs_fold1(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -94,7 +94,21 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n \n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n-        equals_expr,\n+        |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n+            Some((span, self_f, other_fs)) => {\n+                let new = {\n+                    let [other_f] = other_fs else {\n+                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                        };\n+                    let args =\n+                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                };\n+\n+                new\n+            }\n+            None => cx.expr_some(span, ordering_expr.clone()),\n+        },\n         Box::new(|cx, span, tag_tuple| {\n             if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")"}, {"sha": "99793e675be03ff37c007784958da89f07610ba0", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "patch": "@@ -1694,31 +1694,6 @@ fn cs_fold_static(cx: &mut ExtCtxt<'_>, trait_span: Span) -> P<Expr> {\n     cx.span_bug(trait_span, \"static function in `derive`\")\n }\n \n-/// Fold the fields. `use_foldl` controls whether this is done\n-/// left-to-right (`true`) or right-to-left (`false`).\n-pub fn cs_fold<F>(\n-    use_foldl: bool,\n-    f: F,\n-    base: P<Expr>,\n-    enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-    cx: &mut ExtCtxt<'_>,\n-    trait_span: Span,\n-    substructure: &Substructure<'_>,\n-) -> P<Expr>\n-where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-{\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n-        }\n-        EnumNonMatchingCollapsed(..) => {\n-            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n-        }\n-        StaticEnum(..) | StaticStruct(..) => cs_fold_static(cx, trait_span),\n-    }\n-}\n-\n /// Function to fold over fields, with three cases, to generate more efficient and concise code.\n /// When the `substructure` has grouped fields, there are two cases:\n /// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`)."}, {"sha": "9b10192d75a132b8bd550b9d26ec1c5547a39a6d", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 23, "deletions": 105, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=0ee79f2c5a13cae0ffaa43a21b7f11d1d7ad5316", "patch": "@@ -161,13 +161,7 @@ impl ::core::cmp::PartialOrd for Point {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n             ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y)\n-                    {\n-                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                        =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y),\n             cmp => cmp,\n         }\n     }\n@@ -179,11 +173,7 @@ impl ::core::cmp::Ord for Point {\n     fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n         match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n             ::core::cmp::Ordering::Equal =>\n-                match ::core::cmp::Ord::cmp(&self.y, &other.y) {\n-                    ::core::cmp::Ordering::Equal =>\n-                        ::core::cmp::Ordering::Equal,\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::Ord::cmp(&self.y, &other.y),\n             cmp => cmp,\n         }\n     }\n@@ -323,13 +313,7 @@ impl ::core::cmp::PartialOrd for Big {\n                                                                 &other.b7) {\n                                                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                                                 =>\n-                                                                match ::core::cmp::PartialOrd::partial_cmp(&self.b8,\n-                                                                        &other.b8) {\n-                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                                                        =>\n-                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                                                    cmp => cmp,\n-                                                                },\n+                                                                ::core::cmp::PartialOrd::partial_cmp(&self.b8, &other.b8),\n                                                             cmp => cmp,\n                                                         },\n                                                     cmp => cmp,\n@@ -365,11 +349,7 @@ impl ::core::cmp::Ord for Big {\n                                                     ::core::cmp::Ordering::Equal =>\n                                                         match ::core::cmp::Ord::cmp(&self.b7, &other.b7) {\n                                                             ::core::cmp::Ordering::Equal =>\n-                                                                match ::core::cmp::Ord::cmp(&self.b8, &other.b8) {\n-                                                                    ::core::cmp::Ordering::Equal =>\n-                                                                        ::core::cmp::Ordering::Equal,\n-                                                                    cmp => cmp,\n-                                                                },\n+                                                                ::core::cmp::Ord::cmp(&self.b8, &other.b8),\n                                                             cmp => cmp,\n                                                         },\n                                                     cmp => cmp,\n@@ -461,11 +441,7 @@ impl ::core::cmp::PartialOrd for Packed {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let Self(__self_0_0) = *self;\n         let Self(__self_1_0) = *other;\n-        match ::core::cmp::PartialOrd::partial_cmp(&__self_0_0, &__self_1_0) {\n-            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-            cmp => cmp,\n-        }\n+        ::core::cmp::PartialOrd::partial_cmp(&__self_0_0, &__self_1_0)\n     }\n }\n #[automatically_derived]\n@@ -475,10 +451,7 @@ impl ::core::cmp::Ord for Packed {\n     fn cmp(&self, other: &Packed) -> ::core::cmp::Ordering {\n         let Self(__self_0_0) = *self;\n         let Self(__self_1_0) = *other;\n-        match ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0) {\n-            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,\n-            cmp => cmp,\n-        }\n+        ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0)\n     }\n }\n \n@@ -621,13 +594,7 @@ impl ::core::cmp::PartialOrd for Enum1 {\n         match (&*self, &*other) {\n             (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n                 x: ref __arg_1_0 }) =>\n-                match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                        &*__arg_1_0) {\n-                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                        =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::PartialOrd::partial_cmp(&*__self_0, &*__arg_1_0),\n         }\n     }\n }\n@@ -639,11 +606,7 @@ impl ::core::cmp::Ord for Enum1 {\n         match (&*self, &*other) {\n             (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n                 x: ref __arg_1_0 }) =>\n-                match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                    ::core::cmp::Ordering::Equal =>\n-                        ::core::cmp::Ordering::Equal,\n-                    cmp => cmp,\n-                },\n+                ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n         }\n     }\n }\n@@ -873,26 +836,16 @@ impl ::core::cmp::PartialOrd for Mixed {\n         if __self_vi == __arg_1_vi {\n                 match (&*self, &*other) {\n                     (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                &*__arg_1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n                     (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                         &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n                         match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                                 &*__arg_1_0) {\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                 =>\n-                                match ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n-                                        &*__arg_1_1) {\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                        =>\n-                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                    cmp => cmp,\n-                                },\n+                                ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n+                                    &*__arg_1_1),\n                             cmp => cmp,\n                         },\n                     _ =>\n@@ -913,20 +866,12 @@ impl ::core::cmp::Ord for Mixed {\n         if __self_vi == __arg_1_vi {\n                 match (&*self, &*other) {\n                     (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                            ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ordering::Equal,\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n                     (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n                         &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n                         match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                             ::core::cmp::Ordering::Equal =>\n-                                match ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1) {\n-                                    ::core::cmp::Ordering::Equal =>\n-                                        ::core::cmp::Ordering::Equal,\n-                                    cmp => cmp,\n-                                },\n+                                ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1),\n                             cmp => cmp,\n                         },\n                     _ => ::core::cmp::Ordering::Equal,\n@@ -1054,29 +999,14 @@ impl ::core::cmp::PartialOrd for Fielded {\n         if __self_vi == __arg_1_vi {\n                 match (&*self, &*other) {\n                     (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                &*__arg_1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n                     (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                &*__arg_1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n                     (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                &*__arg_1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                            &*__arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else {\n@@ -1094,23 +1024,11 @@ impl ::core::cmp::Ord for Fielded {\n         if __self_vi == __arg_1_vi {\n                 match (&*self, &*other) {\n                     (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                            ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ordering::Equal,\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n                     (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                            ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ordering::Equal,\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n                     (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                            ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ordering::Equal,\n-                            cmp => cmp,\n-                        },\n+                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }"}]}