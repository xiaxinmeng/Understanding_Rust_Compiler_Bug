{"sha": "0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNmNlZTU1ZWFmMzg3MWM0YmI2NTlmZWE5YjNhZGE5YWQxZjliMmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-30T23:17:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-02T22:16:07Z"}, "message": "libsyntax: De-`@mut` `Parser::span`", "tree": {"sha": "5108099a80cacfb36a84663864cd8dc1cdcf8169", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5108099a80cacfb36a84663864cd8dc1cdcf8169"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "html_url": "https://github.com/rust-lang/rust/commit/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "758d854436a2174c85717a64b8a90ed4041962d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/758d854436a2174c85717a64b8a90ed4041962d8", "html_url": "https://github.com/rust-lang/rust/commit/758d854436a2174c85717a64b8a90ed4041962d8"}], "stats": {"total": 106, "additions": 54, "deletions": 52}, "files": [{"sha": "8660b4c056091f8a254bdc69e8b6fff1cdef8582", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "patch": "@@ -86,13 +86,13 @@ impl<'a> Context<'a> {\n                         i\n                     }\n                     _ if named => {\n-                        self.ecx.span_err(*p.span,\n+                        self.ecx.span_err(p.span,\n                                           \"expected ident, positional arguments \\\n                                            cannot follow named arguments\");\n                         return (extra, None);\n                     }\n                     _ => {\n-                        self.ecx.span_err(*p.span,\n+                        self.ecx.span_err(p.span,\n                                           format!(\"expected ident for named \\\n                                                 argument, but found `{}`\",\n                                                p.this_token_to_str()));"}, {"sha": "c9827fb54bd79bc0fdace2e93641dc50563e3cb6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "patch": "@@ -48,7 +48,7 @@ impl ParserAnyMacro {\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\",\n                               token_str);\n-            let span = *parser.get().span;\n+            let span = parser.get().span;\n             parser.get().span_err(span, msg);\n         }\n     }"}, {"sha": "92df36da21732ae680ba50a51c7855a6330a2620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "patch": "@@ -304,7 +304,7 @@ pub fn Parser(sess: @mut ParseSess,\n         sess: sess,\n         cfg: cfg,\n         token: tok0.tok,\n-        span: @mut span,\n+        span: span,\n         last_span: @mut span,\n         last_token: @mut None,\n         buffer: @mut ([\n@@ -332,7 +332,7 @@ pub struct Parser {\n     // the current token:\n     token: token::Token,\n     // the span of the current token:\n-    span: @mut Span,\n+    span: Span,\n     // the span of the prior token:\n     last_span: @mut Span,\n     // the previous token or None (only stashed sometimes).\n@@ -434,7 +434,7 @@ impl Parser {\n             && expected.iter().all(|t| *t != token::LBRACE)\n             && self.look_ahead(1, |t| *t == token::RBRACE) {\n             // matched; signal non-fatal error and recover.\n-            self.span_err(*self.span,\n+            self.span_err(self.span,\n                           \"Unit-like struct construction is written with no trailing `{ }`\");\n             self.eat(&token::LBRACE);\n             self.eat(&token::RBRACE);\n@@ -547,7 +547,7 @@ impl Parser {\n     pub fn check_strict_keywords(&mut self) {\n         if token::is_strict_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n-            self.span_err(*self.span,\n+            self.span_err(self.span,\n                           format!(\"found `{}` in ident position\", token_str));\n         }\n     }\n@@ -566,9 +566,8 @@ impl Parser {\n         match self.token {\n             token::BINOP(token::OR) => self.bump(),\n             token::OROR => {\n-                self.replace_token(token::BINOP(token::OR),\n-                                   self.span.lo + BytePos(1),\n-                                   self.span.hi)\n+                let lo = self.span.lo + BytePos(1);\n+                self.replace_token(token::BINOP(token::OR), lo, self.span.hi)\n             }\n             _ => {\n                 let token_str = self.this_token_to_str();\n@@ -608,11 +607,10 @@ impl Parser {\n     pub fn expect_gt(&mut self) {\n         match self.token {\n             token::GT => self.bump(),\n-            token::BINOP(token::SHR) => self.replace_token(\n-                token::GT,\n-                self.span.lo + BytePos(1),\n-                self.span.hi\n-            ),\n+            token::BINOP(token::SHR) => {\n+                let lo = self.span.lo + BytePos(1);\n+                self.replace_token(token::GT, lo, self.span.hi)\n+            }\n             _ => {\n                 let gt_str = Parser::token_to_str(&token::GT);\n                 let this_token_str = self.this_token_to_str();\n@@ -730,7 +728,7 @@ impl Parser {\n \n     // advance the parser by one token\n     pub fn bump(&mut self) {\n-        *self.last_span = *self.span;\n+        *self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         *self.last_token = if is_ident_or_path(&self.token) {\n             Some(~self.token.clone())\n@@ -747,11 +745,11 @@ impl Parser {\n \n             let placeholder = TokenAndSpan {\n                 tok: token::UNDERSCORE,\n-                sp: *self.span,\n+                sp: self.span,\n             };\n             util::replace(&mut self.buffer[buffer_start], placeholder)\n         };\n-        *self.span = next.sp;\n+        self.span = next.sp;\n         self.token = next.tok;\n         *self.tokens_consumed += 1u;\n     }\n@@ -769,7 +767,7 @@ impl Parser {\n                          lo: BytePos,\n                          hi: BytePos) {\n         self.token = next;\n-        *self.span = mk_sp(lo, hi);\n+        self.span = mk_sp(lo, hi);\n     }\n     pub fn buffer_length(&mut self) -> int {\n         if *self.buffer_start <= *self.buffer_end {\n@@ -787,7 +785,7 @@ impl Parser {\n         f(&self.buffer[(*self.buffer_start + dist - 1) & 3].tok)\n     }\n     pub fn fatal(&mut self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_fatal(*self.span, m)\n+        self.sess.span_diagnostic.span_fatal(self.span, m)\n     }\n     pub fn span_fatal(&mut self, sp: Span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n@@ -796,10 +794,10 @@ impl Parser {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n     pub fn bug(&mut self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(*self.span, m)\n+        self.sess.span_diagnostic.span_bug(self.span, m)\n     }\n     pub fn warn(&mut self, m: &str) {\n-        self.sess.span_diagnostic.span_warn(*self.span, m)\n+        self.sess.span_diagnostic.span_warn(self.span, m)\n     }\n     pub fn span_err(&mut self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n@@ -1047,7 +1045,7 @@ impl Parser {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n-            let vis_span = *p.span;\n+            let vis_span = p.span;\n             let vis = p.parse_visibility();\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n@@ -1590,7 +1588,7 @@ impl Parser {\n     pub fn parse_lifetime(&mut self) -> ast::Lifetime {\n         match self.token {\n             token::LIFETIME(i) => {\n-                let span = *self.span;\n+                let span = self.span;\n                 self.bump();\n                 return ast::Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n@@ -1722,7 +1720,7 @@ impl Parser {\n     }\n \n     pub fn mk_lit_u32(&mut self, i: u32) -> @Expr {\n-        let span = self.span;\n+        let span = &self.span;\n         let lv_lit = @codemap::Spanned {\n             node: lit_uint(i as u64, ty_u32),\n             span: *span\n@@ -2105,7 +2103,7 @@ impl Parser {\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if p.quote_depth > 0u => {\n                 p.bump();\n-                let sp = *p.span;\n+                let sp = p.span;\n \n                 if p.token == token::LPAREN {\n                     let seq = p.parse_seq(\n@@ -2136,7 +2134,7 @@ impl Parser {\n \n         // turn the next token into a tt_tok:\n         fn parse_any_tt_tok(p: &mut Parser) -> token_tree{\n-            tt_tok(*p.span, p.bump_and_get())\n+            tt_tok(p.span, p.bump_and_get())\n         }\n \n         match self.token {\n@@ -2152,7 +2150,7 @@ impl Parser {\n                 let close_delim = token::flip_delimiter(&self.token);\n \n                 // Parse the open delimiter.\n-                (*self.open_braces).push(*self.span);\n+                (*self.open_braces).push(self.span);\n                 let mut result = ~[parse_any_tt_tok(self)];\n \n                 let trees =\n@@ -2430,7 +2428,7 @@ impl Parser {\n               self.mk_expr(lo, rhs.span.hi, assign_op)\n           }\n           token::DARROW => {\n-            self.obsolete(*self.span, ObsoleteSwap);\n+            self.obsolete(self.span, ObsoleteSwap);\n             self.bump();\n             // Ignore what we get, this is an error anyway\n             self.parse_expr();\n@@ -2472,7 +2470,7 @@ impl Parser {\n                           output: P(Ty {\n                               id: ast::DUMMY_NODE_ID,\n                               node: ty_infer,\n-                              span: *p.span\n+                              span: p.span\n                           }),\n                           cf: return_val,\n                           variadic: false\n@@ -2758,13 +2756,13 @@ impl Parser {\n                     slice = Some(@ast::Pat {\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatWildMulti,\n-                        span: *self.span,\n+                        span: self.span,\n                     })\n                 } else {\n                     let subpat = self.parse_pat();\n                     match subpat {\n                         @ast::Pat { id, node: PatWild, span } => {\n-                            self.obsolete(*self.span, ObsoleteVecDotDotWildcard);\n+                            self.obsolete(self.span, ObsoleteVecDotDotWildcard);\n                             slice = Some(@ast::Pat {\n                                 id: id,\n                                 node: PatWildMulti,\n@@ -2808,7 +2806,7 @@ impl Parser {\n \n             etc = self.token == token::UNDERSCORE || self.token == token::DOTDOT;\n             if self.token == token::UNDERSCORE {\n-                self.obsolete(*self.span, ObsoleteStructWildcard);\n+                self.obsolete(self.span, ObsoleteStructWildcard);\n             }\n             if etc {\n                 self.bump();\n@@ -3093,7 +3091,7 @@ impl Parser {\n                                 // This is a \"top constructor only\" pat\n                                 self.bump();\n                                 if is_star {\n-                                    self.obsolete(*self.span, ObsoleteEnumWildcard);\n+                                    self.obsolete(self.span, ObsoleteEnumWildcard);\n                                 }\n                                 self.bump();\n                                 self.expect(&token::RPAREN);\n@@ -3193,7 +3191,7 @@ impl Parser {\n         let local = self.parse_local();\n         while self.eat(&token::COMMA) {\n             let _ = self.parse_local();\n-            self.obsolete(*self.span, ObsoleteMultipleLocalDecl);\n+            self.obsolete(self.span, ObsoleteMultipleLocalDecl);\n         }\n         return @spanned(lo, self.last_span.hi, DeclLocal(local));\n     }\n@@ -3324,7 +3322,7 @@ impl Parser {\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n-            self.obsolete(*self.span, ObsoleteUnsafeBlock);\n+            self.obsolete(self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n \n@@ -3339,7 +3337,7 @@ impl Parser {\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n-            self.obsolete(*self.span, ObsoleteUnsafeBlock);\n+            self.obsolete(self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n         let (inner, next) = self.parse_inner_attrs_and_next();\n@@ -3497,7 +3495,7 @@ impl Parser {\n                     if \"static\" == self.id_to_str(lifetime) {\n                         result.push(RegionTyParamBound);\n                     } else {\n-                        self.span_err(*self.span,\n+                        self.span_err(self.span,\n                                       \"`'static` is the only permissible region bound here\");\n                     }\n                     self.bump();\n@@ -3552,7 +3550,7 @@ impl Parser {\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n                      -> (~[arg], bool) {\n-        let sp = *self.span;\n+        let sp = self.span;\n         let mut args: ~[Option<arg>] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n@@ -3563,11 +3561,11 @@ impl Parser {\n                         p.bump();\n                         if allow_variadic {\n                             if p.token != token::RPAREN {\n-                                p.span_fatal(*p.span,\n+                                p.span_fatal(p.span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n                         } else {\n-                            p.span_fatal(*p.span,\n+                            p.span_fatal(p.span,\n                                          \"only foreign functions are allowed to be variadic\");\n                         }\n                         None\n@@ -3729,7 +3727,7 @@ impl Parser {\n                 self.parse_mutability()\n             } else { MutImmutable };\n             if self.is_self_ident() {\n-                self.span_err(*self.span, \"cannot pass self by unsafe pointer\");\n+                self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n                 self.bump();\n             }\n             sty_value(mutability)\n@@ -3815,7 +3813,11 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            P(Ty { id: ast::DUMMY_NODE_ID, node: ty_infer, span: *self.span })\n+            P(Ty {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ty_infer,\n+                span: self.span,\n+            })\n         };\n \n         P(ast::fn_decl {\n@@ -3840,7 +3842,7 @@ impl Parser {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ty_infer,\n-                span: *self.span,\n+                span: self.span,\n             })\n         };\n \n@@ -4087,7 +4089,7 @@ impl Parser {\n             token::RBRACE => {}\n             _ => {\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(*self.span,\n+                self.span_fatal(self.span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n                                         token_str))\n             }\n@@ -4183,7 +4185,7 @@ impl Parser {\n \n     // parse a `mod <foo> { ... }` or `mod <foo>;` item\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> item_info {\n-        let id_span = *self.span;\n+        let id_span = self.span;\n         let id = self.parse_ident();\n         if self.token == token::SEMI {\n             self.bump();\n@@ -4221,7 +4223,7 @@ impl Parser {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {\n-        let mut prefix = Path::new(self.sess.cm.span_to_filename(*self.span));\n+        let mut prefix = Path::new(self.sess.cm.span_to_filename(self.span));\n         prefix.pop();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path::new(\".\").join_many(*mod_path_stack);\n@@ -4383,7 +4385,7 @@ impl Parser {\n             self.expect_keyword(keywords::Mod);\n         } else if self.token != token::LBRACE {\n             let token_str = self.this_token_to_str();\n-            self.span_fatal(*self.span,\n+            self.span_fatal(self.span,\n                             format!(\"expected `\\\\{` or `mod` but found `{}`\",\n                                     token_str))\n         }\n@@ -4401,7 +4403,7 @@ impl Parser {\n             _ => {\n                 if must_be_named_mod {\n                     let token_str = self.this_token_to_str();\n-                    self.span_fatal(*self.span,\n+                    self.span_fatal(self.span,\n                                     format!(\"expected foreign module name but \\\n                                              found `{}`\",\n                                             token_str))\n@@ -4435,7 +4437,7 @@ impl Parser {\n         }\n \n         if opt_abis.is_some() {\n-            self.span_err(*self.span, \"an ABI may not be specified here\");\n+            self.span_err(self.span, \"an ABI may not be specified here\");\n         }\n \n \n@@ -4580,7 +4582,7 @@ impl Parser {\n                         Some(abi) => {\n                             if abis.contains(abi) {\n                                 self.span_err(\n-                                    *self.span,\n+                                    self.span,\n                                     format!(\"ABI `{}` appears twice\",\n                                          word));\n                             } else {\n@@ -4590,7 +4592,7 @@ impl Parser {\n \n                         None => {\n                             self.span_err(\n-                                *self.span,\n+                                self.span,\n                                 format!(\"illegal ABI: \\\n                                       expected one of [{}], \\\n                                       found `{}`\","}]}