{"sha": "db0492ace429cfeb3567e2c04e300be7df9972ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDQ5MmFjZTQyOWNmZWIzNTY3ZTJjMDRlMzAwYmU3ZGY5OTcyZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-29T20:35:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-29T20:35:52Z"}, "message": "Auto merge of #74733 - richkadel:llvm-coverage-map-gen-5, r=tmandry\n\nFixed coverage map issues; better aligned with LLVM APIs\n\nFound some problems with the coverage map encoding when testing with more than one counter per function.\n\nWhile debugging, I realized some better ways to structure the Rust implementation of the coverage mapping generator. I refactored somewhat, resulting in less code overall, expanded coverage of LLVM Coverage Map capabilities, and much closer alignment with LLVM data structures, APIs, and naming.\n\nThis should be easier to follow and easier to maintain.\n\nr? @tmandry\n\nRust compiler MCP rust-lang/compiler-team#278\nRelevant issue: #34701 - Implement support for LLVMs code coverage instrumentation", "tree": {"sha": "bdaef57c8b3bace8e9939edd479d945a2da53633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdaef57c8b3bace8e9939edd479d945a2da53633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db0492ace429cfeb3567e2c04e300be7df9972ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db0492ace429cfeb3567e2c04e300be7df9972ff", "html_url": "https://github.com/rust-lang/rust/commit/db0492ace429cfeb3567e2c04e300be7df9972ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db0492ace429cfeb3567e2c04e300be7df9972ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8611e526b766ce188dc29bd49bf66ff17764ceea", "url": "https://api.github.com/repos/rust-lang/rust/commits/8611e526b766ce188dc29bd49bf66ff17764ceea", "html_url": "https://github.com/rust-lang/rust/commit/8611e526b766ce188dc29bd49bf66ff17764ceea"}, {"sha": "5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e", "html_url": "https://github.com/rust-lang/rust/commit/5b2e2b25e41afbbd0ad803f7986d8559ef649a7e"}], "stats": {"total": 1484, "additions": 794, "deletions": 690}, "files": [{"sha": "4d9747a43f2e2b64e3c9681c50414a1490faf953", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 117, "deletions": 155, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,23 +1,15 @@\n-use crate::llvm;\n-\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n+use crate::llvm;\n \n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, MiscMethods};\n+use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n-use rustc_middle::ty::Instance;\n-use rustc_middle::{bug, mir};\n \n-use std::collections::BTreeMap;\n use std::ffi::CString;\n-use std::path::PathBuf;\n-\n-// FIXME(richkadel): Complete all variations of generating and exporting the coverage map to LLVM.\n-// The current implementation is an initial foundation with basic capabilities (Counters, but not\n-// CounterExpressions, etc.).\n \n /// Generates and exports the Coverage Map.\n ///\n@@ -32,174 +24,123 @@ use std::path::PathBuf;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let mut coverage_writer = CoverageMappingWriter::new(cx);\n-\n     let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    if function_coverage_map.is_empty() {\n+        // This module has no functions with coverage instrumentation\n+        return;\n+    }\n+\n+    let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n     let mut function_records = Vec::<&'ll llvm::Value>::new();\n     let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n         for (instance, function_coverage) in function_coverage_map.into_iter() {\n-            if let Some(function_record) = coverage_writer.write_function_mappings_and_record(\n-                instance,\n-                function_coverage,\n-                coverage_mappings_buffer,\n-            ) {\n-                function_records.push(function_record);\n-            }\n+            debug!(\"Generate coverage map for: {:?}\", instance);\n+\n+            let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+            let function_source_hash = function_coverage.source_hash();\n+            let (expressions, counter_regions) =\n+                function_coverage.get_expressions_and_counter_regions();\n+\n+            let old_len = coverage_mappings_buffer.len();\n+            mapgen.write_coverage_mappings(expressions, counter_regions, coverage_mappings_buffer);\n+            let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n+            debug_assert!(\n+                mapping_data_size > 0,\n+                \"Every `FunctionCoverage` should have at least one counter\"\n+            );\n+\n+            let function_record = mapgen.make_function_record(\n+                cx,\n+                mangled_function_name,\n+                function_source_hash,\n+                mapping_data_size,\n+            );\n+            function_records.push(function_record);\n         }\n     });\n \n-    // Encode all filenames covered in this module, ordered by `file_id`\n+    // Encode all filenames referenced by counters/expressions in this module\n     let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n-        coverageinfo::write_filenames_section_to_buffer(\n-            &coverage_writer.filenames,\n-            filenames_buffer,\n-        );\n+        coverageinfo::write_filenames_section_to_buffer(&mapgen.filenames, filenames_buffer);\n     });\n \n-    if coverage_mappings_buffer.len() > 0 {\n-        // Generate the LLVM IR representation of the coverage map and store it in a well-known\n-        // global constant.\n-        coverage_writer.write_coverage_map(\n-            function_records,\n-            filenames_buffer,\n-            coverage_mappings_buffer,\n-        );\n-    }\n+    // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n+    mapgen.save_generated_coverage_map(\n+        cx,\n+        function_records,\n+        filenames_buffer,\n+        coverage_mappings_buffer,\n+    );\n }\n \n-struct CoverageMappingWriter<'a, 'll, 'tcx> {\n-    cx: &'a CodegenCx<'ll, 'tcx>,\n+struct CoverageMapGenerator {\n     filenames: Vec<CString>,\n     filename_to_index: FxHashMap<CString, u32>,\n }\n \n-impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n-    fn new(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n-        Self { cx, filenames: Vec::new(), filename_to_index: FxHashMap::<CString, u32>::default() }\n+impl CoverageMapGenerator {\n+    fn new() -> Self {\n+        Self { filenames: Vec::new(), filename_to_index: FxHashMap::default() }\n     }\n \n-    /// For the given function, get the coverage region data, stream it to the given buffer, and\n-    /// then generate and return a new function record.\n-    fn write_function_mappings_and_record(\n+    /// Using the `expressions` and `counter_regions` collected for the current function, generate\n+    /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n+    /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n+    /// the given `coverage_mappings` byte buffer, compliant with the LLVM Coverage Mapping format.\n+    fn write_coverage_mappings(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        mut function_coverage: FunctionCoverage,\n+        expressions: Vec<CounterExpression>,\n+        counter_regions: impl Iterator<Item = (Counter, &'a Region)>,\n         coverage_mappings_buffer: &RustString,\n-    ) -> Option<&'ll llvm::Value> {\n-        let cx = self.cx;\n-        let coverageinfo: &mir::CoverageInfo = cx.tcx.coverageinfo(instance.def_id());\n-        debug!(\n-            \"Generate coverage map for: {:?}, num_counters: {}, num_expressions: {}\",\n-            instance, coverageinfo.num_counters, coverageinfo.num_expressions\n-        );\n-        debug_assert!(coverageinfo.num_counters > 0);\n-\n-        let regions_in_file_order = function_coverage.regions_in_file_order(cx.sess().source_map());\n-        if regions_in_file_order.len() == 0 {\n-            return None;\n+    ) {\n+        let mut counter_regions = counter_regions.collect::<Vec<_>>();\n+        if counter_regions.is_empty() {\n+            return;\n         }\n \n-        // Stream the coverage mapping regions for the function (`instance`) to the buffer, and\n-        // compute the data byte size used.\n-        let old_len = coverage_mappings_buffer.len();\n-        self.regions_to_mappings(regions_in_file_order, coverage_mappings_buffer);\n-        let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n-        debug_assert!(mapping_data_size > 0);\n-\n-        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n-        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n-        let function_source_hash = function_coverage.source_hash();\n-\n-        // Generate and return the function record\n-        let name_ref_val = cx.const_u64(name_ref);\n-        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n-        let func_hash_val = cx.const_u64(function_source_hash);\n-        Some(cx.const_struct(\n-            &[name_ref_val, mapping_data_size_val, func_hash_val],\n-            /*packed=*/ true,\n-        ))\n-    }\n-\n-    /// For each coverage region, extract its coverage data from the earlier coverage analysis.\n-    /// Use LLVM APIs to convert the data into buffered bytes compliant with the LLVM Coverage\n-    /// Mapping format.\n-    fn regions_to_mappings(\n-        &mut self,\n-        regions_in_file_order: BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>>,\n-        coverage_mappings_buffer: &RustString,\n-    ) {\n         let mut virtual_file_mapping = Vec::new();\n-        let mut mapping_regions = coverageinfo::SmallVectorCounterMappingRegion::new();\n-        let mut expressions = coverageinfo::SmallVectorCounterExpression::new();\n-\n-        for (file_id, (file_path, file_coverage_regions)) in\n-            regions_in_file_order.into_iter().enumerate()\n-        {\n-            let file_id = file_id as u32;\n-            let filename = CString::new(file_path.to_string_lossy().to_string())\n-                .expect(\"null error converting filename to C string\");\n-            debug!(\"  file_id: {} = '{:?}'\", file_id, filename);\n-            let filenames_index = match self.filename_to_index.get(&filename) {\n-                Some(index) => *index,\n-                None => {\n-                    let index = self.filenames.len() as u32;\n-                    self.filenames.push(filename.clone());\n-                    self.filename_to_index.insert(filename, index);\n-                    index\n+        let mut mapping_regions = Vec::new();\n+        let mut current_file_path = None;\n+        let mut current_file_id = 0;\n+\n+        // Convert the list of (Counter, Region) pairs to an array of `CounterMappingRegion`, sorted\n+        // by filename and position. Capture any new files to compute the `CounterMappingRegion`s\n+        // `file_id` (indexing files referenced by the current function), and construct the\n+        // function-specific `virtual_file_mapping` from `file_id` to its index in the module's\n+        // `filenames` array.\n+        counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n+        for (counter, region) in counter_regions {\n+            let (file_path, start_line, start_col, end_line, end_col) = region.file_start_and_end();\n+            let same_file = current_file_path.as_ref().map_or(false, |p| p == file_path);\n+            if !same_file {\n+                if current_file_path.is_some() {\n+                    current_file_id += 1;\n                 }\n-            };\n-            virtual_file_mapping.push(filenames_index);\n-\n-            let mut mapping_indexes = vec![0 as u32; file_coverage_regions.len()];\n-            for (mapping_index, (region_id, _)) in file_coverage_regions.values().enumerate() {\n-                mapping_indexes[*region_id] = mapping_index as u32;\n-            }\n-\n-            for (region_loc, (region_id, region_kind)) in file_coverage_regions.into_iter() {\n-                let mapping_index = mapping_indexes[region_id];\n-                match region_kind {\n-                    CoverageKind::Counter => {\n-                        debug!(\n-                            \"  Counter {}, file_id: {}, region_loc: {}\",\n-                            mapping_index, file_id, region_loc\n-                        );\n-                        mapping_regions.push_from(\n-                            mapping_index,\n-                            file_id,\n-                            region_loc.start_line,\n-                            region_loc.start_col,\n-                            region_loc.end_line,\n-                            region_loc.end_col,\n-                        );\n-                    }\n-                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n-                        debug!(\n-                            \"  CounterExpression {} = {} {:?} {}, file_id: {}, region_loc: {:?}\",\n-                            mapping_index, lhs, op, rhs, file_id, region_loc,\n-                        );\n-                        mapping_regions.push_from(\n-                            mapping_index,\n-                            file_id,\n-                            region_loc.start_line,\n-                            region_loc.start_col,\n-                            region_loc.end_line,\n-                            region_loc.end_col,\n-                        );\n-                        expressions.push_from(op, lhs, rhs);\n-                    }\n-                    CoverageKind::Unreachable => {\n-                        debug!(\n-                            \"  Unreachable region, file_id: {}, region_loc: {:?}\",\n-                            file_id, region_loc,\n-                        );\n-                        bug!(\"Unreachable region not expected and not yet handled!\")\n-                        // FIXME(richkadel): implement and call\n-                        //   mapping_regions.push_from(...) for unreachable regions\n+                current_file_path = Some(file_path.clone());\n+                let filename = CString::new(file_path.to_string_lossy().to_string())\n+                    .expect(\"null error converting filename to C string\");\n+                debug!(\"  file_id: {} = '{:?}'\", current_file_id, filename);\n+                let filenames_index = match self.filename_to_index.get(&filename) {\n+                    Some(index) => *index,\n+                    None => {\n+                        let index = self.filenames.len() as u32;\n+                        self.filenames.push(filename.clone());\n+                        self.filename_to_index.insert(filename.clone(), index);\n+                        index\n                     }\n-                }\n+                };\n+                virtual_file_mapping.push(filenames_index);\n             }\n+            mapping_regions.push(CounterMappingRegion::code_region(\n+                counter,\n+                current_file_id,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+            ));\n         }\n \n         // Encode and append the current function's coverage mapping data\n@@ -211,14 +152,35 @@ impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n         );\n     }\n \n-    fn write_coverage_map(\n+    /// Generate and return the function record `Value`\n+    fn make_function_record(\n+        &mut self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        mangled_function_name: String,\n+        function_source_hash: u64,\n+        mapping_data_size: usize,\n+    ) -> &'ll llvm::Value {\n+        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n+        let name_ref_val = cx.const_u64(name_ref);\n+        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n+        let func_hash_val = cx.const_u64(function_source_hash);\n+        cx.const_struct(\n+            &[name_ref_val, mapping_data_size_val, func_hash_val],\n+            /*packed=*/ true,\n+        )\n+    }\n+\n+    /// Combine the filenames and coverage mappings buffers, construct coverage map header and the\n+    /// array of function records, and combine everything into the complete coverage map. Save the\n+    /// coverage map data into the LLVM IR as a static global using a specific, well-known section\n+    /// and name.\n+    fn save_generated_coverage_map(\n         self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         function_records: Vec<&'ll llvm::Value>,\n         filenames_buffer: Vec<u8>,\n         mut coverage_mappings_buffer: Vec<u8>,\n     ) {\n-        let cx = self.cx;\n-\n         // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n         // bytes as-needed to ensure 8-byte alignment.\n         let mut coverage_size = coverage_mappings_buffer.len();"}, {"sha": "9d2090eae8f19669429e42c172942afa0d901973", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 31, "deletions": 123, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -4,8 +4,9 @@ use crate::builder::Builder;\n use crate::common::CodegenCx;\n \n use libc::c_uint;\n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n };\n@@ -23,15 +24,15 @@ const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n     // Coverage region data for each instrumented function identified by DefId.\n-    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage>>,\n+    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n }\n \n impl<'tcx> CrateCoverageContext<'tcx> {\n     pub fn new() -> Self {\n         Self { function_coverage_map: Default::default() }\n     }\n \n-    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage> {\n+    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>> {\n         self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n@@ -47,44 +48,49 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n-        index: u32,\n+        id: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, index={}, byte range {}..{}\",\n-            instance, function_source_hash, index, start_byte_pos, end_byte_pos,\n+            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={}, \\\n+             byte range {}..{}\",\n+            instance, function_source_hash, id, start_byte_pos, end_byte_pos,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_counter(function_source_hash, index, start_byte_pos, end_byte_pos);\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_counter(function_source_hash, id, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n-        index: u32,\n+        id_descending_from_max: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n-            instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+            \"adding counter expression to coverage_regions: instance={:?}, id={}, {} {:?} {}, \\\n+             byte range {}..{}\",\n+            instance, id_descending_from_max, lhs, op, rhs, start_byte_pos, end_byte_pos,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_counter_expression(index, lhs, op, rhs, start_byte_pos, end_byte_pos);\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_counter_expression(\n+                id_descending_from_max,\n+                lhs,\n+                op,\n+                rhs,\n+                start_byte_pos,\n+                end_byte_pos,\n+            );\n     }\n \n     fn add_unreachable_region(\n@@ -100,108 +106,8 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_unreachable(start_byte_pos, end_byte_pos);\n-    }\n-}\n-\n-/// This struct wraps an opaque reference to the C++ template instantiation of\n-/// `llvm::SmallVector<coverage::CounterExpression>`. Each `coverage::CounterExpression` object is\n-/// constructed from primative-typed arguments, and pushed to the `SmallVector`, in the C++\n-/// implementation of `LLVMRustCoverageSmallVectorCounterExpressionAdd()` (see\n-/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n-pub struct SmallVectorCounterExpression<'a> {\n-    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterExpression<'a>,\n-}\n-\n-impl SmallVectorCounterExpression<'a> {\n-    pub fn new() -> Self {\n-        SmallVectorCounterExpression {\n-            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterExpressionCreate() },\n-        }\n-    }\n-\n-    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterExpression<'a> {\n-        self.raw\n-    }\n-\n-    pub fn push_from(\n-        &mut self,\n-        kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n-        left_index: u32,\n-        right_index: u32,\n-    ) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterExpressionAdd(\n-                &mut *(self.raw as *mut _),\n-                kind,\n-                left_index,\n-                right_index,\n-            )\n-        }\n-    }\n-}\n-\n-impl Drop for SmallVectorCounterExpression<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterExpressionDispose(&mut *(self.raw as *mut _));\n-        }\n-    }\n-}\n-\n-/// This struct wraps an opaque reference to the C++ template instantiation of\n-/// `llvm::SmallVector<coverage::CounterMappingRegion>`. Each `coverage::CounterMappingRegion`\n-/// object is constructed from primative-typed arguments, and pushed to the `SmallVector`, in the\n-/// C++ implementation of `LLVMRustCoverageSmallVectorCounterMappingRegionAdd()` (see\n-/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n-pub struct SmallVectorCounterMappingRegion<'a> {\n-    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterMappingRegion<'a>,\n-}\n-\n-impl SmallVectorCounterMappingRegion<'a> {\n-    pub fn new() -> Self {\n-        SmallVectorCounterMappingRegion {\n-            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterMappingRegionCreate() },\n-        }\n-    }\n-\n-    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterMappingRegion<'a> {\n-        self.raw\n-    }\n-\n-    pub fn push_from(\n-        &mut self,\n-        index: u32,\n-        file_id: u32,\n-        line_start: u32,\n-        column_start: u32,\n-        line_end: u32,\n-        column_end: u32,\n-    ) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n-                &mut *(self.raw as *mut _),\n-                index,\n-                file_id,\n-                line_start,\n-                column_start,\n-                line_end,\n-                column_end,\n-            )\n-        }\n-    }\n-}\n-\n-impl Drop for SmallVectorCounterMappingRegion<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n-                &mut *(self.raw as *mut _),\n-            );\n-        }\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_unreachable_region(start_byte_pos, end_byte_pos);\n     }\n }\n \n@@ -218,16 +124,18 @@ pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer\n \n pub(crate) fn write_mapping_to_buffer(\n     virtual_file_mapping: Vec<u32>,\n-    expressions: SmallVectorCounterExpression<'_>,\n-    mapping_regions: SmallVectorCounterMappingRegion<'_>,\n+    expressions: Vec<CounterExpression>,\n+    mut mapping_regions: Vec<CounterMappingRegion>,\n     buffer: &RustString,\n ) {\n     unsafe {\n         llvm::LLVMRustCoverageWriteMappingToBuffer(\n             virtual_file_mapping.as_ptr(),\n             virtual_file_mapping.len() as c_uint,\n             expressions.as_ptr(),\n-            mapping_regions.as_ptr(),\n+            expressions.len() as c_uint,\n+            mapping_regions.as_mut_ptr(),\n+            mapping_regions.len() as c_uint,\n             buffer,\n         );\n     }"}, {"sha": "236f7f696533d44d2ceb6383eb78a0cec238d7b3", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::coverageinfo::CounterOp;\n+use rustc_codegen_ssa::coverageinfo::ExprKind;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -101,7 +101,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.add_counter_region(\n                         caller_instance,\n                         op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                        op_to_u32(&args[COUNTER_INDEX]),\n+                        op_to_u32(&args[COUNTER_ID]),\n                         op_to_u32(&args[START_BYTE_POS]),\n                         op_to_u32(&args[END_BYTE_POS]),\n                     );\n@@ -111,14 +111,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     use coverage::coverage_counter_expression_args::*;\n                     self.add_counter_expression_region(\n                         caller_instance,\n-                        op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n-                        op_to_u32(&args[LEFT_INDEX]),\n+                        op_to_u32(&args[EXPRESSION_ID]),\n+                        op_to_u32(&args[LEFT_ID]),\n                         if intrinsic == sym::coverage_counter_add {\n-                            CounterOp::Add\n+                            ExprKind::Add\n                         } else {\n-                            CounterOp::Subtract\n+                            ExprKind::Subtract\n                         },\n-                        op_to_u32(&args[RIGHT_INDEX]),\n+                        op_to_u32(&args[RIGHT_ID]),\n                         op_to_u32(&args[START_BYTE_POS]),\n                         op_to_u32(&args[END_BYTE_POS]),\n                     );\n@@ -219,7 +219,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n                 let hash = args[FUNCTION_SOURCE_HASH].immediate();\n-                let index = args[COUNTER_INDEX].immediate();\n+                let index = args[COUNTER_ID].immediate();\n                 debug!(\n                     \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n                     instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\","}, {"sha": "eb7dc827f9391b38fa15c332c9f79d805038879c", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 147, "deletions": 33, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n \n-use super::coverageinfo::{SmallVectorCounterExpression, SmallVectorCounterMappingRegion};\n+use rustc_codegen_ssa::coverageinfo::map as coverage_map;\n \n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n@@ -653,13 +653,152 @@ pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n \n pub mod coverageinfo {\n-    use super::InvariantOpaque;\n+    use super::coverage_map;\n \n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n+    #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n-    pub struct SmallVectorCounterExpression<'a>(InvariantOpaque<'a>);\n+    pub enum RegionKind {\n+        /// A CodeRegion associates some code with a counter\n+        CodeRegion = 0,\n+\n+        /// An ExpansionRegion represents a file expansion region that associates\n+        /// a source range with the expansion of a virtual source file, such as\n+        /// for a macro instantiation or #include file.\n+        ExpansionRegion = 1,\n+\n+        /// A SkippedRegion represents a source range with code that was skipped\n+        /// by a preprocessor or similar means.\n+        SkippedRegion = 2,\n+\n+        /// A GapRegion is like a CodeRegion, but its count is only set as the\n+        /// line execution count when its the only region in the line.\n+        GapRegion = 3,\n+    }\n \n+    /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n+    /// coverage map, in accordance with the\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n+    /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n+    /// array\", encoded separately), and source location (start and end positions of the represented\n+    /// code region).\n+    ///\n+    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+    /// Important: The Rust struct layout (order and types of fields) must match its C++\n+    /// counterpart.\n+    #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n-    pub struct SmallVectorCounterMappingRegion<'a>(InvariantOpaque<'a>);\n+    pub struct CounterMappingRegion {\n+        /// The counter type and type-dependent counter data, if any.\n+        counter: coverage_map::Counter,\n+\n+        /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n+        /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes\n+        /// that, in turn, are used to look up the filename for this region.\n+        file_id: u32,\n+\n+        /// If the `RegionKind` is an `ExpansionRegion`, the `expanded_file_id` can be used to find\n+        /// the mapping regions created as a result of macro expansion, by checking if their file id\n+        /// matches the expanded file id.\n+        expanded_file_id: u32,\n+\n+        /// 1-based starting line of the mapping region.\n+        start_line: u32,\n+\n+        /// 1-based starting column of the mapping region.\n+        start_col: u32,\n+\n+        /// 1-based ending line of the mapping region.\n+        end_line: u32,\n+\n+        /// 1-based ending column of the mapping region. If the high bit is set, the current\n+        /// mapping region is a gap area.\n+        end_col: u32,\n+\n+        kind: RegionKind,\n+    }\n+\n+    impl CounterMappingRegion {\n+        pub fn code_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::CodeRegion,\n+            }\n+        }\n+\n+        pub fn expansion_region(\n+            file_id: u32,\n+            expanded_file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::ExpansionRegion,\n+            }\n+        }\n+\n+        pub fn skipped_region(\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::SkippedRegion,\n+            }\n+        }\n+\n+        pub fn gap_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col: ((1 as u32) << 31) | end_col,\n+                kind: RegionKind::GapRegion,\n+            }\n+        }\n+    }\n }\n \n pub mod debuginfo {\n@@ -1645,33 +1784,6 @@ extern \"C\" {\n         ConstraintsLen: size_t,\n     ) -> bool;\n \n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionCreate()\n-    -> &'a mut SmallVectorCounterExpression<'a>;\n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionDispose(\n-        Container: &'a mut SmallVectorCounterExpression<'a>,\n-    );\n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionAdd(\n-        Container: &mut SmallVectorCounterExpression<'a>,\n-        Kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n-        LeftIndex: c_uint,\n-        RightIndex: c_uint,\n-    );\n-\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionCreate()\n-    -> &'a mut SmallVectorCounterMappingRegion<'a>;\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n-        Container: &'a mut SmallVectorCounterMappingRegion<'a>,\n-    );\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n-        Container: &mut SmallVectorCounterMappingRegion<'a>,\n-        Index: c_uint,\n-        FileID: c_uint,\n-        LineStart: c_uint,\n-        ColumnStart: c_uint,\n-        LineEnd: c_uint,\n-        ColumnEnd: c_uint,\n-    );\n-\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustCoverageWriteFilenamesSectionToBuffer(\n         Filenames: *const *const c_char,\n@@ -1683,8 +1795,10 @@ extern \"C\" {\n     pub fn LLVMRustCoverageWriteMappingToBuffer(\n         VirtualFileMappingIDs: *const c_uint,\n         NumVirtualFileMappingIDs: c_uint,\n-        Expressions: *const SmallVectorCounterExpression<'_>,\n-        MappingRegions: *const SmallVectorCounterMappingRegion<'_>,\n+        Expressions: *const coverage_map::CounterExpression,\n+        NumExpressions: c_uint,\n+        MappingRegions: *mut coverageinfo::CounterMappingRegion,\n+        NumMappingRegions: c_uint,\n         BufferOut: &RustString,\n     );\n "}, {"sha": "5b04f99499437fead897b7edfd29dd573bc52fd0", "filename": "src/librustc_codegen_ssa/coverageinfo/ffi.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -0,0 +1,67 @@\n+use super::map::{CounterValueReference, MappedExpressionIndex};\n+\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+enum CounterKind {\n+    Zero = 0,\n+    CounterValueReference = 1,\n+    Expression = 2,\n+}\n+\n+/// A reference to an instance of an abstract \"counter\" that will yield a value in a coverage\n+/// report. Note that `id` has different interpretations, depending on the `kind`:\n+///   * For `CounterKind::Zero`, `id` is assumed to be `0`\n+///   * For `CounterKind::CounterValueReference`,  `id` matches the `counter_id` of the injected\n+///     instrumentation counter (the `index` argument to the LLVM intrinsic\n+///     `instrprof.increment()`)\n+///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n+///     counter expressions.\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct Counter {\n+    // Important: The layout (order and types of fields) must match its C++ counterpart.\n+    kind: CounterKind,\n+    id: u32,\n+}\n+\n+impl Counter {\n+    pub fn zero() -> Self {\n+        Self { kind: CounterKind::Zero, id: 0 }\n+    }\n+\n+    pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+    }\n+\n+    pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n+        Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n+    }\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub enum ExprKind {\n+    Subtract = 0,\n+    Add = 1,\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++\n+/// counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct CounterExpression {\n+    kind: ExprKind,\n+    lhs: Counter,\n+    rhs: Counter,\n+}\n+\n+impl CounterExpression {\n+    pub fn new(lhs: Counter, kind: ExprKind, rhs: Counter) -> Self {\n+        Self { kind, lhs, rhs }\n+    }\n+}"}, {"sha": "1e36c90baafdf85ec039ec516c8972c4032de30d", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 281, "deletions": 210, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,289 +1,360 @@\n-use rustc_data_structures::sync::Lrc;\n-use rustc_middle::mir;\n-use rustc_span::source_map::{Pos, SourceFile, SourceMap};\n-use rustc_span::{BytePos, FileName, RealFileName};\n+pub use super::ffi::*;\n+\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::Instance;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::source_map::{Pos, SourceMap};\n+use rustc_span::{BytePos, FileName, Loc, RealFileName};\n \n use std::cmp::{Ord, Ordering};\n-use std::collections::BTreeMap;\n use std::fmt;\n use std::path::PathBuf;\n \n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub enum CounterOp {\n-    // Note the order (and therefore the default values) is important. With the attribute\n-    // `#[repr(C)]`, this enum matches the layout of the LLVM enum defined for the nested enum,\n-    // `llvm::coverage::CounterExpression::ExprKind`, as shown in the following source snippet:\n-    // https://github.com/rust-lang/llvm-project/blob/f208b70fbc4dee78067b3c5bd6cb92aa3ba58a1e/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146\n-    Subtract,\n-    Add,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum CoverageKind {\n-    Counter,\n-    CounterExpression(u32, CounterOp, u32),\n-    Unreachable,\n+rustc_index::newtype_index! {\n+    pub struct ExpressionOperandId {\n+        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct CoverageRegion {\n-    pub kind: CoverageKind,\n-    pub start_byte_pos: u32,\n-    pub end_byte_pos: u32,\n+rustc_index::newtype_index! {\n+    pub struct CounterValueReference {\n+        DEBUG_FORMAT = \"CounterValueReference({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n }\n \n-impl CoverageRegion {\n-    pub fn source_loc(&self, source_map: &SourceMap) -> Option<(Lrc<SourceFile>, CoverageLoc)> {\n-        let (start_file, start_line, start_col) =\n-            lookup_file_line_col(source_map, BytePos::from_u32(self.start_byte_pos));\n-        let (end_file, end_line, end_col) =\n-            lookup_file_line_col(source_map, BytePos::from_u32(self.end_byte_pos));\n-        let start_file_path = match &start_file.name {\n-            FileName::Real(RealFileName::Named(path)) => path,\n-            _ => {\n-                bug!(\"start_file_path should be a RealFileName, but it was: {:?}\", start_file.name)\n-            }\n-        };\n-        let end_file_path = match &end_file.name {\n-            FileName::Real(RealFileName::Named(path)) => path,\n-            _ => bug!(\"end_file_path should be a RealFileName, but it was: {:?}\", end_file.name),\n-        };\n-        if start_file_path == end_file_path {\n-            Some((start_file, CoverageLoc { start_line, start_col, end_line, end_col }))\n-        } else {\n-            None\n-            // FIXME(richkadel): There seems to be a problem computing the file location in\n-            // some cases. I need to investigate this more. When I generate and show coverage\n-            // for the example binary in the crates.io crate `json5format`, I had a couple of\n-            // notable problems:\n-            //\n-            //   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n-            //      various comments (not corresponding to rustdoc code), indicating a possible\n-            //      problem with the byte_pos-to-source-map implementation.\n-            //\n-            //   2. And (perhaps not related) when I build the aforementioned example binary with:\n-            //      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n-            //      and then run that binary with\n-            //      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n-            //      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n-            //      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n-            //      name, in this case).\n-            //\n-            // If the byte range conversion is wrong, fix it. But if it\n-            // is right, then it is possible for the start and end to be in different files.\n-            // Can I do something other than ignore coverages that span multiple files?\n-            //\n-            // If I can resolve this, remove the \"Option<>\" result type wrapper\n-            // `regions_in_file_order()` accordingly.\n-        }\n+rustc_index::newtype_index! {\n+    pub struct InjectedExpressionIndex {\n+        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n     }\n }\n \n-impl Default for CoverageRegion {\n-    fn default() -> Self {\n-        Self {\n-            // The default kind (Unreachable) is a placeholder that will be overwritten before\n-            // backend codegen.\n-            kind: CoverageKind::Unreachable,\n-            start_byte_pos: 0,\n-            end_byte_pos: 0,\n-        }\n+rustc_index::newtype_index! {\n+    pub struct MappedExpressionIndex {\n+        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n     }\n }\n \n-/// A source code region used with coverage information.\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct CoverageLoc {\n-    /// The (1-based) line number of the region start.\n-    pub start_line: u32,\n-    /// The (1-based) column number of the region start.\n-    pub start_col: u32,\n-    /// The (1-based) line number of the region end.\n-    pub end_line: u32,\n-    /// The (1-based) column number of the region end.\n-    pub end_col: u32,\n+#[derive(Clone, Debug)]\n+pub struct Region {\n+    start: Loc,\n+    end: Loc,\n }\n \n-impl Ord for CoverageLoc {\n+impl Ord for Region {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (self.start_line, &self.start_col, &self.end_line, &self.end_col).cmp(&(\n-            other.start_line,\n-            &other.start_col,\n-            &other.end_line,\n-            &other.end_col,\n-        ))\n+        (&self.start.file.name, &self.start.line, &self.start.col, &self.end.line, &self.end.col)\n+            .cmp(&(\n+                &other.start.file.name,\n+                &other.start.line,\n+                &other.start.col,\n+                &other.end.line,\n+                &other.end.col,\n+            ))\n     }\n }\n \n-impl PartialOrd for CoverageLoc {\n+impl PartialOrd for Region {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-impl fmt::Display for CoverageLoc {\n+impl PartialEq for Region {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.start.file.name == other.start.file.name\n+            && self.start.line == other.start.line\n+            && self.start.col == other.start.col\n+            && self.end.line == other.end.line\n+            && self.end.col == other.end.col\n+    }\n+}\n+\n+impl Eq for Region {}\n+\n+impl fmt::Display for Region {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Customize debug format, and repeat the file name, so generated location strings are\n-        // \"clickable\" in many IDEs.\n-        write!(f, \"{}:{} - {}:{}\", self.start_line, self.start_col, self.end_line, self.end_col)\n+        let (file_path, start_line, start_col, end_line, end_col) = self.file_start_and_end();\n+        write!(f, \"{:?}:{}:{} - {}:{}\", file_path, start_line, start_col, end_line, end_col)\n     }\n }\n \n-fn lookup_file_line_col(source_map: &SourceMap, byte_pos: BytePos) -> (Lrc<SourceFile>, u32, u32) {\n-    let found = source_map\n-        .lookup_line(byte_pos)\n-        .expect(\"should find coverage region byte position in source\");\n-    let file = found.sf;\n-    let line_pos = file.line_begin_pos(byte_pos);\n+impl Region {\n+    pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n+        let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n+        let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n+        assert_eq!(start.file.name, end.file.name);\n+        Self { start, end }\n+    }\n \n-    // Use 1-based indexing.\n-    let line = (found.line + 1) as u32;\n-    let col = (byte_pos - line_pos).to_u32() + 1;\n+    pub fn file_start_and_end<'a>(&'a self) -> (&'a PathBuf, u32, u32, u32, u32) {\n+        let start = &self.start;\n+        let end = &self.end;\n+        match &start.file.name {\n+            FileName::Real(RealFileName::Named(path)) => (\n+                path,\n+                start.line as u32,\n+                start.col.to_u32() + 1,\n+                end.line as u32,\n+                end.col.to_u32() + 1,\n+            ),\n+            _ => {\n+                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n+            }\n+        }\n+    }\n+}\n \n-    (file, line, col)\n+#[derive(Clone, Debug)]\n+pub struct ExpressionRegion {\n+    lhs: ExpressionOperandId,\n+    op: ExprKind,\n+    rhs: ExpressionOperandId,\n+    region: Region,\n }\n \n+// FIXME(richkadel): There seems to be a problem computing the file location in\n+// some cases. I need to investigate this more. When I generate and show coverage\n+// for the example binary in the crates.io crate `json5format`, I had a couple of\n+// notable problems:\n+//\n+//   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n+//      various comments (not corresponding to rustdoc code), indicating a possible\n+//      problem with the byte_pos-to-source-map implementation.\n+//\n+//   2. And (perhaps not related) when I build the aforementioned example binary with:\n+//      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n+//      and then run that binary with\n+//      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n+//      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n+//      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n+//      name, in this case).\n+//\n+//   3. I think that if I eliminate regions within a function, their region_ids,\n+//      referenced in expressions, will be wrong? I think the ids are implied by their\n+//      array position in the final coverage map output (IIRC).\n+//\n+//   4. I suspect a problem (if not the only problem) is the SourceMap is wrong for some\n+//      region start/end byte positions. Just like I couldn't get the function hash at\n+//      intrinsic codegen time for external crate functions, I think the SourceMap I\n+//      have here only applies to the local crate, and I know I have coverages that\n+//      reference external crates.\n+//\n+//          I still don't know if I fixed the hash problem correctly. If external crates\n+//          implement the function, can't I use the coverage counters already compiled\n+//          into those external crates? (Maybe not for generics and/or maybe not for\n+//          macros... not sure. But I need to understand this better.)\n+//\n+// If the byte range conversion is wrong, fix it. But if it\n+// is right, then it is possible for the start and end to be in different files.\n+// Can I do something other than ignore coverages that span multiple files?\n+//\n+// If I can resolve this, remove the \"Option<>\" result type wrapper\n+// `regions_in_file_order()` accordingly.\n+\n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n-/// for a given Function. Counters and counter expressions are indexed because they can be operands\n-/// in an expression. This struct also stores the `function_source_hash`, computed during\n-/// instrumentation and forwarded with counters.\n+/// for a given Function. Counters and counter expressions have non-overlapping `id`s because they\n+/// can both be operands in an expression. This struct also stores the `function_source_hash`,\n+/// computed during instrumentation, and forwarded with counters.\n ///\n-/// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n-/// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n-/// counter or expression), but the line or lines in the gap region are not executable (such as\n-/// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n-/// \"A count for a gap area is only used as the line execution count if there are no other regions\n-/// on a line.\"\n-pub struct FunctionCoverage {\n+/// Note, it may be important to understand LLVM's definitions of `unreachable` regions versus \"gap\n+/// regions\" (or \"gap areas\"). A gap region is a code region within a counted region (either counter\n+/// or expression), but the line or lines in the gap region are not executable (such as lines with\n+/// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n+/// for a gap area is only used as the line execution count if there are no other regions on a\n+/// line.\"\n+pub struct FunctionCoverage<'a> {\n+    source_map: &'a SourceMap,\n     source_hash: u64,\n-    counters: Vec<CoverageRegion>,\n-    expressions: Vec<CoverageRegion>,\n-    unreachable: Vec<CoverageRegion>,\n-    translated: bool,\n+    counters: IndexVec<CounterValueReference, Option<Region>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n+    unreachable_regions: Vec<Region>,\n }\n \n-impl FunctionCoverage {\n-    pub fn with_coverageinfo<'tcx>(coverageinfo: &'tcx mir::CoverageInfo) -> Self {\n+impl<'a> FunctionCoverage<'a> {\n+    pub fn new<'tcx: 'a>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+        let coverageinfo = tcx.coverageinfo(instance.def_id());\n         Self {\n+            source_map: tcx.sess.source_map(),\n             source_hash: 0, // will be set with the first `add_counter()`\n-            counters: vec![CoverageRegion::default(); coverageinfo.num_counters as usize],\n-            expressions: vec![CoverageRegion::default(); coverageinfo.num_expressions as usize],\n-            unreachable: Vec::new(),\n-            translated: false,\n+            counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n+            expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n+            unreachable_regions: Vec::new(),\n         }\n     }\n \n-    /// Adds a code region to be counted by an injected counter intrinsic. Return a counter ID\n-    /// for the call.\n+    /// Adds a code region to be counted by an injected counter intrinsic.\n+    /// The source_hash (computed during coverage instrumentation) should also be provided, and\n+    /// should be the same for all counters in a given function.\n     pub fn add_counter(\n         &mut self,\n         source_hash: u64,\n-        index: u32,\n+        id: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        self.source_hash = source_hash;\n-        self.counters[index as usize] =\n-            CoverageRegion { kind: CoverageKind::Counter, start_byte_pos, end_byte_pos };\n+        if self.source_hash == 0 {\n+            self.source_hash = source_hash;\n+        } else {\n+            debug_assert_eq!(source_hash, self.source_hash);\n+        }\n+        self.counters[CounterValueReference::from(id)]\n+            .replace(Region::new(self.source_map, start_byte_pos, end_byte_pos))\n+            .expect_none(\"add_counter called with duplicate `id`\");\n     }\n \n+    /// Both counters and \"counter expressions\" (or simply, \"expressions\") can be operands in other\n+    /// expressions. Expression IDs start from `u32::MAX` and go down, so the range of expression\n+    /// IDs will not overlap with the range of counter IDs. Counters and expressions can be added in\n+    /// any order, and expressions can still be assigned contiguous (though descending) IDs, without\n+    /// knowing what the last counter ID will be.\n+    ///\n+    /// When storing the expression data in the `expressions` vector in the `FunctionCoverage`\n+    /// struct, its vector index is computed, from the given expression ID, by subtracting from\n+    /// `u32::MAX`.\n+    ///\n+    /// Since the expression operands (`lhs` and `rhs`) can reference either counters or\n+    /// expressions, an operand that references an expression also uses its original ID, descending\n+    /// from `u32::MAX`. Theses operands are translated only during code generation, after all\n+    /// counters and expressions have been added.\n     pub fn add_counter_expression(\n         &mut self,\n-        translated_index: u32,\n+        id_descending_from_max: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        let index = u32::MAX - translated_index;\n-        // Counter expressions start with \"translated indexes\", descending from `u32::MAX`, so\n-        // the range of expression indexes is disjoint from the range of counter indexes. This way,\n-        // both counters and expressions can be operands in other expressions.\n-        //\n-        // Once all counters have been added, the final \"region index\" for an expression is\n-        // `counters.len() + expression_index` (where `expression_index` is its index in\n-        // `self.expressions`), and the expression operands (`lhs` and `rhs`) can be converted to\n-        // final \"region index\" references by the same conversion, after subtracting from\n-        // `u32::MAX`.\n-        self.expressions[index as usize] = CoverageRegion {\n-            kind: CoverageKind::CounterExpression(lhs, op, rhs),\n-            start_byte_pos,\n-            end_byte_pos,\n-        };\n+        let expression_id = ExpressionOperandId::from(id_descending_from_max);\n+        let lhs = ExpressionOperandId::from(lhs);\n+        let rhs = ExpressionOperandId::from(rhs);\n+\n+        let expression_index = self.expression_index(expression_id);\n+        self.expressions[expression_index]\n+            .replace(ExpressionRegion {\n+                lhs,\n+                op,\n+                rhs,\n+                region: Region::new(self.source_map, start_byte_pos, end_byte_pos),\n+            })\n+            .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n     }\n \n-    pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable.push(CoverageRegion {\n-            kind: CoverageKind::Unreachable,\n-            start_byte_pos,\n-            end_byte_pos,\n-        });\n+    /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n+    pub fn add_unreachable_region(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.unreachable_regions.push(Region::new(self.source_map, start_byte_pos, end_byte_pos));\n     }\n \n+    /// Return the source hash, generated from the HIR node structure, and used to indicate whether\n+    /// or not the source code structure changed between different compilations.\n     pub fn source_hash(&self) -> u64 {\n         self.source_hash\n     }\n \n-    fn regions(&'a mut self) -> impl Iterator<Item = &'a CoverageRegion> {\n+    /// Generate an array of CounterExpressions, and an iterator over all `Counter`s and their\n+    /// associated `Regions` (from which the LLVM-specific `CoverageMapGenerator` will create\n+    /// `CounterMappingRegion`s.\n+    pub fn get_expressions_and_counter_regions(\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n         assert!(self.source_hash != 0);\n-        self.ensure_expressions_translated();\n-        self.counters.iter().chain(self.expressions.iter().chain(self.unreachable.iter()))\n+\n+        let counter_regions = self.counter_regions();\n+        let (counter_expressions, expression_regions) = self.expressions_with_regions();\n+        let unreachable_regions = self.unreachable_regions();\n+\n+        let counter_regions =\n+            counter_regions.chain(expression_regions.into_iter().chain(unreachable_regions));\n+        (counter_expressions, counter_regions)\n     }\n \n-    pub fn regions_in_file_order(\n-        &'a mut self,\n-        source_map: &SourceMap,\n-    ) -> BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>> {\n-        let mut regions_in_file_order = BTreeMap::new();\n-        for (region_id, region) in self.regions().enumerate() {\n-            if let Some((source_file, region_loc)) = region.source_loc(source_map) {\n-                // FIXME(richkadel): `region.source_loc()` sometimes fails with two different\n-                // filenames for the start and end byte position. This seems wrong, but for\n-                // now, if encountered, the region is skipped. If resolved, convert the result\n-                // to a non-option value so regions are never skipped.\n-                let real_file_path = match &(*source_file).name {\n-                    FileName::Real(RealFileName::Named(path)) => path.clone(),\n-                    _ => bug!(\"coverage mapping expected only real, named files\"),\n-                };\n-                let file_coverage_regions =\n-                    regions_in_file_order.entry(real_file_path).or_insert_with(|| BTreeMap::new());\n-                file_coverage_regions.insert(region_loc, (region_id, region.kind));\n-            }\n-        }\n-        regions_in_file_order\n+    fn counter_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+        self.counters.iter_enumerated().filter_map(|(index, entry)| {\n+            // Option::map() will return None to filter out missing counters. This may happen\n+            // if, for example, a MIR-instrumented counter is removed during an optimization.\n+            entry.as_ref().map(|region| {\n+                (Counter::counter_value_reference(index as CounterValueReference), region)\n+            })\n+        })\n     }\n \n-    /// A one-time translation of expression operands is needed, for any operands referencing\n-    /// other CounterExpressions. CounterExpression operands get an initial operand ID that is\n-    /// computed by the simple translation: `u32::max - expression_index` because, when created,\n-    /// the total number of Counters is not yet known. This function recomputes region indexes\n-    /// for expressions so they start with the next region index after the last counter index.\n-    fn ensure_expressions_translated(&mut self) {\n-        if !self.translated {\n-            self.translated = true;\n-            let start = self.counters.len() as u32;\n-            assert!(\n-                (start as u64 + self.expressions.len() as u64) < u32::MAX as u64,\n-                \"the number of counters and counter expressions in a single function exceeds {}\",\n-                u32::MAX\n-            );\n-            for region in self.expressions.iter_mut() {\n-                match region.kind {\n-                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n-                        let lhs = to_region_index(start, lhs);\n-                        let rhs = to_region_index(start, rhs);\n-                        region.kind = CoverageKind::CounterExpression(lhs, op, rhs);\n-                    }\n-                    _ => bug!(\"expressions must only contain CounterExpression kinds\"),\n+    fn expressions_with_regions(\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n+        let mut expression_regions = Vec::with_capacity(self.expressions.len());\n+        let mut new_indexes =\n+            IndexVec::from_elem_n(MappedExpressionIndex::from(u32::MAX), self.expressions.len());\n+        // Note, the initial value shouldn't matter since every index in use in `self.expressions`\n+        // will be set, and after that, `new_indexes` will only be accessed using those same\n+        // indexes.\n+\n+        // Note that an `ExpressionRegion`s at any given index can include other expressions as\n+        // operands, but expression operands can only come from the subset of expressions having\n+        // `expression_index`s lower than the referencing `ExpressionRegion`. Therefore, it is\n+        // reasonable to look up the new index of an expression operand while the `new_indexes`\n+        // vector is only complete up to the current `ExpressionIndex`.\n+        let id_to_counter =\n+            |new_indexes: &IndexVec<InjectedExpressionIndex, MappedExpressionIndex>,\n+             id: ExpressionOperandId| {\n+                if id.index() < self.counters.len() {\n+                    let index = CounterValueReference::from(id.index());\n+                    self.counters\n+                        .get(index)\n+                        .unwrap() // pre-validated\n+                        .as_ref()\n+                        .map(|_| Counter::counter_value_reference(index))\n+                } else {\n+                    let index = self.expression_index(id);\n+                    self.expressions\n+                        .get(index)\n+                        .expect(\"expression id is out of range\")\n+                        .as_ref()\n+                        .map(|_| Counter::expression(new_indexes[index]))\n                 }\n+            };\n+\n+        for (original_index, expression_region) in\n+            self.expressions.iter_enumerated().filter_map(|(original_index, entry)| {\n+                // Option::map() will return None to filter out missing expressions. This may happen\n+                // if, for example, a MIR-instrumented expression is removed during an optimization.\n+                entry.as_ref().map(|region| (original_index, region))\n+            })\n+        {\n+            let region = &expression_region.region;\n+            let ExpressionRegion { lhs, op, rhs, .. } = *expression_region;\n+\n+            if let Some(Some((lhs_counter, rhs_counter))) =\n+                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+                    id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n+                })\n+            {\n+                // Both operands exist. `Expression` operands exist in `self.expressions` and have\n+                // been assigned a `new_index`.\n+                let mapped_expression_index =\n+                    MappedExpressionIndex::from(counter_expressions.len());\n+                counter_expressions.push(CounterExpression::new(lhs_counter, op, rhs_counter));\n+                new_indexes[original_index] = mapped_expression_index;\n+                expression_regions.push((Counter::expression(mapped_expression_index), region));\n             }\n         }\n+        (counter_expressions, expression_regions.into_iter())\n+    }\n+\n+    fn unreachable_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+        self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n-}\n \n-fn to_region_index(start: u32, index: u32) -> u32 {\n-    if index < start { index } else { start + (u32::MAX - index) }\n+    fn expression_index(\n+        &self,\n+        id_descending_from_max: ExpressionOperandId,\n+    ) -> InjectedExpressionIndex {\n+        debug_assert!(id_descending_from_max.index() >= self.counters.len());\n+        InjectedExpressionIndex::from(u32::MAX - u32::from(id_descending_from_max))\n+    }\n }"}, {"sha": "1f0ffd289b13a7ca9a158ecb9d42634c8f1cce49", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,3 +1,4 @@\n+pub mod ffi;\n pub mod map;\n \n-pub use map::CounterOp;\n+pub use map::ExprKind;"}, {"sha": "85260d30a3d7c36292b30580c427e8d392df94ba", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,12 +1,15 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n+#![feature(option_expect_none)]\n #![feature(box_patterns)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(trusted_len)]\n #![feature(associated_type_bounds)]\n+#![feature(const_fn)] // for rustc_index::newtype_index\n+#![feature(const_panic)] // for rustc_index::newtype_index\n #![recursion_limit = \"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others)."}, {"sha": "db1d86c974ea885477c19222b5f2ea2e5c8fd8f5", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::coverageinfo::CounterOp;\n+use crate::coverageinfo::ExprKind;\n use rustc_middle::ty::Instance;\n \n pub trait CoverageInfoMethods: BackendTypes {\n@@ -21,7 +21,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         index: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,"}, {"sha": "82365ef6a73de8ebb2e5f05ad0af9d2717b3a328", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -3,17 +3,17 @@\n /// Positional arguments to `libcore::count_code_region()`\n pub mod count_code_region_args {\n     pub const FUNCTION_SOURCE_HASH: usize = 0;\n-    pub const COUNTER_INDEX: usize = 1;\n+    pub const COUNTER_ID: usize = 1;\n     pub const START_BYTE_POS: usize = 2;\n     pub const END_BYTE_POS: usize = 3;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and\n /// `libcore::coverage_counter_subtract()`\n pub mod coverage_counter_expression_args {\n-    pub const COUNTER_EXPRESSION_INDEX: usize = 0;\n-    pub const LEFT_INDEX: usize = 1;\n-    pub const RIGHT_INDEX: usize = 2;\n+    pub const EXPRESSION_ID: usize = 0;\n+    pub const LEFT_ID: usize = 1;\n+    pub const RIGHT_ID: usize = 2;\n     pub const START_BYTE_POS: usize = 3;\n     pub const END_BYTE_POS: usize = 4;\n }"}, {"sha": "fe63a67fdbb34cd1041ce89ce95584d5a37a9c2f", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 111, "deletions": 85, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -7,10 +7,9 @@ use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::CoverageInfo;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, Operand, Place, SourceInfo, StatementKind,\n-    Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo,\n+    SourceScope, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n@@ -41,14 +40,14 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n-    // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+    // counters, with each counter having a counter ID from `0..num_counters-1`. MIR optimization\n     // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n-    // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+    // work; but computing the num_counters by adding `1` to the highest counter_id (for a given\n     // instrumented function) is valid.\n     //\n     // `num_expressions` is the number of counter expressions added to the MIR body. Both\n     // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n-    // code generate, to lookup counters and expressions by their simple u32 indexes.\n+    // code generate, to lookup counters and expressions by simple u32 indexes.\n     let mut num_counters: u32 = 0;\n     let mut num_expressions: u32 = 0;\n     for terminator in\n@@ -57,27 +56,26 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n             match func.literal.ty.kind {\n                 FnDef(id, _) if id == count_code_region_fn => {\n-                    let index_arg =\n-                        args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n-                    let counter_index = mir::Operand::scalar_from_const(index_arg)\n+                    let counter_id_arg =\n+                        args.get(count_code_region_args::COUNTER_ID).expect(\"arg found\");\n+                    let counter_id = mir::Operand::scalar_from_const(counter_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    num_counters = std::cmp::max(num_counters, counter_index + 1);\n+                        .expect(\"counter_id arg is u32\");\n+                    num_counters = std::cmp::max(num_counters, counter_id + 1);\n                 }\n                 FnDef(id, _)\n                     if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n                 {\n-                    let index_arg = args\n-                        .get(coverage_counter_expression_args::COUNTER_EXPRESSION_INDEX)\n+                    let expression_id_arg = args\n+                        .get(coverage_counter_expression_args::EXPRESSION_ID)\n                         .expect(\"arg found\");\n-                    let translated_index = mir::Operand::scalar_from_const(index_arg)\n+                    let id_descending_from_max = mir::Operand::scalar_from_const(expression_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    // Counter expressions start with \"translated indexes\", descending from\n-                    // `u32::MAX`, so the range of expression indexes is disjoint from the range of\n-                    // counter indexes. This way, both counters and expressions can be operands in\n-                    // other expressions.\n-                    let expression_index = u32::MAX - translated_index;\n+                        .expect(\"expression_id arg is u32\");\n+                    // Counter expressions are initially assigned IDs descending from `u32::MAX`, so\n+                    // the range of expression IDs is disjoint from the range of counter IDs. This\n+                    // way, both counters and expressions can be operands in other expressions.\n+                    let expression_index = u32::MAX - id_descending_from_max;\n                     num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n                 }\n                 _ => {}\n@@ -97,12 +95,10 @@ fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n-        if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n-            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n-            if src.promoted.is_none() {\n-                Instrumentor::new(tcx, src, mir_body).inject_counters();\n-            }\n+        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+        if src.promoted.is_none() {\n+            Instrumentor::new(tcx, src, mir_body).inject_counters();\n         }\n     }\n }\n@@ -113,6 +109,12 @@ enum Op {\n     Subtract,\n }\n \n+struct InjectedCall<'tcx> {\n+    func: Operand<'tcx>,\n+    args: Vec<Operand<'tcx>>,\n+    inject_at: Span,\n+}\n+\n struct Instrumentor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n@@ -147,11 +149,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n-    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The indexes\n-    /// of each type of region must be contiguous, but also must be unique across both sets.\n-    /// The expression IDs are eventually translated into region indexes (starting after the last\n-    /// counter index, for the given function), during backend code generation, by the helper method\n-    /// `rustc_codegen_ssa::coverageinfo::map::FunctionCoverage::translate_expressions()`.\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The counter\n+    /// expression operand IDs must be unique across both types.\n     fn next_expression(&mut self) -> u32 {\n         assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = u32::MAX - self.num_expressions;\n@@ -171,17 +170,25 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     fn inject_counters(&mut self) {\n+        let mir_body = &self.mir_body;\n         let body_span = self.hir_body.value.span;\n-        debug!(\n-            \"instrumenting {:?}, span: {}\",\n-            self.mir_def_id,\n-            self.tcx.sess.source_map().span_to_string(body_span)\n-        );\n+        debug!(\"instrumenting {:?}, span: {:?}\", self.mir_def_id, body_span);\n \n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let next_block = START_BLOCK;\n-        self.inject_counter(body_span, next_block);\n+        let _ignore = mir_body;\n+        let id = self.next_counter();\n+        let function_source_hash = self.function_source_hash();\n+        let code_region = body_span;\n+        let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+        let is_cleanup = false;\n+        let next_block = rustc_middle::mir::START_BLOCK;\n+        self.inject_call(\n+            self.make_counter(id, function_source_hash, code_region),\n+            scope,\n+            is_cleanup,\n+            next_block,\n+        );\n \n         // FIXME(richkadel): The next step to implement source based coverage analysis will be\n         // instrumenting branches within functions, and some regions will be counted by \"counter\n@@ -190,57 +197,68 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let fake_use = false;\n         if fake_use {\n             let add = false;\n-            if add {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Add, 2);\n-            } else {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Subtract, 2);\n-            }\n+            let lhs = 1;\n+            let op = if add { Op::Add } else { Op::Subtract };\n+            let rhs = 2;\n+\n+            let code_region = body_span;\n+            let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+            let is_cleanup = false;\n+            let next_block = rustc_middle::mir::START_BLOCK;\n+\n+            let id = self.next_expression();\n+            self.inject_call(\n+                self.make_expression(id, code_region, lhs, op, rhs),\n+                scope,\n+                is_cleanup,\n+                next_block,\n+            );\n         }\n     }\n \n-    fn inject_counter(&mut self, code_region: Span, next_block: BasicBlock) -> u32 {\n-        let counter_id = self.next_counter();\n-        let function_source_hash = self.function_source_hash();\n-        let injection_point = code_region.shrink_to_lo();\n+    fn make_counter(\n+        &self,\n+        id: u32,\n+        function_source_hash: u64,\n+        code_region: Span,\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use count_code_region_args::*;\n         debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n-        args.push(self.const_u64(function_source_hash, injection_point));\n+        args.push(self.const_u64(function_source_hash, inject_at));\n \n-        debug_assert_eq!(COUNTER_INDEX, args.len());\n-        args.push(self.const_u32(counter_id, injection_point));\n+        debug_assert_eq!(COUNTER_ID, args.len());\n+        args.push(self.const_u32(id, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n-\n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        counter_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n-    fn inject_counter_expression(\n-        &mut self,\n+    fn make_expression(\n+        &self,\n+        id: u32,\n         code_region: Span,\n-        next_block: BasicBlock,\n         lhs: u32,\n         op: Op,\n         rhs: u32,\n-    ) -> u32 {\n-        let expression_id = self.next_expression();\n-        let injection_point = code_region.shrink_to_lo();\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(\n                 match op {\n@@ -249,43 +267,51 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 },\n                 None,\n             ),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use coverage_counter_expression_args::*;\n-        debug_assert_eq!(COUNTER_EXPRESSION_INDEX, args.len());\n-        args.push(self.const_u32(expression_id, injection_point));\n+        debug_assert_eq!(EXPRESSION_ID, args.len());\n+        args.push(self.const_u32(id, inject_at));\n \n-        debug_assert_eq!(LEFT_INDEX, args.len());\n-        args.push(self.const_u32(lhs, injection_point));\n+        debug_assert_eq!(LEFT_ID, args.len());\n+        args.push(self.const_u32(lhs, inject_at));\n \n-        debug_assert_eq!(RIGHT_INDEX, args.len());\n-        args.push(self.const_u32(rhs, injection_point));\n+        debug_assert_eq!(RIGHT_ID, args.len());\n+        args.push(self.const_u32(rhs, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n-\n-        expression_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n     fn inject_call(\n         &mut self,\n-        func: Operand<'tcx>,\n-        args: Vec<Operand<'tcx>>,\n-        fn_span: Span,\n+        call: InjectedCall<'tcx>,\n+        scope: SourceScope,\n+        is_cleanup: bool,\n         next_block: BasicBlock,\n     ) {\n+        let InjectedCall { func, args, inject_at } = call;\n+        debug!(\n+            \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n+            if is_cleanup { \"cleanup \" } else { \"\" },\n+            func,\n+            args,\n+            inject_at,\n+            scope,\n+        );\n+\n         let mut patch = MirPatch::new(self.mir_body);\n \n-        let temp = patch.new_temp(self.tcx.mk_unit(), fn_span);\n-        let new_block = patch.new_block(placeholder_block(fn_span));\n+        let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n+        let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n         patch.patch_terminator(\n             new_block,\n             TerminatorKind::Call {\n@@ -295,7 +321,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n                 from_hir_call: false,\n-                fn_span,\n+                fn_span: inject_at,\n             },\n         );\n \n@@ -325,15 +351,15 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span, scope: SourceScope, is_cleanup: bool) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info: SourceInfo::outermost(span),\n+            source_info: SourceInfo { span, scope },\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n-        is_cleanup: false,\n+        is_cleanup,\n     }\n }\n "}, {"sha": "26b4a6968971d9efc5eb5604f3fd93513203842a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -332,21 +332,25 @@ fn mir_validated(\n     body.required_consts = required_consts;\n \n     let promote_pass = promote_consts::PromoteTemps::default();\n+    let promote: &[&dyn MirPass<'tcx>] = &[\n+        // What we need to run borrowck etc.\n+        &promote_pass,\n+        &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+    ];\n+\n+    let opt_coverage: &[&dyn MirPass<'tcx>] = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        &[&instrument_coverage::InstrumentCoverage]\n+    } else {\n+        &[]\n+    };\n+\n     run_passes(\n         tcx,\n         &mut body,\n         InstanceDef::Item(def.to_global()),\n         None,\n         MirPhase::Validated,\n-        &[&[\n-            // What we need to run borrowck etc.\n-            &promote_pass,\n-            &simplify::SimplifyCfg::new(\"qualify-consts\"),\n-            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n-            // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n-            // where needed.\n-            &instrument_coverage::InstrumentCoverage,\n-        ]],\n+        &[promote, opt_coverage],\n     );\n \n     let promoted = promote_pass.promoted_fragments.into_inner();"}, {"sha": "80164840334a23ba3de4724190d8439ccd0b922e", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -883,7 +883,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`, \\\n         and is mutually exclusive with `-C profile-generate`/`-C profile-use`); \\\n-        implies `-C link-dead-code` (unless explicitly disabled)` and\n+        implies `-C link-dead-code` (unless explicitly disabled)` and \\\n         `-Z symbol-mangling-version=v0`; and disables/overrides some optimization \\\n         options (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],"}, {"sha": "7c8481540aae41d259bd79eaa99be4b45634a040", "filename": "src/rustllvm/CoverageMappingWrapper.cpp", "status": "modified", "additions": 7, "deletions": 59, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/db0492ace429cfeb3567e2c04e300be7df9972ff/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FCoverageMappingWrapper.cpp?ref=db0492ace429cfeb3567e2c04e300be7df9972ff", "patch": "@@ -8,60 +8,6 @@\n \n using namespace llvm;\n \n-extern \"C\" SmallVectorTemplateBase<coverage::CounterExpression>\n-    *LLVMRustCoverageSmallVectorCounterExpressionCreate() {\n-  return new SmallVector<coverage::CounterExpression, 32>();\n-}\n-\n-extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionDispose(\n-    SmallVectorTemplateBase<coverage::CounterExpression> *Vector) {\n-  delete Vector;\n-}\n-\n-extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionAdd(\n-    SmallVectorTemplateBase<coverage::CounterExpression> *Expressions,\n-    coverage::CounterExpression::ExprKind Kind,\n-    unsigned LeftIndex,\n-    unsigned RightIndex) {\n-  auto LHS = coverage::Counter::getCounter(LeftIndex);\n-  auto RHS = coverage::Counter::getCounter(RightIndex);\n-  Expressions->push_back(coverage::CounterExpression { Kind, LHS, RHS });\n-}\n-\n-extern \"C\" SmallVectorTemplateBase<coverage::CounterMappingRegion>\n-    *LLVMRustCoverageSmallVectorCounterMappingRegionCreate() {\n-  return new SmallVector<coverage::CounterMappingRegion, 32>();\n-}\n-\n-extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n-    SmallVectorTemplateBase<coverage::CounterMappingRegion> *Vector) {\n-  delete Vector;\n-}\n-\n-extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n-    SmallVectorTemplateBase<coverage::CounterMappingRegion> *MappingRegions,\n-    unsigned Index,\n-    unsigned FileID,\n-    unsigned LineStart,\n-    unsigned ColumnStart,\n-    unsigned LineEnd,\n-    unsigned ColumnEnd) {\n-  auto Counter = coverage::Counter::getCounter(Index);\n-  MappingRegions->push_back(coverage::CounterMappingRegion::makeRegion(\n-           Counter, FileID, LineStart,\n-           ColumnStart, LineEnd, ColumnEnd));\n-\n-  // FIXME(richkadel): As applicable, implement additional CounterMappingRegion types using the\n-  // static method alternatives to `coverage::CounterMappingRegion::makeRegion`:\n-  //\n-  //   makeExpansion(unsigned FileID, unsigned ExpandedFileID, unsigned LineStart,\n-  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n-  //   makeSkipped(unsigned FileID, unsigned LineStart, unsigned ColumnStart,\n-  //               unsigned LineEnd, unsigned ColumnEnd) {\n-  //   makeGapRegion(Counter Count, unsigned FileID, unsigned LineStart,\n-  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n-}\n-\n extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n@@ -79,13 +25,15 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n     const unsigned *VirtualFileMappingIDs,\n     unsigned NumVirtualFileMappingIDs,\n-    const SmallVectorImpl<coverage::CounterExpression> *Expressions,\n-    SmallVectorImpl<coverage::CounterMappingRegion> *MappingRegions,\n+    const coverage::CounterExpression *Expressions,\n+    unsigned NumExpressions,\n+    coverage::CounterMappingRegion *MappingRegions,\n+    unsigned NumMappingRegions,\n     RustStringRef BufferOut) {\n   auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n-    makeArrayRef(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n-    makeArrayRef(*Expressions),\n-    MutableArrayRef<coverage::CounterMappingRegion> { *MappingRegions });\n+      makeArrayRef(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n+      makeArrayRef(Expressions, NumExpressions),\n+      makeMutableArrayRef(MappingRegions, NumMappingRegions));\n   RawRustStringOstream OS(BufferOut);\n   CoverageMappingWriter.write(OS);\n }"}]}