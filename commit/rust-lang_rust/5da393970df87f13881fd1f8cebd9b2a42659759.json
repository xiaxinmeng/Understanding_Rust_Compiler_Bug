{"sha": "5da393970df87f13881fd1f8cebd9b2a42659759", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYTM5Mzk3MGRmODdmMTM4ODFmZDFmOGNlYmQ5YjJhNDI2NTk3NTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-23T16:04:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-23T16:45:44Z"}, "message": "miri/machine: add canonical_alloc_id hook to replace find_foreign_static", "tree": {"sha": "c1a0f60a823816c1b21f226224b1eadf783432aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1a0f60a823816c1b21f226224b1eadf783432aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5da393970df87f13881fd1f8cebd9b2a42659759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5da393970df87f13881fd1f8cebd9b2a42659759", "html_url": "https://github.com/rust-lang/rust/commit/5da393970df87f13881fd1f8cebd9b2a42659759", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5da393970df87f13881fd1f8cebd9b2a42659759/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "html_url": "https://github.com/rust-lang/rust/commit/87e494c4cdf3f4f39d25ca008173f80688b8eb3d"}], "stats": {"total": 122, "additions": 57, "deletions": 65}, "files": [{"sha": "25727b75faf14af09fcd7e84f6d0a0c8fdb503bc", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=5da393970df87f13881fd1f8cebd9b2a42659759", "patch": "@@ -1,7 +1,6 @@\n use rustc::mir;\n use rustc::ty::layout::HasTyCtxt;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{self, Ty};\n use std::borrow::{Borrow, Cow};\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -320,13 +319,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n         _memory_extra: &MemoryExtra,"}, {"sha": "98a305ec2d92c3ddf29584dac5e420923f7550e2", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=5da393970df87f13881fd1f8cebd9b2a42659759", "patch": "@@ -6,8 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{self, Ty};\n use rustc_span::Span;\n \n use super::{\n@@ -123,10 +122,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Called before a basic block terminator is executed.\n-    /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n-\n     /// Entry point to all function calls.\n     ///\n     /// Returns either the mir to use for the call, or `None` if execution should\n@@ -175,18 +170,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n-    /// Called for read access to a foreign static item.\n-    ///\n-    /// This will only be called once per static and machine; the result is cached in\n-    /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n-    /// owned allocation to the map even when the map is shared.)\n-    ///\n-    /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n-    fn find_foreign_static(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n-\n     /// Called for all binary operations where the LHS has pointer type.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n@@ -204,6 +187,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n+    #[inline]\n     fn access_local(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n@@ -212,14 +196,36 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n+    /// Called before a basic block terminator is executed.\n+    /// You can use this to detect endlessly running programs.\n+    #[inline]\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called before a `Static` value is accessed.\n+    #[inline]\n     fn before_access_static(\n         _memory_extra: &Self::MemoryExtra,\n         _allocation: &Allocation,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n+    /// Called for *every* memory access to determine the real ID of the given allocation.\n+    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n+    ///\n+    /// This is used by Miri to redirect extern statics to real allocations.\n+    ///\n+    /// This function must be idempotent.\n+    #[inline]\n+    fn canonical_alloc_id(\n+        _mem: &Memory<'mir, 'tcx, Self>,\n+        id: AllocId,\n+    ) -> AllocId {\n+        id\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -259,7 +265,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called immediately before a new stack frame got pushed\n+    /// Called immediately before a new stack frame got pushed.\n     fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped"}, {"sha": "048c5d7b1595666dc6581d7885ff43a9ade72559", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=5da393970df87f13881fd1f8cebd9b2a42659759", "patch": "@@ -421,6 +421,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n     /// contains a reference to memory that was created during its evaluation (i.e., not to\n     /// another static), those inner references only exist in \"resolved\" form.\n+    ///\n+    /// Assumes `id` is already canonical.\n     fn get_static_alloc(\n         memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n@@ -434,31 +436,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"static_alloc: foreign item {:?}\", def_id);\n-                    M::find_foreign_static(tcx.tcx, def_id)?\n-                } else {\n-                    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-                    let instance = Instance::mono(tcx.tcx, def_id);\n-                    let gid = GlobalId { instance, promoted: None };\n-                    // use the raw query here to break validation cycles. Later uses of the static\n-                    // will call the full query anyway\n-                    let raw_const =\n-                        tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                            // no need to report anything, the const_eval call takes care of that\n-                            // for statics\n-                            assert!(tcx.is_static(def_id));\n-                            match err {\n-                                ErrorHandled::Reported => err_inval!(ReferencedConstant),\n-                                ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n-                            }\n-                        })?;\n-                    // Make sure we use the ID of the resolved memory, not the lazy one!\n-                    let id = raw_const.alloc_id;\n-                    let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n-\n-                    M::before_access_static(memory_extra, allocation)?;\n-                    Cow::Borrowed(allocation)\n+                    trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n+                    throw_unsup!(ReadForeignStatic)\n                 }\n+                trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n+                let instance = Instance::mono(tcx.tcx, def_id);\n+                let gid = GlobalId { instance, promoted: None };\n+                // use the raw query here to break validation cycles. Later uses of the static\n+                // will call the full query anyway\n+                let raw_const =\n+                    tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+                        // no need to report anything, the const_eval call takes care of that\n+                        // for statics\n+                        assert!(tcx.is_static(def_id));\n+                        match err {\n+                            ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+                            ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+                        }\n+                    })?;\n+                // Make sure we use the ID of the resolved memory, not the lazy one!\n+                let id = raw_const.alloc_id;\n+                let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+\n+                M::before_access_static(memory_extra, allocation)?;\n+                Cow::Borrowed(allocation)\n             }\n         };\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n@@ -478,6 +479,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n+        let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -513,6 +515,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n+        let id = M::canonical_alloc_id(self, id);\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n@@ -550,6 +553,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        let id = M::canonical_alloc_id(self, id);\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n@@ -602,6 +606,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Assumes `id` is already canonical.\n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n@@ -622,7 +627,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             throw_unsup!(InvalidFunctionPointer)\n         }\n-        self.get_fn_alloc(ptr.alloc_id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n+        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n+        self.get_fn_alloc(id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "ccfe765f2bb3c58168211f88ada0fc0d16b4f3e1", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da393970df87f13881fd1f8cebd9b2a42659759/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5da393970df87f13881fd1f8cebd9b2a42659759", "patch": "@@ -22,7 +22,6 @@ use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::traits;\n@@ -222,13 +221,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         ));\n     }\n \n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n         _memory_extra: &(),\n@@ -279,10 +271,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         Ok(())\n     }\n \n-    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n     #[inline(always)]\n     fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())"}]}