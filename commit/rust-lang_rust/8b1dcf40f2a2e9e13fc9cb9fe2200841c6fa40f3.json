{"sha": "8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMWRjZjQwZjJhMmU5ZTEzZmM5Y2I5ZmUyMjAwODQxYzZmYTQwZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-29T16:02:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-29T16:02:36Z"}, "message": "Auto merge of #33232 - jseyfried:resolve_ast_groundwork, r=nrc\n\nresolve: cleanup and groundwork for resolving the AST\n\nCleanup `resolve` and refactor away uses of the hir map (incorrectly named `ast_map`).\nr? @nrc", "tree": {"sha": "225227a1b5488e9c638344aa848a61a032c910a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/225227a1b5488e9c638344aa848a61a032c910a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "html_url": "https://github.com/rust-lang/rust/commit/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e07e34c4b0ccdc0feecd49091682e6cc365b279a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e07e34c4b0ccdc0feecd49091682e6cc365b279a", "html_url": "https://github.com/rust-lang/rust/commit/e07e34c4b0ccdc0feecd49091682e6cc365b279a"}, {"sha": "ac264196e2f4c1f3de8b081f72dc78838e423085", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac264196e2f4c1f3de8b081f72dc78838e423085", "html_url": "https://github.com/rust-lang/rust/commit/ac264196e2f4c1f3de8b081f72dc78838e423085"}], "stats": {"total": 320, "additions": 132, "deletions": 188}, "files": [{"sha": "bc342b235dd42f80c77fc2d866517bbf984cadb2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "patch": "@@ -283,6 +283,24 @@ pub enum Visibility {\n     PrivateExternal,\n }\n \n+pub trait NodeIdTree {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool;\n+}\n+\n+impl<'a> NodeIdTree for ast_map::Map<'a> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        let mut node_ancestor = node;\n+        while node_ancestor != ancestor {\n+            let node_ancestor_parent = self.get_module_parent(node_ancestor);\n+            if node_ancestor_parent == node_ancestor {\n+                return false;\n+            }\n+            node_ancestor = node_ancestor_parent;\n+        }\n+        true\n+    }\n+}\n+\n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n         match *visibility {\n@@ -301,7 +319,7 @@ impl Visibility {\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from(self, block: NodeId, map: &ast_map::Map) -> bool {\n+    pub fn is_accessible_from<T: NodeIdTree>(self, block: NodeId, tree: &T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n@@ -311,24 +329,18 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        let mut block_ancestor = block;\n-        loop {\n-            if block_ancestor == restriction { return true }\n-            let block_ancestor_parent = map.get_module_parent(block_ancestor);\n-            if block_ancestor_parent == block_ancestor { return false }\n-            block_ancestor = block_ancestor_parent;\n-        }\n+        tree.is_descendant_of(block, restriction)\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least(self, vis: Visibility, map: &ast_map::Map) -> bool {\n+    pub fn is_at_least<T: NodeIdTree>(self, vis: Visibility, tree: &T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n             Visibility::PrivateExternal => return true,\n             Visibility::Restricted(module) => module,\n         };\n \n-        self.is_accessible_from(vis_restriction, map)\n+        self.is_accessible_from(vis_restriction, tree)\n     }\n }\n "}, {"sha": "4dc19434c80248c2d1b4be6fe51252899753fcf4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "patch": "@@ -46,15 +46,15 @@ trait ToNameBinding<'a> {\n     fn to_name_binding(self) -> NameBinding<'a>;\n }\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding::create_from_module(self.0, Some(self.1))\n+        NameBinding { kind: NameBindingKind::Module(self.0), span: self.1, vis: self.2 }\n     }\n }\n \n impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding { kind: NameBindingKind::Def(self.0), span: Some(self.1), vis: self.2 }\n+        NameBinding { kind: NameBindingKind::Def(self.0), span: self.1, vis: self.2 }\n     }\n }\n \n@@ -247,8 +247,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                     };\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent_link, def, vis, item.id);\n-                    self.define(parent, name, TypeNS, (module, sp));\n+                    let module = self.new_extern_crate_module(parent_link, def, item.id);\n+                    self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.build_reduced_graph_for_external_crate(module);\n                 }\n@@ -257,8 +257,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemMod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, vis);\n-                self.define(parent, name, TypeNS, (module, sp));\n+                let module = self.new_module(parent_link, Some(def), false);\n+                self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n                 *parent_ref = module;\n             }\n@@ -289,12 +289,12 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemEnum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, vis);\n-                self.define(parent, name, TypeNS, (module, sp));\n+                let module = self.new_module(parent_link, Some(def), false);\n+                self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id, module);\n+                    self.build_reduced_graph_for_variant(variant, item_def_id, module, vis);\n                 }\n             }\n \n@@ -328,21 +328,25 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n-                let module_parent = self.new_module(parent_link, Some(def), false, vis);\n-                self.define(parent, name, TypeNS, (module_parent, sp));\n+                let module_parent = self.new_module(parent_link, Some(def), false);\n+                self.define(parent, name, TypeNS, (module_parent, sp, vis));\n \n                 // Add the names of all the items to the trait info.\n                 for item in items {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let mut is_static_method = false;\n                     let (def, ns) = match item.node {\n                         hir::ConstTraitItem(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-                        hir::MethodTraitItem(..) => (Def::Method(item_def_id), ValueNS),\n+                        hir::MethodTraitItem(ref sig, _) => {\n+                            is_static_method = sig.explicit_self.node == hir::SelfStatic;\n+                            (Def::Method(item_def_id), ValueNS)\n+                        }\n                         hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n                     self.define(module_parent, item.name, ns, (def, item.span, vis));\n \n-                    self.trait_item_map.insert((item.name, def_id), item_def_id);\n+                    self.trait_item_map.insert((item.name, def_id), is_static_method);\n                 }\n             }\n         }\n@@ -353,7 +357,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: Module<'b>) {\n+                                       parent: Module<'b>,\n+                                       vis: ty::Visibility) {\n         let name = variant.node.name;\n         if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n@@ -364,8 +369,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n-        self.define(parent, name, ValueNS, (def, variant.span, parent.vis));\n-        self.define(parent, name, TypeNS, (def, variant.span, parent.vis));\n+        self.define(parent, name, ValueNS, (def, variant.span, vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -396,7 +401,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                    block_id);\n \n             let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, false, parent.vis);\n+            let new_module = self.new_module(parent_link, None, false);\n             self.module_map.insert(block_id, new_module);\n             *parent = new_module;\n         }\n@@ -425,8 +430,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, vis);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n+                let module = self.new_module(parent_link, Some(def), true);\n+                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n@@ -463,12 +468,12 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                             '{}'\",\n                            trait_item_name);\n \n-                    self.trait_item_map.insert((trait_item_name, def_id), trait_item_def.def_id());\n+                    self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, vis);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n+                let module = self.new_module(parent_link, Some(def), true);\n+                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);"}, {"sha": "1674a96c8badc4daf702cccb7fcf2ed7df698172", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 73, "deletions": 147, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "patch": "@@ -42,7 +42,6 @@ use self::ModulePrefixResult::*;\n use self::AssocItemResolveResult::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n-use self::FallbackChecks::*;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n@@ -81,7 +80,7 @@ use rustc::hir::{Pat, PatKind, Path, PrimTy};\n use rustc::hir::{PathSegment, PathParameters};\n use rustc::hir::HirVec;\n use rustc::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n-use rustc::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n+use rustc::hir::{TyRptr, TyStr, TyUint, TyPath};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -349,7 +348,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(binding) = resolver.current_module\n                                            .resolve_name_in_lexical_scope(name, ValueNS) {\n                 if binding.is_import() {\n-                    err.span_note(binding.span.unwrap(), \"constant imported here\");\n+                    err.span_note(binding.span, \"constant imported here\");\n                 }\n             }\n             err\n@@ -676,9 +675,7 @@ impl<T> ResolveResult<T> {\n enum FallbackSuggestion {\n     NoSuggestion,\n     Field,\n-    Method,\n     TraitItem,\n-    StaticMethod(String),\n     TraitMethod(String),\n }\n \n@@ -818,7 +815,6 @@ enum ParentLink<'a> {\n pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n-    vis: ty::Visibility,\n \n     // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n@@ -833,7 +829,7 @@ pub struct ModuleS<'a> {\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n-    traits: RefCell<Option<Box<[&'a NameBinding<'a>]>>>,\n+    traits: RefCell<Option<Box<[(Name, &'a NameBinding<'a>)]>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -849,12 +845,10 @@ impl<'a> ModuleS<'a> {\n     fn new(parent_link: ParentLink<'a>,\n            def: Option<Def>,\n            external: bool,\n-           vis: ty::Visibility,\n            arenas: &'a ResolverArenas<'a>) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n-            vis: vis,\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n@@ -895,15 +889,15 @@ impl<'a> ModuleS<'a> {\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}, {:?}\", self.def, self.vis)\n+        write!(f, \"{:?}\", self.def)\n     }\n }\n \n // Records a possibly-private value, type, or module definition.\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n-    span: Option<Span>,\n+    span: Span,\n     vis: ty::Visibility,\n }\n \n@@ -923,14 +917,6 @@ enum NameBindingKind<'a> {\n struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n impl<'a> NameBinding<'a> {\n-    fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n-        NameBinding {\n-            kind: NameBindingKind::Module(module),\n-            span: span,\n-            vis: module.vis,\n-        }\n-    }\n-\n     fn module(&self) -> Option<Module<'a>> {\n         match self.kind {\n             NameBindingKind::Module(module) => Some(module),\n@@ -1030,7 +1016,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     graph_root: Module<'a>,\n \n-    trait_item_map: FnvHashMap<(Name, DefId), DefId>,\n+    trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n@@ -1135,10 +1121,19 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-#[derive(PartialEq)]\n-enum FallbackChecks {\n-    Everything,\n-    OnlyTraitAndStatics,\n+impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        let ancestor = self.ast_map.local_def_id(ancestor);\n+        let mut module = *self.module_map.get(&node).unwrap();\n+        while module.def_id() != Some(ancestor) {\n+            let module_parent = match self.get_nearest_normal_module_parent(module) {\n+                Some(parent) => parent,\n+                None => return false,\n+            };\n+            module = module_parent;\n+        }\n+        true\n+    }\n }\n \n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n@@ -1148,10 +1143,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let vis = ty::Visibility::Public;\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, vis, arenas);\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n+        let mut module_map = NodeMap();\n+        module_map.insert(CRATE_NODE_ID, graph_root);\n \n         Resolver {\n             session: session,\n@@ -1182,7 +1178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             freevars_seen: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n-            module_map: NodeMap(),\n+            module_map: module_map,\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n \n@@ -1208,21 +1204,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn new_module(&self,\n-                  parent_link: ParentLink<'a>,\n-                  def: Option<Def>,\n-                  external: bool,\n-                  vis: ty::Visibility) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, vis, self.arenas))\n+    fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, external: bool)\n+                  -> Module<'a> {\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, self.arenas))\n     }\n \n-    fn new_extern_crate_module(&self,\n-                               parent_link: ParentLink<'a>,\n-                               def: Def,\n-                               vis: ty::Visibility,\n-                               local_node_id: NodeId)\n+    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, vis, self.arenas);\n+        let mut module = ModuleS::new(parent_link, Some(def), false, self.arenas);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1262,14 +1251,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.glob_map.insert(directive.id, new_set);\n     }\n \n-    fn get_trait_name(&self, did: DefId) -> Name {\n-        if let Some(node_id) = self.ast_map.as_local_node_id(did) {\n-            self.ast_map.expect_item(node_id).name\n-        } else {\n-            self.session.cstore.item_name(did)\n-        }\n-    }\n-\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Module<'a>,\n@@ -1719,8 +1700,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Ok(def) =>\n-                                    self.record_def(item.id, PathResolution::new(def, 0)),\n+                                Ok(binding) => {\n+                                    let def = binding.def().unwrap();\n+                                    self.record_def(item.id, PathResolution::new(def, 0));\n+                                }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n                                 Err(false) => {\n                                     resolve_error(self,\n@@ -1853,11 +1836,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       path_depth)));\n \n                 // If it's a typedef, give a note\n-                if let Def::TyAlias(did) = path_res.base_def {\n+                if let Def::TyAlias(..) = path_res.base_def {\n                     err.fileline_note(trait_path.span,\n                                   \"`type` aliases cannot be used for traits\");\n-                    if let Some(sp) = self.ast_map.span_if_local(did) {\n-                        err.span_note(sp, \"type defined here\");\n+\n+                    let definition_site = {\n+                        let segments = &trait_path.segments;\n+                        if trait_path.global {\n+                            self.resolve_crate_relative_path(trait_path.span, segments, TypeNS)\n+                        } else {\n+                            self.resolve_module_relative_path(trait_path.span, segments, TypeNS)\n+                        }.map(|binding| binding.span).unwrap_or(codemap::DUMMY_SP)\n+                    };\n+\n+                    if definition_site != codemap::DUMMY_SP {\n+                        err.span_note(definition_site, \"type defined here\");\n                     }\n                 }\n                 err.emit();\n@@ -2583,8 +2576,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mk_res = |def| PathResolution::new(def, path_depth);\n \n         if path.global {\n-            let def = self.resolve_crate_relative_path(span, segments, namespace);\n-            return def.map(mk_res);\n+            let binding = self.resolve_crate_relative_path(span, segments, namespace);\n+            return binding.map(|binding| mk_res(binding.def().unwrap()));\n         }\n \n         // Try to find a path to an item in a module.\n@@ -2620,9 +2613,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let unqualified_def = resolve_identifier_with_fallback(self, false);\n-        let def = self.resolve_module_relative_path(span, segments, namespace);\n-        match (def, unqualified_def) {\n-            (Ok(d), Some(ref ud)) if d == ud.def => {\n+        let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n+        match (qualified_binding, unqualified_def) {\n+            (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2632,7 +2625,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n \n-        def.map(mk_res)\n+        qualified_binding.map(|binding| mk_res(binding.def().unwrap()))\n     }\n \n     // Resolve a single identifier\n@@ -2743,7 +2736,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Result<Def, bool /* true if an error was reported */> {\n+                                    -> Result<&'a NameBinding<'a>,\n+                                              bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2776,7 +2770,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n-            binding.def().unwrap()\n+            binding\n         }).ok_or(false)\n     }\n \n@@ -2786,7 +2780,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Result<Def, bool /* true if an error was reported */> {\n+                                   -> Result<&'a NameBinding<'a>,\n+                                             bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2826,7 +2821,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n-            binding.def().unwrap()\n+            binding\n         }).ok_or(false)\n     }\n \n@@ -2840,65 +2835,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n-        fn extract_path_and_node_id(t: &Ty,\n-                                    allow: FallbackChecks)\n-                                    -> Option<(Path, NodeId, FallbackChecks)> {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n-                TyPath(None, ref path) => Some((path.clone(), t.id, allow)),\n-                TyPtr(ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, allow),\n+                TyPath(None, _) => Some(t.id),\n+                TyRptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n                 _ => None,\n             }\n         }\n \n-        fn get_module<'a, 'tcx>(this: &mut Resolver<'a, 'tcx>,\n-                                span: Span,\n-                                name_path: &[ast::Name])\n-                                -> Option<Module<'a>> {\n-            let last_name = name_path.last().unwrap();\n-\n-            if name_path.len() == 1 {\n-                match this.primitive_type_table.primitive_types.get(last_name) {\n-                    Some(_) => None,\n-                    None => this.current_module.resolve_name_in_lexical_scope(*last_name, TypeNS)\n-                                               .and_then(NameBinding::module)\n-                }\n-            } else {\n-                this.resolve_module_path(&name_path, UseLexicalScope, span).success()\n-            }\n-        }\n-\n-        fn is_static_method(this: &Resolver, did: DefId) -> bool {\n-            if let Some(node_id) = this.ast_map.as_local_node_id(did) {\n-                let sig = match this.ast_map.get(node_id) {\n-                    hir_map::NodeTraitItem(trait_item) => match trait_item.node {\n-                        hir::MethodTraitItem(ref sig, _) => sig,\n-                        _ => return false,\n-                    },\n-                    hir_map::NodeImplItem(impl_item) => match impl_item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => sig,\n-                        _ => return false,\n-                    },\n-                    _ => return false,\n-                };\n-                sig.explicit_self.node == hir::SelfStatic\n-            } else {\n-                this.session.cstore.is_static_method(did)\n-            }\n-        }\n-\n-        let (path, node_id, allowed) = match self.current_self_type {\n-            Some(ref ty) => match extract_path_and_node_id(ty, Everything) {\n-                Some(x) => x,\n-                None => return NoSuggestion,\n-            },\n-            None => return NoSuggestion,\n-        };\n-\n-        if allowed == Everything {\n+        if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n             // Look for a field with the same name in the current self_type.\n             match self.def_map.borrow().get(&node_id).map(|d| d.full_def()) {\n                 Some(Def::Enum(did)) |\n@@ -2916,28 +2864,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n-\n-        // Look for a method in the current self type's impl module.\n-        if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Some(binding) = module.resolve_name_in_lexical_scope(name, ValueNS) {\n-                if let Some(Def::Method(did)) = binding.def() {\n-                    if is_static_method(self, did) {\n-                        return StaticMethod(path_names_to_string(&path, 0));\n-                    }\n-                    if self.current_trait_ref.is_some() {\n-                        return TraitItem;\n-                    } else if allowed == Everything {\n-                        return Method;\n-                    }\n-                }\n-            }\n-        }\n-\n         // Look for a method in the current trait.\n         if let Some((trait_did, ref trait_ref)) = self.current_trait_ref {\n-            if let Some(&did) = self.trait_item_map.get(&(name, trait_did)) {\n-                if is_static_method(self, did) {\n+            if let Some(&is_static_method) = self.trait_item_map.get(&(name, trait_did)) {\n+                if is_static_method {\n                     return TraitMethod(path_names_to_string(&trait_ref.path, 0));\n                 } else {\n                     return TraitItem;\n@@ -3092,10 +3022,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         }\n                                     }\n                                     Field => format!(\"`self.{}`\", path_name),\n-                                    Method |\n                                     TraitItem => format!(\"to call `self.{}`\", path_name),\n-                                    TraitMethod(path_str) |\n-                                    StaticMethod(path_str) =>\n+                                    TraitMethod(path_str) =>\n                                         format!(\"to call `{}::{}`\", path_str, path_name),\n                                 };\n \n@@ -3241,20 +3169,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut traits = module.traits.borrow_mut();\n                 if traits.is_none() {\n                     let mut collected_traits = Vec::new();\n-                    module.for_each_child(|_, ns, binding| {\n+                    module.for_each_child(|name, ns, binding| {\n                         if ns != TypeNS { return }\n                         if let Some(Def::Trait(_)) = binding.def() {\n-                            collected_traits.push(binding);\n+                            collected_traits.push((name, binding));\n                         }\n                     });\n                     *traits = Some(collected_traits.into_boxed_slice());\n                 }\n \n-                for binding in traits.as_ref().unwrap().iter() {\n+                for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n                     let trait_def_id = binding.def().unwrap().def_id();\n                     if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n-                        let trait_name = self.get_trait_name(trait_def_id);\n                         self.record_use(trait_name, TypeNS, binding);\n                     }\n                 }\n@@ -3312,7 +3239,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             identifier: ident,\n                             parameters: params,\n                         };\n-                        let span = name_binding.span.unwrap_or(syntax::codemap::DUMMY_SP);\n+                        let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n                         segms.push(segment);\n                         let segms = HirVec::from_vec(segms);\n@@ -3433,7 +3360,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n         let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n         let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n-        vis.is_accessible_from(node_id, &self.ast_map)\n+        vis.is_accessible_from(node_id, self)\n     }\n \n     fn check_privacy(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Span) {\n@@ -3466,7 +3393,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                        binding: &NameBinding,\n                        old_binding: &NameBinding) {\n         // Error on the second of two conflicting names\n-        if old_binding.span.unwrap().lo > binding.span.unwrap().lo {\n+        if old_binding.span.lo > binding.span.lo {\n             return self.report_conflict(parent, name, ns, old_binding, binding);\n         }\n \n@@ -3482,7 +3409,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             false => (\"defined\", \"definition\"),\n         };\n \n-        let span = binding.span.unwrap();\n+        let span = binding.span;\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n@@ -3507,9 +3434,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             },\n         };\n \n-        let span = old_binding.span.unwrap();\n-        if span != codemap::DUMMY_SP {\n-            err.span_note(span, &format!(\"previous {} of `{}` here\", noun, name));\n+        if old_binding.span != codemap::DUMMY_SP {\n+            err.span_note(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();\n     }"}, {"sha": "f0639a8517686e343f8d0a450e6255d34a60e07b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "patch": "@@ -26,7 +26,7 @@ use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell};\n@@ -76,7 +76,7 @@ impl<'a> ImportDirective<'a> {\n                 directive: self,\n                 privacy_error: privacy_error,\n             },\n-            span: Some(self.span),\n+            span: self.span,\n             vis: self.vis,\n         }\n     }\n@@ -412,7 +412,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         if let SingleImport { target, .. } = e.import_directive.subclass {\n             let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n-                span: None,\n+                span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n             let dummy_binding = e.import_directive.import(dummy_binding, None);\n@@ -552,9 +552,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => (),\n         }\n \n-        let ast_map = self.resolver.ast_map;\n         match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+            (&Success(binding), _) if !binding.pseudo_vis()\n+                                              .is_at_least(directive.vis, self.resolver) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n@@ -564,7 +564,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+            (_, &Success(binding)) if !binding.pseudo_vis()\n+                                              .is_at_least(directive.vis, self.resolver) &&\n                                       self.resolver.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n@@ -691,12 +692,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                   !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n+                   !orig_binding.vis.is_at_least(binding.vis, self.resolver) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);\n                     let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n-                    self.resolver.session.add_lint(lint, directive.id, binding.span.unwrap(), msg);\n+                    self.resolver.session.add_lint(lint, directive.id, binding.span, msg);\n                 }\n             }\n         }"}]}