{"sha": "2a51e73ac9a1616300e3db93e094baa4b86b895f", "node_id": "C_kwDOAAsO6NoAKDJhNTFlNzNhYzlhMTYxNjMwMGUzZGI5M2UwOTRiYWE0Yjg2Yjg5NWY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-12T18:31:04Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-14T19:55:45Z"}, "message": "Do not fetch HIR for inherent impls.", "tree": {"sha": "78dbf9bc827c22ad0f4de11a3ea60f2eb4bf75a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78dbf9bc827c22ad0f4de11a3ea60f2eb4bf75a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a51e73ac9a1616300e3db93e094baa4b86b895f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a51e73ac9a1616300e3db93e094baa4b86b895f", "html_url": "https://github.com/rust-lang/rust/commit/2a51e73ac9a1616300e3db93e094baa4b86b895f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a51e73ac9a1616300e3db93e094baa4b86b895f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03dff82d598233d4f1193d763f73c71a76ad6187", "url": "https://api.github.com/repos/rust-lang/rust/commits/03dff82d598233d4f1193d763f73c71a76ad6187", "html_url": "https://github.com/rust-lang/rust/commit/03dff82d598233d4f1193d763f73c71a76ad6187"}], "stats": {"total": 92, "additions": 36, "deletions": 56}, "files": [{"sha": "f0b6ab03ad69324b3619e9a04a3cdafd894d67c2", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 36, "deletions": 56, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2a51e73ac9a1616300e3db93e094baa4b86b895f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a51e73ac9a1616300e3db93e094baa4b86b895f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=2a51e73ac9a1616300e3db93e094baa4b86b895f", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n@@ -57,99 +56,90 @@ const ADD_ATTR: &str =\n     \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n \n impl<'tcx> InherentCollect<'tcx> {\n-    fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId, span: Span) {\n-        let impl_def_id = item.owner_id;\n-        if let Some(def_id) = def_id.as_local() {\n+    fn check_def_id(&mut self, impl_def_id: LocalDefId, self_ty: Ty<'tcx>, ty_def_id: DefId) {\n+        if let Some(ty_def_id) = ty_def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n+            let vec = self.impls_map.inherent_impls.entry(ty_def_id).or_default();\n             vec.push(impl_def_id.to_def_id());\n             return;\n         }\n \n         if self.tcx.features().rustc_attrs {\n-            let hir::ItemKind::Impl(&hir::Impl { items, .. }) = item.kind else {\n-                bug!(\"expected `impl` item: {:?}\", item);\n-            };\n+            let items = self.tcx.associated_item_def_ids(impl_def_id);\n \n-            if !self.tcx.has_attr(def_id, sym::rustc_has_incoherent_inherent_impls) {\n+            if !self.tcx.has_attr(ty_def_id, sym::rustc_has_incoherent_inherent_impls) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    span,\n+                    impl_span,\n                     E0390,\n                     \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                 )\n                 .help(INTO_DEFINING_CRATE)\n-                .span_help(span, ADD_ATTR_TO_TY)\n+                .span_help(impl_span, ADD_ATTR_TO_TY)\n                 .emit();\n                 return;\n             }\n \n-            for impl_item in items {\n-                if !self\n-                    .tcx\n-                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                {\n+            for &impl_item in items {\n+                if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                    let impl_span = self.tcx.def_span(impl_def_id);\n                     struct_span_err!(\n                         self.tcx.sess,\n-                        span,\n+                        impl_span,\n                         E0390,\n                         \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                     )\n                     .help(INTO_DEFINING_CRATE)\n-                    .span_help(self.tcx.hir().span(impl_item.id.hir_id()), ADD_ATTR)\n+                    .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                     .emit();\n                     return;\n                 }\n             }\n \n             if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n-                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id.def_id);\n+                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n             }\n         } else {\n+            let impl_span = self.tcx.def_span(impl_def_id);\n             struct_span_err!(\n                 self.tcx.sess,\n-                span,\n+                impl_span,\n                 E0116,\n                 \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\"\n             )\n-            .span_label(span, \"impl for type defined outside of crate.\")\n+            .span_label(impl_span, \"impl for type defined outside of crate.\")\n             .note(\"define and implement a trait or new type instead\")\n             .emit();\n         }\n     }\n \n-    fn check_primitive_impl(\n-        &mut self,\n-        impl_def_id: LocalDefId,\n-        ty: Ty<'tcx>,\n-        items: &[hir::ImplItemRef],\n-        span: Span,\n-    ) {\n+    fn check_primitive_impl(&mut self, impl_def_id: LocalDefId, ty: Ty<'tcx>) {\n+        let items = self.tcx.associated_item_def_ids(impl_def_id);\n         if !self.tcx.hir().rustc_coherence_is_core() {\n             if self.tcx.features().rustc_attrs {\n-                for item in items {\n-                    if !self\n-                        .tcx\n-                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                    {\n+                for &impl_item in items {\n+                    if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                        let span = self.tcx.def_span(impl_def_id);\n                         struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0390,\n                             \"cannot define inherent `impl` for primitive types outside of `core`\",\n                         )\n                         .help(INTO_CORE)\n-                        .span_help(item.span, ADD_ATTR)\n+                        .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                         .emit();\n                         return;\n                     }\n                 }\n             } else {\n+                let span = self.tcx.def_span(impl_def_id);\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n@@ -181,31 +171,23 @@ impl<'tcx> InherentCollect<'tcx> {\n             return;\n         }\n \n-        let item = self.tcx.hir().item(id);\n-        let impl_span = self.tcx.hir().span(id.hir_id());\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, items, .. }) = item.kind else {\n-            return;\n-        };\n-\n-        let self_ty = self.tcx.type_of(item.owner_id);\n+        let id = id.owner_id.def_id;\n+        let item_span = self.tcx.def_span(id);\n+        let self_ty = self.tcx.type_of(id);\n         match *self_ty.kind() {\n-            ty::Adt(def, _) => {\n-                self.check_def_id(item, self_ty, def.did(), impl_span);\n-            }\n-            ty::Foreign(did) => {\n-                self.check_def_id(item, self_ty, did, impl_span);\n-            }\n+            ty::Adt(def, _) => self.check_def_id(id, self_ty, def.did()),\n+            ty::Foreign(did) => self.check_def_id(id, self_ty, did),\n             ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, self_ty, data.principal_def_id().unwrap(), impl_span);\n+                self.check_def_id(id, self_ty, data.principal_def_id().unwrap());\n             }\n             ty::Dynamic(..) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0785,\n                     \"cannot define inherent `impl` for a dyn auto trait\"\n                 )\n-                .span_label(impl_span, \"impl requires at least one non-auto trait\")\n+                .span_label(item_span, \"impl requires at least one non-auto trait\")\n                 .note(\"define and implement a new trait or type instead\")\n                 .emit();\n             }\n@@ -221,18 +203,16 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Ref(..)\n             | ty::Never\n             | ty::FnPtr(_)\n-            | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, impl_span)\n-            }\n+            | ty::Tuple(..) => self.check_primitive_impl(id, self_ty),\n             ty::Alias(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0118,\n                     \"no nominal type found for inherent implementation\"\n                 );\n \n-                err.span_label(impl_span, \"impl requires a nominal type\")\n+                err.span_label(item_span, \"impl requires a nominal type\")\n                     .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n \n                 err.emit();\n@@ -245,7 +225,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}]}