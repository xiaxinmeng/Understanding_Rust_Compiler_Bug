{"sha": "a30f96311aa2c0c1614132b1d5dd07bcfa9267fe", "node_id": "C_kwDOAAsO6NoAKGEzMGY5NjMxMWFhMmMwYzE2MTQxMzJiMWQ1ZGQwN2JjZmE5MjY3ZmU", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-11-28T23:34:53Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-12-06T08:58:40Z"}, "message": "Add `array::IntoIter::{empty, from_raw_parts}`\n\n`array::IntoIter` has a bunch of really handy logic for dealing with partial arrays, but it's currently hamstrung by only being creatable from a fully-initialized array.\n\nThis PR adds two new constructors:\n- a safe & const `empty`, since `[].into_iter()` gives `<T, 0>`, not `<T, N>`.\n- an unsafe `from_raw_parts`, to allow experimentation with new uses.\n\n(Slice & vec iterators don't need `from_raw_parts` because you `from_raw_parts` the slice or vec instead, but there's no useful way to made a `<[T; N]>::from_raw_parts`, so I think this is a reasonable place to have one.)", "tree": {"sha": "24772195634940fb0b66a77d110143f12cac0716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24772195634940fb0b66a77d110143f12cac0716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe", "html_url": "https://github.com/rust-lang/rust/commit/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87dce6e8dfdae605c9c2a713cf0133066a52022a", "url": "https://api.github.com/repos/rust-lang/rust/commits/87dce6e8dfdae605c9c2a713cf0133066a52022a", "html_url": "https://github.com/rust-lang/rust/commit/87dce6e8dfdae605c9c2a713cf0133066a52022a"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "bebf9aa28fae3c93f5a5c19150959580f4069210", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30f96311aa2c0c1614132b1d5dd07bcfa9267fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=a30f96311aa2c0c1614132b1d5dd07bcfa9267fe", "patch": "@@ -84,6 +84,135 @@ impl<T, const N: usize> IntoIter<T, N> {\n         IntoIterator::into_iter(array)\n     }\n \n+    /// Creates an iterator over the elements in a partially-initialized buffer.\n+    ///\n+    /// If you have a fully-initialized array, then use [`IntoIterator`].\n+    /// But this is useful for returning partial results from unsafe code.\n+    ///\n+    /// # Safety\n+    ///\n+    /// - The `buffer[initialized]` elements must all be initialized.\n+    /// - The range must be canonical, with `initialized.start <= initialized.end`.\n+    /// - The range must in in-bounds for the buffer, with `initialized.end <= N`.\n+    ///   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n+    ///\n+    /// It's sound to have more elements initialized than mentioned, though that\n+    /// will most likely result in them being leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_into_iter_constructors)]\n+    ///\n+    /// #![feature(maybe_uninit_array_assume_init)]\n+    /// #![feature(maybe_uninit_uninit_array)]\n+    /// use std::array::IntoIter;\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// # // Hi!  Thanks for reading the code.  This is restricted to `Copy` because\n+    /// # // otherwise it could leak.  A fully-general version this would need a drop\n+    /// # // guard to handle panics from the iterator, but this works for an example.\n+    /// fn next_chunk<T: Copy, const N: usize>(\n+    ///     it: &mut impl Iterator<Item = T>,\n+    /// ) -> Result<[T; N], IntoIter<T, N>> {\n+    ///     let mut buffer = MaybeUninit::uninit_array();\n+    ///     let mut i = 0;\n+    ///     while i < N {\n+    ///         match it.next() {\n+    ///             Some(x) => {\n+    ///                 buffer[i].write(x);\n+    ///                 i += 1;\n+    ///             }\n+    ///             None => {\n+    ///                 // SAFETY: We've initialized the first `i` items\n+    ///                 unsafe {\n+    ///                     return Err(IntoIter::from_raw_parts(buffer, 0..i));\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///\n+    ///     // SAFETY: We've initialized all N items\n+    ///     unsafe { Ok(MaybeUninit::array_assume_init(buffer)) }\n+    /// }\n+    ///\n+    /// let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n+    /// assert_eq!(r, [10, 11, 12, 13]);\n+    /// let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n+    /// assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n+    /// ```\n+    #[unstable(feature = \"array_into_iter_constructors\", issue = \"88888888\")]\n+    #[rustc_const_unstable(feature = \"array_into_iter_constructors_const\", issue = \"88888888\")]\n+    pub const unsafe fn from_raw_parts(\n+        buffer: [MaybeUninit<T>; N],\n+        initialized: Range<usize>,\n+    ) -> Self {\n+        Self { data: buffer, alive: initialized }\n+    }\n+\n+    /// Creates an iterator over `T` which returns no elements.\n+    ///\n+    /// If you just need an empty iterator, then use\n+    /// [`iter::empty()`](crate::iter::empty) instead.\n+    /// And if you need an empty array, use `[]`.\n+    ///\n+    /// But this is useful when you need an `array::IntoIter<T, N>` *specifically*.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// let empty = IntoIter::<i32, 3>::empty();\n+    /// assert_eq!(empty.len(), 0);\n+    /// assert_eq!(empty.as_slice(), &[]);\n+    ///\n+    /// let empty = IntoIter::<std::convert::Infallible, 200>::empty();\n+    /// assert_eq!(empty.len(), 0);\n+    /// ```\n+    ///\n+    /// `[1, 2].into_iter()` and `[].into_iter()` have different types\n+    /// ```should_fail\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// # // FIXME: use `.into_iter()` once the doc tests are in edition2021\n+    /// pub fn get_bytes(b: bool) -> IntoIter<i8, 4> {\n+    ///     if b {\n+    ///         IntoIter::new([1, 2, 3, 4])\n+    ///     } else {\n+    ///         IntoIter::new([]) // error[E0308]: mismatched types\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// But using this method you can get an empty iterator of appropriate size:\n+    /// ```\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// pub fn get_bytes(b: bool) -> IntoIter<i8, 4> {\n+    ///     if b {\n+    ///         IntoIter::new([1, 2, 3, 4])\n+    ///     } else {\n+    ///         IntoIter::empty()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(get_bytes(true).collect::<Vec<_>>(), vec![1, 2, 3, 4]);\n+    /// assert_eq!(get_bytes(false).collect::<Vec<_>>(), vec![]);\n+    /// ```\n+    #[unstable(feature = \"array_into_iter_constructors\", issue = \"88888888\")]\n+    pub fn empty() -> Self {\n+        let buffer = MaybeUninit::uninit_array();\n+        let initialized = 0..0;\n+\n+        // SAFETY: We're telling it that none of the elements are initialized,\n+        // which is trivially true.  And \u2200N: usize, 0 <= N.\n+        unsafe { Self::from_raw_parts(buffer, initialized) }\n+    }\n+\n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]"}]}