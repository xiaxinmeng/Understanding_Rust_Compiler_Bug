{"sha": "7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYmE2ODNjNzZmM2RiNzhhZmEwYzEwYTdiMGVjZmIwMmEzZThiNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-16T13:37:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-16T13:37:18Z"}, "message": "Auto merge of #34239 - jseyfried:fix_macro_use_scope_regression, r=nrc\n\nRevert a change in the scope of macros imported from crates to fix a regression\n\nFixes #34212.\nThe regression was caused by #34032, which changed the scope of macros imported from extern crates to match the scope of macros imported from modules.\nr? @nrc", "tree": {"sha": "9ca24d1ae63f36e923a35c92e6e5937fdf9a7c19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca24d1ae63f36e923a35c92e6e5937fdf9a7c19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "html_url": "https://github.com/rust-lang/rust/commit/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6edea2cfda2818f0a76f4bac2d18a30feb54c137", "url": "https://api.github.com/repos/rust-lang/rust/commits/6edea2cfda2818f0a76f4bac2d18a30feb54c137", "html_url": "https://github.com/rust-lang/rust/commit/6edea2cfda2818f0a76f4bac2d18a30feb54c137"}, {"sha": "236b67af5197fc76206d402cab99cd0af2bff090", "url": "https://api.github.com/repos/rust-lang/rust/commits/236b67af5197fc76206d402cab99cd0af2bff090", "html_url": "https://github.com/rust-lang/rust/commit/236b67af5197fc76206d402cab99cd0af2bff090"}], "stats": {"total": 117, "additions": 91, "deletions": 26}, "files": [{"sha": "dba7d987d9f4d558dd4e8bf9730fedd650b8ecf1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "patch": "@@ -928,6 +928,6 @@ impl SyntaxEnv {\n     pub fn is_crate_root(&mut self) -> bool {\n         // The first frame is pushed in `SyntaxEnv::new()` and the second frame is\n         // pushed when folding the crate root pseudo-module (c.f. noop_fold_crate).\n-        self.chain.len() == 2\n+        self.chain.len() <= 2\n     }\n }"}, {"sha": "4631ffcf0ffbd39d3549bc803b538ad30a592e9b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "patch": "@@ -41,6 +41,7 @@ trait MacroGenerable: Sized {\n \n     // Fold this node or list of nodes using the given folder.\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n+    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V);\n \n     // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n     fn dummy(span: Span) -> Self;\n@@ -50,7 +51,9 @@ trait MacroGenerable: Sized {\n }\n \n macro_rules! impl_macro_generable {\n-    ($($ty:ty: $kind_name:expr, .$make:ident, $(.$fold:ident)* $(lift .$fold_elt:ident)*,\n+    ($($ty:ty: $kind_name:expr, .$make:ident,\n+               $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n+               $(.$visit:ident)* $(lift .$visit_elt:ident)*,\n                |$span:ident| $dummy:expr;)*) => { $(\n         impl MacroGenerable for $ty {\n             fn kind_name() -> &'static str { $kind_name }\n@@ -59,21 +62,27 @@ macro_rules! impl_macro_generable {\n                 $( folder.$fold(self) )*\n                 $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n             }\n+            fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+                $( visitor.$visit(self) )*\n+                $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n+            }\n             fn dummy($span: Span) -> Self { $dummy }\n         }\n     )* }\n }\n \n impl_macro_generable! {\n-    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, |span| DummyResult::raw_expr(span);\n-    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  |span| P(DummyResult::raw_pat(span));\n-    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   |span| DummyResult::raw_ty(span);\n-    SmallVector<ast::ImplItem>:\n-        \"impl item\", .make_impl_items, lift .fold_impl_item, |_span| SmallVector::zero();\n-    SmallVector<P<ast::Item>>:\n-        \"item\",      .make_items,      lift .fold_item,      |_span| SmallVector::zero();\n+    P<ast::Pat>: \"pattern\", .make_pat, .fold_pat, .visit_pat, |span| P(DummyResult::raw_pat(span));\n+    P<ast::Ty>:  \"type\",    .make_ty,  .fold_ty,  .visit_ty,  |span| DummyResult::raw_ty(span);\n+    P<ast::Expr>:\n+        \"expression\", .make_expr, .fold_expr, .visit_expr, |span| DummyResult::raw_expr(span);\n     SmallVector<ast::Stmt>:\n-        \"statement\", .make_stmts,      lift .fold_stmt,      |_span| SmallVector::zero();\n+        \"statement\",  .make_stmts, lift .fold_stmt, lift .visit_stmt, |_span| SmallVector::zero();\n+    SmallVector<P<ast::Item>>:\n+        \"item\",       .make_items, lift .fold_item, lift .visit_item, |_span| SmallVector::zero();\n+    SmallVector<ast::ImplItem>:\n+        \"impl item\",  .make_impl_items, lift .fold_impl_item, lift .visit_impl_item,\n+        |_span| SmallVector::zero();\n }\n \n impl MacroGenerable for Option<P<ast::Expr>> {\n@@ -85,6 +94,9 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n         self.and_then(|expr| folder.fold_opt_expr(expr))\n     }\n+    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+        self.as_ref().map(|expr| visitor.visit_expr(expr));\n+    }\n }\n \n pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n@@ -320,6 +332,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n \n     let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n     let configured = marked.fold_with(&mut fld.strip_unconfigured());\n+    fld.load_macros(&configured);\n     let fully_expanded = configured.fold_with(fld);\n     fld.cx.bt_pop();\n     fully_expanded\n@@ -742,15 +755,6 @@ fn expand_annotatable(a: Annotatable,\n                 }\n                 result\n             },\n-            ast::ItemKind::ExternCrate(_) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                let allows_macros = fld.cx.syntax_env.is_crate_root();\n-                for def in fld.cx.loader.load_crate(&it, allows_macros) {\n-                    fld.cx.insert_macro(def);\n-                }\n-                SmallVector::one(it)\n-            },\n             _ => noop_fold_item(it, fld),\n         }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n \n@@ -999,6 +1003,40 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                &self.cx.parse_sess.span_diagnostic,\n                                self.cx.feature_gated_cfgs)\n     }\n+\n+    fn load_macros<T: MacroGenerable>(&mut self, node: &T) {\n+        struct MacroLoadingVisitor<'a, 'b: 'a>{\n+            cx: &'a mut ExtCtxt<'b>,\n+            at_crate_root: bool,\n+        }\n+\n+        impl<'a, 'b, 'v> Visitor<'v> for MacroLoadingVisitor<'a, 'b> {\n+            fn visit_mac(&mut self, _: &'v ast::Mac) {}\n+            fn visit_item(&mut self, item: &'v ast::Item) {\n+                if let ast::ItemKind::ExternCrate(..) = item.node {\n+                    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                    // crate root, because `$crate` won't work properly.\n+                    for def in self.cx.loader.load_crate(item, self.at_crate_root) {\n+                        self.cx.insert_macro(def);\n+                    }\n+                } else {\n+                    let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n+                    visit::walk_item(self, item);\n+                    self.at_crate_root = at_crate_root;\n+                }\n+            }\n+            fn visit_block(&mut self, block: &'v ast::Block) {\n+                let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n+                visit::walk_block(self, block);\n+                self.at_crate_root = at_crate_root;\n+            }\n+        }\n+\n+        node.visit_with(&mut MacroLoadingVisitor {\n+            at_crate_root: self.cx.syntax_env.is_crate_root(),\n+            cx: self.cx,\n+        });\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -1142,7 +1180,7 @@ impl<'feat> ExpansionConfig<'feat> {\n \n pub fn expand_crate(mut cx: ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n-                    c: Crate) -> (Crate, HashSet<Name>) {\n+                    mut c: Crate) -> (Crate, HashSet<Name>) {\n     if std_inject::no_core(&c) {\n         cx.crate_root = None;\n     } else if std_inject::no_std(&c) {\n@@ -1157,6 +1195,10 @@ pub fn expand_crate(mut cx: ExtCtxt,\n             expander.cx.syntax_env.insert(name, extension);\n         }\n \n+        let items = SmallVector::many(c.module.items);\n+        expander.load_macros(&items);\n+        c.module.items = items.into();\n+\n         let err_count = cx.parse_sess.span_diagnostic.err_count();\n         let mut ret = expander.fold_crate(c);\n         ret.exported_macros = expander.cx.exported_macros.clone();"}, {"sha": "9548805c1f8865dde69db3dbbd1ded397da2cbfd", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "patch": "@@ -29,6 +29,16 @@ enum SmallVectorRepr<T> {\n     Many(Vec<T>),\n }\n \n+impl<T> Into<Vec<T>> for SmallVector<T> {\n+    fn into(self) -> Vec<T> {\n+        match self.repr {\n+            Zero => Vec::new(),\n+            One(t) => vec![t],\n+            Many(vec) => vec,\n+        }\n+    }\n+}\n+\n impl<T> FromIterator<T> for SmallVector<T> {\n     fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> SmallVector<T> {\n         let mut v = SmallVector::zero();"}, {"sha": "5256396a242c9eaac08de95ef01a59a04da4f5c8", "filename": "src/test/compile-fail/macro-use-scope.rs", "status": "renamed", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs?ref=7aba683c76f3db78afa0c10a7b0ecfb02a3e8b63", "patch": "@@ -8,12 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_private)]\n-macro_rules! m {\n-    () => { #[macro_use] extern crate syntax; }\n+// aux-build:two_macros.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn f() {\n+    let _ = macro_one!();\n }\n+#[macro_use(macro_one)] // Check that this macro is usable in the above function\n+extern crate two_macros;\n+\n+macro_rules! m { () => {\n+    fn g() {\n+        macro_two!();\n+    }\n+    #[macro_use(macro_two)] // Check that this macro is usable in the above function\n+    extern crate two_macros as _two_macros;\n+} }\n m!();\n \n-fn main() {\n-    help!(); //~ ERROR unexpected end of macro invocation\n-}\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail-fulldeps/expanded-macro-use.rs"}]}