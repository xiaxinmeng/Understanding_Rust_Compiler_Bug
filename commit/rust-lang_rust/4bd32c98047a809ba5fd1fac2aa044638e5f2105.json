{"sha": "4bd32c98047a809ba5fd1fac2aa044638e5f2105", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZDMyYzk4MDQ3YTgwOWJhNWZkMWZhYzJhYTA0NDYzOGU1ZjIxMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T19:50:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T19:50:22Z"}, "message": "Auto merge of #72747 - Dylan-DPC:rollup-vvydkgl, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #72310 (Add Peekable::next_if)\n - #72383 (Suggest using std::mem::drop function instead of explicit destructor call)\n - #72398 (SocketAddr and friends now correctly pad its content)\n - #72465 (Warn about unused captured variables)\n - #72568 (Implement total_cmp for f32, f64)\n - #72572 (Add some regression tests)\n - #72591 (librustc_middle: Rename upvar_list to closure_captures)\n - #72701 (Fix grammar in liballoc raw_vec)\n - #72731 (Add missing empty line in E0619 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2ab4b52a13d0ec1df564fac39c011993112c9709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab4b52a13d0ec1df564fac39c011993112c9709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd32c98047a809ba5fd1fac2aa044638e5f2105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd32c98047a809ba5fd1fac2aa044638e5f2105", "html_url": "https://github.com/rust-lang/rust/commit/4bd32c98047a809ba5fd1fac2aa044638e5f2105", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd32c98047a809ba5fd1fac2aa044638e5f2105/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "url": "https://api.github.com/repos/rust-lang/rust/commits/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "html_url": "https://github.com/rust-lang/rust/commit/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df"}, {"sha": "180a92cad72fc6fa9fad5a0f97db24703fe280bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/180a92cad72fc6fa9fad5a0f97db24703fe280bf", "html_url": "https://github.com/rust-lang/rust/commit/180a92cad72fc6fa9fad5a0f97db24703fe280bf"}], "stats": {"total": 1428, "additions": 1274, "deletions": 154}, "files": [{"sha": "56e284a12fa832eaaec9ed3be3328d62811033cc", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -315,7 +315,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n     /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n+    /// but in principle the allocator is free to give back more than what\n     /// we asked for.\n     ///\n     /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate"}, {"sha": "00529f0e2d54f4dcc0ac8ad3ea1c30bfab8efe42", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1619,6 +1619,69 @@ impl<I: Iterator> Peekable<I> {\n         let iter = &mut self.iter;\n         self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n     }\n+\n+    /// Consume the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<R>(&mut self, expected: &R) -> Option<I::Item>\n+    where\n+        R: ?Sized,\n+        I::Item: PartialEq<R>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n }\n \n /// An iterator that rejects elements while `predicate` returns `true`."}, {"sha": "6313de31ce4d582dfc2f7b33e57216ed7d1f1070", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -810,4 +810,78 @@ impl f32 {\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f32,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i32;\n+        let mut right = other.to_bits() as i32;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 31) as u32) >> 1) as i32;\n+        right ^= (((right >> 31) as u32) >> 1) as i32;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "d42e5392c586347af9dd092d4033342b46349e3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -824,4 +824,78 @@ impl f64 {\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f64,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i64;\n+        let mut right = other.to_bits() as i64;\n+\n+        // In case of negatives, flip all the bits except the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        //\n+        // To do the flipping, we construct a mask and XOR against it.\n+        // We branchlessly calculate an \"all-ones except for the sign bit\"\n+        // mask from negative-signed values: right shifting sign-extends\n+        // the integer, so we \"fill\" the mask with sign bits, and then\n+        // convert to unsigned to push one more zero bit.\n+        // On positive values, the mask is all zeros, so it's a no-op.\n+        left ^= (((left >> 63) as u64) >> 1) as i64;\n+        right ^= (((right >> 63) as u64) >> 1) as i64;\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "0265235a65a35562a5b462982668cf604d4f5c96", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -813,6 +813,30 @@ fn test_iterator_peekable_rfold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_next_if_eq() {\n+    // first, try on references\n+    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n+    let mut it = xs.into_iter().peekable();\n+    // try before `peek()`\n+    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n+    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n+    // try after peek()\n+    assert_eq!(it.peek(), Some(&\"of\"));\n+    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n+    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n+    // make sure `next()` still behaves\n+    assert_eq!(it.next(), Some(\"Gold\"));\n+\n+    // make sure comparison works for owned values\n+    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n+    let mut it = xs.into_iter().peekable();\n+    // make sure basic functionality works\n+    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n+    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n+    assert_eq!(it.next_if_eq(\"\"), None);\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again."}, {"sha": "37ebf4112808e77ecfeb193acb91e3887ea5e28a", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -43,6 +43,7 @@\n #![feature(leading_trailing_ones)]\n #![feature(const_forget)]\n #![feature(option_unwrap_none)]\n+#![feature(peekable_next_if)]\n \n extern crate test;\n "}, {"sha": "f516de43095bd4dd3f0d19c9a045a4cc5aea3898", "filename": "src/librustc_error_codes/error_codes/E0619.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0619.md?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1,4 +1,5 @@\n #### Note: this error code is no longer emitted by the compiler.\n+\n The type-checker needed to know the type of an expression, but that type had not\n yet been inferred.\n "}, {"sha": "0298f3d8442a6c37fd3fad2f387ced1b21b8b831", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -419,7 +419,7 @@ pub struct TypeckTables<'tcx> {\n     /// The upvarID contains the HIR node ID and it also contains the full path\n     /// leading to the member of the struct or tuple that is used instead of the\n     /// entire variable.\n-    pub upvar_list: ty::UpvarListMap,\n+    pub closure_captures: ty::UpvarListMap,\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n@@ -447,7 +447,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n-            upvar_list: Default::default(),\n+            closure_captures: Default::default(),\n             generator_interior_types: Default::default(),\n         }\n     }\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref concrete_opaque_types,\n-            ref upvar_list,\n+            ref closure_captures,\n             ref generator_interior_types,\n         } = *self;\n \n@@ -721,7 +721,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n-            upvar_list.hash_stable(hcx, hasher);\n+            closure_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "65e62dbd9dd492420e1a8c0dc8a691422faa8518", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -142,7 +142,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n-        .upvar_list\n+        .closure_captures\n         .get(&def_id.to_def_id())\n         .into_iter()\n         .flat_map(|v| v.values())"}, {"sha": "e962dfb2b3e86735db858db51e93e8f2056028ba", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -227,7 +227,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let mut name = None;\n                 if let Some(def_id) = def_id.as_local() {\n                     let tables = self.ecx.tcx.typeck_tables_of(def_id);\n-                    if let Some(upvars) = tables.upvar_list.get(&def_id.to_def_id()) {\n+                    if let Some(upvars) = tables.closure_captures.get(&def_id.to_def_id()) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {"}, {"sha": "3d821aa55a1f87fc0d51d3a0e3c5fa377904acf3", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -790,11 +790,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let hir_tables = self.hir.tables();\n \n         // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n-        // closure and we stored in a map called upvar_list in TypeckTables indexed\n+        // indexed closure and we stored in a map called closure_captures in TypeckTables\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`.\n-        if let Some(upvars) = hir_tables.upvar_list.get(&fn_def_id) {\n+        if let Some(upvars) = hir_tables.closure_captures.get(&fn_def_id) {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;"}, {"sha": "fd3c48b38badbf3786fd58db4dfa95241899d94e", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -884,7 +884,7 @@ fn convert_var<'tcx>(\n ) -> ExprKind<'tcx> {\n     let upvar_index = cx\n         .tables()\n-        .upvar_list\n+        .closure_captures\n         .get(&cx.body_owner)\n         .and_then(|upvars| upvars.get_full(&var_hir_id).map(|(i, _, _)| i));\n "}, {"sha": "55978afc59437c74dbfe750d0d1b5530ac82b924", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 208, "deletions": 113, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -76,22 +76,10 @@\n //!   is not just used to generate a new value. For example, `x += 1` is\n //!   a read but not a use. This is used to generate better warnings.\n //!\n-//! ## Special Variables\n+//! ## Special nodes and variables\n //!\n-//! We generate various special variables for various, well, special purposes.\n-//! These are described in the `specials` struct:\n-//!\n-//! - `exit_ln`: a live node that is generated to represent every 'exit' from\n-//!   the function, whether it be by explicit return, panic, or other means.\n-//!\n-//! - `fallthrough_ln`: a live node that represents a fallthrough\n-//!\n-//! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n-//!   fallthrough node. It is only live if the function could converge\n-//!   via means other than an explicit `return` expression. That is, it is\n-//!   only dead if the end of the function's block can never be reached.\n-//!   It is the responsibility of typeck to ensure that there are no\n-//!   `return` expressions in a function declared as diverging.\n+//! We generate various special nodes for various, well, special purposes.\n+//! These are described in the `Specials` struct.\n \n use self::LiveNodeKind::*;\n use self::VarKind::*;\n@@ -140,6 +128,7 @@ enum LiveNodeKind {\n     UpvarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n+    ClosureNode,\n     ExitNode,\n }\n \n@@ -149,6 +138,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n         UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_string(s)),\n         ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_string(s)),\n         VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_string(s)),\n+        ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n }\n@@ -253,7 +243,7 @@ struct LocalInfo {\n enum VarKind {\n     Param(HirId, Symbol),\n     Local(LocalInfo),\n-    CleanExit,\n+    Upvar(HirId, Symbol),\n }\n \n struct IrMaps<'tcx> {\n@@ -306,10 +296,9 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) | Upvar(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             }\n-            CleanExit => {}\n         }\n \n         debug!(\"{:?} is {:?}\", v, vk);\n@@ -328,15 +317,14 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Param(_, name) => name.to_string(),\n-            CleanExit => \"<clean-exit>\".to_owned(),\n+            Local(LocalInfo { name, .. }) | Param(_, name) | Upvar(_, name) => name.to_string(),\n         }\n     }\n \n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Param(..) | CleanExit => false,\n+            Param(..) | Upvar(..) => false,\n         }\n     }\n \n@@ -357,7 +345,7 @@ fn visit_fn<'tcx>(\n     sp: Span,\n     id: hir::HirId,\n ) {\n-    debug!(\"visit_fn\");\n+    debug!(\"visit_fn {:?}\", id);\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n@@ -377,6 +365,14 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n+    if let Some(upvars) = ir.tcx.upvars_mentioned(def_id) {\n+        for (&var_hir_id, _upvar) in upvars {\n+            debug!(\"adding upvar {:?}\", var_hir_id);\n+            let var_name = ir.tcx.hir().name(var_hir_id);\n+            fn_maps.add_variable(Upvar(var_hir_id, var_name));\n+        }\n+    }\n+\n     for param in body.params {\n         let is_shorthand = match param.pat.kind {\n             rustc_hir::PatKind::Struct(..) => true,\n@@ -399,10 +395,12 @@ fn visit_fn<'tcx>(\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, def_id);\n-    let entry_ln = lsets.compute(&body.value);\n+    let entry_ln = lsets.compute(fk, &body, sp, id);\n+    lsets.log_liveness(entry_ln, id);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n+    lsets.warn_about_unused_upvars(entry_ln);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -462,11 +460,8 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         // live nodes required for uses or definitions of variables:\n         hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n             debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n-            if let Res::Local(var_hir_id) = path.res {\n-                let upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n-                if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n-                    ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-                }\n+            if let Res::Local(_var_hir_id) = path.res {\n+                ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n             }\n             intravisit::walk_expr(ir, expr);\n         }\n@@ -482,16 +477,9 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             let mut call_caps = Vec::new();\n             let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = ir.tcx.upvars_mentioned(closure_def_id) {\n-                let parent_upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n-                call_caps.extend(upvars.iter().filter_map(|(&var_id, upvar)| {\n-                    let has_parent =\n-                        parent_upvars.map_or(false, |upvars| upvars.contains_key(&var_id));\n-                    if !has_parent {\n-                        let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n-                        Some(CaptureInfo { ln: upvar_ln, var_hid: var_id })\n-                    } else {\n-                        None\n-                    }\n+                call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n+                    CaptureInfo { ln: upvar_ln, var_hid: var_id }\n                 }));\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n@@ -647,9 +635,13 @@ impl RWUTable {\n \n #[derive(Copy, Clone)]\n struct Specials {\n+    /// A live node representing a point of execution before closure entry &\n+    /// after closure exit. Used to calculate liveness of captured variables\n+    /// through calls to the same closure. Used for Fn & FnMut closures only.\n+    closure_ln: LiveNode,\n+    /// A live node representing every 'exit' from the function, whether it be\n+    /// by explicit return, panic, or other means.\n     exit_ln: LiveNode,\n-    fallthrough_ln: LiveNode,\n-    clean_exit_var: Variable,\n }\n \n const ACC_READ: u32 = 1;\n@@ -673,14 +665,9 @@ struct Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        // Special nodes and variables:\n-        // - exit_ln represents the end of the fn, either by return or panic\n-        // - implicit_ret_var is a pseudo-variable that represents\n-        //   an implicit return\n         let specials = Specials {\n+            closure_ln: ir.add_live_node(ClosureNode),\n             exit_ln: ir.add_live_node(ExitNode),\n-            fallthrough_ln: ir.add_live_node(ExitNode),\n-            clean_exit_var: ir.add_variable(CleanExit),\n         };\n \n         let tables = ir.tcx.typeck_tables_of(def_id);\n@@ -777,12 +764,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn write_vars<F>(&self, wr: &mut dyn Write, ln: LiveNode, mut test: F) -> io::Result<()>\n     where\n-        F: FnMut(usize) -> LiveNode,\n+        F: FnMut(usize) -> bool,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in 0..self.ir.num_vars {\n             let idx = node_base_idx + var_idx;\n-            if test(idx).is_valid() {\n+            if test(idx) {\n                 write!(wr, \" {:?}\", Variable(var_idx as u32))?;\n             }\n         }\n@@ -795,14 +782,31 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx));\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx));\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n+            write!(wr, \"  uses\");\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n+\n             write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n \n+    fn log_liveness(&self, entry_ln: LiveNode, hir_id: hir::HirId) {\n+        // hack to skip the loop unless debug! is enabled:\n+        debug!(\n+            \"^^ liveness computation results for body {} (entry={:?})\",\n+            {\n+                for ln_idx in 0..self.ir.num_live_nodes {\n+                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                }\n+                hir_id\n+            },\n+            entry_ln\n+        );\n+    }\n+\n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[ln.get()] = succ_ln;\n \n@@ -903,30 +907,87 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n-        debug!(\"compute: using id for body, {:?}\", body);\n+    fn compute(\n+        &mut self,\n+        fk: FnKind<'_>,\n+        body: &hir::Body<'_>,\n+        span: Span,\n+        id: hir::HirId,\n+    ) -> LiveNode {\n+        debug!(\"compute: using id for body, {:?}\", body.value);\n+\n+        // # Liveness of captured variables\n+        //\n+        // When computing the liveness for captured variables we take into\n+        // account how variable is captured (ByRef vs ByValue) and what is the\n+        // closure kind (Generator / FnOnce vs Fn / FnMut).\n+        //\n+        // Variables captured by reference are assumed to be used on the exit\n+        // from the closure.\n+        //\n+        // In FnOnce closures, variables captured by value are known to be dead\n+        // on exit since it is impossible to call the closure again.\n+        //\n+        // In Fn / FnMut closures, variables captured by value are live on exit\n+        // if they are live on the entry to the closure, since only the closure\n+        // itself can access them on subsequent calls.\n+\n+        if let Some(upvars) = self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            // Mark upvars captured by reference as used after closure exits.\n+            for (&var_hir_id, upvar) in upvars.iter().rev() {\n+                let upvar_id = ty::UpvarId {\n+                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                    closure_expr_id: self.ir.body_owner.expect_local(),\n+                };\n+                match self.tables.upvar_capture(upvar_id) {\n+                    ty::UpvarCapture::ByRef(_) => {\n+                        let var = self.variable(var_hir_id, upvar.span);\n+                        self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n+                    }\n+                    ty::UpvarCapture::ByValue => {}\n+                }\n+            }\n+        }\n \n-        // the fallthrough exit is only for those cases where we do not\n-        // explicitly return:\n-        let s = self.s;\n-        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+        let succ = self.propagate_through_expr(&body.value, self.s.exit_ln);\n \n-        let entry_ln = self.propagate_through_expr(body, s.fallthrough_ln);\n+        match fk {\n+            FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n+            FnKind::Closure(..) => {}\n+        }\n \n-        // hack to skip the loop unless debug! is enabled:\n-        debug!(\n-            \"^^ liveness computation results for body {} (entry={:?})\",\n-            {\n-                for ln_idx in 0..self.ir.num_live_nodes {\n-                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n-                }\n-                body.hir_id\n+        let ty = self.tables.node_type(id);\n+        match ty.kind {\n+            ty::Closure(_def_id, substs) => match substs.as_closure().kind() {\n+                ty::ClosureKind::Fn => {}\n+                ty::ClosureKind::FnMut => {}\n+                ty::ClosureKind::FnOnce => return succ,\n             },\n-            entry_ln\n-        );\n+            ty::Generator(..) => return succ,\n+            _ => {\n+                span_bug!(span, \"type of closure expr {:?} is not a closure {:?}\", id, ty,);\n+            }\n+        };\n+\n+        // Propagate through calls to the closure.\n+        let mut first_merge = true;\n+        loop {\n+            self.init_from_succ(self.s.closure_ln, succ);\n+            for param in body.params {\n+                param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+                    let var = self.variable(hir_id, ident.span);\n+                    self.define(self.s.closure_ln, var);\n+                })\n+            }\n+\n+            if !self.merge_from_succ(self.s.exit_ln, self.s.closure_ln, first_merge) {\n+                break;\n+            }\n+            first_merge = false;\n+            assert_eq!(succ, self.propagate_through_expr(&body.value, self.s.exit_ln));\n+        }\n \n-        entry_ln\n+        succ\n     }\n \n     fn propagate_through_block(&mut self, blk: &hir::Block<'_>, succ: LiveNode) -> LiveNode {\n@@ -1363,14 +1424,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         acc: u32,\n     ) -> LiveNode {\n         match path.res {\n-            Res::Local(hid) => {\n-                let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n-                if !upvars.map_or(false, |upvars| upvars.contains_key(&hid)) {\n-                    self.access_var(hir_id, hid, succ, acc, path.span)\n-                } else {\n-                    succ\n-                }\n-            }\n+            Res::Local(hid) => self.access_var(hir_id, hid, succ, acc, path.span),\n             _ => succ,\n         }\n     }\n@@ -1529,16 +1583,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n-                    let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n-                    if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hid)) {\n-                        // Assignment to an immutable variable or argument: only legal\n-                        // if there is no later assignment. If this local is actually\n-                        // mutable, then check for a reassignment to flag the mutability\n-                        // as being used.\n-                        let ln = self.live_node(expr.hir_id, expr.span);\n-                        let var = self.variable(var_hid, expr.span);\n-                        self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n-                    }\n+                    // Assignment to an immutable variable or argument: only legal\n+                    // if there is no later assignment. If this local is actually\n+                    // mutable, then check for a reassignment to flag the mutability\n+                    // as being used.\n+                    let ln = self.live_node(expr.hir_id, expr.span);\n+                    let var = self.variable(var_hid, expr.span);\n+                    self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n                 }\n             }\n             _ => {\n@@ -1554,11 +1605,60 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         if name.is_empty() || name.as_bytes()[0] == b'_' { None } else { Some(name) }\n     }\n \n+    fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n+        let upvars = match self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            None => return,\n+            Some(upvars) => upvars,\n+        };\n+        for (&var_hir_id, upvar) in upvars.iter() {\n+            let var = self.variable(var_hir_id, upvar.span);\n+            let upvar_id = ty::UpvarId {\n+                var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                closure_expr_id: self.ir.body_owner.expect_local(),\n+            };\n+            match self.tables.upvar_capture(upvar_id) {\n+                ty::UpvarCapture::ByValue => {}\n+                ty::UpvarCapture::ByRef(..) => continue,\n+            };\n+            if self.used_on_entry(entry_ln, var) {\n+                if self.live_on_entry(entry_ln, var).is_none() {\n+                    if let Some(name) = self.should_warn(var) {\n+                        self.ir.tcx.struct_span_lint_hir(\n+                            lint::builtin::UNUSED_ASSIGNMENTS,\n+                            var_hir_id,\n+                            vec![upvar.span],\n+                            |lint| {\n+                                lint.build(&format!(\"value captured by `{}` is never read\", name))\n+                                    .help(\"did you mean to capture by reference instead?\")\n+                                    .emit();\n+                            },\n+                        );\n+                    }\n+                }\n+            } else {\n+                if let Some(name) = self.should_warn(var) {\n+                    self.ir.tcx.struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        var_hir_id,\n+                        vec![upvar.span],\n+                        |lint| {\n+                            lint.build(&format!(\"unused variable: `{}`\", name))\n+                                .help(\"did you mean to capture by reference instead?\")\n+                                .emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n         for p in body.params {\n             self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n                 if self.live_on_entry(ln, var).is_none() {\n-                    self.report_dead_assign(hir_id, spans, var, true);\n+                    self.report_unsed_assign(hir_id, spans, var, |name| {\n+                        format!(\"value passed to `{}` is never read\", name)\n+                    });\n                 }\n             });\n         }\n@@ -1672,35 +1772,30 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, spans, var, false);\n+            self.report_unsed_assign(hir_id, spans, var, |name| {\n+                format!(\"value assigned to `{}` is never read\", name)\n+            });\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n+    fn report_unsed_assign(\n+        &self,\n+        hir_id: HirId,\n+        spans: Vec<Span>,\n+        var: Variable,\n+        message: impl Fn(&str) -> String,\n+    ) {\n         if let Some(name) = self.should_warn(var) {\n-            if is_param {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value passed to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            } else {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value assigned to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            }\n+            self.ir.tcx.struct_span_lint_hir(\n+                lint::builtin::UNUSED_ASSIGNMENTS,\n+                hir_id,\n+                spans,\n+                |lint| {\n+                    lint.build(&message(&name))\n+                        .help(\"maybe it is overwritten before being read?\")\n+                        .emit();\n+                },\n+            )\n         }\n     }\n }"}, {"sha": "f4e46a04931519b95e5386734bcafa02e87614c1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -21,11 +21,31 @@ use rustc_target::spec::abi;\n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called).\n-pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_>, span: Span, trait_id: DefId) {\n+pub fn check_legal_trait_for_method_call(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    receiver: Option<Span>,\n+    trait_id: DefId,\n+) {\n     if tcx.lang_items().drop_trait() == Some(trait_id) {\n-        struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n-            .span_label(span, \"explicit destructor calls not allowed\")\n-            .emit();\n+        let mut err = struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\");\n+        err.span_label(span, \"explicit destructor calls not allowed\");\n+\n+        let snippet = receiver\n+            .and_then(|s| tcx.sess.source_map().span_to_snippet(s).ok())\n+            .unwrap_or_default();\n+\n+        let suggestion =\n+            if snippet.is_empty() { \"drop\".to_string() } else { format!(\"drop({})\", snippet) };\n+\n+        err.span_suggestion(\n+            span,\n+            &format!(\"consider using `drop` function: `{}`\", suggestion),\n+            String::new(),\n+            Applicability::Unspecified,\n+        );\n+\n+        err.emit();\n     }\n }\n "}, {"sha": "7e4e1aa608ece784564b238251b60bda68f145f1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -597,9 +597,12 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick<'_>) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {\n-            ty::TraitContainer(trait_def_id) => {\n-                callee::check_legal_trait_for_method_call(self.tcx, self.span, trait_def_id)\n-            }\n+            ty::TraitContainer(trait_def_id) => callee::check_legal_trait_for_method_call(\n+                self.tcx,\n+                self.span,\n+                Some(self.self_expr.span),\n+                trait_def_id,\n+            ),\n             ty::ImplContainer(..) => {}\n         }\n     }"}, {"sha": "3cb6ce61ee8d78da706c2986c192fc61b5cc9823", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -5433,7 +5433,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n+                        callee::check_legal_trait_for_method_call(tcx, span, None, trait_did)\n                     }\n                     ty::ImplContainer(impl_def_id) => {\n                         if segments.len() == 1 {"}, {"sha": "19a23e5a594788b52a8c5e02a98fa74ce1233623", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-            let mut upvar_list: FxIndexMap<hir::HirId, ty::UpvarId> =\n+            let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> =\n                 FxIndexMap::with_capacity_and_hasher(upvars.len(), Default::default());\n             for (&var_hir_id, _) in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n@@ -122,7 +122,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n                 // Adding the upvar Id to the list of Upvars, which will be added\n                 // to the map for the closure at the end of the for loop.\n-                upvar_list.insert(var_hir_id, upvar_id);\n+                closure_captures.insert(var_hir_id, upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureBy::Value => ty::UpvarCapture::ByValue,\n@@ -140,8 +140,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Add the vector of upvars to the map keyed with the closure id.\n             // This gives us an easier access to them without having to call\n             // tcx.upvars again..\n-            if !upvar_list.is_empty() {\n-                self.tables.borrow_mut().upvar_list.insert(closure_def_id, upvar_list);\n+            if !closure_captures.is_empty() {\n+                self.tables.borrow_mut().closure_captures.insert(closure_def_id, closure_captures);\n             }\n         }\n "}, {"sha": "3473dc7a58d0469e5c50751b5dde57999cf0c7dc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -74,8 +74,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n-        wbcx.tables.upvar_list =\n-            mem::replace(&mut self.tables.borrow_mut().upvar_list, Default::default());\n+        wbcx.tables.closure_captures =\n+            mem::replace(&mut self.tables.borrow_mut().closure_captures, Default::default());\n \n         if self.is_tainted_by_errors() {\n             // FIXME(eddyb) keep track of `ErrorReported` from where the error was emitted."}, {"sha": "8ff19557a3063467ceeb0c5e663c31700d2390a9", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1531,4 +1531,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f32.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u32 {\n+            1 << (f32::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f32 {\n+            f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f32 {\n+            f32::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f32 {\n+            f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f32 {\n+            f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "d7845fd2c4ddcc3efe86096faeaf71ecd36fd301", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1554,4 +1554,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f64.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u64 {\n+            1 << (f64::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f64 {\n+            f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f64 {\n+            f64::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f64 {\n+            f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f64 {\n+            f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "72dfe2937f491082041f1c91c6565e1d5863ed1b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -311,6 +311,7 @@\n #![feature(test)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n+#![feature(total_cmp)]\n #![feature(trace_macros)]\n #![feature(track_caller)]\n #![feature(try_reserve)]"}, {"sha": "b780340884e1f83d735a8907887acc86e3774111", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -2,7 +2,7 @@ use crate::cmp::Ordering;\n use crate::convert::TryInto;\n use crate::fmt;\n use crate::hash;\n-use crate::io;\n+use crate::io::{self, Write};\n use crate::iter;\n use crate::mem;\n use crate::net::{htons, ntohs, IpAddr, Ipv4Addr, Ipv6Addr};\n@@ -600,7 +600,26 @@ impl fmt::Display for SocketAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV4 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}:{}\", self.ip(), self.port())\n+        // Fast path: if there's no alignment stuff, write to the output buffer\n+        // directly\n+        if f.precision().is_none() && f.width().is_none() {\n+            write!(f, \"{}:{}\", self.ip(), self.port())\n+        } else {\n+            const IPV4_SOCKET_BUF_LEN: usize = (3 * 4)  // the segments\n+                + 3  // the separators\n+                + 1 + 5; // the port\n+            let mut buf = [0; IPV4_SOCKET_BUF_LEN];\n+            let mut buf_slice = &mut buf[..];\n+\n+            // Unwrap is fine because writing to a sufficiently-sized\n+            // buffer is infallible\n+            write!(buf_slice, \"{}:{}\", self.ip(), self.port()).unwrap();\n+            let len = IPV4_SOCKET_BUF_LEN - buf_slice.len();\n+\n+            // This unsafe is OK because we know what is being written to the buffer\n+            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+            f.pad(buf)\n+        }\n     }\n }\n \n@@ -614,7 +633,28 @@ impl fmt::Debug for SocketAddrV4 {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV6 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"[{}]:{}\", self.ip(), self.port())\n+        // Fast path: if there's no alignment stuff, write to the output\n+        // buffer directly\n+        if f.precision().is_none() && f.width().is_none() {\n+            write!(f, \"[{}]:{}\", self.ip(), self.port())\n+        } else {\n+            const IPV6_SOCKET_BUF_LEN: usize = (4 * 8)  // The address\n+            + 7  // The colon separators\n+            + 2  // The brackets\n+            + 1 + 5; // The port\n+\n+            let mut buf = [0; IPV6_SOCKET_BUF_LEN];\n+            let mut buf_slice = &mut buf[..];\n+\n+            // Unwrap is fine because writing to a sufficiently-sized\n+            // buffer is infallible\n+            write!(buf_slice, \"[{}]:{}\", self.ip(), self.port()).unwrap();\n+            let len = IPV6_SOCKET_BUF_LEN - buf_slice.len();\n+\n+            // This unsafe is OK because we know what is being written to the buffer\n+            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+            f.pad(buf)\n+        }\n     }\n }\n \n@@ -1168,6 +1208,28 @@ mod tests {\n         assert!(v6.is_ipv6());\n     }\n \n+    #[test]\n+    fn socket_v4_to_str() {\n+        let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n+\n+        assert_eq!(format!(\"{}\", socket), \"192.168.0.1:8080\");\n+        assert_eq!(format!(\"{:<20}\", socket), \"192.168.0.1:8080    \");\n+        assert_eq!(format!(\"{:>20}\", socket), \"    192.168.0.1:8080\");\n+        assert_eq!(format!(\"{:^20}\", socket), \"  192.168.0.1:8080  \");\n+        assert_eq!(format!(\"{:.10}\", socket), \"192.168.0.\");\n+    }\n+\n+    #[test]\n+    fn socket_v6_to_str() {\n+        let socket: SocketAddrV6 = \"[2a02:6b8:0:1::1]:53\".parse().unwrap();\n+\n+        assert_eq!(format!(\"{}\", socket), \"[2a02:6b8:0:1::1]:53\");\n+        assert_eq!(format!(\"{:<24}\", socket), \"[2a02:6b8:0:1::1]:53    \");\n+        assert_eq!(format!(\"{:>24}\", socket), \"    [2a02:6b8:0:1::1]:53\");\n+        assert_eq!(format!(\"{:^24}\", socket), \"  [2a02:6b8:0:1::1]:53  \");\n+        assert_eq!(format!(\"{:.15}\", socket), \"[2a02:6b8:0:1::\");\n+    }\n+\n     #[test]\n     fn compare() {\n         let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();"}, {"sha": "1b0feede34ecfc0a8714e340d58af8985b66f464", "filename": "src/test/ui/closures/closure-immutable-outer-variable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let mut y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "50ec1c6148a046cfe39fc815ee16b9fce849df04", "filename": "src/test/ui/closures/closure-immutable-outer-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "799097889cd30f40e16d8c3cbcd15b7059b94595", "filename": "src/test/ui/closures/closure-immutable-outer-variable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -3,8 +3,8 @@ error[E0594]: cannot assign to `y`, as it is not declared as mutable\n    |\n LL |     let y = true;\n    |         - help: consider changing this to be mutable: `mut y`\n-LL |     foo(Box::new(move || y = false) as Box<_>);\n-   |                          ^^^^^^^^^ cannot assign\n+LL |     foo(Box::new(move || y = !y) as Box<_>);\n+   |                          ^^^^^^ cannot assign\n \n error: aborting due to previous error\n "}, {"sha": "69cf28b29704fafa1452cc6ded0ea23aa75bf480", "filename": "src/test/ui/error-codes/E0040.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Ferror-codes%2FE0040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Ferror-codes%2FE0040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0040.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -2,7 +2,10 @@ error[E0040]: explicit use of destructor method\n   --> $DIR/E0040.rs:13:7\n    |\n LL |     x.drop();\n-   |       ^^^^ explicit destructor calls not allowed\n+   |       ^^^^\n+   |       |\n+   |       explicit destructor calls not allowed\n+   |       help: consider using `drop` function: `drop(x)`\n \n error: aborting due to previous error\n "}, {"sha": "5ebe4ee4b90f89a146dc7dda6cdc5f914fae7ef6", "filename": "src/test/ui/explicit/explicit-call-to-dtor.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-dtor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-dtor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-dtor.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -2,7 +2,10 @@ error[E0040]: explicit use of destructor method\n   --> $DIR/explicit-call-to-dtor.rs:13:7\n    |\n LL |     x.drop();\n-   |       ^^^^ explicit destructor calls not allowed\n+   |       ^^^^\n+   |       |\n+   |       explicit destructor calls not allowed\n+   |       help: consider using `drop` function: `drop(x)`\n \n error: aborting due to previous error\n "}, {"sha": "cd3fb3119a5cfae286bbf7b0ad624f18da19374c", "filename": "src/test/ui/explicit/explicit-call-to-supertrait-dtor.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-supertrait-dtor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-supertrait-dtor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplicit%2Fexplicit-call-to-supertrait-dtor.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -2,7 +2,10 @@ error[E0040]: explicit use of destructor method\n   --> $DIR/explicit-call-to-supertrait-dtor.rs:17:14\n    |\n LL |         self.drop();\n-   |              ^^^^ explicit destructor calls not allowed\n+   |              ^^^^\n+   |              |\n+   |              explicit destructor calls not allowed\n+   |              help: consider using `drop` function: `drop(self)`\n \n error: aborting due to previous error\n "}, {"sha": "57c99739afd247f7e0c84ef7907a5043d8e1901e", "filename": "src/test/ui/illegal-ufcs-drop.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fillegal-ufcs-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fillegal-ufcs-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fillegal-ufcs-drop.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -2,7 +2,10 @@ error[E0040]: explicit use of destructor method\n   --> $DIR/illegal-ufcs-drop.rs:8:5\n    |\n LL |     Drop::drop(&mut Foo)\n-   |     ^^^^^^^^^^ explicit destructor calls not allowed\n+   |     ^^^^^^^^^^\n+   |     |\n+   |     explicit destructor calls not allowed\n+   |     help: consider using `drop` function: `drop`\n \n error: aborting due to previous error\n "}, {"sha": "a34d7bae3a6ca9bda37d7958e1262a868d7ea695", "filename": "src/test/ui/impl-trait/issue-56445.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-56445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-56445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-56445.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,26 @@\n+// Regression test for https://github.com/rust-lang/rust/issues/56445#issuecomment-629426939\n+// check-pass\n+\n+#![crate_type = \"lib\"]\n+\n+use std::marker::PhantomData;\n+\n+pub struct S<'a>\n+{\n+    pub m1: PhantomData<&'a u8>,\n+    pub m2: [u8; S::size()],\n+}\n+\n+impl<'a> S<'a>\n+{\n+    pub const fn size() -> usize { 1 }\n+\n+    pub fn new() -> Self\n+    {\n+        Self\n+        {\n+            m1: PhantomData,\n+            m2: [0; Self::size()],\n+        }\n+    }\n+}"}, {"sha": "01a7af0aee40e872bdd238aa0d15f4203f4a3e86", "filename": "src/test/ui/impl-trait/issue-68532.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-68532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-68532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-68532.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+pub struct A<'a>(&'a ());\n+\n+impl<'a> A<'a> {\n+    const N: usize = 68;\n+\n+    pub fn foo(&self) {\n+        let _b = [0; Self::N];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a7af01e25b4e2899512d0d8cc0a00c91bf8c13d1", "filename": "src/test/ui/issues/issue-11958.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1,10 +1,11 @@\n // run-pass\n-#![forbid(warnings)]\n \n // We shouldn't need to rebind a moved upvar as mut if it's already\n // marked as mut\n \n pub fn main() {\n     let mut x = 1;\n     let _thunk = Box::new(move|| { x = 2; });\n+    //~^ WARN value assigned to `x` is never read\n+    //~| WARN unused variable: `x`\n }"}, {"sha": "25de6ff4c118c033083e9d4cc20b92212726bea8", "filename": "src/test/ui/issues/issue-11958.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,20 @@\n+warning: value assigned to `x` is never read\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "b2837e74b8c5161668e07a2e27e7b6eae5c69581", "filename": "src/test/ui/liveness/liveness-upvars.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,108 @@\n+// edition:2018\n+// check-pass\n+#![warn(unused)]\n+#![allow(unreachable_code)]\n+\n+pub fn unintentional_copy_one() {\n+    let mut last = None;\n+    let mut f = move |s| {\n+        last = Some(s); //~  WARN value assigned to `last` is never read\n+                        //~| WARN unused variable: `last`\n+    };\n+    f(\"a\");\n+    f(\"b\");\n+    f(\"c\");\n+    dbg!(last.unwrap());\n+}\n+\n+pub fn unintentional_copy_two() {\n+    let mut sum = 0;\n+    (1..10).for_each(move |x| {\n+        sum += x; //~ WARN unused variable: `sum`\n+    });\n+    dbg!(sum);\n+}\n+\n+pub fn f() {\n+    let mut c = 0;\n+\n+    // Captured by value, but variable is dead on entry.\n+    move || {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+    let _ = async move {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+\n+    // Read and written to, but never actually used.\n+    move || {\n+        c += 1; //~ WARN unused variable: `c`\n+    };\n+    let _ = async move {\n+        c += 1; //~  WARN value assigned to `c` is never read\n+                //~| WARN unused variable: `c`\n+    };\n+\n+    move || {\n+        println!(\"{}\", c);\n+        // Value is read by closure itself on later invocations.\n+        c += 1;\n+    };\n+    let b = Box::new(42);\n+    move || {\n+        println!(\"{}\", c);\n+        // Never read because this is FnOnce closure.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+        drop(b);\n+    };\n+    let _ = async move {\n+        println!(\"{}\", c);\n+        // Never read because this is a generator.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+    };\n+}\n+\n+pub fn nested() {\n+    let mut d = None;\n+    let mut e = None;\n+    || {\n+        || {\n+            d = Some(\"d1\"); //~ WARN value assigned to `d` is never read\n+            d = Some(\"d2\");\n+        };\n+        move || {\n+            e = Some(\"e1\"); //~  WARN value assigned to `e` is never read\n+                            //~| WARN unused variable: `e`\n+            e = Some(\"e2\"); //~  WARN value assigned to `e` is never read\n+        };\n+    };\n+}\n+\n+pub fn g<T: Default>(mut v: T) {\n+    |r| {\n+        if r {\n+            v = T::default(); //~ WARN value assigned to `v` is never read\n+        } else {\n+            drop(v);\n+        }\n+    };\n+}\n+\n+pub fn h<T: Copy + Default + std::fmt::Debug>() {\n+    let mut z = T::default();\n+    move |b| {\n+        loop {\n+            if b {\n+                z = T::default(); //~  WARN value assigned to `z` is never read\n+                                  //~| WARN unused variable: `z`\n+            } else {\n+                return;\n+            }\n+        }\n+        dbg!(z);\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "14fed917864361d0810912e8704066fca84fbcbc", "filename": "src/test/ui/liveness/liveness-upvars.stderr", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,150 @@\n+warning: value assigned to `last` is never read\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `last`\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `sum`\n+  --> $DIR/liveness-upvars.rs:21:9\n+   |\n+LL |         sum += x;\n+   |         ^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:31:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:35:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:41:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:57:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:63:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `d` is never read\n+  --> $DIR/liveness-upvars.rs:72:13\n+   |\n+LL |             d = Some(\"d1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:78:13\n+   |\n+LL |             e = Some(\"e2\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `e`\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `v` is never read\n+  --> $DIR/liveness-upvars.rs:86:13\n+   |\n+LL |             v = T::default();\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `z` is never read\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `z`\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 17 warnings emitted\n+"}, {"sha": "c5e4a72fb9ff18ed69a61ae52506d7fbf6d8500e", "filename": "src/test/ui/pattern/issue-71042-opaquely-typed-constant-used-in-pattern.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,9 @@\n+#![feature(impl_trait_in_bindings)]\n+#![allow(incomplete_features)]\n+\n+fn main() {\n+    const C: impl Copy = 0;\n+    match C {\n+        C | _ => {} //~ ERROR: opaque types cannot be used in patterns\n+    }\n+}"}, {"sha": "7695223f2cf98ef8dfff80d6090302a22769551c", "filename": "src/test/ui/pattern/issue-71042-opaquely-typed-constant-used-in-pattern.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,8 @@\n+error: opaque types cannot be used in patterns\n+  --> $DIR/issue-71042-opaquely-typed-constant-used-in-pattern.rs:7:9\n+   |\n+LL |         C | _ => {}\n+   |         ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "dff0d89d465dd4573681b0b20b30236dc195e688", "filename": "src/test/ui/type-alias-impl-trait/issue-70121.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-70121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-70121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-70121.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub type Successors<'a> = impl Iterator<Item = &'a ()>;\n+\n+pub fn f<'a>() -> Successors<'a> {\n+    None.into_iter()\n+}\n+\n+pub trait Tr {\n+    type Item;\n+}\n+\n+impl<'a> Tr for &'a () {\n+    type Item = Successors<'a>;\n+}\n+\n+pub fn kazusa<'a>() -> <&'a () as Tr>::Item {\n+    None.into_iter()\n+}\n+\n+fn main() {}"}, {"sha": "390386e57fa72db7dca488f0ff1c1c9511ee7c13", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![allow(unused_variables)]\n // Test that we mutate a counter on the stack only when we expect to.\n \n fn call<F>(f: F) where F : FnOnce() {\n@@ -13,7 +12,7 @@ fn main() {\n     call(|| {\n         // Move `y`, but do not move `counter`, even though it is read\n         // by value (note that it is also mutated).\n-        for item in y {\n+        for item in y { //~ WARN unused variable: `item`\n             let v = counter;\n             counter += v;\n         }\n@@ -22,7 +21,8 @@ fn main() {\n \n     call(move || {\n         // this mutates a moved copy, and hence doesn't affect original\n-        counter += 1;\n+        counter += 1; //~  WARN value assigned to `counter` is never read\n+                      //~| WARN unused variable: `counter`\n     });\n     assert_eq!(counter, 88);\n }"}, {"sha": "ba4b3dac6705e0bc41204e16de8bceb09ca10fb5", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,27 @@\n+warning: unused variable: `item`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:15:13\n+   |\n+LL |         for item in y {\n+   |             ^^^^ help: if this is intentional, prefix it with an underscore: `_item`\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+\n+warning: value assigned to `counter` is never read\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `counter`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "e5b19db78223123f78c73d9cab8feda4aeac7a5e", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -13,11 +13,11 @@ fn set(x: &mut usize) { *x = 42; }\n fn main() {\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;"}, {"sha": "4dfd1bb307574e7d0c94350bbd111d1bb49899a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd32c98047a809ba5fd1fac2aa044638e5f2105/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr?ref=4bd32c98047a809ba5fd1fac2aa044638e5f2105", "patch": "@@ -0,0 +1,19 @@\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:16:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:20:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}]}