{"sha": "fe63e479d1f6e3122b61f86f5117eac981b071f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNjNlNDc5ZDFmNmUzMTIyYjYxZjg2ZjUxMTdlYWM5ODFiMDcxZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-11T13:26:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-11T13:26:13Z"}, "message": "Auto merge of #50332 - Zoxc:interner-split, r=michaelwoerister\n\nOnly lookup types in one interner", "tree": {"sha": "64d8c55f5cc7a0aac854a2d0049fc6a2292e96f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64d8c55f5cc7a0aac854a2d0049fc6a2292e96f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe63e479d1f6e3122b61f86f5117eac981b071f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe63e479d1f6e3122b61f86f5117eac981b071f2", "html_url": "https://github.com/rust-lang/rust/commit/fe63e479d1f6e3122b61f86f5117eac981b071f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe63e479d1f6e3122b61f86f5117eac981b071f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41707d8df9a441e19387a4a61415ee0af58a9e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/41707d8df9a441e19387a4a61415ee0af58a9e48", "html_url": "https://github.com/rust-lang/rust/commit/41707d8df9a441e19387a4a61415ee0af58a9e48"}, {"sha": "e245d693225552b70d4dba7a1ee5d3cae12a8ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e245d693225552b70d4dba7a1ee5d3cae12a8ab4", "html_url": "https://github.com/rust-lang/rust/commit/e245d693225552b70d4dba7a1ee5d3cae12a8ab4"}], "stats": {"total": 145, "additions": 68, "deletions": 77}, "files": [{"sha": "a18103aaee54a8103cb075492556d2a977b833df", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 68, "deletions": 77, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/fe63e479d1f6e3122b61f86f5117eac981b071f2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe63e479d1f6e3122b61f86f5117eac981b071f2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fe63e479d1f6e3122b61f86f5117eac981b071f2", "patch": "@@ -162,66 +162,65 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n         }\n     }\n \n-    /// Intern a type. global_interners is Some only if this is\n-    /// a local interner and global_interners is its counterpart.\n-    fn intern_ty(&self, st: TypeVariants<'tcx>,\n-                 global_interners: Option<&CtxtInterners<'gcx>>)\n-                 -> Ty<'tcx> {\n-        let ty = {\n-            let mut interner = self.type_.borrow_mut();\n+    /// Intern a type\n+    fn intern_ty(\n+        local: &CtxtInterners<'tcx>,\n+        global: &CtxtInterners<'gcx>,\n+        st: TypeVariants<'tcx>\n+    ) -> Ty<'tcx> {\n+        let flags = super::flags::FlagComputation::for_sty(&st);\n+\n+        // HACK(eddyb) Depend on flags being accurate to\n+        // determine that all contents are in the global tcx.\n+        // See comments on Lift for why we can't use that.\n+        if flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n+            let mut interner = local.type_.borrow_mut();\n             if let Some(&Interned(ty)) = interner.get(&st) {\n                 return ty;\n             }\n-            let global_interner = global_interners.map(|interners| {\n-                (interners.type_.borrow_mut(), &interners.arena)\n-            });\n-            if let Some((ref type_, _)) = global_interner {\n-                if let Some(&Interned(ty)) = type_.get(&st) {\n-                    return ty;\n-                }\n-            }\n \n-            let flags = super::flags::FlagComputation::for_sty(&st);\n             let ty_struct = TyS {\n                 sty: st,\n                 flags: flags.flags,\n                 region_depth: flags.depth,\n             };\n \n-            // HACK(eddyb) Depend on flags being accurate to\n-            // determine that all contents are in the global tcx.\n-            // See comments on Lift for why we can't use that.\n-            if !flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n-                if let Some((mut type_, arena)) = global_interner {\n-                    let ty_struct: TyS<'gcx> = unsafe {\n-                        mem::transmute(ty_struct)\n-                    };\n-                    let ty: Ty<'gcx> = arena.alloc(ty_struct);\n-                    type_.insert(Interned(ty));\n-                    return ty;\n-                }\n-            } else {\n-                // Make sure we don't end up with inference\n-                // types/regions in the global tcx.\n-                if global_interner.is_none() {\n-                    drop(interner);\n-                    bug!(\"Attempted to intern `{:?}` which contains \\\n-                          inference types/regions in the global type context\",\n-                         &ty_struct);\n-                }\n+            // Make sure we don't end up with inference\n+            // types/regions in the global interner\n+            if local as *const _ as usize == global as *const _ as usize {\n+                bug!(\"Attempted to intern `{:?}` which contains \\\n+                    inference types/regions in the global type context\",\n+                    &ty_struct);\n             }\n \n             // Don't be &mut TyS.\n-            let ty: Ty<'tcx> = self.arena.alloc(ty_struct);\n+            let ty: Ty<'tcx> = local.arena.alloc(ty_struct);\n             interner.insert(Interned(ty));\n             ty\n-        };\n+        } else {\n+            let mut interner = global.type_.borrow_mut();\n+            if let Some(&Interned(ty)) = interner.get(&st) {\n+                return ty;\n+            }\n \n-        debug!(\"Interned type: {:?} Pointer: {:?}\",\n-            ty, ty as *const TyS);\n-        ty\n-    }\n+            let ty_struct = TyS {\n+                sty: st,\n+                flags: flags.flags,\n+                region_depth: flags.depth,\n+            };\n+\n+            // This is safe because all the types the ty_struct can point to\n+            // already is in the global arena\n+            let ty_struct: TyS<'gcx> = unsafe {\n+                mem::transmute(ty_struct)\n+            };\n \n+            // Don't be &mut TyS.\n+            let ty: Ty<'gcx> = global.arena.alloc(ty_struct);\n+            interner.insert(Interned(ty));\n+            ty\n+        }\n+    }\n }\n \n pub struct CommonTypes<'tcx> {\n@@ -796,7 +795,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n-        let mk = |sty| interners.intern_ty(sty, None);\n+        let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n             if let Some(r) = interners.region.borrow().get(&r) {\n                 return r.0;\n@@ -2130,43 +2129,42 @@ macro_rules! intern_method {\n                                             $keep_in_local_tcx:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n-                {\n-                    let key = ($alloc_to_key)(&v);\n-                    if let Some(i) = self.interners.$name.borrow().get(key) {\n-                        return i.0;\n-                    }\n-                    if !self.is_global() {\n-                        if let Some(i) = self.global_interners.$name.borrow().get(key) {\n-                            return i.0;\n-                        }\n-                    }\n-                }\n+                let key = ($alloc_to_key)(&v);\n \n                 // HACK(eddyb) Depend on flags being accurate to\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n-                if !($keep_in_local_tcx)(&v) {\n-                    if !self.is_global() {\n-                        let v = unsafe {\n-                            mem::transmute(v)\n-                        };\n-                        let i = ($alloc_to_ret)(self.global_interners.arena.$alloc_method(v));\n-                        self.global_interners.$name.borrow_mut().insert(Interned(i));\n-                        return i;\n+                if ($keep_in_local_tcx)(&v) {\n+                    let mut interner = self.interners.$name.borrow_mut();\n+                    if let Some(&Interned(v)) = interner.get(key) {\n+                        return v;\n                     }\n-                } else {\n+\n                     // Make sure we don't end up with inference\n                     // types/regions in the global tcx.\n                     if self.is_global() {\n                         bug!(\"Attempted to intern `{:?}` which contains \\\n                               inference types/regions in the global type context\",\n                              v);\n                     }\n-                }\n \n-                let i = ($alloc_to_ret)(self.interners.arena.$alloc_method(v));\n-                self.interners.$name.borrow_mut().insert(Interned(i));\n-                i\n+                    let i = ($alloc_to_ret)(self.interners.arena.$alloc_method(v));\n+                    interner.insert(Interned(i));\n+                    i\n+                } else {\n+                    let mut interner = self.global_interners.$name.borrow_mut();\n+                    if let Some(&Interned(v)) = interner.get(key) {\n+                        return v;\n+                    }\n+\n+                    // This transmutes $alloc<'tcx> to $alloc<'gcx>\n+                    let v = unsafe {\n+                        mem::transmute(v)\n+                    };\n+                    let i = ($alloc_to_ret)(self.global_interners.arena.$alloc_method(v));\n+                    interner.insert(Interned(i));\n+                    i\n+                }\n             }\n         }\n     }\n@@ -2274,15 +2272,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n-    // Interns a type/name combination, stores the resulting box in cx.interners,\n-    // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-    pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-        let global_interners = if !self.is_global() {\n-            Some(&self.global_interners)\n-        } else {\n-            None\n-        };\n-        self.interners.intern_ty(st, global_interners)\n+    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        CtxtInterners::intern_ty(&self.interners, &self.global_interners, st)\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}]}