{"sha": "217f1fbfc861cd6da41746f899bad79b37f471ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2YxZmJmYzg2MWNkNmRhNDE3NDZmODk5YmFkNzliMzdmNDcxYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T23:11:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T23:11:12Z"}, "message": "auto merge of #15272 : jakub-/rust/issue-13041, r=pcwalton\n\nFixes #13041.", "tree": {"sha": "05a42b3d59a43879c11416936d7e85dbf9cf67d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a42b3d59a43879c11416936d7e85dbf9cf67d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217f1fbfc861cd6da41746f899bad79b37f471ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217f1fbfc861cd6da41746f899bad79b37f471ab", "html_url": "https://github.com/rust-lang/rust/commit/217f1fbfc861cd6da41746f899bad79b37f471ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217f1fbfc861cd6da41746f899bad79b37f471ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43d84bf32ef8437b39cbb89cc30c6fd293df7b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d84bf32ef8437b39cbb89cc30c6fd293df7b88", "html_url": "https://github.com/rust-lang/rust/commit/43d84bf32ef8437b39cbb89cc30c6fd293df7b88"}, {"sha": "59edfdd2ab3bad73086940afe1a57fa4706a4d2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/59edfdd2ab3bad73086940afe1a57fa4706a4d2f", "html_url": "https://github.com/rust-lang/rust/commit/59edfdd2ab3bad73086940afe1a57fa4706a4d2f"}], "stats": {"total": 396, "additions": 312, "deletions": 84}, "files": [{"sha": "517bdcbff962ebee67552e0bd960d9dbbe30c8ee", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -13,8 +13,10 @@ use middle::freevars::freevar_entry;\n use middle::freevars;\n use middle::subst;\n use middle::ty;\n-use middle::typeck::{MethodCall, NoAdjustment};\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n+use middle::typeck::{MethodCall, NoAdjustment};\n use util::ppaux::{Repr, ty_to_string};\n use util::ppaux::UserString;\n \n@@ -83,18 +85,29 @@ pub fn check_crate(tcx: &ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n+struct EmptySubstsFolder<'a> {\n+    tcx: &'a ty::ctxt\n+}\n+impl<'a> ty_fold::TypeFolder for EmptySubstsFolder<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self.tcx\n+    }\n+    fn fold_substs(&mut self, _: &subst::Substs) -> subst::Substs {\n+        subst::Substs::empty()\n+    }\n+}\n+\n fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     span: Span,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n     if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n       && !struct_tpt.generics.has_region_params(subst::TypeSpace) {\n-        let struct_ty = ty::mk_struct(cx.tcx, struct_did,\n-                                      subst::Substs::empty());\n-        if !ty::type_is_sendable(cx.tcx, struct_ty) {\n+        let mut folder = EmptySubstsFolder { tcx: cx.tcx };\n+        if !ty::type_is_sendable(cx.tcx, struct_tpt.ty.fold_with(&mut folder)) {\n             span_err!(cx.tcx.sess, span, E0125,\n                       \"cannot implement a destructor on a \\\n-                       structure that does not satisfy Send\");\n+                       structure or enumeration that does not satisfy Send\");\n             span_note!(cx.tcx.sess, span,\n                        \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n                         to force the compiler to allow this\");"}, {"sha": "9ec0407b5c3fc48e2c2aa9f39b258dd73f674028", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 110, "deletions": 34, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -53,7 +53,10 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::build::*;\n+use middle::trans::cleanup;\n+use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::machine;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n@@ -83,8 +86,12 @@ pub enum Repr {\n     /**\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n+     *\n+     * Types with destructors need a dynamic destroyedness flag to\n+     * avoid running the destructor too many times; the last argument\n+     * indicates whether such a flag is present.\n      */\n-    General(IntType, Vec<Struct>),\n+    General(IntType, Vec<Struct>, bool),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` must have single field which is known to be nonnull due to its type.\n@@ -121,7 +128,7 @@ pub struct Struct {\n     pub size: u64,\n     pub align: u64,\n     pub packed: bool,\n-    pub fields: Vec<ty::t>,\n+    pub fields: Vec<ty::t>\n }\n \n /**\n@@ -173,14 +180,17 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n             let hint = ty::lookup_repr_hint(cx.tcx(), def_id);\n \n+            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n+\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                return Univariant(mk_struct(cx, [], false), false);\n+                let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n             }\n \n-            if cases.iter().all(|c| c.tys.len() == 0) {\n+            if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs: Vec<u64> = cases.iter().map(|c| c.discr).collect();\n                 let bounds = IntBounds {\n@@ -199,20 +209,19 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id)).as_slice())\n+                                                        def_id)).as_slice());\n             }\n \n             if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                return Univariant(mk_struct(cx,\n-                                            cases.get(0).tys.as_slice(),\n-                                            false),\n-                                  false)\n+                let mut ftys = cases.get(0).tys.clone();\n+                if dtor { ftys.push(ty::mk_bool()); }\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n             }\n \n-            if cases.len() == 2 && hint == attr::ReprAny {\n+            if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n@@ -246,10 +255,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n+\n             return General(ity, cases.iter().map(|c| {\n-                let discr = vec!(ty_of_inttype(ity));\n-                mk_struct(cx, discr.append(c.tys.as_slice()).as_slice(), false)\n-            }).collect())\n+                let mut ftys = vec!(ty_of_inttype(ity)).append(c.tys.as_slice());\n+                if dtor { ftys.push(ty::mk_bool()); }\n+                mk_struct(cx, ftys.as_slice(), false)\n+            }).collect(), dtor);\n         }\n         _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n     }\n@@ -359,7 +370,6 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-\n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n     let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n@@ -499,7 +509,7 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n             }\n         }\n-        General(ity, ref sts) => {\n+        General(ity, ref sts, _) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -584,7 +594,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = load_discr(bcx, ity, scrutinee, min, max);\n             signed = ity.is_signed();\n         }\n-        General(ity, ref cases) => {\n+        General(ity, ref cases, _) => {\n             let ptr = GEPi(bcx, scrutinee, [0, 0]);\n             val = load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr);\n             signed = ity.is_signed();\n@@ -658,7 +668,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n             _match::single_result(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n                                                               discr as u64, true)))\n         }\n-        General(ity, _) => {\n+        General(ity, _, _) => {\n             _match::single_result(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n                                                               discr as u64, true)))\n         }\n@@ -684,17 +694,21 @@ pub fn trans_set_discr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n                   val)\n         }\n-        General(ity, _) => {\n+        General(ity, ref cases, dtor) => {\n+            if dtor {\n+                let ptr = trans_field_ptr(bcx, r, val, discr,\n+                                          cases.get(discr as uint).fields.len() - 2);\n+                Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n+            }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n                   GEPi(bcx, val, [0, 0]))\n         }\n-        Univariant(ref st, true) => {\n-            assert_eq!(discr, 0);\n-            Store(bcx, C_u8(bcx.ccx(), 1),\n-                  GEPi(bcx, val, [0, st.fields.len() - 1]))\n-        }\n-        Univariant(..) => {\n+        Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n+            if dtor {\n+                Store(bcx, C_u8(bcx.ccx(), 1),\n+                    GEPi(bcx, val, [0, st.fields.len() - 1]));\n+            }\n         }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n@@ -737,7 +751,9 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n+        General(_, ref cases, dtor) => {\n+            cases.get(discr as uint).fields.len() - 1 - (if dtor { 1 } else { 0 })\n+        }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n         }\n@@ -762,7 +778,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             assert_eq!(discr, 0);\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n-        General(_, ref cases) => {\n+        General(_, ref cases, _) => {\n             struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n@@ -788,11 +804,10 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n-              needs_cast: bool) -> ValueRef {\n-    let ccx = bcx.ccx();\n-\n+pub fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef,\n+                        ix: uint, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n+        let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n@@ -803,10 +818,71 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n     GEPi(bcx, val, [0, ix])\n }\n \n+pub fn fold_variants<'r, 'b>(\n+    bcx: &'b Block<'b>, r: &Repr, value: ValueRef,\n+    f: |&'b Block<'b>, &Struct, ValueRef|: 'r -> &'b Block<'b>\n+) -> &'b Block<'b> {\n+    let fcx = bcx.fcx;\n+    match *r {\n+        Univariant(ref st, _) => {\n+            f(bcx, st, value)\n+        }\n+        General(ity, ref cases, _) => {\n+            let ccx = bcx.ccx();\n+            let unr_cx = fcx.new_temp_block(\"enum-variant-iter-unr\");\n+            Unreachable(unr_cx);\n+\n+            let discr_val = trans_get_discr(bcx, r, value, None);\n+            let llswitch = Switch(bcx, discr_val, unr_cx.llbb, cases.len());\n+            let bcx_next = fcx.new_temp_block(\"enum-variant-iter-next\");\n+\n+            for (discr, case) in cases.iter().enumerate() {\n+                let mut variant_cx = fcx.new_temp_block(\n+                    format!(\"enum-variant-iter-{}\", discr.to_string()).as_slice()\n+                );\n+                let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n+                AddCase(llswitch, rhs_val, variant_cx.llbb);\n+\n+                let fields = case.fields.iter().map(|&ty|\n+                    type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n+                let real_ty = Type::struct_(ccx, fields.as_slice(), case.packed);\n+                let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n+\n+                variant_cx = f(variant_cx, case, variant_value);\n+                Br(variant_cx, bcx_next.llbb);\n+            }\n+\n+            bcx_next\n+        }\n+        _ => unreachable!()\n+    }\n+}\n+\n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr(bcx: &Block, r: &Repr, val: ValueRef) -> ValueRef {\n+pub fn trans_drop_flag_ptr<'b>(mut bcx: &'b Block<'b>, r: &Repr,\n+                               val: ValueRef) -> datum::DatumBlock<'b, datum::Expr> {\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n-        Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n+        Univariant(ref st, true) => {\n+            let flag_ptr = GEPi(bcx, val, [0, st.fields.len() - 1]);\n+            datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n+        }\n+        General(_, _, true) => {\n+            let fcx = bcx.fcx;\n+            let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+            let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n+                bcx, ty::mk_bool(), \"drop_flag\", false,\n+                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n+            ));\n+            bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n+                let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n+                datum::Datum::new(ptr, ptr_ty, datum::Rvalue::new(datum::ByRef))\n+                    .store_to(variant_cx, scratch.val)\n+            });\n+            let expr_datum = scratch.to_expr_datum();\n+            fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+            datum::DatumBlock::new(bcx, expr_datum)\n+        }\n         _ => bcx.ccx().sess().bug(\"tried to get drop flag of non-droppable type\")\n     }\n }\n@@ -840,7 +916,7 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             assert_discr_in_range(ity, min, max, discr);\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n-        General(ity, ref cases) => {\n+        General(ity, ref cases, _) => {\n             let case = cases.get(discr as uint);\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n@@ -964,7 +1040,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n                 attr::UnsignedInt(..) => const_to_uint(val) as Disr\n             }\n         }\n-        General(ity, _) => {\n+        General(ity, _, _) => {\n             match ity {\n                 attr::SignedInt(..) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n                 attr::UnsignedInt(..) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr"}, {"sha": "dbdb99d3ccd942d78f4f9a6afdf68bb1b9fd8a13", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -1856,7 +1856,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n \n     let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n     match *avar {\n-        adt::General(_, ref variants) => {\n+        adt::General(_, ref variants, _) => {\n             for var in variants.iter() {\n                 let mut size = 0;\n                 for field in var.fields.iter().skip(1) {"}, {"sha": "66722b2c4dbdaf6dbc786c47b973c226bb1ecd37", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -1993,7 +1993,7 @@ struct EnumMemberDescriptionFactory {\n impl EnumMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n         match *self.type_rep {\n-            adt::General(_, ref struct_defs) => {\n+            adt::General(_, ref struct_defs, _) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n \n@@ -2362,7 +2362,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::RawNullablePointer { .. }           |\n         adt::StructWrappedNullablePointer { .. } |\n         adt::Univariant(..)                      => None,\n-        adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n+        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);"}, {"sha": "2d2e5f141a5d10dddd2a9915f1632e71e57b9b54", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -204,16 +204,16 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n+fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n                               t: ty::t,\n                               v0: ValueRef,\n                               dtor_did: ast::DefId,\n                               class_did: ast::DefId,\n                               substs: &subst::Substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n-    with_cond(bcx, load_ty(bcx, drop_flag, ty::mk_bool()), |cx| {\n+    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, v0));\n+    with_cond(bcx, load_ty(bcx, drop_flag.val, ty::mk_bool()), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n@@ -237,33 +237,33 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n         ty.element_type().func_params()\n     };\n \n-    // Class dtors have no explicit args, so the params should\n-    // just consist of the environment (self)\n-    assert_eq!(params.len(), 1);\n-\n-    // Be sure to put all of the fields into a scope so we can use an invoke\n-    // instruction to call the user destructor but still call the field\n-    // destructors if the user destructor fails.\n-    let field_scope = bcx.fcx.push_custom_cleanup_scope();\n-\n-    let self_arg = PointerCast(bcx, v0, *params.get(0));\n-    let args = vec!(self_arg);\n-\n-    // Add all the fields as a value which needs to be cleaned at the end of\n-    // this scope.\n-    let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-    for (i, fld) in field_tys.iter().enumerate() {\n-        let llfld_a = adt::trans_field_ptr(bcx, &*repr, v0, 0, i);\n-        bcx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n-                                  llfld_a,\n-                                  fld.mt.ty);\n-    }\n+    adt::fold_variants(bcx, &*repr, v0, |variant_cx, st, value| {\n+        // Be sure to put all of the fields into a scope so we can use an invoke\n+        // instruction to call the user destructor but still call the field\n+        // destructors if the user destructor fails.\n+        let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n+\n+        // Class dtors have no explicit args, so the params should\n+        // just consist of the environment (self).\n+        assert_eq!(params.len(), 1);\n+        let self_arg = PointerCast(variant_cx, value, *params.get(0));\n+        let args = vec!(self_arg);\n+\n+        // Add all the fields as a value which needs to be cleaned at the end of\n+        // this scope.\n+        for (i, ty) in st.fields.iter().enumerate() {\n+            let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n+            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n+                                             llfld_a, *ty);\n+        }\n \n-    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), ast::DUMMY_NODE_ID,\n-                                 [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n-    let (_, bcx) = invoke(bcx, dtor_addr, args, dtor_ty, None);\n+        let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n+                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None);\n \n-    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, field_scope)\n+        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n+        variant_cx\n+    })\n }\n \n fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n@@ -317,7 +317,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n-        ty::ty_struct(did, ref substs) => {\n+        ty::ty_struct(did, ref substs) | ty::ty_enum(did, ref substs) => {\n             let tcx = bcx.tcx();\n             match ty::ty_dtor(tcx, did) {\n                 ty::TraitDtor(dtor, true) => {"}, {"sha": "4dfd15fe13619d7cd15356fdf162017c238b5b3f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -2106,13 +2106,16 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n-                let res =\n+                let mut res =\n                     TypeContents::union(variants.as_slice(), |variant| {\n                         TypeContents::union(variant.args.as_slice(),\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n+                if ty::has_dtor(cx, did) {\n+                    res = res | TC::OwnsDtor;\n+                }\n                 apply_lang_items(cx, did, res)\n             }\n \n@@ -3778,17 +3781,13 @@ pub enum DtorKind {\n }\n \n impl DtorKind {\n-    pub fn is_not_present(&self) -> bool {\n+    pub fn is_present(&self) -> bool {\n         match *self {\n-            NoDtor => true,\n+            TraitDtor(..) => true,\n             _ => false\n         }\n     }\n \n-    pub fn is_present(&self) -> bool {\n-        !self.is_not_present()\n-    }\n-\n     pub fn has_drop_flag(&self) -> bool {\n         match self {\n             &NoDtor => false,"}, {"sha": "44fe2607fcc259d07e8f0ebdf593ba0010c6acb3", "filename": "src/test/compile-fail/kindck-destructor-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -17,7 +17,7 @@ struct Foo {\n }\n \n impl Drop for Foo {\n-    //~^ ERROR cannot implement a destructor on a structure that does not satisfy Send\n+//~^ ERROR cannot implement a destructor on a structure or enumeration that does not satisfy Send\n     fn drop(&mut self) {\n     }\n }"}, {"sha": "977eaa13fc108e03b53901b11ee55a5602c1b657", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+use std::task;\n+\n+#[deriving(PartialEq, Show)]\n+enum Message {\n+    Dropped,\n+    DestructorRan\n+}\n+\n+struct SendOnDrop {\n+    sender: Sender<Message>\n+}\n+\n+impl Drop for SendOnDrop {\n+    fn drop(&mut self) {\n+        self.sender.send(Dropped);\n+    }\n+}\n+\n+enum Foo {\n+    SimpleVariant(Sender<Message>),\n+    NestedVariant(Box<uint>, SendOnDrop, Sender<Message>),\n+    FailingVariant { on_drop: SendOnDrop }\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        match self {\n+            &SimpleVariant(ref mut sender) => {\n+                sender.send(DestructorRan);\n+            }\n+            &NestedVariant(_, _, ref mut sender) => {\n+                sender.send(DestructorRan);\n+            }\n+            &FailingVariant { .. } => {\n+                fail!(\"Failed\");\n+            }\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let (sender, receiver) = channel();\n+    {\n+        let v = SimpleVariant(sender);\n+    }\n+    assert_eq!(receiver.recv(), DestructorRan);\n+    assert_eq!(receiver.recv_opt().ok(), None);\n+\n+    let (sender, receiver) = channel();\n+    {\n+        let v = NestedVariant(box 42u, SendOnDrop { sender: sender.clone() }, sender);\n+    }\n+    assert_eq!(receiver.recv(), DestructorRan);\n+    assert_eq!(receiver.recv(), Dropped);\n+    assert_eq!(receiver.recv_opt().ok(), None);\n+\n+    let (sender, receiver) = channel();\n+    task::spawn(proc() {\n+        let v = FailingVariant { on_drop: SendOnDrop { sender: sender } };\n+    });\n+    assert_eq!(receiver.recv(), Dropped);\n+    assert_eq!(receiver.recv_opt().ok(), None);\n+\n+    let (sender, receiver) = channel();\n+    {\n+        task::spawn(proc() {\n+            let mut v = NestedVariant(box 42u, SendOnDrop {\n+                sender: sender.clone()\n+            }, sender.clone());\n+            v = NestedVariant(box 42u, SendOnDrop { sender: sender.clone() }, sender.clone());\n+            v = SimpleVariant(sender.clone());\n+            v = FailingVariant { on_drop: SendOnDrop { sender: sender } };\n+        });\n+    }\n+    assert_eq!(receiver.recv(), DestructorRan);\n+    assert_eq!(receiver.recv(), Dropped);\n+    assert_eq!(receiver.recv(), DestructorRan);\n+    assert_eq!(receiver.recv(), Dropped);\n+    assert_eq!(receiver.recv(), DestructorRan);\n+    assert_eq!(receiver.recv(), Dropped);\n+    assert_eq!(receiver.recv_opt().ok(), None);\n+}"}, {"sha": "f8c54fbab8a4ec876a9ecef76ba4f7ee5c0a59a5", "filename": "src/test/run-pass/drop-uninhabited-enum.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fdrop-uninhabited-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fdrop-uninhabited-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-uninhabited-enum.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo { }\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) { }\n+}\n+\n+fn foo(x: Foo) { }\n+\n+fn main() { }"}, {"sha": "4fda506ae64b665c08c635f518a8ce1c89feb71a", "filename": "src/test/run-pass/issue-10802.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fissue-10802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10802.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n struct DroppableStruct;\n+enum DroppableEnum {\n+    DroppableVariant1, DroppableVariant2\n+}\n \n static mut DROPPED: bool = false;\n \n@@ -18,9 +20,15 @@ impl Drop for DroppableStruct {\n         unsafe { DROPPED = true; }\n     }\n }\n+impl Drop for DroppableEnum {\n+    fn drop(&mut self) {\n+        unsafe { DROPPED = true; }\n+    }\n+}\n \n trait MyTrait { }\n impl MyTrait for Box<DroppableStruct> {}\n+impl MyTrait for Box<DroppableEnum> {}\n \n struct Whatever { w: Box<MyTrait> }\n impl  Whatever {\n@@ -35,4 +43,10 @@ fn main() {\n         let _a = Whatever::new(box f as Box<MyTrait>);\n     }\n     assert!(unsafe { DROPPED });\n+    unsafe { DROPPED = false; }\n+    {\n+        let f = box DroppableVariant1;\n+        let _a = Whatever::new(box f as Box<MyTrait>);\n+    }\n+    assert!(unsafe { DROPPED });\n }"}, {"sha": "462a78a5368f8dad51eb438072153699ad6f7f44", "filename": "src/test/run-pass/issue-6892.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fissue-6892.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f1fbfc861cd6da41746f899bad79b37f471ab/src%2Ftest%2Frun-pass%2Fissue-6892.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6892.rs?ref=217f1fbfc861cd6da41746f899bad79b37f471ab", "patch": "@@ -14,6 +14,7 @@\n struct Foo;\n struct Bar { x: int }\n struct Baz(int);\n+enum FooBar { _Foo(Foo), _Bar(uint) }\n \n static mut NUM_DROPS: uint = 0;\n \n@@ -32,6 +33,11 @@ impl Drop for Baz {\n         unsafe { NUM_DROPS += 1; }\n     }\n }\n+impl Drop for FooBar {\n+    fn drop(&mut self) {\n+        unsafe { NUM_DROPS += 1; }\n+    }\n+}\n \n fn main() {\n     assert_eq!(unsafe { NUM_DROPS }, 0);\n@@ -41,12 +47,19 @@ fn main() {\n     assert_eq!(unsafe { NUM_DROPS }, 2);\n     { let _x = Baz(21); }\n     assert_eq!(unsafe { NUM_DROPS }, 3);\n+    { let _x = _Foo(Foo); }\n+    assert_eq!(unsafe { NUM_DROPS }, 5);\n+    { let _x = _Bar(42u); }\n+    assert_eq!(unsafe { NUM_DROPS }, 6);\n \n-    assert_eq!(unsafe { NUM_DROPS }, 3);\n     { let _ = Foo; }\n-    assert_eq!(unsafe { NUM_DROPS }, 4);\n+    assert_eq!(unsafe { NUM_DROPS }, 7);\n     { let _ = Bar { x: 21 }; }\n-    assert_eq!(unsafe { NUM_DROPS }, 5);\n+    assert_eq!(unsafe { NUM_DROPS }, 8);\n     { let _ = Baz(21); }\n-    assert_eq!(unsafe { NUM_DROPS }, 6);\n+    assert_eq!(unsafe { NUM_DROPS }, 9);\n+    { let _ = _Foo(Foo); }\n+    assert_eq!(unsafe { NUM_DROPS }, 11);\n+    { let _ = _Bar(42u); }\n+    assert_eq!(unsafe { NUM_DROPS }, 12);\n }"}]}