{"sha": "574d37568029f5c637557a87426ade54770d9a14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-07T20:43:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-07T20:43:25Z"}, "message": "Auto merge of #87743 - cuviper:opaque-calls, r=nikic\n\nPrepare call/invoke for opaque pointers\n\nRather than relying on `getPointerElementType()` from LLVM function\npointers, we now pass the function type explicitly when building `call`\nor `invoke` instructions.", "tree": {"sha": "0c36b728b150682f3b4825f5eb7434fc5b890eb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c36b728b150682f3b4825f5eb7434fc5b890eb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/574d37568029f5c637557a87426ade54770d9a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/574d37568029f5c637557a87426ade54770d9a14", "html_url": "https://github.com/rust-lang/rust/commit/574d37568029f5c637557a87426ade54770d9a14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/574d37568029f5c637557a87426ade54770d9a14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "399ab4601b2d4087787659af72f6c3b373ef7baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/399ab4601b2d4087787659af72f6c3b373ef7baf", "html_url": "https://github.com/rust-lang/rust/commit/399ab4601b2d4087787659af72f6c3b373ef7baf"}, {"sha": "a29239085455964176ab0ad59b097da725813f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a29239085455964176ab0ad59b097da725813f6f", "html_url": "https://github.com/rust-lang/rust/commit/a29239085455964176ab0ad59b097da725813f6f"}], "stats": {"total": 316, "additions": 168, "deletions": 148}, "files": [{"sha": "abf0ea8cc0a65b05c4329b1312e507a17eb2a698", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -353,7 +353,11 @@ pub trait FnAbiLlvmExt<'tcx> {\n \n impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n-        let args_capacity: usize = self.args.iter().map(|arg|\n+        // Ignore \"extra\" args from the call site for C variadic functions.\n+        // Only the \"fixed\" args are part of the LLVM function signature.\n+        let args = if self.c_variadic { &self.args[..self.fixed_count] } else { &self.args };\n+\n+        let args_capacity: usize = args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n@@ -371,7 +375,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             }\n         };\n \n-        for arg in &self.args {\n+        for arg in args {\n             // add padding\n             if let Some(ty) = arg.pad {\n                 llargument_tys.push(ty.llvm_type(cx));"}, {"sha": "2d79b73cf9f519e921d2c50626c5228b093ae700", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -78,8 +78,14 @@ pub(crate) unsafe fn codegen(\n             .enumerate()\n             .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n             .collect::<Vec<_>>();\n-        let ret =\n-            llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n+        let ret = llvm::LLVMRustBuildCall(\n+            llbuilder,\n+            ty,\n+            callee,\n+            args.as_ptr(),\n+            args.len() as c_uint,\n+            None,\n+        );\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n             llvm::LLVMBuildRet(llbuilder, ret);\n@@ -121,7 +127,8 @@ pub(crate) unsafe fn codegen(\n         .enumerate()\n         .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n         .collect::<Vec<_>>();\n-    let ret = llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n+    let ret =\n+        llvm::LLVMRustBuildCall(llbuilder, ty, callee, args.as_ptr(), args.len() as c_uint, None);\n     llvm::LLVMSetTailCall(ret, True);\n     llvm::LLVMBuildRetVoid(llbuilder);\n     llvm::LLVMDisposeBuilder(llbuilder);"}, {"sha": "ebc3773df57cd7fd84b1bbce79876ce3142a64b2", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -464,7 +464,7 @@ fn inline_asm_call(\n                 alignstack,\n                 llvm::AsmDialect::from_generic(dia),\n             );\n-            let call = bx.call(v, inputs, None);\n+            let call = bx.call(fty, v, inputs, None);\n \n             // Store mark in a metadata node so we can map LLVM errors\n             // back to source locations.  See #17552."}, {"sha": "2139f9776b736192edc8c391b667ad1c23a3a047", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -200,6 +200,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn invoke(\n         &mut self,\n+        llty: &'ll Type,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         then: &'ll BasicBlock,\n@@ -208,13 +209,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         debug!(\"invoke {:?} with args ({:?})\", llfn, args);\n \n-        let args = self.check_call(\"invoke\", llfn, args);\n+        let args = self.check_call(\"invoke\", llty, llfn, args);\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr(),\n                 args.len() as c_uint,\n@@ -369,8 +371,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n         };\n \n-        let intrinsic = self.get_intrinsic(&name);\n-        let res = self.call(intrinsic, &[lhs, rhs], None);\n+        let res = self.call_intrinsic(name, &[lhs, rhs]);\n         (self.extract_value(res, 0), self.extract_value(res, 1))\n     }\n \n@@ -695,8 +696,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n             let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n-            let intrinsic = self.get_intrinsic(&name);\n-            return Some(self.call(intrinsic, &[val], None));\n+            return Some(self.call_intrinsic(&name, &[val]));\n         }\n \n         None\n@@ -708,8 +708,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n             let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n-            let intrinsic = self.get_intrinsic(&name);\n-            return Some(self.call(intrinsic, &[val], None));\n+            return Some(self.call_intrinsic(&name, &[val]));\n         }\n \n         None\n@@ -743,8 +742,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => None,\n                 };\n                 if let Some(name) = name {\n-                    let intrinsic = self.get_intrinsic(name);\n-                    return self.call(intrinsic, &[val], None);\n+                    return self.call_intrinsic(name, &[val]);\n                 }\n             }\n         }\n@@ -766,8 +764,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => None,\n                 };\n                 if let Some(name) = name {\n-                    let intrinsic = self.get_intrinsic(name);\n-                    return self.call(intrinsic, &[val], None);\n+                    return self.call_intrinsic(name, &[val]);\n                 }\n             }\n         }\n@@ -1115,12 +1112,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         );\n \n         let llfn = unsafe { llvm::LLVMRustGetInstrProfIncrementIntrinsic(self.cx().llmod) };\n+        let llty = self.cx.type_func(\n+            &[self.cx.type_i8p(), self.cx.type_i64(), self.cx.type_i32(), self.cx.type_i32()],\n+            self.cx.type_void(),\n+        );\n         let args = &[fn_name, hash, num_counters, index];\n-        let args = self.check_call(\"call\", llfn, args);\n+        let args = self.check_call(\"call\", llty, llfn, args);\n \n         unsafe {\n             let _ = llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n@@ -1131,19 +1133,21 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn call(\n         &mut self,\n+        llty: &'ll Type,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n         debug!(\"call {:?} with args ({:?})\", llfn, args);\n \n-        let args = self.check_call(\"call\", llfn, args);\n+        let args = self.check_call(\"call\", llty, llfn, args);\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n@@ -1313,15 +1317,10 @@ impl Builder<'a, 'll, 'tcx> {\n     fn check_call<'b>(\n         &mut self,\n         typ: &str,\n+        fn_ty: &'ll Type,\n         llfn: &'ll Value,\n         args: &'b [&'ll Value],\n     ) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = self.cx.val_ty(llfn);\n-        // Strip off pointers\n-        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n-            fn_ty = self.cx.element_type(fn_ty);\n-        }\n-\n         assert!(\n             self.cx.type_kind(fn_ty) == TypeKind::Function,\n             \"builder::{} not passed a function, but {:?}\",\n@@ -1362,6 +1361,11 @@ impl Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n     }\n \n+    crate fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n+        let (ty, f) = self.cx.get_intrinsic(intrinsic);\n+        self.call(ty, f, args, None)\n+    }\n+\n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         let size = size.bytes();\n         if size == 0 {\n@@ -1372,10 +1376,8 @@ impl Builder<'a, 'll, 'tcx> {\n             return;\n         }\n \n-        let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n-\n         let ptr = self.pointercast(ptr, self.cx.type_i8p());\n-        self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n+        self.call_intrinsic(intrinsic, &[self.cx.const_u64(size), ptr]);\n     }\n \n     pub(crate) fn phi("}, {"sha": "685f222e8025f90dc44c81d949b20ac82f20da2f", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -84,9 +84,9 @@ pub struct CodegenCx<'ll, 'tcx> {\n \n     eh_personality: Cell<Option<&'ll Value>>,\n     eh_catch_typeinfo: Cell<Option<&'ll Value>>,\n-    pub rust_try_fn: Cell<Option<&'ll Value>>,\n+    pub rust_try_fn: Cell<Option<(&'ll Type, &'ll Value)>>,\n \n-    intrinsics: RefCell<FxHashMap<&'static str, &'ll Value>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, (&'ll Type, &'ll Value)>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -452,7 +452,7 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl CodegenCx<'b, 'tcx> {\n-    crate fn get_intrinsic(&self, key: &str) -> &'b Value {\n+    crate fn get_intrinsic(&self, key: &str) -> (&'b Type, &'b Value) {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -465,18 +465,18 @@ impl CodegenCx<'b, 'tcx> {\n         name: &'static str,\n         args: Option<&[&'b llvm::Type]>,\n         ret: &'b llvm::Type,\n-    ) -> &'b llvm::Value {\n+    ) -> (&'b llvm::Type, &'b llvm::Value) {\n         let fn_ty = if let Some(args) = args {\n             self.type_func(args, ret)\n         } else {\n             self.type_variadic_func(&[], ret)\n         };\n         let f = self.declare_cfn(name, llvm::UnnamedAddr::No, fn_ty);\n-        self.intrinsics.borrow_mut().insert(name, f);\n-        f\n+        self.intrinsics.borrow_mut().insert(name, (fn_ty, f));\n+        (fn_ty, f)\n     }\n \n-    fn declare_intrinsic(&self, key: &str) -> Option<&'b Value> {\n+    fn declare_intrinsic(&self, key: &str) -> Option<(&'b Type, &'b Value)> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {"}, {"sha": "ed4841858651749e613e83abc9516bf496ab7d42", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 80, "deletions": 94, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::{Abi, FnAbi, LlvmType, PassMode};\n+use crate::abi::{Abi, FnAbi, FnAbiLlvmExt, LlvmType, PassMode};\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm;\n@@ -24,7 +24,7 @@ use rustc_target::spec::PanicStrategy;\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Value> {\n+fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<(&'ll Type, &'ll Value)> {\n     let llvm_name = match name {\n         sym::sqrtf32 => \"llvm.sqrt.f32\",\n         sym::sqrtf64 => \"llvm.sqrt.f64\",\n@@ -102,19 +102,20 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let simple = get_simple_intrinsic(self, name);\n         let llval = match name {\n-            _ if simple.is_some() => self.call(\n-                simple.unwrap(),\n-                &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-                None,\n-            ),\n-            sym::likely => {\n-                let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n-                self.call(expect, &[args[0].immediate(), self.const_bool(true)], None)\n+            _ if simple.is_some() => {\n+                let (simple_ty, simple_fn) = simple.unwrap();\n+                self.call(\n+                    simple_ty,\n+                    simple_fn,\n+                    &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                    None,\n+                )\n             }\n-            sym::unlikely => {\n-                let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n-                self.call(expect, &[args[0].immediate(), self.const_bool(false)], None)\n+            sym::likely => {\n+                self.call_intrinsic(\"llvm.expect.i1\", &[args[0].immediate(), self.const_bool(true)])\n             }\n+            sym::unlikely => self\n+                .call_intrinsic(\"llvm.expect.i1\", &[args[0].immediate(), self.const_bool(false)]),\n             kw::Try => {\n                 try_intrinsic(\n                     self,\n@@ -125,13 +126,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            sym::breakpoint => {\n-                let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n-                self.call(llfn, &[], None)\n-            }\n+            sym::breakpoint => self.call_intrinsic(\"llvm.debugtrap\", &[]),\n             sym::va_copy => {\n-                let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n-                self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n+                self.call_intrinsic(\"llvm.va_copy\", &[args[0].immediate(), args[1].immediate()])\n             }\n             sym::va_arg => {\n                 match fn_abi.ret.layout.abi {\n@@ -194,23 +191,21 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             | sym::prefetch_write_data\n             | sym::prefetch_read_instruction\n             | sym::prefetch_write_instruction => {\n-                let expect = self.get_intrinsic(&(\"llvm.prefetch\"));\n                 let (rw, cache_type) = match name {\n                     sym::prefetch_read_data => (0, 1),\n                     sym::prefetch_write_data => (1, 1),\n                     sym::prefetch_read_instruction => (0, 0),\n                     sym::prefetch_write_instruction => (1, 0),\n                     _ => bug!(),\n                 };\n-                self.call(\n-                    expect,\n+                self.call_intrinsic(\n+                    \"llvm.prefetch\",\n                     &[\n                         args[0].immediate(),\n                         self.const_i32(rw),\n                         args[1].immediate(),\n                         self.const_i32(cache_type),\n                     ],\n-                    None,\n                 )\n             }\n             sym::ctlz\n@@ -229,35 +224,33 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     Some((width, signed)) => match name {\n                         sym::ctlz | sym::cttz => {\n                             let y = self.const_bool(false);\n-                            let llfn = self.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            self.call(llfn, &[args[0].immediate(), y], None)\n+                            self.call_intrinsic(\n+                                &format!(\"llvm.{}.i{}\", name, width),\n+                                &[args[0].immediate(), y],\n+                            )\n                         }\n                         sym::ctlz_nonzero | sym::cttz_nonzero => {\n                             let y = self.const_bool(true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name_str[..4], width);\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[args[0].immediate(), y], None)\n+                            self.call_intrinsic(llvm_name, &[args[0].immediate(), y])\n                         }\n-                        sym::ctpop => self.call(\n-                            self.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n+                        sym::ctpop => self.call_intrinsic(\n+                            &format!(\"llvm.ctpop.i{}\", width),\n                             &[args[0].immediate()],\n-                            None,\n                         ),\n                         sym::bswap => {\n                             if width == 8 {\n                                 args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n-                                self.call(\n-                                    self.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n+                                self.call_intrinsic(\n+                                    &format!(\"llvm.bswap.i{}\", width),\n                                     &[args[0].immediate()],\n-                                    None,\n                                 )\n                             }\n                         }\n-                        sym::bitreverse => self.call(\n-                            self.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n+                        sym::bitreverse => self.call_intrinsic(\n+                            &format!(\"llvm.bitreverse.i{}\", width),\n                             &[args[0].immediate()],\n-                            None,\n                         ),\n                         sym::rotate_left | sym::rotate_right => {\n                             let is_left = name == sym::rotate_left;\n@@ -266,8 +259,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             // rotate = funnel shift with first two args the same\n                             let llvm_name =\n                                 &format!(\"llvm.fsh{}.i{}\", if is_left { 'l' } else { 'r' }, width);\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[val, val, raw_shift], None)\n+                            self.call_intrinsic(llvm_name, &[val, val, raw_shift])\n                         }\n                         sym::saturating_add | sym::saturating_sub => {\n                             let is_add = name == sym::saturating_add;\n@@ -279,8 +271,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                                 if is_add { \"add\" } else { \"sub\" },\n                                 width\n                             );\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[lhs, rhs], None)\n+                            self.call_intrinsic(llvm_name, &[lhs, rhs])\n                         }\n                         _ => bug!(),\n                     },\n@@ -331,8 +322,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     let a_ptr = self.bitcast(a, i8p_ty);\n                     let b_ptr = self.bitcast(b, i8p_ty);\n                     let n = self.const_usize(layout.size.bytes());\n-                    let llfn = self.get_intrinsic(\"memcmp\");\n-                    let cmp = self.call(llfn, &[a_ptr, b_ptr, n], None);\n+                    let cmp = self.call_intrinsic(\"memcmp\", &[a_ptr, b_ptr, n]);\n                     self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n                 }\n             }\n@@ -361,38 +351,32 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn abort(&mut self) {\n-        let fnname = self.get_intrinsic(&(\"llvm.trap\"));\n-        self.call(fnname, &[], None);\n+        self.call_intrinsic(\"llvm.trap\", &[]);\n     }\n \n     fn assume(&mut self, val: Self::Value) {\n-        let assume_intrinsic = self.get_intrinsic(\"llvm.assume\");\n-        self.call(assume_intrinsic, &[val], None);\n+        self.call_intrinsic(\"llvm.assume\", &[val]);\n     }\n \n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value {\n-        let expect = self.get_intrinsic(&\"llvm.expect.i1\");\n-        self.call(expect, &[cond, self.const_bool(expected)], None)\n+        self.call_intrinsic(\"llvm.expect.i1\", &[cond, self.const_bool(expected)])\n     }\n \n     fn sideeffect(&mut self) {\n         // This kind of check would make a ton of sense in the caller, but currently the only\n         // caller of this function is in `rustc_codegen_ssa`, which is agnostic to whether LLVM\n         // codegen backend being used, and so is unable to check the LLVM version.\n         if unsafe { llvm::LLVMRustVersionMajor() } < 12 {\n-            let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n-            self.call(fnname, &[], None);\n+            self.call_intrinsic(\"llvm.sideeffect\", &[]);\n         }\n     }\n \n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n-        let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n-        self.call(intrinsic, &[va_list], None)\n+        self.call_intrinsic(\"llvm.va_start\", &[va_list])\n     }\n \n     fn va_end(&mut self, va_list: &'ll Value) -> &'ll Value {\n-        let intrinsic = self.cx().get_intrinsic(\"llvm.va_end\");\n-        self.call(intrinsic, &[va_list], None)\n+        self.call_intrinsic(\"llvm.va_end\", &[va_list])\n     }\n }\n \n@@ -404,7 +388,8 @@ fn try_intrinsic(\n     dest: &'ll Value,\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(try_func, &[data], None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.call(try_func_ty, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -432,7 +417,7 @@ fn codegen_msvc_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n@@ -502,7 +487,8 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n-        bx.invoke(try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n@@ -544,22 +530,23 @@ fn codegen_msvc_try(\n         let flags = bx.const_i32(8);\n         let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n-        catchpad_rust.call(catch_func, &[data, ptr], Some(&funclet));\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catchpad_rust.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n         catchpad_rust.catch_ret(&funclet, caught.llbb());\n \n         // The flag value of 64 indicates a \"catch-all\".\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n-        catchpad_foreign.call(catch_func, &[data, null], Some(&funclet));\n+        catchpad_foreign.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n         catchpad_foreign.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -582,7 +569,7 @@ fn codegen_gnu_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n@@ -601,7 +588,8 @@ fn codegen_gnu_try(\n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -615,13 +603,14 @@ fn codegen_gnu_try(\n         let tydesc = bx.const_null(bx.type_i8p());\n         catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n-        catch.call(catch_func, &[data, ptr], None);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catch.call(catch_ty, catch_func, &[data, ptr], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -636,7 +625,7 @@ fn codegen_emcc_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n@@ -660,7 +649,8 @@ fn codegen_emcc_try(\n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -677,8 +667,7 @@ fn codegen_emcc_try(\n         let selector = catch.extract_value(vals, 1);\n \n         // Check if the typeid we got is the one for a Rust panic.\n-        let llvm_eh_typeid_for = bx.get_intrinsic(\"llvm.eh.typeid.for\");\n-        let rust_typeid = catch.call(llvm_eh_typeid_for, &[tydesc], None);\n+        let rust_typeid = catch.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n         let is_rust_panic = catch.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n         let is_rust_panic = catch.zext(is_rust_panic, bx.type_bool());\n \n@@ -702,13 +691,14 @@ fn codegen_emcc_try(\n         catch.store(is_rust_panic, catch_data_1, i8_align);\n         let catch_data = catch.bitcast(catch_data, bx.type_i8p());\n \n-        catch.call(catch_func, &[data, catch_data], None);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catch.call(catch_ty, catch_func, &[data, catch_data], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -720,8 +710,9 @@ fn gen_fn<'ll, 'tcx>(\n     name: &str,\n     rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> &'ll Value {\n+) -> (&'ll Type, &'ll Value) {\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n+    let llty = fn_abi.llvm_type(cx);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_type(llfn);\n     cx.apply_target_cpu_attr(llfn);\n@@ -730,7 +721,7 @@ fn gen_fn<'ll, 'tcx>(\n     let llbb = Builder::append_block(cx, llfn, \"entry-block\");\n     let bx = Builder::build(cx, llbb);\n     codegen(bx);\n-    llfn\n+    (llty, llfn)\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n@@ -740,7 +731,7 @@ fn gen_fn<'ll, 'tcx>(\n fn get_rust_try_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> &'ll Value {\n+) -> (&'ll Type, &'ll Value) {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n@@ -1123,7 +1114,8 @@ fn generic_simd_intrinsic(\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n-        let c = bx.call(f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c =\n+            bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n     }\n \n@@ -1300,15 +1292,13 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic =\n             format!(\"llvm.masked.gather.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(\n-                &[llvm_pointer_vec_ty, alignment_ty, mask_ty, llvm_elem_vec_ty],\n-                llvm_elem_vec_ty,\n-            ),\n+        let fn_ty = bx.type_func(\n+            &[llvm_pointer_vec_ty, alignment_ty, mask_ty, llvm_elem_vec_ty],\n+            llvm_elem_vec_ty,\n         );\n-        let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v =\n+            bx.call(fn_ty, f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n         return Ok(v);\n     }\n \n@@ -1430,12 +1420,11 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic =\n             format!(\"llvm.masked.scatter.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t),\n-        );\n-        let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n+        let fn_ty =\n+            bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v =\n+            bx.call(fn_ty, f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n         return Ok(v);\n     }\n \n@@ -1757,12 +1746,9 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         );\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(&[vec_ty, vec_ty], vec_ty),\n-        );\n-        let v = bx.call(f, &[lhs, rhs], None);\n+        let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "57173a49107a53f3cd8d58522daac043f72c92ef", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -1155,6 +1155,7 @@ extern \"C\" {\n     ) -> &'a Value;\n     pub fn LLVMRustBuildInvoke(\n         B: &Builder<'a>,\n+        Ty: &'a Type,\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n@@ -1526,6 +1527,7 @@ extern \"C\" {\n     pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n+        Ty: &'a Type,\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,"}, {"sha": "52ae56b89b33170c671cd82cf5122b126a0bd839", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -203,7 +203,11 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n-        unsafe { llvm::LLVMGetElementType(ty) }\n+        match self.type_kind(ty) {\n+            TypeKind::Array | TypeKind::Vector => unsafe { llvm::LLVMGetElementType(ty) },\n+            TypeKind::Pointer => bug!(\"element_type is not supported for opaque pointers\"),\n+            other => bug!(\"element_type called on unsupported type {:?}\", other),\n+        }\n     }\n \n     fn vector_length(&self, ty: &'ll Type) -> usize {\n@@ -275,6 +279,9 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n+    fn fn_decl_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        fn_abi.llvm_type(self)\n+    }\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n         fn_abi.ptr_to_llvm_type(self)\n     }"}, {"sha": "064a51c8f609086e00e4d4721e246c3a75737a73", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -441,9 +441,11 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n+        let isize_ty = cx.type_isize();\n+        let i8pp_ty = cx.type_ptr_to(cx.type_i8p());\n         let (arg_argc, arg_argv) = get_argc_argv(cx, &mut bx);\n \n-        let (start_fn, args) = if use_start_lang_item {\n+        let (start_fn, start_ty, args) = if use_start_lang_item {\n             let start_def_id = cx.tcx().require_lang_item(LangItem::Start, None);\n             let start_fn = cx.get_fn_addr(\n                 ty::Instance::resolve(\n@@ -455,16 +457,15 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 .unwrap()\n                 .unwrap(),\n             );\n-            (\n-                start_fn,\n-                vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())), arg_argc, arg_argv],\n-            )\n+            let start_ty = cx.type_func(&[cx.val_ty(rust_main), isize_ty, i8pp_ty], isize_ty);\n+            (start_fn, start_ty, vec![rust_main, arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n-            (rust_main, vec![arg_argc, arg_argv])\n+            let start_ty = cx.type_func(&[isize_ty, i8pp_ty], isize_ty);\n+            (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_fn, &args, None);\n+        let result = bx.call(start_ty, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n "}, {"sha": "58ce31e0c4c9d48747a0a9e0d032862e133f87da", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -132,14 +132,21 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n     ) {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n+        let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n         if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n             let ret_llbb = if let Some((_, target)) = destination {\n                 fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret =\n-                bx.invoke(fn_ptr, &llargs, ret_llbb, self.llblock(fx, cleanup), self.funclet(fx));\n+            let invokeret = bx.invoke(\n+                fn_ty,\n+                fn_ptr,\n+                &llargs,\n+                ret_llbb,\n+                self.llblock(fx, cleanup),\n+                self.funclet(fx),\n+            );\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n@@ -148,7 +155,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n-            let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n+            let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, llret);\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline"}, {"sha": "7e432d274022453b7726a5c48df9c1256244f87f", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -518,7 +518,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let r = bx.cx().get_fn_addr(instance);\n-                let call = bx.call(r, &[llsize, llalign], None);\n+                let ty = bx.type_func(&[bx.type_isize(), bx.type_isize()], bx.type_i8p());\n+                let call = bx.call(ty, r, &[llsize, llalign], None);\n                 let val = bx.pointercast(call, llty_ptr);\n \n                 let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };"}, {"sha": "afb8ee3c40d5569169327fe602c1d2bcc54c5093", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -72,6 +72,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     );\n     fn invoke(\n         &mut self,\n+        llty: Self::Type,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n@@ -303,6 +304,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn call(\n         &mut self,\n+        llty: Self::Type,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         funclet: Option<&Self::Funclet>,"}, {"sha": "b94fb1e10db0198386750c06b657ae5e52a940a8", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -102,6 +102,7 @@ impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscM\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n+    fn fn_decl_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;"}, {"sha": "52566b19eca045298e5987abaff628ea470156af", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/574d37568029f5c637557a87426ade54770d9a14/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=574d37568029f5c637557a87426ade54770d9a14", "patch": "@@ -1392,11 +1392,11 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n   delete Bundle;\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n                                           OperandBundleDef *Bundle) {\n   Value *Callee = unwrap(Fn);\n-  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n+  FunctionType *FTy = unwrap<FunctionType>(Ty);\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n@@ -1437,12 +1437,12 @@ extern \"C\" LLVMValueRef LLVMRustBuildMemSet(LLVMBuilderRef B,\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n-                    unsigned NumArgs, LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n-                    const char *Name) {\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n+                    LLVMValueRef *Args, unsigned NumArgs,\n+                    LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,\n+                    OperandBundleDef *Bundle, const char *Name) {\n   Value *Callee = unwrap(Fn);\n-  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n+  FunctionType *FTy = unwrap<FunctionType>(Ty);\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),"}]}