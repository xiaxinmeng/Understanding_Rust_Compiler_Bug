{"sha": "0aca7b78de234526e1d85a4dfd23fb4f374908ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhY2E3Yjc4ZGUyMzQ1MjZlMWQ4NWE0ZGZkMjNmYjRmMzc0OTA4ZWE=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T14:09:47Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T14:23:23Z"}, "message": "do not use associated types placeholder for inlay hint\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "c0b1a4c5e2cd450c2b07cd7e3ef067a35f510365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b1a4c5e2cd450c2b07cd7e3ef067a35f510365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aca7b78de234526e1d85a4dfd23fb4f374908ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aca7b78de234526e1d85a4dfd23fb4f374908ea", "html_url": "https://github.com/rust-lang/rust/commit/0aca7b78de234526e1d85a4dfd23fb4f374908ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aca7b78de234526e1d85a4dfd23fb4f374908ea/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef2f7bb2438e66fd046791bb67849b6c61d946ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f7bb2438e66fd046791bb67849b6c61d946ab", "html_url": "https://github.com/rust-lang/rust/commit/ef2f7bb2438e66fd046791bb67849b6c61d946ab"}], "stats": {"total": 104, "additions": 44, "deletions": 60}, "files": [{"sha": "0bf181a92a6928c0f2321882cc6f1af1d451c715", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=0aca7b78de234526e1d85a4dfd23fb4f374908ea", "patch": "@@ -84,26 +84,17 @@ pub trait HirDisplay {\n     }\n \n     /// Returns a String representation of `self` for test purposes\n-    fn display_test<'a>(\n-        &'a self,\n-        db: &'a dyn HirDatabase,\n-        module_id: ModuleId,\n-    ) -> Result<String, DisplaySourceCodeError> {\n-        let mut result = String::new();\n-        match self.hir_fmt(&mut HirFormatter {\n+    fn display_test<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n+    where\n+        Self: Sized,\n+    {\n+        HirDisplayWrapper {\n             db,\n-            fmt: &mut result,\n-            buf: String::with_capacity(20),\n-            curr_size: 0,\n+            t: self,\n             max_size: None,\n             omit_verbose_types: false,\n-            display_target: DisplayTarget::Test { module_id },\n-        }) {\n-            Ok(()) => {}\n-            Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n-            Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),\n-        };\n-        Ok(result)\n+            display_target: DisplayTarget::Test,\n+        }\n     }\n }\n \n@@ -158,15 +149,15 @@ enum DisplayTarget {\n     /// The generated code should compile, so paths need to be qualified.\n     SourceCode { module_id: ModuleId },\n     /// Only for test purpose to keep real types\n-    Test { module_id: ModuleId },\n+    Test,\n }\n \n impl DisplayTarget {\n     fn is_source_code(&self) -> bool {\n         matches!(self, Self::SourceCode {..})\n     }\n     fn is_test(&self) -> bool {\n-        matches!(self, Self::Test {..})\n+        matches!(self, Self::Test)\n     }\n }\n \n@@ -348,15 +339,15 @@ impl HirDisplay for ApplicationTy {\n             }\n             TypeCtor::Adt(def_id) => {\n                 match f.display_target {\n-                    DisplayTarget::Diagnostics => {\n+                    DisplayTarget::Diagnostics | DisplayTarget::Test => {\n                         let name = match def_id {\n                             AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n                             AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n                             AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n                         };\n                         write!(f, \"{}\", name)?;\n                     }\n-                    DisplayTarget::SourceCode { module_id } | DisplayTarget::Test { module_id } => {\n+                    DisplayTarget::SourceCode { module_id } => {\n                         if let Some(path) = find_path::find_path(\n                             f.db.upcast(),\n                             ItemInNs::Types(def_id.into()),\n@@ -417,28 +408,23 @@ impl HirDisplay for ApplicationTy {\n                     _ => panic!(\"not an associated type\"),\n                 };\n                 let trait_ = f.db.trait_data(trait_);\n-                let type_alias = f.db.type_alias_data(type_alias);\n+                let type_alias_data = f.db.type_alias_data(type_alias);\n \n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n-                if f.display_target.is_test() || self.parameters.len() > 1 {\n-                    write!(f, \"{}::{}\", trait_.name, type_alias.name)?;\n+                if f.display_target.is_test() {\n+                    write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n                     if self.parameters.len() > 0 {\n                         write!(f, \"<\")?;\n                         f.write_joined(&*self.parameters.0, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n-                    if self.parameters.len() == 1 {\n-                        write!(\n-                            f,\n-                            \"<{} as {}>::{}\",\n-                            self.parameters.as_single().display(f.db),\n-                            trait_.name,\n-                            type_alias.name\n-                        )?;\n-                    } else {\n-                        write!(f, \"{}::{}\", trait_.name, type_alias.name)?;\n-                    }\n+                    let projection_ty = ProjectionTy {\n+                        associated_ty: type_alias,\n+                        parameters: self.parameters.clone(),\n+                    };\n+\n+                    projection_ty.hir_fmt(f)?;\n                 }\n             }\n             TypeCtor::ForeignType(type_alias) => {"}, {"sha": "29b178ec1263ef88cb1ccff34553677ccac910f8", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=0aca7b78de234526e1d85a4dfd23fb4f374908ea", "patch": "@@ -157,14 +157,13 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n                 (node.value.text_range(), node.value.text().to_string().replace(\"\\n\", \" \"))\n             };\n             let macro_prefix = if node.file_id != file_id.into() { \"!\" } else { \"\" };\n-            let module = db.module_for_file(node.file_id.original_file(&db));\n             format_to!(\n                 buf,\n                 \"{}{:?} '{}': {}\\n\",\n                 macro_prefix,\n                 range,\n                 ellipsize(text, 15),\n-                ty.display_test(&db, module).unwrap()\n+                ty.display_test(&db)\n             );\n         }\n         if include_mismatches {\n@@ -175,14 +174,13 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             for (src_ptr, mismatch) in &mismatches {\n                 let range = src_ptr.value.text_range();\n                 let macro_prefix = if src_ptr.file_id != file_id.into() { \"!\" } else { \"\" };\n-                let module = db.module_for_file(src_ptr.file_id.original_file(&db));\n                 format_to!(\n                     buf,\n                     \"{}{:?}: expected {}, got {}\\n\",\n                     macro_prefix,\n                     range,\n-                    mismatch.expected.display_test(&db, module).unwrap(),\n-                    mismatch.actual.display_test(&db, module).unwrap(),\n+                    mismatch.expected.display_test(&db),\n+                    mismatch.actual.display_test(&db),\n                 );\n             }\n         }"}, {"sha": "0f17ff1517b3c64429ecdd1b8853c2a0677b3587", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aca7b78de234526e1d85a4dfd23fb4f374908ea/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=0aca7b78de234526e1d85a4dfd23fb4f374908ea", "patch": "@@ -108,16 +108,16 @@ fn infer_associated_method_with_modules() {\n     check_infer(\n         r#\"\n         mod a {\n-            pub struct A;\n+            struct A;\n             impl A { pub fn thing() -> A { A {} }}\n         }\n \n         mod b {\n-            pub struct B;\n+            struct B;\n             impl B { pub fn thing() -> u32 { 99 }}\n \n-            pub mod c {\n-                pub struct C;\n+            mod c {\n+                struct C;\n                 impl C { pub fn thing() -> C { C {} }}\n             }\n         }\n@@ -130,22 +130,22 @@ fn infer_associated_method_with_modules() {\n         }\n         \"#,\n         expect![[r#\"\n-            59..67 '{ A {} }': a::A\n-            61..65 'A {}': a::A\n-            133..139 '{ 99 }': u32\n-            135..137 '99': u32\n-            217..225 '{ C {} }': c::C\n-            219..223 'C {}': c::C\n-            256..340 '{     ...g(); }': ()\n-            266..267 'x': a::A\n-            270..281 'a::A::thing': fn thing() -> A\n-            270..283 'a::A::thing()': a::A\n-            293..294 'y': u32\n-            297..308 'b::B::thing': fn thing() -> u32\n-            297..310 'b::B::thing()': u32\n-            320..321 'z': c::C\n-            324..335 'c::C::thing': fn thing() -> C\n-            324..337 'c::C::thing()': c::C\n+            55..63 '{ A {} }': A\n+            57..61 'A {}': A\n+            125..131 '{ 99 }': u32\n+            127..129 '99': u32\n+            201..209 '{ C {} }': C\n+            203..207 'C {}': C\n+            240..324 '{     ...g(); }': ()\n+            250..251 'x': A\n+            254..265 'a::A::thing': fn thing() -> A\n+            254..267 'a::A::thing()': A\n+            277..278 'y': u32\n+            281..292 'b::B::thing': fn thing() -> u32\n+            281..294 'b::B::thing()': u32\n+            304..305 'z': C\n+            308..319 'c::C::thing': fn thing() -> C\n+            308..321 'c::C::thing()': C\n         \"#]],\n     );\n }"}]}