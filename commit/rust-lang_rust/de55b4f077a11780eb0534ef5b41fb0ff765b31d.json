{"sha": "de55b4f077a11780eb0534ef5b41fb0ff765b31d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNTViNGYwNzdhMTE3ODBlYjA1MzRlZjViNDFmYjBmZjc2NWIzMWQ=", "commit": {"author": {"name": "Tobias Schottdorf", "email": "tobias.schottdorf@gmail.com", "date": "2017-10-06T20:30:23Z"}, "committer": {"name": "Tobias Schottdorf", "email": "tobias.schottdorf@gmail.com", "date": "2017-10-06T20:30:23Z"}, "message": "implement pattern-binding-modes RFC\n\nSee the [RFC] and [tracking issue].\n\n[tracking issue]: https://github.com/rust-lang/rust/issues/42640\n[RFC]: https://github.com/rust-lang/rfcs/blob/491e0af/text/2005-match-ergonomics.md", "tree": {"sha": "757df51c4a42e2e74b50ee90d5c1f4c831eadf8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757df51c4a42e2e74b50ee90d5c1f4c831eadf8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de55b4f077a11780eb0534ef5b41fb0ff765b31d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de55b4f077a11780eb0534ef5b41fb0ff765b31d", "html_url": "https://github.com/rust-lang/rust/commit/de55b4f077a11780eb0534ef5b41fb0ff765b31d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de55b4f077a11780eb0534ef5b41fb0ff765b31d/comments", "author": {"login": "tbg", "id": 5076964, "node_id": "MDQ6VXNlcjUwNzY5NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5076964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbg", "html_url": "https://github.com/tbg", "followers_url": "https://api.github.com/users/tbg/followers", "following_url": "https://api.github.com/users/tbg/following{/other_user}", "gists_url": "https://api.github.com/users/tbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbg/subscriptions", "organizations_url": "https://api.github.com/users/tbg/orgs", "repos_url": "https://api.github.com/users/tbg/repos", "events_url": "https://api.github.com/users/tbg/events{/privacy}", "received_events_url": "https://api.github.com/users/tbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbg", "id": 5076964, "node_id": "MDQ6VXNlcjUwNzY5NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5076964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbg", "html_url": "https://github.com/tbg", "followers_url": "https://api.github.com/users/tbg/followers", "following_url": "https://api.github.com/users/tbg/following{/other_user}", "gists_url": "https://api.github.com/users/tbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbg/subscriptions", "organizations_url": "https://api.github.com/users/tbg/orgs", "repos_url": "https://api.github.com/users/tbg/repos", "events_url": "https://api.github.com/users/tbg/events{/privacy}", "received_events_url": "https://api.github.com/users/tbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8feaee5b6b54c03f49481fe04a9ad9e8f659f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8feaee5b6b54c03f49481fe04a9ad9e8f659f7c", "html_url": "https://github.com/rust-lang/rust/commit/a8feaee5b6b54c03f49481fe04a9ad9e8f659f7c"}], "stats": {"total": 1481, "additions": 1406, "deletions": 75}, "files": [{"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match_default_bindings.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch_default_bindings.md?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,58 @@\n+# `match_default_bindings`\n+\n+The tracking issue for this feature is: [#42640]\n+\n+[#42640]: https://github.com/rust-lang/rust/issues/42640\n+\n+------------------------\n+\n+Match default bindings (also called \"default binding modes in match\") improves ergonomics for\n+pattern-matching on references by introducing automatic dereferencing (and a corresponding shift\n+in binding modes) for large classes of patterns that would otherwise not compile.\n+\n+For example, under match default bindings,\n+\n+```rust\n+#![feature(match_default_bindings)]\n+\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match x {\n+        Some(y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        None => {},\n+    }\n+}\n+```\n+\n+compiles and is equivalent to either of the below:\n+\n+```rust\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match *x {\n+        Some(ref y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        None => {},\n+    }\n+}\n+```\n+\n+or\n+\n+```rust\n+fn main() {\n+    let x: &Option<_> = &Some(0);\n+\n+    match x {\n+        &Some(ref y) => {\n+            println!(\"y={}\", *y);\n+        },\n+        &None => {},\n+    }\n+}\n+```"}, {"sha": "2bec224362ea64710106683d573240ba914afacc", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -160,11 +160,13 @@ impl hir::Pat {\n         variants\n     }\n \n-    /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-    /// and if yes whether it contains mutable or just immutables ones.\n+    /// Checks if the pattern contains any `ref` or `ref mut` bindings, and if\n+    /// yes whether it contains mutable or just immutables ones.\n     ///\n-    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped,\n-    /// but ref bindings may be implicit after #42640.\n+    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n+    /// ref bindings are be implicit after #42640 (default match binding modes).\n+    ///\n+    /// See #44848.\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {\n@@ -188,7 +190,9 @@ impl hir::Arm {\n     /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n-        // for #42640.\n+        // for #42640 (default match binding modes).\n+        //\n+        // See #44848.\n         self.pats.iter()\n                  .filter_map(|pat| pat.contains_explicit_ref_binding())\n                  .max_by_key(|m| match *m {"}, {"sha": "c973881c980eef5dd2669fa27a29e91b43a51b85", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -1094,7 +1094,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+    fn cat_pattern_<F>(&self, mut cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n         where F : FnMut(cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n@@ -1144,6 +1144,56 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n+        // If (pattern) adjustments are active for this pattern, adjust the `cmt` correspondingly.\n+        // `cmt`s are constructed differently from patterns. For example, in\n+        //\n+        // ```\n+        // match foo {\n+        //     &&Some(x, ) => { ... },\n+        //     _ => { ... },\n+        // }\n+        // ```\n+        //\n+        // the pattern `&&Some(x,)` is represented as `Ref { Ref { TupleStruct }}`. To build the\n+        // corresponding `cmt` we start with a `cmt` for `foo`, and then, by traversing the\n+        // pattern, try to answer the question: given the address of `foo`, how is `x` reached?\n+        //\n+        // `&&Some(x,)` `cmt_foo`\n+        //  `&Some(x,)` `deref { cmt_foo}`\n+        //   `Some(x,)` `deref { deref { cmt_foo }}`\n+        //        (x,)` `field0 { deref { deref { cmt_foo }}}` <- resulting cmt\n+        //\n+        // The above example has no adjustments. If the code were instead the (after adjustments,\n+        // equivalent) version\n+        //\n+        // ```\n+        // match foo {\n+        //     Some(x, ) => { ... },\n+        //     _ => { ... },\n+        // }\n+        // ```\n+        //\n+        // Then we see that to get the same result, we must start with `deref { deref { cmt_foo }}`\n+        // instead of `cmt_foo` since the pattern is now `Some(x,)` and not `&&Some(x,)`, even\n+        // though its assigned type is that of `&&Some(x,)`.\n+        for _ in 0..self.tables\n+                        .pat_adjustments()\n+                        .get(pat.hir_id)\n+                        .map(|v| v.len())\n+                        .unwrap_or(0) {\n+            cmt = self.cat_deref(pat, cmt, true /* implicit */)?;\n+        }\n+        let cmt = cmt; // lose mutability\n+\n+        // Invoke the callback, but only now, after the `cmt` has adjusted.\n+        //\n+        // To see that this makes sense, consider `match &Some(3) { Some(x) => { ... }}`. In that\n+        // case, the initial `cmt` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n+        // don't want to call `op` with these incompatible values. As written, what happens instead\n+        // is that `op` is called with the adjusted cmt (that for `*&Some(3)`) and the pattern\n+        // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n+        // result in the cmt `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n+        // that (where the `ref` on `x` is implied).\n         op(cmt.clone(), pat);\n \n         match pat.node {"}, {"sha": "15e10f8c5e8d57f6ef692a8fe7ada632fa11a59a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -337,9 +337,24 @@ pub struct TypeckTables<'tcx> {\n \n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n-    // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n     pat_binding_modes: ItemLocalMap<BindingMode>,\n \n+    /// Stores the types which were implicitly dereferenced in pattern binding modes\n+    /// for later usage in HAIR lowering. For example,\n+    ///\n+    /// ```\n+    /// match &&Some(5i32) {\n+    ///     Some(n) => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n+    ///\n+    /// See:\n+    /// https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions\n+    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n@@ -394,6 +409,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             node_substs: ItemLocalMap(),\n             adjustments: ItemLocalMap(),\n             pat_binding_modes: ItemLocalMap(),\n+            pat_adjustments: ItemLocalMap(),\n             upvar_capture_map: FxHashMap(),\n             generator_sigs: ItemLocalMap(),\n             generator_interiors: ItemLocalMap(),\n@@ -574,6 +590,21 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn pat_adjustments(&self) -> LocalTableInContext<Vec<Ty<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.pat_adjustments,\n+        }\n+    }\n+\n+    pub fn pat_adjustments_mut(&mut self)\n+                           -> LocalTableInContextMut<Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.pat_adjustments,\n+        }\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n@@ -699,6 +730,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n             ref node_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n+            ref pat_adjustments,\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n@@ -720,6 +752,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n             node_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n+            pat_adjustments.hash_stable(hcx, hasher);\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "d7a16e9d2fc7565ba9b32949951cb37c6bf436a7", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -301,6 +301,44 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n+        // pattern has the type that results *after* dereferencing. For example, in this code:\n+        //\n+        // ```\n+        // match &&Some(0i32) {\n+        //     Some(n) => { ... },\n+        //     _ => { ... },\n+        // }\n+        // ```\n+        //\n+        // the type assigned to `Some(n)` in `unadjusted_pat` would be `Option<i32>` (this is\n+        // determined in rustc_typeck::check::match). The adjustments would be\n+        //\n+        // `vec![&&Option<i32>, &Option<i32>]`.\n+        //\n+        // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n+        // we wrap the unadjusted pattern in `PatternKind::Deref` repeatedly, consuming the\n+        // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n+        // gets the least-dereferenced type).\n+        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n+        self.tables\n+            .pat_adjustments()\n+            .get(pat.hir_id)\n+            .unwrap_or(&vec![])\n+            .iter()\n+            .rev()\n+            .fold(unadjusted_pat, |pat, ref_ty| {\n+                    debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n+                    Pattern {\n+                        span: pat.span,\n+                        ty: ref_ty,\n+                        kind: Box::new(PatternKind::Deref { subpattern: pat }),\n+                    }\n+                },\n+            )\n+    }\n+\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {"}, {"sha": "ab8994bcae2537bed89e4f3bcee629111802b1ff", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 133, "deletions": 41, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -27,25 +27,111 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n-        self.check_pat_arg(pat, expected, false);\n-    }\n-\n     /// The `is_arg` argument indicates whether this pattern is the\n     /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n     /// &u32)`, it is true for the `&x` pattern but not `x`). This is\n     /// used to tailor error reporting.\n-    pub fn check_pat_arg(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>, is_arg: bool) {\n+    pub fn check_pat_walk(\n+        &self,\n+        pat: &'gcx hir::Pat,\n+        mut expected: Ty<'tcx>,\n+        mut def_bm: ty::BindingMode,\n+        is_arg: bool)\n+    {\n         let tcx = self.tcx;\n \n-        debug!(\"check_pat(pat={:?},expected={:?},is_arg={})\", pat, expected, is_arg);\n+        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?},is_arg={})\",\n+            pat, expected, def_bm, is_arg);\n+\n+        let is_non_ref_pat = match pat.node {\n+            PatKind::Struct(..) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Tuple(..) |\n+            PatKind::Box(_) |\n+            PatKind::Range(..) |\n+            PatKind::Slice(..) => true,\n+            PatKind::Lit(ref lt) => {\n+                let ty = self.check_expr(lt);\n+                match ty.sty {\n+                    ty::TypeVariants::TyRef(..) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Path(ref qpath) => {\n+                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+                match def {\n+                    Def::Const(..) | Def::AssociatedConst(..) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Wild |\n+            PatKind::Binding(..) |\n+            PatKind::Ref(..) => false,\n+        };\n+        if is_non_ref_pat && tcx.sess.features.borrow().match_default_bindings {\n+            debug!(\"pattern is non reference pattern\");\n+            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n+\n+            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n+            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n+            // the `Some(5)` which is not of type TyRef.\n+            //\n+            // For each ampersand peeled off, update the binding mode and push the original\n+            // type into the adjustments vector.\n+            //\n+            // See the examples in `run-pass/match-defbm*.rs`.\n+            let mut pat_adjustments = vec![];\n+            expected = loop {\n+                debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n+                match exp_ty.sty {\n+                    ty::TypeVariants::TyRef(_, ty::TypeAndMut{\n+                        ty: inner_ty, mutbl: inner_mutability,\n+                    }) => {\n+                        debug!(\"current discriminant is TyRef, inserting implicit deref\");\n+                        // Preserve the reference type. We'll need it later during HAIR lowering.\n+                        pat_adjustments.push(exp_ty);\n+\n+                        exp_ty = inner_ty;\n+                        def_bm = match def_bm {\n+                            // If default binding mode is by value, make it `ref` or `ref mut`\n+                            // (depending on whether we observe `&` or `&mut`).\n+                            ty::BindByValue(_) =>\n+                                ty::BindByReference(inner_mutability),\n+\n+                            // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n+                            // the underlying value.\n+                            ty::BindByReference(hir::Mutability::MutImmutable) =>\n+                                ty::BindByReference(hir::Mutability::MutImmutable),\n+\n+                            // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n+                            // (on `&`).\n+                            ty::BindByReference(hir::Mutability::MutMutable) =>\n+                                ty::BindByReference(inner_mutability),\n+                        };\n+                    },\n+                    _ => break exp_ty,\n+                }\n+            };\n+            if pat_adjustments.len() > 0 {\n+                debug!(\"default binding mode is now {:?}\", def_bm);\n+                self.inh.tables.borrow_mut()\n+                    .pat_adjustments_mut()\n+                    .insert(pat.hir_id, pat_adjustments);\n+            }\n+        }\n+\n+        // Lose mutability now that we know binding mode and discriminant type.\n+        let def_bm = def_bm;\n+        let expected = expected;\n \n         let ty = match pat.node {\n             PatKind::Wild => {\n                 expected\n             }\n             PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(&lt);\n+                // We've already computed the type above (when checking for a non-ref pat), so\n+                // avoid computing it again.\n+                let ty = self.node_ty(lt.hir_id);\n \n                 // Byte string patterns behave the same way as array patterns\n                 // They can denote both statically and dynamically sized byte arrays\n@@ -114,10 +200,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 common_type\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n-                // Note the binding mode in the typeck tables. For now, what we store is always\n-                // identical to what could be scraped from the HIR, but this will change with\n-                // default binding modes (#42640).\n-                let bm = ty::BindingMode::convert(ba);\n+                let bm = if ba == hir::BindingAnnotation::Unannotated {\n+                    def_bm\n+                } else {\n+                    ty::BindingMode::convert(ba)\n+                };\n                 self.inh\n                     .tables\n                     .borrow_mut()\n@@ -155,19 +242,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    self.check_pat(&p, expected);\n+                    self.check_pat_walk(&p, expected, def_bm, true);\n                 }\n \n                 typ\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected)\n+                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected, def_bm)\n             }\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -188,7 +275,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys, false));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n                 for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                    self.check_pat(elem, &element_tys[i]);\n+                    self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n                 }\n                 pat_ty\n             }\n@@ -201,10 +288,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n                     self.demand_eqtype(pat.span, expected, uniq_ty);\n-                    self.check_pat(&inner, inner_ty);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n                     uniq_ty\n                 } else {\n-                    self.check_pat(&inner, tcx.types.err);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n                     tcx.types.err\n                 }\n             }\n@@ -219,7 +306,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // can, to avoid creating needless variables.  This\n                     // also helps with the bad interactions of the given\n                     // hack detailed in (*) below.\n-                    debug!(\"check_pat_arg: expected={:?}\", expected);\n+                    debug!(\"check_pat_walk: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n                         ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n                             (expected, mt.ty)\n@@ -230,7 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n                             let rptr_ty = tcx.mk_ref(region, mt);\n-                            debug!(\"check_pat_arg: demanding {:?} = {:?}\", expected, rptr_ty);\n+                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n                             let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n \n                             // Look for a case like `fn foo(&foo: u32)` and suggest\n@@ -253,10 +340,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.check_pat(&inner, inner_ty);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n                     rptr_ty\n                 } else {\n-                    self.check_pat(&inner, tcx.types.err);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n                     tcx.types.err\n                 }\n             }\n@@ -314,13 +401,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 for elt in before {\n-                    self.check_pat(&elt, inner_ty);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    self.check_pat(&slice, slice_ty);\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, true);\n                 }\n                 for elt in after {\n-                    self.check_pat(&elt, inner_ty);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n                 }\n                 expected_ty\n             }\n@@ -329,7 +416,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.write_ty(pat.hir_id, ty);\n \n         // (*) In most of the cases above (literals and constants being\n-        // the exception), we relate types using strict equality, evewn\n+        // the exception), we relate types using strict equality, even\n         // though subtyping would be sufficient. There are a few reasons\n         // for this, some of which are fairly subtle and which cost me\n         // (nmatsakis) an hour or two debugging to remember, so I thought\n@@ -339,7 +426,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // cause some inconvenience. What we are saying is that the type\n         // of `x` becomes *exactly* what is expected. This can cause unnecessary\n         // errors in some cases, such as this one:\n-        // it will cause errors in a case like this:\n         //\n         // ```\n         // fn foo<'x>(x: &'x int) {\n@@ -409,11 +495,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // use the *precise* type of the discriminant, *not* some supertype, as\n         // the \"discriminant type\" (issue #23116).\n         //\n-        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n-        // is problematic as the HIR is being scraped, but ref bindings may be\n-        // implicit after #42640. We need to make sure that pat_adjustments\n-        // (once introduced) is populated by the time we get here.\n-        //\n         // arielb1 [writes here in this comment thread][c] that there\n         // is certainly *some* potential danger, e.g. for an example\n         // like:\n@@ -455,7 +536,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //     assert_eq!(foo.0.0, 42);\n         // }\n         // ```\n-\n+        //\n+        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n+        // is problematic as the HIR is being scraped, but ref bindings may be\n+        // implicit after #42640. We need to make sure that pat_adjustments\n+        // (once introduced) is populated by the time we get here.\n+        //\n+        // See #44848.\n         let contains_ref_bindings = arms.iter()\n                                         .filter_map(|a| a.contains_explicit_ref_binding())\n                                         .max_by_key(|m| match *m {\n@@ -495,7 +582,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat(&p, discrim_ty);\n+                self.check_pat_walk(&p, discrim_ty,\n+                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -576,14 +664,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         qpath: &hir::QPath,\n                         fields: &'gcx [Spanned<hir::FieldPat>],\n                         etc: bool,\n-                        expected: Ty<'tcx>) -> Ty<'tcx>\n+                        expected: Ty<'tcx>,\n+                        def_bm: ty::BindingMode) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat(&field.node.pat, self.tcx.types.err);\n+                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, true);\n             }\n             return self.tcx.types.err;\n         };\n@@ -592,7 +681,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n-        self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc);\n+        self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm);\n         pat_ty\n     }\n \n@@ -637,12 +726,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               qpath: &hir::QPath,\n                               subpats: &'gcx [P<hir::Pat>],\n                               ddpos: Option<usize>,\n-                              expected: Ty<'tcx>) -> Ty<'tcx>\n+                              expected: Ty<'tcx>,\n+                              def_bm: ty::BindingMode) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n+                self.check_pat_walk(&pat, tcx.types.err, def_bm, true);\n             }\n         };\n         let report_unexpected_def = |def: Def| {\n@@ -678,6 +768,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Replace constructor type with constructed type for tuple struct patterns.\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n+\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n@@ -689,7 +780,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty);\n+                self.check_pat_walk(&subpat, field_ty, def_bm, true);\n \n                 self.tcx.check_stability(variant.fields[i].did, pat.id, subpat.span);\n             }\n@@ -715,7 +806,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                span: Span,\n                                variant: &'tcx ty::VariantDef,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n-                               etc: bool) {\n+                               etc: bool,\n+                               def_bm: ty::BindingMode) {\n         let tcx = self.tcx;\n \n         let (substs, kind_name) = match adt_ty.sty {\n@@ -772,7 +864,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty);\n+            self.check_pat_walk(&field.pat, field_ty, def_bm, true);\n         }\n \n         // Report an error if incorrect number of the fields were specified."}, {"sha": "9c6a4abfbd7c0295c0d77fdf239537bf931bd519", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -1037,7 +1037,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        fcx.check_pat_arg(&arg.pat, arg_ty, true);\n+        fcx.check_pat_walk(&arg.pat, arg_ty,\n+            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -4106,6 +4107,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (self.to_ty(qself), segment)\n             }\n         };\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        if let Some(cached_def) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n+            // Return directly on cache hit. This is useful to avoid doubly reporting\n+            // errors with default match binding modes. See #44614.\n+            return (*cached_def, Some(ty), slice::ref_slice(&**item_segment))\n+        }\n         let item_name = item_segment.name;\n         let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n             Ok(def) => def,\n@@ -4122,7 +4129,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n         self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n@@ -4132,7 +4138,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n-        // for #42640.\n+        // for #42640 (default match binding modes).\n+        //\n+        // See #44848.\n         let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n         let local_ty = self.local_ty(init.span, local.id);\n@@ -4164,7 +4172,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_pat(&local.pat, t);\n+        self.check_pat_walk(&local.pat, t,\n+                            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+                            true);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n             self.write_ty(local.hir_id, pat_ty);"}, {"sha": "b3648d357e51580127e0922e590a88fe235634cb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -197,6 +197,8 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             _ => {}\n         };\n \n+        self.visit_pat_adjustments(p.span, p.hir_id);\n+\n         self.visit_node_id(p.span, p.hir_id);\n         intravisit::walk_pat(self, p);\n     }\n@@ -366,6 +368,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_pat_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n+        let adjustment = self.fcx\n+                             .tables\n+                             .borrow_mut()\n+                             .pat_adjustments_mut()\n+                             .remove(hir_id);\n+        match adjustment {\n+            None => {\n+                debug!(\"No pat_adjustments for node {:?}\", hir_id);\n+            }\n+\n+            Some(adjustment) => {\n+                let resolved_adjustment = self.resolve(&adjustment, &span);\n+                debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                self.tables.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n+            }\n+        }\n+    }\n+\n     fn visit_generator_interiors(&mut self) {\n         let common_local_id_root = self.fcx.tables.borrow().local_id_root.unwrap();\n         for (&id, interior) in self.fcx.tables.borrow().generator_interiors().iter() {"}, {"sha": "a2f29181a20d3ec5f423ddfb7f2efe173f16bd52", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -395,6 +395,9 @@ declare_features! (\n \n     // allow `..=` in patterns (RFC 1192)\n     (active, dotdoteq_in_patterns, \"1.22.0\", Some(28237)),\n+\n+    // Default match binding modes (RFC 2005)\n+    (active, match_default_bindings, \"1.22.0\", Some(42640)),\n );\n \n declare_features! ("}, {"sha": "2b3bf94eadce5ed020fb8a36033b778a883df466", "filename": "src/test/compile-fail/feature-gate-match_default_bindings.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-match_default_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-match_default_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-match_default_bindings.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    match &Some(3) {\n+        Some(n) => {}, //~ ERROR mismatched types [E0308]\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "7b5e61380f2ba263ddb60186e200074957bf814c", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    for (ref i,) in [].iter() { //~ ERROR mismatched types\n+    // NB: this (almost) typechecks when default binding modes are enabled.\n+    for (ref i,) in [].iter() { //~ ERROR mismatched types [E0308]\n         i.clone();\n     }\n }"}, {"sha": "016df6cb6ef819bcf459b6d1d82567e337991821", "filename": "src/test/compile-fail/issue-7867.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -21,17 +21,4 @@ fn main() {\n         //~| expected tuple, found enum `A`\n         _ => ()\n     }\n-\n-    match &Some(42) {\n-        Some(x) => (),\n-        //~^ ERROR mismatched types\n-        //~| expected type `&std::option::Option<{integer}>`\n-        //~| found type `std::option::Option<_>`\n-        //~| expected reference, found enum `std::option::Option`\n-        None => ()\n-        //~^ ERROR mismatched types\n-        //~| expected type `&std::option::Option<{integer}>`\n-        //~| found type `std::option::Option<_>`\n-        //~| expected reference, found enum `std::option::Option`\n-    }\n }"}, {"sha": "d72ec8ba40868c59c30f816ac26475bd86d60ddc", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -17,8 +17,9 @@ fn main() {\n         _ => { }\n     };\n \n+    // Note that this one works with default binding modes.\n     match &[0, 1, 2] {\n-        [..] => {} //~ ERROR expected an array or slice, found `&[{integer}; 3]`\n+        [..] => {} //~ ERROR expected an array or slice, found `&[{integer}; 3]` [E0529]\n     };\n \n     match &[0, 1, 2] {"}, {"sha": "54028ffa63ffc0f87bb2f27cd8bc1b887e713d93", "filename": "src/test/compile-fail/pat-slice-old-style.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -10,13 +10,19 @@\n \n #![feature(slice_patterns)]\n \n+// NB: this test was introduced in #23121 and will have to change when default match binding modes\n+// stabilizes.\n+\n fn slice_pat(x: &[u8]) {\n     // OLD!\n     match x {\n-        [a, b..] => {}\n+        [a, b..] => {},\n         //~^ ERROR expected an array or slice, found `&[u8]`\n         //~| HELP the semantics of slice patterns changed recently; see issue #23121\n+        _ => panic!(),\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    slice_pat(\"foo\".as_bytes());\n+}"}, {"sha": "85453f32208cbc5640aa7aee2c7598071d676454", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/box.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fbox.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax, box_patterns)]\n+#![feature(match_default_bindings)]\n+\n+struct Foo{}\n+\n+pub fn main() {\n+    let b = box Foo{};\n+    let box f = &b;\n+    let _: &Foo = f;\n+\n+    match &&&b {\n+        box f => {\n+            let _: &Foo = f;\n+        },\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "1b8fdbaa4d75c475b2c32fcbdc2daab90f5b9f3c", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/constref.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fconstref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fconstref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fconstref.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+const CONST_REF: &[u8; 3] = b\"foo\";\n+\n+trait Foo {\n+    const CONST_REF_DEFAULT: &'static [u8; 3] = b\"bar\";\n+    const CONST_REF: &'static [u8; 3];\n+}\n+\n+impl Foo for i32 {\n+    const CONST_REF: &'static [u8; 3] = b\"jjj\";\n+}\n+\n+impl Foo for i64 {\n+    const CONST_REF_DEFAULT: &'static [u8; 3] = b\"ggg\";\n+    const CONST_REF: &'static [u8; 3] = b\"fff\";\n+}\n+\n+// Check that (associated and free) const references are not mistaken for a\n+// non-reference pattern (in which case they would be auto-dereferenced, making\n+// the types mismatched).\n+\n+fn const_ref() -> bool {\n+    let f = b\"foo\";\n+    match f {\n+        CONST_REF => true,\n+        _ => false,\n+    }\n+}\n+\n+fn associated_const_ref() -> bool {\n+    match (b\"bar\", b\"jjj\", b\"ggg\", b\"fff\") {\n+        (i32::CONST_REF_DEFAULT, i32::CONST_REF, i64::CONST_REF_DEFAULT, i64::CONST_REF) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn main() {\n+    assert!(const_ref());\n+    assert!(associated_const_ref());\n+}"}, {"sha": "a7b3db021b021a428a45a6571c0758b0277327e6", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/enum.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fenum.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+enum Wrapper {\n+    Wrap(i32),\n+}\n+\n+use Wrapper::Wrap;\n+\n+pub fn main() {\n+    let Wrap(x) = &Wrap(3);\n+    println!(\"{}\", *x);\n+\n+    let Wrap(x) = &mut Wrap(3);\n+    println!(\"{}\", *x);\n+\n+    if let Some(x) = &Some(3) {\n+        println!(\"{}\", *x);\n+    } else {\n+        panic!();\n+    }\n+\n+    if let Some(x) = &mut Some(3) {\n+        println!(\"{}\", *x);\n+    } else {\n+        panic!();\n+    }\n+\n+    if let Some(x) = &mut Some(3) {\n+        *x += 1;\n+    } else {\n+        panic!();\n+    }\n+\n+    while let Some(x) = &Some(3) {\n+        println!(\"{}\", *x);\n+        break;\n+    }\n+    while let Some(x) = &mut Some(3) {\n+        println!(\"{}\", *x);\n+        break;\n+    }\n+    while let Some(x) = &mut Some(3) {\n+        *x += 1;\n+        break;\n+    }\n+}"}, {"sha": "4feab94a7edf534d6937039a3ed051dc934929b9", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/for.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ffor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ffor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ffor.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+pub fn main() {\n+    let mut tups = vec![(0u8, 1u8)];\n+\n+    for (n, m) in &tups {\n+        let _: &u8 = n;\n+        let _: &u8 = m;\n+    }\n+\n+    for (n, m) in &mut tups {\n+        *n += 1;\n+        *m += 2;\n+    }\n+\n+    assert_eq!(tups, vec![(1u8, 3u8)]);\n+\n+    for (n, m) in tups {\n+        println!(\"{} {}\", m, n);\n+    }\n+}"}, {"sha": "779a38bdb16720ef190af42db0d83697d976a0f8", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/general.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fgeneral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fgeneral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fgeneral.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+fn some_or_wildcard(r: &Option<i32>, b: &i32) {\n+    let _: &i32 = match r {\n+        Some(a) => a,\n+        _ => b,\n+    };\n+}\n+\n+fn none_or_wildcard(r: &Option<i32>, b: &i32) {\n+    let _: &i32 = match r {\n+        None => b,\n+        _ => b,\n+    };\n+}\n+\n+fn some_or_ref_none(r: &Option<i32>, b: &i32) {\n+    let _: &i32 = match r {\n+        Some(a) => a,\n+        &None => b,\n+    };\n+}\n+\n+fn ref_some_or_none(r: &Option<i32>, b: &i32) {\n+    let _: &i32 = match r {\n+        &Some(ref a) => a,\n+        None => b,\n+    };\n+}\n+\n+fn some_or_self(r: &Option<i32>) {\n+    let _: &Option<i32> = match r {\n+        Some(n) => {\n+            let _: &i32 = n;\n+            r\n+        },\n+        x => x,\n+    };\n+}\n+\n+fn multiple_deref(r: &&&&&Option<i32>) {\n+    let _: i32 = match r {\n+        Some(a) => *a,\n+        None => 5,\n+    };\n+}\n+\n+fn match_with_or() {\n+    // FIXME(tschottdorf): #44912.\n+    //\n+    // let x = &Some((3, 3));\n+    // let _: &i32 = match x {\n+    //     Some((x, 3)) | &Some((ref x, 5)) => x,\n+    //     _ => &5i32,\n+    // };\n+}\n+\n+fn nested_mixed() {\n+    match (&Some(5), &Some(6)) {\n+        (Some(a), &Some(mut b)) => {\n+            // Here, the `a` will be `&i32`, because in the first half of the tuple\n+            // we hit a non-reference pattern and shift into `ref` mode.\n+            //\n+            // In the second half of the tuple there's no non-reference pattern,\n+            // so `b` will be `i32` (bound with `move` mode). Moreover, `b` is\n+            // mutable.\n+            let _: &i32 = a;\n+            b = 7;\n+            let _: i32 = b;\n+        },\n+        _ => {},\n+    };\n+}\n+\n+fn nested_mixed_multiple_deref_1() {\n+    let x = (1, &Some(5));\n+    let y = &Some(x);\n+    match y {\n+        Some((a, Some(b))) => {\n+            let _: &i32 = a;\n+            let _: &i32 = b;\n+        },\n+        _ => {},\n+    };\n+}\n+\n+fn nested_mixed_multiple_deref_2() {\n+    let x = &Some(5);\n+    let y = &x;\n+    match y {\n+        Some(z) => {\n+            let _: &i32 = z;\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn new_mutable_reference() {\n+    let mut x = &mut Some(5);\n+    match &mut x {\n+        Some(y) => {\n+            *y = 5;\n+        },\n+        None => { },\n+    }\n+\n+    match &mut x {\n+        Some(y) => {\n+            println!(\"{}\", *y);\n+        },\n+        None => {},\n+    }\n+}\n+\n+fn let_implicit_ref_binding() {\n+    struct Foo(i32);\n+\n+    // Note that these rules apply to any pattern matching\n+    // whether it be in a `match` or a `let`.\n+    // For example, `x` here is a `ref` binding:\n+    let Foo(x) = &Foo(3);\n+    let _: &i32 = x;\n+}\n+\n+fn explicit_mut_binding() {\n+    match &Some(5i32) {\n+        Some(mut n) => {\n+            n += 1;\n+            let _ = n;\n+        }\n+        None => {},\n+    };\n+\n+    match &mut Some(5i32) {\n+        Some(n) => {\n+            *n += 1;\n+            let _ = n;\n+        }\n+        None => {},\n+    };\n+\n+    match &mut &mut Some(5i32) {\n+        Some(n) => {\n+             let _: &mut i32 = n;\n+        }\n+        None => {},\n+    };\n+}\n+\n+fn tuple_mut_and_mut_mut() {\n+    match (Some(5i32), &Some(5i32)) {\n+        (Some(n), Some(m)) => {\n+            // `n` and `m` are bound as immutable references. Make new references from them to\n+            // assert that.\n+            let r = n;\n+            let _ = r;\n+            let q = m;\n+            let _ = q;\n+\n+            // Assert the types. Note that we use `n` and `m` here which would fail had they been\n+            // moved due to the assignments above.\n+            let _: i32 = n;\n+            let _: &i32 = m;\n+        }\n+        (_, _) => {},\n+    };\n+\n+    match (&Some(5i32), &&Some(5i32)) {\n+        (Some(n), Some(m)) => {\n+            let _: &i32 = n;\n+            let _: &i32 = m;\n+        }\n+        (_, _) => {},\n+    };\n+\n+    match &mut &mut (Some(5i32), Some(5i32)) {\n+        (Some(n), Some(m)) => {\n+            // Dereferenced through &mut &mut, so a mutable binding results.\n+            let _: &mut i32 = n;\n+            let _: &mut i32 = m;\n+        }\n+        (_, _) => {},\n+    };\n+\n+    match (&mut Some(5i32), &mut &mut Some(5i32)) {\n+        (Some(n), Some(m)) => {\n+            let _: &mut i32 = n;\n+            let _: &mut i32 = m;\n+        }\n+        (_, _) => {},\n+    };\n+}\n+\n+fn min_mir_embedded_type() {\n+    // The reduced invocation that an ICE was diagnosed with (was consuming\n+    // adjustments in wrong order).\n+    match (0u8, &&Some(5i32)) {\n+        (_, Some(m)) => {\n+            let _: &i32 = m;\n+        }\n+        (_, _) => {},\n+    };\n+}\n+\n+fn no_autoderef() {\n+    // Binding.\n+    let x = &3;\n+    println!(\"{}\", *x);\n+\n+    // Wildcard.\n+    let _ = &3;\n+\n+    // Constant of generic type (string)\n+    const Y: &'static str = \"foo\";\n+    assert_eq!(0, match \"foo\" {\n+        Y => 0,\n+        _ => 1,\n+    });\n+\n+    // Reference pattern.\n+    let &x = &3;\n+}\n+\n+pub fn main() {\n+    let r: &Option<i32> = &Some(3);\n+    let b = &4i32;\n+\n+    none_or_wildcard(r, b);\n+    some_or_wildcard(r, b);\n+    some_or_ref_none(r, b);\n+    ref_some_or_none(r, b);\n+\n+    some_or_self(r);\n+    multiple_deref(&&&&r);\n+    match_with_or();\n+\n+    nested_mixed();\n+    nested_mixed_multiple_deref_1();\n+    nested_mixed_multiple_deref_2();\n+\n+    new_mutable_reference();\n+    explicit_mut_binding();\n+    tuple_mut_and_mut_mut();\n+    min_mir_embedded_type();\n+\n+    let_implicit_ref_binding();\n+\n+    no_autoderef();\n+}"}, {"sha": "0b2a8e52fbf77354b6f81255fb10437416f9d565", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/lit.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Flit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Flit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Flit.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+fn with_u8() {\n+    let s = 5u8;\n+    let r = match &s {\n+        4 => false,\n+        5 => true,\n+        _ => false,\n+    };\n+    assert!(r);\n+}\n+\n+// A string literal isn't mistaken for a non-ref pattern (in which case we'd\n+// deref `s` and mess things up).\n+fn with_str() {\n+    let s: &'static str = \"abc\";\n+    match s {\n+            \"abc\" => true,\n+            _ => panic!(),\n+    };\n+}\n+\n+// Ditto with byte strings.\n+fn with_bytes() {\n+    let s: &'static [u8] = b\"abc\";\n+    match s {\n+        b\"abc\" => true,\n+        _ => panic!(),\n+    };\n+}\n+\n+pub fn main() {\n+    with_str();\n+}"}, {"sha": "aafaa4cca82ca3ba22e51f6473f6abb490f29e47", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/range.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Frange.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+pub fn main() {\n+    let i = 5;\n+    match &&&&i {\n+        1 ... 3 => panic!(),\n+        3 ... 8 => {},\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "de7df011b56fd77d5d71fcc0ab0d9e653f95e441", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/ref-region.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fref-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fref-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fref-region.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+fn foo<'a, 'b>(x: &'a &'b Option<u32>) -> &'a u32 {\n+    let x: &'a &'a Option<u32> = x;\n+    match x {\n+        Some(r) => {\n+            let _: &u32 = r;\n+            r\n+        },\n+        &None => panic!(),\n+    }\n+}\n+\n+pub fn main() {\n+    let x = Some(5);\n+    foo(&&x);\n+}"}, {"sha": "1717d0d54c0260bd7d3283ace94e9379eb055015", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/slice.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fslice.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+#![feature(match_default_bindings)]\n+\n+fn slice_pat() {\n+    let sl: &[u8] = b\"foo\";\n+\n+    match sl {\n+        [first, remainder..] => {\n+            let _: &u8 = first;\n+            assert_eq!(first, &b'f');\n+            assert_eq!(remainder, b\"oo\");\n+        }\n+        [] => panic!(),\n+    }\n+}\n+\n+fn slice_pat_omission() {\n+     match &[0, 1, 2] {\n+        [..] => {}\n+     };\n+}\n+\n+fn main() {\n+    slice_pat();\n+    slice_pat_omission();\n+}"}, {"sha": "11a675c0c72af5be884dac10310d3e7f5081b51a", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/struct.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Fstruct.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+#[derive(Debug, PartialEq)]\n+struct Foo {\n+    x: u8,\n+}\n+\n+pub fn main() {\n+    let mut foo = Foo {\n+        x: 1,\n+    };\n+\n+    match &mut foo {\n+        Foo{x: n} => {\n+            *n += 1;\n+        },\n+    };\n+\n+    assert_eq!(foo, Foo{x: 2});\n+\n+    let Foo{x: n} = &foo;\n+    assert_eq!(*n, 2);\n+}"}, {"sha": "7867d6529050dad30ddddfbd7cb13aed3343b955", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/tuple-struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple-struct.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+enum Foo {\n+    Bar(Option<i8>, (), (), Vec<i32>),\n+    Baz,\n+}\n+\n+pub fn main() {\n+    let foo = Foo::Bar(Some(1), (), (), vec![2, 3]);\n+\n+    match &foo {\n+        Foo::Baz => panic!(),\n+        Foo::Bar(None, ..) => panic!(),\n+        Foo::Bar(Some(n), .., v) => {\n+            assert_eq!((*v).len(), 2);\n+            assert_eq!(*n, 1);\n+        }\n+    }\n+}"}, {"sha": "cf27265b2ed560671a89de05466cda6e7c57fdf9", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/tuple.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Ftuple.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+pub fn main() {\n+    let foo = (Some(1), (), (), vec![2, 3]);\n+\n+    match &foo {\n+        (Some(n), .., v) => {\n+            assert_eq!((*v).len(), 2);\n+            assert_eq!(*n, 1);\n+        }\n+        (None, (), (), ..) => panic!(),\n+    }\n+}"}, {"sha": "282b0d4e45b7098ae5b3d26d42c6ecb25c747bd4", "filename": "src/test/ui/const-expr-addr-operator.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Encountered while testing #44614.\n+\n+pub fn main() {\n+    // Constant of generic type (int)\n+    const X: &'static u32 = &22;\n+    assert_eq!(0, match &22 {\n+        X => 0,\n+        _ => 1,\n+    });\n+}\n\\ No newline at end of file"}, {"sha": "5bda81451d0e248ae04d9634288212f9d3afff95", "filename": "src/test/ui/const-expr-addr-operator.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,14 @@\n+error[E0080]: constant evaluation error\n+  --> $DIR/const-expr-addr-operator.rs:15:29\n+   |\n+15 |     const X: &'static u32 = &22;\n+   |                             ^^^ unimplemented constant expression: address operator\n+   |\n+note: for pattern here\n+  --> $DIR/const-expr-addr-operator.rs:17:9\n+   |\n+17 |         X => 0,\n+   |         ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "6b49079c47210c039762fb10ffbfa5c9e2eba36a", "filename": "src/test/ui/mismatched_types/issue-38371.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -25,6 +25,8 @@ fn qux(foo: &Foo) {\n fn zar(&foo: &Foo) {\n }\n \n+// The somewhat unexpected help message in this case is courtesy of\n+// match_default_bindings.\n fn agh(&&bar: &u32) {\n }\n "}, {"sha": "c80f075021ec8003063af6f6689d2fe147f5a03b", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -9,27 +9,28 @@ error[E0308]: mismatched types\n    = help: did you mean `foo: &Foo`?\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-38371.rs:28:9\n+  --> $DIR/issue-38371.rs:30:9\n    |\n-28 | fn agh(&&bar: &u32) {\n+30 | fn agh(&&bar: &u32) {\n    |         ^^^^ expected u32, found reference\n    |\n    = note: expected type `u32`\n               found type `&_`\n+   = help: did you mean `bar: &u32`?\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-38371.rs:31:8\n+  --> $DIR/issue-38371.rs:33:8\n    |\n-31 | fn bgh(&&bar: u32) {\n+33 | fn bgh(&&bar: u32) {\n    |        ^^^^^ expected u32, found reference\n    |\n    = note: expected type `u32`\n               found type `&_`\n \n error[E0529]: expected an array or slice, found `u32`\n-  --> $DIR/issue-38371.rs:34:9\n+  --> $DIR/issue-38371.rs:36:9\n    |\n-34 | fn ugh(&[bar]: &u32) {\n+36 | fn ugh(&[bar]: &u32) {\n    |         ^^^^^ pattern cannot match with input type `u32`\n \n error: aborting due to 4 previous errors"}, {"sha": "31923343b6aa7f116ed25ea71afb839db6d07578", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME(tschottdorf): this test should pass.\n+\n+#![feature(match_default_bindings)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo {\n+    bar: i32,\n+}\n+\n+const FOO: Foo = Foo{bar: 5};\n+\n+fn main() {\n+    let f = Foo{bar:6};\n+\n+    match &f {\n+        FOO => {},\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "0dfd79f356545c2cc57849ad811bf1cd29394c61", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/const.rs:26:9\n+   |\n+26 |         FOO => {},\n+   |         ^^^ expected &Foo, found struct `Foo`\n+   |\n+   = note: expected type `&Foo`\n+              found type `Foo`\n+\n+error: aborting due to previous error\n+"}, {"sha": "58902bf06b314a1c449c417324947a64354b3059", "filename": "src/test/ui/rfc-2005-default-binding-mode/enum.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+enum Wrapper {\n+    Wrap(i32),\n+}\n+\n+use Wrapper::Wrap;\n+\n+pub fn main() {\n+    let Wrap(x) = &Wrap(3);\n+    *x += 1;\n+\n+\n+    if let Some(x) = &Some(3) {\n+        *x += 1;\n+    } else {\n+        panic!();\n+    }\n+\n+    while let Some(x) = &Some(3) {\n+        *x += 1;\n+        break;\n+    }\n+}"}, {"sha": "ad08ae83a49ef92612b9fdbce93c6b9d43b076a4", "filename": "src/test/ui/rfc-2005-default-binding-mode/enum.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,26 @@\n+error[E0594]: cannot assign to immutable borrowed content `*x`\n+  --> $DIR/enum.rs:21:5\n+   |\n+20 |     let Wrap(x) = &Wrap(3);\n+   |              - consider changing this to `x`\n+21 |     *x += 1;\n+   |     ^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to immutable borrowed content `*x`\n+  --> $DIR/enum.rs:25:9\n+   |\n+24 |     if let Some(x) = &Some(3) {\n+   |                 - consider changing this to `x`\n+25 |         *x += 1;\n+   |         ^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to immutable borrowed content `*x`\n+  --> $DIR/enum.rs:31:9\n+   |\n+30 |     while let Some(x) = &Some(3) {\n+   |                    - consider changing this to `x`\n+31 |         *x += 1;\n+   |         ^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b5287b7cccc76dc1a2dc33150d661b94b11e0234", "filename": "src/test/ui/rfc-2005-default-binding-mode/explicit-mut.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+// Verify the binding mode shifts - only when no `&` are auto-dereferenced is the\n+// final default binding mode mutable.\n+\n+fn main() {\n+    match &&Some(5i32) {\n+        Some(n) => {\n+            *n += 1;\n+            let _ = n;\n+        }\n+        None => {},\n+    };\n+\n+    match &mut &Some(5i32) {\n+        Some(n) => {\n+            *n += 1;\n+            let _ = n;\n+        }\n+        None => {},\n+    };\n+\n+    match &&mut Some(5i32) {\n+        Some(n) => {\n+            *n += 1;\n+            let _ = n;\n+        }\n+        None => {},\n+    };\n+}"}, {"sha": "1dbd769373b9da591a596b6bce9231522d7cbc53", "filename": "src/test/ui/rfc-2005-default-binding-mode/explicit-mut.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,26 @@\n+error[E0594]: cannot assign to immutable borrowed content `*n`\n+  --> $DIR/explicit-mut.rs:19:13\n+   |\n+18 |         Some(n) => {\n+   |              - consider changing this to `n`\n+19 |             *n += 1;\n+   |             ^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to immutable borrowed content `*n`\n+  --> $DIR/explicit-mut.rs:27:13\n+   |\n+26 |         Some(n) => {\n+   |              - consider changing this to `n`\n+27 |             *n += 1;\n+   |             ^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to immutable borrowed content `*n`\n+  --> $DIR/explicit-mut.rs:35:13\n+   |\n+34 |         Some(n) => {\n+   |              - consider changing this to `n`\n+35 |             *n += 1;\n+   |             ^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "35f8fbb9b71f7bc3b5a02baa831b3627c021abf3", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+struct Foo {}\n+\n+pub fn main() {\n+    let mut tups = vec![(Foo{}, Foo{})];\n+    // The below desugars to &(ref n, mut m).\n+    for (n, mut m) in &tups {\n+    }\n+}"}, {"sha": "795dffb722a15608b969a1d81eaada7e28bdf9f2", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,10 @@\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/for.rs:18:13\n+   |\n+18 |     for (n, mut m) in &tups {\n+   |          -  ^^^^^ by-move pattern here\n+   |          |\n+   |          both by-ref and by-move used\n+\n+error: aborting due to previous error\n+"}, {"sha": "294d6b88596bf7980ddd7d31b2019e2d5c6fe9c8", "filename": "src/test/ui/rfc-2005-default-binding-mode/issue-44912-or.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+// FIXME(tschottdorf): This should compile. See #44912.\n+\n+pub fn main() {\n+    let x = &Some((3, 3));\n+    let _: &i32 = match x {\n+        Some((x, 3)) | &Some((ref x, 5)) => x,\n+        _ => &5i32,\n+    };\n+}"}, {"sha": "7430dc2c87f950a4eb28acd59e0d5665f3bf2935", "filename": "src/test/ui/rfc-2005-default-binding-mode/issue-44912-or.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fissue-44912-or.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,8 @@\n+error[E0409]: variable `x` is bound in inconsistent ways within the same match arm\n+  --> $DIR/issue-44912-or.rs:18:35\n+   |\n+18 |         Some((x, 3)) | &Some((ref x, 5)) => x,\n+   |               - first binding     ^ bound in different ways\n+\n+error: aborting due to previous error\n+"}, {"sha": "54cee39209ba3b96fdcea4acf2a53f8c10a8a378", "filename": "src/test/ui/rfc-2005-default-binding-mode/lit.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+// FIXME(tschottdorf): we want these to compile, but they don't.\n+\n+fn with_str() {\n+    let s: &'static str = \"abc\";\n+\n+    match &s {\n+            \"abc\" => true,\n+            _ => panic!(),\n+    };\n+}\n+\n+fn with_bytes() {\n+    let s: &'static [u8] = b\"abc\";\n+\n+    match &s {\n+        b\"abc\" => true,\n+        _ => panic!(),\n+    };\n+}\n+\n+pub fn main() {\n+    with_str();\n+    with_bytes();\n+}"}, {"sha": "811d3b8074f53b85a154950c97e9be252815e83a", "filename": "src/test/ui/rfc-2005-default-binding-mode/lit.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/lit.rs:19:13\n+   |\n+19 |             \"abc\" => true,\n+   |             ^^^^^ expected &str, found str\n+   |\n+   = note: expected type `&&str`\n+              found type `&'static str`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/lit.rs:28:9\n+   |\n+28 |         b\"abc\" => true,\n+   |         ^^^^^^ expected &[u8], found array of 3 elements\n+   |\n+   = note: expected type `&&[u8]`\n+              found type `&'static [u8; 3]`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a0134c499bb0164871fa30acfcb0f62ffe0a44c0", "filename": "src/test/ui/rfc-2005-default-binding-mode/no-double-error.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Without caching type lookups in FnCtxt.resolve_ty_and_def_ufcs\n+// the error below would be reported twice (once when checking\n+// for a non-ref pattern, once when processing the pattern).\n+\n+fn main() {\n+    let foo = 22;\n+    match foo {\n+        u32::XXX => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "da065eea897b77233c2f63635ea65c03e4867938", "filename": "src/test/ui/rfc-2005-default-binding-mode/no-double-error.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,8 @@\n+error[E0599]: no associated item named `XXX` found for type `u32` in the current scope\n+  --> $DIR/no-double-error.rs:18:9\n+   |\n+18 |         u32::XXX => { }\n+   |         ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fb87ed72abc3f7ed9250a0874a24c49e42822397", "filename": "src/test/ui/rfc-2005-default-binding-mode/slice.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+#![feature(match_default_bindings)]\n+\n+pub fn main() {\n+    let sl: &[u8] = b\"foo\";\n+\n+    match sl {\n+        [first, remainder..] => {},\n+    };\n+}"}, {"sha": "90a2f75c07fb090eddc9da60cc7a885898173581", "filename": "src/test/ui/rfc-2005-default-binding-mode/slice.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de55b4f077a11780eb0534ef5b41fb0ff765b31d/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr?ref=de55b4f077a11780eb0534ef5b41fb0ff765b31d", "patch": "@@ -0,0 +1,8 @@\n+error[E0004]: non-exhaustive patterns: `&[]` not covered\n+  --> $DIR/slice.rs:17:11\n+   |\n+17 |     match sl {\n+   |           ^^ pattern `&[]` not covered\n+\n+error: aborting due to previous error\n+"}]}