{"sha": "52016a10053bcdd6c52b60cdcab8c316d26f4172", "node_id": "C_kwDOAAsO6NoAKDUyMDE2YTEwMDUzYmNkZDZjNTJiNjBjZGNhYjhjMzE2ZDI2ZjQxNzI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-29T04:34:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-29T04:34:41Z"}, "message": "Rollup merge of #94890 - marmeladema:ip-addr-try-from-bytes, r=joshtriplett\n\nSupport parsing IP addresses from a byte string\n\nFixes #94821\n\nThe goal is to be able to parse addresses from a byte string without requiring to do any utf8 validation. Since internally the parser already works on byte strings, this should be possible and I personally already needed this in the past too.\n\n~~I used the proposed approach from the issue by implementing `TryFrom<&'a [u8]>` for all 6 address types (3 ip address types and 3 socket address types). I believe implementing stable traits for stable types is insta-stable so this will probably need an FCP?~~\n\nSwitched to an unstable inherent method approach called `parse_ascii` as requested.\n\ncc ``````@jyn514``````", "tree": {"sha": "e3013a0518523725850f71ffbdf102aa4cca244a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3013a0518523725850f71ffbdf102aa4cca244a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52016a10053bcdd6c52b60cdcab8c316d26f4172", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDEHhCRBK7hj4Ov3rIwAA28IIAAQA0KChetVtYjm71AgvXZVD\nQx3GJK94kwBNrLTunUXUG5Zdb/mixZteLWqFj/q/wbXc3NI+yvRNDDxYuOFpg+EH\nMOC9/AOZ9wrPAunFWskH/t34LPOg5vRiJ3G0MD5q+A8fKGkKCa7AEeLnIr28LMj8\n/ecdHCwcPlJndtJjmjnzc1X7w93A+UZPkkqQTxlJ4Ig47SfypyOf9WORzvAiM7AE\ncODwyc7622hDPeuO3Eaf5wCxUMNSK4ODZhYzk9N6aYnj9NlIOM+TDKLkCG4PUEGG\nDof9C4uNat9dEqNQfUciVK9Bv0LKf/xWEcIREkE73QJ0lMN3/WWptlFgcO+gqM0=\n=Ftb+\n-----END PGP SIGNATURE-----\n", "payload": "tree e3013a0518523725850f71ffbdf102aa4cca244a\nparent 1ea4efd0656599f824e2567a5b7a95454f701c03\nparent 8bb4b5f44c8b7c811e2075022e5205f927287e0a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661747681 +0200\ncommitter GitHub <noreply@github.com> 1661747681 +0200\n\nRollup merge of #94890 - marmeladema:ip-addr-try-from-bytes, r=joshtriplett\n\nSupport parsing IP addresses from a byte string\n\nFixes #94821\n\nThe goal is to be able to parse addresses from a byte string without requiring to do any utf8 validation. Since internally the parser already works on byte strings, this should be possible and I personally already needed this in the past too.\n\n~~I used the proposed approach from the issue by implementing `TryFrom<&'a [u8]>` for all 6 address types (3 ip address types and 3 socket address types). I believe implementing stable traits for stable types is insta-stable so this will probably need an FCP?~~\n\nSwitched to an unstable inherent method approach called `parse_ascii` as requested.\n\ncc ``````@jyn514``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52016a10053bcdd6c52b60cdcab8c316d26f4172", "html_url": "https://github.com/rust-lang/rust/commit/52016a10053bcdd6c52b60cdcab8c316d26f4172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52016a10053bcdd6c52b60cdcab8c316d26f4172/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ea4efd0656599f824e2567a5b7a95454f701c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4efd0656599f824e2567a5b7a95454f701c03", "html_url": "https://github.com/rust-lang/rust/commit/1ea4efd0656599f824e2567a5b7a95454f701c03"}, {"sha": "8bb4b5f44c8b7c811e2075022e5205f927287e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb4b5f44c8b7c811e2075022e5205f927287e0a", "html_url": "https://github.com/rust-lang/rust/commit/8bb4b5f44c8b7c811e2075022e5205f927287e0a"}], "stats": {"total": 138, "additions": 125, "deletions": 13}, "files": [{"sha": "a38031c48c86251d2c9c0b3e05246de82e3adc10", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 125, "deletions": 13, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/52016a10053bcdd6c52b60cdcab8c316d26f4172/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52016a10053bcdd6c52b60cdcab8c316d26f4172/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=52016a10053bcdd6c52b60cdcab8c316d26f4172", "patch": "@@ -39,8 +39,8 @@ struct Parser<'a> {\n }\n \n impl<'a> Parser<'a> {\n-    fn new(input: &'a str) -> Parser<'a> {\n-        Parser { state: input.as_bytes() }\n+    fn new(input: &'a [u8]) -> Parser<'a> {\n+        Parser { state: input }\n     }\n \n     /// Run a parser, and restore the pre-parse state if it fails.\n@@ -273,56 +273,168 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+impl IpAddr {\n+    /// Parse an IP address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+    /// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    ///\n+    /// assert_eq!(IpAddr::parse_ascii(b\"127.0.0.1\"), Ok(localhost_v4));\n+    /// assert_eq!(IpAddr::parse_ascii(b\"::1\"), Ok(localhost_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+    }\n+}\n+\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromStr for Ipv4Addr {\n-    type Err = AddrParseError;\n-    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+impl Ipv4Addr {\n+    /// Parse an IPv4 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv4Addr::parse_ascii(b\"127.0.0.1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n         // don't try to parse if too long\n-        if s.len() > 15 {\n+        if b.len() > 15 {\n             Err(AddrParseError(AddrKind::Ipv4))\n         } else {\n-            Parser::new(s).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n+            Parser::new(b).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl FromStr for Ipv4Addr {\n+    type Err = AddrParseError;\n+    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Parse an IPv6 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv6Addr::parse_ascii(b\"::1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV4 {\n+    /// Parse an IPv4 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv4Addr, SocketAddrV4};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    ///\n+    /// assert_eq!(SocketAddrV4::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV6 {\n+    /// Parse an IPv6 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv6Addr, SocketAddrV6};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    ///\n+    /// assert_eq!(SocketAddrV6::parse_ascii(b\"[2001:db8::1]:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddr {\n+    /// Parse a socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// let socket_v4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// let socket_v6 = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), 8080);\n+    ///\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket_v4));\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"[::1]:8080\"), Ok(socket_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n "}]}