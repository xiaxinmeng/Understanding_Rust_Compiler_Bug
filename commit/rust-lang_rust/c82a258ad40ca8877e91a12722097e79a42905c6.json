{"sha": "c82a258ad40ca8877e91a12722097e79a42905c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MmEyNThhZDQwY2E4ODc3ZTkxYTEyNzIyMDk3ZTc5YTQyOTA1YzY=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-11-15T20:36:28Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-11-15T20:36:28Z"}, "message": "Turn top-level comments into module docs in MIR visitor", "tree": {"sha": "5173e93e509e23132b055c91bfb371fd5b021223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5173e93e509e23132b055c91bfb371fd5b021223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c82a258ad40ca8877e91a12722097e79a42905c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c82a258ad40ca8877e91a12722097e79a42905c6", "html_url": "https://github.com/rust-lang/rust/commit/c82a258ad40ca8877e91a12722097e79a42905c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c82a258ad40ca8877e91a12722097e79a42905c6/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "603ab5bd6e0ffefafa7411cd8bd23a6ca82bcff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/603ab5bd6e0ffefafa7411cd8bd23a6ca82bcff0", "html_url": "https://github.com/rust-lang/rust/commit/603ab5bd6e0ffefafa7411cd8bd23a6ca82bcff0"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "638dd8ce9706f355a408c8a0438ac801b06224e9", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c82a258ad40ca8877e91a12722097e79a42905c6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82a258ad40ca8877e91a12722097e79a42905c6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=c82a258ad40ca8877e91a12722097e79a42905c6", "patch": "@@ -1,70 +1,70 @@\n+//! # The MIR Visitor\n+//!\n+//! ## Overview\n+//!\n+//! There are two visitors, one for immutable and one for mutable references,\n+//! but both are generated by the following macro. The code is written according\n+//! to the following conventions:\n+//!\n+//! - introduce a `visit_foo` and a `super_foo` method for every MIR type\n+//! - `visit_foo`, by default, calls `super_foo`\n+//! - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n+//!\n+//! This allows you as a user to override `visit_foo` for types are\n+//! interested in, and invoke (within that method) call\n+//! `self.super_foo` to get the default behavior. Just as in an OO\n+//! language, you should never call `super` methods ordinarily except\n+//! in that circumstance.\n+//!\n+//! For the most part, we do not destructure things external to the\n+//! MIR, e.g., types, spans, etc, but simply visit them and stop. This\n+//! avoids duplication with other visitors like `TypeFoldable`.\n+//!\n+//! ## Updating\n+//!\n+//! The code is written in a very deliberate style intended to minimize\n+//! the chance of things being overlooked. You'll notice that we always\n+//! use pattern matching to reference fields and we ensure that all\n+//! matches are exhaustive.\n+//!\n+//! For example, the `super_basic_block_data` method begins like this:\n+//!\n+//! ```rust\n+//! fn super_basic_block_data(&mut self,\n+//!                           block: BasicBlock,\n+//!                           data: & $($mutability)? BasicBlockData<'tcx>) {\n+//!     let BasicBlockData {\n+//!         statements,\n+//!         terminator,\n+//!         is_cleanup: _\n+//!     } = *data;\n+//!\n+//!     for statement in statements {\n+//!         self.visit_statement(block, statement);\n+//!     }\n+//!\n+//!     ...\n+//! }\n+//! ```\n+//!\n+//! Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n+//! rather than writing `data.statements` in the body. This is because if one\n+//! adds a new field to `BasicBlockData`, one will be forced to revise this code,\n+//! and hence one will (hopefully) invoke the correct visit methods (if any).\n+//!\n+//! For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n+//! That means you never write `..` to skip over fields, nor do you write `_`\n+//! to skip over variants in a `match`.\n+//!\n+//! The only place that `_` is acceptable is to match a field (or\n+//! variant argument) that does not require visiting, as in\n+//! `is_cleanup` above.\n+\n use crate::mir::*;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n use rustc_span::Span;\n \n-// # The MIR Visitor\n-//\n-// ## Overview\n-//\n-// There are two visitors, one for immutable and one for mutable references,\n-// but both are generated by the following macro. The code is written according\n-// to the following conventions:\n-//\n-// - introduce a `visit_foo` and a `super_foo` method for every MIR type\n-// - `visit_foo`, by default, calls `super_foo`\n-// - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n-//\n-// This allows you as a user to override `visit_foo` for types are\n-// interested in, and invoke (within that method) call\n-// `self.super_foo` to get the default behavior. Just as in an OO\n-// language, you should never call `super` methods ordinarily except\n-// in that circumstance.\n-//\n-// For the most part, we do not destructure things external to the\n-// MIR, e.g., types, spans, etc, but simply visit them and stop. This\n-// avoids duplication with other visitors like `TypeFoldable`.\n-//\n-// ## Updating\n-//\n-// The code is written in a very deliberate style intended to minimize\n-// the chance of things being overlooked. You'll notice that we always\n-// use pattern matching to reference fields and we ensure that all\n-// matches are exhaustive.\n-//\n-// For example, the `super_basic_block_data` method begins like this:\n-//\n-// ```rust\n-// fn super_basic_block_data(&mut self,\n-//                           block: BasicBlock,\n-//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n-//     let BasicBlockData {\n-//         statements,\n-//         terminator,\n-//         is_cleanup: _\n-//     } = *data;\n-//\n-//     for statement in statements {\n-//         self.visit_statement(block, statement);\n-//     }\n-//\n-//     ...\n-// }\n-// ```\n-//\n-// Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n-// rather than writing `data.statements` in the body. This is because if one\n-// adds a new field to `BasicBlockData`, one will be forced to revise this code,\n-// and hence one will (hopefully) invoke the correct visit methods (if any).\n-//\n-// For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n-// That means you never write `..` to skip over fields, nor do you write `_`\n-// to skip over variants in a `match`.\n-//\n-// The only place that `_` is acceptable is to match a field (or\n-// variant argument) that does not require visiting, as in\n-// `is_cleanup` above.\n-\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {"}]}