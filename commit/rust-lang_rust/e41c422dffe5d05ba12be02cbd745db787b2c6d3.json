{"sha": "e41c422dffe5d05ba12be02cbd745db787b2c6d3", "node_id": "C_kwDOAAsO6NoAKGU0MWM0MjJkZmZlNWQwNWJhMTJiZTAyY2JkNzQ1ZGI3ODdiMmM2ZDM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-05-05T16:33:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-05-22T16:59:35Z"}, "message": "rustc_privacy: Merge three matches on `ItemKind` into one\n\nand remove some more `Option`s as a result", "tree": {"sha": "64739ea4080e8bb2edaf4631e709ab590e1934f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64739ea4080e8bb2edaf4631e709ab590e1934f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41c422dffe5d05ba12be02cbd745db787b2c6d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41c422dffe5d05ba12be02cbd745db787b2c6d3", "html_url": "https://github.com/rust-lang/rust/commit/e41c422dffe5d05ba12be02cbd745db787b2c6d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41c422dffe5d05ba12be02cbd745db787b2c6d3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d831141638f59b7f3aca28de33d089d7e74ac3fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d831141638f59b7f3aca28de33d089d7e74ac3fd", "html_url": "https://github.com/rust-lang/rust/commit/d831141638f59b7f3aca28de33d089d7e74ac3fd"}], "stats": {"total": 173, "additions": 61, "deletions": 112}, "files": [{"sha": "5b06c7fbcbb6eaec553831548cbd4b1e65a4d959", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 61, "deletions": 112, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e41c422dffe5d05ba12be02cbd745db787b2c6d3/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41c422dffe5d05ba12be02cbd745db787b2c6d3/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e41c422dffe5d05ba12be02cbd745db787b2c6d3", "patch": "@@ -474,7 +474,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n     ) {\n         let nominal_vis = self.tcx.local_visibility(def_id);\n@@ -484,23 +484,20 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update_eff_vis(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         nominal_vis: Option<ty::Visibility>,\n         level: Level,\n     ) {\n-        if let Some(inherited_effective_vis) = inherited_effective_vis {\n-            let private_vis =\n-                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n-            if Some(private_vis) != nominal_vis {\n-                self.changed |= self.effective_visibilities.update(\n-                    def_id,\n-                    nominal_vis,\n-                    || private_vis,\n-                    inherited_effective_vis,\n-                    level,\n-                    self.tcx,\n-                );\n-            }\n+        let private_vis = ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n+        if Some(private_vis) != nominal_vis {\n+            self.changed |= self.effective_visibilities.update(\n+                def_id,\n+                nominal_vis,\n+                || private_vis,\n+                inherited_effective_vis,\n+                level,\n+                self.tcx,\n+            );\n         }\n     }\n \n@@ -532,9 +529,13 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n \n     // We have to make sure that the items that macros might reference\n     // are reachable, since they might be exported transitively.\n-    fn update_reachability_from_macro(&mut self, local_def_id: LocalDefId, md: &MacroDef) {\n+    fn update_reachability_from_macro(\n+        &mut self,\n+        local_def_id: LocalDefId,\n+        md: &MacroDef,\n+        macro_ev: EffectiveVisibility,\n+    ) {\n         // Non-opaque macros cannot make other items more accessible than they already are.\n-\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         if attr::find_transparency(attrs, md.macro_rules).0 != Transparency::Opaque {\n@@ -554,8 +555,6 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        // If the macro eff vis is not in the table the condition above will return.\n-        let macro_ev = self.get(local_def_id).unwrap();\n         loop {\n             let changed_reachability =\n                 self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n@@ -620,12 +619,12 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         module: LocalDefId,\n         macro_ev: EffectiveVisibility,\n     ) {\n-        self.update(def_id, Some(macro_ev), Level::Reachable);\n+        self.update(def_id, macro_ev, Level::Reachable);\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, Some(macro_ev), Level::Reachable);\n+                    self.update(def_id, macro_ev, Level::Reachable);\n                 }\n             }\n \n@@ -637,7 +636,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, Some(macro_ev), Level::Reachable);\n+                        self.update(def_id, macro_ev, Level::Reachable);\n                     }\n                 }\n             }\n@@ -701,86 +700,21 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n \n impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_ev = match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n-                    item.owner_id.def_id,\n-                    self.tcx,\n-                    &self.effective_visibilities,\n-                );\n-\n-                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n-                impl_ev\n-            }\n-            _ => self.get(item.owner_id.def_id),\n-        };\n-\n-        // Update levels of nested things.\n+        // Update levels of nested things and mark all items\n+        // in interfaces of reachable items as reachable.\n+        let item_ev = self.get(item.owner_id.def_id);\n         match item.kind {\n-            hir::ItemKind::Enum(ref def, _) => {\n-                for variant in def.variants {\n-                    self.update(variant.def_id, item_ev, Level::Reachable);\n-                    let variant_ev = self.get(variant.def_id);\n-                    if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n-                    }\n-                    for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_ev, Level::Reachable);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Impl(ref impl_) => {\n-                for impl_item_ref in impl_.items {\n-                    let def_id = impl_item_ref.id.owner_id.def_id;\n-                    let nominal_vis =\n-                        impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n-                    self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n-                }\n-            }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_ev, Level::Reachable);\n-                }\n-                for field in def.fields() {\n-                    self.update(field.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n+            // The interface is empty, and no nested items.\n+            hir::ItemKind::Use(..)\n+            | hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::GlobalAsm(..) => {}\n+            // The interface is empty, and all nested items are processed by `visit_item`.\n+            hir::ItemKind::Mod(..) => {}\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n-            }\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n+                if let Some(item_ev) = item_ev {\n+                    self.update_reachability_from_macro(item.owner_id.def_id, macro_def, item_ev);\n                 }\n             }\n-\n-            hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::ExternCrate(..) => {}\n-        }\n-\n-        // Mark all items in interfaces of reachable items as reachable.\n-        match item.kind {\n-            // The interface is empty.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by `visit_item`.\n-            hir::ItemKind::Mod(..) => {}\n-            // Handled in `rustc_resolve`.\n-            hir::ItemKind::Use(..) => {}\n-            // The interface is empty.\n-            hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 // HACK(jynelson): trying to infer the type of `impl trait` breaks `async-std` (and `pub async fn` in general)\n                 // Since rustdoc never needs to do codegen and doesn't care about link-time reachability,\n@@ -797,7 +731,6 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         .ty();\n                 }\n             }\n-            // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n@@ -811,9 +744,10 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n+                        self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n+\n                         let tcx = self.tcx;\n                         let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n-\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -831,34 +765,47 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n-            // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if let Some(item_ev) = item_ev {\n+                if let Some(item_ev) = Option::<EffectiveVisibility>::of_impl(\n+                    item.owner_id.def_id,\n+                    self.tcx,\n+                    &self.effective_visibilities,\n+                ) {\n+                    self.update_eff_vis(item.owner_id.def_id, item_ev, None, Level::Direct);\n+\n                     self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        if let Some(impl_item_ev) = self.get(impl_item_ref.id.owner_id.def_id) {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n-                                .generics()\n-                                .predicates()\n-                                .ty();\n+                        let def_id = impl_item_ref.id.owner_id.def_id;\n+                        let nominal_vis =\n+                            impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n+                        self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n+\n+                        if let Some(impl_item_ev) = self.get(def_id) {\n+                            self.reach(def_id, impl_item_ev).generics().predicates().ty();\n                         }\n                     }\n                 }\n             }\n-\n-            // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(variant.def_id, item_ev, Level::Reachable);\n+                    }\n+\n                     if let Some(variant_ev) = self.get(variant.def_id) {\n+                        if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n+                            self.update(ctor_def_id, variant_ev, Level::Reachable);\n+                        }\n                         for field in variant.data.fields() {\n+                            self.update(field.def_id, variant_ev, Level::Reachable);\n                             self.reach(field.def_id, variant_ev).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n@@ -872,7 +819,6 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     if let Some(foreign_item_ev) = self.get(foreign_item.id.owner_id.def_id) {\n@@ -883,17 +829,20 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n+                        self.update(field.def_id, item_ev, Level::Reachable);\n                         if let Some(field_ev) = self.get(field.def_id) {\n                             self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(ctor_def_id, item_ev, Level::Reachable);\n+                    }\n                     if let Some(ctor_ev) = self.get(ctor_def_id) {\n                         self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n@@ -953,7 +902,7 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            self.ev.update_eff_vis(def_id, Some(self.effective_vis), None, self.level);\n+            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n         }\n         ControlFlow::Continue(())\n     }"}]}