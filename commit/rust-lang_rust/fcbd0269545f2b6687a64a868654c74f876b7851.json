{"sha": "fcbd0269545f2b6687a64a868654c74f876b7851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYmQwMjY5NTQ1ZjJiNjY4N2E2NGE4Njg2NTRjNzRmODc2Yjc4NTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-14T14:06:48Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-14T14:06:48Z"}, "message": "Merge #1120\n\n1120: More trait infrastructure r=matklad a=flodiebold\n\nThis adds enough trait infrastructure to be able to make some deductions about type variables when resolving trait methods, while at the same time doing as little as possible that will be later replaced by Chalk :smile: \r\n\r\nE.g. (as the tests show) if we have\r\n```rust\r\ntrait Trait<T> { fn method(self) -> T }\r\nimpl Trait<u32> for S {}\r\n...\r\nS.method()\r\n```\r\nwe can infer that the return type is `u32`. On the other hand the unification logic is so primitive that we can't handle e.g. `impl<T> Trait<T> for S<T>`.\r\n\r\nIt's all quite hacky, I plan to refactor the parts that will stay, while hopefully the other parts will be replaced soon :slightly_smiling_face: In particular, we need to handle 'containers' (impls and trait defs) more cleanly, and I need to reorganize the method resolution / type inference code...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "cb439cc77b5445f00cda86e932c199cb69ae47d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb439cc77b5445f00cda86e932c199cb69ae47d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcbd0269545f2b6687a64a868654c74f876b7851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd0269545f2b6687a64a868654c74f876b7851", "html_url": "https://github.com/rust-lang/rust/commit/fcbd0269545f2b6687a64a868654c74f876b7851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd0269545f2b6687a64a868654c74f876b7851/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "23b876bc3b00c53ce24b8a99b4f4bf190fc6300e", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b876bc3b00c53ce24b8a99b4f4bf190fc6300e", "html_url": "https://github.com/rust-lang/rust/commit/23b876bc3b00c53ce24b8a99b4f4bf190fc6300e"}, {"sha": "8bcbcc454cbb48b897083c122566c0b4c2b780aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bcbcc454cbb48b897083c122566c0b4c2b780aa", "html_url": "https://github.com/rust-lang/rust/commit/8bcbcc454cbb48b897083c122566c0b4c2b780aa"}], "stats": {"total": 804, "additions": 583, "deletions": 221}, "files": [{"sha": "8f1ed1086c7fdda87b416bc93d7b59d953c147b1", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     expr::{Body, BodySourceMap},\n     ty::InferenceResult,\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n-    generics::GenericParams,\n+    generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n@@ -189,12 +189,12 @@ impl Module {\n         }\n     }\n \n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n         Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n \n-    pub fn declarations(self, db: &impl HirDatabase) -> Vec<ModuleDef> {\n+    pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.krate);\n         def_map[self.module_id]\n             .scope\n@@ -299,10 +299,6 @@ impl Struct {\n             .map(|(id, _)| StructField { parent: (*self).into(), id })\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into(), Namespace::Types)\n     }\n@@ -363,10 +359,6 @@ impl Enum {\n             .map(|(id, _)| EnumVariant { parent: *self, id })\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into(), Namespace::Types)\n     }\n@@ -537,24 +529,32 @@ impl Function {\n         db.infer((*self).into())\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n     /// The containing impl block, if this is a method.\n     pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n         ImplBlock::containing(module_impls, (*self).into())\n     }\n \n+    /// The containing trait, if this is a trait method definition.\n+    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    }\n+\n+    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+        if let Some(impl_block) = self.impl_block(db) {\n+            Some(impl_block.into())\n+        } else if let Some(trait_) = self.parent_trait(db) {\n+            Some(trait_.into())\n+        } else {\n+            None\n+        }\n+    }\n+\n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n-        let r = self\n-            .impl_block(db)\n-            .map(|ib| ib.resolver(db))\n-            .unwrap_or_else(|| self.module(db).resolver(db));\n+        let r = self.container(db).map_or_else(|| self.module(db).resolver(db), |c| c.resolver(db));\n         // ...and add generic params, if present\n         let p = self.generic_params(db);\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n@@ -684,10 +684,6 @@ impl Trait {\n         self.id.module(db)\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         self.trait_data(db).name().clone()\n     }\n@@ -699,6 +695,14 @@ impl Trait {\n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n         db.trait_data(self)\n     }\n+\n+    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+        let r = self.module(db).resolver(db);\n+        // add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n+        r\n+    }\n }\n \n impl Docs for Trait {\n@@ -717,10 +721,6 @@ impl TypeAlias {\n         self.id.source(db)\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n     pub fn module(&self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n@@ -731,6 +731,21 @@ impl TypeAlias {\n         ImplBlock::containing(module_impls, (*self).into())\n     }\n \n+    /// The containing trait, if this is a trait method definition.\n+    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    }\n+\n+    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+        if let Some(impl_block) = self.impl_block(db) {\n+            Some(impl_block.into())\n+        } else if let Some(trait_) = self.parent_trait(db) {\n+            Some(trait_.into())\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn type_ref(self, db: &impl DefDatabase) -> Arc<TypeRef> {\n         db.type_alias_ref(self)\n     }\n@@ -754,3 +769,18 @@ impl Docs for TypeAlias {\n         docs_from_ast(&*self.source(db).1)\n     }\n }\n+\n+pub enum Container {\n+    Trait(Trait),\n+    ImplBlock(ImplBlock),\n+}\n+impl_froms!(Container: Trait, ImplBlock);\n+\n+impl Container {\n+    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            Container::Trait(trait_) => trait_.resolver(db),\n+            Container::ImplBlock(impl_block) => impl_block.resolver(db),\n+        }\n+    }\n+}"}, {"sha": "18627bbc24d083b83ffad8eb0852cf02bbfa994a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -53,6 +53,9 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n     fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n \n+    #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n+    fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n+\n     #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n@@ -128,8 +131,8 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n-    #[salsa::invoke(crate::ty::method_resolution::implements)]\n-    fn implements(&self, trait_ref: TraitRef) -> bool;\n+    #[salsa::invoke(crate::ty::traits::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> Option<crate::ty::traits::Solution>;\n }\n \n #[test]"}, {"sha": "5625c2459f56f11b41f07bb5325333aaa3f3d2dd", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::ast::{self, NameOwner, TypeParamsOwner};\n \n use crate::{\n     db::DefDatabase,\n-    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock\n+    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -27,6 +27,7 @@ pub struct GenericParams {\n     pub(crate) params: Vec<GenericParam>,\n }\n \n+// FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n     Function(Function),\n@@ -45,18 +46,22 @@ impl GenericParams {\n     ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n         let parent = match def {\n-            GenericDef::Function(it) => it.impl_block(db),\n-            GenericDef::TypeAlias(it) => it.impl_block(db),\n+            GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n+            GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n             GenericDef::Struct(_) | GenericDef::Enum(_) | GenericDef::Trait(_) => None,\n             GenericDef::ImplBlock(_) => None,\n         };\n-        generics.parent_params = parent.map(|p| p.generic_params(db));\n+        generics.parent_params = parent.map(|p| db.generic_params(p));\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n             GenericDef::Function(it) => generics.fill(&*it.source(db).1, start),\n             GenericDef::Struct(it) => generics.fill(&*it.source(db).1, start),\n             GenericDef::Enum(it) => generics.fill(&*it.source(db).1, start),\n-            GenericDef::Trait(it) => generics.fill(&*it.source(db).1, start),\n+            GenericDef::Trait(it) => {\n+                // traits get the Self type as an implicit first type parameter\n+                generics.params.push(GenericParam { idx: start, name: Name::self_type() });\n+                generics.fill(&*it.source(db).1, start + 1);\n+            }\n             GenericDef::TypeAlias(it) => generics.fill(&*it.source(db).1, start),\n             GenericDef::ImplBlock(it) => generics.fill(&*it.source(db).1, start),\n         }\n@@ -104,3 +109,25 @@ impl GenericParams {\n         vec\n     }\n }\n+\n+impl From<Container> for GenericDef {\n+    fn from(c: Container) -> Self {\n+        match c {\n+            Container::Trait(trait_) => trait_.into(),\n+            Container::ImplBlock(impl_block) => impl_block.into(),\n+        }\n+    }\n+}\n+\n+pub trait HasGenericParams {\n+    fn generic_params(self, db: &impl DefDatabase) -> Arc<GenericParams>;\n+}\n+\n+impl<T> HasGenericParams for T\n+where\n+    T: Into<GenericDef>,\n+{\n+    fn generic_params(self, db: &impl DefDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.into())\n+    }\n+}"}, {"sha": "a8a466e43ee839edc3df6e513c1912e10fb38da8", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -9,16 +9,15 @@ use ra_syntax::{\n \n use crate::{\n     Const, TypeAlias, Function, HirFileId,\n-    HirDatabase, DefDatabase,\n-    ModuleDef, Trait, Resolution,\n+    HirDatabase, DefDatabase, TraitRef,\n     type_ref::TypeRef,\n     ids::LocationCtx,\n     resolve::Resolver,\n-    ty::Ty, generics::GenericParams,\n+    ty::Ty,\n+    generics::HasGenericParams,\n+    code_model_api::{Module, ModuleSource}\n };\n \n-use crate::code_model_api::{Module, ModuleSource};\n-\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImplSourceMap {\n     map: ArenaMap<ImplId, AstPtr<ast::ImplBlock>>,\n@@ -73,7 +72,7 @@ impl ImplBlock {\n         self.module\n     }\n \n-    pub fn target_trait_ref(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n+    pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.impls_in_module(self.module).impls[self.impl_id].target_trait().cloned()\n     }\n \n@@ -85,27 +84,16 @@ impl ImplBlock {\n         Ty::from_hir(db, &self.resolver(db), &self.target_type(db))\n     }\n \n-    pub fn target_trait(&self, db: &impl HirDatabase) -> Option<Trait> {\n-        if let Some(TypeRef::Path(path)) = self.target_trait_ref(db) {\n-            let resolver = self.resolver(db);\n-            if let Some(Resolution::Def(ModuleDef::Trait(tr))) =\n-                resolver.resolve_path(db, &path).take_types()\n-            {\n-                return Some(tr);\n-            }\n-        }\n-        None\n+    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        let target_ty = self.target_ty(db);\n+        TraitRef::from_hir(db, &self.resolver(db), &self.target_trait(db)?, Some(target_ty))\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<ImplItem> {\n         db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n     }\n \n-    pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params((*self).into())\n-    }\n-\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module().resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);"}, {"sha": "9292de1b564d19d1ca1bac06c0d4dc1ce4dfbbbb", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -61,12 +61,13 @@ pub use self::{\n     source_id::{AstIdMap, ErasedFileAstId},\n     ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc},\n     nameres::{PerNs, Namespace, ImportId},\n-    ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay, CallableDef},\n+    ty::{Ty, ApplicationTy, TypeCtor, TraitRef, Substs, display::HirDisplay, CallableDef},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,\n     expr::ExprScopes,\n     resolve::Resolution,\n+    generics::{GenericParams, GenericParam, HasGenericParams},\n     source_binder::{SourceAnalyzer, PathResolution, ScopeEntryWithSyntax},\n };\n \n@@ -78,5 +79,5 @@ pub use self::code_model_api::{\n     Function, FnSignature,\n     StructField, FieldSource,\n     Static, Const, ConstSignature,\n-    Trait, TypeAlias,\n+    Trait, TypeAlias, Container,\n };"}, {"sha": "15f0977b718b4ed2d114dd35e3039e3507b3ddf8", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -1,10 +1,11 @@\n //! HIR for trait definitions.\n \n use std::sync::Arc;\n+use rustc_hash::FxHashMap;\n \n use ra_syntax::ast::{self, NameOwner};\n \n-use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName};\n+use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName, Module};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n@@ -49,4 +50,34 @@ pub enum TraitItem {\n     TypeAlias(TypeAlias),\n     // Existential\n }\n+// FIXME: not every function, ... is actually a trait item. maybe we should make\n+// sure that you can only turn actual trait items into TraitItems. This would\n+// require not implementing From, and instead having some checked way of\n+// casting them.\n impl_froms!(TraitItem: Function, Const, TypeAlias);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitItemsIndex {\n+    traits_by_def: FxHashMap<TraitItem, Trait>,\n+}\n+\n+impl TraitItemsIndex {\n+    pub(crate) fn trait_items_index(db: &impl DefDatabase, module: Module) -> TraitItemsIndex {\n+        let mut index = TraitItemsIndex { traits_by_def: FxHashMap::default() };\n+        for decl in module.declarations(db) {\n+            match decl {\n+                crate::ModuleDef::Trait(tr) => {\n+                    for item in tr.trait_data(db).items() {\n+                        index.traits_by_def.insert(*item, tr);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        index\n+    }\n+\n+    pub(crate) fn get_parent_trait(&self, item: TraitItem) -> Option<Trait> {\n+        self.traits_by_def.get(&item).cloned()\n+    }\n+}"}, {"sha": "12e10c75187c62de3e9ebdd17ce3e47f4f4d7f54", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -5,6 +5,7 @@ mod autoderef;\n pub(crate) mod primitive;\n #[cfg(test)]\n mod tests;\n+pub(crate) mod traits;\n pub(crate) mod method_resolution;\n mod op;\n mod lower;\n@@ -145,6 +146,10 @@ impl Substs {\n         Substs(Arc::new([ty]))\n     }\n \n+    pub fn prefix(&self, n: usize) -> Substs {\n+        Substs(self.0.iter().cloned().take(n).collect::<Vec<_>>().into())\n+    }\n+\n     pub fn iter(&self) -> impl Iterator<Item = &Ty> {\n         self.0.iter()\n     }\n@@ -170,6 +175,12 @@ impl Substs {\n     }\n }\n \n+impl From<Vec<Ty>> for Substs {\n+    fn from(v: Vec<Ty>) -> Self {\n+        Substs(v.into())\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -210,6 +221,14 @@ impl FnSig {\n         &self.params_and_return[self.params_and_return.len() - 1]\n     }\n \n+    /// Applies the given substitutions to all types in this signature and\n+    /// returns the result.\n+    pub fn subst(&self, substs: &Substs) -> FnSig {\n+        let result: Vec<_> =\n+            self.params_and_return.iter().map(|ty| ty.clone().subst(substs)).collect();\n+        FnSig { params_and_return: result.into() }\n+    }\n+\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.params_and_return.iter().cloned().collect();\n@@ -309,6 +328,20 @@ impl Ty {\n         }\n     }\n \n+    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnPtr => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnDef(def) => {\n+                    let sig = db.callable_item_signature(def);\n+                    Some(sig.subst(&a_ty.parameters))\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n     /// If this is a type with type parameters (an ADT or function), replaces\n     /// the `Substs` for these type parameters with the given ones. (So e.g. if\n     /// `self` is `Option<_>` and the substs contain `u32`, we'll have"}, {"sha": "651a78fe52b704690f1d5833372a3d022b2790b1", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 147, "deletions": 96, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -20,9 +20,9 @@ use std::sync::Arc;\n use std::mem;\n \n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n-use ra_arena::map::ArenaMap;\n use rustc_hash::FxHashMap;\n \n+use ra_arena::map::ArenaMap;\n use test_utils::tested_by;\n \n use crate::{\n@@ -33,15 +33,18 @@ use crate::{\n     ImplItem,\n     type_ref::{TypeRef, Mutability},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat,Array, self},\n-    generics::GenericParams,\n+    generics::{GenericParams, HasGenericParams},\n     path::{GenericArgs, GenericArg},\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n     nameres::Namespace,\n-    ty::infer::diagnostics::InferenceDiagnostic,\n     diagnostics::DiagnosticSink,\n };\n-use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n+use super::{\n+    Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n+    traits::{ Solution, Obligation, Guidance},\n+};\n+use self::diagnostics::InferenceDiagnostic;\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -153,6 +156,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    obligations: Vec<Obligation>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n@@ -173,6 +177,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             type_of_pat: ArenaMap::default(),\n             diagnostics: Vec::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n+            obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             body,\n@@ -181,6 +186,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n+        // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut tv_stack = Vec::new();\n         let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n         for ty in expr_types.values_mut() {\n@@ -311,11 +317,49 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n     }\n \n+    fn resolve_obligations_as_possible(&mut self) {\n+        let obligations = mem::replace(&mut self.obligations, Vec::new());\n+        for obligation in obligations {\n+            // FIXME resolve types in the obligation first\n+            let (solution, var_mapping) = match &obligation {\n+                Obligation::Trait(tr) => {\n+                    let (tr, var_mapping) = super::traits::canonicalize(tr.clone());\n+                    (self.db.implements(tr), var_mapping)\n+                }\n+            };\n+            match solution {\n+                Some(Solution::Unique(substs)) => {\n+                    for (i, subst) in substs.0.iter().enumerate() {\n+                        let uncanonical = var_mapping[i];\n+                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n+                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n+                    }\n+                }\n+                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                    for (i, subst) in substs.0.iter().enumerate() {\n+                        let uncanonical = var_mapping[i];\n+                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n+                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n+                    }\n+                    self.obligations.push(obligation);\n+                }\n+                Some(_) => {\n+                    self.obligations.push(obligation);\n+                }\n+                None => {\n+                    // FIXME obligation cannot be fulfilled => diagnostic\n+                }\n+            }\n+        }\n+    }\n+\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        self.resolve_obligations_as_possible();\n+\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n@@ -420,6 +464,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for segment in &path.segments[remaining_index..] {\n             let ty = match resolved {\n                 Resolution::Def(def) => {\n+                    // FIXME resolve associated items from traits as well\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n@@ -709,13 +754,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn substs_for_method_call(\n         &mut self,\n         def_generics: Option<Arc<GenericParams>>,\n-        generic_args: &Option<GenericArgs>,\n+        generic_args: Option<&GenericArgs>,\n+        receiver_ty: &Ty,\n     ) -> Substs {\n         let (parent_param_count, param_count) =\n-            def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n         let mut substs = Vec::with_capacity(parent_param_count + param_count);\n-        for _ in 0..parent_param_count {\n-            substs.push(Ty::Unknown);\n+        // Parent arguments are unknown, except for the receiver type\n+        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n+            for param in &parent_generics.params {\n+                if param.name.as_known_name() == Some(crate::KnownName::SelfType) {\n+                    substs.push(receiver_ty.clone());\n+                } else {\n+                    substs.push(Ty::Unknown);\n+                }\n+            }\n         }\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n@@ -737,6 +790,83 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Substs(substs.into())\n     }\n \n+    fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n+        match callable_ty {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnDef(def) => {\n+                    // add obligation for trait implementation, if this is a trait method\n+                    // FIXME also register obligations from where clauses from the trait or impl and method\n+                    match def {\n+                        CallableDef::Function(f) => {\n+                            if let Some(trait_) = f.parent_trait(self.db) {\n+                                // construct a TraitDef\n+                                let substs = a_ty.parameters.prefix(\n+                                    trait_.generic_params(self.db).count_params_including_parent(),\n+                                );\n+                                self.obligations\n+                                    .push(Obligation::Trait(TraitRef { trait_, substs }));\n+                            }\n+                        }\n+                        CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n+                    }\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    fn infer_method_call(\n+        &mut self,\n+        tgt_expr: ExprId,\n+        receiver: ExprId,\n+        args: &[ExprId],\n+        method_name: &Name,\n+        generic_args: Option<&GenericArgs>,\n+    ) -> Ty {\n+        let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n+        let resolved = receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n+        let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n+            Some((ty, func)) => {\n+                self.write_method_resolution(tgt_expr, func);\n+                (\n+                    ty,\n+                    self.db.type_for_def(func.into(), Namespace::Values),\n+                    Some(func.generic_params(self.db)),\n+                )\n+            }\n+            None => (receiver_ty, Ty::Unknown, None),\n+        };\n+        let substs =\n+            self.substs_for_method_call(def_generics.clone(), generic_args, &derefed_receiver_ty);\n+        let method_ty = method_ty.apply_substs(substs);\n+        let method_ty = self.insert_type_vars(method_ty);\n+        self.register_obligations_for_call(&method_ty);\n+        let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n+            Some(sig) => {\n+                if !sig.params().is_empty() {\n+                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n+                } else {\n+                    (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                }\n+            }\n+            None => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+        };\n+        // Apply autoref so the below unification works correctly\n+        // FIXME: return correct autorefs from lookup_method\n+        let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n+            Some((_, mutability)) => Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty),\n+            _ => derefed_receiver_ty,\n+        };\n+        self.unify(&expected_receiver_ty, &actual_receiver_ty);\n+\n+        let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+        for (arg, param) in args.iter().zip(param_iter) {\n+            self.infer_expr(*arg, &Expectation::has_type(param));\n+        }\n+        ret_ty\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n@@ -793,102 +923,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::FnPtr => {\n-                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n-                            (sig.params().to_vec(), sig.ret().clone())\n-                        }\n-                        TypeCtor::FnDef(def) => {\n-                            let sig = self.db.callable_item_signature(def);\n-                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n-                            let param_tys = sig\n-                                .params()\n-                                .iter()\n-                                .map(|ty| ty.clone().subst(&a_ty.parameters))\n-                                .collect();\n-                            (param_tys, ret_ty)\n-                        }\n-                        _ => (Vec::new(), Ty::Unknown),\n-                    },\n-                    _ => {\n-                        // not callable\n-                        // FIXME report an error?\n+                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n+                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n+                    None => {\n+                        // Not callable\n+                        // FIXME: report an error\n                         (Vec::new(), Ty::Unknown)\n                     }\n                 };\n+                // FIXME register obligations from where clauses from the function\n                 let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n                 for (arg, param) in args.iter().zip(param_iter) {\n                     self.infer_expr(*arg, &Expectation::has_type(param));\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall { receiver, args, method_name, generic_args } => {\n-                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved =\n-                    receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n-                let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n-                    Some((ty, func)) => {\n-                        self.write_method_resolution(tgt_expr, func);\n-                        (\n-                            ty,\n-                            self.db.type_for_def(func.into(), Namespace::Values),\n-                            Some(func.generic_params(self.db)),\n-                        )\n-                    }\n-                    None => (receiver_ty, Ty::Unknown, None),\n-                };\n-                let substs = self.substs_for_method_call(def_generics, generic_args);\n-                let method_ty = method_ty.apply_substs(substs);\n-                let method_ty = self.insert_type_vars(method_ty);\n-                let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::FnPtr => {\n-                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n-                            if !sig.params().is_empty() {\n-                                (\n-                                    sig.params()[0].clone(),\n-                                    sig.params()[1..].to_vec(),\n-                                    sig.ret().clone(),\n-                                )\n-                            } else {\n-                                (Ty::Unknown, Vec::new(), sig.ret().clone())\n-                            }\n-                        }\n-                        TypeCtor::FnDef(def) => {\n-                            let sig = self.db.callable_item_signature(def);\n-                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n-\n-                            if !sig.params().is_empty() {\n-                                let mut params_iter = sig\n-                                    .params()\n-                                    .iter()\n-                                    .map(|ty| ty.clone().subst(&a_ty.parameters));\n-                                let receiver_ty = params_iter.next().unwrap();\n-                                (receiver_ty, params_iter.collect(), ret_ty)\n-                            } else {\n-                                (Ty::Unknown, Vec::new(), ret_ty)\n-                            }\n-                        }\n-                        _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-                    },\n-                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-                };\n-                // Apply autoref so the below unification works correctly\n-                let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-                    Some((_, mutability)) => {\n-                        Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty)\n-                    }\n-                    _ => derefed_receiver_ty,\n-                };\n-                self.unify(&expected_receiver_ty, &actual_receiver_ty);\n-\n-                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n-                }\n-                ret_ty\n-            }\n+            Expr::MethodCall { receiver, args, method_name, generic_args } => self\n+                .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n                 let expected = if expected.ty == Ty::Unknown {\n                     Expectation::has_type(self.new_type_var())\n@@ -1180,7 +1231,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(u32);\n+pub struct TypeVarId(pub(super) u32);\n \n impl UnifyKey for TypeVarId {\n     type Value = TypeVarValue;"}, {"sha": "7fac084ce14550dbfc4f5aa3dc614629d498d9ed", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 82, "deletions": 27, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -5,6 +5,7 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::iter;\n \n use crate::{\n     Function, Struct, StructField, Enum, EnumVariant, Path,\n@@ -15,11 +16,11 @@ use crate::{\n     name::KnownName,\n     nameres::Namespace,\n     resolve::{Resolver, Resolution},\n-    path::{ PathSegment, GenericArg},\n-    generics::GenericParams,\n-    adt::VariantDef,\n+    path::{PathSegment, GenericArg},\n+    generics::{GenericParams, HasGenericParams},\n+    adt::VariantDef, Trait\n };\n-use super::{Ty, primitive, FnSig, Substs, TypeCtor};\n+use super::{Ty, primitive, FnSig, Substs, TypeCtor, TraitRef};\n \n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n@@ -115,7 +116,6 @@ impl Ty {\n         segment: &PathSegment,\n         resolved: TypableDef,\n     ) -> Substs {\n-        let mut substs = Vec::new();\n         let def_generics = match resolved {\n             TypableDef::Function(func) => func.generic_params(db),\n             TypableDef::Struct(s) => s.generic_params(db),\n@@ -124,28 +124,7 @@ impl Ty {\n             TypableDef::TypeAlias(t) => t.generic_params(db),\n             TypableDef::Const(_) | TypableDef::Static(_) => GenericParams::default().into(),\n         };\n-        let parent_param_count = def_generics.count_parent_params();\n-        substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n-        if let Some(generic_args) = &segment.args_and_bindings {\n-            // if args are provided, it should be all of them, but we can't rely on that\n-            let param_count = def_generics.params.len();\n-            for arg in generic_args.args.iter().take(param_count) {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        let ty = Ty::from_hir(db, resolver, type_ref);\n-                        substs.push(ty);\n-                    }\n-                }\n-            }\n-        }\n-        // add placeholders for args that were not provided\n-        // FIXME: handle defaults\n-        let supplied_params = substs.len();\n-        for _ in supplied_params..def_generics.count_params_including_parent() {\n-            substs.push(Ty::Unknown);\n-        }\n-        assert_eq!(substs.len(), def_generics.count_params_including_parent());\n-        Substs(substs.into())\n+        substs_from_path_segment(db, resolver, segment, &def_generics, false)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -185,6 +164,82 @@ impl Ty {\n     }\n }\n \n+pub(super) fn substs_from_path_segment(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    segment: &PathSegment,\n+    def_generics: &GenericParams,\n+    add_self_param: bool,\n+) -> Substs {\n+    let mut substs = Vec::new();\n+    let parent_param_count = def_generics.count_parent_params();\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n+    if add_self_param {\n+        // FIXME this add_self_param argument is kind of a hack: Traits have the\n+        // Self type as an implicit first type parameter, but it can't be\n+        // actually provided in the type arguments\n+        // (well, actually sometimes it can, in the form of type-relative paths: `<Foo as Default>::default()`)\n+        substs.push(Ty::Unknown);\n+    }\n+    if let Some(generic_args) = &segment.args_and_bindings {\n+        // if args are provided, it should be all of them, but we can't rely on that\n+        let self_param_correction = if add_self_param { 1 } else { 0 };\n+        let param_count = def_generics.params.len() - self_param_correction;\n+        for arg in generic_args.args.iter().take(param_count) {\n+            match arg {\n+                GenericArg::Type(type_ref) => {\n+                    let ty = Ty::from_hir(db, resolver, type_ref);\n+                    substs.push(ty);\n+                }\n+            }\n+        }\n+    }\n+    // add placeholders for args that were not provided\n+    // FIXME: handle defaults\n+    let supplied_params = substs.len();\n+    for _ in supplied_params..def_generics.count_params_including_parent() {\n+        substs.push(Ty::Unknown);\n+    }\n+    assert_eq!(substs.len(), def_generics.count_params_including_parent());\n+    Substs(substs.into())\n+}\n+\n+impl TraitRef {\n+    pub(crate) fn from_hir(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        type_ref: &TypeRef,\n+        explicit_self_ty: Option<Ty>,\n+    ) -> Option<Self> {\n+        let path = match type_ref {\n+            TypeRef::Path(path) => path,\n+            _ => return None,\n+        };\n+        let resolved = match resolver.resolve_path(db, &path).take_types()? {\n+            Resolution::Def(ModuleDef::Trait(tr)) => tr,\n+            _ => return None,\n+        };\n+        let mut substs = Self::substs_from_path(db, resolver, path, resolved);\n+        if let Some(self_ty) = explicit_self_ty {\n+            // FIXME this could be nicer\n+            let mut substs_vec = substs.0.to_vec();\n+            substs_vec[0] = self_ty;\n+            substs.0 = substs_vec.into();\n+        }\n+        Some(TraitRef { trait_: resolved, substs })\n+    }\n+\n+    fn substs_from_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        path: &Path,\n+        resolved: Trait,\n+    ) -> Substs {\n+        let segment = path.segments.last().expect(\"path should have at least one segment\");\n+        substs_from_path_segment(db, resolver, segment, &resolved.generic_params(db), true)\n+    }\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values"}, {"sha": "6b7918187a21dc3bbe5265824e26812de2edf637", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -10,10 +10,12 @@ use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{Ty, TypeCtor},\n-    nameres::CrateModuleId, resolve::Resolver, traits::TraitItem\n-\n+    nameres::CrateModuleId,\n+    resolve::Resolver,\n+    traits::TraitItem,\n+    generics::HasGenericParams,\n };\n-use super::{ TraitRef, Substs};\n+use super::{TraitRef, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -72,9 +74,9 @@ impl CrateImplBlocks {\n \n             let target_ty = impl_block.target_ty(db);\n \n-            if let Some(tr) = impl_block.target_trait(db) {\n+            if let Some(tr) = impl_block.target_trait_ref(db) {\n                 self.impls_by_trait\n-                    .entry(tr)\n+                    .entry(tr.trait_)\n                     .or_insert_with(Vec::new)\n                     .push((module.module_id, impl_id));\n             } else {\n@@ -108,20 +110,6 @@ impl CrateImplBlocks {\n     }\n }\n \n-/// Rudimentary check whether an impl exists for a given type and trait; this\n-/// will actually be done by chalk.\n-pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n-    // FIXME use all trait impls in the whole crate graph\n-    let krate = trait_ref.trait_.module(db).krate(db);\n-    let krate = match krate {\n-        Some(krate) => krate,\n-        None => return false,\n-    };\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n-    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n-}\n-\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -142,6 +130,7 @@ impl Ty {\n         resolver: &Resolver,\n     ) -> Option<(Ty, Function)> {\n         // FIXME: trait methods should be used before autoderefs\n+        // (and we need to do autoderefs for trait method calls as well)\n         let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n@@ -174,22 +163,15 @@ impl Ty {\n                 }\n             }\n         }\n-        // FIXME:\n-        //  - we might not actually be able to determine fully that the type\n-        //    implements the trait here; it's enough if we (well, Chalk) determine\n-        //    that it's possible.\n-        //  - when the trait method is picked, we need to register an\n-        //    'obligation' somewhere so that we later check that it's really\n-        //    implemented\n-        //  - both points go for additional requirements from where clauses as\n-        //    well (in fact, the 'implements' condition could just be considered a\n-        //    'where Self: Trait' clause)\n         candidates.retain(|(t, _m)| {\n-            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n-            db.implements(trait_ref)\n+            let trait_ref =\n+                TraitRef { trait_: *t, substs: fresh_substs_for_trait(db, *t, self.clone()) };\n+            let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n+            db.implements(trait_ref).is_some()\n         });\n         // FIXME if there's multiple candidates here, that's an ambiguity error\n         let (_chosen_trait, chosen_method) = candidates.first()?;\n+        // FIXME return correct receiver type\n         Some((self.clone(), *chosen_method))\n     }\n \n@@ -252,3 +234,17 @@ impl Ty {\n         None\n     }\n }\n+\n+/// This creates Substs for a trait with the given Self type and type variables\n+/// for all other parameters. This is kind of a hack since these aren't 'real'\n+/// type variables; the resulting trait reference is just used for the\n+/// preliminary method candidate check.\n+fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n+    let mut substs = Vec::new();\n+    let generics = tr.generic_params(db);\n+    substs.push(self_ty);\n+    substs.extend(generics.params_including_parent().into_iter().skip(1).enumerate().map(\n+        |(i, _p)| Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(i as u32))),\n+    ));\n+    substs.into()\n+}"}, {"sha": "291bc9ae52a2e91f4e8a38f204bab1f3f9988f52", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -1926,8 +1926,8 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[31; 35) 'self': &{unknown}\n-[110; 114) 'self': &{unknown}\n+[31; 35) 'self': &Self\n+[110; 114) 'self': &Self\n [170; 228) '{     ...i128 }': ()\n [176; 178) 'S1': S1\n [176; 187) 'S1.method()': u32\n@@ -1972,8 +1972,8 @@ mod bar_test {\n }\n \"#),\n         @r###\"\n-[63; 67) 'self': &{unknown}\n-[169; 173) 'self': &{unknown}\n+[63; 67) 'self': &Self\n+[169; 173) 'self': &Self\n [300; 337) '{     ...     }': ()\n [310; 311) 'S': S\n [310; 320) 'S.method()': u32\n@@ -1998,10 +1998,45 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[33; 37) 'self': &{unknown}\n+[33; 37) 'self': &Self\n [92; 111) '{     ...d(); }': ()\n [98; 99) 'S': S\n-[98; 108) 'S.method()': {unknown}\"###\n+[98; 108) 'S.method()': u32\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_more_params() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1(); // u8, u16, u32\n+    S1.method2(); // u32, u16, u8\n+    S2.method1(); // i8, i16, {unknown}\n+    S2.method2(); // {unknown}, i16, i8\n+}\n+\"#),\n+        @r###\"\n+[43; 47) 'self': &Self\n+[82; 86) 'self': &Self\n+[210; 361) '{     ..., i8 }': ()\n+[216; 218) 'S1': S1\n+[216; 228) 'S1.method1()': (u8, u16, u32)\n+[250; 252) 'S1': S1\n+[250; 262) 'S1.method2()': (u32, u16, u8)\n+[284; 286) 'S2': S2\n+[284; 296) 'S2.method1()': (i8, i16, {unknown})\n+[324; 326) 'S2': S2\n+[324; 336) 'S2.method2()': ({unknown}, i16, i8)\"###\n     );\n }\n \n@@ -2020,7 +2055,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[33; 37) 'self': &{unknown}\n+[33; 37) 'self': &Self\n [102; 127) '{     ...d(); }': ()\n [108; 109) 'S': S<u32>(T) -> S<T>\n [108; 115) 'S(1u32)': S<u32>\n@@ -2168,7 +2203,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[29; 33) 'self': {unknown}\n+[29; 33) 'self': Self\n [107; 198) '{     ...(S); }': ()\n [117; 118) 'x': u32\n [126; 127) 'S': S"}, {"sha": "f8c3958bd85a1d7f2edda8fecf4fb646b98264cc", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -0,0 +1,112 @@\n+//! Stuff that will probably mostly replaced by Chalk.\n+use std::collections::HashMap;\n+\n+use crate::db::HirDatabase;\n+use super::{ TraitRef, Substs, infer::{ TypeVarId, InferTy}, Ty};\n+\n+// Copied (and simplified) from Chalk\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// A (possible) solution for a proposed goal. Usually packaged in a `Result`,\n+/// where `Err` represents definite *failure* to prove a goal.\n+pub enum Solution {\n+    /// The goal indeed holds, and there is a unique value for all existential\n+    /// variables.\n+    Unique(Substs),\n+\n+    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n+    /// for type inference.\n+    Ambig(Guidance),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// When a goal holds ambiguously (e.g., because there are multiple possible\n+/// solutions), we issue a set of *guidance* back to type inference.\n+pub enum Guidance {\n+    /// The existential variables *must* have the given values if the goal is\n+    /// ever to hold, but that alone isn't enough to guarantee the goal will\n+    /// actually hold.\n+    Definite(Substs),\n+\n+    /// There are multiple plausible values for the existentials, but the ones\n+    /// here are suggested as the preferred choice heuristically. These should\n+    /// be used for inference fallback only.\n+    Suggested(Substs),\n+\n+    /// There's no useful information to feed back to type inference\n+    Unknown,\n+}\n+\n+/// Something that needs to be proven (by Chalk) during type checking, e.g. that\n+/// a certain type implements a certain trait. Proving the Obligation might\n+/// result in additional information about inference variables.\n+///\n+/// This might be handled by Chalk when we integrate it?\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum Obligation {\n+    /// Prove that a certain type implements a trait (the type is the `Self` type\n+    /// parameter to the `TraitRef`).\n+    Trait(TraitRef),\n+}\n+\n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> Option<Solution> {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return None,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks\n+        .find_map(|impl_block| unify_trait_refs(&trait_ref, &impl_block.target_trait_ref(db)?))\n+}\n+\n+pub(super) fn canonicalize(trait_ref: TraitRef) -> (TraitRef, Vec<TypeVarId>) {\n+    let mut canonical = HashMap::new(); // mapping uncanonical -> canonical\n+    let mut uncanonical = Vec::new(); // mapping canonical -> uncanonical (which is dense)\n+    let mut substs = trait_ref.substs.0.to_vec();\n+    for ty in &mut substs {\n+        ty.walk_mut(&mut |ty| match ty {\n+            Ty::Infer(InferTy::TypeVar(tv)) => {\n+                let tv: &mut TypeVarId = tv;\n+                *tv = *canonical.entry(*tv).or_insert_with(|| {\n+                    let i = uncanonical.len();\n+                    uncanonical.push(*tv);\n+                    TypeVarId(i as u32)\n+                });\n+            }\n+            _ => {}\n+        });\n+    }\n+    (TraitRef { substs: substs.into(), ..trait_ref }, uncanonical)\n+}\n+\n+fn unify_trait_refs(tr1: &TraitRef, tr2: &TraitRef) -> Option<Solution> {\n+    if tr1.trait_ != tr2.trait_ {\n+        return None;\n+    }\n+    let mut solution_substs = Vec::new();\n+    for (t1, t2) in tr1.substs.0.iter().zip(tr2.substs.0.iter()) {\n+        // this is very bad / hacky 'unification' logic, just enough to make the simple tests pass\n+        match (t1, t2) {\n+            (_, Ty::Infer(InferTy::TypeVar(_))) | (_, Ty::Unknown) | (_, Ty::Param { .. }) => {\n+                // type variable (or similar) in the impl, we just assume it works\n+            }\n+            (Ty::Infer(InferTy::TypeVar(v1)), _) => {\n+                // type variable in the query and fixed type in the impl, record its value\n+                solution_substs.resize_with(v1.0 as usize + 1, || Ty::Unknown);\n+                solution_substs[v1.0 as usize] = t2.clone();\n+            }\n+            _ => {\n+                // check that they're equal (actually we'd have to recurse etc.)\n+                if t1 != t2 {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+    Some(Solution::Unique(solution_substs.into()))\n+}"}, {"sha": "40a2bd148d7c1211fcc94297920cead26f3c3523", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd0269545f2b6687a64a868654c74f876b7851/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=fcbd0269545f2b6687a64a868654c74f876b7851", "patch": "@@ -104,7 +104,7 @@ pub(crate) fn reference_definition(\n                     }\n                 }\n                 hir::PathResolution::AssocItem(assoc) => {\n-                    return Exact(NavigationTarget::from_impl_item(db, assoc))\n+                    return Exact(NavigationTarget::from_impl_item(db, assoc));\n                 }\n             }\n         }"}]}