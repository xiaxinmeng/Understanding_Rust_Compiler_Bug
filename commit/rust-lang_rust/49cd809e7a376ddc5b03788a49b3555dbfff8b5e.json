{"sha": "49cd809e7a376ddc5b03788a49b3555dbfff8b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Y2Q4MDllN2EzNzZkZGM1YjAzNzg4YTQ5YjM1NTVkYmZmZjhiNWU=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2016-12-19T07:59:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-19T07:59:41Z"}, "message": "Rollup merge of #38433 - GuillaumeGomez:thread_docs, r=frewsxcv\n\nThread docs\n\nr? @frewscvx", "tree": {"sha": "17199964b70919f6409708595f8e05c845c3a4a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17199964b70919f6409708595f8e05c845c3a4a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49cd809e7a376ddc5b03788a49b3555dbfff8b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49cd809e7a376ddc5b03788a49b3555dbfff8b5e", "html_url": "https://github.com/rust-lang/rust/commit/49cd809e7a376ddc5b03788a49b3555dbfff8b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49cd809e7a376ddc5b03788a49b3555dbfff8b5e/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813af34c9252ce8898f1ff7bebbc1ebbe3e90571", "url": "https://api.github.com/repos/rust-lang/rust/commits/813af34c9252ce8898f1ff7bebbc1ebbe3e90571", "html_url": "https://github.com/rust-lang/rust/commit/813af34c9252ce8898f1ff7bebbc1ebbe3e90571"}, {"sha": "79e8a70b62f15ca56489a751cd3184f8acefcae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e8a70b62f15ca56489a751cd3184f8acefcae9", "html_url": "https://github.com/rust-lang/rust/commit/79e8a70b62f15ca56489a751cd3184f8acefcae9"}], "stats": {"total": 62, "additions": 38, "deletions": 24}, "files": [{"sha": "55adc3dabf40fa7e54763730ecf938012663f8ad", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/49cd809e7a376ddc5b03788a49b3555dbfff8b5e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49cd809e7a376ddc5b03788a49b3555dbfff8b5e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=49cd809e7a376ddc5b03788a49b3555dbfff8b5e", "patch": "@@ -17,13 +17,11 @@\n //! provide some built-in support for low-level synchronization.\n //!\n //! Communication between threads can be done through\n-//! [channels](../../std/sync/mpsc/index.html), Rust's message-passing\n-//! types, along with [other forms of thread\n+//! [channels], Rust's message-passing types, along with [other forms of thread\n //! synchronization](../../std/sync/index.html) and shared-memory data\n //! structures. In particular, types that are guaranteed to be\n //! threadsafe are easily shared between threads using the\n-//! atomically-reference-counted container,\n-//! [`Arc`](../../std/sync/struct.Arc.html).\n+//! atomically-reference-counted container, [`Arc`].\n //!\n //! Fatal logic errors in Rust cause *thread panic*, during which\n //! a thread will unwind the stack, running destructors and freeing\n@@ -40,7 +38,7 @@\n //!\n //! ## Spawning a thread\n //!\n-//! A new thread can be spawned using the `thread::spawn` function:\n+//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n //!\n //! ```rust\n //! use std::thread;\n@@ -55,7 +53,7 @@\n //! it), unless this parent is the main thread.\n //!\n //! The parent thread can also wait on the completion of the child\n-//! thread; a call to `spawn` produces a `JoinHandle`, which provides\n+//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n //! a `join` method for waiting:\n //!\n //! ```rust\n@@ -68,13 +66,13 @@\n //! let res = child.join();\n //! ```\n //!\n-//! The `join` method returns a `Result` containing `Ok` of the final\n-//! value produced by the child thread, or `Err` of the value given to\n-//! a call to `panic!` if the child panicked.\n+//! The [`join`] method returns a [`Result`] containing [`Ok`] of the final\n+//! value produced by the child thread, or [`Err`] of the value given to\n+//! a call to [`panic!`] if the child panicked.\n //!\n //! ## Configuring threads\n //!\n-//! A new thread can be configured before it is spawned via the `Builder` type,\n+//! A new thread can be configured before it is spawned via the [`Builder`] type,\n //! which currently allows you to set the name and stack size for the child thread:\n //!\n //! ```rust\n@@ -88,43 +86,43 @@\n //!\n //! ## The `Thread` type\n //!\n-//! Threads are represented via the `Thread` type, which you can get in one of\n+//! Threads are represented via the [`Thread`] type, which you can get in one of\n //! two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `thread::spawn` function, and\n-//!   calling `thread()` on the `JoinHandle`.\n-//! * By requesting the current thread, using the `thread::current` function.\n+//! * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n+//!   function, and calling [`thread()`] on the [`JoinHandle`].\n+//! * By requesting the current thread, using the [`thread::current()`] function.\n //!\n-//! The `thread::current()` function is available even for threads not spawned\n+//! The [`thread::current()`] function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n //! ## Blocking support: park and unpark\n //!\n //! Every thread is equipped with some basic low-level blocking support, via the\n-//! `thread::park()` function and `thread::Thread::unpark()` method. `park()`\n-//! blocks the current thread, which can then be resumed from another thread by\n-//! calling the `unpark()` method on the blocked thread's handle.\n+//! [`thread::park()`][`park()`] function and [`thread::Thread::unpark()`][`unpark()`]\n+//! method. [`park()`] blocks the current thread, which can then be resumed from\n+//! another thread by calling the [`unpark()`] method on the blocked thread's handle.\n //!\n-//! Conceptually, each `Thread` handle has an associated token, which is\n+//! Conceptually, each [`Thread`] handle has an associated token, which is\n //! initially not present:\n //!\n-//! * The `thread::park()` function blocks the current thread unless or until\n+//! * The [`thread::park()`][`park()`] function blocks the current thread unless or until\n //!   the token is available for its thread handle, at which point it atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. `thread::park_timeout()` does the same, but allows specifying a\n+//!   token. [`thread::park_timeout()`] does the same, but allows specifying a\n //!   maximum time to block the thread for.\n //!\n-//! * The `unpark()` method on a `Thread` atomically makes the token available\n+//! * The [`unpark()`] method on a [`Thread`] atomically makes the token available\n //!   if it wasn't already.\n //!\n-//! In other words, each `Thread` acts a bit like a semaphore with initial count\n+//! In other words, each [`Thread`] acts a bit like a semaphore with initial count\n //! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n //! and can return spuriously.\n //!\n //! The API is typically used by acquiring a handle to the current thread,\n //! placing that handle in a shared data structure so that other threads can\n //! find it, and then `park`ing. When some desired condition is met, another\n-//! thread calls `unpark` on the handle.\n+//! thread calls [`unpark()`] on the handle.\n //!\n //! The motivation for this design is twofold:\n //!\n@@ -149,6 +147,22 @@\n //! will want to make use of some form of **interior mutability** through the\n //! [`Cell`] or [`RefCell`] types.\n //!\n+//! [channels]: ../../std/sync/mpsc/index.html\n+//! [`Arc`]: ../../std/sync/struct.Arc.html\n+//! [`spawn`]: ../../std/thread/fn.spawn.html\n+//! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+//! [`thread()`]: ../../std/thread/struct.JoinHandle.html#method.thread\n+//! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n+//! [`Result`]: ../../std/result/enum.Result.html\n+//! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+//! [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+//! [`panic!`]: ../../std/macro.panic.html\n+//! [`Builder`]: ../../std/thread/struct.Builder.html\n+//! [`thread::current()`]: ../../std/thread/fn.spawn.html\n+//! [`Thread`]: ../../std/thread/struct.Thread.html\n+//! [`park()`]: ../../std/thread/fn.park.html\n+//! [`unpark()`]: ../../std/thread/struct.Thread.html#method.unpark\n+//! [`thread::park_timeout()`]: ../../std/thread/fn.park_timeout.html\n //! [`Cell`]: ../cell/struct.Cell.html\n //! [`RefCell`]: ../cell/struct.RefCell.html\n //! [`thread_local!`]: ../macro.thread_local.html"}]}