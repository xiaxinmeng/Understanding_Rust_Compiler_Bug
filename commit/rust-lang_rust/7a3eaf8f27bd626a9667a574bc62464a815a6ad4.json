{"sha": "7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhM2VhZjhmMjdiZDYyNmE5NjY3YTU3NGJjNjI0NjRhODE1YTZhZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T13:28:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T13:28:35Z"}, "message": "auto merge of #7941 : dotdash/rust/codegen, r=huonw\n\nThese changes remove unnecessary basic blocks and the associated branches from\r\nthe LLVM IR that we emit. Together, they reduce the time for unoptimized builds\r\nin stage2 by about 10% on my box.", "tree": {"sha": "7243080fdb16fd17cf4133f6ddd32a8ad2cbd584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7243080fdb16fd17cf4133f6ddd32a8ad2cbd584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "html_url": "https://github.com/rust-lang/rust/commit/7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b2218d248571a242ac243e0443d95619bdda056", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2218d248571a242ac243e0443d95619bdda056", "html_url": "https://github.com/rust-lang/rust/commit/7b2218d248571a242ac243e0443d95619bdda056"}, {"sha": "205baa6ca2272e21032f8fb5477edefe4120bcbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/205baa6ca2272e21032f8fb5477edefe4120bcbc", "html_url": "https://github.com/rust-lang/rust/commit/205baa6ca2272e21032f8fb5477edefe4120bcbc"}], "stats": {"total": 1934, "additions": 1246, "deletions": 688}, "files": [{"sha": "d1a9e387d00ed6445c580a6cea7a83148e3fa7c4", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -984,6 +984,8 @@ pub mod llvm {\n         pub unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n+        pub unsafe fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n \n         /* Operations on call sites */\n         #[fast_ffi]"}, {"sha": "2e54423431fb08e8cb4328a46a9276a44c55e3d5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -41,6 +41,7 @@ use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build::*;\n+use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::consts;\n@@ -1499,34 +1500,35 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n }\n \n pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n+    if cx.unreachable { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of::type_of(ccx, t);\n-    memzero(bcx, llptr, llty);\n+    memzero(&B(bcx), llptr, llty);\n }\n \n // Always use this function instead of storing a zero constant to the memory\n // in question. If you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n+pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n-    let ccx = cx.ccx();\n+    let ccx = b.ccx;\n \n     let intrinsic_key = match ccx.sess.targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = PointerCast(cx, llptr, Type::i8().ptr_to());\n+    let llptr = b.pointercast(llptr, Type::i8().ptr_to());\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type);\n+    let size = machine::llsize_of(ccx, ty);\n     let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n-    Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n+    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n@@ -1549,9 +1551,12 @@ pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> Value\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n-    let initcx = base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas());\n-    let p = Alloca(initcx, ty, name);\n-    if zero { memzero(initcx, p, ty); }\n+    let p = Alloca(cx, ty, name);\n+    if zero {\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        memzero(&b, p, ty);\n+    }\n     p\n }\n \n@@ -1562,7 +1567,7 @@ pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas()), ty, v);\n+    return ArrayAlloca(cx, ty, v);\n }\n \n pub struct BasicBlocks {\n@@ -1593,8 +1598,8 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            alloca(raw_block(fcx, false, fcx.get_llstaticallocas()), lloutputtype,\n-                   \"__make_return_pointer\")\n+            let bcx = fcx.entry_bcx.get();\n+            Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n }\n@@ -1612,6 +1617,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         output_type: ty::t,\n                         skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n+                        opt_node_info: Option<NodeInfo>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n     for param_substs.iter().advance |p| { p.validate(); }\n@@ -1635,8 +1641,8 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n               llvm::LLVMGetUndef(Type::i8p().to_ref())\n           },\n           llretptr: None,\n-          llstaticallocas: None,\n-          llloadenv: None,\n+          entry_bcx: None,\n+          alloca_insert_pt: None,\n           llreturn: None,\n           llself: None,\n           personality: None,\n@@ -1654,6 +1660,15 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n     };\n+\n+    unsafe {\n+        let entry_bcx = top_scope_block(fcx, opt_node_info);\n+        Load(entry_bcx, C_null(Type::i8p()));\n+\n+        fcx.entry_bcx = Some(entry_bcx);\n+        fcx.alloca_insert_pt = Some(llvm::LLVMGetFirstInstruction(entry_bcx.llbb));\n+    }\n+\n     if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n         fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n     }\n@@ -1666,7 +1681,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, sp)\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1781,9 +1796,8 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n+pub fn finish_fn(fcx: fn_ctxt, last_bcx: block) {\n     let _icx = push_ctxt(\"finish_fn\");\n-    tie_up_header_blocks(fcx, lltop);\n \n     let ret_cx = match fcx.llreturn {\n         Some(llreturn) => {\n@@ -1795,6 +1809,7 @@ pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n         None => last_bcx\n     };\n     build_return_block(fcx, ret_cx);\n+    fcx.cleanup();\n }\n \n // Builds the return block for a function.\n@@ -1807,29 +1822,6 @@ pub fn build_return_block(fcx: fn_ctxt, ret_cx: block) {\n     }\n }\n \n-pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = push_ctxt(\"tie_up_header_blocks\");\n-    let llnext = match fcx.llloadenv {\n-        Some(ll) => {\n-            unsafe {\n-                llvm::LLVMMoveBasicBlockBefore(ll, lltop);\n-            }\n-            Br(raw_block(fcx, false, ll), lltop);\n-            ll\n-        }\n-        None => lltop\n-    };\n-    match fcx.llstaticallocas {\n-        Some(ll) => {\n-            unsafe {\n-                llvm::LLVMMoveBasicBlockBefore(ll, llnext);\n-            }\n-            Br(raw_block(fcx, false, ll), llnext);\n-        }\n-        None => ()\n-    }\n-}\n-\n pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n@@ -1862,6 +1854,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                output_type,\n                                false,\n                                param_substs,\n+                               body.info(),\n                                Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n@@ -1873,9 +1866,8 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = top_scope_block(fcx, body.info());\n+    let bcx_top = fcx.entry_bcx.get();\n     let mut bcx = bcx_top;\n-    let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.id);\n \n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n@@ -1911,7 +1903,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -2081,12 +2073,12 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                                result_ty,\n                                false,\n                                param_substs,\n+                               None,\n                                None);\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n@@ -2104,7 +2096,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n@@ -2332,9 +2324,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         // be updated if this assertion starts to fail.\n         assert!(fcx.has_immediate_return_value);\n \n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n-\n+        let bcx = fcx.entry_bcx.get();\n         // Call main.\n         let llenvarg = unsafe {\n             let env_arg = fcx.env_arg_pos();\n@@ -2343,7 +2333,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         let args = ~[llenvarg];\n         Call(bcx, main_llfn, args);\n \n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n         return llfdecl;\n     }\n "}, {"sha": "a8c7efb2ad43de193024b6f08bbb4ce91b16696a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 197, "deletions": 566, "changes": 763, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -11,21 +11,17 @@\n \n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n-use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use lib::llvm::{Opcode, IntPredicate, RealPredicate};\n+use lib::llvm::{ValueRef, BasicBlockRef};\n use lib;\n use middle::trans::common::*;\n-use middle::trans::machine::llalign_of_min;\n use syntax::codemap::span;\n \n-use middle::trans::base;\n+use middle::trans::builder::Builder;\n use middle::trans::type_::Type;\n \n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n-use std::hashmap::HashMap;\n-use std::str;\n-use std::vec;\n \n pub fn terminate(cx: block, _: &str) {\n     cx.terminated = true;\n@@ -37,56 +33,12 @@ pub fn check_not_terminated(cx: block) {\n     }\n }\n \n-pub fn B(cx: block) -> BuilderRef {\n-    unsafe {\n-        let b = cx.fcx.ccx.builder.B;\n-        llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n-        return b;\n-    }\n-}\n-\n-pub fn count_insn(cx: block, category: &str) {\n-    if cx.ccx().sess.trans_stats() {\n-        cx.ccx().stats.n_llvm_insns += 1;\n-    }\n-    do base::with_insn_ctxt |v| {\n-        let h = &mut cx.ccx().stats.llvm_insns;\n-\n-        // Build version of path with cycles removed.\n-\n-        // Pass 1: scan table mapping str -> rightmost pos.\n-        let mut mm = HashMap::new();\n-        let len = v.len();\n-        let mut i = 0u;\n-        while i < len {\n-            mm.insert(v[i], i);\n-            i += 1u;\n-        }\n-\n-        // Pass 2: concat strings for each elt, skipping\n-        // forwards over any cycles by advancing to rightmost\n-        // occurrence of each element in path.\n-        let mut s = ~\".\";\n-        i = 0u;\n-        while i < len {\n-            i = *mm.get(&v[i]);\n-            s.push_char('/');\n-            s.push_str(v[i]);\n-            i += 1u;\n-        }\n-\n-        s.push_char('/');\n-        s.push_str(category);\n-\n-        let n = match h.find(&s) {\n-          Some(&n) => n,\n-          _ => 0u\n-        };\n-        h.insert(s, n+1u);\n-    }\n+pub fn B(cx: block) -> Builder {\n+    let b = cx.fcx.ccx.builder();\n+    b.position_at_end(cx.llbb);\n+    b\n }\n \n-\n // The difference between a block being unreachable and being terminated is\n // somewhat obscure, and has to do with error checking. When a block is\n // terminated, we're saying that trying to add any further statements in the\n@@ -96,64 +48,47 @@ pub fn count_insn(cx: block, category: &str) {\n // further instructions to the block should simply be ignored.\n \n pub fn RetVoid(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"RetVoid\");\n-        count_insn(cx, \"retvoid\");\n-        llvm::LLVMBuildRetVoid(B(cx));\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"RetVoid\");\n+    B(cx).ret_void();\n }\n \n pub fn Ret(cx: block, V: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Ret\");\n-        count_insn(cx, \"ret\");\n-        llvm::LLVMBuildRet(B(cx), V);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Ret\");\n+    B(cx).ret(V);\n }\n \n pub fn AggregateRet(cx: block, RetVals: &[ValueRef]) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n-    unsafe {\n-        llvm::LLVMBuildAggregateRet(B(cx), vec::raw::to_ptr(RetVals),\n-                                    RetVals.len() as c_uint);\n-    }\n+    B(cx).aggregate_ret(RetVals);\n }\n \n pub fn Br(cx: block, Dest: BasicBlockRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Br\");\n-        count_insn(cx, \"br\");\n-        llvm::LLVMBuildBr(B(cx), Dest);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Br\");\n+    B(cx).br(Dest);\n }\n \n pub fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"CondBr\");\n-        count_insn(cx, \"condbr\");\n-        llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"CondBr\");\n+    B(cx).cond_br(If, Then, Else);\n }\n \n pub fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Switch\");\n-        return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Switch\");\n+    B(cx).switch(V, Else, NumCases)\n }\n \n pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n@@ -164,22 +99,10 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n }\n \n pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"IndirectBr\");\n-        count_insn(cx, \"indirectbr\");\n-        llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n-    }\n-}\n-\n-// This is a really awful way to get a zero-length c-string, but better (and a\n-// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-pub fn noname() -> *c_char {\n-    unsafe {\n-        static cnull: uint = 0u;\n-        return cast::transmute(&cnull);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"IndirectBr\");\n+    B(cx).indirect_br(Addr, NumDests);\n }\n \n pub fn Invoke(cx: block,\n@@ -196,40 +119,22 @@ pub fn Invoke(cx: block,\n     debug!(\"Invoke(%s with arguments (%s))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n-    unsafe {\n-        count_insn(cx, \"invoke\");\n-        llvm::LLVMBuildInvoke(B(cx),\n-                              Fn,\n-                              vec::raw::to_ptr(Args),\n-                              Args.len() as c_uint,\n-                              Then,\n-                              Catch,\n-                              noname())\n-    }\n+    B(cx).invoke(Fn, Args, Then, Catch)\n }\n \n pub fn FastInvoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                   Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"FastInvoke\");\n-    unsafe {\n-        count_insn(cx, \"fastinvoke\");\n-        let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                      Args.len() as c_uint,\n-                                      Then, Catch, noname());\n-        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-    }\n+    B(cx).fast_invoke(Fn, Args, Then, Catch);\n }\n \n pub fn Unreachable(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        cx.unreachable = true;\n-        if !cx.terminated {\n-            count_insn(cx, \"unreachable\");\n-            llvm::LLVMBuildUnreachable(B(cx));\n-        }\n+    if cx.unreachable { return; }\n+    cx.unreachable = true;\n+    if !cx.terminated {\n+        B(cx).unreachable();\n     }\n }\n \n@@ -241,298 +146,196 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n \n /* Arithmetic */\n pub fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"add\");\n-        return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).add(LHS, RHS)\n }\n \n pub fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nswadd\");\n-        return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswadd(LHS, RHS)\n }\n \n pub fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwadd\");\n-        return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwadd(LHS, RHS)\n }\n \n pub fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fadd\");\n-        return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fadd(LHS, RHS)\n }\n \n pub fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sub\");\n-        return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).sub(LHS, RHS)\n }\n \n pub fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nwsub\");\n-        return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswsub(LHS, RHS)\n }\n \n pub fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwsub\");\n-        return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwsub(LHS, RHS)\n }\n \n pub fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sub\");\n-        return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fsub(LHS, RHS)\n }\n \n pub fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"mul\");\n-        return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).mul(LHS, RHS)\n }\n \n pub fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nswmul\");\n-        return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswmul(LHS, RHS)\n }\n \n pub fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwmul\");\n-        return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwmul(LHS, RHS)\n }\n \n pub fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fmul\");\n-        return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fmul(LHS, RHS)\n }\n \n pub fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"udiv\");\n-        return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).udiv(LHS, RHS)\n }\n \n pub fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sdiv\");\n-        return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).sdiv(LHS, RHS)\n }\n \n pub fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"extractsdiv\");\n-        return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).exactsdiv(LHS, RHS)\n }\n \n pub fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fdiv\");\n-        return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fdiv(LHS, RHS)\n }\n \n pub fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"urem\");\n-        return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).urem(LHS, RHS)\n }\n \n pub fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"srem\");\n-        return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).srem(LHS, RHS)\n }\n \n pub fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"frem\");\n-        return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).frem(LHS, RHS)\n }\n \n pub fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"shl\");\n-        return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).shl(LHS, RHS)\n }\n \n pub fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"lshr\");\n-        return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).lshr(LHS, RHS)\n }\n \n pub fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"ashr\");\n-        return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).ashr(LHS, RHS)\n }\n \n pub fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"and\");\n-        return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).and(LHS, RHS)\n }\n \n pub fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"or\");\n-        return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).or(LHS, RHS)\n }\n \n pub fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"xor\");\n-        return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).xor(LHS, RHS)\n }\n \n pub fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"binop\");\n-        return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).binop(Op, LHS, RHS)\n }\n \n pub fn Neg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"neg\");\n-        return llvm::LLVMBuildNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).neg(V)\n }\n \n pub fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"nswneg\");\n-        return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).nswneg(V)\n }\n \n pub fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"nuwneg\");\n-        return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).nuwneg(V)\n }\n pub fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"fneg\");\n-        return llvm::LLVMBuildFNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).fneg(V)\n }\n \n pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"not\");\n-        return llvm::LLVMBuildNot(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).not(V)\n }\n \n /* Memory */\n pub fn Malloc(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"malloc\");\n-        return llvm::LLVMBuildMalloc(B(cx), Ty.to_ref(), noname());\n+        B(cx).malloc(Ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"arraymalloc\");\n-        return llvm::LLVMBuildArrayMalloc(B(cx), Ty.to_ref(), Val, noname());\n+        B(cx).array_malloc(Ty, Val)\n     }\n }\n \n pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        count_insn(cx, \"alloca\");\n-        if name.is_empty() {\n-            llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname())\n-        } else {\n-            str::as_c_str(\n-                name,\n-                |c| llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), c))\n-        }\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.alloca(Ty, name)\n     }\n }\n \n pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        count_insn(cx, \"arrayalloca\");\n-        return llvm::LLVMBuildArrayAlloca(B(cx), Ty.to_ref(), Val, noname());\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.array_alloca(Ty, Val)\n     }\n }\n \n pub fn Free(cx: block, PointerVal: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        count_insn(cx, \"free\");\n-        llvm::LLVMBuildFree(B(cx), PointerVal);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).free(PointerVal)\n }\n \n pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n@@ -547,8 +350,7 @@ pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n             };\n             return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n-        count_insn(cx, \"load\");\n-        return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n+        B(cx).load(PointerVal)\n     }\n }\n \n@@ -558,272 +360,216 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n         if cx.unreachable {\n             return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n-        count_insn(cx, \"load.atomic\");\n-        let align = llalign_of_min(ccx, ccx.int_type);\n-        return llvm::LLVMBuildAtomicLoad(B(cx), PointerVal, noname(), order, align as c_uint);\n+        B(cx).atomic_load(PointerVal, order)\n     }\n }\n \n \n pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n-    let value = Load(cx, PointerVal);\n-\n-    if !cx.unreachable {\n+    if cx.unreachable {\n+        let ccx = cx.fcx.ccx;\n+        let ty = val_ty(PointerVal);\n+        let eltty = if ty.kind() == lib::llvm::Array {\n+            ty.element_type()\n+        } else {\n+            ccx.int_type\n+        };\n         unsafe {\n-            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(PointerVal));\n-            let min = llvm::LLVMConstInt(t, lo, signed);\n-            let max = llvm::LLVMConstInt(t, hi, signed);\n-\n-            do [min, max].as_imm_buf |ptr, len| {\n-                llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n-                                      llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n-                                                                ptr, len as c_uint));\n-            }\n+            llvm::LLVMGetUndef(eltty.to_ref())\n         }\n+    } else {\n+        B(cx).load_range_assert(PointerVal, lo, hi, signed)\n     }\n-\n-    value\n }\n \n pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        debug!(\"Store %s -> %s\",\n-               cx.val_to_str(Val),\n-               cx.val_to_str(Ptr));\n-        count_insn(cx, \"store\");\n-        llvm::LLVMBuildStore(B(cx), Val, Ptr);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).store(Val, Ptr)\n }\n \n pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        debug!(\"Store %s -> %s\",\n-               cx.val_to_str(Val),\n-               cx.val_to_str(Ptr));\n-        count_insn(cx, \"store.atomic\");\n-        let align = llalign_of_min(cx.ccx(), cx.ccx().int_type);\n-        llvm::LLVMBuildAtomicStore(B(cx), Val, Ptr, order, align as c_uint);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).atomic_store(Val, Ptr, order)\n }\n \n pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"gep\");\n-        return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n-                                   Indices.len() as c_uint, noname());\n+        B(cx).gep(Pointer, Indices)\n     }\n }\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n-    // Small vector optimization. This should catch 100% of the cases that\n-    // we care about.\n-    if ixs.len() < 16 {\n-        let mut small_vec = [ C_i32(0), ..16 ];\n-        for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n-            *small_vec_e = C_i32(ix as i32);\n-        }\n-        InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))\n-    } else {\n-        let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n-        count_insn(cx, \"gepi\");\n-        InBoundsGEP(cx, base, v)\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"inboundsgep\");\n-        return llvm::LLVMBuildInBoundsGEP(\n-            B(cx), Pointer, vec::raw::to_ptr(Indices), Indices.len() as c_uint, noname());\n+        B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"structgep\");\n-        return llvm::LLVMBuildStructGEP(B(cx),\n-                                        Pointer,\n-                                        Idx as c_uint,\n-                                        noname());\n+        B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"globalstring\");\n-        return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+        B(cx).global_string(_Str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"globalstringptr\");\n-        return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+        B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n pub fn Trunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"trunc\");\n-        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).trunc(Val, DestTy)\n     }\n }\n \n pub fn ZExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"zext\");\n-        return llvm::LLVMBuildZExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).zext(Val, DestTy)\n     }\n }\n \n pub fn SExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sext\");\n-        return llvm::LLVMBuildSExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sext(Val, DestTy)\n     }\n }\n \n pub fn FPToUI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptoui\");\n-        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fptoui(Val, DestTy)\n     }\n }\n \n pub fn FPToSI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptosi\");\n-        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy.to_ref(),noname());\n+        B(cx).fptosi(Val, DestTy)\n     }\n }\n \n pub fn UIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"uitofp\");\n-        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).uitofp(Val, DestTy)\n     }\n }\n \n pub fn SIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sitofp\");\n-        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sitofp(Val, DestTy)\n     }\n }\n \n pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptrunc\");\n-        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n pub fn FPExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fpext\");\n-        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fpext(Val, DestTy)\n     }\n }\n \n pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"ptrtoint\");\n-        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"inttoptr\");\n-        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n pub fn BitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"bitcast\");\n-        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).bitcast(Val, DestTy)\n     }\n }\n \n pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"zextorbitcast\");\n-        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sextorbitcast\");\n-        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"truncorbitcast\");\n-        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        count_insn(cx, \"cast\");\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy.to_ref(), noname());\n+        B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n pub fn PointerCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"pointercast\");\n-        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).pointercast(Val, DestTy)\n     }\n }\n \n pub fn IntCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"intcast\");\n-        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).intcast(Val, DestTy)\n     }\n }\n \n pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fpcast\");\n-        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fpcast(Val, DestTy)\n     }\n }\n \n@@ -833,40 +579,30 @@ pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"icmp\");\n-        return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+        B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"fcmp\");\n-        return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+        B(cx).fcmp(Op, LHS, RHS)\n     }\n }\n \n /* Miscellaneous instructions */\n pub fn EmptyPhi(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        count_insn(cx, \"emptyphi\");\n-        return llvm::LLVMBuildPhi(B(cx), Ty.to_ref(), noname());\n+        B(cx).empty_phi(Ty)\n     }\n }\n \n-pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef])\n-    -> ValueRef {\n+pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        assert_eq!(vals.len(), bbs.len());\n-        let phi = EmptyPhi(cx, Ty);\n-        count_insn(cx, \"addincoming\");\n-        llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n-                              vec::raw::to_ptr(bbs),\n-                              vals.len() as c_uint);\n-        return phi;\n+        B(cx).phi(Ty, vals, bbs)\n     }\n }\n \n@@ -888,253 +624,148 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n         } else {\n             ccx.int_type\n         };\n-        count_insn(cx, \"ret_undef\");\n-        return llvm::LLVMGetUndef(retty.to_ref());\n+        B(cx).count_insn(\"ret_undef\");\n+        llvm::LLVMGetUndef(retty.to_ref())\n     }\n }\n \n-pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n-    let ccx = bcx.ccx();\n-    if ccx.sess.asm_comments() {\n-        let s = fmt!(\"%s (%s)\", text, ccx.sess.codemap.span_to_str(sp));\n-        debug!(\"%s\", s);\n-        add_comment(bcx, s);\n-    }\n+pub fn add_span_comment(cx: block, sp: span, text: &str) {\n+    B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(bcx: block, text: &str) {\n-    unsafe {\n-        let ccx = bcx.ccx();\n-        if ccx.sess.asm_comments() {\n-            let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = ~\"# \" +\n-                sanitized.replace(\"\\n\", \"\\n\\t# \");\n-            count_insn(bcx, \"inlineasm\");\n-            let asm = do comment_text.as_c_str |c| {\n-                llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n-                                         c, noname(), False, False)\n-            };\n-            Call(bcx, asm, []);\n-        }\n-    }\n+pub fn add_comment(cx: block, text: &str) {\n+    B(cx).add_comment(text)\n }\n \n pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n-    unsafe {\n-        count_insn(cx, \"inlineasm\");\n-\n-        let volatile = if volatile { lib::llvm::True }\n-                       else        { lib::llvm::False };\n-        let alignstack = if alignstack { lib::llvm::True }\n-                         else          { lib::llvm::False };\n-\n-        let argtys = do inputs.map |v| {\n-            debug!(\"Asm Input Type: %?\", cx.val_to_str(*v));\n-            val_ty(*v)\n-        };\n-\n-        debug!(\"Asm Output Type: %?\", cx.ccx().tn.type_to_str(output));\n-        let fty = Type::func(argtys, &output);\n-        let v = llvm::LLVMInlineAsm(fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-\n-        Call(cx, v, inputs)\n-    }\n+    B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"call\");\n-\n-        debug!(\"Call(Fn=%s, Args=%?)\",\n-               cx.val_to_str(Fn),\n-               Args.map(|arg| cx.val_to_str(*arg)));\n-\n-        do Args.as_imm_buf |ptr, len| {\n-            llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n-        }\n-    }\n+    B(cx).call(Fn, Args)\n }\n \n pub fn FastCall(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"fastcall\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                    Args.len() as c_uint, noname());\n-        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-        return v;\n-    }\n+    B(cx).call(Fn, Args)\n }\n \n pub fn CallWithConv(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                     Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"callwithconv\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                    Args.len() as c_uint, noname());\n-        lib::llvm::SetInstructionCallConv(v, Conv);\n-        return v;\n-    }\n+    B(cx).call_with_conv(Fn, Args, Conv)\n }\n \n-pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n-   ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(Then); }\n-        count_insn(cx, \"select\");\n-        return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n-    }\n+pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n+    if cx.unreachable { return _Undef(Then); }\n+    B(cx).select(If, Then, Else)\n }\n \n pub fn VAArg(cx: block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        count_insn(cx, \"vaarg\");\n-        return llvm::LLVMBuildVAArg(B(cx), list, Ty.to_ref(), noname());\n+        B(cx).va_arg(list, Ty)\n     }\n }\n \n-pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n-   ValueRef {\n+pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"extractelement\");\n-        return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+        B(cx).extract_element(VecVal, Index)\n     }\n }\n \n pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"insertelement\");\n-        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname())\n+        B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"shufflevector\");\n-        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname())\n+        B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        let elt_ty = val_ty(EltVal);\n-        let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, NumElts as u64).to_ref());\n-        let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n-        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(&Type::i32(), NumElts as u64)))\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"extractvalue\");\n-        return llvm::LLVMBuildExtractValue(\n-            B(cx), AggVal, Index as c_uint, noname());\n+        B(cx).extract_value(AggVal, Index)\n     }\n }\n \n-pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n-                   Index: uint) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        count_insn(cx, \"insertvalue\");\n-        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n-                                   noname());\n-    }\n+pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {\n+    if cx.unreachable { return; }\n+    B(cx).insert_value(AggVal, EltVal, Index)\n }\n \n pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"isnull\");\n-        return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+        B(cx).is_null(Val)\n     }\n }\n \n pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"isnotnull\");\n-        return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+        B(cx).is_not_null(Val)\n     }\n }\n \n pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n-        count_insn(cx, \"ptrdiff\");\n-        return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+        B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n pub fn Trap(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        let b = B(cx);\n-        let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n-        let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n-        let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-        let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n-            llvm::LLVMGetNamedFunction(M, buf)\n-        });\n-        assert!((T as int != 0));\n-        let Args: ~[ValueRef] = ~[];\n-        count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args), Args.len() as c_uint, noname());\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).trap();\n }\n \n pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n-    unsafe {\n-        check_not_terminated(cx);\n-        assert!(!cx.unreachable);\n-        count_insn(cx, \"landingpad\");\n-        return llvm::LLVMBuildLandingPad(\n-            B(cx), Ty.to_ref(), PersFn, NumClauses as c_uint, noname());\n-    }\n+    check_not_terminated(cx);\n+    assert!(!cx.unreachable);\n+    B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n pub fn SetCleanup(cx: block, LandingPad: ValueRef) {\n-    unsafe {\n-        count_insn(cx, \"setcleanup\");\n-        llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n-    }\n+    B(cx).set_cleanup(LandingPad)\n }\n \n pub fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n-    unsafe {\n-        check_not_terminated(cx);\n-        terminate(cx, \"Resume\");\n-        count_insn(cx, \"resume\");\n-        return llvm::LLVMBuildResume(B(cx), Exn);\n-    }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Resume\");\n+    B(cx).resume(Exn)\n }\n \n // Atomic Operations\n pub fn AtomicCmpXchg(cx: block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMBuildAtomicCmpXchg(B(cx), dst, cmp, src, order)\n-    }\n+    B(cx).atomic_cmpxchg(dst, cmp, src, order)\n }\n pub fn AtomicRMW(cx: block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n-    }\n+    B(cx).atomic_rmw(op, dst, src, order)\n }"}, {"sha": "a4a976145b9a5c7eba237813209eea6f97a4ee87", "filename": "src/librustc/middle/trans/builder.rs", "status": "added", "additions": 947, "deletions": 0, "changes": 947, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -0,0 +1,947 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lib;\n+use lib::llvm::llvm;\n+use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use middle::trans::base;\n+use middle::trans::common::*;\n+use middle::trans::machine::llalign_of_min;\n+use middle::trans::type_::Type;\n+use std::cast;\n+use std::hashmap::HashMap;\n+use std::libc::{c_uint, c_ulonglong, c_char};\n+use std::str;\n+use std::vec;\n+use syntax::codemap::span;\n+\n+pub struct Builder {\n+    llbuilder: BuilderRef,\n+    ccx: @mut CrateContext,\n+}\n+\n+// This is a really awful way to get a zero-length c-string, but better (and a\n+// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n+pub fn noname() -> *c_char {\n+    unsafe {\n+        static cnull: uint = 0u;\n+        cast::transmute(&cnull)\n+    }\n+}\n+\n+impl Builder {\n+    pub fn new(ccx: @mut CrateContext) -> Builder {\n+        Builder {\n+            llbuilder: ccx.builder.B,\n+            ccx: ccx,\n+        }\n+    }\n+\n+    pub fn count_insn(&self, category: &str) {\n+        if self.ccx.sess.trans_stats() {\n+            self.ccx.stats.n_llvm_insns += 1;\n+        }\n+        if self.ccx.sess.count_llvm_insns() {\n+            do base::with_insn_ctxt |v| {\n+                let h = &mut self.ccx.stats.llvm_insns;\n+\n+                // Build version of path with cycles removed.\n+\n+                // Pass 1: scan table mapping str -> rightmost pos.\n+                let mut mm = HashMap::new();\n+                let len = v.len();\n+                let mut i = 0u;\n+                while i < len {\n+                    mm.insert(v[i], i);\n+                    i += 1u;\n+                }\n+\n+                // Pass 2: concat strings for each elt, skipping\n+                // forwards over any cycles by advancing to rightmost\n+                // occurrence of each element in path.\n+                let mut s = ~\".\";\n+                i = 0u;\n+                while i < len {\n+                    i = *mm.get(&v[i]);\n+                    s.push_char('/');\n+                    s.push_str(v[i]);\n+                    i += 1u;\n+                }\n+\n+                s.push_char('/');\n+                s.push_str(category);\n+\n+                let n = match h.find(&s) {\n+                    Some(&n) => n,\n+                    _ => 0u\n+                };\n+                h.insert(s, n+1u);\n+            }\n+        }\n+    }\n+\n+    pub fn position_before(&self, insn: ValueRef) {\n+        unsafe {\n+            llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);\n+        }\n+    }\n+\n+    pub fn position_at_end(&self, llbb: BasicBlockRef) {\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    pub fn ret_void(&self) {\n+        self.count_insn(\"retvoid\");\n+        unsafe {\n+            llvm::LLVMBuildRetVoid(self.llbuilder);\n+        }\n+    }\n+\n+    pub fn ret(&self, v: ValueRef) {\n+        self.count_insn(\"ret\");\n+        unsafe {\n+            llvm::LLVMBuildRet(self.llbuilder, v);\n+        }\n+    }\n+\n+    pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n+        unsafe {\n+            llvm::LLVMBuildAggregateRet(self.llbuilder,\n+                                        vec::raw::to_ptr(ret_vals),\n+                                        ret_vals.len() as c_uint);\n+        }\n+    }\n+\n+    pub fn br(&self, dest: BasicBlockRef) {\n+        self.count_insn(\"br\");\n+        unsafe {\n+            llvm::LLVMBuildBr(self.llbuilder, dest);\n+        }\n+    }\n+\n+    pub fn cond_br(&self, cond: ValueRef, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n+        self.count_insn(\"condbr\");\n+        unsafe {\n+            llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n+        }\n+    }\n+\n+    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: uint) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n+        }\n+    }\n+\n+    pub fn indirect_br(&self, addr: ValueRef, num_dests: uint) {\n+        self.count_insn(\"indirectbr\");\n+        unsafe {\n+            llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n+        }\n+    }\n+\n+    pub fn invoke(&self,\n+                  llfn: ValueRef,\n+                  args: &[ValueRef],\n+                  then: BasicBlockRef,\n+                  catch: BasicBlockRef)\n+                  -> ValueRef {\n+        self.count_insn(\"invoke\");\n+        unsafe {\n+            llvm::LLVMBuildInvoke(self.llbuilder,\n+                                  llfn,\n+                                  vec::raw::to_ptr(args),\n+                                  args.len() as c_uint,\n+                                  then,\n+                                  catch,\n+                                  noname())\n+        }\n+    }\n+\n+    pub fn fast_invoke(&self,\n+                       llfn: ValueRef,\n+                       args: &[ValueRef],\n+                       then: BasicBlockRef,\n+                       catch: BasicBlockRef) {\n+        self.count_insn(\"fastinvoke\");\n+        let v = self.invoke(llfn, args, then, catch);\n+        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n+    }\n+\n+    pub fn unreachable(&self) {\n+        self.count_insn(\"unreachable\");\n+        unsafe {\n+            llvm::LLVMBuildUnreachable(self.llbuilder);\n+        }\n+    }\n+\n+    /* Arithmetic */\n+    pub fn add(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"add\");\n+        unsafe {\n+            llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswadd\");\n+        unsafe {\n+            llvm::LLVMBuildNSWAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwadd\");\n+        unsafe {\n+            llvm::LLVMBuildNUWAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fadd\");\n+        unsafe {\n+            llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn sub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sub\");\n+        unsafe {\n+            llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nwsub\");\n+        unsafe {\n+            llvm::LLVMBuildNSWSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwsub\");\n+        unsafe {\n+            llvm::LLVMBuildNUWSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sub\");\n+        unsafe {\n+            llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn mul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"mul\");\n+        unsafe {\n+            llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswmul\");\n+        unsafe {\n+            llvm::LLVMBuildNSWMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwmul\");\n+        unsafe {\n+            llvm::LLVMBuildNUWMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fmul\");\n+        unsafe {\n+            llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn udiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"udiv\");\n+        unsafe {\n+            llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sdiv\");\n+        unsafe {\n+            llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn exactsdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"exactsdiv\");\n+        unsafe {\n+            llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fdiv\");\n+        unsafe {\n+            llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn urem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"urem\");\n+        unsafe {\n+            llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn srem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"srem\");\n+        unsafe {\n+            llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn frem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"frem\");\n+        unsafe {\n+            llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn shl(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"shl\");\n+        unsafe {\n+            llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn lshr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"lshr\");\n+        unsafe {\n+            llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn ashr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"ashr\");\n+        unsafe {\n+            llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn and(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"and\");\n+        unsafe {\n+            llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn or(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"or\");\n+        unsafe {\n+            llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn xor(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"xor\");\n+        unsafe {\n+            llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn binop(&self, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+              -> ValueRef {\n+        self.count_insn(\"binop\");\n+        unsafe {\n+            llvm::LLVMBuildBinOp(self.llbuilder, op, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn neg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"neg\");\n+        unsafe {\n+            llvm::LLVMBuildNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn nswneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswneg\");\n+        unsafe {\n+            llvm::LLVMBuildNSWNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn nuwneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwneg\");\n+        unsafe {\n+            llvm::LLVMBuildNUWNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+    pub fn fneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"fneg\");\n+        unsafe {\n+            llvm::LLVMBuildFNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn not(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"not\");\n+        unsafe {\n+            llvm::LLVMBuildNot(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    /* Memory */\n+    pub fn malloc(&self, ty: Type) -> ValueRef {\n+        self.count_insn(\"malloc\");\n+        unsafe {\n+            llvm::LLVMBuildMalloc(self.llbuilder, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn array_malloc(&self, ty: Type, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"arraymalloc\");\n+        unsafe {\n+            llvm::LLVMBuildArrayMalloc(self.llbuilder, ty.to_ref(), val, noname())\n+        }\n+    }\n+\n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        self.count_insn(\"alloca\");\n+        unsafe {\n+            if name.is_empty() {\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n+            } else {\n+                str::as_c_str(\n+                    name,\n+                    |c| llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c))\n+            }\n+        }\n+    }\n+\n+    pub fn array_alloca(&self, ty: Type, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"arrayalloca\");\n+        unsafe {\n+            llvm::LLVMBuildArrayAlloca(self.llbuilder, ty.to_ref(), val, noname())\n+        }\n+    }\n+\n+    pub fn free(&self, ptr: ValueRef) {\n+        self.count_insn(\"free\");\n+        unsafe {\n+            llvm::LLVMBuildFree(self.llbuilder, ptr);\n+        }\n+    }\n+\n+    pub fn load(&self, ptr: ValueRef) -> ValueRef {\n+        self.count_insn(\"load\");\n+        unsafe {\n+            llvm::LLVMBuildLoad(self.llbuilder, ptr, noname())\n+        }\n+    }\n+\n+    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering) -> ValueRef {\n+        self.count_insn(\"load.atomic\");\n+        unsafe {\n+            let align = llalign_of_min(self.ccx, self.ccx.int_type);\n+            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order, align as c_uint)\n+        }\n+    }\n+\n+\n+    pub fn load_range_assert(&self, ptr: ValueRef, lo: c_ulonglong,\n+                           hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n+        let value = self.load(ptr);\n+\n+        unsafe {\n+            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(ptr));\n+            let min = llvm::LLVMConstInt(t, lo, signed);\n+            let max = llvm::LLVMConstInt(t, hi, signed);\n+\n+            do [min, max].as_imm_buf |ptr, len| {\n+                llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n+                                      llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                                                ptr, len as c_uint));\n+            }\n+        }\n+\n+        value\n+    }\n+\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n+        debug!(\"Store %s -> %s\",\n+               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_str(ptr));\n+        self.count_insn(\"store\");\n+        unsafe {\n+            llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+        }\n+    }\n+\n+    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+        debug!(\"Store %s -> %s\",\n+               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_str(ptr));\n+        self.count_insn(\"store.atomic\");\n+        let align = llalign_of_min(self.ccx, self.ccx.int_type);\n+        unsafe {\n+            llvm::LLVMBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+        }\n+    }\n+\n+    pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"gep\");\n+        unsafe {\n+            llvm::LLVMBuildGEP(self.llbuilder, ptr, vec::raw::to_ptr(indices),\n+                               indices.len() as c_uint, noname())\n+        }\n+    }\n+\n+    // Simple wrapper around GEP that takes an array of ints and wraps them\n+    // in C_i32()\n+    #[inline]\n+    pub fn gepi(&self, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+        // Small vector optimization. This should catch 100% of the cases that\n+        // we care about.\n+        if ixs.len() < 16 {\n+            let mut small_vec = [ C_i32(0), ..16 ];\n+            for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n+                *small_vec_e = C_i32(ix as i32);\n+            }\n+            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n+        } else {\n+            let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n+            self.count_insn(\"gepi\");\n+            self.inbounds_gep(base, v)\n+        }\n+    }\n+\n+    pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"inboundsgep\");\n+        unsafe {\n+            llvm::LLVMBuildInBoundsGEP(\n+                self.llbuilder, ptr, vec::raw::to_ptr(indices), indices.len() as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: uint) -> ValueRef {\n+        self.count_insn(\"structgep\");\n+        unsafe {\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn global_string(&self, _Str: *c_char) -> ValueRef {\n+        self.count_insn(\"globalstring\");\n+        unsafe {\n+            llvm::LLVMBuildGlobalString(self.llbuilder, _Str, noname())\n+        }\n+    }\n+\n+    pub fn global_string_ptr(&self, _Str: *c_char) -> ValueRef {\n+        self.count_insn(\"globalstringptr\");\n+        unsafe {\n+            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _Str, noname())\n+        }\n+    }\n+\n+    /* Casts */\n+    pub fn trunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"trunc\");\n+        unsafe {\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn zext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"zext\");\n+        unsafe {\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sext\");\n+        unsafe {\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptoui(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptoui\");\n+        unsafe {\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptosi(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptosi\");\n+        unsafe {\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty.to_ref(),noname())\n+        }\n+    }\n+\n+    pub fn uitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"uitofp\");\n+        unsafe {\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sitofp\");\n+        unsafe {\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptrunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptrunc\");\n+        unsafe {\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fpext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fpext\");\n+        unsafe {\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn ptrtoint(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"ptrtoint\");\n+        unsafe {\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn inttoptr(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"inttoptr\");\n+        unsafe {\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"bitcast\");\n+        unsafe {\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"zextorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sextorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"truncorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"cast\");\n+        unsafe {\n+            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn pointercast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"pointercast\");\n+        unsafe {\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn intcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"intcast\");\n+        unsafe {\n+            llvm::LLVMBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fpcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fpcast\");\n+        unsafe {\n+            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+\n+    /* Comparisons */\n+    pub fn icmp(&self, op: IntPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"icmp\");\n+        unsafe {\n+            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fcmp(&self, op: RealPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fcmp\");\n+        unsafe {\n+            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+        }\n+    }\n+\n+    /* Miscellaneous instructions */\n+    pub fn empty_phi(&self, ty: Type) -> ValueRef {\n+        self.count_insn(\"emptyphi\");\n+        unsafe {\n+            llvm::LLVMBuildPhi(self.llbuilder, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn phi(&self, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+        assert_eq!(vals.len(), bbs.len());\n+        let phi = self.empty_phi(ty);\n+        self.count_insn(\"addincoming\");\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n+                                  vec::raw::to_ptr(bbs),\n+                                  vals.len() as c_uint);\n+            phi\n+        }\n+    }\n+\n+    pub fn add_span_comment(&self, sp: span, text: &str) {\n+        if self.ccx.sess.asm_comments() {\n+            let s = fmt!(\"%s (%s)\", text, self.ccx.sess.codemap.span_to_str(sp));\n+            debug!(\"%s\", s);\n+            self.add_comment(s);\n+        }\n+    }\n+\n+    pub fn add_comment(&self, text: &str) {\n+        if self.ccx.sess.asm_comments() {\n+            let sanitized = text.replace(\"$\", \"\");\n+            let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n+            self.count_insn(\"inlineasm\");\n+            let asm = do comment_text.as_c_str |c| {\n+                unsafe {\n+                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                                             c, noname(), False, False)\n+                }\n+            };\n+            self.call(asm, []);\n+        }\n+    }\n+\n+    pub fn inline_asm_call(&self, asm: *c_char, cons: *c_char,\n+                         inputs: &[ValueRef], output: Type,\n+                         volatile: bool, alignstack: bool,\n+                         dia: AsmDialect) -> ValueRef {\n+        self.count_insn(\"inlineasm\");\n+\n+        let volatile = if volatile { lib::llvm::True }\n+                       else        { lib::llvm::False };\n+        let alignstack = if alignstack { lib::llvm::True }\n+                         else          { lib::llvm::False };\n+\n+        let argtys = do inputs.map |v| {\n+            debug!(\"Asm Input Type: %?\", self.ccx.tn.val_to_str(*v));\n+            val_ty(*v)\n+        };\n+\n+        debug!(\"Asm Output Type: %?\", self.ccx.tn.type_to_str(output));\n+        let fty = Type::func(argtys, &output);\n+        unsafe {\n+            let v = llvm::LLVMInlineAsm(\n+                fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+            self.call(v, inputs)\n+        }\n+    }\n+\n+    pub fn call(&self, llfn: ValueRef, args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"call\");\n+\n+        debug!(\"Call(llfn=%s, args=%?)\",\n+               self.ccx.tn.val_to_str(llfn),\n+               args.map(|arg| self.ccx.tn.val_to_str(*arg)));\n+\n+        do args.as_imm_buf |ptr, len| {\n+            unsafe {\n+            llvm::LLVMBuildCall(self.llbuilder, llfn, ptr, len as c_uint, noname())\n+            }\n+        }\n+    }\n+\n+    pub fn fastcall(&self, llfn: ValueRef, args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"fastcall\");\n+        unsafe {\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+                                        args.len() as c_uint, noname());\n+            lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n+            v\n+        }\n+    }\n+\n+    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n+                        conv: CallConv) -> ValueRef {\n+        self.count_insn(\"callwithconv\");\n+        unsafe {\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+                                        args.len() as c_uint, noname());\n+            lib::llvm::SetInstructionCallConv(v, conv);\n+            v\n+        }\n+    }\n+\n+    pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n+        self.count_insn(\"select\");\n+        unsafe {\n+            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n+        }\n+    }\n+\n+    pub fn va_arg(&self, list: ValueRef, ty: Type) -> ValueRef {\n+        self.count_insn(\"vaarg\");\n+        unsafe {\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn extract_element(&self, vec: ValueRef, idx: ValueRef) -> ValueRef {\n+        self.count_insn(\"extractelement\");\n+        unsafe {\n+            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n+        }\n+    }\n+\n+    pub fn insert_element(&self, vec: ValueRef, elt: ValueRef, idx: ValueRef) -> ValueRef {\n+        self.count_insn(\"insertelement\");\n+        unsafe {\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+        }\n+    }\n+\n+    pub fn shuffle_vector(&self, v1: ValueRef, v2: ValueRef, mask: ValueRef) -> ValueRef {\n+        self.count_insn(\"shufflevector\");\n+        unsafe {\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+        }\n+    }\n+\n+    pub fn vector_splat(&self, num_elts: uint, elt: ValueRef) -> ValueRef {\n+        unsafe {\n+            let elt_ty = val_ty(elt);\n+            let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n+            let vec = self.insert_element(Undef, elt, C_i32(0));\n+            self.shuffle_vector(vec, Undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n+        }\n+    }\n+\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: uint) -> ValueRef {\n+        self.count_insn(\"extractvalue\");\n+        unsafe {\n+            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n+                       idx: uint) {\n+        self.count_insn(\"insertvalue\");\n+        unsafe {\n+            llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n+                                       noname());\n+        }\n+    }\n+\n+    pub fn is_null(&self, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"isnull\");\n+        unsafe {\n+            llvm::LLVMBuildIsNull(self.llbuilder, val, noname())\n+        }\n+    }\n+\n+    pub fn is_not_null(&self, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"isnotnull\");\n+        unsafe {\n+            llvm::LLVMBuildIsNotNull(self.llbuilder, val, noname())\n+        }\n+    }\n+\n+    pub fn ptrdiff(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"ptrdiff\");\n+        unsafe {\n+            llvm::LLVMBuildPtrDiff(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn trap(&self) {\n+        unsafe {\n+            let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n+            let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n+            let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n+            let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n+                llvm::LLVMGetNamedFunction(M, buf)\n+            });\n+            assert!((T as int != 0));\n+            let args: &[ValueRef] = [];\n+            self.count_insn(\"trap\");\n+            llvm::LLVMBuildCall(\n+                self.llbuilder, T, vec::raw::to_ptr(args), args.len() as c_uint, noname());\n+        }\n+    }\n+\n+    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: uint) -> ValueRef {\n+        self.count_insn(\"landingpad\");\n+        unsafe {\n+            llvm::LLVMBuildLandingPad(\n+                self.llbuilder, ty.to_ref(), pers_fn, num_clauses as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn set_cleanup(&self, landing_pad: ValueRef) {\n+        self.count_insn(\"setcleanup\");\n+        unsafe {\n+            llvm::LLVMSetCleanup(landing_pad, lib::llvm::True);\n+        }\n+    }\n+\n+    pub fn resume(&self, exn: ValueRef) -> ValueRef {\n+        self.count_insn(\"resume\");\n+        unsafe {\n+            llvm::LLVMBuildResume(self.llbuilder, exn)\n+        }\n+    }\n+\n+    // Atomic Operations\n+    pub fn atomic_cmpxchg(&self, dst: ValueRef,\n+                         cmp: ValueRef, src: ValueRef,\n+                         order: AtomicOrdering) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src, order)\n+        }\n+    }\n+    pub fn atomic_rmw(&self, op: AtomicBinOp,\n+                     dst: ValueRef, src: ValueRef,\n+                     order: AtomicOrdering) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildAtomicRMW(self.llbuilder, op, dst, src, order)\n+        }\n+    }\n+}"}, {"sha": "cdde96393a14f4a38a8fdf552657c46929736c25", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -11,7 +11,7 @@\n \n use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n-use lib::llvm::{llvm, ValueRef};\n+use lib::llvm::ValueRef;\n use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -25,7 +25,6 @@ use util::ppaux::ty_to_str;\n \n use middle::trans::type_::Type;\n \n-use std::str;\n use std::vec;\n use syntax::ast;\n use syntax::ast_map::path_name;\n@@ -326,23 +325,12 @@ pub fn load_environment(fcx: fn_ctxt,\n                         sigil: ast::Sigil) {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n-    let llloadenv = match fcx.llloadenv {\n-        Some(ll) => ll,\n-        None => {\n-            let ll =\n-                str::as_c_str(\"load_env\",\n-                              |buf|\n-                              unsafe {\n-                                llvm::LLVMAppendBasicBlockInContext(fcx.ccx.llcx,\n-                                                                    fcx.llfn,\n-                                                                    buf)\n-                              });\n-            fcx.llloadenv = Some(ll);\n-            ll\n-        }\n-    };\n+    // Don't bother to create the block if there's nothing to load\n+    if cap_vars.len() == 0 && !load_ret_handle {\n+        return;\n+    }\n \n-    let bcx = raw_block(fcx, false, llloadenv);\n+    let bcx = fcx.entry_bcx.get();\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);"}, {"sha": "f53f15a83d71e3272e17f093e1ab1bff61a509e7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -174,17 +174,14 @@ pub struct fn_ctxt_ {\n     // always be Some.\n     llretptr: Option<ValueRef>,\n \n+    entry_bcx: Option<block>,\n+\n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n-    // A block for all the function's static allocas, so that LLVM\n-    // will coalesce them into a single alloca call.\n-    llstaticallocas: Option<BasicBlockRef>,\n-    // A block containing code that copies incoming arguments to space\n-    // already allocated by code in one of the llallocas blocks.\n-    // (LLVM requires that arguments be copied to local allocas before\n-    // allowing most any operation to be performed on them.)\n-    llloadenv: Option<BasicBlockRef>,\n+    // A marker for the place where we want to insert the function's static\n+    // allocas, so that LLVM will coalesce them into a single alloca call.\n+    alloca_insert_pt: Option<ValueRef>,\n     llreturn: Option<BasicBlockRef>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n@@ -252,12 +249,12 @@ impl fn_ctxt_ {\n         }\n     }\n \n-    pub fn get_llstaticallocas(&mut self) -> BasicBlockRef {\n-        if self.llstaticallocas.is_none() {\n-            self.llstaticallocas = Some(base::mk_staticallocas_basic_block(self.llfn));\n+    pub fn cleanup(&mut self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.get());\n         }\n-\n-        self.llstaticallocas.get()\n+        // Remove the cycle between fcx and bcx, so memory can be freed\n+        self.entry_bcx = None;\n     }\n \n     pub fn get_llreturn(&mut self) -> BasicBlockRef {"}, {"sha": "2879e4babbceb91249ee54fcb83c1612f54e3eec", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -19,6 +19,7 @@ use middle::astencode;\n use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n+use middle::trans::builder::Builder;\n use middle::trans::debuginfo;\n use middle::trans::type_use;\n use middle::ty;\n@@ -227,6 +228,10 @@ impl CrateContext {\n             }\n         }\n     }\n+\n+    pub fn builder(@mut self) -> Builder {\n+        Builder::new(self)\n+    }\n }\n \n #[unsafe_destructor]"}, {"sha": "e26e37800bbc9b7e1f6602beff517bf1b2117332", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -188,7 +188,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n     set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n \n     return var_metadata;\n@@ -247,7 +247,7 @@ pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Optio\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                         DIB(cx), llptr, var_metadata, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n             }\n             return Some(var_metadata);\n         }"}, {"sha": "08fbfdee9eac0962d10d3c2010c6f3364bd04175", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -149,8 +149,7 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Declare the body of the shim function:\n     let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n \n     let llargbundle = get_param(llshimfn, 0u);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n@@ -162,13 +161,12 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Don't finish up the function in the usual way, because this doesn't\n     // follow the normal Rust calling conventions.\n-    tie_up_header_blocks(fcx, lltop);\n-\n     let ret_cx = match fcx.llreturn {\n         Some(llreturn) => raw_block(fcx, false, llreturn),\n         None => bcx\n     };\n     RetVoid(ret_cx);\n+    fcx.cleanup();\n \n     return llshimfn;\n }\n@@ -192,19 +190,15 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   ret_builder: wrap_ret_builder) {\n     let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n+    let bcx = fcx.entry_bcx.get();\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n     if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n-        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.get_llstaticallocas()),\n-                                   lloutputtype,\n-                                   \"\"));\n+        fcx.llretptr = Some(alloca(bcx, lloutputtype, \"\"));\n     }\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n-\n     // Allocate the struct and write the arguments into it.\n     let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n@@ -215,10 +209,6 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n-    // Perform a custom version of `finish_fn`. First, tie up the header\n-    // blocks.\n-    tie_up_header_blocks(fcx, lltop);\n-\n     // Then return according to the C ABI.\n     let return_context = match fcx.llreturn {\n         Some(llreturn) => raw_block(fcx, false, llreturn),\n@@ -239,6 +229,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n         let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n         Ret(return_context, Load(return_context, llretptr));\n     }\n+    fcx.cleanup();\n }\n \n // For each foreign function F, we generate a wrapper function W and a shim\n@@ -430,8 +421,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n+        let bcx = fcx.entry_bcx.get();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n@@ -443,7 +433,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n     }\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n@@ -456,8 +446,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n+        let bcx = fcx.entry_bcx.get();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n@@ -471,7 +460,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n     }\n \n     fn build_wrap_fn(ccx: @mut CrateContext,\n@@ -619,6 +608,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                output_type,\n                                true,\n                                Some(substs),\n+                               None,\n                                Some(item.span));\n \n     set_always_inline(fcx.llfn);\n@@ -628,7 +618,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    let mut bcx = top_scope_block(fcx, None);\n+    let mut bcx = fcx.entry_bcx.get();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -694,6 +684,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n         }\n \n+        fcx.cleanup();\n         return;\n     }\n \n@@ -942,6 +933,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n+    fcx.cleanup();\n }\n \n /**"}, {"sha": "d3f5b9844c930f6c1607c2637a976e063ad973da", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -546,18 +546,23 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n-    do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n-        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]);\n-        let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n-        Store(bcx, rc, rc_ptr);\n-        let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-        do with_cond(bcx, zero_test) |bcx| {\n-            match box_ptr_ptr {\n-                Some(p) => free_ty(bcx, p, t),\n-                None => free_ty_immediate(bcx, box_ptr, t)\n-            }\n-        }\n-    }\n+    let decr_bcx = sub_block(bcx, \"decr\");\n+    let free_bcx = sub_block(decr_bcx, \"free\");\n+    let next_bcx = sub_block(bcx, \"next\");\n+    CondBr(bcx, IsNotNull(bcx, box_ptr), decr_bcx.llbb, next_bcx.llbb);\n+\n+    let rc_ptr = GEPi(decr_bcx, box_ptr, [0u, abi::box_field_refcnt]);\n+    let rc = Sub(decr_bcx, Load(decr_bcx, rc_ptr), C_int(ccx, 1));\n+    Store(decr_bcx, rc, rc_ptr);\n+    CondBr(decr_bcx, IsNull(decr_bcx, rc), free_bcx.llbb, next_bcx.llbb);\n+\n+    let free_bcx = match box_ptr_ptr {\n+        Some(p) => free_ty(free_bcx, p, t),\n+        None => free_ty_immediate(free_bcx, box_ptr, t)\n+    };\n+    Br(free_bcx, next_bcx.llbb);\n+\n+    next_bcx\n }\n \n \n@@ -610,7 +615,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n             // Zero out the struct\n             unsafe {\n                 let ty = Type::from_ref(llvm::LLVMTypeOf(v));\n-                memzero(bcx, v, ty);\n+                memzero(&B(bcx), v, ty);\n             }\n \n           }\n@@ -702,13 +707,12 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n     let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n \n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n \n     return llfn;\n }"}, {"sha": "d47d9a4ff1628b63d5f51a57c7cbb1722595ead5", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -22,6 +22,7 @@ pub mod context;\n pub mod consts;\n pub mod type_of;\n pub mod build;\n+pub mod builder;\n pub mod base;\n pub mod _match;\n pub mod uniq;"}, {"sha": "6df1df454ff464aea41ec832fcd606fc152b8ff5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -303,15 +303,15 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = top_scope_block(fcx, None);\n+                let mut bcx = fcx.entry_bcx.get();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n                 Store(bcx, ret, fcx.llretptr.get());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n                 };\n-                finish_fn(fcx, bcx.llbb, bcx);\n+                finish_fn(fcx, bcx);\n                 llfdecl\n             };\n "}, {"sha": "48888760fc6650ca9ffdc5b853bb0c9b8833ca2e", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/7a3eaf8f27bd626a9667a574bc62464a815a6ad4/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=7a3eaf8f27bd626a9667a574bc62464a815a6ad4", "patch": "@@ -409,6 +409,7 @@ LLVMInsertBasicBlock\n LLVMInsertBasicBlockInContext\n LLVMInsertIntoBuilder\n LLVMInsertIntoBuilderWithName\n+LLVMInstructionEraseFromParent\n LLVMInt16Type\n LLVMInt16TypeInContext\n LLVMInt1Type"}]}