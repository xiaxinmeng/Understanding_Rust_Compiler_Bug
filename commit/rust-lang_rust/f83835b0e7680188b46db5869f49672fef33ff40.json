{"sha": "f83835b0e7680188b46db5869f49672fef33ff40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MzgzNWIwZTc2ODAxODhiNDZkYjU4NjlmNDk2NzJmZWYzM2ZmNDA=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T20:41:30Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T23:37:09Z"}, "message": "Moved the logic for a pausible idle callback into a new type - PausibleIdleCallback and placed the appropriate signatures in rtio and implementation into uvio.", "tree": {"sha": "1406a0624c0ad95dd6e59ebe7af667bc26413551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1406a0624c0ad95dd6e59ebe7af667bc26413551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83835b0e7680188b46db5869f49672fef33ff40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83835b0e7680188b46db5869f49672fef33ff40", "html_url": "https://github.com/rust-lang/rust/commit/f83835b0e7680188b46db5869f49672fef33ff40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83835b0e7680188b46db5869f49672fef33ff40/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d8baa76b0c03f6aceeb1f92120af664047ac02", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d8baa76b0c03f6aceeb1f92120af664047ac02", "html_url": "https://github.com/rust-lang/rust/commit/88d8baa76b0c03f6aceeb1f92120af664047ac02"}], "stats": {"total": 199, "additions": 103, "deletions": 96}, "files": [{"sha": "e29c30ba0334ae2c92c2e47f1f9678679345c15e", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=f83835b0e7680188b46db5869f49672fef33ff40", "patch": "@@ -24,22 +24,25 @@ pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n+pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n \n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n     fn callback_ms(&mut self, ms: u64, ~fn());\n     fn remote_callback(&mut self, ~fn()) -> ~RemoteCallbackObject;\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait RemoteCallback {\n-    /// Trigger the remote callback. Note that the number of times the callback\n-    /// is run is not guaranteed. All that is guaranteed is that, after calling 'fire',\n-    /// the callback will be called at least once, but multiple callbacks may be coalesced\n-    /// and callbacks may be called more often requested. Destruction also triggers the\n-    /// callback.\n+    /// Trigger the remote callback. Note that the number of times the\n+    /// callback is run is not guaranteed. All that is guaranteed is\n+    /// that, after calling 'fire', the callback will be called at\n+    /// least once, but multiple callbacks may be coalesced and\n+    /// callbacks may be called more often requested. Destruction also\n+    /// triggers the callback.\n     fn fire(&mut self);\n }\n "}, {"sha": "77e3a913e2f5a5a07ea56bcbc0d960ce0de95f24", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 23, "deletions": 73, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=f83835b0e7680188b46db5869f49672fef33ff40", "patch": "@@ -23,14 +23,13 @@ use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n use rt::local_ptr;\n use rt::local::Local;\n-use rt::rtio::RemoteCallback;\n+use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n use cell::Cell;\n use rand::{XorShiftRng, RngUtil};\n use iterator::{range};\n use vec::{OwnedVector};\n-use rt::uv::idle::IdleWatcher;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -78,10 +77,13 @@ pub struct Scheduler {\n     friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n-    /// An IdleWatcher\n-    idle_watcher: Option<IdleWatcher>,\n-    /// A flag to indicate whether or not the idle callback is active.\n-    idle_flag: bool\n+    /// A toggleable idle callback\n+    idle_callback: ~PausibleIdleCallback\n+}\n+\n+enum CleanupJob {\n+    DoNothing,\n+    GiveTask(~Task, UnsafeTaskReceiver)\n }\n \n pub struct SchedHandle {\n@@ -97,11 +99,6 @@ pub enum SchedMessage {\n     TaskFromFriend(~Task)\n }\n \n-enum CleanupJob {\n-    DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n-}\n-\n impl Scheduler {\n \n     pub fn sched_id(&self) -> uint { to_uint(self) }\n@@ -126,7 +123,10 @@ impl Scheduler {\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>)\n-        -> Scheduler {\n+        -> Scheduler {        \n+\n+        let mut event_loop = event_loop;\n+        let idle_callback = event_loop.pausible_idle_callback();\n \n         Scheduler {\n             sleeper_list: sleeper_list,\n@@ -142,9 +142,8 @@ impl Scheduler {\n             metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n             friend_handle: friend,\n-            rng: XorShiftRng::new(),\n-            idle_watcher: None,\n-            idle_flag: false\n+            rng: XorShiftRng::new(),            \n+            idle_callback: idle_callback\n         }\n     }\n \n@@ -172,7 +171,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        this.activate_idle();\n+        this.idle_callback.start(Scheduler::run_sched_once);\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -194,14 +193,17 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        let mut stask = Local::take::<Task>();\n+        let mut stask = Local::take::<Task>();        \n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n         assert!(message.is_none());\n \n+        // Close the idle callback.\n+        stask.sched.get_mut_ref().idle_callback.close();\n+\n         stask.destroyed = true;\n     }\n \n@@ -211,11 +213,6 @@ impl Scheduler {\n \n         let mut self_sched = self;\n \n-        // Always run through the scheduler loop at least once so that\n-        // we enter the sleep state and can then be woken up by other\n-        // schedulers.\n-//        self_sched.event_loop.callback(Scheduler::run_sched_once);\n-\n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n         // mutable reference to the event_loop to give it the \"run\"\n@@ -252,7 +249,7 @@ impl Scheduler {\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n-        sched.activate_idle();\n+        sched.idle_callback.resume();\n \n         // Our first task is to read mail to see if we have important\n         // messages.\n@@ -300,59 +297,19 @@ impl Scheduler {\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n             // Since we are sleeping, deactivate the idle callback.\n-            sched.pause_idle();\n+            sched.idle_callback.pause();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n             // We may not be sleeping, but we still need to deactivate\n             // the idle callback.\n-            sched.pause_idle();\n+            sched.idle_callback.pause();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n         // in TLS.\n         Local::put(sched);\n     }\n \n-    fn activate_idle(&mut self) {\n-        rtdebug!(\"activating idle\");\n-        if self.idle_flag {\n-            rtassert!(self.idle_watcher.is_some());\n-            rtdebug!(\"idle flag already set, not reactivating idle watcher\");\n-        } else {\n-            rtdebug!(\"idle flag was false, reactivating idle watcher\");\n-            self.idle_flag = true;\n-            if self.idle_watcher.is_none() {\n-                // There's no idle handle yet. Create one\n-                let mut idle_watcher = IdleWatcher::new(self.event_loop.uvio.uv_loop());\n-                do idle_watcher.start |_idle_watcher, _status| {\n-                    Scheduler::run_sched_once();\n-                }\n-                self.idle_watcher = Some(idle_watcher);\n-            } else {\n-                self.idle_watcher.get_mut_ref().restart();\n-            }\n-        }            \n-    }\n-\n-    fn pause_idle(&mut self) {\n-        rtassert!(self.idle_watcher.is_some());\n-        rtassert!(self.idle_flag);\n-\n-        rtdebug!(\"stopping idle watcher\");\n-\n-        self.idle_flag = false;\n-        if !self.no_sleep {\n-            self.idle_watcher.get_mut_ref().stop();\n-        } else {\n-            rtdebug!(\"closing idle watcher\");\n-            // The scheduler is trying to exit. Destroy the idle watcher\n-            // to drop the reference to the event loop.\n-            let mut idle_watcher = self.idle_watcher.take_unwrap();\n-            idle_watcher.stop();\n-            idle_watcher.close(||());\n-        }\n-    }\n-\n     pub fn make_handle(&mut self) -> SchedHandle {\n         let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n \n@@ -376,10 +333,9 @@ impl Scheduler {\n \n         // We push the task onto our local queue clone.\n         this.work_queue.push(task);\n-//        this.event_loop.callback(Scheduler::run_sched_once);\n \n         // There is definitely work to be done later. Make sure we wake up for it.\n-        this.activate_idle();\n+        this.idle_callback.resume();\n \n         // We've made work available. Notify a\n         // sleeping scheduler.\n@@ -420,28 +376,23 @@ impl Scheduler {\n         let mut this = self;\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n-//                this.event_loop.callback(Scheduler::run_sched_once);\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n-//                this.event_loop.callback(Scheduler::run_sched_once);\n                 rtdebug!(\"got a task from a friend. lovely!\");\n                 this.sched_schedule_task(task).map_move(Local::put);\n                 return None;\n             }\n             Some(Wake) => {\n-//                this.event_loop.callback(Scheduler::run_sched_once);\n                 this.sleepy = false;\n                 Local::put(this);\n                 return None;\n-//                return Some(this);\n             }\n             Some(Shutdown) => {\n                 rtdebug!(\"shutting down\");\n-//                this.event_loop.callback(Scheduler::run_sched_once);\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n@@ -463,7 +414,6 @@ impl Scheduler {\n \n                 Local::put(this);\n                 return None;\n-//                return Some(this);\n             }\n             None => {\n                 return Some(this);"}, {"sha": "12a6f6f37f76b321b0fd50e6ce3ea2f4a3cd5355", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 72, "deletions": 18, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83835b0e7680188b46db5869f49672fef33ff40/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=f83835b0e7680188b46db5869f49672fef33ff40", "patch": "@@ -116,6 +116,15 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n+        let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n+        return ~UvPausibleIdleCallback {\n+            watcher: idle_watcher,\n+            idle_flag: false,\n+            closed: false\n+        };\n+    }\n+\n     fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n         let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n         do timer.start(ms, 0) |timer, status| {\n@@ -134,6 +143,44 @@ impl EventLoop for UvEventLoop {\n     }\n }\n \n+pub struct UvPausibleIdleCallback {\n+    watcher: IdleWatcher,\n+    idle_flag: bool,\n+    closed: bool\n+}\n+\n+impl UvPausibleIdleCallback {\n+    #[inline]\n+    pub fn start(&mut self, f: ~fn()) {\n+        do self.watcher.start |_idle_watcher, _status| {\n+            f();\n+        };\n+        self.idle_flag = true;\n+    }\n+    #[inline]\n+    pub fn pause(&mut self) {\n+        if self.idle_flag == true {\n+            self.watcher.stop();\n+            self.idle_flag = false;\n+        }\n+    }\n+    #[inline]\n+    pub fn resume(&mut self) {\n+        if self.idle_flag == false {\n+            self.watcher.restart();\n+            self.idle_flag = true;\n+        }\n+    }\n+    #[inline]\n+    pub fn close(&mut self) {\n+        self.pause();\n+        if !self.closed {\n+            self.closed = true;\n+            self.watcher.close(||());\n+        }\n+    }                \n+}\n+\n #[test]\n fn test_callback_run_once() {\n     do run_in_bare_thread {\n@@ -163,24 +210,31 @@ impl UvRemoteCallback {\n         let async = do AsyncWatcher::new(loop_) |watcher, status| {\n             assert!(status.is_none());\n \n-            // The synchronization logic here is subtle. To review, the uv async handle\n-            // type promises that, after it is triggered the remote callback is definitely\n-            // called at least once. UvRemoteCallback needs to maintain those semantics\n-            // while also shutting down cleanly from the dtor. In our case that means that,\n-            // when the UvRemoteCallback dtor calls `async.send()`, here `f` is always called\n-            // later.\n-\n-            // In the dtor both the exit flag is set and the async callback fired under a lock.\n-            // Here, before calling `f`, we take the lock and check the flag. Because we are\n-            // checking the flag before calling `f`, and the flag is set under the same lock\n-            // as the send, then if the flag is set then we're guaranteed to call `f` after\n-            // the final send.\n-\n-            // If the check was done after `f()` then there would be a period between that call\n-            // and the check where the dtor could be called in the other thread, missing the\n-            // final callback while still destroying the handle.\n-\n-            let should_exit = unsafe { exit_flag_clone.with_imm(|&should_exit| should_exit) };\n+            // The synchronization logic here is subtle. To review,\n+            // the uv async handle type promises that, after it is\n+            // triggered the remote callback is definitely called at\n+            // least once. UvRemoteCallback needs to maintain those\n+            // semantics while also shutting down cleanly from the\n+            // dtor. In our case that means that, when the\n+            // UvRemoteCallback dtor calls `async.send()`, here `f` is\n+            // always called later.\n+\n+            // In the dtor both the exit flag is set and the async\n+            // callback fired under a lock.  Here, before calling `f`,\n+            // we take the lock and check the flag. Because we are\n+            // checking the flag before calling `f`, and the flag is\n+            // set under the same lock as the send, then if the flag\n+            // is set then we're guaranteed to call `f` after the\n+            // final send.\n+\n+            // If the check was done after `f()` then there would be a\n+            // period between that call and the check where the dtor\n+            // could be called in the other thread, missing the final\n+            // callback while still destroying the handle.\n+\n+            let should_exit = unsafe { \n+                exit_flag_clone.with_imm(|&should_exit| should_exit) \n+            };\n \n             f();\n "}]}