{"sha": "40a0c835b512599a950f99a09dcf1685f7e1bb65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYTBjODM1YjUxMjU5OWE5NTBmOTlhMDlkY2YxNjg1ZjdlMWJiNjU=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-03T17:58:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T10:08:09Z"}, "message": "Separate libarena::lib module", "tree": {"sha": "1df13cab5e11645ca4e28b5e1fcd551a56b0728c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1df13cab5e11645ca4e28b5e1fcd551a56b0728c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40a0c835b512599a950f99a09dcf1685f7e1bb65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40a0c835b512599a950f99a09dcf1685f7e1bb65", "html_url": "https://github.com/rust-lang/rust/commit/40a0c835b512599a950f99a09dcf1685f7e1bb65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40a0c835b512599a950f99a09dcf1685f7e1bb65/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89292beedb84977970a6ab0e3a0ad695e2fcf7db", "url": "https://api.github.com/repos/rust-lang/rust/commits/89292beedb84977970a6ab0e3a0ad695e2fcf7db", "html_url": "https://github.com/rust-lang/rust/commit/89292beedb84977970a6ab0e3a0ad695e2fcf7db"}], "stats": {"total": 429, "additions": 214, "deletions": 215}, "files": [{"sha": "e2a249c8e61c08c033114ceb20b1c3d99ebd4e44", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 215, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/40a0c835b512599a950f99a09dcf1685f7e1bb65/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a0c835b512599a950f99a09dcf1685f7e1bb65/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=40a0c835b512599a950f99a09dcf1685f7e1bb65", "patch": "@@ -617,218 +617,4 @@ impl SyncDroplessArena {\n }\n \n #[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use super::TypedArena;\n-    use std::cell::Cell;\n-\n-    #[allow(dead_code)]\n-    #[derive(Debug, Eq, PartialEq)]\n-    struct Point {\n-        x: i32,\n-        y: i32,\n-        z: i32,\n-    }\n-\n-    #[test]\n-    pub fn test_unused() {\n-        let arena: TypedArena<Point> = TypedArena::default();\n-        assert!(arena.chunks.borrow().is_empty());\n-    }\n-\n-    #[test]\n-    fn test_arena_alloc_nested() {\n-        struct Inner {\n-            value: u8,\n-        }\n-        struct Outer<'a> {\n-            inner: &'a Inner,\n-        }\n-        enum EI<'e> {\n-            I(Inner),\n-            O(Outer<'e>),\n-        }\n-\n-        struct Wrap<'a>(TypedArena<EI<'a>>);\n-\n-        impl<'a> Wrap<'a> {\n-            fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-                if let &EI::I(ref i) = r {\n-                    i\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-                if let &EI::O(ref o) = r {\n-                    o\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-        }\n-\n-        let arena = Wrap(TypedArena::default());\n-\n-        let result = arena.alloc_outer(|| Outer {\n-            inner: arena.alloc_inner(|| Inner { value: 10 }),\n-        });\n-\n-        assert_eq!(result.inner.value, 10);\n-    }\n-\n-    #[test]\n-    pub fn test_copy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n-        })\n-    }\n-\n-    #[allow(dead_code)]\n-    struct Noncopy {\n-        string: String,\n-        array: Vec<i32>,\n-    }\n-\n-    #[test]\n-    pub fn test_noncopy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_zero_sized() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(());\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_clear() {\n-        let mut arena = TypedArena::default();\n-        for _ in 0..10 {\n-            arena.clear();\n-            for _ in 0..10000 {\n-                arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            }\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_typed_arena_clear(b: &mut Bencher) {\n-        let mut arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            arena.clear();\n-        })\n-    }\n-\n-    // Drop tests\n-\n-    struct DropCounter<'a> {\n-        count: &'a Cell<u32>,\n-    }\n-\n-    impl Drop for DropCounter<'_> {\n-        fn drop(&mut self) {\n-            self.count.set(self.count.get() + 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_count() {\n-        let counter = Cell::new(0);\n-        {\n-            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-        };\n-        assert_eq!(counter.get(), 100);\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_on_clear() {\n-        let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-        for i in 0..10 {\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-            arena.clear();\n-            assert_eq!(counter.get(), i * 100 + 100);\n-        }\n-    }\n-\n-    thread_local! {\n-        static DROP_COUNTER: Cell<u32> = Cell::new(0)\n-    }\n-\n-    struct SmallDroppable;\n-\n-    impl Drop for SmallDroppable {\n-        fn drop(&mut self) {\n-            DROP_COUNTER.with(|c| c.set(c.get() + 1));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_small_count() {\n-        DROP_COUNTER.with(|c| c.set(0));\n-        {\n-            let arena: TypedArena<SmallDroppable> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(SmallDroppable);\n-            }\n-            // dropping\n-        };\n-        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            })\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        })\n-    }\n-}\n+mod tests;"}, {"sha": "fa4189409d0e86ad67776c7bd973f12d5802fec6", "filename": "src/libarena/tests.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/40a0c835b512599a950f99a09dcf1685f7e1bb65/src%2Flibarena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a0c835b512599a950f99a09dcf1685f7e1bb65/src%2Flibarena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Ftests.rs?ref=40a0c835b512599a950f99a09dcf1685f7e1bb65", "patch": "@@ -0,0 +1,213 @@\n+extern crate test;\n+use test::Bencher;\n+use super::TypedArena;\n+use std::cell::Cell;\n+\n+#[allow(dead_code)]\n+#[derive(Debug, Eq, PartialEq)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+\n+#[test]\n+pub fn test_unused() {\n+    let arena: TypedArena<Point> = TypedArena::default();\n+    assert!(arena.chunks.borrow().is_empty());\n+}\n+\n+#[test]\n+fn test_arena_alloc_nested() {\n+    struct Inner {\n+        value: u8,\n+    }\n+    struct Outer<'a> {\n+        inner: &'a Inner,\n+    }\n+    enum EI<'e> {\n+        I(Inner),\n+        O(Outer<'e>),\n+    }\n+\n+    struct Wrap<'a>(TypedArena<EI<'a>>);\n+\n+    impl<'a> Wrap<'a> {\n+        fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n+            let r: &EI<'_> = self.0.alloc(EI::I(f()));\n+            if let &EI::I(ref i) = r {\n+                i\n+            } else {\n+                panic!(\"mismatch\");\n+            }\n+        }\n+        fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n+            let r: &EI<'_> = self.0.alloc(EI::O(f()));\n+            if let &EI::O(ref o) = r {\n+                o\n+            } else {\n+                panic!(\"mismatch\");\n+            }\n+        }\n+    }\n+\n+    let arena = Wrap(TypedArena::default());\n+\n+    let result = arena.alloc_outer(|| Outer {\n+        inner: arena.alloc_inner(|| Inner { value: 10 }),\n+    });\n+\n+    assert_eq!(result.inner.value, 10);\n+}\n+\n+#[test]\n+pub fn test_copy() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(Point { x: 1, y: 2, z: 3 });\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_copy(b: &mut Bencher) {\n+    let arena = TypedArena::default();\n+    b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n+}\n+\n+#[bench]\n+pub fn bench_copy_nonarena(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n+    })\n+}\n+\n+#[allow(dead_code)]\n+struct Noncopy {\n+    string: String,\n+    array: Vec<i32>,\n+}\n+\n+#[test]\n+pub fn test_noncopy() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        });\n+    }\n+}\n+\n+#[test]\n+pub fn test_typed_arena_zero_sized() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(());\n+    }\n+}\n+\n+#[test]\n+pub fn test_typed_arena_clear() {\n+    let mut arena = TypedArena::default();\n+    for _ in 0..10 {\n+        arena.clear();\n+        for _ in 0..10000 {\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        }\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_typed_arena_clear(b: &mut Bencher) {\n+    let mut arena = TypedArena::default();\n+    b.iter(|| {\n+        arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        arena.clear();\n+    })\n+}\n+\n+// Drop tests\n+\n+struct DropCounter<'a> {\n+    count: &'a Cell<u32>,\n+}\n+\n+impl Drop for DropCounter<'_> {\n+    fn drop(&mut self) {\n+        self.count.set(self.count.get() + 1);\n+    }\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_count() {\n+    let counter = Cell::new(0);\n+    {\n+        let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(DropCounter { count: &counter });\n+        }\n+    };\n+    assert_eq!(counter.get(), 100);\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_on_clear() {\n+    let counter = Cell::new(0);\n+    let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n+    for i in 0..10 {\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(DropCounter { count: &counter });\n+        }\n+        arena.clear();\n+        assert_eq!(counter.get(), i * 100 + 100);\n+    }\n+}\n+\n+thread_local! {\n+    static DROP_COUNTER: Cell<u32> = Cell::new(0)\n+}\n+\n+struct SmallDroppable;\n+\n+impl Drop for SmallDroppable {\n+    fn drop(&mut self) {\n+        DROP_COUNTER.with(|c| c.set(c.get() + 1));\n+    }\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_small_count() {\n+    DROP_COUNTER.with(|c| c.set(0));\n+    {\n+        let arena: TypedArena<SmallDroppable> = TypedArena::default();\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(SmallDroppable);\n+        }\n+        // dropping\n+    };\n+    assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n+}\n+\n+#[bench]\n+pub fn bench_noncopy(b: &mut Bencher) {\n+    let arena = TypedArena::default();\n+    b.iter(|| {\n+        arena.alloc(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        })\n+    })\n+}\n+\n+#[bench]\n+pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = Box::new(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        });\n+    })\n+}"}]}