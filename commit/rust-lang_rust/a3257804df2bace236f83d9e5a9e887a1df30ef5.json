{"sha": "a3257804df2bace236f83d9e5a9e887a1df30ef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMjU3ODA0ZGYyYmFjZTIzNmY4M2Q5ZTVhOWU4ODdhMWRmMzBlZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-08T00:31:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-08T00:31:42Z"}, "message": "auto merge of #15406 : luqmana/rust/nop, r=pcwalton\n\nExtend the null ptr optimization to work with slices, closures, procs, & trait objects by using the internal pointers as the discriminant.\r\n\r\nThis decreases the size of `Option<&[int]>` (and similar) by one word.", "tree": {"sha": "c363f1128a77eade9cfd55fc52589f4aaf7681d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c363f1128a77eade9cfd55fc52589f4aaf7681d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3257804df2bace236f83d9e5a9e887a1df30ef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3257804df2bace236f83d9e5a9e887a1df30ef5", "html_url": "https://github.com/rust-lang/rust/commit/a3257804df2bace236f83d9e5a9e887a1df30ef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3257804df2bace236f83d9e5a9e887a1df30ef5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00cdd639a93ec1dcad85cebc52214eeba0441c93", "url": "https://api.github.com/repos/rust-lang/rust/commits/00cdd639a93ec1dcad85cebc52214eeba0441c93", "html_url": "https://github.com/rust-lang/rust/commit/00cdd639a93ec1dcad85cebc52214eeba0441c93"}, {"sha": "fa8da9d6b317f39402f1127575e2bd08db33c508", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8da9d6b317f39402f1127575e2bd08db33c508", "html_url": "https://github.com/rust-lang/rust/commit/fa8da9d6b317f39402f1127575e2bd08db33c508"}], "stats": {"total": 262, "additions": 185, "deletions": 77}, "files": [{"sha": "6e2dc95cfd6e506f47e519e726cfcb51cdff6eae", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -27,6 +27,10 @@ use {Collection, Mutable};\n use slice::{MutableOrdVector, MutableVectorAllocating, CloneableVector};\n use slice::{Items, MutItems};\n \n+\n+#[doc(hidden)]\n+pub static PTR_MARKER: u8 = 0;\n+\n /// An owned, growable vector.\n ///\n /// # Examples\n@@ -71,7 +75,11 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn new() -> Vec<T> {\n-        Vec { len: 0, cap: 0, ptr: 0 as *mut T }\n+        // We want ptr to never be NULL so instead we set it to some arbitrary\n+        // non-null value which is fine since we never call deallocate on the ptr\n+        // if cap is 0. The reason for this is because the pointer of a slice\n+        // being NULL would break the null pointer optimization for enums.\n+        Vec { len: 0, cap: 0, ptr: &PTR_MARKER as *const _ as *mut T }\n     }\n \n     /// Constructs a new, empty `Vec` with the specified capacity.\n@@ -88,7 +96,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { len: 0, cap: uint::MAX, ptr: 0 as *mut T }\n+            Vec { len: 0, cap: uint::MAX, ptr: &PTR_MARKER as *const _ as *mut T }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n@@ -1206,15 +1214,7 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_ptr(&self) -> *const T {\n-        // If we have a 0-sized vector, then the base pointer should not be NULL\n-        // because an iterator over the slice will attempt to yield the base\n-        // pointer as the first element in the vector, but this will end up\n-        // being Some(NULL) which is optimized to None.\n-        if mem::size_of::<T>() == 0 {\n-            1 as *const T\n-        } else {\n-            self.ptr as *const T\n-        }\n+        self.ptr as *const T\n     }\n \n     /// Returns a mutable unsafe pointer to the vector's buffer.\n@@ -1226,12 +1226,7 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n-        // see above for the 0-size check\n-        if mem::size_of::<T>() == 0 {\n-            1 as *mut T\n-        } else {\n-            self.ptr\n-        }\n+        self.ptr\n     }\n \n     /// Retains only the elements specified by the predicate."}, {"sha": "8197a7c2dcbe2dc3904f20d1fbbc3457a0f1f68a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -884,17 +884,20 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n+                        if mem::size_of::<T>() == 0 {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n-                            transmute(self.ptr as uint + 1)\n+                            self.ptr = transmute(self.ptr as uint + 1);\n+\n+                            // Use a non-null pointer value\n+                            Some(transmute(1u))\n                         } else {\n-                            self.ptr.offset(1)\n-                        };\n+                            let old = self.ptr;\n+                            self.ptr = self.ptr.offset(1);\n \n-                        Some(transmute(old))\n+                            Some(transmute(old))\n+                        }\n                     }\n                 }\n             }\n@@ -916,13 +919,17 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n+                        if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n+                            self.end = transmute(self.end as uint - 1);\n+\n+                            // Use a non-null pointer value\n+                            Some(transmute(1u))\n                         } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n+                            self.end = self.end.offset(-1);\n+\n+                            Some(transmute(self.end))\n+                        }\n                     }\n                 }\n             }\n@@ -956,7 +963,12 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     fn idx(&mut self, index: uint) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n+                if mem::size_of::<T>() == 0 {\n+                    // Use a non-null pointer value\n+                    Some(transmute(1u))\n+                } else {\n+                    Some(transmute(self.ptr.offset(index as int)))\n+                }\n             } else {\n                 None\n             }"}, {"sha": "4c7db01657bc9e81950b90c77069ad1665ea5456", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 99, "deletions": 42, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -111,7 +111,7 @@ pub enum Repr {\n     StructWrappedNullablePointer {\n         pub nonnull: Struct,\n         pub nndiscr: Disr,\n-        pub ptrfield: uint,\n+        pub ptrfield: PointerField,\n         pub nullfields: Vec<ty::t>,\n     }\n }\n@@ -211,24 +211,21 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases.get(1 - discr).is_zerolen(cx) {\n+                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(), false);\n                         match cases.get(discr).find_ptr() {\n+                            Some(ThinPointer(_)) if st.fields.len() == 1 => {\n+                                return RawNullablePointer {\n+                                    nndiscr: discr as Disr,\n+                                    nnty: *st.fields.get(0),\n+                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                };\n+                            }\n                             Some(ptrfield) => {\n-                                let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n-                                                   false);\n-\n-                                return if st.fields.len() == 1 {\n-                                    RawNullablePointer {\n-                                        nndiscr: discr as Disr,\n-                                        nnty: *st.fields.get(0),\n-                                        nullfields: cases.get(1 - discr).tys.clone()\n-                                    }\n-                                } else {\n-                                    StructWrappedNullablePointer {\n-                                        nndiscr: discr as Disr,\n-                                        nonnull: st,\n-                                        ptrfield: ptrfield,\n-                                        nullfields: cases.get(1 - discr).tys.clone()\n-                                    }\n+                                return StructWrappedNullablePointer {\n+                                    nndiscr: discr as Disr,\n+                                    nonnull: st,\n+                                    ptrfield: ptrfield,\n+                                    nullfields: cases.get(1 - discr).tys.clone()\n                                 };\n                             }\n                             None => { }\n@@ -283,23 +280,67 @@ pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n // this should probably all be in ty\n-struct Case { discr: Disr, tys: Vec<ty::t> }\n+struct Case {\n+    discr: Disr,\n+    tys: Vec<ty::t>\n+}\n+\n+\n+#[deriving(Show)]\n+pub enum PointerField {\n+    ThinPointer(uint),\n+    FatPointer(uint, uint)\n+}\n+\n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n-    fn find_ptr(&self) -> Option<uint> {\n-        self.tys.iter().position(|&ty| {\n+    fn find_ptr(&self) -> Option<PointerField> {\n+        use back::abi::{fn_field_code, slice_elt_base, trt_field_box};\n+\n+        for (i, &ty) in self.tys.iter().enumerate() {\n             match ty::get(ty).sty {\n-                ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n-                    ty::ty_vec(_, None) | ty::ty_str| ty::ty_trait(..) => false,\n-                    _ => true,\n+                // &T/&mut T could either be a thin or fat pointer depending on T\n+                ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+                    // &[T] and &str are a pointer and length pair\n+                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i, slice_elt_base)),\n+\n+                    // &Trait/&mut Trait are a pair of pointers: the actual object and a vtable\n+                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n+\n+                    // Any other &T/&mut T is just a pointer\n+                    _ => return Some(ThinPointer(i))\n+                },\n+\n+                // Box<T> could either be a thin or fat pointer depending on T\n+                ty::ty_uniq(t) => match ty::get(t).sty {\n+                    // Box<[T]>/Box<str> might be FatPointer in a post DST world\n+                    ty::ty_vec(_, None) | ty::ty_str => continue,\n+\n+                    // Box<Trait> is a pair of pointers: the actual object and a vtable\n+                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n+\n+                    // Any other Box<T> is just a pointer\n+                    _ => return Some(ThinPointer(i))\n                 },\n-                ty::ty_box(..) | ty::ty_bare_fn(..) => true,\n-                // Is that everything?  Would closures or slices qualify?\n-                _ => false\n+\n+                // Gc<T> is just a pointer\n+                ty::ty_box(..) => return Some(ThinPointer(i)),\n+\n+                // Functions are just pointers\n+                ty::ty_bare_fn(..) => return Some(ThinPointer(i)),\n+\n+                // Closures are a pair of pointers: the code and environment\n+                ty::ty_closure(..) => return Some(FatPointer(i, fn_field_code)),\n+\n+                // Anything else is not a pointer\n+                _ => continue\n+\n             }\n-        })\n+        }\n+\n+        None\n     }\n }\n \n@@ -552,8 +593,8 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n             signed = false;\n         }\n-        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            val = struct_wrapped_nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -563,12 +604,15 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: PointerField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n+    let llptrptr = match ptrfield {\n+        ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n+        FatPointer(field, pair) => GEPi(bcx, scrutinee, [0, field, pair])\n+    };\n+    let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n-    ICmp(bcx, cmp, llptr, C_null(llptrty))\n+    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n@@ -655,9 +699,15 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n-                let llptrty = type_of::type_of(bcx.ccx(),\n-                                               *nonnull.fields.get(ptrfield));\n+                let (llptrptr, llptrty) = match ptrfield {\n+                    ThinPointer(field) =>\n+                        (GEPi(bcx, val, [0, field]),\n+                         type_of::type_of(bcx.ccx(), *nonnull.fields.get(field))),\n+                    FatPointer(field, pair) => {\n+                        let v = GEPi(bcx, val, [0, field, pair]);\n+                        (v, val_ty(v).element_type())\n+                    }\n+                };\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -925,7 +975,11 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            if is_null(const_struct_field(ccx, val, ptrfield)) {\n+            let (idx, sub_idx) = match ptrfield {\n+                ThinPointer(field) => (field, None),\n+                FatPointer(field, pair) => (field, Some(pair))\n+            };\n+            if is_null(const_struct_field(ccx, val, idx, sub_idx)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n             } else {\n@@ -946,26 +1000,29 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix),\n-        General(..) => const_struct_field(ccx, val, ix + 1),\n+        Univariant(..) => const_struct_field(ccx, val, ix, None),\n+        General(..) => const_struct_field(ccx, val, ix + 1, None),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         }\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix, None)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint)\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint, sub_idx: Option<uint>)\n     -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = const_get_elt(ccx, val, [real_ix]);\n+            field = match sub_idx {\n+                Some(si) => const_get_elt(ccx, val, [real_ix, si as u32]),\n+                None => const_get_elt(ccx, val, [real_ix])\n+            };\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "52a097ca6f0b03b248147fd76752067fdd0a1a16", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -484,8 +484,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n                 else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n               }\n-              (expr::cast_enum, expr::cast_integral) |\n-              (expr::cast_enum, expr::cast_float)  => {\n+              (expr::cast_enum, expr::cast_integral) => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type, discr, false);"}, {"sha": "f281d8e24486cb5ecdbe1c1f3b48626640a37283", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -2152,8 +2152,12 @@ impl EnumMemberDescriptionFactory {\n                 let null_variant_index = (1 - nndiscr) as uint;\n                 let null_variant_ident = self.variants.get(null_variant_index).name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n+                let discrfield = match ptrfield {\n+                    adt::ThinPointer(field) => format!(\"{}\", field),\n+                    adt::FatPointer(field, pair) => format!(\"{}${}\", field, pair)\n+                };\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                ptrfield,\n+                                                discrfield,\n                                                 null_variant_name);\n \n                 // Create the (singleton) list of descriptions of union members.\n@@ -2196,7 +2200,7 @@ impl VariantMemberDescriptionFactory {\n \n enum EnumDiscriminantInfo {\n     RegularDiscriminant(DIType),\n-    OptimizedDiscriminant(uint),\n+    OptimizedDiscriminant(adt::PointerField),\n     NoDiscriminant\n }\n "}, {"sha": "19d7d6c6a0091472d94a075a3d9f252fbd0f0c21", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -155,8 +155,9 @@ pub fn trans_slice_vstore<'a>(\n     let llcount = C_uint(ccx, count);\n     let llfixed;\n     if count == 0 {\n-        // Zero-length array: just use NULL as the data pointer\n-        llfixed = C_null(vt.llunit_ty.ptr_to());\n+        // Just create a zero-sized alloca to preserve\n+        // the non-null invariant of the inner slice ptr\n+        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n     } else {\n         // Make a fixed-length backing array and allocate it on the stack.\n         llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);"}, {"sha": "bd9dfc1e44901991c9d4fc1cd1f10e3e6efbe261", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3257804df2bace236f83d9e5a9e887a1df30ef5/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=a3257804df2bace236f83d9e5a9e887a1df30ef5", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::gc::Gc;\n+use std::mem::size_of;\n+\n+trait Trait {}\n+\n+fn main() {\n+    // Closures - || / proc()\n+    assert_eq!(size_of::<proc()>(), size_of::<Option<proc()>>());\n+    assert_eq!(size_of::<||>(), size_of::<Option<||>>());\n+\n+    // Functions\n+    assert_eq!(size_of::<fn(int)>(), size_of::<Option<fn(int)>>());\n+    assert_eq!(size_of::<extern \"C\" fn(int)>(), size_of::<Option<extern \"C\" fn(int)>>());\n+\n+    // Slices - &str / &[T] / &mut [T]\n+    assert_eq!(size_of::<&str>(), size_of::<Option<&str>>());\n+    assert_eq!(size_of::<&[int]>(), size_of::<Option<&[int]>>());\n+    assert_eq!(size_of::<&mut [int]>(), size_of::<Option<&mut [int]>>());\n+\n+    // Traits - Box<Trait> / &Trait / &mut Trait\n+    assert_eq!(size_of::<Box<Trait>>(), size_of::<Option<Box<Trait>>>());\n+    assert_eq!(size_of::<&Trait>(), size_of::<Option<&Trait>>());\n+    assert_eq!(size_of::<&mut Trait>(), size_of::<Option<&mut Trait>>());\n+\n+    // Pointers - Box<T> / Gc<T>\n+    assert_eq!(size_of::<Box<int>>(), size_of::<Option<Box<int>>>());\n+    assert_eq!(size_of::<Gc<int>>(), size_of::<Option<Gc<int>>>());\n+\n+}"}]}