{"sha": "b0a82d9314083cad0c985c8f5f752749c9ae96ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYTgyZDkzMTQwODNjYWQwYzk4NWM4ZjVmNzUyNzQ5YzlhZTk2Y2E=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-28T11:55:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:33:04Z"}, "message": "simplify len macro: No longer require the type\n\nAlso use ident, not expr, to avoid accidental side-effects", "tree": {"sha": "4b0fb17b942cc4c92d39d052fb411d9820eaada0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b0fb17b942cc4c92d39d052fb411d9820eaada0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0a82d9314083cad0c985c8f5f752749c9ae96ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a82d9314083cad0c985c8f5f752749c9ae96ca", "html_url": "https://github.com/rust-lang/rust/commit/b0a82d9314083cad0c985c8f5f752749c9ae96ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0a82d9314083cad0c985c8f5f752749c9ae96ca/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "html_url": "https://github.com/rust-lang/rust/commit/3e3ff4b6526c19b5bb5dd67a9431479244874ed3"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "a807e92a2a8412c5b6fae918c6259b016e7b5c74", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0a82d9314083cad0c985c8f5f752749c9ae96ca/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a82d9314083cad0c985c8f5f752749c9ae96ca/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b0a82d9314083cad0c985c8f5f752749c9ae96ca", "patch": "@@ -2337,18 +2337,25 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n+// Macro helper functions\n+#[inline(always)]\n+fn size_from_ptr<T>(_: *const T) -> usize {\n+    mem::size_of::<T>()\n+}\n+\n // Inlining is_empty and len makes a huge performance difference\n macro_rules! is_empty {\n     // The way we encode the length of a ZST iterator, this works both for ZST\n     // and non-ZST.\n-    ($self: expr) => {$self.ptr == $self.end}\n+    ($self: ident) => {$self.ptr == $self.end}\n }\n macro_rules! len {\n-    ($T: ty, $self: expr) => {{\n-        if mem::size_of::<$T>() == 0 {\n-            ($self.end as usize).wrapping_sub($self.ptr as usize)\n+    ($self: ident) => {{\n+        let start = $self.ptr;\n+        if size_from_ptr(start) == 0 {\n+            ($self.end as usize).wrapping_sub(start as usize)\n         } else {\n-            $self.end.offset_from($self.ptr) as usize\n+            $self.end.offset_from(start) as usize\n         }\n     }}\n }\n@@ -2360,7 +2367,7 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, len!(T, self)) }\n+                unsafe { from_raw_parts(self.ptr, len!(self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -2398,7 +2405,7 @@ macro_rules! iterator {\n         impl<'a, T> ExactSizeIterator for $name<'a, T> {\n             #[inline(always)]\n             fn len(&self) -> usize {\n-                unsafe { len!(T, self) }\n+                unsafe { len!(self) }\n             }\n \n             #[inline(always)]\n@@ -2429,7 +2436,7 @@ macro_rules! iterator {\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let exact = unsafe { len!(T, self) };\n+                let exact = unsafe { len!(self) };\n                 (exact, Some(exact))\n             }\n \n@@ -2440,7 +2447,7 @@ macro_rules! iterator {\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                if n >= unsafe { len!(T, self) } {\n+                if n >= unsafe { len!(self) } {\n                     // This iterator is now empty.\n                     if mem::size_of::<T>() == 0 {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n@@ -2471,7 +2478,7 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while len!(T, self) >= 4 {\n+                    while len!(self) >= 4 {\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n@@ -2562,7 +2569,7 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while len!(T, self) >= 4 {\n+                    while len!(self) >= 4 {\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n@@ -2769,7 +2776,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, len!(T, self)) }\n+        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n     }\n }\n "}]}