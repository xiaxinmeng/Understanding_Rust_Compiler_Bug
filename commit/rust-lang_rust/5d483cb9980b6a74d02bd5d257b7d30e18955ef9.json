{"sha": "5d483cb9980b6a74d02bd5d257b7d30e18955ef9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNDgzY2I5OTgwYjZhNzRkMDJiZDVkMjU3YjdkMzBlMTg5NTVlZjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T16:40:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T16:40:41Z"}, "message": "doctrings", "tree": {"sha": "9578c27f5dc4c6c8c47c6d5a984627164c84cdf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9578c27f5dc4c6c8c47c6d5a984627164c84cdf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d483cb9980b6a74d02bd5d257b7d30e18955ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d483cb9980b6a74d02bd5d257b7d30e18955ef9", "html_url": "https://github.com/rust-lang/rust/commit/5d483cb9980b6a74d02bd5d257b7d30e18955ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d483cb9980b6a74d02bd5d257b7d30e18955ef9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08d1537468933910f22aa1cd517cae6b9f97d3ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d1537468933910f22aa1cd517cae6b9f97d3ff", "html_url": "https://github.com/rust-lang/rust/commit/08d1537468933910f22aa1cd517cae6b9f97d3ff"}], "stats": {"total": 90, "additions": 62, "deletions": 28}, "files": [{"sha": "b4669dfff58f029c67e08238da8eca7920fdd1c5", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5d483cb9980b6a74d02bd5d257b7d30e18955ef9/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d483cb9980b6a74d02bd5d257b7d30e18955ef9/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=5d483cb9980b6a74d02bd5d257b7d30e18955ef9", "patch": "@@ -148,27 +148,6 @@ impl AnalysisChange {\n     }\n }\n \n-/// `AnalysisHost` stores the current state of the world.\n-#[derive(Debug, Default)]\n-pub struct AnalysisHost {\n-    db: db::RootDatabase,\n-}\n-\n-impl AnalysisHost {\n-    /// Returns a snapshot of the current state, which you can query for\n-    /// semantic information.\n-    pub fn analysis(&self) -> Analysis {\n-        Analysis {\n-            db: self.db.snapshot(),\n-        }\n-    }\n-    /// Applies changes to the current state of the world. If there are\n-    /// outstanding snapshots, they will be canceled.\n-    pub fn apply_change(&mut self, change: AnalysisChange) {\n-        self.db.apply_change(change)\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n@@ -285,6 +264,27 @@ impl ReferenceResolution {\n     }\n }\n \n+/// `AnalysisHost` stores the current state of the world.\n+#[derive(Debug, Default)]\n+pub struct AnalysisHost {\n+    db: db::RootDatabase,\n+}\n+\n+impl AnalysisHost {\n+    /// Returns a snapshot of the current state, which you can query for\n+    /// semantic information.\n+    pub fn analysis(&self) -> Analysis {\n+        Analysis {\n+            db: self.db.snapshot(),\n+        }\n+    }\n+    /// Applies changes to the current state of the world. If there are\n+    /// outstanding snapshots, they will be canceled.\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        self.db.apply_change(change)\n+    }\n+}\n+\n /// Analysis is a snapshot of a world state at a moment in time. It is the main\n /// entry point for asking semantic information about the world. When the world\n /// state is advanced using `AnalysisHost::apply_change` method, all existing\n@@ -295,107 +295,141 @@ pub struct Analysis {\n }\n \n impl Analysis {\n+    /// Gets the text of the source file.\n     pub fn file_text(&self, file_id: FileId) -> Arc<String> {\n         self.db.file_text(file_id)\n     }\n+    /// Gets the syntax tree of the file.\n     pub fn file_syntax(&self, file_id: FileId) -> SourceFileNode {\n         self.db.source_file(file_id).clone()\n     }\n+    /// Gets the file's `LineIndex`: data structure to convert between absolute\n+    /// offsets and line/column representation.\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.db.file_lines(file_id)\n     }\n+    /// Selects the next syntactic nodes encopasing the range.\n     pub fn extend_selection(&self, frange: FileRange) -> TextRange {\n         extend_selection::extend_selection(&self.db, frange)\n     }\n+    /// Returns position of the mathcing brace (all types of braces are\n+    /// supported).\n     pub fn matching_brace(&self, file: &SourceFileNode, offset: TextUnit) -> Option<TextUnit> {\n         ra_editor::matching_brace(file, offset)\n     }\n+    /// Returns a syntax tree represented as `String`, for debug purposes.\n+    // FIXME: use a better name here.\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n         let file = self.db.source_file(file_id);\n         ra_editor::syntax_tree(&file)\n     }\n+    /// Returns an edit to remove all newlines in the range, cleaning up minor\n+    /// stuff like trailing commas.\n     pub fn join_lines(&self, frange: FileRange) -> SourceChange {\n         let file = self.db.source_file(frange.file_id);\n         SourceChange::from_local_edit(frange.file_id, ra_editor::join_lines(&file, frange.range))\n     }\n+    /// Returns an edit which should be applied when opening a new line, fixing\n+    /// up minor stuff like continuing the comment.\n     pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n         let file = self.db.source_file(position.file_id);\n         let edit = ra_editor::on_enter(&file, position.offset)?;\n-        let res = SourceChange::from_local_edit(position.file_id, edit);\n-        Some(res)\n+        Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+    /// Returns an edit which should be applied after `=` was typed. Primaraly,\n+    /// this works when adding `let =`.\n+    // FIXME: use a snippet completion instead of this hack here.\n     pub fn on_eq_typed(&self, position: FilePosition) -> Option<SourceChange> {\n         let file = self.db.source_file(position.file_id);\n-        Some(SourceChange::from_local_edit(\n-            position.file_id,\n-            ra_editor::on_eq_typed(&file, position.offset)?,\n-        ))\n+        let edit = ra_editor::on_eq_typed(&file, position.offset)?;\n+        Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+    /// Returns a tree representation of symbols in the file. Useful to draw a\n+    /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.db.source_file(file_id);\n         ra_editor::file_structure(&file)\n     }\n+    /// Returns the set of folding ranges.\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n         let file = self.db.source_file(file_id);\n         ra_editor::folding_ranges(&file)\n     }\n+    /// Fuzzy searches for a symbol.\n     pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n-        let res = symbol_index::world_symbols(&*self.db, query)?\n+        let res = symbol_index::world_symbols(self.db, query)?\n             .into_iter()\n             .map(|(file_id, symbol)| NavigationTarget { file_id, symbol })\n             .collect();\n         Ok(res)\n     }\n+    /// Resolves reference to definition, but does not gurantee correctness.\n     pub fn approximately_resolve_symbol(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<ReferenceResolution>> {\n         self.db.approximately_resolve_symbol(position)\n     }\n+    /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         self.db.find_all_refs(position)\n     }\n+    /// Returns documentation string for a given target.\n     pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n         self.db.doc_text_for(nav)\n     }\n+    /// Returns a `mod name;` declaration whihc created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         self.db.parent_module(position)\n     }\n+    /// Returns `::` separated path to the current module from the crate root.\n     pub fn module_path(&self, position: FilePosition) -> Cancelable<Option<String>> {\n         self.db.module_path(position)\n     }\n+    /// Returns crates this file belongs too.\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         self.db.crate_for(file_id)\n     }\n+    /// Returns the root file of the given crate.\n     pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n         Ok(self.db.crate_root(crate_id))\n     }\n+    /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n         let file = self.db.source_file(file_id);\n         Ok(runnables::runnables(self, &file, file_id))\n     }\n+    /// Computes syntax highlighting for the given file.\n     pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n         syntax_highlighting::highlight(&*self.db, file_id)\n     }\n+    /// Computes completions at the given position.\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let completions = completion::completions(&self.db, position)?;\n         Ok(completions.map(|it| it.into()))\n     }\n+    /// Computes assists (aks code actons aka intentions) for the given\n+    /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<SourceChange>> {\n         Ok(self.db.assists(frange))\n     }\n+    /// Computes the set of diagnostics for the given file.\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         self.db.diagnostics(file_id)\n     }\n+    /// Computes parameter information for the given call expression.\n     pub fn resolve_callable(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n         self.db.resolve_callable(position)\n     }\n+    /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n         self.db.type_of(frange)\n     }\n+    /// Returns the edit required to rename reference at the position to the new\n+    /// name.\n     pub fn rename(\n         &self,\n         position: FilePosition,"}]}