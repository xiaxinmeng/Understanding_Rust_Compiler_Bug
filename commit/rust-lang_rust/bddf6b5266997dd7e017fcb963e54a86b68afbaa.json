{"sha": "bddf6b5266997dd7e017fcb963e54a86b68afbaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZGY2YjUyNjY5OTdkZDdlMDE3ZmNiOTYzZTU0YTg2YjY4YWZiYWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-11T11:58:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-11T11:58:55Z"}, "message": "Merge #3557\n\n3557: Continue multiline non-doc comment blocks r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e47b310e3abe307772be9a47ebb4801866ff94ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47b310e3abe307772be9a47ebb4801866ff94ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bddf6b5266997dd7e017fcb963e54a86b68afbaa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeaNJ/CRBK7hj4Ov3rIwAAdHIIAJ53nrQfyDGPLFq/Z7TUVnZU\n+nVtfcUJ7pDIMkTnanBJ1d+Uf0jvyXPfigGugpke2nno4Kc07Q3vX9UTFSd5CPpa\nJBYEWE7/O/8NQ2Mb2hwiItfiPAonu9JbA0ep4IYHjrzmxPQMkzsnbm7wyMqKYnwq\nHD824m0xg78EXiQoERpw0S5GALSN+kJJZ/pyQ9dWs0nS+2kDQu64lnJ44RjTvZzf\nq09PnBb0f3m736BTEmWfLbPcN83kLkuwnWcPpN+3Hr4peVHagRBfr/FCMrFlyxiV\nwVffdat4rimgx+V6kDPBaEMrnYJInALlnJBLg0BlKIfc7OnlFcLA08C26KYL5Y4=\n=9TZF\n-----END PGP SIGNATURE-----\n", "payload": "tree e47b310e3abe307772be9a47ebb4801866ff94ba\nparent c48dcf74118b6e0df747f036a9b66701037f3fc7\nparent 85c30b1915314487515f69f32dfe5e1a7301ab95\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583927935 +0000\ncommitter GitHub <noreply@github.com> 1583927935 +0000\n\nMerge #3557\n\n3557: Continue multiline non-doc comment blocks r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bddf6b5266997dd7e017fcb963e54a86b68afbaa", "html_url": "https://github.com/rust-lang/rust/commit/bddf6b5266997dd7e017fcb963e54a86b68afbaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bddf6b5266997dd7e017fcb963e54a86b68afbaa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48dcf74118b6e0df747f036a9b66701037f3fc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48dcf74118b6e0df747f036a9b66701037f3fc7", "html_url": "https://github.com/rust-lang/rust/commit/c48dcf74118b6e0df747f036a9b66701037f3fc7"}, {"sha": "85c30b1915314487515f69f32dfe5e1a7301ab95", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c30b1915314487515f69f32dfe5e1a7301ab95", "html_url": "https://github.com/rust-lang/rust/commit/85c30b1915314487515f69f32dfe5e1a7301ab95"}], "stats": {"total": 376, "additions": 222, "deletions": 154}, "files": [{"sha": "53c65f8bc3e8e928ee4b0a4760e220026477fd2c", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 6, "deletions": 154, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bddf6b5266997dd7e017fcb963e54a86b68afbaa/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddf6b5266997dd7e017fcb963e54a86b68afbaa/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=bddf6b5266997dd7e017fcb963e54a86b68afbaa", "patch": "@@ -13,77 +13,21 @@\n //! Language server executes such typing assists synchronously. That is, they\n //! block user's typing and should be pretty fast for this reason!\n \n+mod on_enter;\n+\n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstToken},\n-    AstNode, SmolStr, SourceFile,\n-    SyntaxKind::*,\n-    SyntaxToken, TextRange, TextUnit, TokenAtOffset,\n+    AstNode, SourceFile, TextRange, TextUnit,\n };\n use ra_text_edit::TextEdit;\n \n-use crate::{source_change::SingleFileChange, SourceChange, SourceFileEdit};\n-\n-pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n-    let parse = db.parse(position.file_id);\n-    let file = parse.tree();\n-    let comment = file\n-        .syntax()\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        .and_then(ast::Comment::cast)?;\n-\n-    if comment.kind().shape.is_block() {\n-        return None;\n-    }\n-\n-    let prefix = comment.prefix();\n-    let comment_range = comment.syntax().text_range();\n-    if position.offset < comment_range.start() + TextUnit::of_str(prefix) {\n-        return None;\n-    }\n-\n-    // Continuing non-doc line comments (like this one :) ) is annoying\n-    if prefix == \"//\" && comment_range.end() == position.offset {\n-        return None;\n-    }\n-\n-    let indent = node_indent(&file, comment.syntax())?;\n-    let inserted = format!(\"\\n{}{} \", indent, prefix);\n-    let cursor_position = position.offset + TextUnit::of_str(&inserted);\n-    let edit = TextEdit::insert(position.offset, inserted);\n+use crate::{source_change::SingleFileChange, SourceChange};\n \n-    Some(\n-        SourceChange::source_file_edit(\n-            \"on enter\",\n-            SourceFileEdit { edit, file_id: position.file_id },\n-        )\n-        .with_cursor(FilePosition { offset: cursor_position, file_id: position.file_id }),\n-    )\n-}\n-\n-fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n-    let ws = match file.syntax().token_at_offset(token.text_range().start()) {\n-        TokenAtOffset::Between(l, r) => {\n-            assert!(r == *token);\n-            l\n-        }\n-        TokenAtOffset::Single(n) => {\n-            assert!(n == *token);\n-            return Some(\"\".into());\n-        }\n-        TokenAtOffset::None => unreachable!(),\n-    };\n-    if ws.kind() != WHITESPACE {\n-        return None;\n-    }\n-    let text = ws.text();\n-    let pos = text.rfind('\\n').map(|it| it + 1).unwrap_or(0);\n-    Some(text[pos..].into())\n-}\n+pub(crate) use on_enter::on_enter;\n \n pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n \n@@ -196,102 +140,10 @@ fn on_arrow_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChang\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::{add_cursor, assert_eq_text, extract_offset};\n-\n-    use crate::mock_analysis::single_file;\n+    use test_utils::{assert_eq_text, extract_offset};\n \n     use super::*;\n \n-    #[test]\n-    fn test_on_enter() {\n-        fn apply_on_enter(before: &str) -> Option<String> {\n-            let (offset, before) = extract_offset(before);\n-            let (analysis, file_id) = single_file(&before);\n-            let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n-\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n-            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n-            Some(actual)\n-        }\n-\n-        fn do_check(before: &str, after: &str) {\n-            let actual = apply_on_enter(before).unwrap();\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        fn do_check_noop(text: &str) {\n-            assert!(apply_on_enter(text).is_none())\n-        }\n-\n-        do_check(\n-            r\"\n-/// Some docs<|>\n-fn foo() {\n-}\n-\",\n-            r\"\n-/// Some docs\n-/// <|>\n-fn foo() {\n-}\n-\",\n-        );\n-        do_check(\n-            r\"\n-impl S {\n-    /// Some<|> docs.\n-    fn foo() {}\n-}\n-\",\n-            r\"\n-impl S {\n-    /// Some\n-    /// <|> docs.\n-    fn foo() {}\n-}\n-\",\n-        );\n-        do_check(\n-            r\"\n-fn main() {\n-    // Fix<|> me\n-    let x = 1 + 1;\n-}\n-\",\n-            r\"\n-fn main() {\n-    // Fix\n-    // <|> me\n-    let x = 1 + 1;\n-}\n-\",\n-        );\n-        do_check(\n-            r\"\n-///<|> Some docs\n-fn foo() {\n-}\n-\",\n-            r\"\n-///\n-/// <|> Some docs\n-fn foo() {\n-}\n-\",\n-        );\n-        do_check_noop(\n-            r\"\n-fn main() {\n-    // Fix me<|>\n-    let x = 1 + 1;\n-}\n-\",\n-        );\n-\n-        do_check_noop(r\"<|>//! docz\");\n-    }\n-\n     fn do_type_char(char_typed: char, before: &str) -> Option<(String, SingleFileChange)> {\n         let (offset, before) = extract_offset(before);\n         let edit = TextEdit::insert(offset, char_typed.to_string());"}, {"sha": "6bcf2d72b627fac0a1f0f9bca6e1a787c454ee94", "filename": "crates/ra_ide/src/typing/on_enter.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/bddf6b5266997dd7e017fcb963e54a86b68afbaa/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddf6b5266997dd7e017fcb963e54a86b68afbaa/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=bddf6b5266997dd7e017fcb963e54a86b68afbaa", "patch": "@@ -0,0 +1,216 @@\n+//! Handles the `Enter` key press. At the momently, this only continues\n+//! comments, but should handle indent some time in the future as well.\n+\n+use ra_db::{FilePosition, SourceDatabase};\n+use ra_ide_db::RootDatabase;\n+use ra_syntax::{\n+    ast::{self, AstToken},\n+    AstNode, SmolStr, SourceFile,\n+    SyntaxKind::*,\n+    SyntaxToken, TextUnit, TokenAtOffset,\n+};\n+use ra_text_edit::TextEdit;\n+\n+use crate::{SourceChange, SourceFileEdit};\n+\n+pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n+    let parse = db.parse(position.file_id);\n+    let file = parse.tree();\n+    let comment = file\n+        .syntax()\n+        .token_at_offset(position.offset)\n+        .left_biased()\n+        .and_then(ast::Comment::cast)?;\n+\n+    if comment.kind().shape.is_block() {\n+        return None;\n+    }\n+\n+    let prefix = comment.prefix();\n+    let comment_range = comment.syntax().text_range();\n+    if position.offset < comment_range.start() + TextUnit::of_str(prefix) {\n+        return None;\n+    }\n+\n+    // Continuing single-line non-doc comments (like this one :) ) is annoying\n+    if prefix == \"//\" && comment_range.end() == position.offset && !followed_by_comment(&comment) {\n+        return None;\n+    }\n+\n+    let indent = node_indent(&file, comment.syntax())?;\n+    let inserted = format!(\"\\n{}{} \", indent, prefix);\n+    let cursor_position = position.offset + TextUnit::of_str(&inserted);\n+    let edit = TextEdit::insert(position.offset, inserted);\n+\n+    Some(\n+        SourceChange::source_file_edit(\n+            \"on enter\",\n+            SourceFileEdit { edit, file_id: position.file_id },\n+        )\n+        .with_cursor(FilePosition { offset: cursor_position, file_id: position.file_id }),\n+    )\n+}\n+\n+fn followed_by_comment(comment: &ast::Comment) -> bool {\n+    let ws = match comment.syntax().next_token().and_then(ast::Whitespace::cast) {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+    if ws.spans_multiple_lines() {\n+        return false;\n+    }\n+    ws.syntax().next_token().and_then(ast::Comment::cast).is_some()\n+}\n+\n+fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n+    let ws = match file.syntax().token_at_offset(token.text_range().start()) {\n+        TokenAtOffset::Between(l, r) => {\n+            assert!(r == *token);\n+            l\n+        }\n+        TokenAtOffset::Single(n) => {\n+            assert!(n == *token);\n+            return Some(\"\".into());\n+        }\n+        TokenAtOffset::None => unreachable!(),\n+    };\n+    if ws.kind() != WHITESPACE {\n+        return None;\n+    }\n+    let text = ws.text();\n+    let pos = text.rfind('\\n').map(|it| it + 1).unwrap_or(0);\n+    Some(text[pos..].into())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::{add_cursor, assert_eq_text, extract_offset};\n+\n+    use crate::mock_analysis::single_file;\n+\n+    use super::*;\n+\n+    fn apply_on_enter(before: &str) -> Option<String> {\n+        let (offset, before) = extract_offset(before);\n+        let (analysis, file_id) = single_file(&before);\n+        let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n+\n+        assert_eq!(result.source_file_edits.len(), 1);\n+        let actual = result.source_file_edits[0].edit.apply(&before);\n+        let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n+        Some(actual)\n+    }\n+\n+    fn do_check(ra_fixture_before: &str, ra_fixture_after: &str) {\n+        let actual = apply_on_enter(ra_fixture_before).unwrap();\n+        assert_eq_text!(ra_fixture_after, &actual);\n+    }\n+\n+    fn do_check_noop(ra_fixture_text: &str) {\n+        assert!(apply_on_enter(ra_fixture_text).is_none())\n+    }\n+\n+    #[test]\n+    fn continues_doc_comment() {\n+        do_check(\n+            r\"\n+/// Some docs<|>\n+fn foo() {\n+}\n+\",\n+            r\"\n+/// Some docs\n+/// <|>\n+fn foo() {\n+}\n+\",\n+        );\n+\n+        do_check(\n+            r\"\n+impl S {\n+    /// Some<|> docs.\n+    fn foo() {}\n+}\n+\",\n+            r\"\n+impl S {\n+    /// Some\n+    /// <|> docs.\n+    fn foo() {}\n+}\n+\",\n+        );\n+\n+        do_check(\n+            r\"\n+///<|> Some docs\n+fn foo() {\n+}\n+\",\n+            r\"\n+///\n+/// <|> Some docs\n+fn foo() {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_continue_before_doc_comment() {\n+        do_check_noop(r\"<|>//! docz\");\n+    }\n+\n+    #[test]\n+    fn continues_code_comment_in_the_middle_of_line() {\n+        do_check(\n+            r\"\n+fn main() {\n+    // Fix<|> me\n+    let x = 1 + 1;\n+}\n+\",\n+            r\"\n+fn main() {\n+    // Fix\n+    // <|> me\n+    let x = 1 + 1;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn continues_code_comment_in_the_middle_several_lines() {\n+        do_check(\n+            r\"\n+fn main() {\n+    // Fix<|>\n+    // me\n+    let x = 1 + 1;\n+}\n+\",\n+            r\"\n+fn main() {\n+    // Fix\n+    // <|>\n+    // me\n+    let x = 1 + 1;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_continue_end_of_code_comment() {\n+        do_check_noop(\n+            r\"\n+fn main() {\n+    // Fix me<|>\n+    let x = 1 + 1;\n+}\n+\",\n+        );\n+    }\n+}"}]}