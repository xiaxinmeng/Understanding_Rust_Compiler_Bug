{"sha": "32b50e280faf56f21cbd82d1cf82cb4795535143", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYjUwZTI4MGZhZjU2ZjIxY2JkODJkMWNmODJjYjQ3OTU1MzUxNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T06:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T06:40:10Z"}, "message": "Auto merge of #44012 - michaelwoerister:cache-hir-dep-node-index, r=nikomatsakis\n\nincr.comp.: Cache Hir-DepNodeIndices in the HIR map.\n\nIn preparation for red/green. This should also be faster than before without any additional memory cost.\n\nr? @nikomatsakis", "tree": {"sha": "ebdaabb21c79c92419da316f2471fe1a32dd5dfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebdaabb21c79c92419da316f2471fe1a32dd5dfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32b50e280faf56f21cbd82d1cf82cb4795535143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32b50e280faf56f21cbd82d1cf82cb4795535143", "html_url": "https://github.com/rust-lang/rust/commit/32b50e280faf56f21cbd82d1cf82cb4795535143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32b50e280faf56f21cbd82d1cf82cb4795535143/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "426711d11c6315a0bd5eed01327de824d807b65c", "url": "https://api.github.com/repos/rust-lang/rust/commits/426711d11c6315a0bd5eed01327de824d807b65c", "html_url": "https://github.com/rust-lang/rust/commit/426711d11c6315a0bd5eed01327de824d807b65c"}, {"sha": "8d7c59b1fab8f45d6a4cc7271aae55fad31b2a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7c59b1fab8f45d6a4cc7271aae55fad31b2a9c", "html_url": "https://github.com/rust-lang/rust/commit/8d7c59b1fab8f45d6a4cc7271aae55fad31b2a9c"}], "stats": {"total": 577, "additions": 345, "deletions": 232}, "files": [{"sha": "809d1dfcf60a2ff479798bc722197e958a312b99", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -244,8 +244,8 @@ impl DepGraphEdges {\n         self.edges.insert((source, target));\n     }\n \n-    pub fn add_node(&mut self, node: DepNode) {\n-        self.get_or_create_node(node);\n+    pub fn add_node(&mut self, node: DepNode) -> DepNodeIndex {\n+        self.get_or_create_node(node)\n     }\n \n     #[inline]"}, {"sha": "c487fc963ca14a46ae9f0b01eb8e2ded237247b2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -173,6 +173,14 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n+    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().add_node(node)\n+        } else {\n+            DepNodeIndex::INVALID\n+        }\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "d52cc26eaebc666afcc248d19048cde449e5cd40", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -827,7 +827,16 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n+    let ImplItem {\n+        id: _,\n+        hir_id: _,\n+        name,\n+        ref vis,\n+        ref defaultness,\n+        ref attrs,\n+        ref node,\n+        span\n+    } = *impl_item;\n \n     visitor.visit_name(span, name);\n     visitor.visit_vis(vis);"}, {"sha": "ac26cbc833dea0b073028f493dec2fea43cc8195", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -1315,7 +1315,12 @@ impl<'a> LoweringContext<'a> {\n                             path.span = span;\n \n                             self.allocate_hir_id_counter(import.id, import);\n-                            self.with_hir_id_owner(import.id, |this| {\n+                            let LoweredNodeId {\n+                                node_id: import_node_id,\n+                                hir_id: import_hir_id,\n+                            } = self.lower_node_id(import.id);\n+\n+                            self.with_hir_id_owner(import_node_id, |this| {\n                                 let vis = match *vis {\n                                     hir::Visibility::Public => hir::Visibility::Public,\n                                     hir::Visibility::Crate => hir::Visibility::Crate,\n@@ -1329,8 +1334,9 @@ impl<'a> LoweringContext<'a> {\n                                     }\n                                 };\n \n-                                this.items.insert(import.id, hir::Item {\n-                                    id: import.id,\n+                                this.items.insert(import_node_id, hir::Item {\n+                                    id: import_node_id,\n+                                    hir_id: import_hir_id,\n                                     name: import.rename.unwrap_or(ident).name,\n                                     attrs: attrs.clone(),\n                                     node: hir::ItemUse(P(path), hir::UseKind::Single),\n@@ -1461,8 +1467,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1522,8 +1531,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1614,8 +1626,11 @@ impl<'a> LoweringContext<'a> {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+\n         Some(hir::Item {\n-            id: self.lower_node_id(i.id).node_id,\n+            id: node_id,\n+            hir_id,\n             name,\n             attrs,\n             node,"}, {"sha": "a54068c648310ffbda503d9ba5f8c1925a0e6a7c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 165, "deletions": 29, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -10,33 +10,55 @@\n \n use super::*;\n \n+use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n-pub struct NodeCollector<'hir> {\n+pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n-    pub krate: &'hir Crate,\n+    krate: &'hir Crate,\n     /// The node map\n-    pub(super) map: Vec<MapEntry<'hir>>,\n+    map: Vec<MapEntry<'hir>>,\n     /// The parent of this node\n-    pub parent_node: NodeId,\n+    parent_node: NodeId,\n+\n+    current_dep_node_owner: DefIndex,\n+    current_dep_node_index: DepNodeIndex,\n+\n+    dep_graph: &'a DepGraph,\n+    definitions: &'a definitions::Definitions,\n }\n \n-impl<'hir> NodeCollector<'hir> {\n-    pub fn root(krate: &'hir Crate) -> NodeCollector<'hir> {\n+impl<'a, 'hir> NodeCollector<'a, 'hir> {\n+    pub(super) fn root(krate: &'hir Crate,\n+                dep_graph: &'a DepGraph,\n+                definitions: &'a definitions::Definitions)\n+                -> NodeCollector<'a, 'hir> {\n+        let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n+        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n+        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            current_dep_node_index: root_mod_dep_node_index,\n+            current_dep_node_owner: CRATE_DEF_INDEX,\n+            dep_graph,\n+            definitions,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n \n         collector\n     }\n \n+    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+        self.map\n+    }\n+\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -47,8 +69,55 @@ impl<'hir> NodeCollector<'hir> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n+        let parent = self.parent_node;\n+        let dep_node_index = self.current_dep_node_index;\n+\n+        let entry = match node {\n+            NodeItem(n) => EntryItem(parent, dep_node_index, n),\n+            NodeForeignItem(n) => EntryForeignItem(parent, dep_node_index, n),\n+            NodeTraitItem(n) => EntryTraitItem(parent, dep_node_index, n),\n+            NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n+            NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n+            NodeField(n) => EntryField(parent, dep_node_index, n),\n+            NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n+            NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n+            NodeTy(n) => EntryTy(parent, dep_node_index, n),\n+            NodeTraitRef(n) => EntryTraitRef(parent, dep_node_index, n),\n+            NodeBinding(n) => EntryBinding(parent, dep_node_index, n),\n+            NodePat(n) => EntryPat(parent, dep_node_index, n),\n+            NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n+            NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n+            NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n+            NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n+            NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n+            NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+        };\n+\n+        // Make sure that the DepNode of some node coincides with the HirId\n+        // owner of that node.\n+        if cfg!(debug_assertions) {\n+            let hir_id_owner = self.definitions.node_to_hir_id(id).owner;\n+\n+            if hir_id_owner != self.current_dep_node_owner {\n+                let node_str = match self.definitions.opt_def_index(id) {\n+                    Some(def_index) => {\n+                        self.definitions.def_path(def_index).to_string_no_crate()\n+                    }\n+                    None => format!(\"{:?}\", node)\n+                };\n+\n+                bug!(\"inconsistent DepNode for `{}`: \\\n+                      current_dep_node_owner={}, hir_id.owner={}\",\n+                    node_str,\n+                    self.definitions\n+                        .def_path(self.current_dep_node_owner)\n+                        .to_string_no_crate(),\n+                    self.definitions.def_path(hir_id_owner).to_string_no_crate())\n+            }\n+        }\n+\n         self.insert_entry(id, entry);\n+\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n@@ -57,9 +126,27 @@ impl<'hir> NodeCollector<'hir> {\n         f(self);\n         self.parent_node = parent_node;\n     }\n+\n+    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+                                                 dep_node_owner: DefIndex,\n+                                                 f: F) {\n+        let prev_owner = self.current_dep_node_owner;\n+        let prev_index = self.current_dep_node_index;\n+\n+        // When we enter a new owner (item, impl item, or trait item), we always\n+        // start out again with DepKind::Hir.\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(dep_node_owner)\n+                               .to_dep_node(DepKind::Hir);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        self.current_dep_node_owner = dep_node_owner;\n+        f(self);\n+        self.current_dep_node_index = prev_index;\n+        self.current_dep_node_owner = prev_owner;\n+    }\n }\n \n-impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n+impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n@@ -82,25 +169,37 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n+        // When we enter a body, we switch to DepKind::HirBody.\n+        // Note that current_dep_node_index might already be DepKind::HirBody,\n+        // e.g. when entering the body of a closure that is already part of a\n+        // surrounding body. That's expected and not a problem.\n+        let prev_index = self.current_dep_node_index;\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(self.current_dep_node_owner)\n+                               .to_dep_node(DepKind::HirBody);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n         self.visit_body(self.krate.body(id));\n+        self.current_dep_node_index = prev_index;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n-\n-        self.insert(i.id, NodeItem(i));\n-\n-        self.with_parent(i.id, |this| {\n-            match i.node {\n-                ItemStruct(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+        debug_assert_eq!(i.hir_id.owner,\n+                         self.definitions.opt_def_index(i.id).unwrap());\n+        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+            this.insert(i.id, NodeItem(i));\n+            this.with_parent(i.id, |this| {\n+                match i.node {\n+                    ItemStruct(ref struct_def, _) => {\n+                        // If this is a tuple-like struct, register the constructor.\n+                        if !struct_def.is_struct() {\n+                            this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n+                intravisit::walk_item(this, i);\n+            });\n         });\n     }\n \n@@ -121,18 +220,26 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n-        self.insert(ti.id, NodeTraitItem(ti));\n-\n-        self.with_parent(ti.id, |this| {\n-            intravisit::walk_trait_item(this, ti);\n+        debug_assert_eq!(ti.hir_id.owner,\n+                         self.definitions.opt_def_index(ti.id).unwrap());\n+        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+            this.insert(ti.id, NodeTraitItem(ti));\n+\n+            this.with_parent(ti.id, |this| {\n+                intravisit::walk_trait_item(this, ti);\n+            });\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n-        self.insert(ii.id, NodeImplItem(ii));\n-\n-        self.with_parent(ii.id, |this| {\n-            intravisit::walk_impl_item(this, ii);\n+        debug_assert_eq!(ii.hir_id.owner,\n+                         self.definitions.opt_def_index(ii.id).unwrap());\n+        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+            this.insert(ii.id, NodeImplItem(ii));\n+\n+            this.with_parent(ii.id, |this| {\n+                intravisit::walk_impl_item(this, ii);\n+            });\n         });\n     }\n \n@@ -238,4 +345,33 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n             intravisit::walk_struct_field(this, field);\n         });\n     }\n+\n+    fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n+        // Do not visit the duplicate information in TraitItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let TraitItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_trait_item(id);\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n+        // Do not visit the duplicate information in ImplItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let ImplItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            vis: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_impl_item(id);\n+    }\n }"}, {"sha": "63a5b70cb81a9f2ba60ad756d7987f00df16717d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 132, "deletions": 193, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -15,7 +15,7 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode, DepKind};\n+use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndexAddressSpace};\n \n@@ -74,27 +74,28 @@ enum MapEntry<'hir> {\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, &'hir Item),\n-    EntryForeignItem(NodeId, &'hir ForeignItem),\n-    EntryTraitItem(NodeId, &'hir TraitItem),\n-    EntryImplItem(NodeId, &'hir ImplItem),\n-    EntryVariant(NodeId, &'hir Variant),\n-    EntryField(NodeId, &'hir StructField),\n-    EntryExpr(NodeId, &'hir Expr),\n-    EntryStmt(NodeId, &'hir Stmt),\n-    EntryTy(NodeId, &'hir Ty),\n-    EntryTraitRef(NodeId, &'hir TraitRef),\n-    EntryBinding(NodeId, &'hir Pat),\n-    EntryPat(NodeId, &'hir Pat),\n-    EntryBlock(NodeId, &'hir Block),\n-    EntryStructCtor(NodeId, &'hir VariantData),\n-    EntryLifetime(NodeId, &'hir Lifetime),\n-    EntryTyParam(NodeId, &'hir TyParam),\n-    EntryVisibility(NodeId, &'hir Visibility),\n-    EntryLocal(NodeId, &'hir Local),\n-\n-    /// Roots for node trees.\n-    RootCrate,\n+    EntryItem(NodeId, DepNodeIndex, &'hir Item),\n+    EntryForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n+    EntryTraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n+    EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n+    EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n+    EntryField(NodeId, DepNodeIndex, &'hir StructField),\n+    EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n+    EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n+    EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n+    EntryTraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n+    EntryBinding(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryPat(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n+    EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n+    EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n+    EntryTyParam(NodeId, DepNodeIndex, &'hir TyParam),\n+    EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n+    EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n+\n+    /// Roots for node trees. The DepNodeIndex is the dependency node of the\n+    /// crate's root module.\n+    RootCrate(DepNodeIndex),\n }\n \n impl<'hir> Clone for MapEntry<'hir> {\n@@ -104,82 +105,59 @@ impl<'hir> Clone for MapEntry<'hir> {\n }\n \n impl<'hir> MapEntry<'hir> {\n-    fn from_node(p: NodeId, node: Node<'hir>) -> MapEntry<'hir> {\n-        match node {\n-            NodeItem(n) => EntryItem(p, n),\n-            NodeForeignItem(n) => EntryForeignItem(p, n),\n-            NodeTraitItem(n) => EntryTraitItem(p, n),\n-            NodeImplItem(n) => EntryImplItem(p, n),\n-            NodeVariant(n) => EntryVariant(p, n),\n-            NodeField(n) => EntryField(p, n),\n-            NodeExpr(n) => EntryExpr(p, n),\n-            NodeStmt(n) => EntryStmt(p, n),\n-            NodeTy(n) => EntryTy(p, n),\n-            NodeTraitRef(n) => EntryTraitRef(p, n),\n-            NodeBinding(n) => EntryBinding(p, n),\n-            NodePat(n) => EntryPat(p, n),\n-            NodeBlock(n) => EntryBlock(p, n),\n-            NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n),\n-            NodeTyParam(n) => EntryTyParam(p, n),\n-            NodeVisibility(n) => EntryVisibility(p, n),\n-            NodeLocal(n) => EntryLocal(p, n),\n-        }\n-    }\n-\n     fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n-            EntryItem(id, _) => id,\n-            EntryForeignItem(id, _) => id,\n-            EntryTraitItem(id, _) => id,\n-            EntryImplItem(id, _) => id,\n-            EntryVariant(id, _) => id,\n-            EntryField(id, _) => id,\n-            EntryExpr(id, _) => id,\n-            EntryStmt(id, _) => id,\n-            EntryTy(id, _) => id,\n-            EntryTraitRef(id, _) => id,\n-            EntryBinding(id, _) => id,\n-            EntryPat(id, _) => id,\n-            EntryBlock(id, _) => id,\n-            EntryStructCtor(id, _) => id,\n-            EntryLifetime(id, _) => id,\n-            EntryTyParam(id, _) => id,\n-            EntryVisibility(id, _) => id,\n-            EntryLocal(id, _) => id,\n+            EntryItem(id, _, _) => id,\n+            EntryForeignItem(id, _, _) => id,\n+            EntryTraitItem(id, _, _) => id,\n+            EntryImplItem(id, _, _) => id,\n+            EntryVariant(id, _, _) => id,\n+            EntryField(id, _, _) => id,\n+            EntryExpr(id, _, _) => id,\n+            EntryStmt(id, _, _) => id,\n+            EntryTy(id, _, _) => id,\n+            EntryTraitRef(id, _, _) => id,\n+            EntryBinding(id, _, _) => id,\n+            EntryPat(id, _, _) => id,\n+            EntryBlock(id, _, _) => id,\n+            EntryStructCtor(id, _, _) => id,\n+            EntryLifetime(id, _, _) => id,\n+            EntryTyParam(id, _, _) => id,\n+            EntryVisibility(id, _, _) => id,\n+            EntryLocal(id, _, _) => id,\n \n             NotPresent |\n-            RootCrate => return None,\n+            RootCrate(_) => return None,\n         })\n     }\n \n     fn to_node(self) -> Option<Node<'hir>> {\n         Some(match self {\n-            EntryItem(_, n) => NodeItem(n),\n-            EntryForeignItem(_, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, n) => NodeTraitItem(n),\n-            EntryImplItem(_, n) => NodeImplItem(n),\n-            EntryVariant(_, n) => NodeVariant(n),\n-            EntryField(_, n) => NodeField(n),\n-            EntryExpr(_, n) => NodeExpr(n),\n-            EntryStmt(_, n) => NodeStmt(n),\n-            EntryTy(_, n) => NodeTy(n),\n-            EntryTraitRef(_, n) => NodeTraitRef(n),\n-            EntryBinding(_, n) => NodeBinding(n),\n-            EntryPat(_, n) => NodePat(n),\n-            EntryBlock(_, n) => NodeBlock(n),\n-            EntryStructCtor(_, n) => NodeStructCtor(n),\n-            EntryLifetime(_, n) => NodeLifetime(n),\n-            EntryTyParam(_, n) => NodeTyParam(n),\n-            EntryVisibility(_, n) => NodeVisibility(n),\n-            EntryLocal(_, n) => NodeLocal(n),\n+            EntryItem(_, _, n) => NodeItem(n),\n+            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n+            EntryImplItem(_, _, n) => NodeImplItem(n),\n+            EntryVariant(_, _, n) => NodeVariant(n),\n+            EntryField(_, _, n) => NodeField(n),\n+            EntryExpr(_, _, n) => NodeExpr(n),\n+            EntryStmt(_, _, n) => NodeStmt(n),\n+            EntryTy(_, _, n) => NodeTy(n),\n+            EntryTraitRef(_, _, n) => NodeTraitRef(n),\n+            EntryBinding(_, _, n) => NodeBinding(n),\n+            EntryPat(_, _, n) => NodePat(n),\n+            EntryBlock(_, _, n) => NodeBlock(n),\n+            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n+            EntryLifetime(_, _, n) => NodeLifetime(n),\n+            EntryTyParam(_, _, n) => NodeTyParam(n),\n+            EntryVisibility(_, _, n) => NodeVisibility(n),\n+            EntryLocal(_, _, n) => NodeLocal(n),\n             _ => return None\n         })\n     }\n \n     fn associated_body(self) -> Option<BodyId> {\n         match self {\n-            EntryItem(_, item) => {\n+            EntryItem(_, _, item) => {\n                 match item.node {\n                     ItemConst(_, body) |\n                     ItemStatic(.., body) |\n@@ -188,23 +166,23 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n-            EntryTraitItem(_, item) => {\n+            EntryTraitItem(_, _, item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, item) => {\n+            EntryImplItem(_, _, item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryExpr(_, expr) => {\n+            EntryExpr(_, _, expr) => {\n                 match expr.node {\n                     ExprClosure(.., body, _) => Some(body),\n                     _ => None,\n@@ -282,83 +260,40 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        self.dep_graph.read(self.dep_node(id));\n-    }\n-\n-    fn dep_node(&self, id0: NodeId) -> DepNode {\n-        let mut id = id0;\n-        let mut last_expr = None;\n-        loop {\n-            let entry = self.map[id.as_usize()];\n-            match entry {\n-                EntryItem(..) |\n-                EntryTraitItem(..) |\n-                EntryImplItem(..) => {\n-                    let def_index = self.definitions.opt_def_index(id).unwrap();\n+        let entry = self.map[id.as_usize()];\n+        match entry {\n+            EntryItem(_, dep_node_index, _) |\n+            EntryTraitItem(_, dep_node_index, _) |\n+            EntryImplItem(_, dep_node_index, _) |\n+            EntryVariant(_, dep_node_index, _) |\n+            EntryForeignItem(_, dep_node_index, _) |\n+            EntryField(_, dep_node_index, _) |\n+            EntryStmt(_, dep_node_index, _) |\n+            EntryTy(_, dep_node_index, _) |\n+            EntryTraitRef(_, dep_node_index, _) |\n+            EntryBinding(_, dep_node_index, _) |\n+            EntryPat(_, dep_node_index, _) |\n+            EntryBlock(_, dep_node_index, _) |\n+            EntryStructCtor(_, dep_node_index, _) |\n+            EntryLifetime(_, dep_node_index, _) |\n+            EntryTyParam(_, dep_node_index, _) |\n+            EntryVisibility(_, dep_node_index, _) |\n+            EntryExpr(_, dep_node_index, _) |\n+            EntryLocal(_, dep_node_index, _) |\n+            RootCrate(dep_node_index) => {\n+                self.dep_graph.read_index(dep_node_index);\n+            }\n+            NotPresent => {\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n                     let def_path_hash = self.definitions.def_path_hash(def_index);\n-\n-                    if let Some(last_id) = last_expr {\n-                        // The body may have a separate dep node\n-                        if entry.is_body_owner(last_id) {\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n-                }\n-\n-                EntryVariant(p, v) => {\n-                    id = p;\n-\n-                    if last_expr.is_some() {\n-                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                            // The enum parent holds both Hir and HirBody nodes.\n-                            let def_index = self.definitions.opt_def_index(id).unwrap();\n-                            let def_path_hash = self.definitions.def_path_hash(def_index);\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                }\n-\n-                EntryForeignItem(p, _) |\n-                EntryField(p, _) |\n-                EntryStmt(p, _) |\n-                EntryTy(p, _) |\n-                EntryTraitRef(p, _) |\n-                EntryBinding(p, _) |\n-                EntryPat(p, _) |\n-                EntryBlock(p, _) |\n-                EntryStructCtor(p, _) |\n-                EntryLifetime(p, _) |\n-                EntryTyParam(p, _) |\n-                EntryVisibility(p, _) |\n-                EntryLocal(p, _) =>\n-                    id = p,\n-\n-                EntryExpr(p, _) => {\n-                    last_expr = Some(id);\n-                    id = p;\n-                }\n-\n-                RootCrate => {\n-                    let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                } else {\n+                    bug!(\"called HirMap::read() with invalid NodeId\")\n                 }\n-\n-                NotPresent =>\n-                    // Some nodes, notably macro definitions, are not\n-                    // present in the map for whatever reason, but\n-                    // they *do* have def-ids. So if we encounter an\n-                    // empty hole, check for that case.\n-                    return self.definitions.opt_def_index(id)\n-                               .map(|def_index| {\n-                                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                                    def_path_hash.to_dep_node(DepKind::Hir)\n-                                })\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"Walking parents from `{}` \\\n-                                         led to `NotPresent` at `{}`\",\n-                                        id0, id)\n-                               }),\n             }\n         }\n     }\n@@ -481,7 +416,7 @@ impl<'hir> Map<'hir> {\n                 Some(body_id)\n             } else {\n                 // For some expressions, the expression is its own body.\n-                if let EntryExpr(_, expr) = entry {\n+                if let EntryExpr(_, _, expr) = entry {\n                     Some(BodyId { node_id: expr.id })\n                 } else {\n                     None\n@@ -760,7 +695,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => {\n+            Some(EntryItem(_, _, i)) => {\n                 match i.node {\n                     ItemForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n@@ -911,27 +846,27 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         match self.find_entry(id) {\n-            Some(EntryItem(_, item)) => item.span,\n-            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n-            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n-            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n-            Some(EntryVariant(_, variant)) => variant.span,\n-            Some(EntryField(_, field)) => field.span,\n-            Some(EntryExpr(_, expr)) => expr.span,\n-            Some(EntryStmt(_, stmt)) => stmt.span,\n-            Some(EntryTy(_, ty)) => ty.span,\n-            Some(EntryTraitRef(_, tr)) => tr.path.span,\n-            Some(EntryBinding(_, pat)) => pat.span,\n-            Some(EntryPat(_, pat)) => pat.span,\n-            Some(EntryBlock(_, block)) => block.span,\n-            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n-            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n-            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n-            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(EntryLocal(_, local)) => local.span,\n-\n-            Some(RootCrate) => self.forest.krate.span,\n+            Some(EntryItem(_, _, item)) => item.span,\n+            Some(EntryForeignItem(_, _, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, _, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, _, variant)) => variant.span,\n+            Some(EntryField(_, _, field)) => field.span,\n+            Some(EntryExpr(_, _, expr)) => expr.span,\n+            Some(EntryStmt(_, _, stmt)) => stmt.span,\n+            Some(EntryTy(_, _, ty)) => ty.span,\n+            Some(EntryTraitRef(_, _, tr)) => tr.path.span,\n+            Some(EntryBinding(_, _, pat)) => pat.span,\n+            Some(EntryPat(_, _, pat)) => pat.span,\n+            Some(EntryBlock(_, _, block)) => block.span,\n+            Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, _, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(EntryLocal(_, _, local)) => local.span,\n+\n+            Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -1029,12 +964,12 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n-                Some(EntryItem(_, n))       => n.name(),\n-                Some(EntryForeignItem(_, n))=> n.name(),\n-                Some(EntryTraitItem(_, n))  => n.name(),\n-                Some(EntryImplItem(_, n))   => n.name(),\n-                Some(EntryVariant(_, n))    => n.name(),\n-                Some(EntryField(_, n))      => n.name(),\n+                Some(EntryItem(_, _, n))       => n.name(),\n+                Some(EntryForeignItem(_, _, n))=> n.name(),\n+                Some(EntryTraitItem(_, _, n))  => n.name(),\n+                Some(EntryImplItem(_, _, n))   => n.name(),\n+                Some(EntryVariant(_, _, n))    => n.name(),\n+                Some(EntryField(_, _, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1060,9 +995,13 @@ impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n pub fn map_crate<'hir>(forest: &'hir mut Forest,\n                        definitions: Definitions)\n                        -> Map<'hir> {\n-    let mut collector = NodeCollector::root(&forest.krate);\n-    intravisit::walk_crate(&mut collector, &forest.krate);\n-    let map = collector.map;\n+    let map = {\n+        let mut collector = NodeCollector::root(&forest.krate,\n+                                                &forest.dep_graph,\n+                                                &definitions);\n+        intravisit::walk_crate(&mut collector, &forest.krate);\n+        collector.into_map()\n+    };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n         // This only makes sense for ordered stores; note the"}, {"sha": "df67f8416212c413deb77a94c14d7a25805cb6e9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -1220,6 +1220,7 @@ pub struct TraitItemId {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n@@ -1261,6 +1262,7 @@ pub struct ImplItemId {\n pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n@@ -1667,8 +1669,9 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n+    pub attrs: HirVec<Attribute>,\n     pub node: Item_,\n     pub vis: Visibility,\n     pub span: Span,"}, {"sha": "a79133187895a861736d587050b91b86071302f6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b50e280faf56f21cbd82d1cf82cb4795535143/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=32b50e280faf56f21cbd82d1cf82cb4795535143", "patch": "@@ -731,6 +731,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n+            hir_id: _,\n             name,\n             ref attrs,\n             ref node,\n@@ -764,6 +765,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n+            hir_id: _,\n             name,\n             ref vis,\n             defaultness,\n@@ -920,6 +922,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             name,\n             ref attrs,\n             id,\n+            hir_id: _,\n             ref node,\n             ref vis,\n             span"}]}