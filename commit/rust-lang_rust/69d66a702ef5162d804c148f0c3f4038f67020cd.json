{"sha": "69d66a702ef5162d804c148f0c3f4038f67020cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZDY2YTcwMmVmNTE2MmQ4MDRjMTQ4ZjBjM2Y0MDM4ZjY3MDIwY2Q=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-08-21T18:42:16Z"}, "committer": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-08-21T18:42:16Z"}, "message": "fix a bug in bitv where the undefined bits in small/big bitv values could cause operations to return incorrect results.", "tree": {"sha": "4545b5660c94a53cc4163ac49c66c90199fbc093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4545b5660c94a53cc4163ac49c66c90199fbc093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69d66a702ef5162d804c148f0c3f4038f67020cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69d66a702ef5162d804c148f0c3f4038f67020cd", "html_url": "https://github.com/rust-lang/rust/commit/69d66a702ef5162d804c148f0c3f4038f67020cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69d66a702ef5162d804c148f0c3f4038f67020cd/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ccd299b15e2ff5d351e0329df6e75dec2eb1b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ccd299b15e2ff5d351e0329df6e75dec2eb1b6b", "html_url": "https://github.com/rust-lang/rust/commit/5ccd299b15e2ff5d351e0329df6e75dec2eb1b6b"}], "stats": {"total": 161, "additions": 116, "deletions": 45}, "files": [{"sha": "901430a279b4fa266fb7284ce52b69ef915bc922", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 116, "deletions": 45, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/69d66a702ef5162d804c148f0c3f4038f67020cd/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69d66a702ef5162d804c148f0c3f4038f67020cd/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=69d66a702ef5162d804c148f0c3f4038f67020cd", "patch": "@@ -19,37 +19,42 @@ export to_str;\n export eq_vec;\n export methods;\n \n+/// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n+#[inline(always)]\n+fn small_mask(nbits: uint) -> u32 {\n+    (1 << nbits) - 1\n+}\n+\n struct small_bitv {\n+    /// only the lowest nbits of this value are used. the rest is undefined.\n     let mut bits: u32;\n     new(bits: u32) { self.bits = bits; }\n     priv {\n         #[inline(always)]\n-        fn bits_op(right_bits: u32, f: fn(u32, u32) -> u32) -> bool {\n+        fn bits_op(right_bits: u32, nbits: uint, f: fn(u32, u32) -> u32)\n+                                                                     -> bool {\n+            let mask = small_mask(nbits);\n             let old_b: u32 = self.bits;\n             let new_b = f(old_b, right_bits);\n             self.bits = new_b;\n-            old_b != new_b\n+            mask & old_b != mask & new_b\n         }\n     }\n     #[inline(always)]\n-    fn union(s: &small_bitv) -> bool {\n-        self.bits_op(s.bits, |u1, u2| { u1 | u2 })\n+    fn union(s: &small_bitv, nbits: uint) -> bool {\n+        self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n     #[inline(always)]\n-    fn intersect(s: &small_bitv) -> bool {\n-        self.bits_op(s.bits, |u1, u2| { u1 & u2 })\n+    fn intersect(s: &small_bitv, nbits: uint) -> bool {\n+        self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n     #[inline(always)]\n-    fn become(s: &small_bitv) -> bool {\n-        let old = self.bits;\n-        self.bits = s.bits;\n-        old != self.bits\n+    fn become(s: &small_bitv, nbits: uint) -> bool {\n+        self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n     #[inline(always)]\n-    fn difference(s: &small_bitv) -> bool {\n-        let old = self.bits;\n-        self.bits &= !s.bits;\n-        old != self.bits\n+    fn difference(s: &small_bitv, nbits: uint) -> bool {\n+        self.bits_op(s.bits, nbits, |u1, u2| u1 ^ u2)\n     }\n     #[inline(always)]\n     pure fn get(i: uint) -> bool {\n@@ -65,38 +70,66 @@ struct small_bitv {\n         }\n     }\n     #[inline(always)]\n-    fn equals(b: &small_bitv) -> bool { self.bits == b.bits }\n+    fn equals(b: &small_bitv, nbits: uint) -> bool {\n+        let mask = small_mask(nbits);\n+        mask & self.bits == mask & b.bits\n+    }\n     #[inline(always)]\n     fn clear() { self.bits = 0; }\n     #[inline(always)]\n     fn set_all() { self.bits = !0; }\n     #[inline(always)]\n-    fn is_true() -> bool { self.bits == !0 }\n+    fn is_true(nbits: uint) -> bool {\n+        small_mask(nbits) & !self.bits == 0\n+    }\n     #[inline(always)]\n-    fn is_false() -> bool { self.bits == 0 }\n+    fn is_false(nbits: uint) -> bool {\n+        small_mask(nbits) & self.bits == 0\n+    }\n     #[inline(always)]\n     fn invert() { self.bits = !self.bits; }\n }\n \n+/**\n+ * a mask that has a 1 for each defined bit in the nth element of a big_bitv,\n+ * assuming n bits.\n+ */\n+#[inline(always)]\n+fn big_mask(nbits: uint, elem: uint) -> uint {\n+    let rmd = nbits % uint_bits;\n+    let nelems = nbits/uint_bits + if rmd == 0 {0} else {1};\n+\n+    if elem < nelems - 1 || rmd == 0 {\n+        !0\n+    } else {\n+        (1 << rmd) - 1\n+    }\n+}\n+\n struct big_bitv {\n-// only mut b/c of clone and lack of other constructor\n+    // only mut b/c of clone and lack of other constructor\n     let mut storage: ~[mut uint];\n     new(-storage: ~[mut uint]) {\n         self.storage <- storage;\n     }\n     priv {\n         #[inline(always)]\n-        fn process(b: &big_bitv, op: fn(uint, uint) -> uint) -> bool {\n+        fn process(b: &big_bitv, nbits: uint, op: fn(uint, uint) -> uint)\n+                                                                     -> bool {\n             let len = b.storage.len();\n             assert (self.storage.len() == len);\n             let mut changed = false;\n             do uint::range(0, len) |i| {\n-                let w0 = self.storage[i];\n-                let w1 = b.storage[i];\n-                let w = op(w0, w1);\n-                if w0 != w unchecked { changed = true; self.storage[i] = w; };\n+                let mask = big_mask(nbits, i);\n+                let w0 = self.storage[i] & mask;\n+                let w1 = b.storage[i] & mask;\n+                let w = op(w0, w1) & mask;\n+                if w0 != w unchecked {\n+                    changed = true;\n+                    self.storage[i] = w;\n+                }\n                 true\n-            };\n+            }\n             changed\n         }\n     }\n@@ -112,15 +145,21 @@ struct big_bitv {\n     #[inline(always)]\n     fn invert() { for self.each_storage() |w| { w = !w } }\n     #[inline(always)]\n-    fn union(b: &big_bitv)     -> bool { self.process(b, lor) }\n+    fn union(b: &big_bitv, nbits: uint) -> bool {\n+        self.process(b, nbits, lor)\n+    }\n     #[inline(always)]\n-    fn intersect(b: &big_bitv) -> bool { self.process(b, land) }\n+    fn intersect(b: &big_bitv, nbits: uint) -> bool {\n+        self.process(b, nbits, land)\n+    }\n     #[inline(always)]\n-    fn become(b: &big_bitv)    -> bool { self.process(b, right) }\n+    fn become(b: &big_bitv, nbits: uint) -> bool {\n+        self.process(b, nbits, right)\n+    }\n     #[inline(always)]\n-    fn difference(b: &big_bitv) -> bool {\n+    fn difference(b: &big_bitv, nbits: uint) -> bool {\n         self.invert();\n-        let b = self.intersect(b);\n+        let b = self.intersect(b, nbits);\n         self.invert();\n         b\n     }\n@@ -140,10 +179,13 @@ struct big_bitv {\n                  else { self.storage[w] & !flag };\n     }\n     #[inline(always)]\n-    fn equals(b: &big_bitv) -> bool {\n+    fn equals(b: &big_bitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n-            if self.storage[i] != b.storage[i] { return false; }\n+            let mask = big_mask(nbits, i);\n+            if mask & self.storage[i] != mask & b.storage[i] {\n+                return false;\n+            }\n         }\n     }\n }\n@@ -163,8 +205,10 @@ struct bitv {\n           self.rep = small(~small_bitv(if init {!0} else {0}));\n         }\n         else {\n-          let s = to_mut(from_elem(nbits / uint_bits + 1,\n-                                        if init {!0} else {0}));\n+          let nelems = nbits/uint_bits +\n+                       if nbits % uint_bits == 0 {0} else {1};\n+          let elem = if init {!0} else {0};\n+          let s = to_mut(from_elem(nelems, elem));\n           self.rep = big(~big_bitv(s));\n         };\n     }\n@@ -182,20 +226,20 @@ struct bitv {\n             match self.rep {\n               small(s) => match other.rep {\n                 small(s1) => match op {\n-                  union      => s.union(s1),\n-                  intersect  => s.intersect(s1),\n-                  assign     => s.become(s1),\n-                  difference => s.difference(s1)\n+                  union      => s.union(s1,      self.nbits),\n+                  intersect  => s.intersect(s1,  self.nbits),\n+                  assign     => s.become(s1,     self.nbits),\n+                  difference => s.difference(s1, self.nbits)\n                 },\n                 big(s1) => self.die()\n               },\n               big(s) => match other.rep {\n                 small(_) => self.die(),\n                 big(s1) => match op {\n-                  union      => s.union(s1),\n-                  intersect  => s.intersect(s1),\n-                  assign     => s.become(s1),\n-                  difference => s.difference(s1)\n+                  union      => s.union(s1,      self.nbits),\n+                  intersect  => s.intersect(s1,  self.nbits),\n+                  assign     => s.become(s1,     self.nbits),\n+                  difference => s.difference(s1, self.nbits)\n                 }\n               }\n             }\n@@ -280,11 +324,11 @@ struct bitv {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         small(b) => match v1.rep {\n-          small(b1) => b.equals(b1),\n+          small(b1) => b.equals(b1, self.nbits),\n           _ => false\n         },\n         big(s) => match v1.rep {\n-          big(s1) => s.equals(s1),\n+          big(s1) => s.equals(s1, self.nbits),\n           small(_) => return false\n         }\n       }\n@@ -330,7 +374,7 @@ struct bitv {\n     #[inline(always)]\n     fn is_true() -> bool {\n       match self.rep {\n-        small(b) => b.is_true(),\n+        small(b) => b.is_true(self.nbits),\n         _ => {\n           for self.each() |i| { if !i { return false; } }\n           true\n@@ -351,7 +395,7 @@ struct bitv {\n \n     fn is_false() -> bool {\n       match self.rep {\n-        small(b) => b.is_false(),\n+        small(b) => b.is_false(self.nbits),\n         big(_) => {\n           for self.each() |i| { if i { return false; } }\n           true\n@@ -740,6 +784,33 @@ mod tests {\n         let v1 = bitv(110u, false);\n         assert !v0.equal(v1);\n     }\n+\n+    #[test]\n+    fn test_equal_sneaky_small() {\n+        let a = bitv::bitv(1, false);\n+        a.set(0, true);\n+\n+        let b = bitv::bitv(1, true);\n+        b.set(0, true);\n+\n+        assert a.equal(b);\n+    }\n+\n+    #[test]\n+    fn test_equal_sneaky_big() {\n+        let a = bitv::bitv(100, false);\n+        for uint::range(0, 100) |i| {\n+            a.set(i, true);\n+        }\n+\n+        let b = bitv::bitv(100, true);\n+        for uint::range(0, 100) |i| {\n+            b.set(i, true);\n+        }\n+\n+        assert a.equal(b);\n+    }\n+\n }\n \n //"}]}