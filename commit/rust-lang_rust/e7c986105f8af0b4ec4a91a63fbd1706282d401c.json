{"sha": "e7c986105f8af0b4ec4a91a63fbd1706282d401c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3Yzk4NjEwNWY4YWYwYjRlYzRhOTFhNjNmYmQxNzA2MjgyZDQwMWM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-19T07:33:32Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-03T11:10:20Z"}, "message": "Fixes to collections to accommodate arith-overflow changes.\n\n* `collections::btree::node`: accommodate (transient) underflow.\n\n* `collections::btree::map`: avoid underflow during `fn next`\n  for `BTreeMap::range` methods.\n\n* `collections::slice`: note that pnkfelix deliberately used\n  `new_pos_wrapping` only once; the other cases of arithmetic do not\n  over- nor underflow, which is a useful property to leave implicitly\n  checked/documented via the remaining calls to `fn new_pos(..)`.\n\n* `collections::vec_deque` applied wrapping ops (somewhat blindly)\n  to two implementation methods, and many tests.\n\n* `std::collections::hash::table` : Use `OverflowingOps` trait to\n  track overflow during `calculate_offsets` and `calculate_allocation`\n  functions.", "tree": {"sha": "b07dca60310265aedb20362d7466a37e1695599f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b07dca60310265aedb20362d7466a37e1695599f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c986105f8af0b4ec4a91a63fbd1706282d401c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c986105f8af0b4ec4a91a63fbd1706282d401c", "html_url": "https://github.com/rust-lang/rust/commit/e7c986105f8af0b4ec4a91a63fbd1706282d401c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c986105f8af0b4ec4a91a63fbd1706282d401c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf18e9c331e697faa11e395f6ccf3b0230af7aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf18e9c331e697faa11e395f6ccf3b0230af7aae", "html_url": "https://github.com/rust-lang/rust/commit/cf18e9c331e697faa11e395f6ccf3b0230af7aae"}], "stats": {"total": 139, "additions": 83, "deletions": 56}, "files": [{"sha": "1fa592ac477a243cf3f9010c51d8b4a6749cb8bd", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e7c986105f8af0b4ec4a91a63fbd1706282d401c", "patch": "@@ -25,7 +25,7 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator, IntoIterator};\n use core::ops::{Index, IndexMut};\n-use core::{iter, fmt, mem};\n+use core::{iter, fmt, mem, usize};\n use Bound::{self, Included, Excluded, Unbounded};\n \n use borrow::Borrow;\n@@ -1467,7 +1467,7 @@ macro_rules! range_impl {\n             $Range {\n                 inner: AbsIter {\n                     traversals: traversals,\n-                    size: 0, // unused\n+                    size: usize::MAX, // unused\n                 }\n             }\n         }"}, {"sha": "f2a6910a30252469d22bdafd6d5c6a127a114e44", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e7c986105f8af0b4ec4a91a63fbd1706282d401c", "patch": "@@ -1215,7 +1215,8 @@ impl<K, V> Node<K, V> {\n         ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n-            self.len() - index + 1\n+            // index can be == len+1, so do the +1 first to avoid underflow.\n+            (self.len() + 1) - index\n         );\n \n         edge"}, {"sha": "2660161c506465957a3defa2bd3f3ef37cc2f54d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e7c986105f8af0b4ec4a91a63fbd1706282d401c", "patch": "@@ -96,6 +96,7 @@ use core::iter::{range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n+use core::num::wrapping::WrappingOps;\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n@@ -1209,18 +1210,22 @@ struct SizeDirection {\n impl Iterator for ElementSwaps {\n     type Item = (usize, usize);\n \n-    #[inline]\n+    // #[inline]\n     fn next(&mut self) -> Option<(usize, usize)> {\n+        fn new_pos_wrapping(i: usize, s: Direction) -> usize {\n+            i.wrapping_add(match s { Pos => 1, Neg => -1 })\n+        }\n+\n         fn new_pos(i: usize, s: Direction) -> usize {\n-            i + match s { Pos => 1, Neg => -1 }\n+            match s { Pos => i + 1, Neg => i - 1 }\n         }\n \n         // Find the index of the largest mobile element:\n         // The direction should point into the vector, and the\n         // swap should be with a smaller `size` element.\n         let max = self.sdir.iter().cloned().enumerate()\n                            .filter(|&(i, sd)|\n-                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                new_pos_wrapping(i, sd.dir) < self.sdir.len() &&\n                                 self.sdir[new_pos(i, sd.dir)].size < sd.size)\n                            .max_by(|&(_, sd)| sd.size);\n         match max {"}, {"sha": "3f086dd62474af8f247b69b2ff9bfd51faf7691b", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=e7c986105f8af0b4ec4a91a63fbd1706282d401c", "patch": "@@ -26,6 +26,7 @@ use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n+use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n@@ -120,6 +121,20 @@ impl<T> VecDeque<T> {\n     #[inline]\n     fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n \n+    /// Returns the index in the underlying buffer for a given logical element\n+    /// index + addend.\n+    #[inline]\n+    fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n+        wrap_index(idx.wrapping_add(addend), self.cap)\n+    }\n+\n+    /// Returns the index in the underlying buffer for a given logical element\n+    /// index - subtrahend.\n+    #[inline]\n+    fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n+        wrap_index(idx.wrapping_sub(subtrahend), self.cap)\n+    }\n+\n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n@@ -197,7 +212,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: usize) -> Option<&T> {\n         if i < self.len() {\n-            let idx = self.wrap_index(self.tail + i);\n+            let idx = self.wrap_add(self.tail, i);\n             unsafe { Some(&*self.ptr.offset(idx as isize)) }\n         } else {\n             None\n@@ -227,7 +242,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n         if i < self.len() {\n-            let idx = self.wrap_index(self.tail + i);\n+            let idx = self.wrap_add(self.tail, i);\n             unsafe { Some(&mut *self.ptr.offset(idx as isize)) }\n         } else {\n             None\n@@ -257,8 +272,8 @@ impl<T> VecDeque<T> {\n     pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.wrap_index(self.tail + i);\n-        let rj = self.wrap_index(self.tail + j);\n+        let ri = self.wrap_add(self.tail, i);\n+        let rj = self.wrap_add(self.tail, j);\n         unsafe {\n             ptr::swap(self.ptr.offset(ri as isize), self.ptr.offset(rj as isize))\n         }\n@@ -427,7 +442,7 @@ impl<T> VecDeque<T> {\n                 //   [. . . o o o o o o o . . . . . . ]\n                 //        H T\n                 //   [o o . o o o o o ]\n-                let len = self.wrap_index(self.head - target_cap);\n+                let len = self.wrap_sub(self.head, target_cap);\n                 unsafe {\n                     self.copy_nonoverlapping(0, target_cap, len);\n                 }\n@@ -438,7 +453,7 @@ impl<T> VecDeque<T> {\n                 //   [o o o o o . . . . . . . . . o o ]\n                 //              H T\n                 //   [o o o o o . o o ]\n-                debug_assert!(self.wrap_index(self.head - 1) < target_cap);\n+                debug_assert!(self.wrap_sub(self.head, 1) < target_cap);\n                 let len = self.cap - self.tail;\n                 let new_tail = target_cap - len;\n                 unsafe {\n@@ -775,7 +790,7 @@ impl<T> VecDeque<T> {\n             None\n         } else {\n             let tail = self.tail;\n-            self.tail = self.wrap_index(self.tail + 1);\n+            self.tail = self.wrap_add(self.tail, 1);\n             unsafe { Some(self.buffer_read(tail)) }\n         }\n     }\n@@ -799,7 +814,7 @@ impl<T> VecDeque<T> {\n             debug_assert!(!self.is_full());\n         }\n \n-        self.tail = self.wrap_index(self.tail - 1);\n+        self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n         unsafe { self.buffer_write(tail, t); }\n     }\n@@ -824,7 +839,7 @@ impl<T> VecDeque<T> {\n         }\n \n         let head = self.head;\n-        self.head = self.wrap_index(self.head + 1);\n+        self.head = self.wrap_add(self.head, 1);\n         unsafe { self.buffer_write(head, t) }\n     }\n \n@@ -847,7 +862,7 @@ impl<T> VecDeque<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            self.head = self.wrap_index(self.head - 1);\n+            self.head = self.wrap_sub(self.head, 1);\n             let head = self.head;\n             unsafe { Some(self.buffer_read(head)) }\n         }\n@@ -971,7 +986,7 @@ impl<T> VecDeque<T> {\n         //      A - The element that should be after the insertion point\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_index(self.tail + i);\n+        let idx = self.wrap_add(self.tail, i);\n \n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n@@ -990,7 +1005,7 @@ impl<T> VecDeque<T> {\n                 //      [A o o o o o o o . . . . . I]\n                 //\n \n-                self.tail = self.wrap_index(self.tail - 1);\n+                self.tail = self.wrap_sub(self.tail, 1);\n             },\n             (true, true, _) => unsafe {\n                 // contiguous, insert closer to tail:\n@@ -1012,7 +1027,7 @@ impl<T> VecDeque<T> {\n                 //      [o I A o o o o o . . . . . . . o]\n                 //       M                             M\n \n-                let new_tail = self.wrap_index(self.tail - 1);\n+                let new_tail = self.wrap_sub(self.tail, 1);\n \n                 self.copy(new_tail, self.tail, 1);\n                 // Already moved the tail, so we only copy `i - 1` elements.\n@@ -1031,7 +1046,7 @@ impl<T> VecDeque<T> {\n                 //                       M M M\n \n                 self.copy(idx + 1, idx, self.head - idx);\n-                self.head = self.wrap_index(self.head + 1);\n+                self.head = self.wrap_add(self.head, 1);\n             },\n             (false, true, true) => unsafe {\n                 // discontiguous, insert closer to tail, tail section:\n@@ -1123,7 +1138,7 @@ impl<T> VecDeque<T> {\n         }\n \n         // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_index(self.tail + i);\n+        let new_idx = self.wrap_add(self.tail, i);\n         unsafe {\n             self.buffer_write(new_idx, t);\n         }\n@@ -1170,7 +1185,7 @@ impl<T> VecDeque<T> {\n         //      R - Indicates element that is being removed\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_index(self.tail + i);\n+        let idx = self.wrap_add(self.tail, i);\n \n         let elem = unsafe {\n             Some(self.buffer_read(idx))\n@@ -1219,7 +1234,7 @@ impl<T> VecDeque<T> {\n                 //                               M M\n \n                 self.copy(self.tail + 1, self.tail, i);\n-                self.tail = self.wrap_index(self.tail + 1);\n+                self.tail = self.wrap_add(self.tail, 1);\n             },\n             (false, false, false) => unsafe {\n                 // discontiguous, remove closer to head, head section:\n@@ -1265,7 +1280,7 @@ impl<T> VecDeque<T> {\n                     self.copy(0, 1, self.head - 1);\n                 }\n \n-                self.head = self.wrap_index(self.head - 1);\n+                self.head = self.wrap_sub(self.head, 1);\n             },\n             (false, true, false) => unsafe {\n                 // discontiguous, remove closer to tail, head section:\n@@ -1286,7 +1301,7 @@ impl<T> VecDeque<T> {\n                 // move elements from tail to end forward, excluding the last one\n                 self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n \n-                self.tail = self.wrap_index(self.tail + 1);\n+                self.tail = self.wrap_add(self.tail, 1);\n             }\n         }\n \n@@ -1354,7 +1369,7 @@ impl<T> VecDeque<T> {\n         }\n \n         // Cleanup where the ends of the buffers are\n-        self.head = self.wrap_index(self.head - other_len);\n+        self.head = self.wrap_sub(self.head, other_len);\n         other.head = other.wrap_index(other_len);\n \n         other\n@@ -1429,7 +1444,7 @@ fn wrap_index(index: usize, size: usize) -> usize {\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n-    (head - tail) & (size - 1)\n+    (head.wrapping_sub(tail)) & (size - 1)\n }\n \n /// `VecDeque` iterator.\n@@ -1461,7 +1476,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             return None;\n         }\n         let tail = self.tail;\n-        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n         unsafe { Some(self.ring.get_unchecked(tail)) }\n     }\n \n@@ -1479,7 +1494,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         if self.tail == self.head {\n             return None;\n         }\n-        self.head = wrap_index(self.head - 1, self.ring.len());\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n         unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n }\n@@ -1500,7 +1515,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n         if j >= self.indexable() {\n             None\n         } else {\n-            let idx = wrap_index(self.tail + j, self.ring.len());\n+            let idx = wrap_index(self.tail.wrapping_add(j), self.ring.len());\n             unsafe { Some(self.ring.get_unchecked(idx)) }\n         }\n     }\n@@ -1524,7 +1539,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             return None;\n         }\n         let tail = self.tail;\n-        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(tail);\n@@ -1546,7 +1561,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         if self.tail == self.head {\n             return None;\n         }\n-        self.head = wrap_index(self.head - 1, self.ring.len());\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(self.head);"}, {"sha": "2670cd0c003b5c41bed4d7a4ab068daaf63842e8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c986105f8af0b4ec4a91a63fbd1706282d401c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e7c986105f8af0b4ec4a91a63fbd1706282d401c", "patch": "@@ -20,6 +20,7 @@ use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n use num::{Int, UnsignedInt};\n+use num::wrapping::{OverflowingOps, WrappingOps};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n@@ -371,7 +372,6 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     /// In the cited blog posts above, this is called the \"distance to\n     /// initial bucket\", or DIB. Also known as \"probe count\".\n     pub fn distance(&self) -> usize {\n-        use core::num::wrapping::WrappingOps;\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n@@ -528,40 +528,40 @@ fn test_rounding() {\n fn calculate_offsets(hashes_size: usize,\n                      keys_size: usize, keys_align: usize,\n                      vals_align: usize)\n-                     -> (usize, usize) {\n+                     -> (usize, usize, bool) {\n     let keys_offset = round_up_to_next(hashes_size, keys_align);\n-    let end_of_keys = keys_offset + keys_size;\n+    let (end_of_keys, oflo) = keys_offset.overflowing_add(keys_size);\n \n     let vals_offset = round_up_to_next(end_of_keys, vals_align);\n \n-    (keys_offset, vals_offset)\n+    (keys_offset, vals_offset, oflo)\n }\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize, hash_align: usize,\n                         keys_size: usize, keys_align: usize,\n                         vals_size: usize, vals_align: usize)\n-                        -> (usize, usize, usize) {\n+                        -> (usize, usize, usize, bool) {\n     let hash_offset = 0;\n-    let (_, vals_offset) = calculate_offsets(hash_size,\n-                                             keys_size, keys_align,\n-                                                        vals_align);\n-    let end_of_vals = vals_offset + vals_size;\n+    let (_, vals_offset, oflo) = calculate_offsets(hash_size,\n+                                                   keys_size, keys_align,\n+                                                              vals_align);\n+    let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n \n     let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n \n-    (min_align, hash_offset, end_of_vals)\n+    (min_align, hash_offset, end_of_vals, oflo || oflo2)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148));\n-    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6));\n-    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48));\n-    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n-    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5));\n-    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24));\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148, false));\n+    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6, false));\n+    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48, false));\n+    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144, false));\n+    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5, false));\n+    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24, false));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -591,12 +591,14 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, size) =\n+        let (malloc_alignment, hash_offset, size, oflo) =\n             calculate_allocation(\n                 hashes_size, min_align_of::<u64>(),\n                 keys_size,   min_align_of::< K >(),\n                 vals_size,   min_align_of::< V >());\n \n+        assert!(!oflo, \"capacity overflow\");\n+\n         // One check for overflow that covers calculation and rounding of size.\n         let size_of_bucket = size_of::<u64>().checked_add(size_of::<K>()).unwrap()\n                                              .checked_add(size_of::<V>()).unwrap();\n@@ -622,10 +624,11 @@ impl<K, V> RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n \n         let buffer = *self.hashes as *mut u8;\n-        let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n-                                                           keys_size, min_align_of::<K>(),\n-                                                           min_align_of::<V>());\n-\n+        let (keys_offset, vals_offset, oflo) =\n+            calculate_offsets(hashes_size,\n+                              keys_size, min_align_of::<K>(),\n+                              min_align_of::<V>());\n+        debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n@@ -999,9 +1002,12 @@ impl<K, V> Drop for RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n         let vals_size = self.capacity * size_of::<V>();\n-        let (align, _, size) = calculate_allocation(hashes_size, min_align_of::<u64>(),\n-                                                    keys_size, min_align_of::<K>(),\n-                                                    vals_size, min_align_of::<V>());\n+        let (align, _, size, oflo) =\n+            calculate_allocation(hashes_size, min_align_of::<u64>(),\n+                                 keys_size, min_align_of::<K>(),\n+                                 vals_size, min_align_of::<V>());\n+\n+        debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n             deallocate(*self.hashes as *mut u8, size, align);"}]}