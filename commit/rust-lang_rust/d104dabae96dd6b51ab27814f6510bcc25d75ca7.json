{"sha": "d104dabae96dd6b51ab27814f6510bcc25d75ca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMDRkYWJhZTk2ZGQ2YjUxYWIyNzgxNGY2NTEwYmNjMjVkNzVjYTc=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-12T01:56:53Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-16T21:24:49Z"}, "message": "Make some NullablePointer enums FFI-compatible with the base pointer type.", "tree": {"sha": "43eaebaab364bab41a0b9a3eea1e622d7c2ec792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43eaebaab364bab41a0b9a3eea1e622d7c2ec792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d104dabae96dd6b51ab27814f6510bcc25d75ca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d104dabae96dd6b51ab27814f6510bcc25d75ca7", "html_url": "https://github.com/rust-lang/rust/commit/d104dabae96dd6b51ab27814f6510bcc25d75ca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d104dabae96dd6b51ab27814f6510bcc25d75ca7/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "url": "https://api.github.com/repos/rust-lang/rust/commits/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "html_url": "https://github.com/rust-lang/rust/commit/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d"}], "stats": {"total": 108, "additions": 94, "deletions": 14}, "files": [{"sha": "a9e7b2732079b96e0c3d7a231c01e39529cd15b8", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d104dabae96dd6b51ab27814f6510bcc25d75ca7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d104dabae96dd6b51ab27814f6510bcc25d75ca7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d104dabae96dd6b51ab27814f6510bcc25d75ca7", "patch": "@@ -91,6 +91,8 @@ pub enum Repr {\n      * field is known to be nonnull due to its type; if that field is null, then\n      * it represents the other case, which is inhabited by at most one value\n      * (and all other fields are undefined/unused).\n+     * If the case with the nullable pointer has a single field then we don't\n+     * wrap it in a struct and instead just deal with it directly as a pointer.\n      *\n      * For example, `std::option::Option` instantiated at a safe pointer type\n      * is represented such that `None` is a null pointer and `Some` is the\n@@ -413,8 +415,11 @@ pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n }\n pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n-        CEnum(..) | General(..) => { }\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n+        CEnum(..) | General(..) => {\n+        }\n+        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n+        }\n+        Univariant(ref st, _) | NullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n                                  st.packed)\n     }\n@@ -423,7 +428,14 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n+        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n+            if sizing {\n+                type_of::sizing_type_of(cx, *st.fields.get(0))\n+            } else {\n+                type_of::type_of(cx, *st.fields.get(0))\n+            }\n+        }\n+        Univariant(ref st, _) | NullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n                     Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n@@ -498,7 +510,7 @@ pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n         CEnum(..) | General(..) => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n         }\n         Univariant(..) => {\n@@ -528,7 +540,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = C_u8(bcx.ccx(), 0);\n             signed = false;\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n@@ -541,8 +553,12 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n \n fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n+    let llptr = if nonnull.fields.len() == 1 {\n+        Load(bcx, scrutinee)\n+    } else {\n+        Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]))\n+    };\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n     let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n     ICmp(bcx, cmp, llptr, C_null(llptrty))\n }\n@@ -590,7 +606,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         Univariant(..) => {\n             bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n-        NullablePointer{ .. } => {\n+        NullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(Result::new(bcx, C_i1(bcx.ccx(), discr != 0)))\n         }\n@@ -621,9 +637,13 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         Univariant(..) => {\n             assert_eq!(discr, 0);\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n+                let llptrptr = if nonnull.fields.len() == 1 {\n+                    val\n+                } else {\n+                    GEPi(bcx, val, [0, ptrfield])\n+                };\n                 let llptrty = type_of::type_of(bcx.ccx(),\n                                                *nonnull.fields.get(ptrfield));\n                 Store(bcx, C_null(llptrty), llptrptr)\n@@ -651,7 +671,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n-        NullablePointer{ nonnull: ref nonnull, nndiscr,\n+        NullablePointer { nonnull: ref nonnull, nndiscr,\n                          nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n@@ -675,10 +695,15 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields,\n+        NullablePointer { nonnull: ref nonnull, nullfields: ref nullfields,\n                          nndiscr, .. } => {\n             if discr == nndiscr {\n-                struct_field_ptr(bcx, nonnull, val, ix, false)\n+                if nonnull.fields.len() == 1 {\n+                    assert_eq!(ix, 0);\n+                    val\n+                } else {\n+                    struct_field_ptr(bcx, nonnull, val, ix, false)\n+                }\n             } else {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n@@ -759,7 +784,15 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, contents.as_slice(), st.packed)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n+        NullablePointer { nonnull: ref st, nndiscr, .. } if st.fields.len() == 1 => {\n+            if discr == nndiscr {\n+                assert_eq!(vals.len(), 1);\n+                vals[0]\n+            } else {\n+                C_null(type_of::sizing_type_of(ccx, *st.fields.get(0)))\n+            }\n+        }\n+        NullablePointer { nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n@@ -867,7 +900,15 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         Univariant(..) => 0,\n-        NullablePointer{ nndiscr, ptrfield, .. } => {\n+        NullablePointer { nonnull: ref st, nndiscr, .. } if st.fields.len() == 1 => {\n+            if is_null(val) {\n+                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n+                (1 - nndiscr) as Disr\n+            } else {\n+                nndiscr\n+            }\n+        }\n+        NullablePointer { nndiscr, ptrfield, .. } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n@@ -891,6 +932,10 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n         General(..) => const_struct_field(ccx, val, ix + 1),\n+        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n+            assert_eq!(ix, 0);\n+            val\n+        }\n         NullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }"}, {"sha": "548a16bd1205bf14b4164d6446ae1cb064081de1", "filename": "src/test/run-pass/nullable-pointer-ffi-compat.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d104dabae96dd6b51ab27814f6510bcc25d75ca7/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d104dabae96dd6b51ab27814f6510bcc25d75ca7/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs?ref=d104dabae96dd6b51ab27814f6510bcc25d75ca7", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #11303, #11040:\n+// This would previously crash on i686 linux due to abi differences\n+// between returning an Option<T> and T, where T is a non nullable\n+// pointer.\n+// If we have an enum with two variants such that one is zero sized\n+// and the other contains a nonnullable pointer, we don't use a\n+// separate discriminant. Instead we use that pointer field to differentiate\n+// between the 2 cases.\n+// Also, if the variant with the nonnullable pointer has no other fields\n+// then we simply express the enum as just a pointer and not wrap it\n+// in a struct.\n+\n+use std::mem;\n+\n+#[inline(never)]\n+extern \"C\" fn foo<'a>(x: &'a int) -> Option<&'a int> { Some(x) }\n+\n+static FOO: int = 0xDEADBEE;\n+\n+pub fn main() {\n+    unsafe {\n+        let f: extern \"C\" fn<'a>(&'a int) -> &'a int = mem::transmute(foo);\n+        assert_eq!(*f(&FOO), FOO);\n+    }\n+}"}]}