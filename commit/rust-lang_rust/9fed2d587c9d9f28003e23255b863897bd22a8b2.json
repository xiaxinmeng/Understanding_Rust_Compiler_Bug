{"sha": "9fed2d587c9d9f28003e23255b863897bd22a8b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZWQyZDU4N2M5ZDlmMjgwMDNlMjMyNTViODYzODk3YmQyMmE4YjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T03:21:16Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T13:43:20Z"}, "message": "parser: extract common foreign item code for each kind", "tree": {"sha": "ac1af1f02e11ff985bd6432980803b1942837055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1af1f02e11ff985bd6432980803b1942837055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fed2d587c9d9f28003e23255b863897bd22a8b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fed2d587c9d9f28003e23255b863897bd22a8b2", "html_url": "https://github.com/rust-lang/rust/commit/9fed2d587c9d9f28003e23255b863897bd22a8b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fed2d587c9d9f28003e23255b863897bd22a8b2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be493fe8cc40c3d3f6030a1313c1ff747fce770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be493fe8cc40c3d3f6030a1313c1ff747fce770d", "html_url": "https://github.com/rust-lang/rust/commit/be493fe8cc40c3d3f6030a1313c1ff747fce770d"}], "stats": {"total": 88, "additions": 21, "deletions": 67}, "files": [{"sha": "0a8f37708621a3c4769b518065c5996f4a5cf94c", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 21, "deletions": 67, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9fed2d587c9d9f28003e23255b863897bd22a8b2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed2d587c9d9f28003e23255b863897bd22a8b2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=9fed2d587c9d9f28003e23255b863897bd22a8b2", "patch": "@@ -740,7 +740,8 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n-        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n+\n+        let (ident, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_assoc_ty()?\n         } else if self.check_fn_front_matter() {\n             let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n@@ -751,17 +752,9 @@ impl<'a> Parser<'a> {\n             self.parse_assoc_const()?\n         };\n \n-        Ok(AssocItem {\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(self.prev_span),\n-            ident: name,\n-            attrs,\n-            vis,\n-            defaultness,\n-            generics,\n-            kind,\n-            tokens: None,\n-        })\n+        let span = lo.to(self.prev_span);\n+        let id = DUMMY_NODE_ID;\n+        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, generics, kind, tokens: None })\n     }\n \n     /// This parses the grammar:\n@@ -967,35 +960,25 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n-    /// Parses a foreign item.\n+    /// Parses a foreign item (one in an `extern { ... }` block).\n     pub fn parse_foreign_item(&mut self) -> PResult<'a, P<ForeignItem>> {\n         maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.check_keyword(kw::Type) {\n+        let (ident, kind) = if self.check_keyword(kw::Type) {\n             // FOREIGN TYPE ITEM\n-            self.parse_item_foreign_type(vis, lo, attrs)\n+            self.parse_item_foreign_type()?\n         } else if self.check_fn_front_matter() {\n             // FOREIGN FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ForeignItemKind::Fn(sig, generics, body);\n-            let span = lo.to(self.prev_span);\n-            Ok(P(ast::ForeignItem {\n-                ident,\n-                attrs,\n-                kind,\n-                id: DUMMY_NODE_ID,\n-                span,\n-                vis,\n-                tokens: None,\n-            }))\n+            (ident, ForeignItemKind::Fn(sig, generics, body))\n         } else if self.is_static_global() {\n             // FOREIGN STATIC ITEM\n             self.bump(); // `static`\n-            self.parse_item_foreign_static(vis, lo, attrs)\n+            self.parse_item_foreign_static()?\n         } else if self.token.is_keyword(kw::Const) {\n             // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n             self.bump(); // `const`\n@@ -1007,66 +990,37 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            self.parse_item_foreign_static(vis, lo, attrs)\n+            self.parse_item_foreign_static()?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"extern\", Some(&vis), &mut false)? {\n-            let kind = ForeignItemKind::Macro(mac);\n-            let span = lo.to(self.prev_span);\n-            let ident = Ident::invalid();\n-            Ok(P(ForeignItem { ident, span, id: DUMMY_NODE_ID, attrs, vis, kind, tokens: None }))\n+            (Ident::invalid(), ForeignItemKind::Macro(mac))\n         } else {\n             if !attrs.is_empty() {\n                 self.expected_item_err(&attrs)?;\n             }\n-            self.unexpected()\n-        }\n+            self.unexpected()?\n+        };\n+\n+        let span = lo.to(self.prev_span);\n+        Ok(P(ast::ForeignItem { ident, attrs, kind, id: DUMMY_NODE_ID, span, vis, tokens: None }))\n     }\n \n     /// Parses a static item from a foreign module.\n     /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_static(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         let mutbl = self.parse_mutability();\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Static(ty, mutbl),\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Static(ty, mutbl)))\n     }\n \n     /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_type(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         self.expect_keyword(kw::Type)?;\n-\n         let ident = self.parse_ident()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Ty,\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Ty))\n     }\n \n     fn is_static_global(&mut self) -> bool {"}]}