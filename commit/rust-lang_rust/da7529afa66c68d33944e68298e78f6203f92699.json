{"sha": "da7529afa66c68d33944e68298e78f6203f92699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNzUyOWFmYTY2YzY4ZDMzOTQ0ZTY4Mjk4ZTc4ZjYyMDNmOTI2OTk=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-04-07T12:05:22Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-04-07T12:05:22Z"}, "message": "Split check_cast to a separate file", "tree": {"sha": "5110511e55cf873e01e641ba4f7929c98d42ebfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5110511e55cf873e01e641ba4f7929c98d42ebfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da7529afa66c68d33944e68298e78f6203f92699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da7529afa66c68d33944e68298e78f6203f92699", "html_url": "https://github.com/rust-lang/rust/commit/da7529afa66c68d33944e68298e78f6203f92699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da7529afa66c68d33944e68298e78f6203f92699/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1169693f03d73e422866d9c412328a031ed0e4df", "url": "https://api.github.com/repos/rust-lang/rust/commits/1169693f03d73e422866d9c412328a031ed0e4df", "html_url": "https://github.com/rust-lang/rust/commit/1169693f03d73e422866d9c412328a031ed0e4df"}], "stats": {"total": 336, "additions": 184, "deletions": 152}, "files": [{"sha": "b35e3c800fcb01a11695664729f5446d0eac6c8e", "filename": "src/librustc_typeck/check/cast.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/da7529afa66c68d33944e68298e78f6203f92699/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7529afa66c68d33944e68298e78f6203f92699/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=da7529afa66c68d33944e68298e78f6203f92699", "patch": "@@ -0,0 +1,179 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for type-checking cast expressions.\n+\n+use super::coercion;\n+use super::demand;\n+use super::FnCtxt;\n+use super::structurally_resolved_type;\n+\n+use lint;\n+use middle::infer;\n+use middle::ty;\n+use middle::ty::Ty;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+/// Reifies a cast check to be checked once we have full type information for\n+/// a function context.\n+pub struct CastCheck<'tcx> {\n+    expr: ast::Expr,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'tcx> CastCheck<'tcx> {\n+    pub fn new(expr: ast::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n+               -> CastCheck<'tcx> {\n+        CastCheck {\n+            expr: expr,\n+            expr_ty: expr_ty,\n+            cast_ty: cast_ty,\n+            span: span,\n+        }\n+    }\n+}\n+\n+pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n+    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          t_1: Ty<'tcx>,\n+                                          t_e: Ty<'tcx>) {\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"illegal cast; cast through an \\\n+                    integer first: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_string(t_1))\n+        }, t_e, None);\n+    }\n+\n+    let span = cast.span;\n+    let e = &cast.expr;\n+    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n+    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n+\n+    // Check for trivial casts.\n+    if !ty::type_has_ty_infer(t_1) {\n+        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n+            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            } else {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            }\n+            return;\n+        }\n+    }\n+\n+    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+    let t_e_is_scalar = ty::type_is_scalar(t_e);\n+    let t_e_is_integral = ty::type_is_integral(t_e);\n+    let t_e_is_float = ty::type_is_floating_point(t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n+\n+    let t_1_is_scalar = ty::type_is_scalar(t_1);\n+    let t_1_is_char = ty::type_is_char(t_1);\n+    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n+    let t_1_is_float = ty::type_is_floating_point(t_1);\n+\n+    // casts to scalars other than `char` and `bare fn` are trivial\n+    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+\n+    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n+        demand::coerce(fcx, e.span, t_1, &e);\n+    } else if t_1_is_char {\n+        let t_e = fcx.infcx().shallow_resolve(t_e);\n+        if t_e.sty != ty::ty_uint(ast::TyU8) {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+            }, t_e, None);\n+        }\n+    } else if t_1.sty == ty::ty_bool {\n+        span_err!(fcx.tcx().sess, span, E0054,\n+                  \"cannot cast as `bool`, compare with zero instead\");\n+    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n+        t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n+        // Casts to float must go through an integer or boolean\n+        cast_through_integer_err(fcx, span, t_1, t_e)\n+    } else if t_e_is_c_enum && t_1_is_trivial {\n+        if ty::type_is_unsafe_ptr(t_1) {\n+            // ... and likewise with C enum -> *T\n+            cast_through_integer_err(fcx, span, t_1, t_e)\n+        }\n+        // casts from C-like enums are allowed\n+    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n+        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n+            match t1.sty {\n+                ty::ty_vec(_, Some(_)) => {}\n+                _ => return false\n+            }\n+            if ty::type_needs_infer(t2) {\n+                // This prevents this special case from going off when casting\n+                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n+                // #14893.)\n+                return false\n+            }\n+\n+            let el = ty::sequence_element_type(fcx.tcx(), t1);\n+            infer::mk_eqty(fcx.infcx(),\n+                           false,\n+                           infer::Misc(sp),\n+                           el,\n+                           t2).is_ok()\n+        }\n+\n+        // Due to the limitations of LLVM global constants,\n+        // region pointers end up pointing at copies of\n+        // vector elements instead of the original values.\n+        // To allow unsafe pointers to work correctly, we\n+        // need to special-case obtaining an unsafe pointer\n+        // from a region pointer to a vector.\n+\n+        /* this cast is only allowed from &[T, ..n] to *T or\n+        &T to *T. */\n+        match (&t_e.sty, &t_1.sty) {\n+            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n+             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n+            if types_compatible(fcx, e.span, mt1, mt2) => {\n+                /* this case is allowed */\n+            }\n+            _ => {\n+                demand::coerce(fcx, e.span, t_1, &e);\n+            }\n+        }\n+    } else if !(t_e_is_scalar && t_1_is_trivial) {\n+        /*\n+        If more type combinations should be supported than are\n+        supported here, then file an enhancement issue and\n+        record the issue number in this comment.\n+        */\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"non-scalar cast: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_string(t_1))\n+        }, t_e, None);\n+    }\n+}"}, {"sha": "f9bf3eaf3ddf6b11b39eec569cf2664d9c2235fb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 152, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/da7529afa66c68d33944e68298e78f6203f92699/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da7529afa66c68d33944e68298e78f6203f92699/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=da7529afa66c68d33944e68298e78f6203f92699", "patch": "@@ -139,6 +139,7 @@ pub mod demand;\n pub mod method;\n mod upvar;\n pub mod wf;\n+mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n@@ -185,7 +186,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // back and process them.\n     deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'tcx>>>>,\n \n-    deferred_cast_checks: RefCell<Vec<CastCheck<'tcx>>>,\n+    deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n }\n \n trait DeferredCallResolution<'tcx> {\n@@ -194,15 +195,6 @@ trait DeferredCallResolution<'tcx> {\n \n type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n \n-/// Reifies a cast check to be checked once we have full type information for\n-/// a function context.\n-struct CastCheck<'tcx> {\n-    expr: ast::Expr,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-    span: Span,\n-}\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy, Clone)]\n@@ -1071,141 +1063,6 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n \n-fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n-    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          t_1: Ty<'tcx>,\n-                                          t_e: Ty<'tcx>) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast through an \\\n-                    integer first: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    }\n-\n-    let span = cast.span;\n-    let e = &cast.expr;\n-    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n-    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n-\n-    // Check for trivial casts.\n-    if !ty::type_has_ty_infer(t_1) {\n-        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n-            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n-            } else {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n-            }\n-            return;\n-        }\n-    }\n-\n-    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n-    let t_e_is_scalar = ty::type_is_scalar(t_e);\n-    let t_e_is_integral = ty::type_is_integral(t_e);\n-    let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n-\n-    let t_1_is_scalar = ty::type_is_scalar(t_1);\n-    let t_1_is_char = ty::type_is_char(t_1);\n-    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n-    let t_1_is_float = ty::type_is_floating_point(t_1);\n-\n-    // casts to scalars other than `char` and `bare fn` are trivial\n-    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-\n-    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n-        demand::coerce(fcx, e.span, t_1, &e);\n-    } else if t_1_is_char {\n-        let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if t_e.sty != ty::ty_uint(ast::TyU8) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-            }, t_e, None);\n-        }\n-    } else if t_1.sty == ty::ty_bool {\n-        span_err!(fcx.tcx().sess, span, E0054,\n-                  \"cannot cast as `bool`, compare with zero instead\");\n-    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n-        t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n-        // Casts to float must go through an integer or boolean\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_e_is_c_enum && t_1_is_trivial {\n-        if ty::type_is_unsafe_ptr(t_1) {\n-            // ... and likewise with C enum -> *T\n-            cast_through_integer_err(fcx, span, t_1, t_e)\n-        }\n-        // casts from C-like enums are allowed\n-    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n-            match t1.sty {\n-                ty::ty_vec(_, Some(_)) => {}\n-                _ => return false\n-            }\n-            if ty::type_needs_infer(t2) {\n-                // This prevents this special case from going off when casting\n-                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n-                // #14893.)\n-                return false\n-            }\n-\n-            let el = ty::sequence_element_type(fcx.tcx(), t1);\n-            infer::mk_eqty(fcx.infcx(),\n-                           false,\n-                           infer::Misc(sp),\n-                           el,\n-                           t2).is_ok()\n-        }\n-\n-        // Due to the limitations of LLVM global constants,\n-        // region pointers end up pointing at copies of\n-        // vector elements instead of the original values.\n-        // To allow unsafe pointers to work correctly, we\n-        // need to special-case obtaining an unsafe pointer\n-        // from a region pointer to a vector.\n-\n-        /* this cast is only allowed from &[T, ..n] to *T or\n-        &T to *T. */\n-        match (&t_e.sty, &t_1.sty) {\n-            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-            if types_compatible(fcx, e.span, mt1, mt2) => {\n-                /* this case is allowed */\n-            }\n-            _ => {\n-                demand::coerce(fcx, e.span, t_1, &e);\n-            }\n-        }\n-    } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        /*\n-        If more type combinations should be supported than are\n-        supported here, then file an enhancement issue and\n-        record the issue number in this comment.\n-        */\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"non-scalar cast: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    }\n-}\n-\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n@@ -1925,7 +1782,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n         for check in deferred_cast_checks.iter() {\n-            check_cast(self, check);\n+            cast::check_cast(self, check);\n         }\n \n         deferred_cast_checks.clear();\n@@ -3531,12 +3388,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            deferred_cast_checks.push(CastCheck {\n-                expr: (**e).clone(),\n-                expr_ty: t_e,\n-                cast_ty: t_1,\n-                span: expr.span,\n-            });\n+            let cast_check = cast::CastCheck::new((**e).clone(), t_e, t_1, expr.span);\n+            deferred_cast_checks.push(cast_check);\n         }\n       }\n       ast::ExprVec(ref args) => {"}]}