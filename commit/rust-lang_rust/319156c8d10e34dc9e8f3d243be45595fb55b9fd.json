{"sha": "319156c8d10e34dc9e8f3d243be45595fb55b9fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOTE1NmM4ZDEwZTM0ZGM5ZThmM2QyNDNiZTQ1NTk1ZmI1NWI5ZmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-06T22:48:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-06T22:48:47Z"}, "message": "Begin tidying up name-mangling rules.", "tree": {"sha": "061ca797949e75bad556680da1fb286814b995d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061ca797949e75bad556680da1fb286814b995d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/319156c8d10e34dc9e8f3d243be45595fb55b9fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/319156c8d10e34dc9e8f3d243be45595fb55b9fd", "html_url": "https://github.com/rust-lang/rust/commit/319156c8d10e34dc9e8f3d243be45595fb55b9fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/319156c8d10e34dc9e8f3d243be45595fb55b9fd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee54fa5c7d4c670ee379e75cbd434bd524f8a3cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee54fa5c7d4c670ee379e75cbd434bd524f8a3cb", "html_url": "https://github.com/rust-lang/rust/commit/ee54fa5c7d4c670ee379e75cbd434bd524f8a3cb"}], "stats": {"total": 130, "additions": 72, "deletions": 58}, "files": [{"sha": "4230032f7ee6755ca67e25f9c0605ce4281dc69e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/319156c8d10e34dc9e8f3d243be45595fb55b9fd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/319156c8d10e34dc9e8f3d243be45595fb55b9fd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=319156c8d10e34dc9e8f3d243be45595fb55b9fd", "patch": "@@ -118,6 +118,7 @@ state type crate_ctxt = rec(session::session sess,\n                             hashmap[ast::def_id,\n                                     @ast::native_item] native_items,\n                             hashmap[ast::def_id, str] item_symbols,\n+                            mutable option::t[ValueRef] main_fn,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[ty::t, uint] tag_sizes,\n                             hashmap[ast::def_id, ValueRef] discrims,\n@@ -308,19 +309,10 @@ tag block_parent {\n state type result = rec(@block_ctxt bcx,\n                         ValueRef val);\n \n-fn sep() -> str {\n-    ret \"_\";\n-}\n-\n fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n   ret @rec(path = cx.path + [name] with *cx);\n }\n \n-fn path_name(&vec[str] path) -> str {\n-    ret str::connect(path, sep());\n-}\n-\n-\n fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n     auto hash = \"\";\n     alt (ccx.type_sha1s.find(t)) {\n@@ -336,15 +328,31 @@ fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n \n             ccx.sha.input_str(metadata::Encode::ty_str(cx, t));\n             hash = str::substr(ccx.sha.result_str(), 0u, 16u);\n+            // Prefix with _ so that it never blends into adjacent digits\n+            hash = \"_\" + hash;\n             ccx.type_sha1s.insert(t, hash);\n         }\n     }\n     ret hash;\n }\n \n+fn mangle(&vec[str] ss) -> str {\n+\n+    // Follow C++ namespace-mangling style\n+\n+    auto n = \"_ZN\"; // Begin name-sequence.\n+\n+    for (str s in ss) {\n+        n += #fmt(\"%u%s\", str::byte_len(s), s);\n+    }\n+\n+    n += \"E\"; // End name-sequence.\n+    ret n;\n+}\n+\n fn mangle_name_by_type(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n     auto hash = get_type_sha1(ccx, t);\n-    ret sep() + \"rust\" + sep() + hash + sep() + path_name(path);\n+    ret mangle(path + [hash]);\n }\n \n fn mangle_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) -> str {\n@@ -353,14 +361,20 @@ fn mangle_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) -> str {\n     auto s = ty::ty_to_short_str(ccx.tcx, t);\n \n     auto hash = get_type_sha1(ccx, t);\n-    ret sep() + \"rust\" + sep() + hash + sep() + name + \"_\" + s;\n+    ret mangle([name, s, hash]);\n+}\n+\n+fn mangle_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n+                               &str flav) -> str {\n+    ret mangle(path + [ccx.names.next(flav)]);\n+}\n+\n+fn mangle_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n+    ret mangle(path);\n }\n \n-fn mangle_name_by_seq(&@crate_ctxt ccx, &vec[str] path,\n-                      &str flav) -> str {\n-    ret sep() + \"rust\" + sep()\n-        + ccx.names.next(flav) + sep()\n-        + path_name(path);\n+fn mangle_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n+    ret ccx.names.next(flav);\n }\n \n fn res(@block_ctxt bcx, ValueRef val) -> result {\n@@ -1903,7 +1917,7 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t,\n         name = mangle_name_by_type_only(cx.ccx, t, \"tydesc\");\n         name = sanitize(name);\n     } else {\n-        name = mangle_name_by_seq(cx.ccx, cx.path, \"tydesc\");\n+        name = mangle_name_by_seq(cx.ccx, \"tydesc\");\n     }\n \n     auto gvar = llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n@@ -1937,7 +1951,7 @@ fn declare_generic_glue(&@local_ctxt cx,\n         fn_nm = mangle_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n     } else {\n-        fn_nm = mangle_name_by_seq(cx.ccx, cx.path,  \"glue_\" + name);\n+        fn_nm = mangle_name_by_seq(cx.ccx,  \"glue_\" + name);\n     }\n     auto llfn = decl_fastcall_fn(cx.ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(cx, llfn, t);\n@@ -4093,7 +4107,7 @@ fn trans_for_each(&@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s = mangle_name_by_seq(lcx.ccx, lcx.path, \"foreach\");\n+    let str s = mangle_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n@@ -4792,7 +4806,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty:\n \n-    let str s = mangle_name_by_seq(cx.ccx, cx.path, \"thunk\");\n+    let str s = mangle_name_by_path_and_seq(cx.ccx, cx.path, \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, sp,\n                                                     incoming_fty));\n     let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n@@ -6225,9 +6239,10 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n                    0u);\n \n     // TODO: construct a name based on tname\n-    let str wrap_name = mangle_name_by_seq(cx.fcx.lcx.ccx,\n-                                           [\"\"],\n-                                           \"spawn_wrapper\");\n+    let str wrap_name =\n+        mangle_name_by_path_and_seq(cx.fcx.lcx.ccx,\n+                                    cx.fcx.lcx.path,\n+                                    \"spawn_wrapper\");\n     auto llfndecl = decl_fastcall_fn(llmod, wrap_name,\n                                      wrapper_fn_type);\n \n@@ -7078,8 +7093,9 @@ fn create_vtbl(@local_ctxt cx,\n             }\n         }\n \n-        let @local_ctxt mcx = extend_path(cx, m.node.ident);\n-        let str s = mangle_name_by_seq(mcx.ccx, mcx.path, \"method\");\n+        let @local_ctxt mcx = @rec(path = cx.path + [\"method\",\n+                                                     m.node.ident] with *cx);\n+        let str s = mangle_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n                                                       llfnty);\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n@@ -7091,7 +7107,7 @@ fn create_vtbl(@local_ctxt cx,\n         methods += [llfn];\n     }\n     auto vtbl = C_struct(methods);\n-    auto vtbl_name = mangle_name_by_seq(cx.ccx, cx.path, \"vtbl\");\n+    auto vtbl_name = mangle_name_by_path(cx.ccx, cx.path + [\"vtbl\"]);\n     auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -7108,13 +7124,12 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast::method dtor) -> ValueRef {\n \n     auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n-    let @local_ctxt dcx = extend_path(cx, \"drop\");\n-    let str s = mangle_name_by_seq(dcx.ccx, dcx.path, \"drop\");\n+    let str s = mangle_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n \n-    trans_fn(dcx, dtor.span, dtor.node.meth, dtor.node.id,\n+    trans_fn(cx, dtor.span, dtor.node.meth, dtor.node.id,\n              some[ty_self_pair](tup(llself_ty, self_ty)),\n              ty_params, dtor.node.ann);\n \n@@ -7503,13 +7518,22 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n     }\n \n     // Declare the function itself.\n-    let str s = mangle_name_by_seq(ccx, path, flav);\n+    let str s = mangle_name_by_path(ccx, path);\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n     let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n \n     register_fn_pair(ccx, ps, llpairty, llfn, id);\n+\n+    if (str::eq(vec::top(path), \"main\") &&\n+        !ccx.sess.get_opts().shared) {\n+        if (ccx.main_fn != none[ValueRef]) {\n+            ccx.sess.span_err(sp, \"multiple 'main' functions\");\n+        }\n+        log #fmt(\"registering %s as main function for crate\", ps);\n+        ccx.main_fn = some(llfn);\n+    }\n }\n \n fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n@@ -7569,7 +7593,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let str s = mangle_name_by_seq(ccx, path, \"wrapper\");\n+    let str s = mangle_name_by_path(ccx, path);\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n \n@@ -7912,9 +7936,8 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n \n                 auto discrim_val = C_int(i as int);\n \n-                auto s = mangle_name_by_seq(ccx, wcx.path,\n-                                            #fmt(\"_rust_tag_discrim_%s_%u\",\n-                                                 ident, i));\n+                auto p = wcx.path + [ident, variant.node.name, \"discrim\"];\n+                auto s = mangle_name_by_type(ccx, p, ty::mk_int(ccx.tcx));\n                 auto discrim_gvar = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n                                                        str::buf(s));\n \n@@ -7973,29 +7996,6 @@ fn create_typedefs(&@crate_ctxt cx) {\n     llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn find_main_fn(&@crate_ctxt cx) -> ValueRef {\n-    auto e = sep() + \"main\";\n-    let ValueRef v = C_nil();\n-    let uint n = 0u;\n-    for each (@tup(ast::def_id, str) i in cx.item_symbols.items()) {\n-        if (str::ends_with(i._1, e)) {\n-            n += 1u;\n-            v = cx.item_ids.get(i._0);\n-        }\n-    }\n-    alt (n) {\n-        case (0u) {\n-            cx.sess.err(\"main fn not found\");\n-        }\n-        case (1u) {\n-            ret v;\n-        }\n-        case (_) {\n-            cx.sess.err(\"multiple main fns found\");\n-        }\n-    }\n-}\n-\n fn trans_main_fn(@local_ctxt cx, ValueRef crate_map) {\n     auto T_main_args = [T_int(), T_int()];\n     auto T_rust_start_args = [T_int(), T_int(), T_int(), T_int()];\n@@ -8015,7 +8015,14 @@ fn trans_main_fn(@local_ctxt cx, ValueRef crate_map) {\n \n     auto llargc = llvm::LLVMGetParam(llmain, 0u);\n     auto llargv = llvm::LLVMGetParam(llmain, 1u);\n-    auto llrust_main = find_main_fn(cx.ccx);\n+    auto llrust_main = alt (cx.ccx.main_fn) {\n+        case (none) {\n+            cx.ccx.sess.err(\"missing 'main' function\");\n+            // FIXME: shouldn't sess.err's ! result unify with f?\n+            C_nil()\n+        }\n+        case (some(?f)) { f }\n+    };\n \n     //\n     // Emit the moral equivalent of:\n@@ -8283,6 +8290,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n                     items = new_def_hash[@ast::item](),\n                     native_items = new_def_hash[@ast::native_item](),\n                     item_symbols = new_def_hash[str](),\n+                    mutable main_fn = none[ValueRef],\n                     tag_sizes = tag_sizes,\n                     discrims = new_def_hash[ValueRef](),\n                     discrim_symbols = new_def_hash[str](),"}, {"sha": "374b55ed9be363cafcb198ea8db3f159acb3de05", "filename": "src/lib/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/319156c8d10e34dc9e8f3d243be45595fb55b9fd/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/319156c8d10e34dc9e8f3d243be45595fb55b9fd/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=319156c8d10e34dc9e8f3d243be45595fb55b9fd", "patch": "@@ -193,6 +193,12 @@ fn pop[T](&mutable array[T] v) -> T {\n     ret e;\n }\n \n+fn top[T](&array[T] v) -> T {\n+    auto ln = len[T](v);\n+    assert (ln > 0u);\n+    ret v.(ln-1u);\n+}\n+\n fn push[T](&mutable array[T] v, &T t) {\n     v += [t];\n }"}]}