{"sha": "38995c902929500e567fe9dce09f62dbc8bfc2a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTk1YzkwMjkyOTUwMGU1NjdmZTlkY2UwOWY2MmRiYzhiZmMyYTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-21T12:30:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:59:33Z"}, "message": "consult cache in projection", "tree": {"sha": "d4f5a3778fc187dc76be9ae578fc1f231c02affb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4f5a3778fc187dc76be9ae578fc1f231c02affb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38995c902929500e567fe9dce09f62dbc8bfc2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38995c902929500e567fe9dce09f62dbc8bfc2a0", "html_url": "https://github.com/rust-lang/rust/commit/38995c902929500e567fe9dce09f62dbc8bfc2a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38995c902929500e567fe9dce09f62dbc8bfc2a0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6751d68f25e94712ead456e3bc656b2d63bd8beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6751d68f25e94712ead456e3bc656b2d63bd8beb", "html_url": "https://github.com/rust-lang/rust/commit/6751d68f25e94712ead456e3bc656b2d63bd8beb"}], "stats": {"total": 97, "additions": 89, "deletions": 8}, "files": [{"sha": "61ea5eab7eb61b8dbecf4f22df59d4883b98b41f", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/38995c902929500e567fe9dce09f62dbc8bfc2a0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38995c902929500e567fe9dce09f62dbc8bfc2a0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=38995c902929500e567fe9dce09f62dbc8bfc2a0", "patch": "@@ -424,6 +424,79 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n            projection_ty,\n            depth);\n \n+    // FIXME(#20304) For now, I am caching here, which is good, but it\n+    // means we don't capture the type variables that are created in\n+    // the case of ambiguity. Which means we may create a large stream\n+    // of such variables. OTOH, if we move the caching up a level, we\n+    // would not benefit from caching when proving `T: Trait<U=Foo>`\n+    // bounds. It might be the case that we want two distinct caches,\n+    // or else another kind of cache entry.\n+\n+    match infcx.projection_cache.borrow_mut().try_start(projection_ty) {\n+        Ok(()) => { }\n+        Err(ProjectionCacheEntry::Ambiguous) => {\n+            // If we found ambiguity the last time, that generally\n+            // means we will continue to do so until some type in the\n+            // key changes (and we know it hasn't, because we just\n+            // fully resolved it). One exception though is closure\n+            // types, which can transition from having a fixed kind to\n+            // no kind with no visible change in the key.\n+            //\n+            // FIXME(#32286) refactor this so that closure type\n+            // changes\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found cache entry: ambiguous\");\n+            if !projection_ty.has_closure_types() {\n+                return None;\n+            }\n+        }\n+        Err(ProjectionCacheEntry::InProgress) => {\n+            // If while normalized A::B, we are asked to normalize\n+            // A::B, just return A::B itself. This is a conservative\n+            // answer, in the sense that A::B *is* clearly equivalent\n+            // to A::B, though there may be a better value we can\n+            // find.\n+\n+            // Under lazy normalization, this can arise when\n+            // bootstrapping.  That is, imagine an environment with a\n+            // where-clause like `A::B == u32`. Now, if we are asked\n+            // to normalize `A::B`, we will want to check the\n+            // where-clauses in scope. So we will try to unify `A::B`\n+            // with `A::B`, which can trigger a recursive\n+            // normalization. In that case, I think we will want this code:\n+            //\n+            // ```\n+            // let ty = selcx.tcx().mk_projection(projection_ty.trait_ref,\n+            //                                    projection_ty.item_name);\n+            // return Some(NormalizedTy { value: v, obligations: vec![] });\n+            // ```\n+\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found cache entry: in-progress\");\n+\n+            // But for now, let's classify this as an overflow:\n+            let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+            let obligation = Obligation::with_depth(cause.clone(),\n+                                                    recursion_limit,\n+                                                    projection_ty);\n+            selcx.infcx().report_overflow_error(&obligation, false);\n+        }\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // If we find the value in the cache, then the obligations\n+            // have already been returned from the previous entry (and\n+            // should therefore have been honored).\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found normalized ty `{:?}`\",\n+                   ty);\n+            return Some(NormalizedTy { value: ty, obligations: vec![] });\n+        }\n+        Err(ProjectionCacheEntry::Error) => {\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found error\");\n+            return Some(normalize_to_error(selcx, projection_ty, cause, depth));\n+        }\n+    }\n+\n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n     match project_type(selcx, &obligation) {\n         Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n@@ -454,31 +527,37 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                        depth);\n \n                 obligations.extend(normalizer.obligations);\n-                Some(Normalized {\n+                Normalized {\n                     value: normalized_ty,\n                     obligations: obligations,\n-                })\n+                }\n             } else {\n-                Some(Normalized {\n+                Normalized {\n                     value: projected_ty,\n                     obligations: obligations,\n-                })\n+                }\n             };\n-\n-            result\n+            infcx.projection_cache.borrow_mut()\n+                                  .complete(projection_ty, &result, cacheable);\n+            Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} no progress\",\n                    projected_ty);\n-            Some(Normalized {\n+            let result = Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n-            })\n+            };\n+            infcx.projection_cache.borrow_mut()\n+                                  .complete(projection_ty, &result, true);\n+            Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     too many candidates\");\n+            infcx.projection_cache.borrow_mut()\n+                                  .ambiguous(projection_ty);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -488,6 +567,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n+            infcx.projection_cache.borrow_mut()\n+                                  .error(projection_ty);\n             Some(normalize_to_error(selcx, projection_ty, cause, depth))\n         }\n     }"}]}