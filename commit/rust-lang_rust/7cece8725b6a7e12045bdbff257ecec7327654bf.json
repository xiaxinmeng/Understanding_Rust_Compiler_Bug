{"sha": "7cece8725b6a7e12045bdbff257ecec7327654bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZWNlODcyNWI2YTdlMTIwNDViZGJmZjI1N2VjZWM3MzI3NjU0YmY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-13T15:30:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-21T14:27:26Z"}, "message": "syntax: fix fallout of merging ast::ViewItem into ast::Item.", "tree": {"sha": "1df923982bcf420b67ad7c9c6f4684b652935d83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1df923982bcf420b67ad7c9c6f4684b652935d83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cece8725b6a7e12045bdbff257ecec7327654bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cece8725b6a7e12045bdbff257ecec7327654bf", "html_url": "https://github.com/rust-lang/rust/commit/7cece8725b6a7e12045bdbff257ecec7327654bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cece8725b6a7e12045bdbff257ecec7327654bf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ac9e3984392ab11e33b77d5e1927c1fa17fb07", "html_url": "https://github.com/rust-lang/rust/commit/38ac9e3984392ab11e33b77d5e1927c1fa17fb07"}], "stats": {"total": 620, "additions": 202, "deletions": 418}, "files": [{"sha": "2d710e636d82b9f1033ca63f6557c7753c36991a", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -107,7 +107,6 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n #[derive(Copy, Show)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n-    NodeViewItem(&'ast ViewItem),\n     NodeForeignItem(&'ast ForeignItem),\n     NodeTraitItem(&'ast TraitItem),\n     NodeImplItem(&'ast ImplItem),\n@@ -134,7 +133,6 @@ enum MapEntry<'ast> {\n \n     /// All the node types, with a parent ID.\n     EntryItem(NodeId, &'ast Item),\n-    EntryViewItem(NodeId, &'ast ViewItem),\n     EntryForeignItem(NodeId, &'ast ForeignItem),\n     EntryTraitItem(NodeId, &'ast TraitItem),\n     EntryImplItem(NodeId, &'ast ImplItem),\n@@ -169,7 +167,6 @@ impl<'ast> MapEntry<'ast> {\n     fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n             NodeItem(n) => EntryItem(p, n),\n-            NodeViewItem(n) => EntryViewItem(p, n),\n             NodeForeignItem(n) => EntryForeignItem(p, n),\n             NodeTraitItem(n) => EntryTraitItem(p, n),\n             NodeImplItem(n) => EntryImplItem(p, n),\n@@ -188,7 +185,6 @@ impl<'ast> MapEntry<'ast> {\n     fn parent(self) -> Option<NodeId> {\n         Some(match self {\n             EntryItem(id, _) => id,\n-            EntryViewItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n             EntryTraitItem(id, _) => id,\n             EntryImplItem(id, _) => id,\n@@ -208,7 +204,6 @@ impl<'ast> MapEntry<'ast> {\n     fn to_node(self) -> Option<Node<'ast>> {\n         Some(match self {\n             EntryItem(_, n) => NodeItem(n),\n-            EntryViewItem(_, n) => NodeViewItem(n),\n             EntryForeignItem(_, n) => NodeForeignItem(n),\n             EntryTraitItem(_, n) => NodeTraitItem(n),\n             EntryImplItem(_, n) => NodeImplItem(n),\n@@ -341,13 +336,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_view_item(&self, id: NodeId) -> &'ast ViewItem {\n-        match self.find(id) {\n-            Some(NodeViewItem(view_item)) => view_item,\n-            _ => panic!(\"expected view item, found {}\", self.node_to_string(id))\n-        }\n-    }\n-\n     pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n@@ -533,7 +521,6 @@ impl<'ast> Map<'ast> {\n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n-            Some(NodeViewItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n             Some(NodeTraitItem(trait_method)) => {\n                 match *trait_method {\n@@ -826,11 +813,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = parent;\n     }\n \n-    fn visit_view_item(&mut self, item: &'ast ViewItem) {\n-        self.insert(item.id(), NodeViewItem(item));\n-        visit::walk_view_item(self, item);\n-    }\n-\n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n@@ -904,7 +886,6 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n     let krate = mem::replace(&mut forest.krate, Crate {\n         module: Mod {\n             inner: DUMMY_SP,\n-            view_items: vec![],\n             items: vec![],\n         },\n         attrs: vec![],\n@@ -1036,7 +1017,6 @@ impl<'a> NodePrinter for pprust::State<'a> {\n     fn print_node(&mut self, node: &Node) -> IoResult<()> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n-            NodeViewItem(a)    => self.print_view_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n             NodeTraitItem(a)   => self.print_trait_method(&*a),\n             NodeImplItem(a)    => self.print_impl_item(&*a),\n@@ -1065,6 +1045,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             let item_str = match item.node {\n+                ItemExternCrate(..) => \"extern crate\",\n+                ItemUse(..) => \"use\",\n                 ItemStatic(..) => \"static\",\n                 ItemConst(..) => \"const\",\n                 ItemFn(..) => \"fn\",\n@@ -1079,9 +1061,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n-        Some(NodeViewItem(item)) => {\n-            format!(\"view item {}{}\", pprust::view_item_to_string(&*item), id_str)\n-        }\n         Some(NodeForeignItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {}{}\", path_str, id_str)"}, {"sha": "192af7bb789b9ff4a62011d0798aa7d5c827db2f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 65, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -410,37 +410,6 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_mod(self, module)\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return;\n-            } else {\n-                self.visited_outermost = true;\n-            }\n-        }\n-        match view_item.node {\n-            ViewItemExternCrate(_, _, node_id) => {\n-                self.operation.visit_id(node_id)\n-            }\n-            ViewItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _, node_id) |\n-                    ViewPathGlob(_, node_id) => {\n-                        self.operation.visit_id(node_id)\n-                    }\n-                    ViewPathList(_, ref paths, node_id) => {\n-                        self.operation.visit_id(node_id);\n-                        for path in paths.iter() {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, view_item);\n-        self.visited_outermost = false;\n-    }\n-\n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item)\n@@ -456,10 +425,24 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n \n         self.operation.visit_id(item.id);\n-        if let ItemEnum(ref enum_definition, _) = item.node {\n-            for variant in enum_definition.variants.iter() {\n-                self.operation.visit_id(variant.node.id)\n+        match item.node {\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathSimple(_, _) |\n+                    ViewPathGlob(_) => {}\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths.iter() {\n+                            self.operation.visit_id(path.node.id())\n+                        }\n+                    }\n+                }\n+            }\n+            ItemEnum(ref enum_definition, _) => {\n+                for variant in enum_definition.variants.iter() {\n+                    self.operation.visit_id(variant.node.id)\n+                }\n             }\n+            _ => {}\n         }\n \n         visit::walk_item(self, item);\n@@ -662,37 +645,6 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n     walk_pat_(pat, &mut it)\n }\n \n-pub trait EachViewItem {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool;\n-}\n-\n-struct EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    callback: F,\n-}\n-\n-impl<'v, F> Visitor<'v> for EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n-        let _ = (self.callback)(view_item);\n-    }\n-}\n-\n-impl EachViewItem for ast::Crate {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool {\n-        let mut visit = EachViewItemData {\n-            callback: f,\n-        };\n-        visit::walk_crate(&mut visit, self);\n-        true\n-    }\n-}\n-\n-pub fn view_path_id(p: &ViewPath) -> NodeId {\n-    match p.node {\n-        ViewPathSimple(_, _, id) | ViewPathGlob(_, id)\n-        | ViewPathList(_, _, id) => id\n-    }\n-}\n-\n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {"}, {"sha": "3eaac0fe333e8e3026f69abd6ca6b0f7d8f52653", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -63,28 +63,13 @@ pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<F>(cx: &mut Context<F>,\n-                       view_item: ast::ViewItem)\n-                       -> Option<ast::ViewItem> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if view_item_in_cfg(cx, &view_item) {\n-        Some(view_item)\n-    } else {\n-        None\n-    }\n-}\n-\n fn fold_mod<F>(cx: &mut Context<F>,\n-               ast::Mod {inner,\n-               view_items, items}: ast::Mod) -> ast::Mod where\n+               ast::Mod {inner, items}: ast::Mod)\n+               -> ast::Mod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::Mod {\n         inner: inner,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter().flat_map(|a| {\n             cx.fold_item(a).into_iter()\n         }).collect()\n@@ -104,15 +89,12 @@ fn filter_foreign_item<F>(cx: &mut Context<F>,\n }\n \n fn fold_foreign_mod<F>(cx: &mut Context<F>,\n-                       ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                       ast::ForeignMod {abi, items}: ast::ForeignMod)\n                        -> ast::ForeignMod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::ForeignMod {\n         abi: abi,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter()\n                     .filter_map(|a| filter_foreign_item(cx, a))\n                     .collect()\n@@ -216,18 +198,14 @@ fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n+    b.map(|ast::Block {id, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n             stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n         let resulting_stmts = resulting_stmts.into_iter()\n             .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n-        let filtered_view_items = view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect();\n         ast::Block {\n             id: id,\n-            view_items: filtered_view_items,\n             stmts: resulting_stmts,\n             expr: expr.map(|x| cx.fold_expr(x)),\n             rules: rules,\n@@ -267,12 +245,6 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ViewItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(item.attrs.as_slice());\n-}\n-\n fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {"}, {"sha": "2adf0f1a1a2e0d3c3c382aa1b83b26b8b1a4deae", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -97,7 +97,6 @@ pub trait AstBuilder {\n              expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n@@ -242,7 +241,7 @@ pub trait AstBuilder {\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n-                vi: Vec<ast::ViewItem> , items: Vec<P<ast::Item>> ) -> P<ast::Item>;\n+                items: Vec<P<ast::Item>>) -> P<ast::Item>;\n \n     fn item_static(&self,\n                    span: Span,\n@@ -280,15 +279,15 @@ pub trait AstBuilder {\n                        value: ast::Lit_)\n                        -> P<ast::MetaItem>;\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem;\n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem;\n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem;\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item>;\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item>;\n }\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n@@ -519,7 +518,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n              expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, Vec::new(), stmts, expr)\n+        self.block_all(span, stmts, expr)\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n@@ -528,15 +527,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n+        self.block_all(expr.span, Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-               view_items: view_items,\n                stmts: stmts,\n                expr: expr,\n                id: ast::DUMMY_NODE_ID,\n@@ -1031,16 +1028,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute> ,\n-                vi: Vec<ast::ViewItem> ,\n-                items: Vec<P<ast::Item>> ) -> P<ast::Item> {\n+                attrs: Vec<ast::Attribute>,\n+                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n         self.item(\n             span,\n             name,\n             attrs,\n             ast::ItemMod(ast::Mod {\n                 inner: inner_span,\n-                view_items: vi,\n                 items: items,\n             })\n         )\n@@ -1101,47 +1096,47 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n     }\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem {\n-        ast::ViewItem {\n-            node: ast::ViewItemUse(vp),\n-            attrs: Vec::new(),\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n+        P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: special_idents::invalid,\n+            attrs: vec![],\n+            node: ast::ItemUse(vp),\n             vis: vis,\n             span: sp\n-        }\n+        })\n     }\n \n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem {\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n         let last = path.segments.last().unwrap().identifier;\n-        self.view_use_simple_(sp, vis, last, path)\n+        self.item_use_simple_(sp, vis, last, path)\n     }\n \n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathSimple(ident,\n-                                                   path,\n-                                                   ast::DUMMY_NODE_ID))))\n+                                                   path))))\n     }\n \n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n             respan(sp, ast::PathListIdent { name: *id, id: ast::DUMMY_NODE_ID })\n         }).collect();\n \n-        self.view_use(sp, vis,\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathList(self.path(sp, path),\n-                                                 imports,\n-                                                 ast::DUMMY_NODE_ID))))\n+                                                 imports))))\n     }\n \n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n-                               ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n+                               ast::ViewPathGlob(self.path(sp, path)))))\n     }\n }"}, {"sha": "73d002172a98019ff5ae52d11eb4a7c878eb701a", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -1073,7 +1073,7 @@ impl<'a> MethodDef<'a> {\n             //   <delegated expression referring to __self0_vi, et al.>\n             // }\n             let arm_expr = cx.expr_block(\n-                cx.block_all(sp, Vec::new(), index_let_stmts, Some(arm_expr)));\n+                cx.block_all(sp, index_let_stmts, Some(arm_expr)));\n \n             // Builds arm:\n             // _ => { let __self0_vi = ...;"}, {"sha": "2aa5f72c0c408ee85c9694d087b8438b685f9feb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -206,7 +206,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                     // wrap the if-let expr in a block\n                     let span = els.span;\n                     let blk = P(ast::Block {\n-                        view_items: vec![],\n                         stmts: vec![],\n                         expr: Some(P(els)),\n                         id: ast::DUMMY_NODE_ID,\n@@ -799,8 +798,7 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n-        let new_view_items = view_items.into_iter().map(|x| fld.fold_view_item(x)).collect();\n+    b.map(|Block {id, stmts, expr, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n@@ -821,7 +819,6 @@ pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n         });\n         Block {\n             id: fld.new_id(id),\n-            view_items: new_view_items,\n             stmts: new_stmts,\n             expr: new_expr,\n             rules: rules,"}, {"sha": "e63a920994b75a13a839a5e69c798d5c64a59341", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -352,18 +352,11 @@ pub mod rt {\n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n         fn parse_item(&self, s: String) -> P<ast::Item> {\n-            let res = parse::parse_item_from_source_str(\n+            parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n                 self.cfg(),\n-                self.parse_sess());\n-            match res {\n-                Some(ast) => ast,\n-                None => {\n-                    error!(\"parse error\");\n-                    panic!()\n-                }\n-            }\n+                self.parse_sess()).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n@@ -767,7 +760,6 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     vector.extend(mk_tts(cx, &tts[]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n-                     Vec::new(),\n                      vector,\n                      Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n \n@@ -778,18 +770,18 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: P<ast::Expr>,\n                   expr: P<ast::Expr>) -> P<ast::Expr> {\n-    let uses = [\n-        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n-    ].iter().map(|path| {\n-        let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.view_use_glob(sp, ast::Inherited, ids_ext(path))\n-    }).collect();\n-\n     // Explicitly borrow to avoid moving from the invoker (#16992)\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n+    let stmts = [\n+        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n+    ].iter().map(|path| {\n+        let path = path.iter().map(|s| s.to_string()).collect();\n+        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n+    }).chain(Some(stmt_let_ext_cx).into_iter()).collect();\n+\n+    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "762a1dcbfc34b7323e3b0fe5ba2b9b26efaeb0c3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -226,22 +226,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.node {\n-            ast::ViewItemUse(..) => {}\n-            ast::ViewItemExternCrate(..) => {\n-                for attr in i.attrs.iter() {\n-                    if attr.check_name(\"plugin\") {\n-                        self.gate_feature(\"plugin\", attr.span,\n-                                          \"compiler plugins are experimental \\\n-                                           and possibly buggy\");\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i)\n-    }\n-\n     fn visit_item(&mut self, i: &ast::Item) {\n         for attr in i.attrs.iter() {\n             if attr.name() == \"thread_local\" {\n@@ -260,6 +244,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n         }\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if attr::contains_name(&i.attrs[], \"plugin\") {\n+                    self.gate_feature(\"plugin\", i.span,\n+                                      \"compiler plugins are experimental \\\n+                                       and possibly buggy\");\n+                }\n+            }\n+\n             ast::ItemForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,"}, {"sha": "44ee17a0d9670e500c4f28c1f4ba04789661e4db", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -78,10 +78,6 @@ pub trait Folder : Sized {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: ViewItem) -> ViewItem {\n-        noop_fold_view_item(vi, self)\n-    }\n-\n     fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n         noop_fold_foreign_item(ni, self)\n     }\n@@ -349,16 +345,13 @@ pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T\n pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n     view_path.map(|Spanned {node, span}| Spanned {\n         node: match node {\n-            ViewPathSimple(ident, path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathSimple(ident, fld.fold_path(path), id)\n+            ViewPathSimple(ident, path) => {\n+                ViewPathSimple(ident, fld.fold_path(path))\n             }\n-            ViewPathGlob(path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathGlob(fld.fold_path(path), id)\n+            ViewPathGlob(path) => {\n+                ViewPathGlob(fld.fold_path(path))\n             }\n-            ViewPathList(path, path_list_idents, node_id) => {\n-                let id = fld.new_id(node_id);\n+            ViewPathList(path, path_list_idents) => {\n                 ViewPathList(fld.fold_path(path),\n                              path_list_idents.move_map(|path_list_ident| {\n                                 Spanned {\n@@ -373,8 +366,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                                     },\n                                     span: fld.new_span(path_list_ident.span)\n                                 }\n-                             }),\n-                             id)\n+                             }))\n             }\n         },\n         span: fld.new_span(span)\n@@ -470,11 +462,10 @@ pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n         abi: abi,\n-        view_items: view_items.move_map(|x| fld.fold_view_item(x)),\n         items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n@@ -953,28 +944,9 @@ fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mu\n     }\n }\n \n-pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewItem,\n-                                      folder: &mut T) -> ViewItem {\n-    ViewItem {\n-        node: match node {\n-            ViewItemExternCrate(ident, string, node_id) => {\n-                ViewItemExternCrate(ident, string,\n-                                    folder.new_id(node_id))\n-            }\n-            ViewItemUse(view_path) => {\n-                ViewItemUse(folder.fold_view_path(view_path))\n-            }\n-        },\n-        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n-        vis: vis,\n-        span: folder.new_span(span)\n-    }\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n         expr: expr.map(|x| folder.fold_expr(x)),\n         rules: rules,\n@@ -984,6 +956,10 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n \n pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n     match i {\n+        ItemExternCrate(string) => ItemExternCrate(string),\n+        ItemUse(view_path) => {\n+            ItemUse(folder.fold_view_path(view_path))\n+        }\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n@@ -1103,10 +1079,9 @@ pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMetho\n     }\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n     }\n }\n@@ -1137,9 +1112,8 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         }\n         None => (ast::Mod {\n             inner: span,\n-            view_items: Vec::new(),\n-            items: Vec::new(),\n-        }, Vec::new(), span)\n+            items: vec![],\n+        }, vec![], span)\n     };\n \n     for def in exported_macros.iter_mut() {"}, {"sha": "49dca01ef501286e77d103460497dbd56f297cf1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -757,11 +757,10 @@ mod test {\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n-    use print::pprust::view_item_to_string;\n+    use print::pprust::item_to_string;\n     use ptr::P;\n     use util::parser_testing::{string_to_tts, string_to_parser};\n-    use util::parser_testing::{string_to_expr, string_to_item};\n-    use util::parser_testing::{string_to_stmt, string_to_view_item};\n+    use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n \n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n@@ -1079,7 +1078,6 @@ mod test {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        view_items: Vec::new(),\n                                         stmts: vec!(P(Spanned{\n                                             node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n@@ -1111,25 +1109,25 @@ mod test {\n \n     #[test] fn parse_use() {\n         let use_s = \"use foo::bar::baz;\";\n-        let vitem = string_to_view_item(use_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(use_s.to_string());\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n-        let vitem = string_to_view_item(use_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(use_s.to_string());\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n-        let vitem = string_to_view_item(ex_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(ex_s.to_string());\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[], ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n-        let vitem = string_to_view_item(ex_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(ex_s.to_string());\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[], ex_s);\n     }\n "}, {"sha": "19499db28628b7f12a97c3e964b06f3252f9b01c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -337,10 +337,6 @@ pub fn item_to_string(i: &ast::Item) -> String {\n     $to_string(|s| s.print_item(i))\n }\n \n-pub fn view_item_to_string(i: &ast::ViewItem) -> String {\n-    $to_string(|s| s.print_view_item(i))\n-}\n-\n pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n@@ -638,9 +634,6 @@ impl<'a> State<'a> {\n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for vitem in _mod.view_items.iter() {\n-            try!(self.print_view_item(vitem));\n-        }\n         for item in _mod.items.iter() {\n             try!(self.print_item(&**item));\n         }\n@@ -650,9 +643,6 @@ impl<'a> State<'a> {\n     pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n                              attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for vitem in nmod.view_items.iter() {\n-            try!(self.print_view_item(vitem));\n-        }\n         for item in nmod.items.iter() {\n             try!(self.print_foreign_item(&**item));\n         }\n@@ -809,6 +799,28 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs[]));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n+            ast::ItemExternCrate(ref optional_path) => {\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                     \"extern crate\")[]));\n+                for &(ref p, style) in optional_path.iter() {\n+                    try!(self.print_string(p.get(), style));\n+                    try!(space(&mut self.s));\n+                    try!(word(&mut self.s, \"as\"));\n+                    try!(space(&mut self.s));\n+                }\n+                try!(self.print_ident(item.ident));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end inner head-block\n+                try!(self.end()); // end outer head-block\n+            }\n+            ast::ItemUse(ref vp) => {\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                     \"use\")[]));\n+                try!(self.print_view_path(&**vp));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end inner head-block\n+                try!(self.end()); // end outer head-block\n+            }\n             ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"static\")[]));\n@@ -1380,9 +1392,6 @@ impl<'a> State<'a> {\n \n         try!(self.print_inner_attributes(attrs));\n \n-        for vi in blk.view_items.iter() {\n-            try!(self.print_view_item(vi));\n-        }\n         for st in blk.stmts.iter() {\n             try!(self.print_stmt(&**st));\n         }\n@@ -2577,7 +2586,7 @@ impl<'a> State<'a> {\n \n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> IoResult<()> {\n         match vp.node {\n-            ast::ViewPathSimple(ident, ref path, _) => {\n+            ast::ViewPathSimple(ident, ref path) => {\n                 try!(self.print_path(path, false));\n \n                 // FIXME(#6993) can't compare identifiers directly here\n@@ -2591,12 +2600,12 @@ impl<'a> State<'a> {\n                 Ok(())\n             }\n \n-            ast::ViewPathGlob(ref path, _) => {\n+            ast::ViewPathGlob(ref path) => {\n                 try!(self.print_path(path, false));\n                 word(&mut self.s, \"::*\")\n             }\n \n-            ast::ViewPathList(ref path, ref idents, _) => {\n+            ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n@@ -2618,33 +2627,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_view_item(&mut self, item: &ast::ViewItem) -> IoResult<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(&item.attrs[]));\n-        try!(self.print_visibility(item.vis));\n-        match item.node {\n-            ast::ViewItemExternCrate(id, ref optional_path, _) => {\n-                try!(self.head(\"extern crate\"));\n-                for &(ref p, style) in optional_path.iter() {\n-                    try!(self.print_string(p.get(), style));\n-                    try!(space(&mut self.s));\n-                    try!(word(&mut self.s, \"as\"));\n-                    try!(space(&mut self.s));\n-                }\n-                try!(self.print_ident(id));\n-            }\n-\n-            ast::ViewItemUse(ref vp) => {\n-                try!(self.head(\"use\"));\n-                try!(self.print_view_path(&**vp));\n-            }\n-        }\n-        try!(word(&mut self.s, \";\"));\n-        try!(self.end()); // end inner head-block\n-        self.end() // end outer head-block\n-    }\n-\n     pub fn print_mutability(&mut self,\n                             mutbl: ast::Mutability) -> IoResult<()> {\n         match mutbl {"}, {"sha": "d75fbcf199dbe1d8b187dedf6ff4896ea08f4cb9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -20,8 +20,6 @@ use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n-use std::mem;\n-\n pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>)\n                                -> ast::Crate {\n     if use_std(&krate) {\n@@ -60,20 +58,16 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             None => token::intern_and_get_ident(\"std\"),\n         };\n \n-        let mut vis = vec!(ast::ViewItem {\n-            node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n-                                           Some((actual_crate_name, ast::CookedStr)),\n-                                           ast::DUMMY_NODE_ID),\n+        krate.module.items.insert(0, P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: token::str_to_ident(\"std\"),\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n                         InternedString::new(\"macro_use\")))),\n+            node: ast::ItemExternCrate(Some((actual_crate_name, ast::CookedStr))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        });\n-\n-        // `extern crate` must be precede `use` items\n-        mem::swap(&mut vis, &mut krate.module.view_items);\n-        krate.module.view_items.extend(vis.into_iter());\n+        }));\n \n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n@@ -123,7 +117,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         }\n     }\n \n-    fn fold_mod(&mut self, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, mut mod_: ast::Mod) -> ast::Mod {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n@@ -143,18 +137,11 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             ],\n         };\n \n-        let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {\n-            match x.node {\n-                ast::ViewItemExternCrate(..) => true,\n-                _ => false,\n-            }\n-        });\n-\n-        // add prelude after any `extern crate` but before any `use`\n-        let mut view_items = crates;\n-        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID)));\n-        view_items.push(ast::ViewItem {\n-            node: ast::ViewItemUse(vp),\n+        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n+        mod_.items.insert(0, P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: special_idents::invalid,\n+            node: ast::ItemUse(vp),\n             attrs: vec![ast::Attribute {\n                 span: DUMMY_SP,\n                 node: ast::Attribute_ {\n@@ -170,14 +157,9 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             }],\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n-        });\n-        view_items.extend(uses.into_iter());\n-\n-        fold::noop_fold_mod(ast::Mod {\n-            inner: inner,\n-            view_items: view_items,\n-            items: items\n-        }, self)\n+        }));\n+\n+        fold::noop_fold_mod(mod_, self)\n     }\n }\n "}, {"sha": "38aa7b1c76998a987a1576f71b5ae3b2a0bff7b8", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -105,11 +105,11 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n         let (mod_, reexport) = mk_test_module(&mut self.cx);\n-        folded.module.items.push(mod_);\n         match reexport {\n-            Some(re) => folded.module.view_items.push(re),\n+            Some(re) => folded.module.items.push(re),\n             None => {}\n         }\n+        folded.module.items.push(mod_);\n         folded\n     }\n \n@@ -205,22 +205,19 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n                    tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n-    let mut view_items = Vec::new();\n     let super_ = token::str_to_ident(\"super\");\n \n-    view_items.extend(tests.into_iter().map(|r| {\n-        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public,\n+    let items = tests.into_iter().map(|r| {\n+        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Public,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n-    }));\n-    view_items.extend(tested_submods.into_iter().map(|(r, sym)| {\n+    }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.view_use_simple_(DUMMY_SP, ast::Public, r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Public, r, path)\n     }));\n \n     let reexport_mod = ast::Mod {\n         inner: DUMMY_SP,\n-        view_items: view_items,\n-        items: Vec::new(),\n+        items: items.collect(),\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n@@ -388,29 +385,29 @@ mod __test {\n \n */\n \n-fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n+fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = token::str_to_ident(\"test\");\n-    let (vi, vis) = if cx.is_test_crate {\n-        (ast::ViewItemUse(\n+    let (vi, vis, ident) = if cx.is_test_crate {\n+        (ast::ItemUse(\n             P(nospan(ast::ViewPathSimple(id_test,\n-                                         path_node(vec!(id_test)),\n-                                         ast::DUMMY_NODE_ID)))),\n-         ast::Public)\n+                                         path_node(vec!(id_test)))))),\n+         ast::Public, token::special_idents::invalid)\n     } else {\n-        (ast::ViewItemExternCrate(id_test, None, ast::DUMMY_NODE_ID),\n-         ast::Inherited)\n+        (ast::ItemExternCrate(None), ast::Inherited, id_test)\n     };\n-    ast::ViewItem {\n+    P(ast::Item {\n+        id: ast::DUMMY_NODE_ID,\n+        ident: ident,\n         node: vi,\n-        attrs: Vec::new(),\n+        attrs: vec![],\n         vis: vis,\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n-fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n+fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     // Link to test crate\n-    let view_items = vec!(mk_std(cx));\n+    let import = mk_std(cx);\n \n     // A constant vector of test descriptors.\n     let tests = mk_tests(cx);\n@@ -427,8 +424,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n \n     let testmod = ast::Mod {\n         inner: DUMMY_SP,\n-        view_items: view_items,\n-        items: vec!(mainfn, tests),\n+        items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemMod(testmod);\n \n@@ -439,34 +435,35 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n                                            vec![unstable])));\n         attr::mk_attr_inner(attr::mk_attr_id(), allow)\n     };\n-    let item = ast::Item {\n-        ident: mod_ident,\n+    let item = P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n+        ident: mod_ident,\n+        attrs: vec![allow_unstable],\n         node: item_,\n         vis: ast::Public,\n         span: DUMMY_SP,\n-        attrs: vec![allow_unstable],\n-    };\n+    });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n         let reexport_ident = token::str_to_ident(s.get());\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")]),\n-                                       ast::DUMMY_NODE_ID));\n+                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n \n-        ast::ViewItem {\n-            node: ast::ViewItemUse(P(use_path)),\n+        P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: token::special_idents::invalid,\n             attrs: vec![],\n+            node: ast::ItemUse(P(use_path)),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        }\n+        })\n     });\n \n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&*item));\n \n-    (P(item), reexport)\n+    (item, reexport)\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {"}, {"sha": "4a288814b6b836cff97c0ec096309f9ba05eb1f6", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -69,13 +69,6 @@ pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n     })\n }\n \n-/// Parse a string, return a view item\n-pub fn string_to_view_item (source_str : String) -> ast::ViewItem {\n-    with_error_checking_parse(source_str, |p| {\n-        p.parse_view_item(Vec::new())\n-    })\n-}\n-\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {"}, {"sha": "eb906788aa7f4125da1e1fece56bae7a6608a554", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cece8725b6a7e12045bdbff257ecec7327654bf/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7cece8725b6a7e12045bdbff257ecec7327654bf", "patch": "@@ -62,7 +62,6 @@ pub trait Visitor<'v> : Sized {\n         self.visit_name(span, ident.name);\n     }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_view_item(&mut self, i: &'v ViewItem) { walk_view_item(self, i) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n     fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n     fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n@@ -166,51 +165,11 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for view_item in module.view_items.iter() {\n-        visitor.visit_view_item(view_item)\n-    }\n-\n     for item in module.items.iter() {\n         visitor.visit_item(&**item)\n     }\n }\n \n-pub fn walk_view_item<'v, V: Visitor<'v>>(visitor: &mut V, vi: &'v ViewItem) {\n-    match vi.node {\n-        ViewItemExternCrate(name, _, _) => {\n-            visitor.visit_ident(vi.span, name)\n-        }\n-        ViewItemUse(ref vp) => {\n-            match vp.node {\n-                ViewPathSimple(ident, ref path, id) => {\n-                    visitor.visit_ident(vp.span, ident);\n-                    visitor.visit_path(path, id);\n-                }\n-                ViewPathGlob(ref path, id) => {\n-                    visitor.visit_path(path, id);\n-                }\n-                ViewPathList(ref prefix, ref list, _) => {\n-                    for id in list.iter() {\n-                        match id.node {\n-                            PathListIdent { name, .. } => {\n-                                visitor.visit_ident(id.span, name);\n-                            }\n-                            PathListMod { .. } => ()\n-                        }\n-                    }\n-\n-                    // Note that the `prefix` here is not a complete\n-                    // path, so we don't use `visit_path`.\n-                    walk_path(visitor, prefix);\n-                }\n-            }\n-        }\n-    }\n-    for attr in vi.attrs.iter() {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     visitor.visit_pat(&*local.pat);\n     walk_ty_opt(visitor, &local.ty);\n@@ -269,6 +228,32 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n+        ItemExternCrate(..) => {}\n+        ItemUse(ref vp) => {\n+            match vp.node {\n+                ViewPathSimple(ident, ref path) => {\n+                    visitor.visit_ident(vp.span, ident);\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathGlob(ref path) => {\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathList(ref prefix, ref list) => {\n+                    for id in list.iter() {\n+                        match id.node {\n+                            PathListIdent { name, .. } => {\n+                                visitor.visit_ident(id.span, name);\n+                            }\n+                            PathListMod { .. } => ()\n+                        }\n+                    }\n+\n+                    // Note that the `prefix` here is not a complete\n+                    // path, so we don't use `visit_path`.\n+                    walk_path(visitor, prefix);\n+                }\n+            }\n+        }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n             visitor.visit_ty(&**typ);\n@@ -285,9 +270,6 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for view_item in foreign_module.view_items.iter() {\n-                visitor.visit_view_item(view_item)\n-            }\n             for foreign_item in foreign_module.items.iter() {\n                 visitor.visit_foreign_item(&**foreign_item)\n             }\n@@ -732,9 +714,6 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for view_item in block.view_items.iter() {\n-        visitor.visit_view_item(view_item)\n-    }\n     for statement in block.stmts.iter() {\n         visitor.visit_stmt(&**statement)\n     }"}]}