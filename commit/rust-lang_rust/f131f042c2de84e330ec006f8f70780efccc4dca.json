{"sha": "f131f042c2de84e330ec006f8f70780efccc4dca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMzFmMDQyYzJkZTg0ZTMzMGVjMDA2ZjhmNzA3ODBlZmNjYzRkY2E=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-26T21:26:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-26T21:26:36Z"}, "message": "Rollup merge of #59004 - GuillaumeGomez:generics-handling, r=QuietMisdreavus\n\n[rustdoc] Improve \"in parameters\" search and search more generally\n\nFixes #58230.\n\nr? @QuietMisdreavus", "tree": {"sha": "ad89427be4c0567f33f8d509a848985aedbc63ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad89427be4c0567f33f8d509a848985aedbc63ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f131f042c2de84e330ec006f8f70780efccc4dca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmpkNCRBK7hj4Ov3rIwAAdHIIAACtUVIM6vG6MlBRbQ4lVqyu\nnPreETFn6tXB2CkFptTgjGI6IIK82A8Hj3/iem0XOWEZTZpl2/BbTZEe4vprBP4W\nEWO1M26Ld7mljytf+QUDgeM9dnw1SAWmH/hdQqL0TF6+QcJYa1wwcuGWD7dCO8Fl\nFqUjKVmKmskGPuBVdiLFvJ4ByhYMdqLGjfYu3/7msq95tfKcELf8ryMBogE2wUAx\nfpSYj2AHIalzxKJlWT2I6n8k/B38UH6oJVY7h43CqDNBqkG8Pvc2SOaFx7i9x+xn\n0XRpyfamPEkGCfGQyRg8Qw4urRhW1sHxmLAEFB9xM4OBYAUGgogN3bE5gOnqMdo=\n=6RVh\n-----END PGP SIGNATURE-----\n", "payload": "tree ad89427be4c0567f33f8d509a848985aedbc63ec\nparent fbd34efb32b9efb574899e4335bdc8c6525ac27e\nparent befe9cac910f6cf1f98b9c145bcad80be659106a\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1553635596 +0100\ncommitter GitHub <noreply@github.com> 1553635596 +0100\n\nRollup merge of #59004 - GuillaumeGomez:generics-handling, r=QuietMisdreavus\n\n[rustdoc] Improve \"in parameters\" search and search more generally\n\nFixes #58230.\n\nr? @QuietMisdreavus\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f131f042c2de84e330ec006f8f70780efccc4dca", "html_url": "https://github.com/rust-lang/rust/commit/f131f042c2de84e330ec006f8f70780efccc4dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f131f042c2de84e330ec006f8f70780efccc4dca/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd34efb32b9efb574899e4335bdc8c6525ac27e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd34efb32b9efb574899e4335bdc8c6525ac27e", "html_url": "https://github.com/rust-lang/rust/commit/fbd34efb32b9efb574899e4335bdc8c6525ac27e"}, {"sha": "befe9cac910f6cf1f98b9c145bcad80be659106a", "url": "https://api.github.com/repos/rust-lang/rust/commits/befe9cac910f6cf1f98b9c145bcad80be659106a", "html_url": "https://github.com/rust-lang/rust/commit/befe9cac910f6cf1f98b9c145bcad80be659106a"}], "stats": {"total": 348, "additions": 308, "deletions": 40}, "files": [{"sha": "8960c9acafa6e87852041dd26ed4500aad0deefb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -1134,20 +1134,43 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n }\n \n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    checked_type_of(tcx, def_id, true).unwrap()\n+}\n+\n+/// Same as [`type_of`] but returns [`Option`] instead of failing.\n+///\n+/// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n+/// you'd better just call [`type_of`] directly.\n+pub fn checked_type_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    fail: bool,\n+) -> Option<Ty<'tcx>> {\n     use rustc::hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            if !fail {\n+                return None;\n+            }\n+            bug!(\"invalid node\");\n+        }\n+    };\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get_by_hir_id(hir_id) {\n+    Some(match tcx.hir().get_by_hir_id(hir_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n+                if !fail {\n+                    return None;\n+                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1229,6 +1252,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1267,7 +1293,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => {\n             if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n+                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n             }\n \n             let substs = ty::ClosureSubsts {\n@@ -1345,6 +1371,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                             }\n                             // Sanity check to make sure everything is as expected.\n                             if !found_const {\n+                                if !fail {\n+                                    return None;\n+                                }\n                                 bug!(\"no arg matching AnonConst in path\")\n                             }\n                             match path.def {\n@@ -1360,24 +1389,37 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                                     for param in &generics.params {\n                                         if let ty::GenericParamDefKind::Const = param.kind {\n                                             if param_index == arg_index {\n-                                                return tcx.type_of(param.def_id);\n+                                                return Some(tcx.type_of(param.def_id));\n                                             }\n                                             param_index += 1;\n                                         }\n                                     }\n                                     // This is no generic parameter associated with the arg. This is\n                                     // probably from an extra arg where one is not needed.\n-                                    return tcx.types.err;\n+                                    return Some(tcx.types.err);\n                                 }\n                                 Def::Err => tcx.types.err,\n-                                x => bug!(\"unexpected const parent path def {:?}\", x),\n+                                x => {\n+                                    if !fail {\n+                                        return None;\n+                                    }\n+                                    bug!(\"unexpected const parent path def {:?}\", x);\n+                                }\n+                            }\n+                        }\n+                        x => {\n+                            if !fail {\n+                                return None;\n                             }\n+                            bug!(\"unexpected const parent path {:?}\", x);\n                         }\n-                        x => bug!(\"unexpected const parent path {:?}\", x),\n                     }\n                 }\n \n                 x => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n                 }\n             }\n@@ -1388,13 +1430,21 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             hir::GenericParamKind::Const { ref ty, .. } => {\n                 icx.to_ty(ty)\n             }\n-            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+            x => {\n+                if !fail {\n+                    return None;\n+                }\n+                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n+            },\n         },\n \n         x => {\n+            if !fail {\n+                return None;\n+            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    }\n+    })\n }\n \n fn find_existential_constraints<'a, 'tcx>("}, {"sha": "3ddc18284b302a9bc7ef36eda6ddc14096f2d1e6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -115,6 +115,8 @@ use util::common::time;\n \n use std::iter;\n \n+pub use collect::checked_type_of;\n+\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "d9a63969fec972c9eb212979570649c4f852b9c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -210,15 +210,20 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     };\n \n     let predicates = cx.tcx.predicates_of(did);\n+    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n+    let decl = (did, sig).clean(cx);\n+    let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n-        decl: (did, sig).clean(cx),\n-        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n+        decl,\n+        generics,\n         header: hir::FnHeader {\n             unsafety: sig.unsafety(),\n             abi: sig.abi(),\n             constness,\n             asyncness: hir::IsAsync::NotAsync,\n-        }\n+        },\n+        all_types,\n+        ret_types,\n     }\n }\n "}, {"sha": "31f757c87b23e6586c3b9480bea361744eb63670", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 188, "deletions": 7, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -1084,9 +1084,10 @@ impl GenericBound {\n \n     fn get_trait_type(&self) -> Option<Type> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n-            return Some(trait_.clone());\n+            Some(trait_.clone())\n+        } else {\n+            None\n         }\n-        None\n     }\n }\n \n@@ -1325,6 +1326,16 @@ pub enum WherePredicate {\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n+impl WherePredicate {\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match *self {\n+            WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n+            WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl Clean<WherePredicate> for hir::WherePredicate {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n@@ -1461,6 +1472,25 @@ pub enum GenericParamDefKind {\n     },\n }\n \n+impl GenericParamDefKind {\n+    pub fn is_type(&self) -> bool {\n+        match *self {\n+            GenericParamDefKind::Type { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n+        match *self {\n+            GenericParamDefKind::Type { did, .. } => {\n+                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n+            }\n+            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct GenericParamDef {\n     pub name: String,\n@@ -1472,12 +1502,25 @@ impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime |\n-            GenericParamDefKind::Const { .. } => {\n-                false\n-            }\n+            GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n         }\n     }\n+\n+    pub fn is_type(&self) -> bool {\n+        self.kind.is_type()\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n+        self.kind.get_type(cx)\n+    }\n+\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match self.kind {\n+            GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Clean<GenericParamDef> for ty::GenericParamDef {\n@@ -1714,12 +1757,122 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n     }\n }\n \n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+fn get_real_types(\n+    generics: &Generics,\n+    arg: &Type,\n+    cx: &DocContext<'_>,\n+) -> FxHashSet<Type> {\n+    let arg_s = arg.to_string();\n+    let mut res = FxHashSet::default();\n+    if arg.is_full_generic() {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+            match g {\n+                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+                _ => false,\n+            }\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                match *bound {\n+                    GenericBound::TraitBound(ref poly_trait, _) => {\n+                        for x in poly_trait.generic_params.iter() {\n+                            if !x.is_type() {\n+                                continue\n+                            }\n+                            if let Some(ty) = x.get_type(cx) {\n+                                let adds = get_real_types(generics, &ty, cx);\n+                                if !adds.is_empty() {\n+                                    res.extend(adds);\n+                                } else if !ty.is_full_generic() {\n+                                    res.insert(ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| {\n+            g.is_type() && g.name == arg_s\n+        }) {\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, cx);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    } else if !ty.is_full_generic() {\n+                        res.insert(ty.clone());\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        res.insert(arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    let adds = get_real_types(generics, gen, cx);\n+                    if !adds.is_empty() {\n+                        res.extend(adds);\n+                    }\n+                } else {\n+                    res.insert(gen.clone());\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+pub fn get_all_types(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    cx: &DocContext<'_>,\n+) -> (Vec<Type>, Vec<Type>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let args = get_real_types(generics, &arg.type_, cx);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            all_types.insert(arg.type_.clone());\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FunctionRetTy::Return(ref return_type) => {\n+            let mut ret = get_real_types(generics, &return_type, cx);\n+            if ret.is_empty() {\n+                ret.insert(return_type.clone());\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n     pub decl: FnDecl,\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n@@ -1728,11 +1881,14 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Method {\n             decl,\n             generics,\n             header: self.0.header,\n             defaultness: self.3,\n+            all_types,\n+            ret_types,\n         }\n     }\n }\n@@ -1742,13 +1898,17 @@ pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n+    pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1763,6 +1923,7 @@ impl Clean<Item> for doctree::Function {\n         } else {\n             hir::Constness::NotConst\n         };\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1775,6 +1936,8 @@ impl Clean<Item> for doctree::Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n+                all_types,\n+                ret_types,\n             }),\n         }\n     }\n@@ -1862,7 +2025,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n-            attrs: Attributes::default()\n+            attrs: Attributes::default(),\n         }\n     }\n }\n@@ -2044,10 +2207,13 @@ impl Clean<Item> for hir::TraitItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 TyMethodItem(TyMethod {\n                     header: sig.header,\n                     decl,\n                     generics,\n+                    all_types,\n+                    ret_types,\n                 })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -2145,6 +2311,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     ty::ImplContainer(_) => true,\n                     ty::TraitContainer(_) => self.defaultness.has_value()\n                 };\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n                     let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n                         hir::Constness::Const\n@@ -2161,6 +2328,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n                         defaultness: Some(self.defaultness),\n+                        all_types,\n+                        ret_types,\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n@@ -2171,7 +2340,9 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             abi: sig.abi(),\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n-                        }\n+                        },\n+                        all_types,\n+                        ret_types,\n                     })\n                 }\n             }\n@@ -2420,6 +2591,13 @@ impl Type {\n             _ => None\n         }\n     }\n+\n+    pub fn is_full_generic(&self) -> bool {\n+        match *self {\n+            Type::Generic(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GetDefId for Type {\n@@ -3849,6 +4027,7 @@ impl Clean<Item> for hir::ForeignItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 ForeignFunctionItem(Function {\n                     decl,\n                     generics,\n@@ -3858,6 +4037,8 @@ impl Clean<Item> for hir::ForeignItem {\n                         constness: hir::Constness::NotConst,\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n+                    all_types,\n+                    ret_types,\n                 })\n             }\n             hir::ForeignItemKind::Static(ref ty, mutbl) => {"}, {"sha": "866d8fe682a7b4a71b04cf4a59d42b2fce80600b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -446,7 +446,7 @@ impl ToJson for Type {\n                 }\n                 Json::Array(data)\n             }\n-            None => Json::Null\n+            None => Json::Null,\n         }\n     }\n }\n@@ -455,19 +455,27 @@ impl ToJson for Type {\n #[derive(Debug)]\n struct IndexItemFunctionType {\n     inputs: Vec<Type>,\n-    output: Option<Type>,\n+    output: Option<Vec<Type>>,\n }\n \n impl ToJson for IndexItemFunctionType {\n     fn to_json(&self) -> Json {\n         // If we couldn't figure out a type, just write `null`.\n-        if self.inputs.iter().chain(self.output.iter()).any(|ref i| i.name.is_none()) {\n+        let mut iter = self.inputs.iter();\n+        if match self.output {\n+            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n+            None => iter.any(|ref i| i.name.is_none()),\n+        } {\n             Json::Null\n         } else {\n             let mut data = Vec::with_capacity(2);\n             data.push(self.inputs.to_json());\n             if let Some(ref output) = self.output {\n-                data.push(output.to_json());\n+                if output.len() > 1 {\n+                    data.push(output.to_json());\n+                } else {\n+                    data.push(output[0].to_json());\n+                }\n             }\n             Json::Array(data)\n         }\n@@ -5025,20 +5033,26 @@ fn make_item_keywords(it: &clean::Item) -> String {\n }\n \n fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let decl = match item.inner {\n-        clean::FunctionItem(ref f) => &f.decl,\n-        clean::MethodItem(ref m) => &m.decl,\n-        clean::TyMethodItem(ref m) => &m.decl,\n-        _ => return None\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        _ => return None,\n     };\n \n-    let inputs = decl.inputs.values.iter().map(|arg| get_index_type(&arg.type_)).collect();\n-    let output = match decl.output {\n-        clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n-        _ => None\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect();\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n     };\n \n-    Some(IndexItemFunctionType { inputs: inputs, output: output })\n+    Some(IndexItemFunctionType { inputs, output })\n }\n \n fn get_index_type(clean_type: &clean::Type) -> Type {"}, {"sha": "aad7eb627bfe2603a463789a504ef879f579b541", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f131f042c2de84e330ec006f8f70780efccc4dca/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f131f042c2de84e330ec006f8f70780efccc4dca", "patch": "@@ -714,7 +714,10 @@ if (!DOMTokenList.prototype.remove) {\n                 }\n                 lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n                 if (lev_distance <= MAX_LEV_DISTANCE) {\n-                    lev_distance = Math.min(checkGenerics(obj, val), lev_distance);\n+                    // The generics didn't match but the name kinda did so we give it\n+                    // a levenshtein distance value that isn't *this* good so it goes\n+                    // into the search results but not too high.\n+                    lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n                 } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n                     // We can check if the type we're looking for is inside the generics!\n                     var olength = obj[GENERICS_DATA].length;\n@@ -752,13 +755,26 @@ if (!DOMTokenList.prototype.remove) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                    var tmp = checkType(obj.type[OUTPUT_DATA], val, literalSearch);\n-                    if (literalSearch === true && tmp === true) {\n-                        return true;\n+                    var ret = obj.type[OUTPUT_DATA];\n+                    if (!obj.type[OUTPUT_DATA].length) {\n+                        ret = [ret];\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n-                    if (lev_distance === 0) {\n-                        return 0;\n+                    for (var x = 0; x < ret.length; ++x) {\n+                        var r = ret[x];\n+                        if (typeof r === \"string\") {\n+                            r = [r];\n+                        }\n+                        var tmp = checkType(r, val, literalSearch);\n+                        if (literalSearch === true) {\n+                            if (tmp === true) {\n+                                return true;\n+                            }\n+                            continue;\n+                        }\n+                        lev_distance = Math.min(tmp, lev_distance);\n+                        if (lev_distance === 0) {\n+                            return 0;\n+                        }\n                     }\n                 }\n                 return literalSearch === true ? false : lev_distance;"}]}