{"sha": "83c4e25d93ab936567df8fa5c338b5d05c1245ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYzRlMjVkOTNhYjkzNjU2N2RmOGZhNWMzMzhiNWQwNWMxMjQ1ZWM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-27T14:52:27Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-28T16:28:04Z"}, "message": "De-@ NamedMatch.", "tree": {"sha": "2f1cb1c61b9ad8476748942213dc8ff141b23cfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f1cb1c61b9ad8476748942213dc8ff141b23cfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c4e25d93ab936567df8fa5c338b5d05c1245ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c4e25d93ab936567df8fa5c338b5d05c1245ec", "html_url": "https://github.com/rust-lang/rust/commit/83c4e25d93ab936567df8fa5c338b5d05c1245ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c4e25d93ab936567df8fa5c338b5d05c1245ec/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f226e56946d20acfdf8c0c48c57fd7ba3571157", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f226e56946d20acfdf8c0c48c57fd7ba3571157", "html_url": "https://github.com/rust-lang/rust/commit/8f226e56946d20acfdf8c0c48c57fd7ba3571157"}], "stats": {"total": 53, "additions": 27, "deletions": 26}, "files": [{"sha": "ac19342f47a1c56c03e9afed2c7fabe305fe4282", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=83c4e25d93ab936567df8fa5c338b5d05c1245ec", "patch": "@@ -21,6 +21,7 @@ use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Token, EOF, Nonterminal};\n use parse::token;\n \n+use std::rc::Rc;\n use collections::HashMap;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n@@ -102,7 +103,7 @@ pub struct MatcherPos {\n     sep: Option<Token>,\n     idx: uint,\n     up: Option<~MatcherPos>,\n-    matches: Vec<Vec<@NamedMatch>>,\n+    matches: Vec<Vec<Rc<NamedMatch>>>,\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n@@ -165,14 +166,14 @@ pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n // ast::Matcher it was derived from.\n \n pub enum NamedMatch {\n-    MatchedSeq(Vec<@NamedMatch> , codemap::Span),\n+    MatchedSeq(Vec<Rc<NamedMatch>>, codemap::Span),\n     MatchedNonterminal(Nonterminal)\n }\n \n-pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n-            -> HashMap<Ident, @NamedMatch> {\n-    fn n_rec(p_s: &ParseSess, m: &Matcher, res: &[@NamedMatch],\n-             ret_val: &mut HashMap<Ident, @NamedMatch>) {\n+pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[Rc<NamedMatch>])\n+            -> HashMap<Ident, Rc<NamedMatch>> {\n+    fn n_rec(p_s: &ParseSess, m: &Matcher, res: &[Rc<NamedMatch>],\n+             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>) {\n         match *m {\n           codemap::Spanned {node: MatchTok(_), .. } => (),\n           codemap::Spanned {node: MatchSeq(ref more_ms, _, _, _, _), .. } => {\n@@ -189,7 +190,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n                 p_s.span_diagnostic\n                    .span_fatal(span, \"duplicated bind name: \" + string.get())\n             }\n-            ret_val.insert(bind_name, res[idx]);\n+            ret_val.insert(bind_name, res[idx].clone());\n           }\n         }\n     }\n@@ -199,7 +200,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n }\n \n pub enum ParseResult {\n-    Success(HashMap<Ident, @NamedMatch>),\n+    Success(HashMap<Ident, Rc<NamedMatch>>),\n     Failure(codemap::Span, ~str),\n     Error(codemap::Span, ~str)\n }\n@@ -208,7 +209,7 @@ pub fn parse_or_else(sess: &ParseSess,\n                      cfg: ast::CrateConfig,\n                      rdr: TtReader,\n                      ms: Vec<Matcher> )\n-                     -> HashMap<Ident, @NamedMatch> {\n+                     -> HashMap<Ident, Rc<NamedMatch>> {\n     match parse(sess, cfg, rdr, ms.as_slice()) {\n         Success(m) => m,\n         Failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n@@ -282,8 +283,8 @@ pub fn parse(sess: &ParseSess,\n                             let sub = (*ei.matches.get(idx)).clone();\n                             new_pos.matches\n                                    .get_mut(idx)\n-                                   .push(@MatchedSeq(sub, mk_sp(ei.sp_lo,\n-                                                                sp.hi)));\n+                                   .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n+                                                                       sp.hi))));\n                         }\n \n                         new_pos.idx += 1;\n@@ -325,7 +326,7 @@ pub fn parse(sess: &ParseSess,\n                         for idx in range(match_idx_lo, match_idx_hi) {\n                             new_ei.matches\n                                   .get_mut(idx)\n-                                  .push(@MatchedSeq(Vec::new(), sp));\n+                                  .push(Rc::new(MatchedSeq(Vec::new(), sp)));\n                         }\n \n                         cur_eis.push(new_ei);\n@@ -401,8 +402,8 @@ pub fn parse(sess: &ParseSess,\n                 match ei.elts.get(ei.idx).node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n-                    ei.matches.get_mut(idx).push(@MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, name_string.get())));\n+                    ei.matches.get_mut(idx).push(Rc::new(MatchedNonterminal(\n+                        parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()"}, {"sha": "d4a883a63ebbf9ca4f5e1366955ec0de79adb8e8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=83c4e25d93ab936567df8fa5c338b5d05c1245ec", "patch": "@@ -86,8 +86,8 @@ impl<'a> AnyMacro for ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n-    lhses: @Vec<@NamedMatch> ,\n-    rhses: @Vec<@NamedMatch> ,\n+    lhses: Vec<Rc<NamedMatch>>,\n+    rhses: Vec<Rc<NamedMatch>>,\n }\n \n impl MacroExpander for MacroRulesMacroExpander {\n@@ -110,8 +110,8 @@ fn generic_extension(cx: &ExtCtxt,\n                      sp: Span,\n                      name: Ident,\n                      arg: &[ast::TokenTree],\n-                     lhses: &[@NamedMatch],\n-                     rhses: &[@NamedMatch])\n+                     lhses: &[Rc<NamedMatch>],\n+                     rhses: &[Rc<NamedMatch>])\n                      -> MacResult {\n     if cx.trace_macros() {\n         println!(\"{}! \\\\{ {} \\\\}\",\n@@ -221,12 +221,12 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n \n     // Extract the arguments:\n     let lhses = match **argument_map.get(&lhs_nm) {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n     let rhses = match **argument_map.get(&rhs_nm) {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n "}, {"sha": "bc8709befaee26c18b79d63c619c11390ad08d49", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c4e25d93ab936567df8fa5c338b5d05c1245ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=83c4e25d93ab936567df8fa5c338b5d05c1245ec", "patch": "@@ -35,7 +35,7 @@ pub struct TtReader<'a> {\n     // the unzipped tree:\n     priv stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n-    priv interpolations: HashMap<Ident, @NamedMatch>,\n+    priv interpolations: HashMap<Ident, Rc<NamedMatch>>,\n     priv repeat_idx: Vec<uint>,\n     priv repeat_len: Vec<uint>,\n     /* cached: */\n@@ -47,7 +47,7 @@ pub struct TtReader<'a> {\n  *  `src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\n  *  should) be none. */\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n-                         interp: Option<HashMap<Ident, @NamedMatch>>,\n+                         interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n                          src: Vec<ast::TokenTree> )\n                          -> TtReader<'a> {\n     let mut r = TtReader {\n@@ -72,19 +72,19 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n     r\n }\n \n-fn lookup_cur_matched_by_matched(r: &TtReader, start: @NamedMatch) -> @NamedMatch {\n+fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<NamedMatch> {\n     r.repeat_idx.iter().fold(start, |ad, idx| {\n         match *ad {\n             MatchedNonterminal(_) => {\n                 // end of the line; duplicate henceforth\n-                ad\n+                ad.clone()\n             }\n-            MatchedSeq(ref ads, _) => *ads.get(*idx)\n+            MatchedSeq(ref ads, _) => ads.get(*idx).clone()\n         }\n     })\n }\n \n-fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n+fn lookup_cur_matched(r: &TtReader, name: Ident) -> Rc<NamedMatch> {\n     let matched_opt = r.interpolations.find_copy(&name);\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),"}]}