{"sha": "767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2Y1OTQ2MjY2M2ZiYzU1YTY5ZDM5ZmM1ZTFmN2Y4M2I2ZmIzN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-02T02:01:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-02T02:01:31Z"}, "message": "Auto merge of #60460 - Centril:rollup-gz5bc8i, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #59634 (Added an explanation for the E0704 error.)\n - #60348 (move some functions from parser.rs to diagostics.rs)\n - #60385 (Emit metadata files earlier)\n - #60428 (Refactor `eval_body_using_ecx` so that it doesn't need to query for MIR)\n - #60437 (Ensure that drop order of `async fn` matches `fn` and that users cannot refer to generated arguments.)\n - #60439 (doc: Warn about possible zombie apocalypse)\n - #60452 (Remove Context and ContextKind)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "895cfb402b31011b55559d0acf4cdc5d34326eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/895cfb402b31011b55559d0acf4cdc5d34326eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "html_url": "https://github.com/rust-lang/rust/commit/767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea68bee369c9ebc0de35abcd39211fa0d4f9c84f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea68bee369c9ebc0de35abcd39211fa0d4f9c84f", "html_url": "https://github.com/rust-lang/rust/commit/ea68bee369c9ebc0de35abcd39211fa0d4f9c84f"}, {"sha": "4ff12347d994d5c85cab250cedf223d9d0db8973", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff12347d994d5c85cab250cedf223d9d0db8973", "html_url": "https://github.com/rust-lang/rust/commit/4ff12347d994d5c85cab250cedf223d9d0db8973"}], "stats": {"total": 1921, "additions": 1132, "deletions": 789}, "files": [{"sha": "fd6a7a5604edf5abda19342842e98c9261ffc6dd", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -2802,6 +2802,7 @@ dependencies = [\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -2821,6 +2822,7 @@ dependencies = [\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "6d57882976e11dbd3e37b5e0211dd3372f88f761", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -2996,8 +2996,33 @@ impl<'a> LoweringContext<'a> {\n             if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n                 let mut body = body.clone();\n \n+                // Async function arguments are lowered into the closure body so that they are\n+                // captured and so that the drop order matches the equivalent non-async functions.\n+                //\n+                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+                //       async move {\n+                //       }\n+                //     }\n+                //\n+                //     // ...becomes...\n+                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+                //       async move {\n+                //         let __arg2 = __arg2;\n+                //         let <pattern> = __arg2;\n+                //         let __arg1 = __arg1;\n+                //         let <pattern> = __arg1;\n+                //         let __arg0 = __arg0;\n+                //         let <pattern> = __arg0;\n+                //       }\n+                //     }\n+                //\n+                // If `<pattern>` is a simple ident, then it is lowered to a single\n+                // `let <pattern> = <pattern>;` statement as an optimization.\n                 for a in arguments.iter().rev() {\n-                    body.stmts.insert(0, a.stmt.clone());\n+                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                        body.stmts.insert(0, pat_stmt);\n+                    }\n+                    body.stmts.insert(0, a.move_stmt.clone());\n                 }\n \n                 let async_expr = this.make_async_expr(\n@@ -3093,7 +3118,11 @@ impl<'a> LoweringContext<'a> {\n                         let mut decl = decl.clone();\n                         // Replace the arguments of this async function with the generated\n                         // arguments that will be moved into the closure.\n-                        decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                        for (i, a) in arguments.clone().drain(..).enumerate() {\n+                            if let Some(arg) = a.arg {\n+                                decl.inputs[i] = arg;\n+                            }\n+                        }\n                         lower_fn(&decl)\n                     } else {\n                         lower_fn(decl)\n@@ -3590,7 +3619,11 @@ impl<'a> LoweringContext<'a> {\n                     let mut sig = sig.clone();\n                     // Replace the arguments of this async function with the generated\n                     // arguments that will be moved into the closure.\n-                    sig.decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                    for (i, a) in arguments.clone().drain(..).enumerate() {\n+                        if let Some(arg) = a.arg {\n+                            sig.decl.inputs[i] = arg;\n+                        }\n+                    }\n                     lower_method(&sig)\n                 } else {\n                     lower_method(sig)"}, {"sha": "78de85398594efb747920b0816d3415aaae4a278", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -94,7 +94,9 @@ impl<'a> DefCollector<'a> {\n             // Walk the generated arguments for the `async fn`.\n             for a in arguments {\n                 use visit::Visitor;\n-                this.visit_ty(&a.arg.ty);\n+                if let Some(arg) = &a.arg {\n+                    this.visit_ty(&arg.ty);\n+                }\n             }\n \n             // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n@@ -105,10 +107,13 @@ impl<'a> DefCollector<'a> {\n                 *closure_id, DefPathData::ClosureExpr, REGULAR_SPACE, span,\n             );\n             this.with_parent(closure_def, |this| {\n+                use visit::Visitor;\n+                // Walk each of the generated statements before the regular block body.\n                 for a in arguments {\n-                    use visit::Visitor;\n-                    // Walk each of the generated statements before the regular block body.\n-                    this.visit_stmt(&a.stmt);\n+                    this.visit_stmt(&a.move_stmt);\n+                    if let Some(pat_stmt) = &a.pat_stmt {\n+                        this.visit_stmt(&pat_stmt);\n+                    }\n                 }\n \n                 visit::walk_block(this, &body);"}, {"sha": "8d5c1798e0fa4a5c0ef82d076419d45fb351795c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -1334,14 +1334,19 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n             for a in arguments {\n                 // Visit the argument..\n-                self.visit_pat(&a.arg.pat);\n-                if let ast::ArgSource::AsyncFn(pat) = &a.arg.source {\n-                    self.visit_pat(pat);\n+                if let Some(arg) = &a.arg {\n+                    self.visit_pat(&arg.pat);\n+                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n+                        self.visit_pat(pat);\n+                    }\n+                    self.visit_ty(&arg.ty);\n                 }\n-                self.visit_ty(&a.arg.ty);\n \n                 // ..and the statement.\n-                self.visit_stmt(&a.stmt);\n+                self.visit_stmt(&a.move_stmt);\n+                if let Some(pat_stmt) = &a.pat_stmt {\n+                    self.visit_stmt(&pat_stmt);\n+                }\n             }\n         }\n     }"}, {"sha": "9077e89a4020eae8cc5b479ec13d83d6b1d89008", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -28,7 +28,7 @@ use rustc::mir::mono::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n-use rustc::session::config::{self, DebugInfo};\n+use rustc::session::config::DebugInfo;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_data_structures::small_c_str::SmallCStr;\n \n@@ -42,47 +42,16 @@ use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n \n-\n-pub fn write_metadata<'a, 'gcx>(\n+pub fn write_compressed_metadata<'a, 'gcx>(\n     tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    metadata: &EncodedMetadata,\n     llvm_module: &mut ModuleLlvm\n-) -> EncodedMetadata {\n+) {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n \n     let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed\n-    }\n-\n-    let kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n-        match *ty {\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib |\n-            config::CrateType::Cdylib => MetadataKind::None,\n-\n-            config::CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro => MetadataKind::Compressed,\n-        }\n-    }).max().unwrap_or(MetadataKind::None);\n-\n-    if kind == MetadataKind::None {\n-        return EncodedMetadata::new();\n-    }\n-\n-    let metadata = tcx.encode_metadata();\n-    if kind == MetadataKind::Uncompressed {\n-        return metadata;\n-    }\n-\n-    assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n@@ -107,7 +76,6 @@ pub fn write_metadata<'a, 'gcx>(\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return metadata;\n }\n \n pub struct ValueIter<'ll> {"}, {"sha": "09b284052b3c488414f140c4ec9ac96ab66de9d2", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -110,12 +110,13 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n     }\n \n-    fn write_metadata<'b, 'gcx>(\n+    fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &mut ModuleLlvm\n-    ) -> EncodedMetadata {\n-        base::write_metadata(tcx, metadata)\n+        metadata: &EncodedMetadata,\n+        llvm_module: &mut ModuleLlvm\n+    ) {\n+        base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n@@ -289,9 +290,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n     fn codegen_crate<'b, 'tcx>(\n         &self,\n         tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        metadata: EncodedMetadata,\n+        need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any> {\n-        box rustc_codegen_ssa::base::codegen_crate(LlvmCodegenBackend(()), tcx, rx)\n+        box rustc_codegen_ssa::base::codegen_crate(\n+            LlvmCodegenBackend(()), tcx, metadata, need_metadata_module, rx)\n     }\n \n     fn join_codegen_and_link("}, {"sha": "f25891d77ce5353b6b4564ee96beb44537e46ca2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 44, "deletions": 80, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -7,7 +7,7 @@ use rustc::session::config::{\n };\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n use rustc::util::common::{time, time_ext};\n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::fx::FxHashSet;\n@@ -50,9 +50,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                                               outputs: &OutputFilenames,\n                                               crate_name: &str,\n                                               target_cpu: &str) {\n+    let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n-        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n            !output_metadata &&\n            crate_type == config::CrateType::Executable {\n@@ -63,12 +63,43 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        link_binary_output::<B>(sess,\n-                                codegen_results,\n-                                crate_type,\n-                                outputs,\n-                                crate_name,\n-                                target_cpu);\n+\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+            check_file_is_writeable(obj, sess);\n+        }\n+\n+        let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+            sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+\n+        if outputs.outputs.should_codegen() {\n+            let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+            match crate_type {\n+                config::CrateType::Rlib => {\n+                    link_rlib::<B>(sess,\n+                              codegen_results,\n+                              RlibFlavor::Normal,\n+                              &out_filename,\n+                              &tmpdir).build();\n+                }\n+                config::CrateType::Staticlib => {\n+                    link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+                }\n+                _ => {\n+                    link_natively::<B>(\n+                        sess,\n+                        crate_type,\n+                        &out_filename,\n+                        codegen_results,\n+                        tmpdir.path(),\n+                        target_cpu,\n+                    );\n+                }\n+            }\n+        }\n+\n+        if sess.opts.cg.save_temps {\n+            let _ = tmpdir.into_path();\n+        }\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -85,7 +116,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             if let Some(ref obj) = metadata_module.object {\n                 remove(sess, obj);\n             }\n-         }\n+        }\n         if let Some(ref allocator_module) = codegen_results.allocator_module {\n             if let Some(ref obj) = allocator_module.object {\n                 remove(sess, obj);\n@@ -97,73 +128,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     }\n }\n \n-fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                                                 codegen_results: &CodegenResults,\n-                                                 crate_type: config::CrateType,\n-                                                 outputs: &OutputFilenames,\n-                                                 crate_name: &str,\n-                                                 target_cpu: &str) {\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        check_file_is_writeable(obj, sess);\n-    }\n-\n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with a `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-        match fs::rename(&metadata, &out_filename) {\n-            Ok(_) => {\n-                if sess.opts.debugging_opts.emit_directives {\n-                    sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n-                        format!(\"metadata file written: {}\", out_filename.display()));\n-                }\n-            }\n-            Err(e) => sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n-        }\n-    }\n-\n-    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n-        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n-    if outputs.outputs.should_codegen() {\n-        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n-        match crate_type {\n-            config::CrateType::Rlib => {\n-                link_rlib::<B>(sess,\n-                          codegen_results,\n-                          RlibFlavor::Normal,\n-                          &out_filename,\n-                          &tmpdir).build();\n-            }\n-            config::CrateType::Staticlib => {\n-                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n-            }\n-            _ => {\n-                link_natively::<B>(\n-                    sess,\n-                    crate_type,\n-                    &out_filename,\n-                    codegen_results,\n-                    tmpdir.path(),\n-                    target_cpu,\n-                );\n-            }\n-        }\n-    }\n-\n-    if sess.opts.cg.save_temps {\n-        let _ = tmpdir.into_path();\n-    }\n-}\n-\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n@@ -261,13 +225,13 @@ pub fn each_linked_rlib(sess: &Session,\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(\n+pub fn emit_metadata<'a>(\n     sess: &'a Session,\n-    codegen_results: &CodegenResults,\n+    metadata: &EncodedMetadata,\n     tmpdir: &TempDir\n ) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n+    let result = fs::write(&out_filename, &metadata.raw_data);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -351,7 +315,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n         RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n             // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n+            ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive."}, {"sha": "3cd47dfbb29fb7cf6387cecc36406e59999565b0", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -17,6 +17,7 @@ use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen};\n \n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n@@ -25,7 +26,7 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::session::config::{self, CrateType, EntryFnType, Lto};\n+use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n@@ -530,26 +531,13 @@ pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>\n ) -> OngoingCodegen<B> {\n \n     check_for_rustc_errors_attr(tcx);\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n-\n-    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                            &[\"crate\"],\n-                                                            Some(\"metadata\")).as_str()\n-                                                                             .to_string();\n-    let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n-    let metadata = time(tcx.sess, \"write metadata\", || {\n-        backend.write_metadata(tcx, &mut metadata_llvm_module)\n-    });\n-    tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n-\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen ||\n        !tcx.sess.opts.output_types.should_codegen() {\n@@ -569,6 +557,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         return ongoing_codegen;\n     }\n \n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n     // Run the monomorphization collector and partition the collected items into\n     // codegen units.\n     let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n@@ -632,17 +622,21 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n     }\n \n-    let needs_metadata_module = tcx.sess.crate_types.borrow().iter().any(|ct| {\n-        match *ct {\n-            CrateType::Dylib |\n-            CrateType::ProcMacro => true,\n-            CrateType::Executable |\n-            CrateType::Rlib |\n-            CrateType::Staticlib |\n-            CrateType::Cdylib => false,\n-        }\n-    });\n-    if needs_metadata_module {\n+    if need_metadata_module {\n+        // Codegen the encoded metadata.\n+        tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n+\n+        let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                                &[\"crate\"],\n+                                                                Some(\"metadata\")).as_str()\n+                                                                                 .to_string();\n+        let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n+        time(tcx.sess, \"write compressed metadata\", || {\n+            backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,\n+                                              &mut metadata_llvm_module);\n+        });\n+        tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n+\n         let metadata_module = ModuleCodegen {\n             name: metadata_cgu_name,\n             module_llvm: metadata_llvm_module,"}, {"sha": "530eba516a6c0c4a00094498a47424482809700d", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -33,11 +33,12 @@ impl<'tcx, T> Backend<'tcx> for T where\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n     fn new_metadata(&self, sess: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self::Module;\n-    fn write_metadata<'b, 'gcx>(\n+    fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &mut Self::Module,\n-    ) -> EncodedMetadata;\n+        metadata: &EncodedMetadata,\n+        llvm_module: &mut Self::Module,\n+    );\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,"}, {"sha": "191c6605b43ff4022e636c1fa6fe758ebcf15d35", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -18,7 +18,7 @@ use rustc::util::common::ErrorReported;\n use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::dep_graph::DepGraph;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -37,6 +37,8 @@ pub trait CodegenBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        metadata: EncodedMetadata,\n+        need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any>;\n "}, {"sha": "bcaa4216109aa7c839301286d4bae000ba6b7e2e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -24,6 +24,7 @@ rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n@@ -34,3 +35,4 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+tempfile = \"3.0.5\""}, {"sha": "6d3115c621343ad1eb131caa65d70a5e61fb26c1", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -16,11 +16,13 @@ use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n use rustc::util::profiling::ProfileCategory;\n use rustc::session::{CompileResult, CrateDisambiguator, Session};\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n+use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -50,6 +52,7 @@ use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n use serialize::json;\n+use tempfile::Builder as TempFileBuilder;\n \n use std::any::Any;\n use std::env;\n@@ -999,6 +1002,68 @@ fn analysis<'tcx>(\n     Ok(())\n }\n \n+fn encode_and_write_metadata<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    outputs: &OutputFilenames,\n+) -> (middle::cstore::EncodedMetadata, bool) {\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed\n+    }\n+\n+    let metadata_kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n+        match *ty {\n+            CrateType::Executable |\n+            CrateType::Staticlib |\n+            CrateType::Cdylib => MetadataKind::None,\n+\n+            CrateType::Rlib => MetadataKind::Uncompressed,\n+\n+            CrateType::Dylib |\n+            CrateType::ProcMacro => MetadataKind::Compressed,\n+        }\n+    }).max().unwrap_or(MetadataKind::None);\n+\n+    let metadata = match metadata_kind {\n+        MetadataKind::None => middle::cstore::EncodedMetadata::new(),\n+        MetadataKind::Uncompressed |\n+        MetadataKind::Compressed => tcx.encode_metadata(),\n+    };\n+\n+    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n+    if need_metadata_file {\n+        let crate_name = &tcx.crate_name(LOCAL_CRATE).as_str();\n+        let out_filename = filename_for_metadata(tcx.sess, crate_name, outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with an `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| {\n+                tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err))\n+            });\n+        let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n+        match std::fs::rename(&metadata_filename, &out_filename) {\n+            Ok(_) => {\n+                if tcx.sess.opts.debugging_opts.emit_directives {\n+                    tcx.sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n+                        format!(\"metadata file written: {}\", out_filename.display()));\n+                }\n+            }\n+            Err(e) => tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n+        }\n+    }\n+\n+    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n+\n+    (metadata, need_metadata_module)\n+}\n+\n /// Runs the codegen backend, after which the AST and analysis can\n /// be discarded.\n pub fn start_codegen<'tcx>(\n@@ -1013,11 +1078,17 @@ pub fn start_codegen<'tcx>(\n     }\n \n     time(tcx.sess, \"resolving dependency formats\", || {\n-        ::rustc::middle::dependency_format::calculate(tcx)\n+        middle::dependency_format::calculate(tcx)\n+    });\n+\n+    let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n+        encode_and_write_metadata(tcx, outputs)\n     });\n \n     tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));\n-    let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n+    let codegen = time(tcx.sess, \"codegen\", move || {\n+        codegen_backend.codegen_crate(tcx, metadata, need_metadata_module, rx)\n+    });\n     tcx.sess.profiler(|p| p.end_activity(\"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {"}, {"sha": "ed42326d7d5206f6398ffdf9d8f62b622843c24c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -22,7 +22,7 @@ use syntax_pos::Span;\n use syntax::source_map::CompilerDesugaringKind;\n \n use super::borrow_set::BorrowData;\n-use super::{Context, MirBorrowckCtxt};\n+use super::{MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MovePathIndex, MoveOutIndex};\n@@ -42,22 +42,22 @@ struct MoveSite {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n-            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} \\\n+            \"report_use_of_moved_or_uninitialized: location={:?} desired_action={:?} \\\n              moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n-            context, desired_action, moved_place, used_place, span, mpi\n+            location, desired_action, moved_place, used_place, span, mpi\n         );\n \n-        let use_spans = self.move_spans(moved_place, context.loc)\n-            .or_else(|| self.borrow_spans(span, context.loc));\n+        let use_spans = self.move_spans(moved_place, location)\n+            .or_else(|| self.borrow_spans(span, location));\n         let span = use_spans.args_or_use();\n \n-        let move_site_vec = self.get_moved_indexes(context, mpi);\n+        let move_site_vec = self.get_moved_indexes(location, mpi);\n         debug!(\n             \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n             move_site_vec\n@@ -125,7 +125,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n \n             self.add_moved_or_invoked_closure_note(\n-                context.loc,\n+                location,\n                 used_place,\n                 &mut err,\n             );\n@@ -261,13 +261,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         debug!(\n-            \"report_move_out_while_borrowed: context={:?} place={:?} span={:?} borrow={:?}\",\n-            context, place, span, borrow\n+            \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n+            location, place, span, borrow\n         );\n         let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n@@ -282,7 +282,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n-        let move_spans = self.move_spans(place, context.loc);\n+        let move_spans = self.move_spans(place, location);\n         let span = move_spans.args_or_use();\n \n         let mut err = tcx.cannot_move_when_borrowed(\n@@ -304,7 +304,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(\n-            context,\n+            location,\n             borrow,\n             None,\n         ).add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", Some(borrow_span));\n@@ -313,7 +313,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -324,7 +324,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Conflicting borrows are reported separately, so only check for move\n         // captures.\n-        let use_spans = self.move_spans(place, context.loc);\n+        let use_spans = self.move_spans(place, location);\n         let span = use_spans.var_or_use();\n \n         let mut err = tcx.cannot_use_when_mutably_borrowed(\n@@ -343,22 +343,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n         });\n \n-        self.explain_why_borrow_contains_point(context, borrow, None)\n+        self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n         err\n     }\n \n     pub(super) fn report_conflicting_borrow(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n         let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n         let issued_span = issued_spans.args_or_use();\n \n-        let borrow_spans = self.borrow_spans(span, context.loc);\n+        let borrow_spans = self.borrow_spans(span, location);\n         let span = borrow_spans.args_or_use();\n \n         let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n@@ -370,7 +370,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let (desc_place, msg_place, msg_borrow, union_type_name) =\n             self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n \n-        let explanation = self.explain_why_borrow_contains_point(context, issued_borrow, None);\n+        let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() {\n             \"second \"\n         } else {\n@@ -671,7 +671,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// `Drop::drop` with an aliasing borrow.)\n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n@@ -680,7 +680,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_borrowed_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, borrow, place_span, kind\n+            location, borrow, place_span, kind\n         );\n \n         let drop_span = place_span.1;\n@@ -719,7 +719,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n                 self.report_borrow_conflicts_with_destructor(\n-                    context, borrow, place_span, kind, dropped_ty,\n+                    location, borrow, place_span, kind, dropped_ty,\n                 );\n                 return;\n             }\n@@ -728,7 +728,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place_desc = self.describe_place(&borrow.borrowed_place);\n \n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n-        let explanation = self.explain_why_borrow_contains_point(context, &borrow, kind_place);\n+        let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n         let err = match (place_desc, explanation) {\n             (Some(_), _) if self.is_place_thread_local(root_place) => {\n@@ -784,7 +784,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 },\n             ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 &name,\n                 &scope_tree,\n                 &borrow,\n@@ -793,7 +793,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 explanation,\n             ),\n             (None, explanation) => self.report_temporary_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 &scope_tree,\n                 &borrow,\n                 drop_span,\n@@ -808,7 +808,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_local_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         name: &str,\n         scope_tree: &'tcx ScopeTree,\n         borrow: &BorrowData<'tcx>,\n@@ -820,7 +820,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, name, scope_tree, borrow, drop_span, borrow_spans\n+            location, name, scope_tree, borrow, drop_span, borrow_spans\n         );\n \n         let borrow_span = borrow_spans.var_or_use();\n@@ -914,7 +914,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_borrow_conflicts_with_destructor(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         (place, drop_span): (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n@@ -924,7 +924,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_borrow_conflicts_with_destructor(\\\n              {:?}, {:?}, ({:?}, {:?}), {:?}\\\n              )\",\n-            context, borrow, place, drop_span, kind,\n+            location, borrow, place, drop_span, kind,\n         );\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n@@ -957,7 +957,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Only give this note and suggestion if they could be relevant.\n         let explanation =\n-            self.explain_why_borrow_contains_point(context, borrow, kind.map(|k| (k, place)));\n+            self.explain_why_borrow_contains_point(location, borrow, kind.map(|k| (k, place)));\n         match explanation {\n             BorrowExplanation::UsedLater { .. }\n             | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n@@ -998,7 +998,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_temporary_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         scope_tree: &'tcx ScopeTree,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n@@ -1010,7 +1010,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_temporary_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, scope_tree, borrow, drop_span, proper_span\n+            location, scope_tree, borrow, drop_span, proper_span\n         );\n \n         if let BorrowExplanation::MustBeValidFor {\n@@ -1246,12 +1246,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveSite> {\n+    fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n         let mir = self.mir;\n \n         let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(context.loc).map(|predecessor| {\n-            let is_back_edge = context.loc.dominates(predecessor, &self.dominators);\n+        stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+            let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n \n@@ -1348,7 +1348,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n@@ -1386,7 +1386,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n         );\n \n-        self.explain_why_borrow_contains_point(context, loan, None)\n+        self.explain_why_borrow_contains_point(location, loan, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n \n         err.buffer(&mut self.errors_buffer);\n@@ -1400,7 +1400,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// assignment to `x.f`).\n     pub(super) fn report_illegal_reassignment(\n         &mut self,\n-        _context: Context,\n+        _location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         assigned_span: Span,\n         err_place: &Place<'tcx>,"}, {"sha": "1d65a018dd62d6b584016be3100e0bd00c90ed0b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 83, "deletions": 120, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -302,11 +302,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::replace(&mut mbcx.reservation_warnings, Default::default());\n-    for (_, (place, span, context, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag = mbcx.report_conflicting_borrow(context, (&place, span), bk, &borrow);\n+    for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n+        let mut initial_diag =\n+            mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n \n         let lint_root = if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n-            let scope = mbcx.mir.source_info(context.loc).scope;\n+            let scope = mbcx.mir.source_info(location).scope;\n             vsi[scope].lint_root\n         } else {\n             id\n@@ -483,7 +484,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// for the activation of the borrow.\n     reservation_warnings: FxHashMap<\n         BorrowIndex,\n-        (Place<'tcx>, Span, Context, BorrowKind, BorrowData<'tcx>)\n+        (Place<'tcx>, Span, Location, BorrowKind, BorrowData<'tcx>)\n     >,\n     /// This field keeps track of move errors that are to be reported for given move indicies.\n     ///\n@@ -559,14 +560,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 self.consume_rvalue(\n-                    ContextKind::AssignRhs.new(location),\n-                    (rhs, span),\n                     location,\n+                    (rhs, span),\n                     flow_state,\n                 );\n \n                 self.mutate_place(\n-                    ContextKind::AssignLhs.new(location),\n+                    location,\n                     (lhs, span),\n                     Shallow(None),\n                     JustWrite,\n@@ -585,7 +585,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 //      match x {};\n                 // from compiling.\n                 self.check_if_path_or_subpath_is_moved(\n-                    ContextKind::FakeRead.new(location),\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -596,35 +596,34 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 variant_index: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::SetDiscrim.new(location),\n+                    location,\n                     (place, span),\n                     Shallow(None),\n                     JustWrite,\n                     flow_state,\n                 );\n             }\n             StatementKind::InlineAsm(ref asm) => {\n-                let context = ContextKind::InlineAsm.new(location);\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n-                            context,\n+                            location,\n                             (output, o.span),\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                             flow_state,\n                         );\n                         self.check_if_path_or_subpath_is_moved(\n-                            context,\n+                            location,\n                             InitializationRequiringAction::Use,\n                             (output, o.span),\n                             flow_state,\n                         );\n                     } else {\n                         self.mutate_place(\n-                            context,\n+                            location,\n                             (output, o.span),\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n@@ -633,7 +632,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     }\n                 }\n                 for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(context, (input, span), flow_state);\n+                    self.consume_operand(location, (input, span), flow_state);\n                 }\n             }\n             StatementKind::Nop\n@@ -645,7 +644,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n-                    ContextKind::StorageDead.new(location),\n+                    location,\n                     (&Place::Base(PlaceBase::Local(local)), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -677,7 +676,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 values: _,\n                 targets: _,\n             } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(loc), (discr, span), flow_state);\n+                self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop {\n                 location: ref drop_place,\n@@ -702,7 +701,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                        loc, term, drop_place, drop_place_ty, span);\n \n                 self.access_place(\n-                    ContextKind::Drop.new(loc),\n+                    loc,\n                     (drop_place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -716,14 +715,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 unwind: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::DropAndReplace.new(loc),\n+                    loc,\n                     (drop_place, span),\n                     Deep,\n                     JustWrite,\n                     flow_state,\n                 );\n                 self.consume_operand(\n-                    ContextKind::DropAndReplace.new(loc),\n+                    loc,\n                     (new_value, span),\n                     flow_state,\n                 );\n@@ -735,17 +734,17 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                self.consume_operand(ContextKind::CallOperator.new(loc), (func, span), flow_state);\n+                self.consume_operand(loc, (func, span), flow_state);\n                 for arg in args {\n                     self.consume_operand(\n-                        ContextKind::CallOperand.new(loc),\n+                        loc,\n                         (arg, span),\n                         flow_state,\n                     );\n                 }\n                 if let Some((ref dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(\n-                        ContextKind::CallDest.new(loc),\n+                        loc,\n                         (dest, span),\n                         Deep,\n                         JustWrite,\n@@ -760,11 +759,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::Assert.new(loc), (cond, span), flow_state);\n+                self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                    self.consume_operand(ContextKind::Assert.new(loc), (index, span), flow_state);\n+                    self.consume_operand(loc, (len, span), flow_state);\n+                    self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n@@ -773,7 +772,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 resume: _,\n                 drop: _,\n             } => {\n-                self.consume_operand(ContextKind::Yield.new(loc), (value, span), flow_state);\n+                self.consume_operand(loc, (value, span), flow_state);\n \n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n@@ -796,8 +795,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 flow_state.with_outgoing_borrows(|borrows| {\n                     for i in borrows {\n                         let borrow = &borrow_set[i];\n-                        let context = ContextKind::StorageDead.new(loc);\n-                        self.check_for_invalidation_at_exit(context, borrow, span);\n+                        self.check_for_invalidation_at_exit(loc, borrow, span);\n                     }\n                 });\n             }\n@@ -955,7 +953,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Returns `true` if an error is reported.\n     fn access_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n@@ -994,10 +992,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 rw,\n                 is_local_mutation_allowed,\n                 flow_state,\n-                context.loc,\n+                location,\n             );\n         let conflict_error =\n-            self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n+            self.check_access_for_conflict(location, place_span, sd, rw, flow_state);\n \n         if let (Activation(_, borrow_idx), true) = (kind.1, conflict_error) {\n             // Suppress this warning when there's an error being emited for the\n@@ -1018,30 +1016,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_access_for_conflict(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n         debug!(\n-            \"check_access_for_conflict(context={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            context, place_span, sd, rw,\n+            \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n+            location, place_span, sd, rw,\n         );\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let mir = self.mir;\n-        let location = self.location_table.start_index(context.loc);\n+        let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,\n             tcx,\n             mir,\n-            context,\n+            location,\n             (sd, place_span.0),\n             &borrow_set,\n-            flow_state.borrows_in_scope(location),\n+            flow_state.borrows_in_scope(location_table),\n             |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n@@ -1075,19 +1073,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if !is_active(&this.dominators, borrow, context.loc) {\n+                    if !is_active(&this.dominators, borrow, location) {\n                         assert!(allow_two_phase_borrow(borrow.kind));\n                         return Control::Continue;\n                     }\n \n                     error_reported = true;\n                     match kind {\n                         ReadKind::Copy  => {\n-                            this.report_use_while_mutably_borrowed(context, place_span, borrow)\n+                            this.report_use_while_mutably_borrowed(location, place_span, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            this.report_conflicting_borrow(context, place_span, bk, borrow)\n+                            this.report_conflicting_borrow(location, place_span, bk, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                     }\n@@ -1098,7 +1096,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 | (Reservation(WriteKind::MutableBorrow(bk)), BorrowKind::Shared) if {\n                     tcx.migrate_borrowck()\n                 } => {\n-                    let bi = this.borrow_set.location_map[&context.loc];\n+                    let bi = this.borrow_set.location_map[&location];\n                     debug!(\n                         \"recording invalid reservation of place: {:?} with \\\n                          borrow index {:?} as warning\",\n@@ -1111,7 +1109,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // checking was otherwise successful.\n                     this.reservation_warnings.insert(\n                         bi,\n-                        (place_span.0.clone(), place_span.1, context, bk, borrow.clone()),\n+                        (place_span.0.clone(), place_span.1, location, bk, borrow.clone()),\n                     );\n \n                     // Don't suppress actual errors.\n@@ -1143,21 +1141,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     error_reported = true;\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            this.report_conflicting_borrow(context, place_span, bk, borrow)\n+                            this.report_conflicting_borrow(location, place_span, bk, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context,\n+                                location,\n                                 borrow,\n                                 place_span,\n                                 Some(kind))\n                         }\n                         WriteKind::Mutate => {\n-                            this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n+                            this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n-                            this.report_move_out_while_borrowed(context, place_span, borrow)\n+                            this.report_move_out_while_borrowed(location, place_span, borrow)\n                         }\n                     }\n                     Control::Break\n@@ -1170,7 +1168,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn mutate_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n@@ -1180,14 +1178,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match mode {\n             MutateMode::WriteAndRead => {\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Update,\n                     place_span,\n                     flow_state,\n                 );\n             }\n             MutateMode::JustWrite => {\n-                self.check_if_assigned_path_is_moved(context, place_span, flow_state);\n+                self.check_if_assigned_path_is_moved(location, place_span, flow_state);\n             }\n         }\n \n@@ -1198,7 +1196,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let Mutability::Not = self.mir.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n-                    context,\n+                    location,\n                     local,\n                     place_span,\n                     flow_state,\n@@ -1209,7 +1207,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Otherwise, use the normal access permission rules.\n         self.access_place(\n-            context,\n+            location,\n             place_span,\n             (kind, Write(WriteKind::Mutate)),\n             LocalMutationIsAllowed::No,\n@@ -1219,9 +1217,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn consume_rvalue(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (rvalue, span): (&Rvalue<'tcx>, Span),\n-        _location: Location,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *rvalue {\n@@ -1242,7 +1239,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n@@ -1256,7 +1253,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     action,\n                     (place, span),\n                     flow_state,\n@@ -1267,7 +1264,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n             | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n-                self.consume_operand(context, (operand, span), flow_state)\n+                self.consume_operand(location, (operand, span), flow_state)\n             }\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n@@ -1277,14 +1274,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1293,8 +1290,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n             | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, (operand1, span), flow_state);\n-                self.consume_operand(context, (operand2, span), flow_state);\n+                self.consume_operand(location, (operand1, span), flow_state);\n+                self.consume_operand(location, (operand2, span), flow_state);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n@@ -1326,7 +1323,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 for operand in operands {\n-                    self.consume_operand(context, (operand, span), flow_state);\n+                    self.consume_operand(location, (operand, span), flow_state);\n                 }\n             }\n         }\n@@ -1407,7 +1404,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn consume_operand(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (operand, span): (&Operand<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1416,7 +1413,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // copy of place: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n@@ -1425,7 +1422,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1434,7 +1431,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Operand::Move(ref place) => {\n                 // move of place: check if this is move of already borrowed path\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n                     LocalMutationIsAllowed::Yes,\n@@ -1443,7 +1440,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1457,7 +1454,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// exits\n     fn check_for_invalidation_at_exit(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n     ) {\n@@ -1513,7 +1510,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // of just a span here.\n             let span = self.infcx.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 borrow,\n                 (place, span),\n                 None,\n@@ -1558,7 +1555,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             });\n \n             self.access_place(\n-                ContextKind::Activation.new(location),\n+                location,\n                 (&borrow.borrowed_place, span),\n                 (\n                     Deep,\n@@ -1577,7 +1574,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         local: Local,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1590,14 +1587,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let init = &self.move_data.inits[init_index];\n             let span = init.span(&self.mir);\n             self.report_illegal_reassignment(\n-                context, place_span, span, place_span.0\n+                location, place_span, span, place_span.0\n             );\n         }\n     }\n \n     fn check_if_full_path_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1644,7 +1641,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Ok((prefix, mpi)) => {\n                 if maybe_uninits.contains(mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n-                        context,\n+                        location,\n                         desired_action,\n                         (prefix, place_span.0, place_span.1),\n                         mpi,\n@@ -1665,7 +1662,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_path_or_subpath_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1687,7 +1684,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //    must have been initialized for the use to be sound.\n         // 6. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n \n-        self.check_if_full_path_is_moved(context, desired_action, place_span, flow_state);\n+        self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);\n \n         // A move of any shallow suffix of `place` also interferes\n         // with an attempt to use `place`. This is scenario 3 above.\n@@ -1702,7 +1699,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n             if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved_or_uninitialized(\n-                    context,\n+                    location,\n                     desired_action,\n                     (place_span.0, place_span.0, place_span.1),\n                     child_mpi,\n@@ -1753,7 +1750,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_assigned_path_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1781,16 +1778,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // assigning to (*P) requires P to be initialized\n                         ProjectionElem::Deref => {\n                             self.check_if_full_path_is_moved(\n-                                context, InitializationRequiringAction::Use,\n+                                location, InitializationRequiringAction::Use,\n                                 (base, span), flow_state);\n                             // (base initialized; no need to\n                             // recur further)\n                             break;\n                         }\n \n                         ProjectionElem::Subslice { .. } => {\n-                            panic!(\"we don't allow assignments to subslices, context: {:?}\",\n-                                   context);\n+                            panic!(\"we don't allow assignments to subslices, location: {:?}\",\n+                                   location);\n                         }\n \n                         ProjectionElem::Field(..) => {\n@@ -1801,7 +1798,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             match base.ty(self.mir, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n-                                        context, InitializationRequiringAction::Assignment,\n+                                        location, InitializationRequiringAction::Assignment,\n                                         (base, span), flow_state);\n \n                                     // (base initialized; no need to\n@@ -1813,7 +1810,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 // Once `let s; s.x = V; read(s.x);`,\n                                 // is allowed, remove this match arm.\n                                 ty::Adt(..) | ty::Tuple(..) => {\n-                                    check_parent_of_field(self, context, base, span, flow_state);\n+                                    check_parent_of_field(self, location, base, span, flow_state);\n \n                                     if let Some(local) = place.base_local() {\n                                         // rust-lang/rust#21232,\n@@ -1841,7 +1838,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         fn check_parent_of_field<'cx, 'gcx, 'tcx>(\n             this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-            context: Context,\n+            location: Location,\n             base: &Place<'tcx>,\n             span: Span,\n             flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1907,7 +1904,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                context.loc, this.mir,\n+                                location, this.mir,\n                             )\n                         }) {\n                             return;\n@@ -1916,7 +1913,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 this.report_use_of_moved_or_uninitialized(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::PartialAssignment,\n                     (prefix, base, span),\n                     mpi,\n@@ -2234,7 +2231,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Subtle: this is an upvar\n                                     // reference, so it looks like\n                                     // `self.foo` -- we want to double\n-                                    // check that the context `*self`\n+                                    // check that the location `*self`\n                                     // is mutable (i.e., this is not a\n                                     // `Fn` closure).  But if that\n                                     // check succeeds, we want to\n@@ -2331,37 +2328,3 @@ enum Overlap {\n     /// will also be disjoint.\n     Disjoint,\n }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-struct Context {\n-    kind: ContextKind,\n-    loc: Location,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ContextKind {\n-    Activation,\n-    AssignLhs,\n-    AssignRhs,\n-    SetDiscrim,\n-    InlineAsm,\n-    SwitchInt,\n-    Drop,\n-    DropAndReplace,\n-    CallOperator,\n-    CallOperand,\n-    CallDest,\n-    Assert,\n-    Yield,\n-    FakeRead,\n-    StorageDead,\n-}\n-\n-impl ContextKind {\n-    fn new(self, loc: Location) -> Context {\n-        Context {\n-            kind: self,\n-            loc,\n-        }\n-    }\n-}"}, {"sha": "c64d4b4a531e046994e7a39e6ef4737c87e916c8", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -4,7 +4,7 @@ use crate::borrow_check::borrow_set::BorrowData;\n use crate::borrow_check::error_reporting::UseSpans;\n use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n-use crate::borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n+use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n     CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, PlaceBase,\n     Projection, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n@@ -209,27 +209,27 @@ impl BorrowExplanation {\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Returns structured explanation for *why* the borrow contains the\n-    /// point from `context`. This is key for the \"3-point errors\"\n+    /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n     ///\n     /// # Parameters\n     ///\n     /// - `borrow`: the borrow in question\n-    /// - `context`: where the borrow occurs\n+    /// - `location`: where the borrow occurs\n     /// - `kind_place`: if Some, this describes the statement that triggered the error.\n     ///   - first half is the kind of write, if any, being performed\n     ///   - second half is the place being accessed\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in crate::borrow_check) fn explain_why_borrow_contains_point(\n         &self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> BorrowExplanation {\n         debug!(\n-            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n-            context, borrow, kind_place\n+            \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n+            location, borrow, kind_place\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n@@ -242,20 +242,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             borrow_region_vid\n         );\n \n-        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n+        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\",\n             region_sub\n         );\n \n-        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+        match find_use::find(mir, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n                 let spans = self\n                     .move_spans(&Place::Base(PlaceBase::Local(local)), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                let borrow_location = context.loc;\n+                let borrow_location = location;\n                 if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n                     let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)"}, {"sha": "e3ab48ccff15b0a3f812fa77122c4996b9e89dcb", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -3,7 +3,6 @@ use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::{JustWrite, WriteAndRead};\n use crate::borrow_check::{AccessDepth, Deep, Shallow};\n use crate::borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n-use crate::borrow_check::{Context, ContextKind};\n use crate::borrow_check::{LocalMutationIsAllowed, MutateMode};\n use crate::borrow_check::ArtificialField;\n use crate::borrow_check::{ReadKind, WriteKind};\n@@ -66,12 +65,12 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         match statement.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 self.consume_rvalue(\n-                    ContextKind::AssignRhs.new(location),\n+                    location,\n                     rhs,\n                 );\n \n                 self.mutate_place(\n-                    ContextKind::AssignLhs.new(location),\n+                    location,\n                     lhs,\n                     Shallow(None),\n                     JustWrite\n@@ -85,35 +84,34 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 variant_index: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::SetDiscrim.new(location),\n+                    location,\n                     place,\n                     Shallow(None),\n                     JustWrite,\n                 );\n             }\n             StatementKind::InlineAsm(ref asm) => {\n-                let context = ContextKind::InlineAsm.new(location);\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n-                            context,\n+                            location,\n                             output,\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                         );\n                     } else {\n                         self.mutate_place(\n-                            context,\n+                            location,\n                             output,\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                         );\n                     }\n                 }\n                 for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(context, input);\n+                    self.consume_operand(location, input);\n                 }\n             }\n             StatementKind::Nop |\n@@ -125,7 +123,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             }\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n-                    ContextKind::StorageDead.new(location),\n+                    location,\n                     &Place::Base(PlaceBase::Local(local)),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -150,15 +148,15 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 values: _,\n                 targets: _,\n             } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(location), discr);\n+                self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop {\n                 location: ref drop_place,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.access_place(\n-                    ContextKind::Drop.new(location),\n+                    location,\n                     drop_place,\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -171,13 +169,13 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 unwind: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::DropAndReplace.new(location),\n+                    location,\n                     drop_place,\n                     Deep,\n                     JustWrite,\n                 );\n                 self.consume_operand(\n-                    ContextKind::DropAndReplace.new(location),\n+                    location,\n                     new_value,\n                 );\n             }\n@@ -188,13 +186,13 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                self.consume_operand(ContextKind::CallOperator.new(location), func);\n+                self.consume_operand(location, func);\n                 for arg in args {\n-                    self.consume_operand(ContextKind::CallOperand.new(location), arg);\n+                    self.consume_operand(location, arg);\n                 }\n                 if let Some((ref dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(\n-                        ContextKind::CallDest.new(location),\n+                        location,\n                         dest,\n                         Deep,\n                         JustWrite,\n@@ -208,19 +206,19 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 target: _,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::Assert.new(location), cond);\n+                self.consume_operand(location, cond);\n                 use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    self.consume_operand(ContextKind::Assert.new(location), len);\n-                    self.consume_operand(ContextKind::Assert.new(location), index);\n+                    self.consume_operand(location, len);\n+                    self.consume_operand(location, index);\n                 }\n             }\n             TerminatorKind::Yield {\n                 ref value,\n                 resume,\n                 drop: _,\n             } => {\n-                self.consume_operand(ContextKind::Yield.new(location), value);\n+                self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n@@ -264,13 +262,13 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates mutation of a place.\n     fn mutate_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         kind: AccessDepth,\n         _mode: MutateMode,\n     ) {\n         self.access_place(\n-            context,\n+            location,\n             place,\n             (kind, Write(WriteKind::Mutate)),\n             LocalMutationIsAllowed::ExceptUpvars,\n@@ -280,21 +278,21 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates consumption of an operand.\n     fn consume_operand(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         operand: &Operand<'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }\n             Operand::Move(ref place) => {\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Deep, Write(WriteKind::Move)),\n                     LocalMutationIsAllowed::Yes,\n@@ -307,7 +305,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     // Simulates consumption of an rvalue\n     fn consume_rvalue(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         rvalue: &Rvalue<'tcx>,\n     ) {\n         match *rvalue {\n@@ -328,7 +326,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 };\n \n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n@@ -339,7 +337,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n             | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n-                self.consume_operand(context, operand)\n+                self.consume_operand(location, operand)\n             }\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n@@ -349,7 +347,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n@@ -358,16 +356,16 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n             | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, operand1);\n-                self.consume_operand(context, operand2);\n+                self.consume_operand(location, operand1);\n+                self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n             }\n \n             Rvalue::Aggregate(_, ref operands) => {\n                 for operand in operands {\n-                    self.consume_operand(context, operand);\n+                    self.consume_operand(location, operand);\n                 }\n             }\n         }\n@@ -376,27 +374,27 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates an access to a place.\n     fn access_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         kind: (AccessDepth, ReadOrWrite),\n         _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n         let (sd, rw) = kind;\n         // note: not doing check_access_permissions checks because they don't generate invalidates\n-        self.check_access_for_conflict(context, place, sd, rw);\n+        self.check_access_for_conflict(location, place, sd, rw);\n     }\n \n     fn check_access_for_conflict(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n     ) {\n         debug!(\n-            \"invalidation::check_access_for_conflict(context={:?}, place={:?}, sd={:?}, \\\n+            \"invalidation::check_access_for_conflict(location={:?}, place={:?}, sd={:?}, \\\n              rw={:?})\",\n-            context,\n+            location,\n             place,\n             sd,\n             rw,\n@@ -409,7 +407,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             self,\n             tcx,\n             mir,\n-            context,\n+            location,\n             (sd, place),\n             &borrow_set.clone(),\n             indices,\n@@ -435,15 +433,15 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n                     (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n                         // Reading from mere reservations of mutable-borrows is OK.\n-                        if !is_active(&this.dominators, borrow, context.loc) {\n+                        if !is_active(&this.dominators, borrow, location) {\n                             // If the borrow isn't active yet, reads don't invalidate it\n                             assert!(allow_two_phase_borrow(borrow.kind));\n                             return Control::Continue;\n                         }\n \n                         // Unique and mutable borrows are invalidated by reads from any\n                         // involved path\n-                        this.generate_invalidates(borrow_index, context.loc);\n+                        this.generate_invalidates(borrow_index, location);\n                     }\n \n                     (Reservation(_), _)\n@@ -453,7 +451,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                         // Reservations count as writes since we need to check\n                         // that activating the borrow will be OK\n                         // FIXME(bob_twinkles) is this actually the right thing to do?\n-                        this.generate_invalidates(borrow_index, context.loc);\n+                        this.generate_invalidates(borrow_index, location);\n                     }\n                 }\n                 Control::Continue\n@@ -485,7 +483,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             });\n \n             self.access_place(\n-                ContextKind::Activation.new(location),\n+                location,\n                 &borrow.borrowed_place,\n                 (\n                     Deep,"}, {"sha": "0c2a4ef45f104f3986d33da833a689eb1e30913c", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -1,6 +1,5 @@\n use crate::borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseActivation};\n use crate::borrow_check::places_conflict;\n-use crate::borrow_check::Context;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase};\n@@ -27,7 +26,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     s: &mut S,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    _context: Context,\n+    _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n     candidates: I,"}, {"sha": "681a204d76e1d64d4778eda5da65cb50f4b6bb54", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = mk_eval_cx(tcx, span, param_env);\n-    eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n+    eval_body_using_ecx(&mut ecx, cid, mir, param_env)\n }\n \n fn mplace_to_const<'tcx>(\n@@ -107,37 +107,15 @@ fn op_to_const<'tcx>(\n     ty::Const { val, ty: op.layout.ty }\n }\n \n-fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cid: GlobalId<'tcx>,\n-    mir: Option<&'mir mir::Mir<'tcx>>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, MPlaceTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n-    // we start out with the best span we have\n-    // and try improving it down the road when more information is available\n-    let span = tcx.def_span(cid.instance.def_id());\n-    let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n-    let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n-    (r, ecx)\n-}\n-\n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n-    mir: Option<&'mir mir::Mir<'tcx>>,\n+    mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n-    let mut mir = match mir {\n-        Some(mir) => mir,\n-        None => ecx.load_mir(cid.instance.def)?,\n-    };\n-    if let Some(index) = cid.promoted {\n-        mir = &mir.promoted[index];\n-    }\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -618,8 +596,19 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n         return Err(ErrorHandled::Reported);\n     }\n \n-    let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|place| {\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut ecx = InterpretCx::new(tcx.at(span), key.param_env, CompileTimeInterpreter::new());\n+\n+    let res = ecx.load_mir(cid.instance.def);\n+    res.map(|mir| {\n+        if let Some(index) = cid.promoted {\n+            &mir.promoted[index]\n+        } else {\n+            mir\n+        }\n+    }).and_then(\n+        |mir| eval_body_using_ecx(&mut ecx, cid, mir, key.param_env)\n+    ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.to_ptr().expect(\"we allocated this ptr!\").alloc_id,\n             ty: place.layout.ty"}, {"sha": "2465adf46cdf436781ddef8c5b36154a38fbf54d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -301,7 +301,8 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n                 let res = self.use_ecx(source_info, |this| {\n-                    eval_promoted(this.tcx, cid, this.mir, this.param_env)\n+                    let mir = &this.mir.promoted[promoted];\n+                    eval_promoted(this.tcx, cid, mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n                 Some((res.into(), source_info.span))"}, {"sha": "dcfe00069c5bd263b0497ce81dc0b562b36124ff", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -862,7 +862,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n         // normal arguments.\n         if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for a in arguments { add_argument(&a.arg); }\n+            for (i, a) in arguments.iter().enumerate() {\n+                if let Some(arg) = &a.arg {\n+                    add_argument(&arg);\n+                } else {\n+                    add_argument(&declaration.inputs[i]);\n+                }\n+            }\n         } else {\n             for a in &declaration.inputs { add_argument(a); }\n         }\n@@ -882,8 +888,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     let mut body = body.clone();\n                     // Insert the generated statements into the body before attempting to\n                     // resolve names.\n-                    for a in arguments {\n-                        body.stmts.insert(0, a.stmt.clone());\n+                    for a in arguments.iter().rev() {\n+                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n+                            body.stmts.insert(0, pat_stmt);\n+                        }\n+                        body.stmts.insert(0, a.move_stmt.clone());\n                     }\n                     self.visit_block(&body);\n                 } else {\n@@ -4174,7 +4183,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if filter_fn(binding.def()) {\n+                    if !ident.name.is_gensymed() && filter_fn(binding.def()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.def().article(),\n@@ -4192,7 +4201,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, def) in &rib.bindings {\n-                    if filter_fn(*def) {\n+                    if !ident.name.is_gensymed() && filter_fn(*def) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: def.article(),\n@@ -4219,7 +4228,7 @@ impl<'a> Resolver<'a> {\n                                             index: CRATE_DEF_INDEX,\n                                         });\n \n-                                        if filter_fn(crate_mod) {\n+                                        if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4242,13 +4251,16 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Def::PrimTy(Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n-                        TypoSuggestion {\n-                            candidate: *name,\n-                            article: \"a\",\n-                            kind: \"primitive type\",\n-                        }\n-                    })\n+                    self.primitive_type_table.primitive_types\n+                        .iter()\n+                        .filter(|(name, _)| !name.is_gensymed())\n+                        .map(|(name, _)| {\n+                            TypoSuggestion {\n+                                candidate: *name,\n+                                article: \"a\",\n+                                kind: \"primitive type\",\n+                            }\n+                        })\n                 )\n             }\n         } else {"}, {"sha": "6e4c6e4c366e4e2cae01d0a7cb2a9f82b88d483f", "filename": "src/libstd/process.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -134,6 +134,18 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// the parent process wait until the child has actually exited before\n /// continuing.\n ///\n+/// # Warning\n+///\n+/// On some system, calling [`wait`] or similar is necessary for the OS to\n+/// release resources. A process that terminated but has not been waited on is\n+/// still around as a \"zombie\". Leaving too many zombies around may exhaust\n+/// global resources (for example process IDs).\n+///\n+/// The standard library does *not* automatically wait on child processes (not\n+/// even if the `Child` is dropped), it is up to the application developer to do\n+/// so. As a consequence, dropping `Child` handles without waiting on them first\n+/// is not recommended in long-running applications.\n+///\n /// # Examples\n ///\n /// ```should_panic"}, {"sha": "33b8c76bb531a2a6fc9219eb373bec20d0fad763", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -1865,10 +1865,14 @@ pub enum Unsafety {\n pub struct AsyncArgument {\n     /// `__arg0`\n     pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`.\n-    pub arg: Arg,\n-    /// `let <pat>: <ty> = __arg0;` statement to be inserted at the start of the block.\n-    pub stmt: Stmt,\n+    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n+    /// argument is not a simple binding.\n+    pub arg: Option<Arg>,\n+    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n+    pub move_stmt: Stmt,\n+    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n+    /// move statement. Only if argument is not a simple binding.\n+    pub pat_stmt: Option<Stmt>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "e2d212eb721ff9cadcbb26ef5eb0e58a8b091d87", "filename": "src/libsyntax/error_codes.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -363,6 +363,35 @@ and likely to change in the future.\n \n \"##,\n \n+E0704: r##\"\n+This error indicates that a incorrect visibility restriction was specified.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0704\n+mod foo {\n+    pub(foo) struct Bar {\n+        x: i32\n+    }\n+}\n+```\n+\n+To make struct `Bar` only visible in module `foo` the `in` keyword should be\n+used:\n+```\n+mod foo {\n+    pub(in crate::foo) struct Bar {\n+        x: i32\n+    }\n+}\n+# fn main() {}\n+```\n+\n+For more information see the Rust Reference on [Visibility].\n+\n+[Visibility]: https://doc.rust-lang.org/reference/visibility-and-privacy.html\n+\"##,\n+\n E0705: r##\"\n A `#![feature]` attribute was declared for a feature that is stable in\n the current edition, but not in all editions.\n@@ -417,6 +446,5 @@ register_diagnostics! {\n     E0693, // incorrect `repr(align)` attribute format\n     E0694, // an unknown tool name found in scoped attributes\n     E0703, // invalid ABI\n-    E0704, // incorrect visibility restriction\n     E0717, // rustc_promotable without stability attribute\n }"}, {"sha": "f5e18e98436e6e1b222ca0eabca59fb3e3074afb", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -199,7 +199,10 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n         if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n             for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.stmt.id);\n+                self.next_id(&mut argument.move_stmt.id);\n+                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n+                    self.next_id(&mut pat_stmt.id);\n+                }\n             }\n         }\n     }"}, {"sha": "2e09235ca77b0a72bbcb1463778789e73e747164", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -694,13 +694,21 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n         IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, stmt } in arguments.iter_mut() {\n+            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n                 vis.visit_ident(ident);\n-                vis.visit_arg(arg);\n-                visit_clobber(stmt, |stmt| {\n+                if let Some(arg) = arg {\n+                    vis.visit_arg(arg);\n+                }\n+                visit_clobber(move_stmt, |stmt| {\n                     vis.flat_map_stmt(stmt)\n                         .expect_one(\"expected visitor to produce exactly one item\")\n                 });\n+                visit_opt(pat_stmt, |stmt| {\n+                    visit_clobber(stmt, |stmt| {\n+                        vis.flat_map_stmt(stmt)\n+                            .expect_one(\"expected visitor to produce exactly one item\")\n+                    })\n+                });\n             }\n         }\n         IsAsync::NotAsync => {}"}, {"sha": "32e1ee94f0dfb702f8ce3667b888e73a95c322d7", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -0,0 +1,226 @@\n+use crate::ast;\n+use crate::ast::{Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n+use crate::parse::parser::PathStyle;\n+use crate::parse::token;\n+use crate::parse::PResult;\n+use crate::parse::Parser;\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::ThinVec;\n+use errors::Applicability;\n+use syntax_pos::Span;\n+\n+pub trait RecoverQPath: Sized + 'static {\n+    const PATH_STYLE: PathStyle = PathStyle::Expr;\n+    fn to_ty(&self) -> Option<P<Ty>>;\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n+}\n+\n+impl RecoverQPath for Ty {\n+    const PATH_STYLE: PathStyle = PathStyle::Type;\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        Some(P(self.clone()))\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: TyKind::Path(qself, path),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl RecoverQPath for Pat {\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        self.to_ty()\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: PatKind::Path(qself, path),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl RecoverQPath for Expr {\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        self.to_ty()\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: ExprKind::Path(qself, path),\n+            attrs: ThinVec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    crate fn maybe_report_ambiguous_plus(\n+        &mut self,\n+        allow_plus: bool,\n+        impl_dyn_multi: bool,\n+        ty: &Ty,\n+    ) {\n+        if !allow_plus && impl_dyn_multi {\n+            let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n+            self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n+                .span_suggestion(\n+                    ty.span,\n+                    \"use parentheses to disambiguate\",\n+                    sum_with_parens,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    crate fn maybe_recover_from_bad_type_plus(\n+        &mut self,\n+        allow_plus: bool,\n+        ty: &Ty,\n+    ) -> PResult<'a, ()> {\n+        // Do not add `+` to expected tokens.\n+        if !allow_plus || !self.token.is_like_plus() {\n+            return Ok(());\n+        }\n+\n+        self.bump(); // `+`\n+        let bounds = self.parse_generic_bounds(None)?;\n+        let sum_span = ty.span.to(self.prev_span);\n+\n+        let mut err = struct_span_err!(\n+            self.sess.span_diagnostic,\n+            sum_span,\n+            E0178,\n+            \"expected a path on the left-hand side of `+`, not `{}`\",\n+            pprust::ty_to_string(ty)\n+        );\n+\n+        match ty.node {\n+            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n+                let sum_with_parens = pprust::to_string(|s| {\n+                    use crate::print::pprust::PrintState;\n+\n+                    s.s.word(\"&\")?;\n+                    s.print_opt_lifetime(lifetime)?;\n+                    s.print_mutability(mut_ty.mutbl)?;\n+                    s.popen()?;\n+                    s.print_type(&mut_ty.ty)?;\n+                    s.print_type_bounds(\" +\", &bounds)?;\n+                    s.pclose()\n+                });\n+                err.span_suggestion(\n+                    sum_span,\n+                    \"try adding parentheses\",\n+                    sum_with_parens,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            TyKind::Ptr(..) | TyKind::BareFn(..) => {\n+                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n+            }\n+            _ => {\n+                err.span_label(sum_span, \"expected a path\");\n+            }\n+        }\n+        err.emit();\n+        Ok(())\n+    }\n+\n+    /// Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n+    /// Attempt to convert the base expression/pattern/type into a type, parse the `::AssocItem`\n+    /// tail, and combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    crate fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n+        &mut self,\n+        base: P<T>,\n+        allow_recovery: bool,\n+    ) -> PResult<'a, P<T>> {\n+        // Do not add `::` to expected tokens.\n+        if allow_recovery && self.token == token::ModSep {\n+            if let Some(ty) = base.to_ty() {\n+                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n+            }\n+        }\n+        Ok(base)\n+    }\n+\n+    /// Given an already parsed `Ty` parse the `::AssocItem` tail and\n+    /// combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    crate fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(\n+        &mut self,\n+        ty_span: Span,\n+        ty: P<Ty>,\n+    ) -> PResult<'a, P<T>> {\n+        self.expect(&token::ModSep)?;\n+\n+        let mut path = ast::Path {\n+            segments: Vec::new(),\n+            span: syntax_pos::DUMMY_SP,\n+        };\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n+        path.span = ty_span.to(self.prev_span);\n+\n+        let ty_str = self\n+            .sess\n+            .source_map()\n+            .span_to_snippet(ty_span)\n+            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n+        self.diagnostic()\n+            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n+            .span_suggestion(\n+                // this is a best-effort recovery\n+                path.span,\n+                \"try\",\n+                format!(\"<{}>::{}\", ty_str, path),\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n+\n+        let path_span = ty_span.shrink_to_hi(); // use an empty path since `position` == 0\n+        Ok(P(T::recovered(\n+            Some(QSelf {\n+                ty,\n+                path_span,\n+                position: 0,\n+            }),\n+            path,\n+        )))\n+    }\n+\n+    crate fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n+        if self.eat(&token::Semi) {\n+            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n+            err.span_suggestion_short(\n+                self.prev_span,\n+                \"remove this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            if !items.is_empty() {\n+                let previous_item = &items[items.len() - 1];\n+                let previous_item_kind_name = match previous_item.node {\n+                    // say \"braced struct\" because tuple-structs and\n+                    // braceless-empty-struct declarations do take a semicolon\n+                    ItemKind::Struct(..) => Some(\"braced struct\"),\n+                    ItemKind::Enum(..) => Some(\"enum\"),\n+                    ItemKind::Trait(..) => Some(\"trait\"),\n+                    ItemKind::Union(..) => Some(\"union\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = previous_item_kind_name {\n+                    err.help(&format!(\n+                        \"{} declarations are not followed by a semicolon\",\n+                        name\n+                    ));\n+                }\n+            }\n+            err.emit();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "85a74df23573835841136af4b92ad1feb8fbc56e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -30,6 +30,7 @@ pub mod parser;\n pub mod lexer;\n pub mod token;\n pub mod attr;\n+pub mod diagnostics;\n \n pub mod classify;\n "}, {"sha": "f70acb3e7da9a3cfc0a6eff34c4bf0725df494d1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 53, "deletions": 177, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -189,41 +189,6 @@ enum PrevTokenKind {\n     Other,\n }\n \n-trait RecoverQPath: Sized + 'static {\n-    const PATH_STYLE: PathStyle = PathStyle::Expr;\n-    fn to_ty(&self) -> Option<P<Ty>>;\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n-}\n-\n-impl RecoverQPath for Ty {\n-    const PATH_STYLE: PathStyle = PathStyle::Type;\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        Some(P(self.clone()))\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: TyKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n-impl RecoverQPath for Pat {\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        self.to_ty()\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: PatKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n-impl RecoverQPath for Expr {\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        self.to_ty()\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: ExprKind::Path(qself, path),\n-               attrs: ThinVec::new(), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n /* ident is handled by common.rs */\n \n #[derive(Clone)]\n@@ -1479,7 +1444,7 @@ impl<'a> Parser<'a> {\n     fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n-    fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n     fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n@@ -1882,99 +1847,6 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n-    fn maybe_report_ambiguous_plus(&mut self, allow_plus: bool, impl_dyn_multi: bool, ty: &Ty) {\n-        if !allow_plus && impl_dyn_multi {\n-            let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n-            self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n-                .span_suggestion(\n-                    ty.span,\n-                    \"use parentheses to disambiguate\",\n-                    sum_with_parens,\n-                    Applicability::MachineApplicable\n-                ).emit();\n-        }\n-    }\n-\n-    fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n-        // Do not add `+` to expected tokens.\n-        if !allow_plus || !self.token.is_like_plus() {\n-            return Ok(())\n-        }\n-\n-        self.bump(); // `+`\n-        let bounds = self.parse_generic_bounds(None)?;\n-        let sum_span = ty.span.to(self.prev_span);\n-\n-        let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n-            \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(ty));\n-\n-        match ty.node {\n-            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n-                let sum_with_parens = pprust::to_string(|s| {\n-                    use crate::print::pprust::PrintState;\n-\n-                    s.s.word(\"&\")?;\n-                    s.print_opt_lifetime(lifetime)?;\n-                    s.print_mutability(mut_ty.mutbl)?;\n-                    s.popen()?;\n-                    s.print_type(&mut_ty.ty)?;\n-                    s.print_type_bounds(\" +\", &bounds)?;\n-                    s.pclose()\n-                });\n-                err.span_suggestion(\n-                    sum_span,\n-                    \"try adding parentheses\",\n-                    sum_with_parens,\n-                    Applicability::MachineApplicable\n-                );\n-            }\n-            TyKind::Ptr(..) | TyKind::BareFn(..) => {\n-                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n-            }\n-            _ => {\n-                err.span_label(sum_span, \"expected a path\");\n-            },\n-        }\n-        err.emit();\n-        Ok(())\n-    }\n-\n-    /// Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n-    /// Attempt to convert the base expression/pattern/type into a type, parse the `::AssocItem`\n-    /// tail, and combine them into a `<Ty>::AssocItem` expression/pattern/type.\n-    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: P<T>, allow_recovery: bool)\n-                                                     -> PResult<'a, P<T>> {\n-        // Do not add `::` to expected tokens.\n-        if allow_recovery && self.token == token::ModSep {\n-            if let Some(ty) = base.to_ty() {\n-                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n-            }\n-        }\n-        Ok(base)\n-    }\n-\n-    /// Given an already parsed `Ty` parse the `::AssocItem` tail and\n-    /// combine them into a `<Ty>::AssocItem` expression/pattern/type.\n-    fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(&mut self, ty_span: Span, ty: P<Ty>)\n-                                                             -> PResult<'a, P<T>> {\n-        self.expect(&token::ModSep)?;\n-\n-        let mut path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n-        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n-        path.span = ty_span.to(self.prev_span);\n-\n-        let ty_str = self.sess.source_map().span_to_snippet(ty_span)\n-            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n-        self.diagnostic()\n-            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n-            .span_suggestion( // this is a best-effort recovery\n-                path.span, \"try\", format!(\"<{}>::{}\", ty_str, path), Applicability::MaybeIncorrect\n-            ).emit();\n-\n-        let path_span = ty_span.shrink_to_hi(); // use an empty path since `position` == 0\n-        Ok(P(T::recovered(Some(QSelf { ty, path_span, position: 0 }), path)))\n-    }\n-\n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n         let mutbl = self.parse_mutability();\n@@ -2410,7 +2282,7 @@ impl<'a> Parser<'a> {\n         self.parse_path(style)\n     }\n \n-    fn parse_path_segments(&mut self,\n+    crate fn parse_path_segments(&mut self,\n                            segments: &mut Vec<PathSegment>,\n                            style: PathStyle)\n                            -> PResult<'a, ()> {\n@@ -5815,7 +5687,8 @@ impl<'a> Parser<'a> {\n         return Ok(bounds);\n     }\n \n-    fn parse_generic_bounds(&mut self, colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+    crate fn parse_generic_bounds(&mut self,\n+                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n         self.parse_generic_bounds_common(true, colon_span)\n     }\n \n@@ -7352,37 +7225,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n-        if self.eat(&token::Semi) {\n-            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n-            err.span_suggestion_short(\n-                self.prev_span,\n-                \"remove this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            if !items.is_empty() {\n-                let previous_item = &items[items.len()-1];\n-                let previous_item_kind_name = match previous_item.node {\n-                    // say \"braced struct\" because tuple-structs and\n-                    // braceless-empty-struct declarations do take a semicolon\n-                    ItemKind::Struct(..) => Some(\"braced struct\"),\n-                    ItemKind::Enum(..) => Some(\"enum\"),\n-                    ItemKind::Trait(..) => Some(\"trait\"),\n-                    ItemKind::Union(..) => Some(\"union\"),\n-                    _ => None,\n-                };\n-                if let Some(name) = previous_item_kind_name {\n-                    err.help(&format!(\"{} declarations are not followed by a semicolon\", name));\n-                }\n-            }\n-            err.emit();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Given a termination token, parses all of the items in a module.\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: Span) -> PResult<'a, Mod> {\n         let mut items = vec![];\n@@ -8878,27 +8720,46 @@ impl<'a> Parser<'a> {\n \n                 // Construct a name for our temporary argument.\n                 let name = format!(\"__arg{}\", index);\n-                let ident = Ident::from_str(&name);\n+                let ident = Ident::from_str(&name).gensym();\n+\n+                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n+                // statement.\n+                let (ident, is_simple_pattern) = match input.pat.node {\n+                    PatKind::Ident(_, ident, _) => (ident, true),\n+                    _ => (ident, false),\n+                };\n \n                 // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function.\n-                let arg = Arg {\n-                    ty: input.ty.clone(),\n-                    id,\n+                // async function if it isn't a simple pattern.\n+                let arg = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Arg {\n+                        ty: input.ty.clone(),\n+                        id,\n+                        pat: P(Pat {\n+                            id,\n+                            node: PatKind::Ident(\n+                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n+                            ),\n+                            span,\n+                        }),\n+                        source: ArgSource::AsyncFn(input.pat.clone()),\n+                    })\n+                };\n+\n+                // Construct a `let __argN = __argN;` statement to insert at the top of the\n+                // async closure. This makes sure that the argument is captured by the closure and\n+                // that the drop order is correct.\n+                let move_local = Local {\n                     pat: P(Pat {\n                         id,\n                         node: PatKind::Ident(\n                             BindingMode::ByValue(Mutability::Immutable), ident, None,\n                         ),\n                         span,\n                     }),\n-                    source: ArgSource::AsyncFn(input.pat.clone()),\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure.\n-                let local = P(Local {\n-                    pat: input.pat.clone(),\n                     // We explicitly do not specify the type for this statement. When the user's\n                     // argument type is `impl Trait` then this would require the\n                     // `impl_trait_in_bindings` feature to also be present for that same type to\n@@ -8918,10 +8779,25 @@ impl<'a> Parser<'a> {\n                     span,\n                     attrs: ThinVec::new(),\n                     source: LocalSource::AsyncFn,\n-                });\n-                let stmt = Stmt { id, node: StmtKind::Local(local), span, };\n+                };\n+\n+                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n+                // async closure if this isn't a simple pattern.\n+                let pat_stmt = if is_simple_pattern {\n+                    None\n+                } else {\n+                    Some(Stmt {\n+                        id,\n+                        node: StmtKind::Local(P(Local {\n+                            pat: input.pat.clone(),\n+                            ..move_local.clone()\n+                        })),\n+                        span,\n+                    })\n+                };\n \n-                arguments.push(AsyncArgument { ident, arg, stmt });\n+                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n+                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n             }\n         }\n     }"}, {"sha": "4e43aa96e1d853895e90754a9cd747a36fb83d12", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -15,7 +15,7 @@ use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -61,6 +61,8 @@ impl CodegenBackend for TheBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _metadata: EncodedMetadata,\n+        _need_metadata_module: bool,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n     ) -> Box<Any> {\n         use rustc::hir::def_id::LOCAL_CRATE;"}, {"sha": "961c412f5ecb2751bf86551d087beb84becbf77a", "filename": "src/test/run-pass/issue-54716.rs", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ea68bee369c9ebc0de35abcd39211fa0d4f9c84f/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68bee369c9ebc0de35abcd39211fa0d4f9c84f/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=ea68bee369c9ebc0de35abcd39211fa0d4f9c84f", "patch": "@@ -1,184 +0,0 @@\n-// aux-build:arc_wake.rs\n-// edition:2018\n-// run-pass\n-\n-#![allow(unused_variables)]\n-#![feature(async_await, await_macro)]\n-\n-extern crate arc_wake;\n-\n-use arc_wake::ArcWake;\n-use std::cell::RefCell;\n-use std::future::Future;\n-use std::marker::PhantomData;\n-use std::sync::Arc;\n-use std::rc::Rc;\n-use std::task::Context;\n-\n-struct EmptyWaker;\n-\n-impl ArcWake for EmptyWaker {\n-    fn wake(self: Arc<Self>) {}\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-enum DropOrder {\n-    Function,\n-    Val(&'static str),\n-}\n-\n-type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n-\n-struct D(&'static str, DropOrderListPtr);\n-\n-impl Drop for D {\n-    fn drop(&mut self) {\n-        self.1.borrow_mut().push(DropOrder::Val(self.0));\n-    }\n-}\n-\n-/// Check that unused bindings are dropped after the function is polled.\n-async fn foo(x: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns are dropped after the function is polled.\n-async fn bar(x: D, _: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore patterns within more complex patterns are dropped after the function\n-/// is polled.\n-async fn baz((x, _): (D, D)) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n-/// after the function is polled.\n-async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-    x.1.borrow_mut().push(DropOrder::Function);\n-}\n-\n-struct Foo;\n-\n-impl Foo {\n-    /// Check that unused bindings are dropped after the method is polled.\n-    async fn foo(x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method is polled.\n-    async fn bar(x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// is polled.\n-    async fn baz((x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method is polled.\n-    async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-struct Bar<'a>(PhantomData<&'a ()>);\n-\n-impl<'a> Bar<'a> {\n-    /// Check that unused bindings are dropped after the method with self is polled.\n-    async fn foo(&'a self, x: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns are dropped after the method with self is polled.\n-    async fn bar(&'a self, x: D, _: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore patterns within more complex patterns are dropped after the method\n-    /// with self is polled.\n-    async fn baz(&'a self, (x, _): (D, D)) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-\n-    /// Check that underscore and unused bindings within and outwith more complex patterns are\n-    /// dropped after the method with self is polled.\n-    async fn foobar(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n-        x.1.borrow_mut().push(DropOrder::Function);\n-    }\n-}\n-\n-fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n-    f: impl FnOnce(DropOrderListPtr) -> Fut,\n-    expected_order: &[DropOrder],\n-) {\n-    let empty = Arc::new(EmptyWaker);\n-    let waker = ArcWake::into_waker(empty);\n-    let mut cx = Context::from_waker(&waker);\n-\n-    let actual_order = Rc::new(RefCell::new(Vec::new()));\n-    let mut fut = Box::pin(f(actual_order.clone()));\n-    let _ = fut.as_mut().poll(&mut cx);\n-\n-    assert_eq!(*actual_order.borrow(), expected_order);\n-}\n-\n-fn main() {\n-    use DropOrder::*;\n-\n-    // At time of writing (23/04/19), the `bar` and `foobar` tests do not output the same order as\n-    // the equivalent non-async functions. This is because the drop order of captured variables\n-    // doesn't match the drop order of arguments in a function.\n-\n-    // Free functions (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods w/out self (see doc comment on function for what it tests).\n-    assert_drop_order_after_poll(|l| Foo::foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| Foo::bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| Foo::baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        Foo::foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-\n-    // Methods (see doc comment on function for what it tests).\n-    let b = Bar(Default::default());\n-    assert_drop_order_after_poll(|l| b.foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n-                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n-    assert_drop_order_after_poll(|l| b.bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| b.baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n-                                 &[Function, Val(\"x\"), Val(\"_\")]);\n-    assert_drop_order_after_poll(|l| {\n-        b.foobar(\n-            D(\"x\", l.clone()),\n-            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n-            D(\"_\", l.clone()),\n-            D(\"_y\", l.clone()),\n-        )\n-    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n-}"}, {"sha": "c21886f26f467e2176460fc166f95d0d9ee3cc6c", "filename": "src/test/ui/async-await/auxiliary/arc_wake.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fauxiliary%2Farc_wake.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -0,0 +1,64 @@\n+// edition:2018\n+\n+use std::sync::Arc;\n+use std::task::{\n+    Waker, RawWaker, RawWakerVTable,\n+};\n+\n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable::new(\n+            clone_arc_raw::<$ty>,\n+            wake_arc_raw::<$ty>,\n+            wake_by_ref_arc_raw::<$ty>,\n+            drop_arc_raw::<$ty>,\n+        )\n+    };\n+}\n+\n+pub trait ArcWake {\n+    fn wake(self: Arc<Self>);\n+\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.clone().wake()\n+    }\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const ();\n+\n+        unsafe {\n+            Waker::from_raw(RawWaker::new(ptr, waker_vtable!(Self)))\n+        }\n+    }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n+\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker::new(data, waker_vtable!(T))\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(arc);\n+}\n+\n+unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake_by_ref(&arc);\n+    let _ = Arc::into_raw(arc);\n+}"}, {"sha": "708c570498460147de3cac9a1f6a884452d7966b", "filename": "src/test/ui/async-await/drop-order-for-async-fn-parameters.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-for-async-fn-parameters.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -0,0 +1,263 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![feature(async_await, await_macro)]\n+\n+// Test that the drop order for parameters in a fn and async fn matches up. Also test that\n+// parameters (used or unused) are not dropped until the async fn completes execution.\n+// See also #54716.\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::sync::Arc;\n+use std::rc::Rc;\n+use std::task::Context;\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+/// Check that unused bindings are dropped after the function is polled.\n+async fn foo_async(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foo_sync(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns are dropped after the function is polled.\n+async fn bar_async(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn bar_sync(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n+async fn baz_async((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn baz_sync((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n+async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n+    async fn foo_async(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method is polled.\n+    async fn bar_async(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n+    async fn baz_async((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n+    async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+struct Bar<'a>(PhantomData<&'a ()>);\n+\n+impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n+    async fn foo_async(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foo_sync(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method with self is polled.\n+    async fn bar_async(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn bar_sync(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n+    async fn baz_async(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn baz_sync(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n+    async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    fn foobar_sync(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| Foo::foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| Foo::foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| Foo::bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| Foo::baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| Foo::baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            Foo::foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            Foo::foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods (see doc comment on function for what it tests).\n+    let b = Bar(Default::default());\n+    assert_drop_order_after_poll(|l| b.foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 |l| b.foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 |l| b.bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())));\n+    assert_drop_order_after_poll(|l| b.baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 |l| b.baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))));\n+    assert_drop_order_after_poll(\n+        |l| {\n+            b.foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            b.foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+}"}, {"sha": "10dc5e27f6f9f26763d31fd723d64cc16a20a4fe", "filename": "src/test/ui/async-await/drop-order-locals-are-hidden.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.rs?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#![allow(unused_variables)]\n+#![feature(async_await)]\n+\n+async fn foobar_async(x: u32, (a, _, _c): (u32, u32, u32), _: u32, _y: u32) {\n+    assert_eq!(__arg1, (1, 2, 3)); //~ ERROR cannot find value `__arg1` in this scope [E0425]\n+    assert_eq!(__arg2, 4); //~ ERROR cannot find value `__arg2` in this scope [E0425]\n+}\n+\n+fn main() {}"}, {"sha": "ca0da6b7c962add94c48989232011b95477ca0b0", "filename": "src/test/ui/async-await/drop-order-locals-are-hidden.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order-locals-are-hidden.stderr?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -0,0 +1,15 @@\n+error[E0425]: cannot find value `__arg1` in this scope\n+  --> $DIR/drop-order-locals-are-hidden.rs:7:16\n+   |\n+LL |     assert_eq!(__arg1, (1, 2, 3));\n+   |                ^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `__arg2` in this scope\n+  --> $DIR/drop-order-locals-are-hidden.rs:8:16\n+   |\n+LL |     assert_eq!(__arg2, 4);\n+   |                ^^^^^^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "7eeefa9550543860a179d9e200bb5e8e7cac9582", "filename": "src/test/ui/pub/pub-restricted.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/767f59462663fbc55a69d39fc5e1f7f83b6fb37d/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr?ref=767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "patch": "@@ -50,3 +50,4 @@ LL |         pub (in x) non_parent_invalid: usize,\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0704`."}]}