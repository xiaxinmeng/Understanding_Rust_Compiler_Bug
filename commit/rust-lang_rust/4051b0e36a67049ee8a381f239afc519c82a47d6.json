{"sha": "4051b0e36a67049ee8a381f239afc519c82a47d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTFiMGUzNmE2NzA0OWVlOGEzODFmMjM5YWZjNTE5YzgyYTQ3ZDY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-11T09:17:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-11T09:17:58Z"}, "message": "Merge pull request #53 from oli-obk/dont_touch_my_precious_constants\n\nDetect modifications of immutable memory", "tree": {"sha": "99289d9d82a8d16c8362b10f3d51335dd327c1fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99289d9d82a8d16c8362b10f3d51335dd327c1fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4051b0e36a67049ee8a381f239afc519c82a47d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4051b0e36a67049ee8a381f239afc519c82a47d6", "html_url": "https://github.com/rust-lang/rust/commit/4051b0e36a67049ee8a381f239afc519c82a47d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4051b0e36a67049ee8a381f239afc519c82a47d6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db7d842fb3b9ae51f1f4e155b5779503ca3a2bb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/db7d842fb3b9ae51f1f4e155b5779503ca3a2bb4", "html_url": "https://github.com/rust-lang/rust/commit/db7d842fb3b9ae51f1f4e155b5779503ca3a2bb4"}, {"sha": "3c5f595d45917152bbb8e5217ddef94930deb5b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c5f595d45917152bbb8e5217ddef94930deb5b6", "html_url": "https://github.com/rust-lang/rust/commit/3c5f595d45917152bbb8e5217ddef94930deb5b6"}], "stats": {"total": 104, "additions": 87, "deletions": 17}, "files": [{"sha": "e9312a1ef3e643026b002db8ac7fb3e7215e4bb8", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -42,6 +42,7 @@ pub enum EvalError<'tcx> {\n     },\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n+    ModifiedConstantMemory,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -94,6 +95,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to call a closure through a function pointer\",\n             EvalError::VtableForArgumentlessMethod =>\n                 \"tried to call a vtable function without arguments\",\n+            EvalError::ModifiedConstantMemory =>\n+                \"tried to modify constant memory\",\n         }\n     }\n "}, {"sha": "6ba465cb5990cffb33e17cbb8aa743c688d38bf4", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -15,7 +15,7 @@ use std::iter;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, AllocId};\n use primval::{self, PrimVal};\n \n use std::collections::HashMap;\n@@ -74,7 +74,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub return_ptr: Option<Pointer>,\n \n     /// The block to return to when returning from the current stack frame\n-    pub return_to_block: Option<mir::BasicBlock>,\n+    pub return_to_block: StackPopCleanup,\n \n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n@@ -139,6 +139,18 @@ enum ConstantKind {\n     Global,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum StackPopCleanup {\n+    /// The stackframe existed to compute the initial value of a static/constant, make sure the\n+    /// static isn't modifyable afterwards\n+    Freeze(AllocId),\n+    /// A regular stackframe added due to a function call will need to get forwarded to the next\n+    /// block\n+    Goto(mir::BasicBlock),\n+    /// The main function and diverging functions have nowhere to return to\n+    None,\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>, memory_size: usize, stack_limit: usize) -> Self {\n         EvalContext {\n@@ -313,7 +325,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>,\n-        return_to_block: Option<mir::BasicBlock>,\n+        return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n@@ -350,13 +362,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn pop_stack_frame(&mut self) {\n+    fn pop_stack_frame(&mut self) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n-        if let Some(target) = frame.return_to_block {\n-            self.goto_block(target);\n+        match frame.return_to_block {\n+            StackPopCleanup::Freeze(alloc_id) => self.memory.freeze(alloc_id)?,\n+            StackPopCleanup::Goto(target) => self.goto_block(target),\n+            StackPopCleanup::None => {},\n         }\n         // TODO(solson): Deallocate local variables.\n+        Ok(())\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -1036,7 +1051,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), None)\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), StackPopCleanup::None)\n         .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {"}, {"sha": "2509aba09000356aeb6e92814f167c6e690d9382", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -7,11 +7,13 @@ use super::{\n     ConstantId,\n     EvalContext,\n     ConstantKind,\n+    StackPopCleanup,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n use rustc::ty::{subst, self};\n use rustc::hir::def_id::DefId;\n+use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -110,7 +112,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n-    fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span) {\n+    fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span, immutable: bool) {\n         let cid = ConstantId {\n             def_id: def_id,\n             substs: substs,\n@@ -123,7 +125,12 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), None)\n+            let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n+                StackPopCleanup::Freeze(ptr.alloc_id)\n+            } else {\n+                StackPopCleanup::None\n+            };\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -150,7 +157,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     // because the type is the actual function, not the signature of the function.\n                     // Thus we can simply create a zero sized allocation in `evaluate_operand`\n                 } else {\n-                    self.global_item(def_id, substs, constant.span);\n+                    self.global_item(def_id, substs, constant.span, true);\n                 }\n             },\n             mir::Literal::Promoted { index } => {\n@@ -168,7 +175,12 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n-                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr), None)\n+                    this.ecx.push_stack_frame(this.def_id,\n+                                              constant.span,\n+                                              mir,\n+                                              this.substs,\n+                                              Some(return_ptr),\n+                                              StackPopCleanup::Freeze(return_ptr.alloc_id))\n                 });\n             }\n         }\n@@ -179,7 +191,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n             let substs = subst::Substs::empty(self.ecx.tcx);\n             let span = self.span;\n-            self.global_item(def_id, substs, span);\n+            if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = self.ecx.tcx.map.get_if_local(def_id).expect(\"static not found\") {\n+                if let hir::ItemStatic(_, m, _) = *node {\n+                    self.global_item(def_id, substs, span, m == hir::MutImmutable);\n+                    return;\n+                } else {\n+                    bug!(\"static def id doesn't point to static\");\n+                }\n+            } else {\n+                bug!(\"static def id doesn't point to item\");\n+            }\n+            self.global_item(def_id, substs, span, false);\n         }\n     }\n }"}, {"sha": "9984e1f14eaf1c06d7e6ac332c26e7de3b925b7d", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -10,7 +10,7 @@ use std::iter;\n use syntax::{ast, attr};\n use syntax::codemap::{DUMMY_SP, Span};\n \n-use super::{EvalContext, IntegerExt};\n+use super::{EvalContext, IntegerExt, StackPopCleanup};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n \n@@ -27,7 +27,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         use rustc::mir::repr::TerminatorKind::*;\n         match terminator.kind {\n-            Return => self.pop_stack_frame(),\n+            Return => self.pop_stack_frame()?,\n \n             Goto { target } => self.goto_block(target),\n \n@@ -210,8 +210,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let mir = self.load_mir(resolved_def_id);\n                 let (return_ptr, return_to_block) = match destination {\n-                    Some((ptr, block)) => (Some(ptr), Some(block)),\n-                    None => (None, None),\n+                    Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n+                    None => (None, StackPopCleanup::None),\n                 };\n                 self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n "}, {"sha": "edcdccf346cf6c4a3cb9e7ac9fecf6f31c351928", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -96,6 +96,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n+        self.memory.freeze(vtable.alloc_id)?;\n+\n         Ok(vtable)\n     }\n "}, {"sha": "c02ea22c1d997d4b369d7b24c9e6ebb6de326f63", "filename": "src/memory.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -26,10 +26,20 @@ impl fmt::Display for AllocId {\n \n #[derive(Debug)]\n pub struct Allocation {\n+    /// The actual bytes of the allocation.\n+    /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n+    /// Maps from byte addresses to allocations.\n+    /// Only the first byte of a pointer is inserted into the map.\n     pub relocations: BTreeMap<usize, AllocId>,\n+    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n+    /// The alignment of the allocation to detect unaligned reads.\n     pub align: usize,\n+    /// Whether the allocation may be modified.\n+    /// Use the `freeze` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// allocation is modified in the future.\n+    pub immutable: bool,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -111,6 +121,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n             align: 1,\n+            immutable: false, // must be mutable, because sometimes we \"move out\" of a ZST\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n@@ -179,6 +190,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align: align,\n+            immutable: false,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -287,6 +299,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n+            Some(ref alloc) if alloc.immutable => Err(EvalError::ModifiedConstantMemory),\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n@@ -430,10 +443,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n+\n+    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n+        self.get_mut(alloc_id)?.immutable = true;\n+        Ok(())\n+    }\n+\n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n-        let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n+        let src_bytes = self.get_bytes_unchecked(src, size)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size, align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes"}, {"sha": "11961becb246a2a0eae976af412a60941fb6cda3", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "patch": "@@ -0,0 +1,9 @@\n+static X: usize = 5;\n+\n+#[allow(mutable_transmutes)]\n+fn main() {\n+    unsafe {\n+        *std::mem::transmute::<&usize, &mut usize>(&X) = 6; //~ ERROR: tried to modify constant memory\n+        assert_eq!(X, 6);\n+    }\n+}"}, {"sha": "a68f727322e29910d4b72f01939dbcb02058189c", "filename": "tests/run-pass/static_memory_modification.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4051b0e36a67049ee8a381f239afc519c82a47d6/tests%2Frun-pass%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051b0e36a67049ee8a381f239afc519c82a47d6/tests%2Frun-pass%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_memory_modification.rs?ref=4051b0e36a67049ee8a381f239afc519c82a47d6", "previous_filename": "tests/run-pass/bug.rs"}]}