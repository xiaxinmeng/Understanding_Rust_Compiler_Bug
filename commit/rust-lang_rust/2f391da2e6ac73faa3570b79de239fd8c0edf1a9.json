{"sha": "2f391da2e6ac73faa3570b79de239fd8c0edf1a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzkxZGEyZTZhYzczZmFhMzU3MGI3OWRlMjM5ZmQ4YzBlZGYxYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T21:17:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T21:17:52Z"}, "message": "Auto merge of #86765 - cuviper:fuse-less-specialized, r=joshtriplett\n\nMake the specialized Fuse still deal with None\n\nFixes #85863 by removing the assumption that we'll never see a cleared iterator in the `I: FusedIterator` specialization. Now all `Fuse` methods check for the possibility that `self.iter` is `None`, and the specialization only avoids _setting_ that to `None` in `&mut self` methods.", "tree": {"sha": "9609167c43be91396b85d68985b24a82e12b65cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9609167c43be91396b85d68985b24a82e12b65cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f391da2e6ac73faa3570b79de239fd8c0edf1a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f391da2e6ac73faa3570b79de239fd8c0edf1a9", "html_url": "https://github.com/rust-lang/rust/commit/2f391da2e6ac73faa3570b79de239fd8c0edf1a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f391da2e6ac73faa3570b79de239fd8c0edf1a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e87188c252a3b6dea8ed54d7915fbc2cfb61443b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e87188c252a3b6dea8ed54d7915fbc2cfb61443b", "html_url": "https://github.com/rust-lang/rust/commit/e87188c252a3b6dea8ed54d7915fbc2cfb61443b"}, {"sha": "6f5e933adb5705e15380b17ee9a2d7afb19748f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5e933adb5705e15380b17ee9a2d7afb19748f2", "html_url": "https://github.com/rust-lang/rust/commit/6f5e933adb5705e15380b17ee9a2d7afb19748f2"}], "stats": {"total": 254, "additions": 66, "deletions": 188}, "files": [{"sha": "408328adeecf464af75a15adad50aa31e7655702", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 66, "deletions": 188, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/2f391da2e6ac73faa3570b79de239fd8c0edf1a9/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f391da2e6ac73faa3570b79de239fd8c0edf1a9/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=2f391da2e6ac73faa3570b79de239fd8c0edf1a9", "patch": "@@ -1,5 +1,5 @@\n use crate::intrinsics;\n-use crate::iter::adapters::{zip::try_get_unchecked, InPlaceIterable, SourceIter};\n+use crate::iter::adapters::zip::try_get_unchecked;\n use crate::iter::{\n     DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess,\n };\n@@ -14,7 +14,9 @@ use crate::ops::Try;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n-    // NOTE: for `I: FusedIterator`, this is always assumed `Some`!\n+    // NOTE: for `I: FusedIterator`, we never bother setting `None`, but\n+    // we still have to be prepared for that state due to variance.\n+    // See rust-lang/rust#85863\n     iter: Option<I>,\n }\n impl<I> Fuse<I> {\n@@ -42,19 +44,19 @@ macro_rules! fuse {\n     };\n }\n \n-// NOTE: for `I: FusedIterator`, we assume that the iterator is always `Some`.\n-// Implementing this as a directly-expanded macro helps codegen performance.\n-macro_rules! unchecked {\n-    ($self:ident) => {\n-        match $self {\n-            Fuse { iter: Some(iter) } => iter,\n-            // SAFETY: the specialized iterator never sets `None`\n-            Fuse { iter: None } => unsafe { intrinsics::unreachable() },\n+/// Specialized macro that doesn't check if the expression is `None`.\n+/// (We trust that a `FusedIterator` will fuse itself.)\n+macro_rules! spec {\n+    ($self:ident . iter . $($call:tt)+) => {\n+        match $self.iter {\n+            Some(ref mut iter) => iter.$($call)+,\n+            None => None,\n         }\n     };\n }\n \n-// Any implementation here is made internal to avoid exposing default fns outside this trait\n+// Any specialized implementation here is made internal\n+// to avoid exposing default fns outside this trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I>\n where\n@@ -74,17 +76,26 @@ where\n \n     #[inline]\n     fn last(self) -> Option<Self::Item> {\n-        FuseImpl::last(self)\n+        match self.iter {\n+            Some(iter) => iter.last(),\n+            None => None,\n+        }\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        FuseImpl::count(self)\n+        match self.iter {\n+            Some(iter) => iter.count(),\n+            None => 0,\n+        }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        FuseImpl::size_hint(self)\n+        match self.iter {\n+            Some(ref iter) => iter.size_hint(),\n+            None => (0, Some(0)),\n+        }\n     }\n \n     #[inline]\n@@ -98,11 +109,14 @@ where\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        FuseImpl::fold(self, acc, fold)\n+        if let Some(iter) = self.iter {\n+            acc = iter.fold(acc, fold);\n+        }\n+        acc\n     }\n \n     #[inline]\n@@ -155,11 +169,14 @@ where\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        FuseImpl::rfold(self, acc, fold)\n+        if let Some(iter) = self.iter {\n+            acc = iter.rfold(acc, fold);\n+        }\n+        acc\n     }\n \n     #[inline]\n@@ -177,11 +194,17 @@ where\n     I: ExactSizeIterator,\n {\n     fn len(&self) -> usize {\n-        FuseImpl::len(self)\n+        match self.iter {\n+            Some(ref iter) => iter.len(),\n+            None => 0,\n+        }\n     }\n \n     fn is_empty(&self) -> bool {\n-        FuseImpl::is_empty(self)\n+        match self.iter {\n+            Some(ref iter) => iter.is_empty(),\n+            None => true,\n+        }\n     }\n }\n \n@@ -205,25 +228,22 @@ where\n     const MAY_HAVE_SIDE_EFFECT: bool = I::MAY_HAVE_SIDE_EFFECT;\n }\n \n-// Fuse specialization trait\n+/// Fuse specialization trait\n+///\n+/// We only need to worry about `&mut self` methods, which\n+/// may exhaust the iterator without consuming it.\n #[doc(hidden)]\n trait FuseImpl<I> {\n     type Item;\n \n     // Functions specific to any normal Iterators\n     fn next(&mut self) -> Option<Self::Item>;\n     fn nth(&mut self, n: usize) -> Option<Self::Item>;\n-    fn last(self) -> Option<Self::Item>;\n-    fn count(self) -> usize;\n-    fn size_hint(&self) -> (usize, Option<usize>);\n     fn try_fold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Output = Acc>;\n-    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc;\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool;\n@@ -241,25 +261,13 @@ trait FuseImpl<I> {\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Output = Acc>,\n         I: DoubleEndedIterator;\n-    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-        I: DoubleEndedIterator;\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator;\n-\n-    // Functions specific to ExactSizeIterator\n-    fn len(&self) -> usize\n-    where\n-        I: ExactSizeIterator;\n-    fn is_empty(&self) -> bool\n-    where\n-        I: ExactSizeIterator;\n }\n \n-// General Fuse impl\n+/// General `Fuse` impl which sets `iter = None` when exhausted.\n #[doc(hidden)]\n impl<I> FuseImpl<I> for Fuse<I>\n where\n@@ -277,30 +285,6 @@ where\n         fuse!(self.iter.nth(n))\n     }\n \n-    #[inline]\n-    default fn last(self) -> Option<I::Item> {\n-        match self.iter {\n-            Some(iter) => iter.last(),\n-            None => None,\n-        }\n-    }\n-\n-    #[inline]\n-    default fn count(self) -> usize {\n-        match self.iter {\n-            Some(iter) => iter.count(),\n-            None => 0,\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.iter {\n-            Some(ref iter) => iter.size_hint(),\n-            None => (0, Some(0)),\n-        }\n-    }\n-\n     #[inline]\n     default fn try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n     where\n@@ -315,17 +299,6 @@ where\n         try { acc }\n     }\n \n-    #[inline]\n-    default fn fold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if let Some(iter) = self.iter {\n-            acc = iter.fold(acc, fold);\n-        }\n-        acc\n-    }\n-\n     #[inline]\n     default fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n@@ -365,18 +338,6 @@ where\n         try { acc }\n     }\n \n-    #[inline]\n-    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-        I: DoubleEndedIterator,\n-    {\n-        if let Some(iter) = self.iter {\n-            acc = iter.rfold(acc, fold);\n-        }\n-        acc\n-    }\n-\n     #[inline]\n     default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n@@ -385,120 +346,74 @@ where\n     {\n         fuse!(self.iter.rfind(predicate))\n     }\n-\n-    #[inline]\n-    default fn len(&self) -> usize\n-    where\n-        I: ExactSizeIterator,\n-    {\n-        match self.iter {\n-            Some(ref iter) => iter.len(),\n-            None => 0,\n-        }\n-    }\n-\n-    #[inline]\n-    default fn is_empty(&self) -> bool\n-    where\n-        I: ExactSizeIterator,\n-    {\n-        match self.iter {\n-            Some(ref iter) => iter.is_empty(),\n-            None => true,\n-        }\n-    }\n }\n \n+/// Specialized `Fuse` impl which doesn't bother clearing `iter` when exhausted.\n+/// However, we must still be prepared for the possibility that it was already cleared!\n #[doc(hidden)]\n impl<I> FuseImpl<I> for Fuse<I>\n where\n     I: FusedIterator,\n {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        unchecked!(self).next()\n+        spec!(self.iter.next())\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        unchecked!(self).nth(n)\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        unchecked!(self).last()\n+        spec!(self.iter.nth(n))\n     }\n \n     #[inline]\n-    fn count(self) -> usize {\n-        unchecked!(self).count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        unchecked!(self).size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    fn try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Output = Acc>,\n     {\n-        unchecked!(self).try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        unchecked!(self).fold(init, fold)\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_fold(acc, fold)?;\n+        }\n+        try { acc }\n     }\n \n     #[inline]\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        unchecked!(self).find(predicate)\n+        spec!(self.iter.find(predicate))\n     }\n \n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        unchecked!(self).next_back()\n+        spec!(self.iter.next_back())\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        unchecked!(self).nth_back(n)\n+        spec!(self.iter.nth_back(n))\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Output = Acc>,\n         I: DoubleEndedIterator,\n     {\n-        unchecked!(self).try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-        I: DoubleEndedIterator,\n-    {\n-        unchecked!(self).rfold(init, fold)\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_rfold(acc, fold)?;\n+        }\n+        try { acc }\n     }\n \n     #[inline]\n@@ -507,43 +422,6 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        unchecked!(self).rfind(predicate)\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> usize\n-    where\n-        I: ExactSizeIterator,\n-    {\n-        unchecked!(self).len()\n-    }\n-\n-    #[inline]\n-    fn is_empty(&self) -> bool\n-    where\n-        I: ExactSizeIterator,\n-    {\n-        unchecked!(self).is_empty()\n+        spec!(self.iter.rfind(predicate))\n     }\n }\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: FusedIterator> SourceIter for Fuse<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        match self.iter {\n-            // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-            Some(ref mut iter) => unsafe { SourceIter::as_inner(iter) },\n-            // SAFETY: the specialized iterator never sets `None`\n-            None => unsafe { intrinsics::unreachable() },\n-        }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Fuse<I> {}"}]}