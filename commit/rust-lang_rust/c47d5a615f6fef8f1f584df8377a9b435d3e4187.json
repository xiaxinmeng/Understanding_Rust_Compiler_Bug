{"sha": "c47d5a615f6fef8f1f584df8377a9b435d3e4187", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0N2Q1YTYxNWY2ZmVmOGYxZjU4NGRmODM3N2E5YjQzNWQzZTQxODc=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-02-21T14:38:31Z"}, "committer": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-02-21T14:38:31Z"}, "message": "Merge pull request #690 from quininer/fix-nightly\n\nfix nightly (2016-02-17)", "tree": {"sha": "3ca6d201004c7902cc6e0b57fb312e4384120f79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ca6d201004c7902cc6e0b57fb312e4384120f79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c47d5a615f6fef8f1f584df8377a9b435d3e4187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c47d5a615f6fef8f1f584df8377a9b435d3e4187", "html_url": "https://github.com/rust-lang/rust/commit/c47d5a615f6fef8f1f584df8377a9b435d3e4187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c47d5a615f6fef8f1f584df8377a9b435d3e4187/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d77ccdc33870e89c7fba9a55aea876f14754b94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77ccdc33870e89c7fba9a55aea876f14754b94d", "html_url": "https://github.com/rust-lang/rust/commit/d77ccdc33870e89c7fba9a55aea876f14754b94d"}, {"sha": "35a48bf5120d5a92723896982c16d793cd680e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a48bf5120d5a92723896982c16d793cd680e82", "html_url": "https://github.com/rust-lang/rust/commit/35a48bf5120d5a92723896982c16d793cd680e82"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "d97745203f0ce8de4a22d62f45c31162c141f8ca", "filename": "src/copies.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -175,31 +175,31 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n         match pat.node {\n-            PatBox(ref pat) | PatRegion(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatEnum(_, Some(ref pats)) => {\n+            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::TupleStruct(_, Some(ref pats)) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatIdent(_, ref ident, ref as_pat) => {\n+            PatKind::Ident(_, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.name.as_str()) {\n                     v.insert(cx.tcx.pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);\n                 }\n             },\n-            PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, &pat.node.pat, map);\n                 }\n             }\n-            PatTup(ref fields) => {\n+            PatKind::Tup(ref fields) => {\n                 for pat in fields {\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatVec(ref lhs, ref mid, ref rhs) => {\n+            PatKind::Vec(ref lhs, ref mid, ref rhs) => {\n                 for pat in lhs {\n                     bindings_impl(cx, pat, map);\n                 }\n@@ -210,7 +210,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatEnum(..) | PatLit(..) | PatQPath(..) | PatRange(..) | PatWild => (),\n+            PatKind::TupleStruct(..) | PatKind::Lit(..) | PatKind::QPath(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n         }\n     }\n "}, {"sha": "2522b1517a690afd4546edcf7666bcd57dd112bf", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -67,7 +67,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                     }\n                 }\n                 for (ref a1, ref a2) in decl.inputs.iter().zip(args) {\n-                    if let PatIdent(_, ident, _) = a1.pat.node {\n+                    if let PatKind::Ident(_, ident, _) = a1.pat.node {\n                         // XXXManishearth Should I be checking the binding mode here?\n                         if let ExprPath(None, ref p) = a2.node {\n                             if p.segments.len() != 1 {"}, {"sha": "acfb6c150d5eff85fd62c8e4bb7c874077de727e", "filename": "src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -288,7 +288,7 @@ impl LateLintPass for LoopsPass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatEnum(ref path, Some(ref pat_args)),\n+            if let (&PatKind::TupleStruct(ref path, Some(ref pat_args)),\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 if let Some(lhs_constructor) = path.segments.last() {\n@@ -338,7 +338,7 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n     if let ExprRange(Some(ref l), ref r) = arg.node {\n         // the var must be a single name\n-        if let PatIdent(_, ref ident, _) = pat.node {\n+        if let PatKind::Ident(_, ref ident, _) = pat.node {\n \n             let mut visitor = VarVisitor {\n                 cx: cx,\n@@ -584,7 +584,7 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n \n // Check for the FOR_KV_MAP lint.\n fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let PatTup(ref pat) = pat.node {\n+    if let PatKind::Tup(ref pat) = pat.node {\n         if pat.len() == 2 {\n \n             let (pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n@@ -622,10 +622,10 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n }\n \n // Return true if the pattern is a `PatWild` or an ident prefixed with '_'.\n-fn pat_is_wild(pat: &Pat_, body: &Expr) -> bool {\n+fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     match *pat {\n-        PatWild => true,\n-        PatIdent(_, ident, None) if ident.node.name.as_str().starts_with('_') => {\n+        PatKind::Wild => true,\n+        PatKind::Ident(_, ident, None) if ident.node.name.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n@@ -668,7 +668,7 @@ fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n             let Some(ref loopexpr) = block.expr,\n             let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n             innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-            let PatEnum(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n+            let PatKind::TupleStruct(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n             somepats.len() == 1\n         ], {\n             return Some((&somepats[0],\n@@ -909,7 +909,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n-                if let PatIdent(_, ref ident, _) = local.pat.node {\n+                if let PatKind::Ident(_, ref ident, _) = local.pat.node {\n                     self.name = Some(ident.node.name);\n \n                     self.state = if let Some(ref init) = local.init {"}, {"sha": "c83e4ca64ff26af7e0a8b104e10779d3366b35e7", "filename": "src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -108,8 +108,8 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn get_arg_name(pat: &Pat) -> Option<Ident> {\n     match pat.node {\n-        PatIdent(_, ident, None) => Some(ident.node),\n-        PatRegion(ref subpat, _) => get_arg_name(subpat),\n+        PatKind::Ident(_, ident, None) => Some(ident.node),\n+        PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }\n }"}, {"sha": "b8ea4f2b1b09f4008a9a34f818ffbfd36d676ad6", "filename": "src/matches.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -157,7 +157,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n }\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n-    if arms[1].pats[0].node == PatWild {\n+    if arms[1].pats[0].node == PatKind::Wild {\n         let lint = if els.is_some() {\n             SINGLE_MATCH_ELSE\n         } else {\n@@ -192,15 +192,15 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     ];\n \n     let path = match arms[1].pats[0].node {\n-        PatEnum(ref path, Some(ref inner)) => {\n+        PatKind::TupleStruct(ref path, Some(ref inner)) => {\n             // contains any non wildcard patterns? e.g. Err(err)\n-            if inner.iter().any(|pat| if let PatWild = pat.node { false } else { true }) {\n+            if inner.iter().any(|pat| if let PatKind::Wild = pat.node { false } else { true }) {\n                 return;\n             }\n             path.to_string()\n         },\n-        PatEnum(ref path, None) => path.to_string(),\n-        PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n+        PatKind::TupleStruct(ref path, None) => path.to_string(),\n+        PatKind::Ident(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n         _ => return,\n     };\n \n@@ -235,7 +235,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n         let sugg = if arms.len() == 2 && arms[0].pats.len() == 1 {\n             // no guards\n-            let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n+            let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n                 if let ExprLit(ref lit) = arm_bool.node {\n                     match lit.node {\n                         LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n@@ -334,15 +334,15 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n             if let Arm { ref pats, guard: None, .. } = *arm {\n                 Some(pats.iter().filter_map(|pat| {\n                     if_let_chain! {[\n-                        let PatRange(ref lhs, ref rhs) = pat.node,\n+                        let PatKind::Range(ref lhs, ref rhs) = pat.node,\n                         let Ok(lhs) = eval_const_expr_partial(cx.tcx, &lhs, ExprTypeChecked, None),\n                         let Ok(rhs) = eval_const_expr_partial(cx.tcx, &rhs, ExprTypeChecked, None)\n                     ], {\n                         return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                     }}\n \n                     if_let_chain! {[\n-                        let PatLit(ref value) = pat.node,\n+                        let PatKind::Lit(ref value) = pat.node,\n                         let Ok(value) = eval_const_expr_partial(cx.tcx, &value, ExprTypeChecked, None)\n                     ], {\n                         return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n@@ -424,8 +424,8 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n                      .flat_map(|a| &a.pats)\n                      .map(|p| {\n                          match p.node {\n-                             PatRegion(..) => Some(true),  // &-patterns\n-                             PatWild => Some(false),   // an \"anything\" wildcard is also fine\n+                             PatKind::Ref(..) => Some(true),  // &-patterns\n+                             PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n                              _ => None,                    // any other pattern is not fine\n                          }\n                      })"}, {"sha": "5c154dc59e2fb44fbfba11cd1301919a3f5f1c39", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -45,7 +45,7 @@ impl LateLintPass for TopLevelRefPass {\n             return;\n         }\n         for ref arg in &decl.inputs {\n-            if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n+            if let PatKind::Ident(BindByRef(_), _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n                           arg.pat.span,\n@@ -58,7 +58,7 @@ impl LateLintPass for TopLevelRefPass {\n             [\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n-            let PatIdent(BindByRef(_), i, None) = l.pat.node,\n+            let PatKind::Ident(BindByRef(_), i, None) = l.pat.node,\n             let Some(ref init) = l.init\n             ], {\n                 let tyopt = if let Some(ref ty) = l.ty {\n@@ -345,8 +345,8 @@ impl LintPass for PatternPass {\n \n impl LateLintPass for PatternPass {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatIdent(_, ref ident, Some(ref right)) = pat.node {\n-            if right.node == PatWild {\n+        if let PatKind::Ident(_, ref ident, Some(ref right)) = pat.node {\n+            if right.node == PatKind::Wild {\n                 cx.span_lint(REDUNDANT_PATTERN,\n                              pat.span,\n                              &format!(\"the `{} @ _` pattern can be written as just `{}`\","}, {"sha": "206fa492419503311c70f657fba4f81df479c408", "filename": "src/shadow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -67,7 +67,7 @@ impl LateLintPass for ShadowPass {\n fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n-        if let PatIdent(_, ident, _) = arg.pat.node {\n+        if let PatKind::Ident(_, ident, _) = arg.pat.node {\n             bindings.push((ident.node.unhygienic_name, ident.span))\n         }\n     }\n@@ -119,7 +119,7 @@ fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n-        PatIdent(_, ref ident, ref inner) => {\n+        PatKind::Ident(_, ref ident, ref inner) => {\n             let name = ident.node.unhygienic_name;\n             if is_binding(cx, pat) {\n                 let mut new_binding = true;\n@@ -140,7 +140,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         // PatEnum(Path, Option<Vec<P<Pat>>>),\n-        PatStruct(_, ref pfields, _) => {\n+        PatKind::Struct(_, ref pfields, _) => {\n             if let Some(ref init_struct) = *init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n@@ -161,7 +161,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             }\n         }\n-        PatTup(ref inner) => {\n+        PatKind::Tup(ref inner) => {\n             if let Some(ref init_tup) = *init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n@@ -178,7 +178,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             }\n         }\n-        PatBox(ref inner) => {\n+        PatKind::Box(ref inner) => {\n             if let Some(ref initp) = *init {\n                 if let ExprBox(ref inner_init) = initp.node {\n                     check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n@@ -189,7 +189,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 check_pat(cx, inner, init, span, bindings);\n             }\n         }\n-        PatRegion(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n+        PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }"}, {"sha": "631bcb1b1008461145a79ff4b6df32858cf0e3c9", "filename": "src/utils/hir.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c47d5a615f6fef8f1f584df8377a9b435d3e4187/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=c47d5a615f6fef8f1f584df8377a9b435d3e4187", "patch": "@@ -168,41 +168,41 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     /// Check whether two patterns are the same.\n     pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n-            (&PatBox(ref l), &PatBox(ref r)) => {\n+            (&PatKind::Box(ref l), &PatKind::Box(ref r)) => {\n                 self.eq_pat(l, r)\n             }\n-            (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n+            (&PatKind::TupleStruct(ref lp, ref la), &PatKind::TupleStruct(ref rp, ref ra)) => {\n                 self.eq_path(lp, rp) &&\n                     both(la, ra, |l, r| {\n                         over(l, r, |l, r| self.eq_pat(l, r))\n                     })\n             }\n-            (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n+            (&PatKind::Ident(ref lb, ref li, ref lp), &PatKind::Ident(ref rb, ref ri, ref rp)) => {\n                 lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n                     both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatLit(ref l), &PatLit(ref r)) => {\n+            (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => {\n                 self.eq_expr(l, r)\n             }\n-            (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n+            (&PatKind::QPath(ref ls, ref lp), &PatKind::QPath(ref rs, ref rp)) => {\n                 self.eq_qself(ls, rs) && self.eq_path(lp, rp)\n             }\n-            (&PatTup(ref l), &PatTup(ref r)) => {\n+            (&PatKind::Tup(ref l), &PatKind::Tup(ref r)) => {\n                 over(l, r, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n+            (&PatKind::Range(ref ls, ref le), &PatKind::Range(ref rs, ref re)) => {\n                 self.eq_expr(ls, rs) &&\n                     self.eq_expr(le, re)\n             }\n-            (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n+            (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => {\n                 lm == rm && self.eq_pat(le, re)\n             }\n-            (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n+            (&PatKind::Vec(ref ls, ref li, ref le), &PatKind::Vec(ref rs, ref ri, ref re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r)) &&\n                     over(le, re, |l, r| self.eq_pat(l, r)) &&\n                     both(li, ri, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatWild, &PatWild) => true,\n+            (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,\n         }\n     }"}]}