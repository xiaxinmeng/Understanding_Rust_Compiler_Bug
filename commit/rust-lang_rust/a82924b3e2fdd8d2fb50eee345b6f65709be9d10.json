{"sha": "a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MjkyNGIzZTJmZGQ4ZDJmYjUwZWVlMzQ1YjZmNjU3MDliZTlkMTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-03-14T20:35:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-14T20:35:51Z"}, "message": "Merge pull request #152 from oli-obk/intrinsics\n\nIntrinsics and overflow", "tree": {"sha": "03ebe72947ee3b3233e93915f6b0bc652d7a94db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03ebe72947ee3b3233e93915f6b0bc652d7a94db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "html_url": "https://github.com/rust-lang/rust/commit/a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca0676abde64f6c863659f78cc1798dd5959738", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca0676abde64f6c863659f78cc1798dd5959738", "html_url": "https://github.com/rust-lang/rust/commit/0ca0676abde64f6c863659f78cc1798dd5959738"}, {"sha": "257ac5803f0baf0dd0b79b6560391bf588ca17d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/257ac5803f0baf0dd0b79b6560391bf588ca17d8", "html_url": "https://github.com/rust-lang/rust/commit/257ac5803f0baf0dd0b79b6560391bf588ca17d8"}], "stats": {"total": 287, "additions": 232, "deletions": 55}, "files": [{"sha": "155d5574daa045f73dcc6abe669079a33b58e136", "filename": "src/operator.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -178,25 +178,9 @@ pub fn binary_op<'tcx>(\n \n     // These ops can have an RHS with a different numeric type.\n     if bin_op == Shl || bin_op == Shr {\n-        // These are the maximum values a bitshift RHS could possibly have. For example, u16\n-        // can be bitshifted by 0..16, so masking with 0b1111 (16 - 1) will ensure we are in\n-        // that range.\n-        let type_bits: u32 = match left_kind {\n-            I8  | U8  => 8,\n-            I16 | U16 => 16,\n-            I32 | U32 => 32,\n-            I64 | U64 => 64,\n-            I128 | U128 => 128,\n-            _ => bug!(\"bad MIR: bitshift lhs is not integral\"),\n-        };\n-\n-        // Cast to `u32` because `overflowing_sh{l,r}` only take `u32`, then apply the bitmask\n-        // to ensure it's within the valid shift value range.\n-        let masked_shift_width = (r as u32) & (type_bits - 1);\n-\n         return match bin_op {\n-            Shl => int_shift!(left_kind, overflowing_shl, l, masked_shift_width),\n-            Shr => int_shift!(left_kind, overflowing_shr, l, masked_shift_width),\n+            Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n+            Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n             _ => bug!(\"it has already been checked that this is a shift op\"),\n         };\n     }"}, {"sha": "a2e1202ab5d1ff57bc3ba8169343e60fd5bb0d02", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // we are inherently singlethreaded and singlecored, this is a nop\n             }\n \n-            \"atomic_xchg\" => {\n+            _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n@@ -92,8 +92,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n             }\n \n-            \"atomic_cxchg_relaxed\" |\n-            \"atomic_cxchg\" => {\n+            _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n@@ -111,8 +110,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n             }\n \n-            \"atomic_xadd\" |\n-            \"atomic_xadd_relaxed\" => {\n+            \"atomic_or\" | \"atomic_or_acq\" | \"atomic_or_rel\" | \"atomic_or_acqrel\" | \"atomic_or_relaxed\" |\n+            \"atomic_xor\" | \"atomic_xor_acq\" | \"atomic_xor_rel\" | \"atomic_xor_acqrel\" | \"atomic_xor_relaxed\" |\n+            \"atomic_and\" | \"atomic_and_acq\" | \"atomic_and_rel\" | \"atomic_and_acqrel\" | \"atomic_and_relaxed\" |\n+            \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n+            \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n@@ -124,27 +126,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 self.write_primval(dest, old, ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n-                // FIXME: what do atomics do on overflow?\n-                let (val, _) = operator::binary_op(mir::BinOp::Add, old, kind, change, kind)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n-            },\n-\n-            \"atomic_xsub_rel\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let change = self.value_to_primval(arg_vals[1], ty)?;\n-                let old = self.read_value(ptr, ty)?;\n-                let old = match old {\n-                    Value::ByVal(val) => val,\n-                    Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_xsub_rel doesn't work with nonprimitives\"),\n+                let op = match intrinsic_name.split('_').nth(1).unwrap() {\n+                    \"or\" => mir::BinOp::BitOr,\n+                    \"xor\" => mir::BinOp::BitXor,\n+                    \"and\" => mir::BinOp::BitAnd,\n+                    \"xadd\" => mir::BinOp::Add,\n+                    \"xsub\" => mir::BinOp::Sub,\n+                    _ => bug!(),\n                 };\n-                self.write_primval(dest, old, ty)?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = operator::binary_op(mir::BinOp::Sub, old, kind, change, kind)?;\n+                let (val, _) = operator::binary_op(op, old, kind, change, kind)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n-            }\n+            },\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n \n@@ -207,14 +200,50 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 return self.eval_drop_impls(drops, span);\n             }\n \n-            \"fabsf32\" => {\n+            \"sinf32\" | \"fabsf32\" | \"cosf32\" |\n+            \"sqrtf32\" | \"expf32\" | \"exp2f32\" |\n+            \"logf32\" | \"log10f32\" | \"log2f32\" |\n+            \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                self.write_primval(dest, PrimVal::from_f32(f.abs()), dest_ty)?;\n+                let f = match intrinsic_name {\n+                    \"sinf32\" => f.sin(),\n+                    \"fabsf32\" => f.abs(),\n+                    \"cosf32\" => f.cos(),\n+                    \"sqrtf32\" => f.sqrt(),\n+                    \"expf32\" => f.exp(),\n+                    \"exp2f32\" => f.exp2(),\n+                    \"logf32\" => f.ln(),\n+                    \"log10f32\" => f.log10(),\n+                    \"log2f32\" => f.log2(),\n+                    \"floorf32\" => f.floor(),\n+                    \"ceilf32\" => f.ceil(),\n+                    \"truncf32\" => f.trunc(),\n+                    _ => bug!(),\n+                };\n+                self.write_primval(dest, PrimVal::from_f32(f), dest_ty)?;\n             }\n \n-            \"fabsf64\" => {\n+            \"sinf64\" | \"fabsf64\" | \"cosf64\" |\n+            \"sqrtf64\" | \"expf64\" | \"exp2f64\" |\n+            \"logf64\" | \"log10f64\" | \"log2f64\" |\n+            \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                self.write_primval(dest, PrimVal::from_f64(f.abs()), dest_ty)?;\n+                let f = match intrinsic_name {\n+                    \"sinf64\" => f.sin(),\n+                    \"fabsf64\" => f.abs(),\n+                    \"cosf64\" => f.cos(),\n+                    \"sqrtf64\" => f.sqrt(),\n+                    \"expf64\" => f.exp(),\n+                    \"exp2f64\" => f.exp2(),\n+                    \"logf64\" => f.ln(),\n+                    \"log10f64\" => f.log10(),\n+                    \"log2f64\" => f.log2(),\n+                    \"floorf64\" => f.floor(),\n+                    \"ceilf64\" => f.ceil(),\n+                    \"truncf64\" => f.trunc(),\n+                    _ => bug!(),\n+                };\n+                self.write_primval(dest, PrimVal::from_f64(f), dest_ty)?;\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n@@ -320,26 +349,42 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n-            \"powif32\" => {\n+            \"powf32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n-                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n+                let f2 = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n+                self.write_primval(dest, PrimVal::from_f32(f.powf(f2)), dest_ty)?;\n             }\n \n-            \"powif64\" => {\n+            \"powf64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n-                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n+                let f2 = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n+                self.write_primval(dest, PrimVal::from_f64(f.powf(f2)), dest_ty)?;\n+            }\n+\n+            \"fmaf32\" => {\n+                let a = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n+                let b = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n+                let c = self.value_to_primval(arg_vals[2], f32)?.to_f32()?;\n+                self.write_primval(dest, PrimVal::from_f32(a * b + c), dest_ty)?;\n+            }\n+\n+            \"fmaf64\" => {\n+                let a = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n+                let b = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n+                let c = self.value_to_primval(arg_vals[2], f64)?.to_f64()?;\n+                self.write_primval(dest, PrimVal::from_f64(a * b + c), dest_ty)?;\n             }\n \n-            \"sqrtf32\" => {\n+            \"powif32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                self.write_primval(dest, PrimVal::from_f32(f.sqrt()), dest_ty)?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n+                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n             }\n \n-            \"sqrtf64\" => {\n+            \"powif64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                self.write_primval(dest, PrimVal::from_f64(f.sqrt()), dest_ty)?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n+                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"size_of\" => {"}, {"sha": "a7ac9d1d50398d1f50fb9cd00152cf1808a3b77c", "filename": "tests/compile-fail/overflowing-rsh-6.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Fcompile-fail%2Foverflowing-rsh-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Fcompile-fail%2Foverflowing-rsh-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh-6.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(exceeding_bitshifts)]\n+\n+fn main() {\n+    let _n = 1i64 >> 64; //~ Overflow(Shr)\n+}"}, {"sha": "ada584705401f3dd3f71431c4b223e5b001a5838", "filename": "tests/run-pass/atomic-access-bool.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fatomic-access-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fatomic-access-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic-access-bool.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT};\n+use std::sync::atomic::Ordering::*;\n+\n+static mut ATOMIC: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.store(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_or(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_and(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.fetch_nand(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_xor(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+    }\n+}"}, {"sha": "61e9a965889669556d36c798a322e28e3deda2f4", "filename": "tests/run-pass/atomic-compare_exchange.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic-compare_exchange.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT};\n+use std::sync::atomic::Ordering::*;\n+\n+static ATOMIC: AtomicIsize = ATOMIC_ISIZE_INIT;\n+\n+fn main() {\n+    // Make sure trans can emit all the intrinsics correctly\n+    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n+}"}, {"sha": "a2c55634749cbfef24f225727b07a2af0f74577a", "filename": "tests/run-pass/intrinsics-math.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82924b3e2fdd8d2fb50eee345b6f65709be9d10/tests%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics-math.rs?ref=a82924b3e2fdd8d2fb50eee345b6f65709be9d10", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! assert_approx_eq {\n+    ($a:expr, $b:expr) => ({\n+        let (a, b) = (&$a, &$b);\n+        assert!((*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\", *a, *b);\n+    })\n+}\n+\n+pub fn main() {\n+    use std::f32;\n+    use std::f64;\n+\n+    assert_approx_eq!(64f32.sqrt(), 8f32);\n+    assert_approx_eq!(64f64.sqrt(), 8f64);\n+\n+    assert_approx_eq!(25f32.powi(-2), 0.0016f32);\n+    assert_approx_eq!(23.2f64.powi(2), 538.24f64);\n+\n+    assert_approx_eq!(0f32.sin(), 0f32);\n+    assert_approx_eq!((f64::consts::PI / 2f64).sin(), 1f64);\n+\n+    assert_approx_eq!(0f32.cos(), 1f32);\n+    assert_approx_eq!((f64::consts::PI * 2f64).cos(), 1f64);\n+\n+    assert_approx_eq!(25f32.powf(-2f32), 0.0016f32);\n+    assert_approx_eq!(400f64.powf(0.5f64), 20f64);\n+\n+    assert_approx_eq!((1f32.exp() - f32::consts::E).abs(), 0f32);\n+    assert_approx_eq!(1f64.exp(), f64::consts::E);\n+\n+    assert_approx_eq!(10f32.exp2(), 1024f32);\n+    assert_approx_eq!(50f64.exp2(), 1125899906842624f64);\n+\n+    assert_approx_eq!((f32::consts::E.ln() - 1f32).abs(), 0f32);\n+    assert_approx_eq!(1f64.ln(), 0f64);\n+\n+    assert_approx_eq!(10f32.log10(), 1f32);\n+    assert_approx_eq!(f64::consts::E.log10(), f64::consts::LOG10_E);\n+\n+    assert_approx_eq!(8f32.log2(), 3f32);\n+    assert_approx_eq!(f64::consts::E.log2(), f64::consts::LOG2_E);\n+\n+    assert_approx_eq!(1.0f32.mul_add(2.0f32, 5.0f32), 7.0f32);\n+    assert_approx_eq!(0.0f64.mul_add(-2.0f64, f64::consts::E), f64::consts::E);\n+\n+    assert_approx_eq!((-1.0f32).abs(), 1.0f32);\n+    assert_approx_eq!(34.2f64.abs(), 34.2f64);\n+\n+    assert_approx_eq!(3.8f32.floor(), 3.0f32);\n+    assert_approx_eq!((-1.1f64).floor(), -2.0f64);\n+\n+    assert_approx_eq!((-2.3f32).ceil(), -2.0f32);\n+    assert_approx_eq!(3.8f64.ceil(), 4.0f64);\n+\n+    assert_approx_eq!(0.1f32.trunc(), 0.0f32);\n+    assert_approx_eq!((-0.1f64).trunc(), 0.0f64);\n+}"}]}