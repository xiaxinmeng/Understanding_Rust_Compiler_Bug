{"sha": "09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZDRhNDM2YTc0OGEzOWYxM2QyZDZkNmM2YmE1NmE4ODViYjBkMGM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-16T17:58:26Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-17T21:51:10Z"}, "message": "libsyntax: Merge OwnedSlice into ptr::P", "tree": {"sha": "2563cb471d4b92c429b75e5154abe131fde9fe50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2563cb471d4b92c429b75e5154abe131fde9fe50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "html_url": "https://github.com/rust-lang/rust/commit/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6734dccc3149d62d36a41979424e61dce4473267", "url": "https://api.github.com/repos/rust-lang/rust/commits/6734dccc3149d62d36a41979424e61dce4473267", "html_url": "https://github.com/rust-lang/rust/commit/6734dccc3149d62d36a41979424e61dce4473267"}], "stats": {"total": 205, "additions": 90, "deletions": 115}, "files": [{"sha": "820c7e7e4a663494753211135ab2581a9c2d5f84", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 97, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "patch": "@@ -8,100 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::default::Default;\n-use std::fmt;\n-use std::iter::{IntoIterator, FromIterator};\n-use std::ops::Deref;\n-use std::slice;\n-use std::vec;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n-/// A non-growable owned slice. This is a separate type to allow the\n-/// representation to change.\n-#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct OwnedSlice<T> {\n-    data: Box<[T]>\n-}\n-\n-impl<T:fmt::Debug> fmt::Debug for OwnedSlice<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        self.data.fmt(fmt)\n-    }\n-}\n-\n-impl<T> OwnedSlice<T> {\n-    pub fn empty() -> OwnedSlice<T> {\n-        OwnedSlice  { data: Box::new([]) }\n-    }\n-\n-    #[inline(never)]\n-    pub fn from_vec(v: Vec<T>) -> OwnedSlice<T> {\n-        OwnedSlice { data: v.into_boxed_slice() }\n-    }\n-\n-    #[inline(never)]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.data.into_vec()\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &*self.data\n-    }\n-\n-    pub fn move_iter(self) -> vec::IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-\n-    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> OwnedSlice<U> {\n-        self.iter().map(f).collect()\n-    }\n-}\n-\n-impl<T> Deref for OwnedSlice<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-impl<T> Default for OwnedSlice<T> {\n-    fn default() -> OwnedSlice<T> {\n-        OwnedSlice::empty()\n-    }\n-}\n-\n-impl<T: Clone> Clone for OwnedSlice<T> {\n-    fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(self.to_vec())\n-    }\n-}\n-\n-impl<T> FromIterator<T> for OwnedSlice<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a OwnedSlice<T> {\n-    type Item = &'a T;\n-    type IntoIter = slice::Iter<'a, T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.data.into_iter()\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for OwnedSlice<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&**self, s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for OwnedSlice<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<OwnedSlice<T>, D::Error> {\n-        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n-            Ok(t) => t,\n-            Err(e) => return Err(e)\n-        }))\n-    }\n-}\n+/// A non-growable owned slice.\n+pub type OwnedSlice<T> = ::ptr::P<[T]>;"}, {"sha": "1be0b08086d9ce830028441184dc1ee43a285ce7", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=09d4a436a748a39f13d2d6d6c6ba56a885bb0d0c", "patch": "@@ -37,14 +37,15 @@\n //!   Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Display, Debug};\n-use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::ptr;\n+use std::{ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n-pub struct P<T> {\n+#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }\n \n@@ -92,14 +93,6 @@ impl<T: 'static + Clone> Clone for P<T> {\n     }\n }\n \n-impl<T: PartialEq> PartialEq for P<T> {\n-    fn eq(&self, other: &P<T>) -> bool {\n-        **self == **other\n-    }\n-}\n-\n-impl<T: Eq> Eq for P<T> {}\n-\n impl<T: Debug> Debug for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Debug::fmt(&**self, f)\n@@ -111,19 +104,12 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Pointer for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n-impl<T: Hash> Hash for P<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state);\n-    }\n-}\n-\n impl<T: 'static + Decodable> Decodable for P<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n@@ -135,3 +121,87 @@ impl<T: Encodable> Encodable for P<T> {\n         (**self).encode(s)\n     }\n }\n+\n+\n+impl<T:fmt::Debug> fmt::Debug for P<[T]> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        self.ptr.fmt(fmt)\n+    }\n+}\n+\n+impl<T> P<[T]> {\n+    pub fn empty() -> P<[T]> {\n+        P { ptr: Default::default() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(v: Vec<T>) -> P<[T]> {\n+        P { ptr: v.into_boxed_slice() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.ptr.into_vec()\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        &*self.ptr\n+    }\n+\n+    pub fn move_iter(self) -> vec::IntoIter<T> {\n+        self.into_vec().into_iter()\n+    }\n+\n+    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> P<[U]> {\n+        self.iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> Deref for P<[T]> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<T> Default for P<[T]> {\n+    fn default() -> P<[T]> {\n+        P::empty()\n+    }\n+}\n+\n+impl<T: Clone> Clone for P<[T]> {\n+    fn clone(&self) -> P<[T]> {\n+        P::from_vec(self.to_vec())\n+    }\n+}\n+\n+impl<T> FromIterator<T> for P<[T]> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> P<[T]> {\n+        P::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a P<[T]> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.ptr.into_iter()\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for P<[T]> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&**self, s)\n+    }\n+}\n+\n+impl<T: Decodable> Decodable for P<[T]> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+        Ok(P::from_vec(match Decodable::decode(d) {\n+            Ok(t) => t,\n+            Err(e) => return Err(e)\n+        }))\n+    }\n+}"}]}