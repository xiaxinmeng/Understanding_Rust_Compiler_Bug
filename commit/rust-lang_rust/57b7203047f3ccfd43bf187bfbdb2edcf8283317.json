{"sha": "57b7203047f3ccfd43bf187bfbdb2edcf8283317", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YjcyMDMwNDdmM2NjZmQ0M2JmMTg3YmZiZGIyZWRjZjgyODMzMTc=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-03-19T07:34:22Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-03-19T07:34:22Z"}, "message": "add basic IP support in HermitCore\n\n- add initial version to support sockets\n- use TcpStream as test case\n- HermitCore uses smoltcp as IP stack for pure Rust applications\n- further functionalities (e.g. UDP support) will be added step by step", "tree": {"sha": "64250bdaf27880a44473d58add714f8a36a67801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64250bdaf27880a44473d58add714f8a36a67801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57b7203047f3ccfd43bf187bfbdb2edcf8283317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57b7203047f3ccfd43bf187bfbdb2edcf8283317", "html_url": "https://github.com/rust-lang/rust/commit/57b7203047f3ccfd43bf187bfbdb2edcf8283317", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57b7203047f3ccfd43bf187bfbdb2edcf8283317/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57e1da59cd0761330b4ea8d47b16340a78eeafa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e1da59cd0761330b4ea8d47b16340a78eeafa9", "html_url": "https://github.com/rust-lang/rust/commit/57e1da59cd0761330b4ea8d47b16340a78eeafa9"}], "stats": {"total": 247, "additions": 158, "deletions": 89}, "files": [{"sha": "1b4cd78f1602886bbd95700a6b2fc9ea4bb4ae36", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57b7203047f3ccfd43bf187bfbdb2edcf8283317/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/57b7203047f3ccfd43bf187bfbdb2edcf8283317/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=57b7203047f3ccfd43bf187bfbdb2edcf8283317", "patch": "@@ -1349,9 +1349,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.1\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f22b8f315b98f415780ddbe9163c7dbbc5a07225b6d102ace1d8aeef85775140\"\n+checksum = \"1010591b26bbfe835e9faeabeb11866061cc7dcebffd56ad7d0942d0e61aefd8\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "958532b8fc4b278fbeb0c2764f056b567e1aa77b", "filename": "src/libstd/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57b7203047f3ccfd43bf187bfbdb2edcf8283317/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b7203047f3ccfd43bf187bfbdb2edcf8283317/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=57b7203047f3ccfd43bf187bfbdb2edcf8283317", "patch": "@@ -93,9 +93,7 @@ pub unsafe extern \"C\" fn __rust_abort() {\n \n #[cfg(not(test))]\n pub fn init() {\n-    unsafe {\n-        let _ = net::init();\n-    }\n+    let _ = net::init();\n }\n \n #[cfg(not(test))]"}, {"sha": "377c3132c5a32b1476f554af0be335692eb56211", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 155, "deletions": 84, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/57b7203047f3ccfd43bf187bfbdb2edcf8283317/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b7203047f3ccfd43bf187bfbdb2edcf8283317/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=57b7203047f3ccfd43bf187bfbdb2edcf8283317", "patch": "@@ -1,291 +1,362 @@\n use crate::convert::TryFrom;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n+use crate::sys::hermit::abi;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n \n-//// Iinitializes HermitCore's network stack\n-pub unsafe fn init() -> io::Result<()> {\n+/// Checks whether the HermitCore's socket interface has been started already, and\n+/// if not, starts it.\n+pub fn init() -> io::Result<()> {\n+    if abi::network_init() < 0 {\n+        return Err(io::Error::new(ErrorKind::Other, \"Unable to initialize network interface\"));\n+    }\n+\n     Ok(())\n }\n \n-pub struct TcpStream(Void);\n+pub struct TcpStream(abi::Handle);\n \n impl TcpStream {\n-    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = addr?;\n+\n+        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n+            Ok(handle) => Ok(TcpStream(handle)),\n+            _ => {\n+                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n+            }\n+        }\n     }\n \n-    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n+        match abi::tcpstream::connect(\n+            saddr.ip().to_string().as_bytes(),\n+            saddr.port(),\n+            Some(duration.as_millis() as u64),\n+        ) {\n+            Ok(handle) => Ok(TcpStream(handle)),\n+            _ => {\n+                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n+            }\n+        }\n     }\n \n-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n+        abi::tcpstream::set_read_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n+        abi::tcpstream::set_write_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        let duration = abi::tcpstream::get_read_timeout(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+\n+        Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        let duration = abi::tcpstream::get_write_timeout(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+\n+        Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n-    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        abi::tcpstream::peek(self.0, buf)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n+        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n     }\n \n-    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let mut size: usize = 0;\n+\n+        for i in ioslice.iter_mut() {\n+            let mut pos: usize = 0;\n+\n+            while pos < i.len() {\n+                let ret = abi::tcpstream::read(self.0, &mut i[pos..])\n+                    .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n+\n+                if ret == 0 {\n+                    return Ok(size);\n+                } else {\n+                    size += ret;\n+                    pos += ret;\n+                }\n+            }\n+        }\n+\n+        Ok(size)\n     }\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n+        self.write_vectored(&[IoSlice::new(buffer)])\n     }\n \n-    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let mut size: usize = 0;\n+\n+        for i in ioslice.iter() {\n+            size += abi::tcpstream::write(self.0, i)\n+                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to write on socket\"))?;\n+        }\n+\n+        Ok(size)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"peer_addr isn't supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"socket_addr isn't supported\"))\n     }\n \n-    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        abi::tcpstream::shutdown(self.0, how as i32)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        match self.0 {}\n+        let handle = abi::tcpstream::duplicate(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to duplicate stream\"))?;\n+\n+        Ok(TcpStream(handle))\n     }\n \n-    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n+        abi::tcpstream::set_nodelay(self.0, mode)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        abi::tcpstream::nodelay(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"nodelay failed\"))\n     }\n \n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n+        abi::tcpstream::set_tll(self.0, tll)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        abi::tcpstream::get_tll(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to get TTL\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"take_error isn't supported\"))\n     }\n \n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n+        abi::tcpstream::set_nonblocking(self.0, mode)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set blocking mode\"))\n+    }\n+}\n+\n+impl Drop for TcpStream {\n+    fn drop(&mut self) {\n+        let _ = abi::tcpstream::close(self.0);\n     }\n }\n \n impl fmt::Debug for TcpStream {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n \n-pub struct TcpListener(Void);\n+pub struct TcpListener(abi::Handle);\n \n impl TcpListener {\n     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        unsupported()\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n }\n \n impl fmt::Debug for TcpListener {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n \n-pub struct UdpSocket(Void);\n+pub struct UdpSocket(abi::Handle);\n \n impl UdpSocket {\n     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-        unsupported()\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn broadcast(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n }\n \n impl fmt::Debug for UdpSocket {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n "}]}