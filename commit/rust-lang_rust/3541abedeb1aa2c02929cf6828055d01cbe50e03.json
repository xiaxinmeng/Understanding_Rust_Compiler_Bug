{"sha": "3541abedeb1aa2c02929cf6828055d01cbe50e03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDFhYmVkZWIxYWEyYzAyOTI5Y2Y2ODI4MDU1ZDAxY2JlNTBlMDM=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2015-02-24T18:56:01Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2015-03-04T15:13:37Z"}, "message": "Add quasiquote for matchers and attributes", "tree": {"sha": "32fe6e14b4256c8f87b2c93f0c8750e83b0b2059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32fe6e14b4256c8f87b2c93f0c8750e83b0b2059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3541abedeb1aa2c02929cf6828055d01cbe50e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3541abedeb1aa2c02929cf6828055d01cbe50e03", "html_url": "https://github.com/rust-lang/rust/commit/3541abedeb1aa2c02929cf6828055d01cbe50e03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3541abedeb1aa2c02929cf6828055d01cbe50e03/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "157614249594f187f421cd97f928e64c5ab5c1fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/157614249594f187f421cd97f928e64c5ab5c1fa", "html_url": "https://github.com/rust-lang/rust/commit/157614249594f187f421cd97f928e64c5ab5c1fa"}], "stats": {"total": 312, "additions": 268, "deletions": 44}, "files": [{"sha": "7188b81b8e80db39285a88910e62fb9b07f4795e", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -764,7 +764,15 @@ usually in [procedural macros](book/plugins.html#syntax-extensions):\n * `quote_pat!`\n * `quote_stmt!`\n * `quote_tokens!`\n+* `quote_matcher!`\n * `quote_ty!`\n+* `quote_attr!`\n+\n+Keep in mind that when `$name : ident` appears in the input to\n+`quote_tokens!`, the result contains unquoted `name` followed by two tokens.\n+However, input of the same form passed to `quote_matcher!` becomes a\n+quasiquoted MBE-matcher of a nonterminal. No unquotation happens. Otherwise\n+the result of `quote_matcher!` is identical to that of `quote_tokens!`.\n \n Documentation is very limited at the moment.\n "}, {"sha": "05348ee77e81f24d7f6c3cd45fb01d54ee2b4d1f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -58,9 +58,12 @@ pub use self::PathParameters::*;\n use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use ast_util;\n+use ext::base;\n+use ext::tt::macro_parser;\n use owned_slice::OwnedSlice;\n use parse::token::{InternedString, str_to_ident};\n use parse::token;\n+use parse::lexer;\n use ptr::P;\n \n use std::fmt;\n@@ -960,6 +963,18 @@ impl TokenTree {\n             TtSequence(span, _)  => span,\n         }\n     }\n+\n+    /// Use this token tree as a matcher to parse given tts.\n+    pub fn parse(cx: &base::ExtCtxt, mtch: &[TokenTree], tts: &[TokenTree])\n+                 -> macro_parser::NamedParseResult {\n+        // `None` is because we're not interpolating\n+        let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n+                                                         None,\n+                                                         None,\n+                                                         tts.iter().cloned().collect(),\n+                                                         true);\n+        macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n+    }\n }\n \n pub type Mac = Spanned<Mac_>;"}, {"sha": "b8798150524735f468cc44cd5e8b2fecb199aa79", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -519,6 +519,12 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n         syntax_expanders.insert(intern(\"quote_stmt\"),\n                            builtin_normal_expander(\n                                 ext::quote::expand_quote_stmt));\n+        syntax_expanders.insert(intern(\"quote_matcher\"),\n+                           builtin_normal_expander(\n+                                ext::quote::expand_quote_matcher));\n+        syntax_expanders.insert(intern(\"quote_attr\"),\n+                           builtin_normal_expander(\n+                                ext::quote::expand_quote_attr));\n     }\n \n     syntax_expanders.insert(intern(\"line\"),"}, {"sha": "2599a53e313277cbc430699b5fc436a72121e690", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 127, "deletions": 28, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -401,7 +401,7 @@ pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n                                 tts: &[ast::TokenTree])\n                                 -> Box<base::MacResult+'cx> {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n-    let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n+    let expanded = expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n }\n \n@@ -465,6 +465,32 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n+pub fn expand_quote_attr(cx: &mut ExtCtxt,\n+                         sp: Span,\n+                         tts: &[ast::TokenTree])\n+                         -> Box<base::MacResult+'static> {\n+    let expanded = expand_parse_call(cx, sp, \"parse_attribute\",\n+                                    vec!(cx.expr_bool(sp, true)), tts);\n+\n+    base::MacEager::expr(expanded)\n+}\n+\n+pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n+                            sp: Span,\n+                            tts: &[ast::TokenTree])\n+                            -> Box<base::MacResult+'static> {\n+    let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n+    let mut vector = mk_stmts_let(cx, sp);\n+    vector.extend(statements_mk_tts(cx, &tts[..], true).into_iter());\n+    let block = cx.expr_block(\n+        cx.block_all(sp,\n+                     vector,\n+                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+\n+    let expanded = expand_wrapper(cx, sp, cx_expr, block, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n+    base::MacEager::expr(expanded)\n+}\n+\n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n     strs.iter().map(|str| str_to_ident(&(*str))).collect()\n }\n@@ -527,7 +553,7 @@ fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n }\n \n #[allow(non_upper_case_globals)]\n-fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n+fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     macro_rules! mk_lit {\n         ($name: expr, $suffix: expr, $($args: expr),*) => {{\n             let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n@@ -606,6 +632,21 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec!(mk_name(cx, sp, ident.ident())));\n         }\n \n+        token::MatchNt(name, kind, namep, kindp) => {\n+            return cx.expr_call(sp,\n+                                mk_token_path(cx, sp, \"MatchNt\"),\n+                                vec!(mk_ident(cx, sp, name),\n+                                     mk_ident(cx, sp, kind),\n+                                     match namep {\n+                                        ModName => mk_token_path(cx, sp, \"ModName\"),\n+                                        Plain   => mk_token_path(cx, sp, \"Plain\"),\n+                                     },\n+                                     match kindp {\n+                                        ModName => mk_token_path(cx, sp, \"ModName\"),\n+                                        Plain   => mk_token_path(cx, sp, \"Plain\"),\n+                                     }));\n+        }\n+\n         token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n \n         _ => ()\n@@ -642,7 +683,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n+fn statements_mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree, matcher: bool) -> Vec<P<ast::Stmt>> {\n     match *tt {\n         ast::TtToken(sp, SubstNt(ident, _)) => {\n             // tt.extend($ident.to_tokens(ext_cx).into_iter())\n@@ -663,18 +704,18 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n \n             vec!(cx.stmt_expr(e_push))\n         }\n-        ref tt @ ast::TtToken(_, MatchNt(..)) => {\n+        ref tt @ ast::TtToken(_, MatchNt(..)) if !matcher => {\n             let mut seq = vec![];\n             for i in 0..tt.len() {\n                 seq.push(tt.get_tt(i));\n             }\n-            mk_tts(cx, &seq[..])\n+            statements_mk_tts(cx, &seq[..], matcher)\n         }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call(sp,\n                                      mk_ast_path(cx, sp, \"TtToken\"),\n-                                     vec!(e_sp, mk_token(cx, sp, tok)));\n+                                     vec!(e_sp, expr_mk_token(cx, sp, tok)));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n@@ -683,27 +724,61 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             vec!(cx.stmt_expr(e_push))\n         },\n         ast::TtDelimited(_, ref delimed) => {\n-            mk_tt(cx, &delimed.open_tt()).into_iter()\n-                .chain(delimed.tts.iter().flat_map(|tt| mk_tt(cx, tt).into_iter()))\n-                .chain(mk_tt(cx, &delimed.close_tt()).into_iter())\n+            statements_mk_tt(cx, &delimed.open_tt(), matcher).into_iter()\n+                .chain(delimed.tts.iter()\n+                                  .flat_map(|tt| statements_mk_tt(cx, tt, matcher).into_iter()))\n+                .chain(statements_mk_tt(cx, &delimed.close_tt(), matcher).into_iter())\n                 .collect()\n         },\n-        ast::TtSequence(..) => panic!(\"TtSequence in quote!\"),\n-    }\n-}\n+        ast::TtSequence(sp, ref seq) => {\n+            if !matcher {\n+                panic!(\"TtSequence in quote!\");\n+            }\n \n-fn mk_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> Vec<P<ast::Stmt>> {\n-    let mut ss = Vec::new();\n-    for tt in tts {\n-        ss.extend(mk_tt(cx, tt).into_iter());\n+            let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n+\n+            let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n+            let mut tts_stmts = vec![stmt_let_tt];\n+            tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher).into_iter());\n+            let e_tts = cx.expr_block(cx.block(sp, tts_stmts,\n+                                                   Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+            let e_separator = match seq.separator {\n+                Some(ref sep) => cx.expr_some(sp, expr_mk_token(cx, sp, sep)),\n+                None => cx.expr_none(sp),\n+            };\n+            let e_op = match seq.op {\n+                ast::ZeroOrMore => mk_ast_path(cx, sp, \"ZeroOrMore\"),\n+                ast::OneOrMore => mk_ast_path(cx, sp, \"OneOrMore\"),\n+            };\n+            let fields = vec![cx.field_imm(sp, id_ext(\"tts\"), e_tts),\n+                              cx.field_imm(sp, id_ext(\"separator\"), e_separator),\n+                              cx.field_imm(sp, id_ext(\"op\"), e_op),\n+                              cx.field_imm(sp, id_ext(\"num_captures\"),\n+                                               cx.expr_usize(sp, seq.num_captures))];\n+            let seq_path = vec![id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(\"SequenceRepetition\")];\n+            let e_seq_struct = cx.expr_struct(sp, cx.path_global(sp, seq_path), fields);\n+            let e_rc_new = cx.expr_call_global(sp, vec![id_ext(\"std\"),\n+                                                        id_ext(\"rc\"),\n+                                                        id_ext(\"Rc\"),\n+                                                        id_ext(\"new\")],\n+                                                   vec![e_seq_struct]);\n+            let e_tok = cx.expr_call(sp,\n+                                     mk_ast_path(cx, sp, \"TtSequence\"),\n+                                     vec!(e_sp, e_rc_new));\n+            let e_push =\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"push\"),\n+                                    vec!(e_tok));\n+            vec!(cx.stmt_expr(e_push))\n+        }\n     }\n-    ss\n }\n \n-fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-              -> (P<ast::Expr>, P<ast::Expr>) {\n+fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[ast::TokenTree])\n+                            -> (P<ast::Expr>, Vec<ast::TokenTree>) {\n     // NB: It appears that the main parser loses its mind if we consider\n-    // $foo as a TtNonterminal during the main parse, so we have to re-parse\n+    // $foo as a SubstNt during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n@@ -719,6 +794,10 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let tts = p.parse_all_token_trees();\n     p.abort_if_errors();\n \n+    (cx_expr, tts)\n+}\n+\n+fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<P<ast::Stmt>> {\n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n     // This causes every span in a token-tree quote to be attributed to the\n@@ -756,8 +835,23 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n-    let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.extend(mk_tts(cx, &tts[..]).into_iter());\n+    vec!(stmt_let_sp, stmt_let_tt)\n+}\n+\n+fn statements_mk_tts(cx: &ExtCtxt, tts: &[ast::TokenTree], matcher: bool) -> Vec<P<ast::Stmt>> {\n+    let mut ss = Vec::new();\n+    for tt in tts {\n+        ss.extend(statements_mk_tt(cx, tt, matcher).into_iter());\n+    }\n+    ss\n+}\n+\n+fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+              -> (P<ast::Expr>, P<ast::Expr>) {\n+    let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n+\n+    let mut vector = mk_stmts_let(cx, sp);\n+    vector.extend(statements_mk_tts(cx, &tts[..], false).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      vector,\n@@ -769,14 +863,14 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: P<ast::Expr>,\n-                  expr: P<ast::Expr>) -> P<ast::Expr> {\n+                  expr: P<ast::Expr>,\n+                  imports: &[&[&str]]) -> P<ast::Expr> {\n     // Explicitly borrow to avoid moving from the invoker (#16992)\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    let stmts = [\n-        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n-    ].iter().map(|path| {\n+    let stmts = imports.iter().map(|path| {\n+        // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n         cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n     }).chain(Some(stmt_let_ext_cx).into_iter()).collect();\n@@ -807,5 +901,10 @@ fn expand_parse_call(cx: &ExtCtxt,\n     let expr = cx.expr_method_call(sp, new_parser_call, id_ext(parse_method),\n                                    arg_exprs);\n \n-    expand_wrapper(cx, sp, cx_expr, expr)\n+    if parse_method == \"parse_attribute\" {\n+        expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"],\n+                                                &[\"syntax\", \"parse\", \"attr\"]])\n+    } else {\n+        expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]])\n+    }\n }"}, {"sha": "3a744d4b907f76f73156352ff08c987ce4ebe090", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -243,12 +243,15 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n     ret_val\n }\n \n-pub enum ParseResult {\n-    Success(HashMap<Ident, Rc<NamedMatch>>),\n+pub enum ParseResult<T> {\n+    Success(T),\n     Failure(codemap::Span, String),\n     Error(codemap::Span, String)\n }\n \n+pub type NamedParseResult = ParseResult<HashMap<Ident, Rc<NamedMatch>>>;\n+pub type PositionalParseResult = ParseResult<Vec<Rc<NamedMatch>>>;\n+\n pub fn parse_or_else(sess: &ParseSess,\n                      cfg: ast::CrateConfig,\n                      rdr: TtReader,\n@@ -280,7 +283,7 @@ pub fn parse(sess: &ParseSess,\n              cfg: ast::CrateConfig,\n              mut rdr: TtReader,\n              ms: &[TokenTree])\n-             -> ParseResult {\n+             -> NamedParseResult {\n     let mut cur_eis = Vec::new();\n     cur_eis.push(initial_matcher_pos(Rc::new(ms.iter()\n                                                 .cloned()"}, {"sha": "d6787646e7612fde1da3d4e01429a055941e30ca", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -15,7 +15,7 @@ use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else};\n-use parse::lexer::{new_tt_reader, new_tt_reader_with_doc_flag};\n+use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n use parse::token::{self, special_idents, gensym_ident, NtTT, Token};\n@@ -154,15 +154,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 TtDelimited(_, ref delim) => &delim.tts[..],\n                 _ => cx.span_fatal(sp, \"malformed macro lhs\")\n             };\n-            // `None` is because we're not interpolating\n-            let arg_rdr = new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n-                                                      None,\n-                                                      None,\n-                                                      arg.iter()\n-                                                         .cloned()\n-                                                         .collect(),\n-                                                      true);\n-            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, lhs_tt) {\n+\n+            match TokenTree::parse(cx, lhs_tt, arg) {\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?"}, {"sha": "d9a2b06e0393f6f9899af007653ddf0cadc22e4e", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![crate_type=\"dylib\"]\n+#![feature(plugin_registrar, quote)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use syntax::codemap::Span;\n+use syntax::parse::token::{self, str_to_ident, NtExpr, NtPat};\n+use syntax::ast::{TokenTree, TtToken, Pat};\n+use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n+use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n+use syntax::ptr::P;\n+use rustc::plugin::Registry;\n+\n+fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n+        -> Box<MacResult + 'static> {\n+\n+    let mbe_matcher = quote_matcher!(cx, $matched:expr, $($pat:pat)|+);\n+\n+    let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n+        Success(map) => {\n+            match (&*map[str_to_ident(\"matched\")], &*map[str_to_ident(\"pat\")]) {\n+                (&MatchedNonterminal(NtExpr(ref matched_expr)),\n+                 &MatchedSeq(ref pats, seq_sp)) => {\n+                    let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|\n+                        if let &MatchedNonterminal(NtPat(ref pat)) = &**pat_nt {\n+                            pat.clone()\n+                        } else {\n+                            unreachable!()\n+                        }\n+                    ).collect();\n+                    let arm = cx.arm(seq_sp, pats, cx.expr_bool(seq_sp, true));\n+\n+                    quote_expr!(cx,\n+                        match $matched_expr {\n+                            $arm\n+                            _ => false\n+                        }\n+                    )\n+                }\n+                _ => unreachable!()\n+            }\n+        }\n+        Failure(_, s) | Error(_, s) => {\n+            panic!(\"expected Success, but got Error/Failure: {}\", s);\n+        }\n+    };\n+\n+    MacEager::expr(mac_expr)\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"matches\", expand_mbe_matches);\n+}"}, {"sha": "5383b11cf5363d720858fb93248c2d19a4eacea7", "filename": "src/test/run-pass-fulldeps/mbe_matching_test_macro.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:procedural_mbe_matching.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![plugin(procedural_mbe_matching)]\n+\n+#[no_link]\n+extern crate procedural_mbe_matching;\n+\n+pub fn main() {\n+    let abc = 123u32;\n+    assert_eq!(matches!(Some(123), None | Some(0)), false);\n+    assert_eq!(matches!(Some(123), None | Some(123)), true);\n+    assert_eq!(matches!(true, true), true);\n+}"}, {"sha": "92cb0d71e4570fe6f422f4549b6da83ff07d64b3", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -74,6 +74,9 @@ fn main() {\n \n     let arm = quote_arm!(cx, (ref x, ref y) => (x, y));\n     check_pp(ext_cx, arm, pprust::print_stmt, \"(ref x, ref y) = (x, y)\".to_string());\n+\n+    let attr = quote_attr!(cx, #![cfg(foo = \"bar\")]);\n+    check_pp(ext_cx, attr, pprust::print_attribute, \"#![cfg(foo = \"bar\")]\".to_string());\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,"}, {"sha": "4e6f9b46402956e51100735eda180f76e0b6d4dc", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541abedeb1aa2c02929cf6828055d01cbe50e03/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=3541abedeb1aa2c02929cf6828055d01cbe50e03", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -40,6 +40,9 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let _k: P<syntax::ast::Method> = quote_method!(cx, #[doc = \"hello\"] fn foo(&self) {});\n \n     let _l: P<syntax::ast::Ty> = quote_ty!(cx, &int);\n+\n+    let _m: Vec<syntax::ast::TokenTree> = quote_matcher!(cx, $($foo:tt,)* bar);\n+    let _n: syntax::ast::Attribute = quote_attr!(cx, #![cfg(foo, bar = \"baz\")]);\n }\n \n fn main() {"}]}