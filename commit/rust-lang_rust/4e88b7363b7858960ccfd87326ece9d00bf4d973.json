{"sha": "4e88b7363b7858960ccfd87326ece9d00bf4d973", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlODhiNzM2M2I3ODU4OTYwY2NmZDg3MzI2ZWNlOWQwMGJmNGQ5NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-29T03:28:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-29T03:28:31Z"}, "message": "Auto merge of #55270 - RalfJung:stacked-borrows-ng, r=oli-obk\n\nmiri engine: Stacked Borrows NG\n\nFor more refined tracking in miri, we do return untagged pointers from the memory abstraction after allocations and let the caller decide how to tag these.\n\nAlso refactor the `tag_(de)reference` hooks so they can be more easily called in the ref-to-place and place-to-ref methods, and reorder things in validation: validation calls ref-to-place which (when running in miri) triggers some checks, so we want to run it rather late and catch other problems first. We also do not need to redundantly check the ref to be allocated any more, the checks miri does anyway imply thath.\n\nr? @oli-obk", "tree": {"sha": "bbece503c44c85eaac69e2bc0c46d3cf5192f16e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbece503c44c85eaac69e2bc0c46d3cf5192f16e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973", "html_url": "https://github.com/rust-lang/rust/commit/4e88b7363b7858960ccfd87326ece9d00bf4d973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "html_url": "https://github.com/rust-lang/rust/commit/bcb05a0ab23291851d0a233547f2ad3cbb9cc222"}, {"sha": "95b19bbb6f270f584b1e15a874737b59e8203544", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b19bbb6f270f584b1e15a874737b59e8203544", "html_url": "https://github.com/rust-lang/rust/commit/95b19bbb6f270f584b1e15a874737b59e8203544"}], "stats": {"total": 304, "additions": 174, "deletions": 130}, "files": [{"sha": "7db9c3f110272cd34982044c596f94825be524bb", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -20,8 +20,8 @@ use rustc::hir::{self, def_id::DefId};\n use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt, Instance, query::TyCtxtAt};\n-use rustc::ty::layout::{self, Size, LayoutOf, TyLayout};\n+use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -32,7 +32,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value, Pointer, Scalar, ConstValue,\n+    PlaceTy, MemPlace, OpTy, Operand, Value, Scalar, ConstValue, Pointer,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -426,7 +426,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Self::PointerTag>> {\n         // We do not use a tag so we can just cheaply forward the reference\n@@ -467,23 +467,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn tag_reference(\n+    fn tag_new_allocation(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _pointee_ty: Ty<'tcx>,\n-        _pointee_size: Size,\n-        _borrow_kind: Option<mir::BorrowKind>,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_dereference(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _ptr_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n-        Ok(())\n+        ptr: Pointer,\n+        _kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        Ok(ptr)\n     }\n }\n "}, {"sha": "b2c8cba480259d6bf4a83c940a425b69c487c039", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                        let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -143,7 +143,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance);\n+                        let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                         let val = Value::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_value(val, dest)?;\n                     }"}, {"sha": "bc7ad16dc97bc7b59caee2cd1b65736c9652f362", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -47,7 +47,7 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n-    pub memory: Memory<'a, 'mir, 'tcx, M>,\n+    pub(crate) memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag>>,\n@@ -334,7 +334,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n-        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n+        let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n "}, {"sha": "7811dcb0663d5249d4d48bf088b43d5b2ea6ada0", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -15,13 +15,13 @@\n use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n use rustc::ty::{self, Ty, layout::{Size, TyLayout}, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar,\n-    EvalContext, PlaceTy, OpTy, Pointer, MemoryKind,\n+    EvalContext, PlaceTy, OpTy, Pointer, MemPlace, MemoryKind,\n };\n \n /// Classifying memory accesses\n@@ -81,6 +81,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Tag tracked alongside every pointer.  This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n+    /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n \n     /// Extra data stored in every allocation.\n@@ -151,13 +152,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n     /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the appropriate tags on each pointer.\n+    /// the right type for this machine.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n-    /// allocation (because a copy had to be done to add the tags), machine memory will\n+    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n@@ -204,24 +205,40 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n+    /// Add the tag for a newly allocated pointer.\n+    fn tag_new_allocation(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer<Self::PointerTag>>;\n+\n     /// Executed when evaluating the `&` operator: Creating a new reference.\n-    /// This has the chance to adjust the tag.\n-    /// `borrow_kind` can be `None` in case a raw ptr is being created.\n+    /// This has the chance to adjust the tag.  It should not change anything else!\n+    /// `mutability` can be `None` in case a raw ptr is being created.\n+    #[inline]\n     fn tag_reference(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n-        borrow_kind: Option<mir::BorrowKind>,\n-    ) -> EvalResult<'tcx, Self::PointerTag>;\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        place: MemPlace<Self::PointerTag>,\n+        _ty: Ty<'tcx>,\n+        _size: Size,\n+        _mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n+        Ok(place)\n+    }\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the change to adjust the tag.\n+    /// This has the change to adjust the tag.  It should not change anything else!\n+    /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n+    #[inline]\n     fn tag_dereference(\n-        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-        ptr_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Self::PointerTag>;\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        place: MemPlace<Self::PointerTag>,\n+        _ty: Ty<'tcx>,\n+        _size: Size,\n+        _mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n+        Ok(place)\n+    }\n \n     /// Execute a validation operation\n     #[inline]"}, {"sha": "689a29cff6e9e465554829b05194cf14da53f332", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -117,12 +117,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance)).with_default_tag()\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n+        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance))\n     }\n \n-    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer<M::PointerTag> {\n-        Pointer::from(self.tcx.allocate_bytes(bytes)).with_default_tag()\n+    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n+        Pointer::from(self.tcx.allocate_bytes(bytes))\n     }\n \n     pub fn allocate_with(\n@@ -140,9 +140,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n-        let ptr = Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?);\n-        Ok(ptr.with_default_tag())\n+    ) -> EvalResult<'tcx, Pointer> {\n+        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?))\n     }\n \n     pub fn reallocate(\n@@ -153,17 +152,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n \n-        // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n+        // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n+        // This happens so rarely, the perf advantage is outweighed by the maintenance cost.\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n         self.copy(\n             ptr.into(),\n             old_align,\n-            new_ptr.into(),\n+            new_ptr.with_default_tag().into(),\n             new_align,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n@@ -347,7 +347,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Some(AllocType::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n-                return Ok(M::static_with_default_tag(mem))\n+                return Ok(M::adjust_static_allocation(mem))\n             }\n             Some(AllocType::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n@@ -381,7 +381,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n-                M::static_with_default_tag(allocation)\n+                M::adjust_static_allocation(allocation)\n             } else {\n                 bug!(\"Matching on non-ByRef static\")\n             }"}, {"sha": "d0a32161485b4218e50b2834e96f7e01226b94cf", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -217,6 +217,16 @@ impl<'tcx, Tag> Value<Tag> {\n             Value::ScalarPair(ptr, _) => ptr.not_undef(),\n         }\n     }\n+\n+    /// Convert the value into its metadata.\n+    /// Throws away the first half of a ScalarPair!\n+    #[inline]\n+    pub fn to_meta(self) -> EvalResult<'tcx, Option<Scalar<Tag>>> {\n+        Ok(match self {\n+            Value::Scalar(_) => None,\n+            Value::ScalarPair(_, meta) => Some(meta.not_undef()?),\n+        })\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have a value and a type together"}, {"sha": "0eae2bfb226c614fa47c7f7549e032895d1985fa", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -15,6 +15,7 @@\n use std::convert::TryFrom;\n use std::hash::Hash;\n \n+use rustc::hir;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n@@ -270,24 +271,28 @@ where\n         &self,\n         val: ValTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let ptr = match val.to_scalar_ptr()? {\n-            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n-                // Machine might want to track the `*` operator\n-                let tag = M::tag_dereference(self, ptr, val.layout.ty)?;\n-                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n-            }\n-            other => other,\n-        };\n-\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n-        let align = layout.align;\n \n-        let mplace = match *val {\n-            Value::Scalar(_) =>\n-                MemPlace { ptr, align, meta: None },\n-            Value::ScalarPair(_, meta) =>\n-                MemPlace { ptr, align, meta: Some(meta.not_undef()?) },\n+        let align = layout.align;\n+        let meta = val.to_meta()?;\n+        let ptr = val.to_scalar_ptr()?;\n+        let mplace = MemPlace { ptr, align, meta };\n+        // Pointer tag tracking might want to adjust the tag.\n+        let mplace = if M::ENABLE_PTR_TRACKING_HOOKS {\n+            let (size, _) = self.size_and_align_of(meta, layout)?\n+                // for extern types, just cover what we can\n+                .unwrap_or_else(|| layout.size_and_align());\n+            let mutbl = match val.layout.ty.sty {\n+                // `builtin_deref` considers boxes immutable, that's useless for our purposes\n+                ty::Ref(_, _, mutbl) => Some(mutbl),\n+                ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n+                ty::RawPtr(_) => None,\n+                _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n+            };\n+            M::tag_dereference(self, mplace, pointee_type, size, mutbl)?\n+        } else {\n+            mplace\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -299,19 +304,25 @@ where\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         borrow_kind: Option<mir::BorrowKind>,\n     ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n-        let ptr = match place.ptr {\n-            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n-                // Machine might want to track the `&` operator\n-                let (size, _) = self.size_and_align_of_mplace(place)?\n-                    .expect(\"create_ref cannot determine size\");\n-                let tag = M::tag_reference(self, ptr, place.layout.ty, size, borrow_kind)?;\n-                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n-            },\n-            other => other,\n+        // Pointer tag tracking might want to adjust the tag\n+        let place = if M::ENABLE_PTR_TRACKING_HOOKS {\n+            let (size, _) = self.size_and_align_of_mplace(place)?\n+                // for extern types, just cover what we can\n+                .unwrap_or_else(|| place.layout.size_and_align());\n+            let mutbl = match borrow_kind {\n+                Some(mir::BorrowKind::Mut { .. }) |\n+                Some(mir::BorrowKind::Unique) =>\n+                    Some(hir::MutMutable),\n+                Some(_) => Some(hir::MutImmutable),\n+                None => None,\n+            };\n+            M::tag_reference(self, *place, place.layout.ty, size, mutbl)?\n+        } else {\n+            *place\n         };\n         Ok(match place.meta {\n-            None => Value::Scalar(ptr.into()),\n-            Some(meta) => Value::ScalarPair(ptr.into(), meta.into()),\n+            None => Value::Scalar(place.ptr.into()),\n+            Some(meta) => Value::ScalarPair(place.ptr.into(), meta.into()),\n         })\n     }\n \n@@ -845,6 +856,8 @@ where\n     }\n \n     /// Make sure that a place is in memory, and return where it is.\n+    /// If the place currently refers to a local that doesn't yet have a matching allocation,\n+    /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n     pub fn force_allocation(\n         &mut self,\n@@ -888,10 +901,11 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         if layout.is_unsized() {\n             assert!(self.tcx.features().unsized_locals, \"cannot alloc memory for unsized type\");\n-            // FIXME: What should we do here?\n+            // FIXME: What should we do here? We should definitely also tag!\n             Ok(MPlaceTy::dangling(layout, &self))\n         } else {\n             let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n+            let ptr = M::tag_new_allocation(self, ptr, kind)?;\n             Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n         }\n     }"}, {"sha": "c189ec0ca5c7717231defc15f5b7d33678c8a1b5", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -54,10 +54,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Vtable,\n-        )?;\n+        )?.with_default_tag();\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n+        let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n         self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n                 self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }"}, {"sha": "226717538a29484e9e793af4bb882751d43549cc", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e88b7363b7858960ccfd87326ece9d00bf4d973/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4e88b7363b7858960ccfd87326ece9d00bf4d973", "patch": "@@ -12,7 +12,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Align, TyLayout};\n+use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n@@ -176,19 +176,27 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // undef. We should fix that, but let's start low.\n                 }\n             }\n-            _ if ty.is_box() || ty.is_region_ptr() || ty.is_unsafe_ptr() => {\n-                // Handle fat pointers. We also check fat raw pointers,\n-                // their metadata must be valid!\n-                // This also checks that the ptr itself is initialized, which\n-                // seems reasonable even for raw pointers.\n-                let place = try_validation!(self.ref_to_mplace(value),\n-                    \"undefined data in pointer\", path);\n+            ty::RawPtr(..) => {\n+                // No undef allowed here.  Eventually this should be consistent with\n+                // the integer types.\n+                let _ptr = try_validation!(value.to_scalar_ptr(),\n+                    \"undefined address in pointer\", path);\n+                let _meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in fat pointer metadata\", path);\n+            }\n+            _ if ty.is_box() || ty.is_region_ptr() => {\n+                // Handle fat pointers.\n                 // Check metadata early, for better diagnostics\n-                if place.layout.is_unsized() {\n-                    let tail = self.tcx.struct_tail(place.layout.ty);\n+                let ptr = try_validation!(value.to_scalar_ptr(),\n+                    \"undefined address in pointer\", path);\n+                let meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in fat pointer metadata\", path);\n+                let layout = self.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    let tail = self.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n-                            let vtable = try_validation!(place.meta.unwrap().to_ptr(),\n+                            let vtable = try_validation!(meta.unwrap().to_ptr(),\n                                 \"non-pointer vtable in fat pointer\", path);\n                             try_validation!(self.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", path);\n@@ -197,7 +205,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(place.meta.unwrap().to_usize(self),\n+                            try_validation!(meta.unwrap().to_usize(self),\n                                 \"non-integer slice length in fat pointer\", path);\n                         }\n                         ty::Foreign(..) => {\n@@ -207,59 +215,65 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             bug!(\"Unexpected unsized type tail: {:?}\", tail),\n                     }\n                 }\n-                // for safe ptrs, also check the ptr values itself\n-                if !ty.is_unsafe_ptr() {\n-                    // Make sure this is non-NULL and aligned\n-                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?\n-                        // for the purpose of validity, consider foreign types to have\n-                        // alignment and size determined by the layout (size will be 0,\n-                        // alignment should take attributes into account).\n-                        .unwrap_or_else(|| place.layout.size_and_align());\n-                    match self.memory.check_align(place.ptr, align) {\n-                        Ok(_) => {},\n-                        Err(err) => match err.kind {\n+                // Make sure this is non-NULL and aligned\n+                let (size, align) = self.size_and_align_of(meta, layout)?\n+                    // for the purpose of validity, consider foreign types to have\n+                    // alignment and size determined by the layout (size will be 0,\n+                    // alignment should take attributes into account).\n+                    .unwrap_or_else(|| layout.size_and_align());\n+                match self.memory.check_align(ptr, align) {\n+                    Ok(_) => {},\n+                    Err(err) => {\n+                        error!(\"{:?} is not aligned to {:?}\", ptr, align);\n+                        match err.kind {\n                             EvalErrorKind::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", path),\n                             EvalErrorKind::AlignmentCheckFailed { .. } =>\n                                 return validation_failure!(\"unaligned reference\", path),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (out-of-bounds) reference (might be NULL at \\\n-                                     run-time)\",\n+                                        run-time)\",\n                                     path\n                                 ),\n                         }\n                     }\n-                    // non-ZST also have to be dereferenceable\n+                }\n+                // Turn ptr into place.\n+                // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n+                // which in turn will (in full miri) check if the pointer is dereferencable.\n+                let place = self.ref_to_mplace(value)?;\n+                // Recursive checking\n+                if let Some(ref_tracking) = ref_tracking {\n+                    assert!(const_mode, \"We should only do recursie checking in const mode\");\n                     if size != Size::ZERO {\n+                        // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n                             \"integer pointer in non-ZST reference\", path);\n-                        if const_mode {\n-                            // Skip validation entirely for some external statics\n-                            let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                            if let Some(AllocType::Static(did)) = alloc_kind {\n-                                // `extern static` cannot be validated as they have no body.\n-                                // FIXME: Statics from other crates are also skipped.\n-                                // They might be checked at a different type, but for now we\n-                                // want to avoid recursing too deeply.  This is not sound!\n-                                if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                    return Ok(());\n-                                }\n+                        // Skip validation entirely for some external statics\n+                        let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        if let Some(AllocType::Static(did)) = alloc_kind {\n+                            // `extern static` cannot be validated as they have no body.\n+                            // FIXME: Statics from other crates are also skipped.\n+                            // They might be checked at a different type, but for now we\n+                            // want to avoid recursing too deeply.  This is not sound!\n+                            if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                return Ok(());\n                             }\n                         }\n+                        // Maintain the invariant that the place we are checking is\n+                        // already verified to be in-bounds.\n                         try_validation!(self.memory.check_bounds(ptr, size, false),\n                             \"dangling (not entirely in bounds) reference\", path);\n                     }\n-                    if let Some(ref_tracking) = ref_tracking {\n-                        // Check if we have encountered this pointer+layout combination\n-                        // before.  Proceed recursively even for integer pointers, no\n-                        // reason to skip them! They are (recursively) valid for some ZST,\n-                        // but not for others (e.g. `!` is a ZST).\n-                        let op = place.into();\n-                        if ref_tracking.seen.insert(op) {\n-                            trace!(\"Recursing below ptr {:#?}\", *op);\n-                            ref_tracking.todo.push((op, path_clone_and_deref(path)));\n-                        }\n+                    // Check if we have encountered this pointer+layout combination\n+                    // before.  Proceed recursively even for integer pointers, no\n+                    // reason to skip them! They are (recursively) valid for some ZST,\n+                    // but not for others (e.g. `!` is a ZST).\n+                    let op = place.into();\n+                    if ref_tracking.seen.insert(op) {\n+                        trace!(\"Recursing below ptr {:#?}\", *op);\n+                        ref_tracking.todo.push((op, path_clone_and_deref(path)));\n                     }\n                 }\n             }"}]}