{"sha": "2d1e129851a6133da72bc44eea9a48530d42e54d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMWUxMjk4NTFhNjEzM2RhNzJiYzQ0ZWVhOWE0ODUzMGQ0MmU1NGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-15T16:25:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-15T16:25:03Z"}, "message": "Auto merge of #6574 - Jarcho:single_match_eq, r=Manishearth\n\nsingle_match: suggest `if` over `if let` when possible\n\nfixes: #173\nchangelog: single_match: suggest `if` over `if let` when possible", "tree": {"sha": "2255d86c976ae2c5730b230c074df444ed7d1e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2255d86c976ae2c5730b230c074df444ed7d1e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1e129851a6133da72bc44eea9a48530d42e54d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1e129851a6133da72bc44eea9a48530d42e54d", "html_url": "https://github.com/rust-lang/rust/commit/2d1e129851a6133da72bc44eea9a48530d42e54d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1e129851a6133da72bc44eea9a48530d42e54d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9490fdca0941079c669307f34fb75a20802533ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/9490fdca0941079c669307f34fb75a20802533ba", "html_url": "https://github.com/rust-lang/rust/commit/9490fdca0941079c669307f34fb75a20802533ba"}, {"sha": "36ff2f739c62f81d5ecc1850d9f3354d15de928d", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ff2f739c62f81d5ecc1850d9f3354d15de928d", "html_url": "https://github.com/rust-lang/rust/commit/36ff2f739c62f81d5ecc1850d9f3354d15de928d"}], "stats": {"total": 234, "additions": 211, "deletions": 23}, "files": [{"sha": "02021b873695f9dfc858e8a67955e7e2c809f775", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e129851a6133da72bc44eea9a48530d42e54d/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e129851a6133da72bc44eea9a48530d42e54d/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=2d1e129851a6133da72bc44eea9a48530d42e54d", "patch": "@@ -2,10 +2,10 @@ use crate::consts::{constant, miri_to_const, Constant};\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg, remove_blocks,\n-    snippet, snippet_block, snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note,\n-    span_lint_and_sugg, span_lint_and_then,\n+    expr_block, get_arg_name, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of,\n+    is_refutable, is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg,\n+    peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n+    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n@@ -728,20 +728,60 @@ fn report_single_match_single_pattern(\n     let els_str = els.map_or(String::new(), |els| {\n         format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n+\n+    let (msg, sugg) = if_chain! {\n+        let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str() || implements_trait(cx, ty, trait_id, &[]);\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n     span_lint_and_sugg(\n         cx,\n         lint,\n         expr.span,\n-        \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n-         let`\",\n+        msg,\n         \"try this\",\n-        format!(\n-            \"if let {} = {} {}{}\",\n-            snippet(cx, arms[0].pat.span, \"..\"),\n-            snippet(cx, ex.span, \"..\"),\n-            expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n-            els_str,\n-        ),\n+        sugg,\n         Applicability::HasPlaceholders,\n     );\n }"}, {"sha": "62aae749c17dce2a9fb395f84eca16ac130072e1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e129851a6133da72bc44eea9a48530d42e54d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e129851a6133da72bc44eea9a48530d42e54d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2d1e129851a6133da72bc44eea9a48530d42e54d", "patch": "@@ -1669,6 +1669,44 @@ where\n     match_expr_list\n }\n \n+/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n+/// references removed.\n+pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+        if let PatKind::Ref(pat, _) = pat.kind {\n+            peel(pat, count + 1)\n+        } else {\n+            (pat, count)\n+        }\n+    }\n+    peel(pat, 0)\n+}\n+\n+/// Peels off up to the given number of references on the expression. Returns the underlying\n+/// expression and the number of references removed.\n+pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0, count)\n+}\n+\n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n+    }\n+    peel(ty, 0)\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "ca884b41c45792ae0a6a16d39802b06b3c6fb070", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=2d1e129851a6133da72bc44eea9a48530d42e54d", "patch": "@@ -81,6 +81,62 @@ fn single_match_know_enum() {\n     }\n }\n \n+// issue #173\n+fn if_suggestion() {\n+    let x = \"test\";\n+    match x {\n+        \"test\" => println!(),\n+        _ => (),\n+    }\n+\n+    #[derive(PartialEq, Eq)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(u32),\n+    }\n+\n+    let x = Foo::A;\n+    match x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    const FOO_C: Foo = Foo::C(0);\n+    match x {\n+        FOO_C => println!(),\n+        _ => (),\n+    }\n+\n+    match &&x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    let x = &x;\n+    match &x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    enum Bar {\n+        A,\n+        B,\n+    }\n+    impl PartialEq for Bar {\n+        fn eq(&self, rhs: &Self) -> bool {\n+            matches!((self, rhs), (Self::A, Self::A) | (Self::B, Self::B))\n+        }\n+    }\n+    impl Eq for Bar {}\n+\n+    let x = Bar::A;\n+    match x {\n+        Bar::A => println!(),\n+        _ => (),\n+    }\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "7ea6955b7401e4ecb17ca4995b820a10bf4bb5c3", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=2d1e129851a6133da72bc44eea9a48530d42e54d", "patch": "@@ -1,4 +1,4 @@\n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:8:5\n    |\n LL | /     match x {\n@@ -17,7 +17,7 @@ LL |         println!(\"{:?}\", y);\n LL |     };\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:16:5\n    |\n LL | /     match x {\n@@ -29,7 +29,7 @@ LL | |         _ => (),\n LL | |     }\n    | |_____^ help: try this: `if let Some(y) = x { println!(\"{:?}\", y) }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:25:5\n    |\n LL | /     match z {\n@@ -38,7 +38,7 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:54:5\n    |\n LL | /     match x {\n@@ -47,7 +47,7 @@ LL | |         None => (),\n LL | |     };\n    | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n LL | /     match y {\n@@ -56,7 +56,7 @@ LL | |         Err(..) => (),\n LL | |     };\n    | |_____^ help: try this: `if let Ok(y) = y { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:66:5\n    |\n LL | /     match c {\n@@ -65,5 +65,59 @@ LL | |         Cow::Owned(..) => (),\n LL | |     };\n    | |_____^ help: try this: `if let Cow::Borrowed(..) = c { dummy() }`\n \n-error: aborting due to 6 previous errors\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:87:5\n+   |\n+LL | /     match x {\n+LL | |         \"test\" => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == \"test\" { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:100:5\n+   |\n+LL | /     match x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:106:5\n+   |\n+LL | /     match x {\n+LL | |         FOO_C => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == FOO_C { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:111:5\n+   |\n+LL | /     match &&x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:117:5\n+   |\n+LL | /     match &x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == &Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:134:5\n+   |\n+LL | /     match x {\n+LL | |         Bar::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if let Bar::A = x { println!() }`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "20be4fa226cf154f1de72a8dcb6ab2f71285a79b", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e129851a6133da72bc44eea9a48530d42e54d/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=2d1e129851a6133da72bc44eea9a48530d42e54d", "patch": "@@ -1,4 +1,4 @@\n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:14:5\n    |\n LL | /     match ExprNode::Butterflies {\n@@ -19,7 +19,7 @@ LL |         None\n LL |     }\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:70:5\n    |\n LL | /     match Some(1) {\n@@ -39,7 +39,7 @@ LL |         return\n LL |     }\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:79:5\n    |\n LL | /     match Some(1) {"}]}