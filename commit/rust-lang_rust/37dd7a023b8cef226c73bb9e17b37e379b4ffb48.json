{"sha": "37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZGQ3YTAyM2I4Y2VmMjI2YzczYmI5ZTE3YjM3ZTM3OWI0ZmZiNDg=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-07-21T21:32:36Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-07-21T21:32:36Z"}, "message": "Remove Linux workarounds for missing CLOEXEC support\n\nNow that #74163 updated the minimum Linux kernel to 2.6.32, we can\nassume the availability of APIs that open file descriptors that are\nalready set to close on exec, including the flags `O_CLOEXEC`,\n`SOCK_CLOEXEC`, and `F_DUPFD_CLOEXEC`.", "tree": {"sha": "bdc22036dac7caee8a652cbd609f5825f12cb428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc22036dac7caee8a652cbd609f5825f12cb428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "html_url": "https://github.com/rust-lang/rust/commit/37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ad7bc3f428300aee6764f6e23527e19eb235e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad7bc3f428300aee6764f6e23527e19eb235e81", "html_url": "https://github.com/rust-lang/rust/commit/8ad7bc3f428300aee6764f6e23527e19eb235e81"}], "stats": {"total": 245, "additions": 58, "deletions": 187}, "files": [{"sha": "451ebd97c3f0b6119e7c2ec83c99b0ea5f084e91", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "patch": "@@ -3,7 +3,6 @@\n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n \n@@ -223,50 +222,9 @@ impl FileDesc {\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // flag, however, isn't supported on older Linux kernels (earlier than\n-        // 2.6.24).\n-        //\n-        // To detect this and ensure that CLOEXEC is still set, we\n-        // follow a strategy similar to musl [1] where if passing\n-        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n-        // supported (the third parameter, 0, is always valid), so we stop\n-        // trying that.\n-        //\n-        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n-        // resolve so we at least compile this.\n-        //\n-        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n-        #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n-        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(any(target_os = \"android\", target_os = \"haiku\")))]\n-        use libc::F_DUPFD_CLOEXEC;\n-\n-        let make_filedesc = |fd| {\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            Ok(fd)\n-        };\n-        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(!cfg!(target_os = \"android\"));\n-        let fd = self.raw();\n-        if TRY_CLOEXEC.load(Ordering::Relaxed) {\n-            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n-                // We *still* call the `set_cloexec` method as apparently some\n-                // linux kernel at some point stopped setting CLOEXEC even\n-                // though it reported doing so on F_DUPFD_CLOEXEC.\n-                Ok(fd) => {\n-                    return Ok(if cfg!(target_os = \"linux\") {\n-                        make_filedesc(fd)?\n-                    } else {\n-                        FileDesc::new(fd)\n-                    });\n-                }\n-                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n-                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n-                }\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).and_then(make_filedesc)\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n+        Ok(FileDesc::new(fd))\n     }\n }\n "}, {"sha": "acb18e6d064e6e826d0e3910035e12fd516f1e98", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "patch": "@@ -708,56 +708,7 @@ impl File {\n         // However, since this is a variadic function, C integer promotion rules mean that on\n         // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        let fd = FileDesc::new(fd);\n-\n-        // Currently the standard library supports Linux 2.6.18 which did not\n-        // have the O_CLOEXEC flag (passed above). If we're running on an older\n-        // Linux kernel then the flag is just ignored by the OS. After we open\n-        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n-        // we will explicitly ask for a CLOEXEC fd for every further file we\n-        // open, if it does, we will skip that step.\n-        //\n-        // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n-        // that we support, so we only do this on Linux currently.\n-        #[cfg(target_os = \"linux\")]\n-        fn ensure_cloexec(fd: &FileDesc) -> io::Result<()> {\n-            use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-            const OPEN_CLOEXEC_UNKNOWN: usize = 0;\n-            const OPEN_CLOEXEC_SUPPORTED: usize = 1;\n-            const OPEN_CLOEXEC_NOTSUPPORTED: usize = 2;\n-            static OPEN_CLOEXEC: AtomicUsize = AtomicUsize::new(OPEN_CLOEXEC_UNKNOWN);\n-\n-            let need_to_set;\n-            match OPEN_CLOEXEC.load(Ordering::Relaxed) {\n-                OPEN_CLOEXEC_UNKNOWN => {\n-                    need_to_set = !fd.get_cloexec()?;\n-                    OPEN_CLOEXEC.store(\n-                        if need_to_set {\n-                            OPEN_CLOEXEC_NOTSUPPORTED\n-                        } else {\n-                            OPEN_CLOEXEC_SUPPORTED\n-                        },\n-                        Ordering::Relaxed,\n-                    );\n-                }\n-                OPEN_CLOEXEC_SUPPORTED => need_to_set = false,\n-                OPEN_CLOEXEC_NOTSUPPORTED => need_to_set = true,\n-                _ => unreachable!(),\n-            }\n-            if need_to_set {\n-                fd.set_cloexec()?;\n-            }\n-            Ok(())\n-        }\n-\n-        #[cfg(not(target_os = \"linux\"))]\n-        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n-            Ok(())\n-        }\n-\n-        ensure_cloexec(&fd)?;\n-        Ok(File(fd))\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {"}, {"sha": "011325fddc5b93b08304406256bcc748d7e8e3eb", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 61, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "patch": "@@ -54,56 +54,47 @@ impl Socket {\n \n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n-            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n-            // atomically create the socket and set it as CLOEXEC. Support for\n-            // this option, however, was added in 2.6.27, and we still support\n-            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n-            // fallthrough to the fallback.\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0)) {\n-                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            let fd = cvt(libc::socket(fam, ty, 0))?;\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            let socket = Socket(fd);\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // On Linux we pass the SOCK_CLOEXEC flag to atomically create\n+                    // the socket and set it as CLOEXEC, added in 2.6.27.\n+                    let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n+                    Ok(Socket(FileDesc::new(fd)))\n+                } else {\n+                    let fd = cvt(libc::socket(fam, ty, 0))?;\n+                    let fd = FileDesc::new(fd);\n+                    fd.set_cloexec()?;\n+                    let socket = Socket(fd);\n \n-            // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n-            // flag to disable `SIGPIPE` emission on socket.\n-            #[cfg(target_vendor = \"apple\")]\n-            setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n+                    // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n+                    // flag to disable `SIGPIPE` emission on socket.\n+                    #[cfg(target_vendor = \"apple\")]\n+                    setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n \n-            Ok(socket)\n+                    Ok(socket)\n+                }\n+            }\n         }\n     }\n \n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n \n-            // Like above, see if we can set cloexec atomically\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n-                    Ok(_) => {\n-                        return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n-                    }\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // Like above, set cloexec atomically\n+                    cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n+                    Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n+                } else {\n+                    cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n+                    let a = FileDesc::new(fds[0]);\n+                    let b = FileDesc::new(fds[1]);\n+                    a.set_cloexec()?;\n+                    b.set_cloexec()?;\n+                    Ok((Socket(a), Socket(b)))\n                 }\n             }\n-\n-            cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n-            let a = FileDesc::new(fds[0]);\n-            let b = FileDesc::new(fds[1]);\n-            a.set_cloexec()?;\n-            b.set_cloexec()?;\n-            Ok((Socket(a), Socket(b)))\n         }\n     }\n \n@@ -177,30 +168,20 @@ impl Socket {\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n-        // Linux. This was added in 2.6.28, however, and because we support\n-        // 2.6.18 we must detect this support dynamically.\n-        #[cfg(target_os = \"linux\")]\n-        {\n-            syscall! {\n-                fn accept4(\n-                    fd: c_int,\n-                    addr: *mut sockaddr,\n-                    addr_len: *mut socklen_t,\n-                    flags: c_int\n-                ) -> c_int\n-            }\n-            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC) });\n-            match res {\n-                Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n-                Err(e) => return Err(e),\n+        // Linux. This was added in 2.6.28, glibc 2.10 and musl 0.9.5.\n+        cfg_if::cfg_if! {\n+            if #[cfg(target_os = \"linux\")] {\n+                let fd = cvt_r(|| unsafe {\n+                    libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n+                })?;\n+                Ok(Socket(FileDesc::new(fd)))\n+            } else {\n+                let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n+                let fd = FileDesc::new(fd);\n+                fd.set_cloexec()?;\n+                Ok(Socket(fd))\n             }\n         }\n-\n-        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-        let fd = FileDesc::new(fd);\n-        fd.set_cloexec()?;\n-        Ok(Socket(fd))\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {"}, {"sha": "02a43923708a841a0186db9c75e78554d747653c", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd7a023b8cef226c73bb9e17b37e379b4ffb48/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=37dd7a023b8cef226c73bb9e17b37e379b4ffb48", "patch": "@@ -1,58 +1,39 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n \n-use libc::c_int;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct AnonPipe(FileDesc);\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    syscall! { fn pipe2(fds: *mut c_int, flags: c_int) -> c_int }\n-    static INVALID: AtomicBool = AtomicBool::new(false);\n-\n     let mut fds = [0; 2];\n \n     // Unfortunately the only known way right now to create atomically set the\n     // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n-    // 2.6.27, however, and because we support 2.6.18 we must detect this\n-    // support dynamically.\n+    // 2.6.27, glibc 2.9 and musl 0.9.3.\n     if cfg!(any(\n         target_os = \"dragonfly\",\n         target_os = \"freebsd\",\n         target_os = \"linux\",\n         target_os = \"netbsd\",\n         target_os = \"openbsd\",\n         target_os = \"redox\"\n-    )) && !INVALID.load(Ordering::SeqCst)\n-    {\n-        // Note that despite calling a glibc function here we may still\n-        // get ENOSYS. Glibc has `pipe2` since 2.9 and doesn't try to\n-        // emulate on older kernels, so if you happen to be running on\n-        // an older kernel you may see `pipe2` as a symbol but still not\n-        // see the syscall.\n-        match cvt(unsafe { pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n-            Ok(_) => {\n-                return Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))));\n-            }\n-            Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {\n-                INVALID.store(true, Ordering::SeqCst);\n-            }\n-            Err(e) => return Err(e),\n-        }\n+    )) {\n+        cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n+        Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n+    } else {\n+        cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n+\n+        let fd0 = FileDesc::new(fds[0]);\n+        let fd1 = FileDesc::new(fds[1]);\n+        fd0.set_cloexec()?;\n+        fd1.set_cloexec()?;\n+        Ok((AnonPipe(fd0), AnonPipe(fd1)))\n     }\n-    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-    let fd0 = FileDesc::new(fds[0]);\n-    let fd1 = FileDesc::new(fds[1]);\n-    fd0.set_cloexec()?;\n-    fd1.set_cloexec()?;\n-    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n }\n \n impl AnonPipe {"}]}