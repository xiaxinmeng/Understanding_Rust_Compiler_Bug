{"sha": "a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMGVlMGRlZTFhZTAyM2MzODkyMzYxYWQyYTY5OGUxZWJiY2UxMmU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-12T17:28:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-13T00:20:52Z"}, "message": "rustdoc: fix tests for @~str -> @str change.", "tree": {"sha": "6c4c7d89f597ae61faff6f3a1a53ed9a6edc939a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c4c7d89f597ae61faff6f3a1a53ed9a6edc939a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "html_url": "https://github.com/rust-lang/rust/commit/a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096f6f56a8178bd7f4b69a2ea909838e782766fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/096f6f56a8178bd7f4b69a2ea909838e782766fb", "html_url": "https://github.com/rust-lang/rust/commit/096f6f56a8178bd7f4b69a2ea909838e782766fb"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "a86a7f38a8cddbbc0f22b1539dde5f034ad9c42b", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "patch": "@@ -75,82 +75,82 @@ mod test {\n     use syntax;\n     use super::{parse_hidden, parse_crate, parse_desc};\n \n-    fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n+    fn parse_attributes(source: @str) -> ~[ast::attribute] {\n         use syntax::parse;\n         use syntax::parse::attr::parser_attr;\n \n         let parse_sess = syntax::parse::new_parse_sess(None);\n         let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], ~\"-\", @source);\n+            parse_sess, ~[], @\"-\", source);\n \n         parser.parse_outer_attributes()\n     }\n \n \n     #[test]\n     fn should_extract_crate_name_from_link_attribute() {\n-        let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n+        let source = @\"#[link(name = \\\"snuggles\\\")]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == Some(~\"snuggles\"));\n     }\n \n     #[test]\n     fn should_not_extract_crate_name_if_no_link_attribute() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == None);\n     }\n \n     #[test]\n     fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n-        let source = ~\"#[link(whatever)]\";\n+        let source = @\"#[link(whatever)]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == None);\n     }\n \n     #[test]\n     fn parse_desc_should_handle_undocumented_mods() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_desc(attrs);\n         assert!(attrs == None);\n     }\n \n     #[test]\n     fn parse_desc_should_parse_simple_doc_attributes() {\n-        let source = ~\"#[doc = \\\"basic\\\"]\";\n+        let source = @\"#[doc = \\\"basic\\\"]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_desc(attrs);\n         assert!(attrs == Some(~\"basic\"));\n     }\n \n     #[test]\n     fn should_parse_hidden_attribute() {\n-        let source = ~\"#[doc(hidden)]\";\n+        let source = @\"#[doc(hidden)]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == true);\n     }\n \n     #[test]\n     fn should_parse_hidden_attribute_with_other_docs() {\n-        let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n+        let source = @\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == true);\n     }\n \n     #[test]\n     fn should_not_parse_non_hidden_attribute() {\n-        let source = ~\"#[doc = \\\"\\\"]\";\n+        let source = @\"#[doc = \\\"\\\"]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == false);\n     }\n \n     #[test]\n     fn should_concatenate_multiple_doc_comments() {\n-        let source = ~\"/// foo\\n/// bar\";\n+        let source = @\"/// foo\\n/// bar\";\n         let desc = parse_desc(parse_attributes(source));\n         assert!(desc == Some(~\"foo\\nbar\"));\n     }"}, {"sha": "f4b6ae8fb32af8cd844246f20ded550e582d1323", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "patch": "@@ -287,49 +287,49 @@ mod test {\n \n     use core::vec;\n \n-    fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: @str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }\n \n     #[test]\n     fn extract_empty_crate() {\n-        let doc = mk_doc(~\"\");\n+        let doc = mk_doc(@\"\");\n         assert!(doc.cratemod().mods().is_empty());\n         assert!(doc.cratemod().fns().is_empty());\n     }\n \n     #[test]\n     fn extract_mods() {\n-        let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n+        let doc = mk_doc(@\"mod a { mod b { } mod c { } }\");\n         assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n         assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n         assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n     fn extract_fns_from_foreign_mods() {\n-        let doc = mk_doc(~\"extern { fn a(); }\");\n+        let doc = mk_doc(@\"extern { fn a(); }\");\n         assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n-        let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n+        let doc = mk_doc(@\"mod a { mod b { mod c { } } }\");\n         assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n             ~\"c\");\n     }\n \n     #[test]\n     fn extract_should_set_mod_ast_id() {\n-        let doc = mk_doc(~\"mod a { }\");\n+        let doc = mk_doc(@\"mod a { }\");\n         assert!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n     fn extract_fns() {\n         let doc = mk_doc(\n-            ~\"fn a() { } \\\n+            @\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n         assert!(doc.cratemod().fns()[0].name() == ~\"a\");\n@@ -338,13 +338,13 @@ mod test {\n \n     #[test]\n     fn extract_should_set_fn_ast_id() {\n-        let doc = mk_doc(~\"fn a() { }\");\n+        let doc = mk_doc(@\"fn a() { }\");\n         assert!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n     fn extract_should_use_default_crate_name() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n         assert!(doc.cratemod().name() == ~\"burp\");\n@@ -361,57 +361,57 @@ mod test {\n \n     #[test]\n     fn should_extract_const_name_and_id() {\n-        let doc = mk_doc(~\"static a: int = 0;\");\n+        let doc = mk_doc(@\"static a: int = 0;\");\n         assert!(doc.cratemod().consts()[0].id() != 0);\n         assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_enums() {\n-        let doc = mk_doc(~\"enum e { v }\");\n+        let doc = mk_doc(@\"enum e { v }\");\n         assert!(doc.cratemod().enums()[0].id() != 0);\n         assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n     }\n \n     #[test]\n     fn should_extract_enum_variants() {\n-        let doc = mk_doc(~\"enum e { v }\");\n+        let doc = mk_doc(@\"enum e { v }\");\n         assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n     }\n \n     #[test]\n     fn should_extract_traits() {\n-        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        let doc = mk_doc(@\"trait i { fn f(); }\");\n         assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n     }\n \n     #[test]\n     fn should_extract_trait_methods() {\n-        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        let doc = mk_doc(@\"trait i { fn f(); }\");\n         assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n     }\n \n     #[test]\n     fn should_extract_impl_methods() {\n-        let doc = mk_doc(~\"impl int { fn f() { } }\");\n+        let doc = mk_doc(@\"impl int { fn f() { } }\");\n         assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n     }\n \n     #[test]\n     fn should_extract_tys() {\n-        let doc = mk_doc(~\"type a = int;\");\n+        let doc = mk_doc(@\"type a = int;\");\n         assert!(doc.cratemod().types()[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_structs() {\n-        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        let doc = mk_doc(@\"struct Foo { field: () }\");\n         assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n     }\n \n     #[test]\n     fn should_extract_struct_fields() {\n-        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        let doc = mk_doc(@\"struct Foo { field: () }\");\n         assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n     }\n }"}, {"sha": "7cf616065d381e047ce0b23a27bc54335b6fb5a1", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ee0dee1ae023c3892361ad2a698e1ebbce12e/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=a30ee0dee1ae023c3892361ad2a698e1ebbce12e", "patch": "@@ -368,7 +368,7 @@ pub fn default_seq_fold_struct<T>(\n \n #[test]\n fn default_fold_should_produce_same_doc() {\n-    let source = ~\"mod a { fn b() { } mod c { fn d() { } } }\";\n+    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -378,7 +378,7 @@ fn default_fold_should_produce_same_doc() {\n \n #[test]\n fn default_fold_should_produce_same_consts() {\n-    let source = ~\"static a: int = 0;\";\n+    let source = @\"static a: int = 0;\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -388,7 +388,7 @@ fn default_fold_should_produce_same_consts() {\n \n #[test]\n fn default_fold_should_produce_same_enums() {\n-    let source = ~\"enum a { b }\";\n+    let source = @\"enum a { b }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -398,7 +398,7 @@ fn default_fold_should_produce_same_enums() {\n \n #[test]\n fn default_parallel_fold_should_produce_same_doc() {\n-    let source = ~\"mod a { fn b() { } mod c { fn d() { } } }\";\n+    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());"}]}