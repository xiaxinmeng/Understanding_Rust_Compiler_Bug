{"sha": "4d6d7aec50e81d2d6da01e4f4fc1353430e79067", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNmQ3YWVjNTBlODFkMmQ2ZGEwMWU0ZjRmYzEzNTM0MzBlNzkwNjc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-17T19:41:07Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-17T19:41:07Z"}, "message": "Avoid all unchecked indexing in match checking", "tree": {"sha": "b5192e25fd56dbfc3c289a5d117b1e0d5c8622ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5192e25fd56dbfc3c289a5d117b1e0d5c8622ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d6d7aec50e81d2d6da01e4f4fc1353430e79067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6d7aec50e81d2d6da01e4f4fc1353430e79067", "html_url": "https://github.com/rust-lang/rust/commit/4d6d7aec50e81d2d6da01e4f4fc1353430e79067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d6d7aec50e81d2d6da01e4f4fc1353430e79067/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ce8c2b5a08949e78de7ff9dfbae594f6c17b951", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce8c2b5a08949e78de7ff9dfbae594f6c17b951", "html_url": "https://github.com/rust-lang/rust/commit/1ce8c2b5a08949e78de7ff9dfbae594f6c17b951"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "5495ce284f8203d59845cb46b35542370e2ca1f3", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4d6d7aec50e81d2d6da01e4f4fc1353430e79067/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6d7aec50e81d2d6da01e4f4fc1353430e79067/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=4d6d7aec50e81d2d6da01e4f4fc1353430e79067", "patch": "@@ -312,20 +312,16 @@ impl PatStack {\n         Self(v)\n     }\n \n-    fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    fn head(&self) -> PatIdOrWild {\n-        self.0[0]\n-    }\n-\n     fn get_head(&self) -> Option<PatIdOrWild> {\n         self.0.first().copied()\n     }\n \n+    fn tail(&self) -> &[PatIdOrWild] {\n+        self.0.get(1..).unwrap_or(&[])\n+    }\n+\n     fn to_tail(&self) -> PatStack {\n-        Self::from_slice(&self.0[1..])\n+        Self::from_slice(self.tail())\n     }\n \n     fn replace_head_with<I, T>(&self, pats: I) -> PatStack\n@@ -347,7 +343,7 @@ impl PatStack {\n     ///\n     /// See the module docs and the associated documentation in rustc for details.\n     fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n-        if matches!(self.head().as_pat(cx), Pat::Wild) {\n+        if matches!(self.get_head()?.as_pat(cx), Pat::Wild) {\n             Some(self.to_tail())\n         } else {\n             None\n@@ -362,11 +358,12 @@ impl PatStack {\n         cx: &MatchCheckCtx,\n         constructor: &Constructor,\n     ) -> MatchCheckResult<Option<PatStack>> {\n-        if self.is_empty() {\n-            return Ok(None);\n-        }\n+        let head = match self.get_head() {\n+            Some(head) => head,\n+            None => return Ok(None),\n+        };\n \n-        let head_pat = self.head().as_pat(cx);\n+        let head_pat = head.as_pat(cx);\n         let result = match (head_pat, constructor) {\n             (Pat::Tuple { args: ref pat_ids, ellipsis }, Constructor::Tuple { arity: _ }) => {\n                 if ellipsis.is_some() {\n@@ -394,7 +391,7 @@ impl PatStack {\n             (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n                 // unit enum variants become `Pat::Path`\n-                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n                     None\n                 } else {\n@@ -405,7 +402,7 @@ impl PatStack {\n                 Pat::TupleStruct { args: ref pat_ids, ellipsis, .. },\n                 Constructor::Enum(enum_constructor),\n             ) => {\n-                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n@@ -445,7 +442,7 @@ impl PatStack {\n                 }\n             }\n             (Pat::Record { args: ref arg_patterns, .. }, Constructor::Enum(e)) => {\n-                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *e) {\n                     None\n                 } else {\n@@ -491,7 +488,7 @@ impl PatStack {\n     ) -> MatchCheckResult<PatStack> {\n         assert_eq!(\n             Pat::Wild,\n-            self.head().as_pat(cx),\n+            self.get_head().expect(\"expand_wildcard called on empty PatStack\").as_pat(cx),\n             \"expand_wildcard must only be called on PatStack with wild at head\",\n         );\n \n@@ -509,7 +506,6 @@ impl PatStack {\n     }\n }\n \n-#[derive(Debug)]\n /// A collection of PatStack.\n ///\n /// This type is modeled from the struct of the same name in `rustc`.\n@@ -623,13 +619,16 @@ pub(crate) fn is_useful(\n         _ => (),\n     }\n \n-    if v.is_empty() {\n-        let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n+    let head = match v.get_head() {\n+        Some(head) => head,\n+        None => {\n+            let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n \n-        return Ok(result);\n-    }\n+            return Ok(result);\n+        }\n+    };\n \n-    if let Pat::Or(pat_ids) = v.head().as_pat(cx) {\n+    if let Pat::Or(pat_ids) = head.as_pat(cx) {\n         let mut found_unimplemented = false;\n         let any_useful = pat_ids.iter().any(|&pat_id| {\n             let v = PatStack::from_pattern(pat_id);\n@@ -653,7 +652,7 @@ pub(crate) fn is_useful(\n         };\n     }\n \n-    if let Some(constructor) = pat_constructor(cx, v.head())? {\n+    if let Some(constructor) = pat_constructor(cx, head)? {\n         let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n         let v = v\n             .specialize_constructor(&cx, &constructor)?\n@@ -854,10 +853,10 @@ mod tests {\n     }\n \n     pub(super) fn check_no_diagnostic(ra_fixture: &str) {\n-        let diagnostic_count =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n+        let (s, diagnostic_count) =\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>();\n \n-        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n+        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n     }\n \n     #[test]\n@@ -2014,6 +2013,28 @@ mod tests {\n         \",\n         );\n     }\n+\n+    #[test]\n+    fn or_pattern_panic_2() {\n+        // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n+        // so this acts as a regression test for that.\n+        check_diagnostic(\n+            r\"\n+            pub enum Category {\n+                Infinity,\n+                Zero,\n+            }\n+\n+            fn panic(a: Category, b: Category) {\n+                match (a, b) {\n+                    (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => {}\n+\n+                    (Category::Infinity | Category::Zero, _) => {}\n+                }\n+            }\n+        \",\n+        );\n+    }\n }\n \n #[cfg(test)]"}]}