{"sha": "43dfd894934cf7c9161e473495a4e24965239475", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZGZkODk0OTM0Y2Y3YzkxNjFlNDczNDk1YTRlMjQ5NjUyMzk0NzU=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-05T17:16:34Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T12:12:08Z"}, "message": "handle non matching enum pattern types", "tree": {"sha": "323ddd9e91ea46713b1b5c30d40cd6474310c6e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/323ddd9e91ea46713b1b5c30d40cd6474310c6e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43dfd894934cf7c9161e473495a4e24965239475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43dfd894934cf7c9161e473495a4e24965239475", "html_url": "https://github.com/rust-lang/rust/commit/43dfd894934cf7c9161e473495a4e24965239475", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43dfd894934cf7c9161e473495a4e24965239475/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df", "html_url": "https://github.com/rust-lang/rust/commit/b87b7a088f34ff794fc19e57ee2ae1cfe81a12df"}], "stats": {"total": 98, "additions": 57, "deletions": 41}, "files": [{"sha": "91206adc3e6fe1375d06938fa2107c8c582b9069", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd894934cf7c9161e473495a4e24965239475/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd894934cf7c9161e473495a4e24965239475/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=43dfd894934cf7c9161e473495a4e24965239475", "patch": "@@ -250,17 +250,13 @@ pub enum Usefulness {\n \n pub struct MatchCheckCtx<'a> {\n     pub body: Arc<Body>,\n-    pub match_expr: &'a Expr,\n     pub infer: Arc<InferenceResult>,\n     pub db: &'a dyn HirDatabase,\n }\n \n-// see src/librustc_mir_build/hair/pattern/_match.rs\n-// It seems the rustc version of this method is able to assume that all the match arm\n-// patterns are valid (they are valid given a particular match expression), but I\n-// don't think we can make that assumption here. How should that be handled?\n-//\n-// Perhaps check that validity before passing the patterns into this method?\n+/// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n+/// whether `v` is useful. A pattern is useful if it covers cases which were\n+/// not previously covered.\n pub(crate) fn is_useful(\n     cx: &MatchCheckCtx,\n     matrix: &Matrix,\n@@ -517,6 +513,19 @@ mod tests {\n         check_diagnostic_with_no_fix(content);\n     }\n \n+    #[test]\n+    fn empty_tuple_wild() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                    _ => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn empty_tuple_no_diagnostic() {\n         let content = r\"\n@@ -976,21 +985,6 @@ mod tests {\n \n         check_no_diagnostic(content);\n     }\n-}\n-\n-#[cfg(test)]\n-mod false_negatives {\n-    //! The implementation of match checking here is a work in progress. As we roll this out, we\n-    //! prefer false negatives to false positives (ideally there would be no false positives). This\n-    //! test module should document known false negatives. Eventually we will have a complete\n-    //! implementation of match checking and this module will be empty.\n-    //!\n-    //! The reasons for documenting known false negatives:\n-    //!\n-    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-    //!   2. It ensures the code doesn't panic when handling these cases.\n-\n-    use super::tests::*;\n \n     #[test]\n     fn mismatched_types() {\n@@ -1011,10 +1005,8 @@ mod false_negatives {\n             }\n         \";\n \n-        // This is a false negative.\n-        // We don't currently check that the match arms actually\n-        // match the type of the match expression.\n-        check_no_diagnostic(content);\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic_with_no_fix(content);\n     }\n \n     #[test]\n@@ -1028,14 +1020,24 @@ mod false_negatives {\n             }\n         \";\n \n-        // This is a false negative.\n-        // We don't currently check that the match arms actually\n-        // match the type of the match expression. This test\n-        // checks to ensure we don't panic when the code we are\n-        // checking is malformed in such a way that the arity of the\n-        // constructors doesn't match.\n-        check_no_diagnostic(content);\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic_with_no_fix(content);\n     }\n+}\n+\n+#[cfg(test)]\n+mod false_negatives {\n+    //! The implementation of match checking here is a work in progress. As we roll this out, we\n+    //! prefer false negatives to false positives (ideally there would be no false positives). This\n+    //! test module should document known false negatives. Eventually we will have a complete\n+    //! implementation of match checking and this module will be empty.\n+    //!\n+    //! The reasons for documenting known false negatives:\n+    //!\n+    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+    //!   2. It ensures the code doesn't panic when handling these cases.\n+\n+    use super::tests::*;\n \n     #[test]\n     fn integers() {"}, {"sha": "8c7d1a98e550ad683ea839661f458cfd0d99d3c8", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd894934cf7c9161e473495a4e24965239475/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd894934cf7c9161e473495a4e24965239475/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=43dfd894934cf7c9161e473495a4e24965239475", "patch": "@@ -67,26 +67,40 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n-        expr: ExprId,\n+        match_expr: ExprId,\n         arms: &[MatchArm],\n         db: &dyn HirDatabase,\n         infer: Arc<InferenceResult>,\n     ) {\n         let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n             db.body_with_source_map(self.func.into());\n \n-        let match_expr: &hir_def::expr::Expr = &body[expr];\n+        let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n+            Some(ty) => ty,\n+            // If we can't resolve the type of the match expression\n+            // we cannot perform exhaustiveness checks.\n+            None => return,\n+        };\n \n-        let cx = MatchCheckCtx { body: body.clone(), match_expr, infer, db };\n+        let cx = MatchCheckCtx { body, infer: infer.clone(), db };\n         let pats = arms.iter().map(|arm| arm.pat);\n \n         let mut seen = Matrix::empty();\n         for pat in pats {\n-            // If we had a NotUsefulMatchArm diagnostic, we could\n-            // check the usefulness of each pattern as we added it\n-            // to the matrix here.\n-            let v = PatStack::from_pattern(pat);\n-            seen.push(&cx, v);\n+            // We skip any patterns whose type we cannot resolve.\n+            if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n+                // We only include patterns whose type matches the type\n+                // of the match expression. If we had a InvalidMatchArmPattern\n+                // diagnostic or similar we could raise that in an else\n+                // block here.\n+                if pat_ty == match_expr_ty {\n+                    // If we had a NotUsefulMatchArm diagnostic, we could\n+                    // check the usefulness of each pattern as we added it\n+                    // to the matrix here.\n+                    let v = PatStack::from_pattern(pat);\n+                    seen.push(&cx, v);\n+                }\n+            }\n         }\n \n         match is_useful(&cx, &seen, &PatStack::from_wild()) {"}]}