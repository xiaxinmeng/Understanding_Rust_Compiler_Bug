{"sha": "2c1250780d9f533762f647b52b83e25fa394778e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTI1MDc4MGQ5ZjUzMzc2MmY2NDdiNTJiODNlMjVmYTM5NDc3OGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-26T13:17:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-26T13:19:56Z"}, "message": "Remove tuple support from the compiler", "tree": {"sha": "5aab771b9474fd2a09386eb7a75ae838ed741e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aab771b9474fd2a09386eb7a75ae838ed741e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1250780d9f533762f647b52b83e25fa394778e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1250780d9f533762f647b52b83e25fa394778e", "html_url": "https://github.com/rust-lang/rust/commit/2c1250780d9f533762f647b52b83e25fa394778e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1250780d9f533762f647b52b83e25fa394778e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9db454a07f8be8b4de81495acc6f60d4bb8ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9db454a07f8be8b4de81495acc6f60d4bb8ba7", "html_url": "https://github.com/rust-lang/rust/commit/bc9db454a07f8be8b4de81495acc6f60d4bb8ba7"}], "stats": {"total": 368, "additions": 24, "deletions": 344}, "files": [{"sha": "98c4b0438c8378f8d2042e4dab7a950de8cc9610", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -226,13 +226,6 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('a') { ret ty::mk_task(st.tcx); }\n         case ('P') { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n         case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n-        case ('T') {\n-            assert (next(st) as char == '[');\n-            let ty::mt[] params = ~[];\n-            while (peek(st) as char != ']') { params += ~[parse_mt(st, sd)]; }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_tup(st.tcx, params);\n-        }\n         case ('R') {\n             assert (next(st) as char == '[');\n             let ty::field[] fields = ~[];"}, {"sha": "e89480182ef50a95abd1444da950dc4384a755a5", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -128,11 +128,6 @@ fn enc_sty(&ioivec::writer w, &@ctxt cx, &ty::sty st) {\n         case (ty::ty_ivec(?mt)) { w.write_char('I'); enc_mt(w, cx, mt); }\n         case (ty::ty_port(?t)) { w.write_char('P'); enc_ty(w, cx, t); }\n         case (ty::ty_chan(?t)) { w.write_char('C'); enc_ty(w, cx, t); }\n-        case (ty::ty_tup(?mts)) {\n-            w.write_str(\"T[\");\n-            for (ty::mt mt in mts) { enc_mt(w, cx, mt); }\n-            w.write_char(']');\n-        }\n         case (ty::ty_rec(?fields)) {\n             w.write_str(\"R[\");\n             for (ty::field field in fields) {"}, {"sha": "f66cfb9a1e6941c704816bc067591506193ee5d9", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -558,10 +558,6 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                     maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n                 auto mut = false;\n                 alt (ty::struct(cx.tcx, auto_unbox.t)) {\n-                    case (ty::ty_tup(?fields)) {\n-                        auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n-                        mut = fields.(fnm).mut != ast::imm;\n-                    }\n                     case (ty::ty_rec(?fields)) {\n                         for (ty::field fld in fields) {\n                             if (str::eq(ident, fld.ident)) {\n@@ -654,14 +650,6 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n             ty::ty_box(?mt) | ty::ty_vec(?mt) | ty::ty_ptr(?mt) {\n                 ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n             }\n-            ty::ty_tup(?mts) {\n-                for (ty::mt mt in mts) {\n-                    if (helper(tcx, needle, mt.ty, get_mut(mut, mt))) {\n-                        ret true;\n-                    }\n-                }\n-                ret false;\n-            }\n             ty::ty_rec(?fields) {\n                 for (ty::field f in fields) {\n                     if (helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt))) {"}, {"sha": "3a0e8e3b4c0f5a328d7becca94f5a62fbd1e59eb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -239,13 +239,6 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = T_ptr(T_chan(type_of_inner(cx, sp, t)));\n         }\n         case (ty::ty_task) { llty = T_taskptr(*cx); }\n-        case (ty::ty_tup(?elts)) {\n-            let TypeRef[] tys = ~[];\n-            for (ty::mt elt in elts) {\n-                tys += ~[type_of_inner(cx, sp, elt.ty)];\n-            }\n-            llty = T_struct(tys);\n-        }\n         case (ty::ty_rec(?fields)) {\n             let TypeRef[] tys = ~[];\n             for (ty::field f in fields) {\n@@ -610,11 +603,6 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n             ret rslt(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n-        case (ty::ty_tup(?elts)) {\n-            let ty::t[] tys = ~[];\n-            for (ty::mt mt in elts) { tys += ~[mt.ty]; }\n-            ret align_elements(cx, tys);\n-        }\n         case (ty::ty_rec(?flds)) {\n             let ty::t[] tys = ~[];\n             for (ty::field f in flds) { tys += ~[f.mt.ty]; }\n@@ -667,16 +655,6 @@ fn dynamic_align_of(&@block_ctxt cx, &ty::t t) -> result {\n                 field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n             ret rslt(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n         }\n-        case (ty::ty_tup(?elts)) {\n-            auto a = C_int(1);\n-            auto bcx = cx;\n-            for (ty::mt e in elts) {\n-                auto align = align_of(bcx, e.ty);\n-                bcx = align.bcx;\n-                a = umax(bcx, a, align.val);\n-            }\n-            ret rslt(bcx, a);\n-        }\n         case (ty::ty_rec(?flds)) {\n             auto a = C_int(1);\n             auto bcx = cx;\n@@ -2003,18 +1981,6 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n \n     let result r = rslt(cx, C_nil());\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_tup(?args)) {\n-            let int i = 0;\n-            for (ty::mt arg in args) {\n-                r = GEP_tup_like(r.bcx, t, av, ~[0, i]);\n-                auto elt_a = r.val;\n-                r = GEP_tup_like(r.bcx, t, bv, ~[0, i]);\n-                auto elt_b = r.val;\n-                r = f(r.bcx, load_if_immediate(r.bcx, elt_a, arg.ty),\n-                      load_if_immediate(r.bcx, elt_b, arg.ty), arg.ty);\n-                i += 1;\n-            }\n-        }\n         case (ty::ty_rec(?fields)) {\n             let int i = 0;\n             for (ty::field fld in fields) {\n@@ -4196,11 +4162,6 @@ fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n     auto r = autoderef(cx, v, t0);\n     auto t = r.ty;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_tup(_)) {\n-            let uint ix = ty::field_num(cx.fcx.lcx.ccx.sess, sp, field);\n-            auto v = GEP_tup_like(r.bcx, t, r.val, ~[0, ix as int]);\n-            ret lval_mem(v.bcx, v.val);\n-        }\n         case (ty::ty_rec(?fields)) {\n             let uint ix =\n                 ty::field_idx(cx.fcx.lcx.ccx.sess, sp, field, fields);\n@@ -5082,25 +5043,6 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     ret rslt(bcx, retval);\n }\n \n-fn trans_tup(&@block_ctxt cx, &ast::elt[] elts, ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto t = node_id_type(bcx.fcx.lcx.ccx, id);\n-    auto tup_res = alloc_ty(bcx, t);\n-    auto tup_val = tup_res.val;\n-    bcx = tup_res.bcx;\n-    add_clean_temp(cx, tup_val, t);\n-    let int i = 0;\n-    for (ast::elt e in elts) {\n-        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n-        auto src = trans_lval(bcx, e.expr);\n-        bcx = src.res.bcx;\n-        auto dst_res = GEP_tup_like(bcx, t, tup_val, ~[0, i]);\n-        bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty).bcx;\n-        i += 1;\n-    }\n-    ret rslt(bcx, tup_val);\n-}\n-\n fn trans_vec(&@block_ctxt cx, &(@ast::expr)[] args, ast::node_id id) ->\n    result {\n     auto t = node_id_type(cx.fcx.lcx.ccx, id);\n@@ -5457,7 +5399,6 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_vec(?args, _, ast::sk_unique)) {\n             ret trans_ivec(cx, args, e.id);\n         }\n-        case (ast::expr_tup(?args)) { ret trans_tup(cx, args, e.id); }\n         case (ast::expr_rec(?args, ?base)) {\n             ret trans_rec(cx, args, base, e.id);\n         }"}, {"sha": "a52a2c62ddd0e2d58af8e02776816ef8fea3171d", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -175,9 +175,9 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     // unpack the arguments\n \n     alt (ty::struct(fcx.lcx.ccx.tcx, args_ty)) {\n-        case (ty::ty_tup(?elements)) {\n+        case (ty::ty_rec(?fields)) {\n             auto i = 0;\n-            for (ty::mt m in elements) {\n+            for (ty::field f in fields) {\n                 auto src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n                 i += 1;\n                 auto child_arg = fbcx.build.Load(src);"}, {"sha": "eb3635a3b84b9677e0a06734198e715bfa038965", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -334,9 +334,6 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_vec(?args, _, _)) {\n             find_pre_post_exprs(fcx, args, e.id);\n         }\n-        case (expr_tup(?elts)) {\n-            find_pre_post_exprs(fcx, elt_exprs(elts), e.id);\n-        }\n         case (expr_path(?p)) {\n             auto rslt = expr_pp(fcx.ccx, e);\n             clear_pp(rslt);"}, {"sha": "cf8d60489c9e4d54fbaef8a69b2fd0b88b799050", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -293,10 +293,6 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_vec(?elts, _, _)) {\n             ret find_pre_post_state_exprs(fcx, pres, e.id, elts, return);\n         }\n-        case (expr_tup(?elts)) {\n-            ret find_pre_post_state_exprs(fcx, pres, e.id,\n-                                          elt_exprs(elts), return);\n-        }\n         case (expr_call(?operator, ?operands)) {\n             ret find_pre_post_state_call\n                 (fcx, pres, operator, e.id, operands,"}, {"sha": "f0594bd36b3026aea4d91b3ba88d1dcca74ba0ed", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 165, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -47,7 +47,6 @@ export expr_ty;\n export fold_ty;\n export field;\n export field_idx;\n-export field_num;\n export fm_general;\n export get_element_type;\n export hash_ty;\n@@ -69,7 +68,6 @@ export mk_ctxt;\n export mk_float;\n export mk_fn;\n export mk_imm_box;\n-export mk_imm_tup;\n export mk_imm_vec;\n export mk_int;\n export mk_istr;\n@@ -84,10 +82,10 @@ export mk_param;\n export mk_port;\n export mk_ptr;\n export mk_rec;\n+export mk_imm_tup;\n export mk_str;\n export mk_tag;\n export mk_task;\n-export mk_tup;\n export mk_type;\n export mk_uint;\n export mk_var;\n@@ -144,7 +142,6 @@ export ty_rec;\n export ty_str;\n export ty_tag;\n export ty_task;\n-export ty_tup;\n export ty_type;\n export ty_uint;\n export ty_var;\n@@ -265,7 +262,6 @@ tag sty {\n     ty_port(t);\n     ty_chan(t);\n     ty_task;\n-    ty_tup(mt[]);\n     ty_rec(field[]);\n     ty_fn(ast::proto, arg[], t, controlflow, (@constr)[]);\n     ty_native_fn(ast::native_abi, arg[], t);\n@@ -291,8 +287,6 @@ tag type_err {\n     terr_controlflow_mismatch;\n     terr_box_mutability;\n     terr_vec_mutability;\n-    terr_tuple_size(uint, uint);\n-    terr_tuple_mutability;\n     terr_record_size(uint, uint);\n     terr_record_mutability;\n     terr_record_fields(ast::ident, ast::ident);\n@@ -473,11 +467,6 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] in_cname) -> @raw_t {\n         case (ty_ptr(?m)) { derive_flags_mt(cx, has_params, has_vars, m); }\n         case (ty_port(?tt)) { derive_flags_t(cx, has_params, has_vars, tt); }\n         case (ty_chan(?tt)) { derive_flags_t(cx, has_params, has_vars, tt); }\n-        case (ty_tup(?mts)) {\n-            for (mt m in mts) {\n-                derive_flags_mt(cx, has_params, has_vars, m);\n-            }\n-        }\n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n                 derive_flags_mt(cx, has_params, has_vars, f.mt);\n@@ -585,18 +574,19 @@ fn mk_chan(&ctxt cx, &t ty) -> t { ret gen_ty(cx, ty_chan(ty)); }\n \n fn mk_task(&ctxt cx) -> t { ret gen_ty(cx, ty_task); }\n \n-fn mk_tup(&ctxt cx, &mt[] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n+fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n-    // TODO: map\n-\n-    let ty::mt[] mts = ~[];\n-    for (t typ in tys) { mts += ~[rec(ty=typ, mut=ast::imm)]; }\n-    ret mk_tup(cx, mts);\n+    auto fields = ~[];\n+    auto i = 0u;\n+    for (t typ in tys) {\n+        fields += ~[rec(ident=#fmt(\"_%u\", i),\n+                        mt=rec(ty=typ, mut=ast::imm))];\n+        i += 1u;\n+    }\n+    ret gen_ty(cx, ty_rec(fields));\n }\n \n-fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n-\n fn mk_constr(&ctxt cx, &t t, &(@type_constr)[] cs) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n@@ -665,9 +655,6 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n         case (ty_tag(?tid, ?subtys)) {\n             for (t subty in subtys) { walk_ty(cx, walker, subty); }\n         }\n-        case (ty_tup(?mts)) {\n-            for (mt tm in mts) { walk_ty(cx, walker, tm.ty); }\n-        }\n         case (ty_rec(?fields)) {\n             for (field fl in fields) { walk_ty(cx, walker, fl.mt.ty); }\n         }\n@@ -765,14 +752,6 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             }\n             ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n-        case (ty_tup(?mts)) {\n-            let mt[] new_mts = ~[];\n-            for (mt tm in mts) {\n-                auto new_subty = fold_ty(cx, fld, tm.ty);\n-                new_mts += ~[rec(ty=new_subty, mut=tm.mut)];\n-            }\n-            ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n-        }\n         case (ty_rec(?fields)) {\n             let field[] new_fields = ~[];\n             for (field fl in fields) {\n@@ -896,7 +875,6 @@ fn type_is_chan(&ctxt cx, &t ty) -> bool {\n \n fn type_is_structural(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n-        case (ty_tup(_)) { ret true; }\n         case (ty_rec(_)) { ret true; }\n         case (ty_tag(_, _)) { ret true; }\n         case (ty_fn(_, _, _, _, _)) { ret true; }\n@@ -964,7 +942,6 @@ fn sequence_element_type(&ctxt cx, &t ty) -> t {\n fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_box(_)) { ret true; }\n-        case (ty_tup(_)) { ret true; }\n         case (ty_rec(_)) { ret true; }\n         case (ty_tag(_, _)) { ret true; }\n         case (_) { ret false; }\n@@ -973,7 +950,6 @@ fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n \n fn get_element_type(&ctxt cx, &t ty, uint i) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_tup(?mts)) { ret mts.(i).ty; }\n         case (ty_rec(?flds)) { ret flds.(i).mt.ty; }\n         case (_)             {\n             cx.sess.bug(\"get_element_type called on type \"\n@@ -1039,11 +1015,6 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n         case (ty_char) { /* no-op */ }\n         case (ty_type) { /* no-op */ }\n         case (ty_native(_)) { /* no-op */ }\n-        case (ty_tup(?elts)) {\n-            for (mt m in elts) {\n-                if (type_has_pointers(cx, m.ty)) { result = true; }\n-            }\n-        }\n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n                 if (type_has_pointers(cx, f.mt.ty)) { result = true; }\n@@ -1052,11 +1023,11 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n         case (ty_tag(?did, ?tps)) {\n             auto variants = tag_variants(cx, did);\n             for (variant_info variant in variants) {\n-                auto tup_ty = mk_imm_tup(cx, variant.args);\n-\n-                // Perform any type parameter substitutions.\n-                tup_ty = substitute_type_params(cx, tps, tup_ty);\n-                if (type_has_pointers(cx, tup_ty)) { result = true; }\n+                for (t aty in variant.args) {\n+                    // Perform any type parameter substitutions.\n+                    auto arg_ty = substitute_type_params(cx, tps, aty);\n+                    if (type_has_pointers(cx, arg_ty)) { result = true; }\n+                }\n             }\n         }\n         case (ty_res(?did, ?inner, ?tps)) {\n@@ -1107,14 +1078,6 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         case (ty_port(_)) { ret false; }\n         case (ty_chan(_)) { ret false; }\n         case (ty_task) { ret false; }\n-        case (ty_tup(?mts)) {\n-            auto i = 0u;\n-            while (i < ivec::len[mt](mts)) {\n-                if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n-                i += 1u;\n-            }\n-            ret false;\n-        }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n             while (i < ivec::len[field](fields)) {\n@@ -1227,16 +1190,11 @@ fn type_owns_heap_mem(&ctxt cx, &t ty) -> bool {\n         case (ty_tag(?did, ?tps)) {\n             auto variants = tag_variants(cx, did);\n             for (variant_info variant in variants) {\n-                auto tup_ty = mk_imm_tup(cx, variant.args);\n-\n-                // Perform any type parameter substitutions.\n-                tup_ty = substitute_type_params(cx, tps, tup_ty);\n-                if (type_owns_heap_mem(cx, tup_ty)) { result = true; }\n-            }\n-        }\n-        case (ty_tup(?elts)) {\n-            for (mt m in elts) {\n-                if (type_owns_heap_mem(cx, m.ty)) { result = true; }\n+                for (t aty in variant.args) {\n+                    // Perform any type parameter substitutions.\n+                    auto arg_ty = substitute_type_params(cx, tps, aty);\n+                    if (type_owns_heap_mem(cx, arg_ty)) { result = true; }\n+                }\n             }\n         }\n         case (ty_rec(?flds)) {\n@@ -1377,11 +1335,6 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_port(?typ)) { ret hash_subty(22u, typ); }\n         case (ty_chan(?typ)) { ret hash_subty(23u, typ); }\n         case (ty_task) { ret 24u; }\n-        case (ty_tup(?mts)) {\n-            auto h = 25u;\n-            for (mt tm in mts) { h += h << 5u + hash_ty(tm.ty); }\n-            ret h;\n-        }\n         case (ty_rec(?fields)) {\n             auto h = 26u;\n             for (field f in fields) { h += h << 5u + hash_ty(f.mt.ty); }\n@@ -1599,21 +1552,6 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_task) {\n             alt (b) { case (ty_task) { ret true; } case (_) { ret false; } }\n         }\n-        case (ty_tup(?mts_a)) {\n-            alt (b) {\n-                case (ty_tup(?mts_b)) {\n-                    auto len = ivec::len[mt](mts_a);\n-                    if (len != ivec::len[mt](mts_b)) { ret false; }\n-                    auto i = 0u;\n-                    while (i < len) {\n-                        if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n-                        i += 1u;\n-                    }\n-                    ret true;\n-                }\n-                case (_) { ret false; }\n-            }\n-        }\n         case (ty_rec(?flds_a)) {\n             alt (b) {\n                 case (ty_rec(?flds_b)) {\n@@ -1921,34 +1859,6 @@ fn stmt_node_id(&@ast::stmt s) -> ast::node_id {\n     }\n }\n \n-// Expression utilities\n-fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n-    let uint accum = 0u;\n-    let uint i = 0u;\n-    for (u8 c in id) {\n-        if (i == 0u) {\n-            if (c != '_' as u8) {\n-                sess.span_fatal(sp,\n-                              \"bad numeric field on tuple: \" +\n-                                  \"missing leading underscore\");\n-            }\n-        } else {\n-            if ('0' as u8 <= c && c <= '9' as u8) {\n-                accum *= 10u;\n-                accum += (c as uint) - ('0' as uint);\n-            } else {\n-                auto s = \"\";\n-                s += str::unsafe_from_byte(c);\n-                sess.span_fatal(sp,\n-                              \"bad numeric field on tuple: \" +\n-                                  \" non-digit character: \" + s);\n-            }\n-        }\n-        i += 1u;\n-    }\n-    ret accum;\n-}\n-\n fn field_idx(&session::session sess, &span sp, &ast::ident id,\n              &field[] fields) -> uint {\n     let uint i = 0u;\n@@ -2428,9 +2338,7 @@ mod unify {\n                             expected_id.node != actual_id.node) {\n                             ret ures_err(terr_mismatch);\n                         }\n-                        // TODO: factor this cruft out, see the TODO in the\n-                        // ty::ty_tup case\n-\n+                        // TODO: factor this cruft out\n                         let t[] result_tps = ~[];\n                         auto i = 0u;\n                         auto expected_len = ivec::len[t](expected_tps);\n@@ -2597,49 +2505,6 @@ mod unify {\n                     case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n-            case (ty::ty_tup(?expected_elems)) {\n-                alt (struct(cx.tcx, actual)) {\n-                    case (ty::ty_tup(?actual_elems)) {\n-                        auto expected_len = ivec::len[ty::mt](expected_elems);\n-                        auto actual_len = ivec::len[ty::mt](actual_elems);\n-                        if (expected_len != actual_len) {\n-                            auto err =\n-                                terr_tuple_size(expected_len, actual_len);\n-                            ret ures_err(err);\n-                        }\n-                        // TODO: implement an iterator that can iterate over\n-                        // two arrays simultaneously.\n-\n-                        let ty::mt[] result_elems = ~[];\n-                        auto i = 0u;\n-                        while (i < expected_len) {\n-                            auto expected_elem = expected_elems.(i);\n-                            auto actual_elem = actual_elems.(i);\n-                            auto mut;\n-                            alt (unify_mut(expected_elem.mut,\n-                                           actual_elem.mut)) {\n-                                case (none) {\n-                                    ret ures_err(terr_tuple_mutability);\n-                                }\n-                                case (some(?m)) { mut = m; }\n-                            }\n-                            auto result =\n-                                unify_step(cx, expected_elem.ty,\n-                                           actual_elem.ty);\n-                            alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    auto mt = rec(ty=rty, mut=mut);\n-                                    result_elems += ~[mt];\n-                                }\n-                                case (_) { ret result; }\n-                            }\n-                            i += 1u;\n-                        }\n-                        ret ures_ok(mk_tup(cx.tcx, result_elems));\n-                    }\n-                    case (_) { ret ures_err(terr_mismatch); }\n-                }\n-            }\n             case (ty::ty_rec(?expected_fields)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_rec(?actual_fields)) {\n@@ -2837,14 +2702,6 @@ fn type_err_to_str(&ty::type_err err) -> str {\n             ret \"boxed values differ in mutability\";\n         }\n         case (terr_vec_mutability) { ret \"vectors differ in mutability\"; }\n-        case (terr_tuple_size(?e_sz, ?a_sz)) {\n-            ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n-                    \" elements but found one with \" + uint::to_str(a_sz, 10u)\n-                    + \" elements\";\n-        }\n-        case (terr_tuple_mutability) {\n-            ret \"tuple elements differ in mutability\";\n-        }\n         case (terr_record_size(?e_sz, ?a_sz)) {\n             ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n                     \" fields but found one with \" + uint::to_str(a_sz, 10u) +\n@@ -3093,7 +2950,6 @@ fn is_binopable(&ctxt cx, t ty, ast::binop op) -> bool {\n             case (ty_istr) { tycat_str }\n             case (ty_vec(_)) { tycat_vec }\n             case (ty_ivec(_)) { tycat_vec }\n-            case (ty_tup(_)) { tycat_struct }\n             case (ty_rec(_)) { tycat_struct }\n             case (ty_tag(_, _)) { tycat_struct }\n             case (_) { tycat_other }"}, {"sha": "0944f9a805b3b7ce03d7afa6c9f49a8ca488f05d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -329,10 +329,6 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         case (ast::ty_chan(?t)) {\n             typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n         }\n-        case (ast::ty_tup(?fields)) {\n-            auto flds = ivec::map(bind ast_mt_to_mt(tcx, getter, _), fields);\n-            typ = ty::mk_tup(tcx, flds);\n-        }\n         case (ast::ty_rec(?fields)) {\n             let field[] flds = ~[];\n             for (ast::ty_field f in fields) {\n@@ -2208,17 +2204,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_tup(?elts)) {\n-            let ty::mt[] elts_mt = ~[];\n-            ivec::reserve(elts_mt, ivec::len(elts));\n-            for (ast::elt e in elts) {\n-                check_expr(fcx, e.expr);\n-                auto ety = expr_ty(fcx.ccx.tcx, e.expr);\n-                elts_mt += ~[rec(ty=ety, mut=e.mut)];\n-            }\n-            auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n-            write::ty_only_fixup(fcx, id, typ);\n-        }\n         case (ast::expr_rec(?fields, ?base)) {\n             alt (base) {\n                 case (none) {/* no-op */ }\n@@ -2278,15 +2263,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n             base_t = do_autoderef(fcx, expr.span, base_t);\n             alt (structure_of(fcx, expr.span, base_t)) {\n-                case (ty::ty_tup(?args)) {\n-                    let uint ix =\n-                        ty::field_num(fcx.ccx.tcx.sess, expr.span, field);\n-                    if (ix >= ivec::len[ty::mt](args)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                                  \"bad index on tuple\");\n-                    }\n-                    write::ty_only_fixup(fcx, id, args.(ix).ty);\n-                }\n                 case (ty::ty_rec(?fields)) {\n                     let uint ix =\n                         ty::field_idx(fcx.ccx.tcx.sess, expr.span, field,"}, {"sha": "db5559052e9465609122818a9dcf9454a2776909", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -283,7 +283,6 @@ type expr = rec(node_id id,\n \n tag expr_ {\n     expr_vec((@expr)[], mutability, seq_kind);\n-    expr_tup(elt[]);\n     expr_rec(field[], option::t[@expr]);\n     expr_call(@expr, (@expr)[]);\n     expr_self_method(ident);\n@@ -446,7 +445,6 @@ tag ty_ {\n     ty_task;\n     ty_port(@ty);\n     ty_chan(@ty);\n-    ty_tup(mt[]);\n     ty_rec(ty_field[]);\n     ty_fn(proto, ty_arg[], @ty, controlflow, (@constr)[]);\n     ty_obj(ty_method[]);"}, {"sha": "d6fbae88628f3214ffa3c4576735e95892135bbd", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -40,7 +40,7 @@ fn expand_expr(&hashmap[str, base::syntax_extension] exts,\n                                 = ext(ext_cx, pth.span, args, body);\n                             exts.insert(named_extension.ident,\n                                         named_extension.ext);\n-                            ast::expr_tup(~[])\n+                            ast::expr_rec(~[], none)\n                         }\n                     }\n                 }"}, {"sha": "d3290c75318c8eed8dcf72d943825856170eff0b", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -308,10 +308,6 @@ fn noop_fold_decl(&decl_ d, ast_fold fld) -> decl_ {\n }\n \n fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n-    fn fold_elt_(&elt elt, ast_fold fld) -> elt {\n-        ret rec(mut=elt.mut, expr=fld.fold_expr(elt.expr));\n-    }\n-    auto fold_elt = bind fold_elt_(_,fld);\n     fn fold_field_(&field field, ast_fold fld) -> field {\n         ret rec(node=rec(mut=field.node.mut,\n                          ident=fld.fold_ident(field.node.ident),\n@@ -345,9 +341,6 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         case (expr_vec(?exprs, ?mut, ?seq_kind)) {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut, seq_kind)\n                 }\n-        case (expr_tup(?elts)) {\n-            expr_tup(ivec::map(fold_elt, elts))\n-                }\n         case (expr_rec(?fields, ?maybe_expr)) {\n             expr_rec(ivec::map(fold_field, fields),\n                      option::map(fld.fold_expr, maybe_expr))"}, {"sha": "eab542e6c545c5da7b53b08dcb3642018d0a9212", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -564,12 +564,6 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_vec(parse_mt(p));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n-    } else if (eat_word(p, \"tup\")) {\n-        auto elems =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                           parse_mt, p);\n-        hi = elems.span.hi;\n-        t = ast::ty_tup(elems.node);\n     } else if (eat_word(p, \"rec\")) {\n         auto elems =\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n@@ -837,16 +831,6 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ret parse_spawn_expr(p);\n     } else if (eat_word(p, \"fn\")) {\n         ret parse_fn_expr(p);\n-    } else if (eat_word(p, \"tup\")) {\n-        fn parse_elt(&parser p) -> ast::elt {\n-            auto m = parse_mutability(p);\n-            auto e = parse_expr(p);\n-            ret rec(mut=m, expr=e);\n-        }\n-        auto es = parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                            parse_elt, p);\n-        hi = es.span.hi;\n-        ex = ast::expr_tup(es.node);\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n@@ -1737,7 +1721,6 @@ fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n         case (ast::stmt_expr(?e, _)) {\n             ret alt (e.node) {\n                 case (ast::expr_vec(_, _, _)) { true }\n-                case (ast::expr_tup(_)) { true }\n                 case (ast::expr_rec(_, _)) { true }\n                 case (ast::expr_call(_, _)) { true }\n                 case (ast::expr_self_method(_)) { false }"}, {"sha": "2ca445653aa794c9978d06027ef51ed56e9c7b94", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -294,12 +294,6 @@ fn print_type(&ps s, &ast::ty ty) {\n             print_type(s, *t);\n             word(s.s, \"]\");\n         }\n-        case (ast::ty_tup(?elts)) {\n-            word(s.s, \"tup\");\n-            popen(s);\n-            commasep(s, inconsistent, elts, print_mt);\n-            pclose(s);\n-        }\n         case (ast::ty_rec(?fields)) {\n             word(s.s, \"{\");\n             fn print_field(&ps s, &ast::ty_field f) {\n@@ -689,19 +683,6 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             word(s.s, \"]\");\n             end(s);\n         }\n-        case (ast::expr_tup(?exprs)) {\n-            fn printElt(&ps s, &ast::elt elt) {\n-                ibox(s, indent_unit);\n-                if (elt.mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n-                print_expr(s, elt.expr);\n-                end(s);\n-            }\n-            fn get_span(&ast::elt elt) -> codemap::span { ret elt.expr.span; }\n-            word(s.s, \"tup\");\n-            popen(s);\n-            commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n-            pclose(s);\n-        }\n         case (ast::expr_rec(?fields, ?wth)) {\n             fn print_field(&ps s, &ast::field field) {\n                 ibox(s, indent_unit);"}, {"sha": "1820631011d873c48319f3bf5c35a06ed7f5b0a6", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -154,9 +154,6 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n         case (ty_port(?t))      { v.visit_ty(t, e, v); }\n         case (ty_chan(?t))      { v.visit_ty(t, e, v); }\n         case (ty_task)          { /* no-op */ }\n-        case (ty_tup(?mts)) {\n-            for (mt mt in mts) { v.visit_ty(mt.ty, e, v); }\n-        }\n         case (ty_rec(?flds)) {\n             for (ty_field f in flds) { v.visit_ty(f.node.mt.ty, e, v); }\n         }\n@@ -279,9 +276,6 @@ fn visit_mac[E](mac m, &E e, &vt[E] v) {\n fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n     alt (ex.node) {\n         case (expr_vec(?es, _, _)) { visit_exprs(es, e, v); }\n-        case (expr_tup(?elts)) {\n-            for (elt el in elts) { v.visit_expr(el.expr, e, v); }\n-        }\n         case (expr_rec(?flds, ?base)) {\n             for (field f in flds) { v.visit_expr(f.node.expr, e, v); }\n             visit_expr_opt(base, e, v);"}, {"sha": "d439a2e0aeaa2c9800e1f1304b83c41cdca874e5", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -154,9 +154,6 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n         case (ast::ty_task) { }\n         case (ast::ty_port(?t)) { walk_ty(v, t); }\n         case (ast::ty_chan(?t)) { walk_ty(v, t); }\n-        case (ast::ty_tup(?mts)) {\n-            for (ast::mt mt in mts) { walk_ty(v, mt.ty); }\n-        }\n         case (ast::ty_rec(?flds)) {\n             for (ast::ty_field f in flds) { walk_ty(v, f.node.mt.ty); }\n         }\n@@ -286,9 +283,6 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n     v.visit_expr_pre(e);\n     alt (e.node) {\n         case (ast::expr_vec(?es, _, _)) { walk_exprs(v, es); }\n-        case (ast::expr_tup(?elts)) {\n-            for (ast::elt e in elts) { walk_expr(v, e.expr); }\n-        }\n         case (ast::expr_rec(?flds, ?base)) {\n             for (ast::field f in flds) { walk_expr(v, f.node.expr); }\n             walk_expr_opt(v, base);"}, {"sha": "3cef5fe1b757282c831e2a53d342fbf356322d45", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1250780d9f533762f647b52b83e25fa394778e/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=2c1250780d9f533762f647b52b83e25fa394778e", "patch": "@@ -103,11 +103,6 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         case (ty_chan(?t)) { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n         case (ty_type) { s += \"type\"; }\n         case (ty_task) { s += \"task\"; }\n-        case (ty_tup(?elems)) {\n-            let str[] strs = ~[];\n-            for (mt tm in elems) { strs += ~[mt_to_str(cx, tm)]; }\n-            s += \"tup(\" + str::connect_ivec(strs, \",\") + \")\";\n-        }\n         case (ty_rec(?elems)) {\n             let str[] strs = ~[];\n             for (field fld in elems) { strs += ~[field_to_str(cx, fld)]; }"}]}