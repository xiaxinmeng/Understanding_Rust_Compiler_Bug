{"sha": "6403b530bb75f708b44a22e166671917121e625f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MDNiNTMwYmI3NWY3MDhiNDRhMjJlMTY2NjcxOTE3MTIxZTYyNWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-22T11:15:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-22T11:15:22Z"}, "message": "Merge #7387\n\n7387: Refactor build script specific data r=edwin0cheng a=edwin0cheng\n\nIt refactors for separating logic for build script specific data. \r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f05c007360c1450812a28d2578e273bc0039d09b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f05c007360c1450812a28d2578e273bc0039d09b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6403b530bb75f708b44a22e166671917121e625f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgCrPKCRBK7hj4Ov3rIwAAdHIIAArGvslOWhPiHviEhfBIR7KH\nfAyL4smb8OQ0a9n/sxU8oGUIlfFa5RXN/xHjjKJyZdqPFazv0hcTukploWcEubmL\nIF4xvtvOc6frslAaeyWI4dxnkkSs/Ct35ul2ghdZJN/Nvb2qJPMGMfOibjOMxwr6\nSAUB16JCMUDOBQWzJgIejRwNJKbnoERAOVi//HUuYS/Fd1AypXr4fF1zzCjr29oZ\n9c3PjnjciPtztpSFq7hQ/cy7Ynb7fRk+HbtC8z8DxLxj6OVHCCg+pTebI7jzt0ed\nWgX3BHrvjpNBarrzNdzjWR4SXZuxK4lLLOfKbQs5TeIj+nFjL+k3I6ojB+l8wB4=\n=FUnc\n-----END PGP SIGNATURE-----\n", "payload": "tree f05c007360c1450812a28d2578e273bc0039d09b\nparent 2472851ccf22762065670e1cf00a9c39db869aac\nparent 6bdb6786babf47234b87daf512a742d2b169231a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611314122 +0000\ncommitter GitHub <noreply@github.com> 1611314122 +0000\n\nMerge #7387\n\n7387: Refactor build script specific data r=edwin0cheng a=edwin0cheng\n\nIt refactors for separating logic for build script specific data. \r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6403b530bb75f708b44a22e166671917121e625f", "html_url": "https://github.com/rust-lang/rust/commit/6403b530bb75f708b44a22e166671917121e625f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6403b530bb75f708b44a22e166671917121e625f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2472851ccf22762065670e1cf00a9c39db869aac", "url": "https://api.github.com/repos/rust-lang/rust/commits/2472851ccf22762065670e1cf00a9c39db869aac", "html_url": "https://github.com/rust-lang/rust/commit/2472851ccf22762065670e1cf00a9c39db869aac"}, {"sha": "6bdb6786babf47234b87daf512a742d2b169231a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdb6786babf47234b87daf512a742d2b169231a", "html_url": "https://github.com/rust-lang/rust/commit/6bdb6786babf47234b87daf512a742d2b169231a"}], "stats": {"total": 424, "additions": 228, "deletions": 196}, "files": [{"sha": "82fcf23ada765d67119461b15c4e5389bd7fcbee", "filename": "crates/project_model/src/build_data.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=6403b530bb75f708b44a22e166671917121e625f", "patch": "@@ -0,0 +1,206 @@\n+//! Handles build script specific information\n+\n+use std::{\n+    ffi::OsStr,\n+    io::BufReader,\n+    path::{Path, PathBuf},\n+    process::{Command, Stdio},\n+};\n+\n+use anyhow::Result;\n+use cargo_metadata::{BuildScript, Message, Package, PackageId};\n+use itertools::Itertools;\n+use paths::AbsPathBuf;\n+use rustc_hash::FxHashMap;\n+use stdx::JodChild;\n+\n+use crate::{cfg_flag::CfgFlag, CargoConfig};\n+\n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct BuildDataMap {\n+    data: FxHashMap<PackageId, BuildData>,\n+}\n+#[derive(Debug, Clone, Default, PartialEq, Eq)]\n+pub struct BuildData {\n+    /// List of config flags defined by this package's build script\n+    pub cfgs: Vec<CfgFlag>,\n+    /// List of cargo-related environment variables with their value\n+    ///\n+    /// If the package has a build script which defines environment variables,\n+    /// they can also be found here.\n+    pub envs: Vec<(String, String)>,\n+    /// Directory where a build script might place its output\n+    pub out_dir: Option<AbsPathBuf>,\n+    /// Path to the proc-macro library file if this package exposes proc-macros\n+    pub proc_macro_dylib_path: Option<AbsPathBuf>,\n+}\n+\n+impl BuildDataMap {\n+    pub(crate) fn new(\n+        cargo_toml: &Path,\n+        cargo_features: &CargoConfig,\n+        packages: &Vec<Package>,\n+        progress: &dyn Fn(String),\n+    ) -> Result<BuildDataMap> {\n+        let mut cmd = Command::new(toolchain::cargo());\n+        cmd.args(&[\"check\", \"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+            .arg(cargo_toml);\n+\n+        // --all-targets includes tests, benches and examples in addition to the\n+        // default lib and bins. This is an independent concept from the --targets\n+        // flag below.\n+        cmd.arg(\"--all-targets\");\n+\n+        if let Some(target) = &cargo_features.target {\n+            cmd.args(&[\"--target\", target]);\n+        }\n+\n+        if cargo_features.all_features {\n+            cmd.arg(\"--all-features\");\n+        } else {\n+            if cargo_features.no_default_features {\n+                // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+                // https://github.com/oli-obk/cargo_metadata/issues/79\n+                cmd.arg(\"--no-default-features\");\n+            }\n+            if !cargo_features.features.is_empty() {\n+                cmd.arg(\"--features\");\n+                cmd.arg(cargo_features.features.join(\" \"));\n+            }\n+        }\n+\n+        cmd.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n+\n+        let mut child = cmd.spawn().map(JodChild)?;\n+        let child_stdout = child.stdout.take().unwrap();\n+        let stdout = BufReader::new(child_stdout);\n+\n+        let mut res = BuildDataMap::default();\n+        for message in cargo_metadata::Message::parse_stream(stdout) {\n+            if let Ok(message) = message {\n+                match message {\n+                    Message::BuildScriptExecuted(BuildScript {\n+                        package_id,\n+                        out_dir,\n+                        cfgs,\n+                        env,\n+                        ..\n+                    }) => {\n+                        let cfgs = {\n+                            let mut acc = Vec::new();\n+                            for cfg in cfgs {\n+                                match cfg.parse::<CfgFlag>() {\n+                                    Ok(it) => acc.push(it),\n+                                    Err(err) => {\n+                                        anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n+                                    }\n+                                };\n+                            }\n+                            acc\n+                        };\n+                        let res = res.data.entry(package_id.clone()).or_default();\n+                        // cargo_metadata crate returns default (empty) path for\n+                        // older cargos, which is not absolute, so work around that.\n+                        if out_dir != PathBuf::default() {\n+                            let out_dir = AbsPathBuf::assert(out_dir);\n+                            res.out_dir = Some(out_dir);\n+                            res.cfgs = cfgs;\n+                        }\n+\n+                        res.envs = env;\n+                    }\n+                    Message::CompilerArtifact(message) => {\n+                        progress(format!(\"metadata {}\", message.target.name));\n+\n+                        if message.target.kind.contains(&\"proc-macro\".to_string()) {\n+                            let package_id = message.package_id;\n+                            // Skip rmeta file\n+                            if let Some(filename) =\n+                                message.filenames.iter().find(|name| is_dylib(name))\n+                            {\n+                                let filename = AbsPathBuf::assert(filename.clone());\n+                                let res = res.data.entry(package_id.clone()).or_default();\n+                                res.proc_macro_dylib_path = Some(filename);\n+                            }\n+                        }\n+                    }\n+                    Message::CompilerMessage(message) => {\n+                        progress(message.target.name.clone());\n+                    }\n+                    Message::Unknown => (),\n+                    Message::BuildFinished(_) => {}\n+                    Message::TextLine(_) => {}\n+                }\n+            }\n+        }\n+        res.inject_cargo_env(packages);\n+        Ok(res)\n+    }\n+\n+    pub(crate) fn with_cargo_env(packages: &Vec<Package>) -> Self {\n+        let mut res = Self::default();\n+        res.inject_cargo_env(packages);\n+        res\n+    }\n+\n+    pub(crate) fn get(&self, id: &PackageId) -> Option<&BuildData> {\n+        self.data.get(id)\n+    }\n+\n+    fn inject_cargo_env(&mut self, packages: &Vec<Package>) {\n+        for meta_pkg in packages {\n+            let resource = self.data.entry(meta_pkg.id.clone()).or_default();\n+            inject_cargo_env(meta_pkg, &mut resource.envs);\n+\n+            if let Some(out_dir) = &resource.out_dir {\n+                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+                if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                    resource.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME: File a better way to know if it is a dylib\n+fn is_dylib(path: &Path) -> bool {\n+    match path.extension().and_then(OsStr::to_str).map(|it| it.to_string().to_lowercase()) {\n+        None => false,\n+        Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n+    }\n+}\n+\n+/// Recreates the compile-time environment variables that Cargo sets.\n+///\n+/// Should be synced with <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>\n+fn inject_cargo_env(package: &cargo_metadata::Package, env: &mut Vec<(String, String)>) {\n+    // FIXME: Missing variables:\n+    // CARGO, CARGO_PKG_HOMEPAGE, CARGO_CRATE_NAME, CARGO_BIN_NAME, CARGO_BIN_EXE_<name>\n+\n+    let mut manifest_dir = package.manifest_path.clone();\n+    manifest_dir.pop();\n+    if let Some(cargo_manifest_dir) = manifest_dir.to_str() {\n+        env.push((\"CARGO_MANIFEST_DIR\".into(), cargo_manifest_dir.into()));\n+    }\n+\n+    env.push((\"CARGO_PKG_VERSION\".into(), package.version.to_string()));\n+    env.push((\"CARGO_PKG_VERSION_MAJOR\".into(), package.version.major.to_string()));\n+    env.push((\"CARGO_PKG_VERSION_MINOR\".into(), package.version.minor.to_string()));\n+    env.push((\"CARGO_PKG_VERSION_PATCH\".into(), package.version.patch.to_string()));\n+\n+    let pre = package.version.pre.iter().map(|id| id.to_string()).format(\".\");\n+    env.push((\"CARGO_PKG_VERSION_PRE\".into(), pre.to_string()));\n+\n+    let authors = package.authors.join(\";\");\n+    env.push((\"CARGO_PKG_AUTHORS\".into(), authors));\n+\n+    env.push((\"CARGO_PKG_NAME\".into(), package.name.clone()));\n+    env.push((\"CARGO_PKG_DESCRIPTION\".into(), package.description.clone().unwrap_or_default()));\n+    //env.push((\"CARGO_PKG_HOMEPAGE\".into(), package.homepage.clone().unwrap_or_default()));\n+    env.push((\"CARGO_PKG_REPOSITORY\".into(), package.repository.clone().unwrap_or_default()));\n+    env.push((\"CARGO_PKG_LICENSE\".into(), package.license.clone().unwrap_or_default()));\n+\n+    let license_file =\n+        package.license_file.as_ref().map(|buf| buf.display().to_string()).unwrap_or_default();\n+    env.push((\"CARGO_PKG_LICENSE_FILE\".into(), license_file));\n+}"}, {"sha": "c8a5333c44092fa489bc2a943bc35f744ec99db8", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 12, "deletions": 185, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=6403b530bb75f708b44a22e166671917121e625f", "patch": "@@ -1,24 +1,15 @@\n //! FIXME: write short doc here\n \n-use std::{\n-    convert::TryInto,\n-    ffi::OsStr,\n-    io::BufReader,\n-    ops,\n-    path::{Path, PathBuf},\n-    process::{Command, Stdio},\n-};\n+use std::{convert::TryInto, ops, process::Command};\n \n use anyhow::{Context, Result};\n use base_db::Edition;\n-use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n-use itertools::Itertools;\n+use cargo_metadata::{CargoOpt, MetadataCommand};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n-use stdx::JodChild;\n \n-use crate::cfg_flag::CfgFlag;\n+use crate::build_data::{BuildData, BuildDataMap};\n use crate::utf8_stdout;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n@@ -103,17 +94,8 @@ pub struct PackageData {\n     pub features: FxHashMap<String, Vec<String>>,\n     /// List of features enabled on this package\n     pub active_features: Vec<String>,\n-    /// List of config flags defined by this package's build script\n-    pub cfgs: Vec<CfgFlag>,\n-    /// List of cargo-related environment variables with their value\n-    ///\n-    /// If the package has a build script which defines environment variables,\n-    /// they can also be found here.\n-    pub envs: Vec<(String, String)>,\n-    /// Directory where a build script might place its output\n-    pub out_dir: Option<AbsPathBuf>,\n-    /// Path to the proc-macro library file if this package exposes proc-macros\n-    pub proc_macro_dylib_path: Option<AbsPathBuf>,\n+    /// Build script related data for this package\n+    pub build_data: BuildData,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -246,17 +228,11 @@ impl CargoWorkspace {\n             )\n         })?;\n \n-        let mut out_dir_by_id = FxHashMap::default();\n-        let mut cfgs = FxHashMap::default();\n-        let mut envs = FxHashMap::default();\n-        let mut proc_macro_dylib_paths = FxHashMap::default();\n-        if config.load_out_dirs_from_check {\n-            let resources = load_extern_resources(cargo_toml, config, progress)?;\n-            out_dir_by_id = resources.out_dirs;\n-            cfgs = resources.cfgs;\n-            envs = resources.env;\n-            proc_macro_dylib_paths = resources.proc_dylib_paths;\n-        }\n+        let resources = if config.load_out_dirs_from_check {\n+            BuildDataMap::new(cargo_toml, config, &meta.packages, progress)?\n+        } else {\n+            BuildDataMap::with_cargo_env(&meta.packages)\n+        };\n \n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n@@ -267,7 +243,7 @@ impl CargoWorkspace {\n         meta.packages.sort_by(|a, b| a.id.cmp(&b.id));\n         for meta_pkg in meta.packages {\n             let id = meta_pkg.id.clone();\n-            inject_cargo_env(&meta_pkg, envs.entry(id).or_default());\n+            let build_data = resources.get(&id).cloned().unwrap_or_default();\n \n             let cargo_metadata::Package { id, edition, name, manifest_path, version, .. } =\n                 meta_pkg;\n@@ -285,10 +261,7 @@ impl CargoWorkspace {\n                 dependencies: Vec::new(),\n                 features: meta_pkg.features.into_iter().collect(),\n                 active_features: Vec::new(),\n-                cfgs: cfgs.get(&id).cloned().unwrap_or_default(),\n-                envs: envs.get(&id).cloned().unwrap_or_default(),\n-                out_dir: out_dir_by_id.get(&id).cloned(),\n-                proc_macro_dylib_path: proc_macro_dylib_paths.get(&id).cloned(),\n+                build_data,\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n@@ -365,149 +338,3 @@ impl CargoWorkspace {\n         self.packages.iter().filter(|(_, v)| v.name == name).count() == 1\n     }\n }\n-\n-#[derive(Debug, Clone, Default)]\n-pub(crate) struct ExternResources {\n-    out_dirs: FxHashMap<PackageId, AbsPathBuf>,\n-    proc_dylib_paths: FxHashMap<PackageId, AbsPathBuf>,\n-    cfgs: FxHashMap<PackageId, Vec<CfgFlag>>,\n-    env: FxHashMap<PackageId, Vec<(String, String)>>,\n-}\n-\n-pub(crate) fn load_extern_resources(\n-    cargo_toml: &Path,\n-    cargo_features: &CargoConfig,\n-    progress: &dyn Fn(String),\n-) -> Result<ExternResources> {\n-    let mut cmd = Command::new(toolchain::cargo());\n-    cmd.args(&[\"check\", \"--workspace\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n-\n-    // --all-targets includes tests, benches and examples in addition to the\n-    // default lib and bins. This is an independent concept from the --targets\n-    // flag below.\n-    cmd.arg(\"--all-targets\");\n-\n-    if let Some(target) = &cargo_features.target {\n-        cmd.args(&[\"--target\", target]);\n-    }\n-\n-    if cargo_features.all_features {\n-        cmd.arg(\"--all-features\");\n-    } else {\n-        if cargo_features.no_default_features {\n-            // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-            // https://github.com/oli-obk/cargo_metadata/issues/79\n-            cmd.arg(\"--no-default-features\");\n-        }\n-        if !cargo_features.features.is_empty() {\n-            cmd.arg(\"--features\");\n-            cmd.arg(cargo_features.features.join(\" \"));\n-        }\n-    }\n-\n-    cmd.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n-\n-    let mut child = cmd.spawn().map(JodChild)?;\n-    let child_stdout = child.stdout.take().unwrap();\n-    let stdout = BufReader::new(child_stdout);\n-\n-    let mut res = ExternResources::default();\n-    for message in cargo_metadata::Message::parse_stream(stdout) {\n-        if let Ok(message) = message {\n-            match message {\n-                Message::BuildScriptExecuted(BuildScript {\n-                    package_id,\n-                    out_dir,\n-                    cfgs,\n-                    env,\n-                    ..\n-                }) => {\n-                    let cfgs = {\n-                        let mut acc = Vec::new();\n-                        for cfg in cfgs {\n-                            match cfg.parse::<CfgFlag>() {\n-                                Ok(it) => acc.push(it),\n-                                Err(err) => {\n-                                    anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n-                                }\n-                            };\n-                        }\n-                        acc\n-                    };\n-                    // cargo_metadata crate returns default (empty) path for\n-                    // older cargos, which is not absolute, so work around that.\n-                    if out_dir != PathBuf::default() {\n-                        let out_dir = AbsPathBuf::assert(out_dir);\n-                        res.out_dirs.insert(package_id.clone(), out_dir);\n-                        res.cfgs.insert(package_id.clone(), cfgs);\n-                    }\n-\n-                    res.env.insert(package_id, env);\n-                }\n-                Message::CompilerArtifact(message) => {\n-                    progress(format!(\"metadata {}\", message.target.name));\n-\n-                    if message.target.kind.contains(&\"proc-macro\".to_string()) {\n-                        let package_id = message.package_id;\n-                        // Skip rmeta file\n-                        if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n-                        {\n-                            let filename = AbsPathBuf::assert(filename.clone());\n-                            res.proc_dylib_paths.insert(package_id, filename);\n-                        }\n-                    }\n-                }\n-                Message::CompilerMessage(message) => {\n-                    progress(message.target.name.clone());\n-                }\n-                Message::Unknown => (),\n-                Message::BuildFinished(_) => {}\n-                Message::TextLine(_) => {}\n-            }\n-        }\n-    }\n-    Ok(res)\n-}\n-\n-// FIXME: File a better way to know if it is a dylib\n-fn is_dylib(path: &Path) -> bool {\n-    match path.extension().and_then(OsStr::to_str).map(|it| it.to_string().to_lowercase()) {\n-        None => false,\n-        Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n-    }\n-}\n-\n-/// Recreates the compile-time environment variables that Cargo sets.\n-///\n-/// Should be synced with <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>\n-fn inject_cargo_env(package: &cargo_metadata::Package, env: &mut Vec<(String, String)>) {\n-    // FIXME: Missing variables:\n-    // CARGO, CARGO_PKG_HOMEPAGE, CARGO_CRATE_NAME, CARGO_BIN_NAME, CARGO_BIN_EXE_<name>\n-\n-    let mut manifest_dir = package.manifest_path.clone();\n-    manifest_dir.pop();\n-    if let Some(cargo_manifest_dir) = manifest_dir.to_str() {\n-        env.push((\"CARGO_MANIFEST_DIR\".into(), cargo_manifest_dir.into()));\n-    }\n-\n-    env.push((\"CARGO_PKG_VERSION\".into(), package.version.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_MAJOR\".into(), package.version.major.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_MINOR\".into(), package.version.minor.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_PATCH\".into(), package.version.patch.to_string()));\n-\n-    let pre = package.version.pre.iter().map(|id| id.to_string()).format(\".\");\n-    env.push((\"CARGO_PKG_VERSION_PRE\".into(), pre.to_string()));\n-\n-    let authors = package.authors.join(\";\");\n-    env.push((\"CARGO_PKG_AUTHORS\".into(), authors));\n-\n-    env.push((\"CARGO_PKG_NAME\".into(), package.name.clone()));\n-    env.push((\"CARGO_PKG_DESCRIPTION\".into(), package.description.clone().unwrap_or_default()));\n-    //env.push((\"CARGO_PKG_HOMEPAGE\".into(), package.homepage.clone().unwrap_or_default()));\n-    env.push((\"CARGO_PKG_REPOSITORY\".into(), package.repository.clone().unwrap_or_default()));\n-    env.push((\"CARGO_PKG_LICENSE\".into(), package.license.clone().unwrap_or_default()));\n-\n-    let license_file =\n-        package.license_file.as_ref().map(|buf| buf.display().to_string()).unwrap_or_default();\n-    env.push((\"CARGO_PKG_LICENSE_FILE\".into(), license_file));\n-}"}, {"sha": "525c336e6347e089ac358ef79852ddbc0eaea267", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=6403b530bb75f708b44a22e166671917121e625f", "patch": "@@ -6,6 +6,7 @@ mod project_json;\n mod sysroot;\n mod workspace;\n mod rustc_cfg;\n+mod build_data;\n \n use std::{\n     fs::{read_dir, ReadDir},"}, {"sha": "bc5041e5a3d5f46f989f0197d7c65d93d1cc4aa0", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6403b530bb75f708b44a22e166671917121e625f/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=6403b530bb75f708b44a22e166671917121e625f", "patch": "@@ -178,7 +178,7 @@ impl ProjectWorkspace {\n                     let pkg_root = cargo[pkg].root().to_path_buf();\n \n                     let mut include = vec![pkg_root.clone()];\n-                    include.extend(cargo[pkg].out_dir.clone());\n+                    include.extend(cargo[pkg].build_data.out_dir.clone());\n \n                     let mut exclude = vec![pkg_root.join(\".git\")];\n                     if is_member {\n@@ -484,23 +484,21 @@ fn add_target_crate_root(\n         for feature in pkg.active_features.iter() {\n             opts.insert_key_value(\"feature\".into(), feature.into());\n         }\n-        opts.extend(pkg.cfgs.iter().cloned());\n+        opts.extend(pkg.build_data.cfgs.iter().cloned());\n         opts\n     };\n \n     let mut env = Env::default();\n-    for (k, v) in &pkg.envs {\n+    for (k, v) in &pkg.build_data.envs {\n         env.set(k, v.clone());\n     }\n-    if let Some(out_dir) = &pkg.out_dir {\n-        // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-        if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-            env.set(\"OUT_DIR\", out_dir);\n-        }\n-    }\n \n-    let proc_macro =\n-        pkg.proc_macro_dylib_path.as_ref().map(|it| proc_macro_loader(&it)).unwrap_or_default();\n+    let proc_macro = pkg\n+        .build_data\n+        .proc_macro_dylib_path\n+        .as_ref()\n+        .map(|it| proc_macro_loader(&it))\n+        .unwrap_or_default();\n \n     let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n     let crate_id = crate_graph.add_crate_root("}]}