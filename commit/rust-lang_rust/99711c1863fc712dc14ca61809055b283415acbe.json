{"sha": "99711c1863fc712dc14ca61809055b283415acbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NzExYzE4NjNmYzcxMmRjMTRjYTYxODA5MDU1YjI4MzQxNWFjYmU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-25T20:24:20Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-25T20:28:36Z"}, "message": "Clean up comments / use nicer Iterator methods", "tree": {"sha": "c79204bca4912574614eafff8f9e18775d5aa963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c79204bca4912574614eafff8f9e18775d5aa963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99711c1863fc712dc14ca61809055b283415acbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99711c1863fc712dc14ca61809055b283415acbe", "html_url": "https://github.com/rust-lang/rust/commit/99711c1863fc712dc14ca61809055b283415acbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99711c1863fc712dc14ca61809055b283415acbe/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "html_url": "https://github.com/rust-lang/rust/commit/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18"}], "stats": {"total": 25, "additions": 15, "deletions": 10}, "files": [{"sha": "2609585b1f1e98607e30edaa4fdd3589e9ed4050", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99711c1863fc712dc14ca61809055b283415acbe/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99711c1863fc712dc14ca61809055b283415acbe/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=99711c1863fc712dc14ca61809055b283415acbe", "patch": "@@ -187,7 +187,7 @@ impl Resolver {\n                 }\n                 .into_iter()\n             })\n-            .flat_map(|i| i)\n+            .flatten()\n     }\n \n     fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {"}, {"sha": "3ac8dc46b0d747ebb5232f1a5cab6b2f3b9af88e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99711c1863fc712dc14ca61809055b283415acbe/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99711c1863fc712dc14ca61809055b283415acbe/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=99711c1863fc712dc14ca61809055b283415acbe", "patch": "@@ -118,12 +118,8 @@ pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n         None => return false,\n     };\n     let crate_impl_blocks = db.impls_in_crate(krate);\n-    for impl_block in crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_) {\n-        if &impl_block.target_ty(db) == trait_ref.self_ty() {\n-            return true;\n-        }\n-    }\n-    false\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n }\n \n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n@@ -145,7 +141,7 @@ impl Ty {\n         name: &Name,\n         resolver: &Resolver,\n     ) -> Option<(Ty, Function)> {\n-        // FIXME: what has priority, an inherent method that needs autoderefs or a trait method?\n+        // FIXME: trait methods should be used before autoderefs\n         let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n@@ -178,12 +174,21 @@ impl Ty {\n                 }\n             }\n         }\n-        // FIXME the implements check may result in other obligations or unifying variables?\n+        // FIXME:\n+        //  - we might not actually be able to determine fully that the type\n+        //    implements the trait here; it's enough if we (well, Chalk) determine\n+        //    that it's possible.\n+        //  - when the trait method is picked, we need to register an\n+        //    'obligation' somewhere so that we later check that it's really\n+        //    implemented\n+        //  - both points go for additional requirements from where clauses as\n+        //    well (in fact, the 'implements' condition could just be considered a\n+        //    'where Self: Trait' clause)\n         candidates.retain(|(t, _m)| {\n             let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n             db.implements(trait_ref)\n         });\n-        // FIXME what happens if there are still multiple potential candidates?\n+        // FIXME if there's multiple candidates here, that's an ambiguity error\n         let (_chosen_trait, chosen_method) = candidates.first()?;\n         Some((self.clone(), *chosen_method))\n     }"}]}