{"sha": "1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZjdkZGZkYTM5NjA1ODlkNmY1Zjc5ZWExOGQwNTFhY2RlYWJkNzg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-06T00:11:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:43:34Z"}, "message": "typeck: disallow `impl Trait` outside of return types of functions and impl methods.", "tree": {"sha": "aac8f7815ca7dcb21dba076d95c2a10ba0e7b0fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aac8f7815ca7dcb21dba076d95c2a10ba0e7b0fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "html_url": "https://github.com/rust-lang/rust/commit/1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef11d4e3c7040bf7cbb351dac8317a7957471b3b", "html_url": "https://github.com/rust-lang/rust/commit/ef11d4e3c7040bf7cbb351dac8317a7957471b3b"}], "stats": {"total": 217, "additions": 174, "deletions": 43}, "files": [{"sha": "76c73f12f4ebe28c485b3e4c9257d4e9c4cb4073", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "patch": "@@ -832,7 +832,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         constrained_by_input.visit_ty(&arg.ty);\n     }\n \n-    let mut appears_in_output = AllCollector { regions: FnvHashSet() };\n+    let mut appears_in_output = AllCollector {\n+        regions: FnvHashSet(),\n+        impl_trait: false\n+    };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n     debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n@@ -842,7 +845,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     //\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n-    let mut appears_in_where_clause = AllCollector { regions: FnvHashSet() };\n+    let mut appears_in_where_clause = AllCollector {\n+        regions: FnvHashSet(),\n+        impl_trait: false\n+    };\n     for ty_param in generics.ty_params.iter() {\n         walk_list!(&mut appears_in_where_clause,\n                    visit_ty_param_bound,\n@@ -864,12 +870,16 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     // Late bound regions are those that:\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n+    // - are not implicitly captured by `impl Trait`\n     for lifetime in &generics.lifetimes {\n         let name = lifetime.lifetime.name;\n \n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&name) { continue; }\n \n+        // any `impl Trait` in the return type? early-bound.\n+        if appears_in_output.impl_trait { continue; }\n+\n         // does not appear in the inputs, but appears in the return\n         // type? eventually this will be early-bound, but for now we\n         // just mark it so we can issue warnings.\n@@ -932,12 +942,20 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n \n     struct AllCollector {\n         regions: FnvHashSet<ast::Name>,\n+        impl_trait: bool\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n             self.regions.insert(lifetime_ref.name);\n         }\n+\n+        fn visit_ty(&mut self, ty: &hir::Ty) {\n+            if let hir::TyImplTrait(_) = ty.node {\n+                self.impl_trait = true;\n+            }\n+            intravisit::walk_ty(self, ty);\n+        }\n     }\n }\n "}, {"sha": "57e58a98b533cd2fceb4c11f6f58cb1afec230ad", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "patch": "@@ -65,6 +65,7 @@ use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n              ElisionFailureInfo, ElidedLifetime};\n+use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FnvHashSet};\n \n@@ -635,20 +636,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_ty_with_lifetime_elision(&self,\n                                         elided_lifetime: ElidedLifetime,\n-                                        ty: &hir::Ty)\n+                                        ty: &hir::Ty,\n+                                        anon_scope: Option<AnonTypeScope>)\n                                         -> Ty<'tcx>\n     {\n         match elided_lifetime {\n             Ok(implied_output_region) => {\n                 let rb = ElidableRscope::new(implied_output_region);\n-                self.ast_ty_to_ty(&rb, ty)\n+                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n             }\n             Err(param_lifetimes) => {\n                 // All regions must be explicitly specified in the output\n                 // if the lifetime elision rules do not apply. This saves\n                 // the user from potentially-confusing errors.\n                 let rb = UnelidableRscope::new(param_lifetimes);\n-                self.ast_ty_to_ty(&rb, ty)\n+                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n             }\n         }\n     }\n@@ -665,7 +667,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let region_substs =\n             self.create_region_substs(rscope, span, decl_generics, Vec::new());\n \n-        let binding_rscope = BindingRscope::new();\n+        let anon_scope = rscope.anon_type_scope();\n+        let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n         let inputs =\n             data.inputs.iter()\n                        .map(|a_t| self.ast_ty_arg_to_ty(&binding_rscope, decl_generics,\n@@ -679,7 +682,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.convert_ty_with_lifetime_elision(implied_output_region, &output_ty),\n+                (self.convert_ty_with_lifetime_elision(implied_output_region,\n+                                                       &output_ty,\n+                                                       anon_scope),\n                  output_ty.span)\n             }\n             None => {\n@@ -1703,7 +1708,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let bare_fn_ty = self.ty_of_bare_fn(bf.unsafety, bf.abi, &bf.decl);\n+                let anon_scope = rscope.anon_type_scope();\n+                let (bare_fn_ty, _) =\n+                    self.ty_of_method_or_bare_fn(bf.unsafety,\n+                                                 bf.abi,\n+                                                 None,\n+                                                 &bf.decl,\n+                                                 anon_scope,\n+                                                 anon_scope);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1751,10 +1763,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 // Create the anonymized type.\n                 let def_id = tcx.map.local_def_id(ast_ty.id);\n-                let substs = tcx.mk_substs(Substs::empty());\n+                let substs = if let Some(anon_scope) = rscope.anon_type_scope() {\n+                    anon_scope.fresh_substs(tcx)\n+                } else {\n+                    span_err!(tcx.sess, ast_ty.span, E0562,\n+                              \"`impl Trait` not allowed outside of function \\\n+                               and inherent method return types\");\n+                    tcx.mk_substs(Substs::empty())\n+                };\n                 let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n \n-                // Collect the bounds, i.e. the `Trait` in `impl Trait`.\n+                // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                 let bounds = compute_bounds(self, ty, bounds, SizedByDefault::Yes, ast_ty.span);\n                 let predicates = tcx.lift_to_global(&bounds.predicates(tcx, ty)).unwrap();\n                 let predicates = ty::GenericPredicates {\n@@ -1828,36 +1847,40 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn ty_of_method(&self,\n                         sig: &hir::MethodSig,\n-                        untransformed_self_ty: Ty<'tcx>)\n+                        untransformed_self_ty: Ty<'tcx>,\n+                        anon_scope: Option<AnonTypeScope>)\n                         -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n-        let (bare_fn_ty, optional_explicit_self_category) =\n-            self.ty_of_method_or_bare_fn(sig.unsafety,\n-                                         sig.abi,\n-                                         Some(untransformed_self_ty),\n-                                         &sig.decl);\n-        (bare_fn_ty, optional_explicit_self_category)\n+        self.ty_of_method_or_bare_fn(sig.unsafety,\n+                                     sig.abi,\n+                                     Some(untransformed_self_ty),\n+                                     &sig.decl,\n+                                     None,\n+                                     anon_scope)\n     }\n \n     pub fn ty_of_bare_fn(&self,\n                          unsafety: hir::Unsafety,\n                          abi: abi::Abi,\n-                         decl: &hir::FnDecl)\n+                         decl: &hir::FnDecl,\n+                         anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl).0\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope).0\n     }\n \n-    fn ty_of_method_or_bare_fn<'a>(&self,\n-                                   unsafety: hir::Unsafety,\n-                                   abi: abi::Abi,\n-                                   opt_untransformed_self_ty: Option<Ty<'tcx>>,\n-                                   decl: &hir::FnDecl)\n-                                   -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n+    fn ty_of_method_or_bare_fn(&self,\n+                               unsafety: hir::Unsafety,\n+                               abi: abi::Abi,\n+                               opt_untransformed_self_ty: Option<Ty<'tcx>>,\n+                               decl: &hir::FnDecl,\n+                               arg_anon_scope: Option<AnonTypeScope>,\n+                               ret_anon_scope: Option<AnonTypeScope>)\n+                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n         // New region names that appear inside of the arguments of the function\n         // declaration are bound to that function type.\n-        let rb = rscope::BindingRscope::new();\n+        let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n \n         // `implied_output_region` is the region that will be assumed for any\n         // region parameters in the return type. In accordance with the rules for\n@@ -1895,7 +1918,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let output_ty = match decl.output {\n             hir::Return(ref output) =>\n                 ty::FnConverging(self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                                       &output)),\n+                                                                       &output,\n+                                                                       ret_anon_scope)),\n             hir::DefaultReturn(..) => ty::FnConverging(self.tcx().mk_nil()),\n             hir::NoReturn(..) => ty::FnDiverging\n         };"}, {"sha": "7c52ea5f3c977645a4b0b38ee005d54b6819eac0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "patch": "@@ -564,13 +564,17 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generic_predicates =\n         ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n \n-    let (fty, explicit_self_category) =\n+    let (fty, explicit_self_category) = {\n+        let anon_scope = match container {\n+            ImplContainer(_) => Some(AnonTypeScope::new(&ty_generics)),\n+            TraitContainer(_) => None\n+        };\n         AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                              sig,\n-                              untransformed_rcvr_ty);\n+                              sig, untransformed_rcvr_ty, anon_scope)\n+    };\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n \n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n@@ -961,7 +965,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n             let def_id = tcx.map.local_def_id(ctor_id);\n-            let substs = mk_item_substs(ccx, &scheme.generics);\n+            let substs = mk_item_substs(tcx, &scheme.generics);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -1460,9 +1464,10 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n+            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n+                                              Some(AnonTypeScope::new(&ty_generics)));\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let ty = tcx.mk_fn_def(def_id, substs, tofd);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n@@ -1474,14 +1479,14 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemEnum(ref ei, ref generics) => {\n             let def = convert_enum_def(ccx, it, ei);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let t = tcx.mk_enum(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         hir::ItemStruct(ref si, ref generics) => {\n             let def = convert_struct_def(ccx, it, si);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let t = tcx.mk_struct(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n@@ -2194,7 +2199,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n     let t_fn = ccx.tcx.mk_fn_def(id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n@@ -2209,19 +2214,19 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     }\n }\n \n-fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            ty_generics: &ty::Generics<'tcx>)\n-                            -> &'tcx Substs<'tcx>\n+pub fn mk_item_substs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      ty_generics: &ty::Generics)\n+                                      -> &'tcx Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n-            |def| ccx.tcx.mk_param_from_def(def));\n+            |def| tcx.mk_param_from_def(def));\n \n     let regions =\n         ty_generics.regions.map(\n             |def| def.to_early_bound_region());\n \n-    ccx.tcx.mk_substs(Substs::new(types, regions))\n+    tcx.mk_substs(Substs::new(types, regions))\n }\n \n /// Checks that all the type parameters on an impl"}, {"sha": "49c35d1b7efc96c914dcc14d4c874eb1bc172ae2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "patch": "@@ -4084,4 +4084,6 @@ register_diagnostics! {\n     E0513, // no type for local variable ..\n     E0521, // redundant default implementations of trait\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n+    E0562, // `impl Trait` not allowed outside of function\n+           // and inherent method return types\n }"}, {"sha": "58d1ec9d02a954d32047024e8b23b6919a03f9b8", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef7ddfda3960589d6f5f79ea18d051acdeabd78/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n \n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::subst::Substs;\n \n use std::cell::Cell;\n use syntax_pos::Span;\n@@ -50,6 +51,79 @@ pub trait RegionScope {\n     /// computing `object_lifetime_default` (in particular, in legacy\n     /// modes, it may not be relevant).\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n+\n+    /// If this scope allows anonymized types, return the generics in\n+    /// scope, that anonymized types will close over. For example,\n+    /// if you have a function like:\n+    ///\n+    ///     fn foo<'a, T>() -> impl Trait { ... }\n+    ///\n+    /// then, for the rscope that is used when handling the return type,\n+    /// `anon_type_scope()` would return a `Some(AnonTypeScope {...})`,\n+    /// on which `.fresh_substs(...)` can be used to obtain identity\n+    /// Substs for `'a` and `T`, to track them in `TyAnon`. This property\n+    /// is controlled by the region scope because it's fine-grained enough\n+    /// to allow restriction of anonymized types to the syntactical extent\n+    /// of a function's return type.\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct AnonTypeScope<'a> {\n+    generics: &'a ty::Generics<'a>\n+}\n+\n+impl<'a, 'b, 'gcx, 'tcx> AnonTypeScope<'a> {\n+    pub fn new(generics: &'a ty::Generics<'a>) -> AnonTypeScope<'a> {\n+        AnonTypeScope {\n+            generics: generics\n+        }\n+    }\n+\n+    pub fn fresh_substs(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+        use collect::mk_item_substs;\n+\n+        mk_item_substs(tcx, self.generics)\n+    }\n+}\n+\n+/// A scope wrapper which optionally allows anonymized types.\n+#[derive(Copy, Clone)]\n+pub struct MaybeWithAnonTypes<'a, R> {\n+    base_scope: R,\n+    anon_scope: Option<AnonTypeScope<'a>>\n+}\n+\n+impl<'a, R: RegionScope> MaybeWithAnonTypes<'a, R>  {\n+    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope<'a>>) -> Self {\n+        MaybeWithAnonTypes {\n+            base_scope: base_scope,\n+            anon_scope: anon_scope\n+        }\n+    }\n+}\n+\n+impl<'a, R: RegionScope> RegionScope for MaybeWithAnonTypes<'a, R> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        self.base_scope.object_lifetime_default(span)\n+    }\n+\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n+        self.base_scope.anon_regions(span, count)\n+    }\n+\n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n+        self.base_scope.base_object_lifetime_default(span)\n+    }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.anon_scope\n+    }\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -221,6 +295,10 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.base_scope.anon_type_scope()\n+    }\n }\n \n /// A scope which simply shifts the Debruijn index of other scopes\n@@ -262,4 +340,8 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n             }\n         }\n     }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.base_scope.anon_type_scope()\n+    }\n }"}]}