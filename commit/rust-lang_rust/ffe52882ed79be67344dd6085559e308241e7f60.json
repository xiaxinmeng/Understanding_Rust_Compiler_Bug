{"sha": "ffe52882ed79be67344dd6085559e308241e7f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZTUyODgyZWQ3OWJlNjczNDRkZDYwODU1NTllMzA4MjQxZTdmNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T14:24:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T14:24:02Z"}, "message": "Auto merge of #78424 - jyn514:THE-PAPERCLIP-COMETH, r=davidtwco\n\nFix some more clippy warnings\n\nFound while working on https://github.com/rust-lang/rust/pull/77351. It turns out that `x.py clippy --fix` does work on that branch as long as you pass `CARGOFLAGS=--lib`.", "tree": {"sha": "dea8fd60ec5b2aa448b12e491cf8d23053a7892a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dea8fd60ec5b2aa448b12e491cf8d23053a7892a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffe52882ed79be67344dd6085559e308241e7f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe52882ed79be67344dd6085559e308241e7f60", "html_url": "https://github.com/rust-lang/rust/commit/ffe52882ed79be67344dd6085559e308241e7f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffe52882ed79be67344dd6085559e308241e7f60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "388ef349043f20a1a8a3011eaf49dee220485e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/388ef349043f20a1a8a3011eaf49dee220485e0a", "html_url": "https://github.com/rust-lang/rust/commit/388ef349043f20a1a8a3011eaf49dee220485e0a"}, {"sha": "5339bd1ebeb76ea7304ff07dcf8e6c317ba0ced8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5339bd1ebeb76ea7304ff07dcf8e6c317ba0ced8", "html_url": "https://github.com/rust-lang/rust/commit/5339bd1ebeb76ea7304ff07dcf8e6c317ba0ced8"}], "stats": {"total": 965, "additions": 349, "deletions": 616}, "files": [{"sha": "b76e1e7ce65e00ade7e035f890ba3b9b9e5650aa", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -228,7 +228,7 @@ impl<T> TypedArena<T> {\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n                 new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n-                new_cap = new_cap * 2;\n+                new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n             }\n@@ -346,7 +346,7 @@ impl DroplessArena {\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n                 new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n-                new_cap = new_cap * 2;\n+                new_cap *= 2;\n             } else {\n                 new_cap = PAGE;\n             }\n@@ -562,10 +562,8 @@ impl DropArena {\n         // Record the destructors after doing the allocation as that may panic\n         // and would cause `object`'s destructor to run twice if it was recorded before\n         for i in 0..len {\n-            destructors.push(DropType {\n-                drop_fn: drop_for_type::<T>,\n-                obj: start_ptr.offset(i as isize) as *mut u8,\n-            });\n+            destructors\n+                .push(DropType { drop_fn: drop_for_type::<T>, obj: start_ptr.add(i) as *mut u8 });\n         }\n \n         slice::from_raw_parts_mut(start_ptr, len)"}, {"sha": "599599f415f1c9b988cf15b05ab71ddc80e2b33c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -490,10 +490,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let count = generics\n                             .params\n                             .iter()\n-                            .filter(|param| match param.kind {\n-                                ast::GenericParamKind::Lifetime { .. } => true,\n-                                _ => false,\n-                            })\n+                            .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime { .. }))\n                             .count();\n                         self.lctx.type_def_lifetime_params.insert(def_id.to_def_id(), count);\n                     }"}, {"sha": "e1eed168b31bb94b8d8058aba22cb316f234d1c4", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -262,10 +262,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n         };\n \n-        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n-            GenericArg::Lifetime(_) => true,\n-            _ => false,\n-        });\n+        let has_lifetimes =\n+            generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n         let first_generic_span = generic_args\n             .args\n             .iter()"}, {"sha": "9fcba9024433023ba4fba5d54ba6adb5b3a20a5b", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -639,13 +639,11 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n         if !self.is_beginning_of_line() {\n             self.break_offset(n, off)\n-        } else {\n-            if off != 0 && self.last_token().is_hardbreak_tok() {\n-                // We do something pretty sketchy here: tuck the nonzero\n-                // offset-adjustment we were going to deposit along with the\n-                // break into the previous hardbreak.\n-                self.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n-            }\n+        } else if off != 0 && self.last_token().is_hardbreak_tok() {\n+            // We do something pretty sketchy here: tuck the nonzero\n+            // offset-adjustment we were going to deposit along with the\n+            // break into the previous hardbreak.\n+            self.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n         }\n     }\n "}, {"sha": "48238c8bbf5719123522bc06fab33b5a9f3774a0", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -901,38 +901,36 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         )\n                         .emit();\n                     }\n-                } else {\n-                    if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.has_name(sym::align) {\n-                            if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                                recognised = true;\n-                                let mut err = struct_span_err!(\n-                                    diagnostic,\n-                                    item.span(),\n-                                    E0693,\n-                                    \"incorrect `repr(align)` attribute format\"\n-                                );\n-                                match value.kind {\n-                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                        err.span_suggestion(\n-                                            item.span(),\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", int),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                    ast::LitKind::Str(s, _) => {\n-                                        err.span_suggestion(\n-                                            item.span(),\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", s),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                    _ => {}\n+                } else if let Some(meta_item) = item.meta_item() {\n+                    if meta_item.has_name(sym::align) {\n+                        if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n+                            recognised = true;\n+                            let mut err = struct_span_err!(\n+                                diagnostic,\n+                                item.span(),\n+                                E0693,\n+                                \"incorrect `repr(align)` attribute format\"\n+                            );\n+                            match value.kind {\n+                                ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                    err.span_suggestion(\n+                                        item.span(),\n+                                        \"use parentheses instead\",\n+                                        format!(\"align({})\", int),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                ast::LitKind::Str(s, _) => {\n+                                    err.span_suggestion(\n+                                        item.span(),\n+                                        \"use parentheses instead\",\n+                                        format!(\"align({})\", s),\n+                                        Applicability::MachineApplicable,\n+                                    );\n                                 }\n-                                err.emit();\n+                                _ => {}\n                             }\n+                            err.emit();\n                         }\n                     }\n                 }"}, {"sha": "f7d82ff78fa38ded08094f2b3b4a472cbc0da346", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -93,7 +93,7 @@ pub(crate) unsafe fn codegen(\n     let args = [usize, usize]; // size, align\n \n     let ty = llvm::LLVMFunctionType(void, args.as_ptr(), args.len() as c_uint, False);\n-    let name = format!(\"__rust_alloc_error_handler\");\n+    let name = \"__rust_alloc_error_handler\".to_string();\n     let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n     // -> ! DIFlagNoReturn\n     llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);"}, {"sha": "d856280158f2d5d55d1e724334362aec0b9bb947", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -302,13 +302,11 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             } else if options.contains(InlineAsmOptions::READONLY) {\n                 llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n             }\n+        } else if options.contains(InlineAsmOptions::NOMEM) {\n+            llvm::Attribute::InaccessibleMemOnly\n+                .apply_callsite(llvm::AttributePlace::Function, result);\n         } else {\n-            if options.contains(InlineAsmOptions::NOMEM) {\n-                llvm::Attribute::InaccessibleMemOnly\n-                    .apply_callsite(llvm::AttributePlace::Function, result);\n-            } else {\n-                // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n-            }\n+            // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n         }\n \n         // Write results to outputs"}, {"sha": "64fd1d09cc24f4f42acc5c26bd9e5500da6154e8", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -900,7 +900,7 @@ impl ThinLTOKeysMap {\n         let file = File::open(path)?;\n         for line in io::BufReader::new(file).lines() {\n             let line = line?;\n-            let mut split = line.split(\" \");\n+            let mut split = line.split(' ');\n             let module = split.next().unwrap();\n             let key = split.next().unwrap();\n             assert_eq!(split.next(), None, \"Expected two space-separated values, found {:?}\", line);"}, {"sha": "f122fa14e70be172a4820070b9954172232654eb", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -732,10 +732,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let src_ty = self.cx.val_ty(val);\n         let float_width = self.cx.float_width(src_ty);\n         let int_width = self.cx.int_width(dest_ty);\n-        match (int_width, float_width) {\n-            (32, 32) | (32, 64) | (64, 32) | (64, 64) => true,\n-            _ => false,\n-        }\n+        matches!((int_width, float_width), (32, 32) | (32, 64) | (64, 32) | (64, 64))\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {"}, {"sha": "1672601d36f7a6d619a48b917a2175fa239678cd", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -397,10 +397,8 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n \n             // As an optimization, all shared statics which do not have interior\n             // mutability are placed into read-only memory.\n-            if !is_mutable {\n-                if self.type_is_freeze(ty) {\n-                    llvm::LLVMSetGlobalConstant(g, llvm::True);\n-                }\n+            if !is_mutable && self.type_is_freeze(ty) {\n+                llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n \n             debuginfo::create_global_var_metadata(&self, def_id, g);"}, {"sha": "253e02bd082488184d3dfa7f1298db602e50eb3b", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -122,10 +122,10 @@ pub unsafe fn create_module(\n     if llvm_util::get_major_version() < 9 {\n         target_data_layout = strip_function_ptr_alignment(target_data_layout);\n     }\n-    if llvm_util::get_major_version() < 10 {\n-        if sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\" {\n-            target_data_layout = strip_x86_address_spaces(target_data_layout);\n-        }\n+    if llvm_util::get_major_version() < 10\n+        && (sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\")\n+    {\n+        target_data_layout = strip_x86_address_spaces(target_data_layout);\n     }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n@@ -864,7 +864,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         // user defined names\n         let mut name = String::with_capacity(prefix.len() + 6);\n         name.push_str(prefix);\n-        name.push_str(\".\");\n+        name.push('.');\n         base_n::push_str(idx as u128, base_n::ALPHANUMERIC_ONLY, &mut name);\n         name\n     }"}, {"sha": "6bb93857d71aa5b2384e7c1c7bda1819db417c11", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -435,7 +435,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             name_to_append_suffix_to.push('<');\n             for (i, actual_type) in substs.types().enumerate() {\n                 if i != 0 {\n-                    name_to_append_suffix_to.push_str(\",\");\n+                    name_to_append_suffix_to.push(',');\n                 }\n \n                 let actual_type ="}, {"sha": "486a9ba77b75feb5da7be907db31488fa32545b0", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -307,10 +307,7 @@ where\n     fn walk_unvisited_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n         debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n \n-        debug_assert!(match self.node_states[node] {\n-            NodeState::NotVisited => true,\n-            _ => false,\n-        });\n+        debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n \n         // Push `node` onto the stack.\n         self.node_states[node] = NodeState::BeingVisited { depth };"}, {"sha": "fe8ae7abf982bd78c577c730ff5277155401b74f", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -395,7 +395,7 @@ where\n     V: Copy,\n {\n     fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n-        self.extend(iter.into_iter().map(|(k, v)| (k.clone(), v.clone())))\n+        self.extend(iter.into_iter().map(|(k, v)| (*k, *v)))\n     }\n \n     #[inline]\n@@ -451,7 +451,7 @@ impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n             SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.iter()),\n         }\n     }\n }\n@@ -469,7 +469,7 @@ impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n             SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.iter_mut()),\n         }\n     }\n }"}, {"sha": "f434673c39e10dd4e502d5e764a6926b48f00678", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -716,7 +716,7 @@ impl RustcDefaultCalls {\n                 TargetList => {\n                     let mut targets =\n                         rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n-                    targets.sort();\n+                    targets.sort_unstable();\n                     println!(\"{}\", targets.join(\"\\n\"));\n                 }\n                 Sysroot => println!(\"{}\", sess.sysroot.display()),"}, {"sha": "fbe3588280ad1bc9d718edf8ac8da736d659dfbf", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -136,10 +136,7 @@ impl Emitter for JsonEmitter {\n     }\n \n     fn should_show_explain(&self) -> bool {\n-        match self.json_rendered {\n-            HumanReadableErrorType::Short(_) => false,\n-            _ => true,\n-        }\n+        !matches!(self.json_rendered, HumanReadableErrorType::Short(_))\n     }\n }\n "}, {"sha": "2ebc4a7e9d9236bd480cd1a981e438921b1e9798", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -91,10 +91,7 @@ pub enum SuggestionStyle {\n \n impl SuggestionStyle {\n     fn hide_inline(&self) -> bool {\n-        match *self {\n-            SuggestionStyle::ShowCode => false,\n-            _ => true,\n-        }\n+        !matches!(*self, SuggestionStyle::ShowCode)\n     }\n }\n \n@@ -1038,10 +1035,7 @@ impl Level {\n     }\n \n     pub fn is_failure_note(&self) -> bool {\n-        match *self {\n-            FailureNote => true,\n-            _ => false,\n-        }\n+        matches!(*self, FailureNote)\n     }\n }\n "}, {"sha": "dbb2523f28691c30c4ed8ac22eb615b64006b248", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -158,10 +158,7 @@ impl Annotation {\n \n     pub fn takes_space(&self) -> bool {\n         // Multiline annotations always have to keep vertical space.\n-        match self.annotation_type {\n-            AnnotationType::MultilineStart(_) | AnnotationType::MultilineEnd(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.annotation_type, AnnotationType::MultilineStart(_) | AnnotationType::MultilineEnd(_))\n     }\n }\n "}, {"sha": "eb4aab116f00f7218d031466934bdbe058914e2a", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -102,10 +102,7 @@ impl TokenTree {\n \n     /// Returns `true` if the given token tree is delimited.\n     fn is_delimited(&self) -> bool {\n-        match *self {\n-            TokenTree::Delimited(..) => true,\n-            _ => false,\n-        }\n+        matches!(*self, TokenTree::Delimited(..))\n     }\n \n     /// Returns `true` if the given token tree is a token of the given kind."}, {"sha": "91add4f921844c13b22447b5da74d994eb5c5240", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -134,10 +134,7 @@ enum Stack<'a, T> {\n impl<'a, T> Stack<'a, T> {\n     /// Returns whether a stack is empty.\n     fn is_empty(&self) -> bool {\n-        match *self {\n-            Stack::Empty => true,\n-            _ => false,\n-        }\n+        matches!(*self, Stack::Empty)\n     }\n \n     /// Returns a new stack with an element of top."}, {"sha": "a074af0189a280d65ad073ba5f56505a4a45141a", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -1036,17 +1036,16 @@ fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n fn frag_can_be_followed_by_any(kind: NonterminalKind) -> bool {\n-    match kind {\n+    matches!(\n+        kind,\n         NonterminalKind::Item           // always terminated by `}` or `;`\n         | NonterminalKind::Block        // exactly one token tree\n         | NonterminalKind::Ident        // exactly one token tree\n         | NonterminalKind::Literal      // exactly one token tree\n         | NonterminalKind::Meta         // exactly one token tree\n         | NonterminalKind::Lifetime     // exactly one token tree\n-        | NonterminalKind::TT => true,  // exactly one token tree\n-\n-        _ => false,\n-    }\n+        | NonterminalKind::TT // exactly one token tree\n+    )\n }\n \n enum IsInFollow {"}, {"sha": "1bc14ae41bf29106372e22776ea96705ebff1983", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -345,10 +345,10 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n     fn visit_mod(&mut self, module: &mut ast::Mod) {\n         noop_visit_mod(module, self);\n-        module.items.retain(|item| match item.kind {\n-            ast::ItemKind::MacCall(_) if !self.cx.ecfg.keep_macs => false, // remove macro definitions\n-            _ => true,\n-        });\n+        // remove macro definitions\n+        module.items.retain(\n+            |item| !matches!(item.kind, ast::ItemKind::MacCall(_) if !self.cx.ecfg.keep_macs),\n+        );\n     }\n \n     fn visit_mac(&mut self, _mac: &mut ast::MacCall) {"}, {"sha": "57ae534590ddf69369804a5050d4dfde7333424c", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -83,10 +83,7 @@ impl std::fmt::Debug for AttributeGate {\n \n impl AttributeGate {\n     fn is_deprecated(&self) -> bool {\n-        match *self {\n-            Self::Gated(Stability::Deprecated(_, _), ..) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Self::Gated(Stability::Deprecated(_, _), ..))\n     }\n }\n "}, {"sha": "b9ec18688c5f2ee3622856e7c7547f11af8e54b5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -272,10 +272,7 @@ impl GenericArg<'_> {\n     }\n \n     pub fn is_const(&self) -> bool {\n-        match self {\n-            GenericArg::Const(_) => true,\n-            _ => false,\n-        }\n+        matches!(self, GenericArg::Const(_))\n     }\n \n     pub fn descr(&self) -> &'static str {\n@@ -980,17 +977,11 @@ impl BinOpKind {\n     }\n \n     pub fn is_lazy(self) -> bool {\n-        match self {\n-            BinOpKind::And | BinOpKind::Or => true,\n-            _ => false,\n-        }\n+        matches!(self, BinOpKind::And | BinOpKind::Or)\n     }\n \n     pub fn is_shift(self) -> bool {\n-        match self {\n-            BinOpKind::Shl | BinOpKind::Shr => true,\n-            _ => false,\n-        }\n+        matches!(self, BinOpKind::Shl | BinOpKind::Shr)\n     }\n \n     pub fn is_comparison(self) -> bool {\n@@ -1070,10 +1061,7 @@ impl UnOp {\n \n     /// Returns `true` if the unary operator takes its argument by value.\n     pub fn is_by_value(self) -> bool {\n-        match self {\n-            Self::UnNeg | Self::UnNot => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::UnNeg | Self::UnNot)\n     }\n }\n \n@@ -1409,10 +1397,9 @@ impl Expr<'_> {\n     /// on the given expression should be considered a place expression.\n     pub fn is_place_expr(&self, mut allow_projections_from: impl FnMut(&Self) -> bool) -> bool {\n         match self.kind {\n-            ExprKind::Path(QPath::Resolved(_, ref path)) => match path.res {\n-                Res::Local(..) | Res::Def(DefKind::Static, _) | Res::Err => true,\n-                _ => false,\n-            },\n+            ExprKind::Path(QPath::Resolved(_, ref path)) => {\n+                matches!(path.res, Res::Local(..) | Res::Def(DefKind::Static, _) | Res::Err)\n+            }\n \n             // Type ascription inherits its place expression kind from its\n             // operand. See:\n@@ -2204,10 +2191,7 @@ pub enum ImplicitSelfKind {\n impl ImplicitSelfKind {\n     /// Does this represent an implicit self?\n     pub fn has_implicit_self(&self) -> bool {\n-        match *self {\n-            ImplicitSelfKind::None => false,\n-            _ => true,\n-        }\n+        !matches!(*self, ImplicitSelfKind::None)\n     }\n }\n \n@@ -2237,10 +2221,7 @@ impl Defaultness {\n     }\n \n     pub fn is_default(&self) -> bool {\n-        match *self {\n-            Defaultness::Default { .. } => true,\n-            _ => false,\n-        }\n+        matches!(*self, Defaultness::Default { .. })\n     }\n }\n \n@@ -2371,10 +2352,7 @@ pub enum VisibilityKind<'hir> {\n \n impl VisibilityKind<'_> {\n     pub fn is_pub(&self) -> bool {\n-        match *self {\n-            VisibilityKind::Public => true,\n-            _ => false,\n-        }\n+        matches!(*self, VisibilityKind::Public)\n     }\n \n     pub fn is_pub_restricted(&self) -> bool {\n@@ -2502,10 +2480,7 @@ pub struct FnHeader {\n \n impl FnHeader {\n     pub fn is_const(&self) -> bool {\n-        match &self.constness {\n-            Constness::Const => true,\n-            _ => false,\n-        }\n+        matches!(&self.constness, Constness::Const)\n     }\n }\n "}, {"sha": "9e0a6aae24272a28667905eeb3c07a9402b9f861", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -92,10 +92,7 @@ impl hir::Pat<'_> {\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        self.satisfies(|p| match p.kind {\n-            PatKind::Binding(..) => true,\n-            _ => false,\n-        })\n+        self.satisfies(|p| matches!(p.kind, PatKind::Binding(..)))\n     }\n \n     /// Checks if the pattern satisfies the given predicate on some sub-pattern."}, {"sha": "f7018ae62aa198b7e060a23c11acd5050f94ad23", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -299,13 +299,11 @@ impl<'a> State<'a> {\n     pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n         if !self.s.is_beginning_of_line() {\n             self.s.break_offset(n, off)\n-        } else {\n-            if off != 0 && self.s.last_token().is_hardbreak_tok() {\n-                // We do something pretty sketchy here: tuck the nonzero\n-                // offset-adjustment we were going to deposit along with the\n-                // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n-            }\n+        } else if off != 0 && self.s.last_token().is_hardbreak_tok() {\n+            // We do something pretty sketchy here: tuck the nonzero\n+            // offset-adjustment we were going to deposit along with the\n+            // break into the previous hardbreak.\n+            self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n         }\n     }\n \n@@ -1921,10 +1919,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n-                let is_range_inner = match inner.kind {\n-                    PatKind::Range(..) => true,\n-                    _ => false,\n-                };\n+                let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.s.word(\"box \");\n                 if is_range_inner {\n                     self.popen();\n@@ -1935,10 +1930,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let is_range_inner = match inner.kind {\n-                    PatKind::Range(..) => true,\n-                    _ => false,\n-                };\n+                let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.s.word(\"&\");\n                 self.s.word(mutbl.prefix_str());\n                 if is_range_inner {\n@@ -2435,10 +2427,7 @@ impl<'a> State<'a> {\n //\n // Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr<'_>) -> bool {\n-    match e.kind {\n-        hir::ExprKind::Match(..) | hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) => false,\n-        _ => true,\n-    }\n+    !matches!(e.kind, hir::ExprKind::Match(..) | hir::ExprKind::Block(..) | hir::ExprKind::Loop(..))\n }\n \n /// This statement requires a semicolon after it."}, {"sha": "6539419aefb27aaf32a8943b9f7dcfc7386e17c3", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -238,9 +238,10 @@ pub fn is_whitespace(c: char) -> bool {\n     // Note that this set is stable (ie, it doesn't change with different\n     // Unicode versions), so it's ok to just hard-code the values.\n \n-    match c {\n+    matches!(\n+        c,\n         // Usual ASCII suspects\n-        | '\\u{0009}' // \\t\n+        '\\u{0009}'   // \\t\n         | '\\u{000A}' // \\n\n         | '\\u{000B}' // vertical tab\n         | '\\u{000C}' // form feed\n@@ -257,9 +258,7 @@ pub fn is_whitespace(c: char) -> bool {\n         // Dedicated whitespace characters from Unicode\n         | '\\u{2028}' // LINE SEPARATOR\n         | '\\u{2029}' // PARAGRAPH SEPARATOR\n-        => true,\n-        _ => false,\n-    }\n+    )\n }\n \n /// True if `c` is valid as a first character of an identifier."}, {"sha": "7e029aa7a1928afc2be1ed84dcec1f78942fb294", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -1369,10 +1369,9 @@ impl TypeAliasBounds {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n                 match ty.kind {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => match path.res {\n-                        Res::Def(DefKind::TyParam, _) => true,\n-                        _ => false,\n-                    },\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n+                        matches!(path.res, Res::Def(DefKind::TyParam, _))\n+                    }\n                     _ => false,\n                 }\n             }\n@@ -2381,10 +2380,9 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         return Some(InitKind::Zeroed);\n                     } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n                         return Some(InitKind::Uninit);\n-                    } else if cx.tcx.is_diagnostic_item(sym::transmute, def_id) {\n-                        if is_zero(&args[0]) {\n-                            return Some(InitKind::Zeroed);\n-                        }\n+                    } else if cx.tcx.is_diagnostic_item(sym::transmute, def_id) && is_zero(&args[0])\n+                    {\n+                        return Some(InitKind::Zeroed);\n                     }\n                 }\n             } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n@@ -2880,7 +2878,7 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n     fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, this_fi: &hir::ForeignItem<'_>) {\n         trace!(\"ClashingExternDeclarations: check_foreign_item: {:?}\", this_fi);\n         if let ForeignItemKind::Fn(..) = this_fi.kind {\n-            let tcx = *&cx.tcx;\n+            let tcx = cx.tcx;\n             if let Some(existing_hid) = self.insert(tcx, this_fi) {\n                 let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n                 let this_decl_ty = tcx.type_of(tcx.hir().local_def_id(this_fi.hir_id));"}, {"sha": "f117ce1f80544576f45b846492b6686980b69d1c", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -320,7 +320,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n                                             .with_hi(lit.span.hi() - BytePos(right as u32)),\n                                     )\n                                 })\n-                                .unwrap_or_else(|| lit.span);\n+                                .unwrap_or(lit.span);\n \n                             Some(Ident::new(name, sp))\n                         } else {"}, {"sha": "32611fef1faf0b570453287dcfd653578790f4ab", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -544,15 +544,15 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n         }\n \n         fn is_comparison(binop: hir::BinOp) -> bool {\n-            match binop.node {\n+            matches!(\n+                binop.node,\n                 hir::BinOpKind::Eq\n-                | hir::BinOpKind::Lt\n-                | hir::BinOpKind::Le\n-                | hir::BinOpKind::Ne\n-                | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt => true,\n-                _ => false,\n-            }\n+                    | hir::BinOpKind::Lt\n+                    | hir::BinOpKind::Le\n+                    | hir::BinOpKind::Ne\n+                    | hir::BinOpKind::Ge\n+                    | hir::BinOpKind::Gt\n+            )\n         }\n     }\n }\n@@ -1233,15 +1233,10 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn is_internal_abi(&self, abi: SpecAbi) -> bool {\n-        if let SpecAbi::Rust\n-        | SpecAbi::RustCall\n-        | SpecAbi::RustIntrinsic\n-        | SpecAbi::PlatformIntrinsic = abi\n-        {\n-            true\n-        } else {\n-            false\n-        }\n+        matches!(\n+            abi,\n+            SpecAbi::Rust | SpecAbi::RustCall | SpecAbi::RustIntrinsic | SpecAbi::PlatformIntrinsic\n+        )\n     }\n }\n "}, {"sha": "4bbc180b226a59ed104dc31f4f7f37f4f6498ed3", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -752,14 +752,11 @@ impl UnusedDelimLint for UnusedParens {\n                     && value.attrs.is_empty()\n                     && !value.span.from_expansion()\n                     && (ctx != UnusedDelimsCtx::LetScrutineeExpr\n-                        || match inner.kind {\n-                            ast::ExprKind::Binary(\n+                        || !matches!(inner.kind, ast::ExprKind::Binary(\n                                 rustc_span::source_map::Spanned { node, .. },\n                                 _,\n                                 _,\n-                            ) if node.lazy() => false,\n-                            _ => true,\n-                        })\n+                            ) if node.lazy()))\n                 {\n                     self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n                 }"}, {"sha": "33cbf0fb2345e0f34771e662422602cda74b88a6", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -752,10 +752,7 @@ impl<'a> CrateLoader<'a> {\n         // At this point we've determined that we need an allocator. Let's see\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n-        let all_rlib = self.sess.crate_types().iter().all(|ct| match *ct {\n-            CrateType::Rlib => true,\n-            _ => false,\n-        });\n+        let all_rlib = self.sess.crate_types().iter().all(|ct| matches!(*ct, CrateType::Rlib));\n         if all_rlib {\n             return;\n         }"}, {"sha": "d16985b9c2b3fbc69ba3373dfc86edc3e2e2732e", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -633,11 +633,9 @@ impl<'a> CrateLocator<'a> {\n             }\n         }\n \n-        if self.exact_paths.is_empty() {\n-            if self.crate_name != root.name() {\n-                info!(\"Rejecting via crate name\");\n-                return None;\n-            }\n+        if self.exact_paths.is_empty() && self.crate_name != root.name() {\n+            info!(\"Rejecting via crate name\");\n+            return None;\n         }\n \n         if root.triple() != &self.triple {"}, {"sha": "b5fb850e92e6d4e76a27050485eec88459104725", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -220,10 +220,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n     missing_extern_crate_item => {\n-        let r = match *cdata.extern_crate.borrow() {\n-            Some(extern_crate) if !extern_crate.is_direct() => true,\n-            _ => false,\n-        };\n+        let r = matches!(*cdata.extern_crate.borrow(), Some(extern_crate) if !extern_crate.is_direct());\n         r\n     }\n \n@@ -254,9 +251,11 @@ pub fn provide(providers: &mut Providers) {\n             }\n             _ => false,\n         },\n-        is_statically_included_foreign_item: |tcx, id| match tcx.native_library_kind(id) {\n-            Some(NativeLibKind::StaticBundle | NativeLibKind::StaticNoBundle) => true,\n-            _ => false,\n+        is_statically_included_foreign_item: |tcx, id| {\n+            matches!(\n+                tcx.native_library_kind(id),\n+                Some(NativeLibKind::StaticBundle | NativeLibKind::StaticNoBundle)\n+            )\n         },\n         native_library_kind: |tcx, id| {\n             tcx.native_libraries(id.krate)"}, {"sha": "b94346fa439119e4a2f83595c1aa62260e7eb6d3", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -262,10 +262,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::Call { .. } => {\n                 // these are not places, so we need to make a temporary.\n-                debug_assert!(match Category::of(&expr.kind) {\n-                    Some(Category::Place) => false,\n-                    _ => true,\n-                });\n+                debug_assert!(!matches!(Category::of(&expr.kind), Some(Category::Place)));\n                 let temp =\n                     unpack!(block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n                 block.and(PlaceBuilder::from(temp))"}, {"sha": "2853bf887faaf4fa7b4f8f3857c5421f68abbbf6", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -260,10 +260,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::ValueTypeAscription { .. } => {\n                 // these do not have corresponding `Rvalue` variants,\n                 // so make an operand and then return that\n-                debug_assert!(match Category::of(&expr.kind) {\n-                    Some(Category::Rvalue(RvalueFunc::AsRvalue)) => false,\n-                    _ => true,\n-                });\n+                debug_assert!(!matches!(Category::of(&expr.kind), Some(Category::Rvalue(RvalueFunc::AsRvalue))));\n                 let operand = unpack!(block = this.as_operand(block, scope, expr));\n                 block.and(Rvalue::Use(operand))\n             }"}, {"sha": "9dc596a345fe1a556e3106739401c8b87cd9b711", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -58,10 +58,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);\n-                let is_call = match source.kind {\n-                    ExprKind::Call { .. } | ExprKind::InlineAsm { .. } => true,\n-                    _ => false,\n-                };\n+                let is_call = matches!(source.kind, ExprKind::Call { .. } | ExprKind::InlineAsm { .. });\n \n                 // (#66975) Source could be a const of type `!`, so has to\n                 // exist in the generated MIR."}, {"sha": "7bea8220ada7486e189d1a8f16e77bda12885a85", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -250,15 +250,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         place,\n                         ty,\n                     );\n+                } else if let [success, fail] = *make_target_blocks(self) {\n+                    assert_eq!(value.ty, ty);\n+                    let expect = self.literal_operand(test.span, value);\n+                    let val = Operand::Copy(place);\n+                    self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                 } else {\n-                    if let [success, fail] = *make_target_blocks(self) {\n-                        assert_eq!(value.ty, ty);\n-                        let expect = self.literal_operand(test.span, value);\n-                        let val = Operand::Copy(place);\n-                        self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n-                    } else {\n-                        bug!(\"`TestKind::Eq` should have two target blocks\");\n-                    }\n+                    bug!(\"`TestKind::Eq` should have two target blocks\");\n                 }\n             }\n "}, {"sha": "e91227d8357de4cf8c226d32021a48219c414175", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -331,13 +331,11 @@ impl DropTree {\n             }\n             if let DropKind::Value = drop_data.0.kind {\n                 needs_block[drop_data.1] = Block::Own;\n-            } else {\n-                if drop_idx != ROOT_NODE {\n-                    match &mut needs_block[drop_data.1] {\n-                        pred @ Block::None => *pred = Block::Shares(drop_idx),\n-                        pred @ Block::Shares(_) => *pred = Block::Own,\n-                        Block::Own => (),\n-                    }\n+            } else if drop_idx != ROOT_NODE {\n+                match &mut needs_block[drop_data.1] {\n+                    pred @ Block::None => *pred = Block::Shares(drop_idx),\n+                    pred @ Block::Shares(_) => *pred = Block::Own,\n+                    Block::Own => (),\n                 }\n             }\n         }\n@@ -461,9 +459,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n         let break_block = self.build_exit_tree(breakable_scope.break_drops, None);\n-        breakable_scope.continue_drops.map(|drops| {\n-            self.build_exit_tree(drops, loop_block);\n-        });\n+        if let Some(drops) = breakable_scope.continue_drops { self.build_exit_tree(drops, loop_block); }\n         match (normal_exit_block, break_block) {\n             (Some(block), None) | (None, Some(block)) => block,\n             (None, None) => self.cfg.start_new_block().unit(),"}, {"sha": "6ed7ed575fcb525649e7b2a4ceada9b28ba85226", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -316,16 +316,14 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n-            } else {\n-                if let hir::ExprKind::Lit(ref lit) = arg.kind {\n-                    ExprKind::Literal {\n-                        literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n-                        user_ty: None,\n-                        const_id: None,\n-                    }\n-                } else {\n-                    ExprKind::Unary { op: UnOp::Neg, arg: arg.to_ref() }\n+            } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n+                ExprKind::Literal {\n+                    literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                    user_ty: None,\n+                    const_id: None,\n                 }\n+            } else {\n+                ExprKind::Unary { op: UnOp::Neg, arg: arg.to_ref() }\n             }\n         }\n "}, {"sha": "2da5ae574bbea05ad1fcd529f410ad2756212d43", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -337,10 +337,7 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n \n impl<'tcx> Pat<'tcx> {\n     pub(super) fn is_wildcard(&self) -> bool {\n-        match *self.kind {\n-            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => true,\n-            _ => false,\n-        }\n+        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n     }\n }\n \n@@ -1358,10 +1355,7 @@ impl<'tcx> Usefulness<'tcx> {\n     }\n \n     fn is_useful(&self) -> bool {\n-        match *self {\n-            NotUseful => false,\n-            _ => true,\n-        }\n+        !matches!(*self, NotUseful)\n     }\n \n     fn apply_constructor<'p>(\n@@ -1623,10 +1617,7 @@ struct IntRange<'tcx> {\n impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n-        match ty.kind() {\n-            ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool => true,\n-            _ => false,\n-        }\n+        matches!(ty.kind(), ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool)\n     }\n \n     fn is_singleton(&self) -> bool {"}, {"sha": "3c746ac515393a43b608b25fcaa57d70a6f3c2d7", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -223,10 +223,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n                     BindingMode::ByRef(bk) => {\n                         write!(f, \"ref \")?;\n-                        match bk {\n-                            BorrowKind::Mut { .. } => true,\n-                            _ => false,\n-                        }\n+                        matches!(bk, BorrowKind::Mut { .. })\n                     }\n                 };\n                 if is_mut {"}, {"sha": "5c404161004a4c73338db48f66d10c05014cabe4", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -606,7 +606,7 @@ fn prepend_attrs(\n ) -> Option<tokenstream::TokenStream> {\n     let tokens = tokens?.clone().into_token_stream();\n     if attrs.is_empty() {\n-        return Some(tokens.clone());\n+        return Some(tokens);\n     }\n     let mut builder = tokenstream::TokenStreamBuilder::new();\n     for attr in attrs {\n@@ -622,6 +622,6 @@ fn prepend_attrs(\n                 .into_token_stream(),\n         );\n     }\n-    builder.push(tokens.clone());\n+    builder.push(tokens);\n     Some(builder.build())\n }"}, {"sha": "cd3b8db2303b366a65d5a99d5e38876ad33d255b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -1359,11 +1359,7 @@ impl<'a> Parser<'a> {\n         (self.token == token::Lt && // `foo:<bar`, likely a typoed turbofish.\n             self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident()))\n             || self.token.is_ident() &&\n-            match node {\n-                // `foo::` \u2192 `foo:` or `foo.bar::` \u2192 `foo.bar:`\n-                ast::ExprKind::Path(..) | ast::ExprKind::Field(..) => true,\n-                _ => false,\n-            } &&\n+            matches!(node, ast::ExprKind::Path(..) | ast::ExprKind::Field(..)) &&\n             !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n             self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren))\n             || self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace)) // `foo:bar {`"}, {"sha": "48a635844fe705ada863233b4cb17ad53828d9d6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -376,21 +376,19 @@ impl<'a> Parser<'a> {\n                     format!(\" {} \", kw),\n                     Applicability::MachineApplicable,\n                 );\n+            } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                err.span_suggestion(\n+                    full_sp,\n+                    \"if you meant to call a macro, try\",\n+                    format!(\"{}!\", snippet),\n+                    // this is the `ambiguous` conditional branch\n+                    Applicability::MaybeIncorrect,\n+                );\n             } else {\n-                if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                    err.span_suggestion(\n-                        full_sp,\n-                        \"if you meant to call a macro, try\",\n-                        format!(\"{}!\", snippet),\n-                        // this is the `ambiguous` conditional branch\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    err.help(\n-                        \"if you meant to call a macro, remove the `pub` \\\n-                                  and add a trailing `!` after the identifier\",\n-                    );\n-                }\n+                err.help(\n+                    \"if you meant to call a macro, remove the `pub` \\\n+                              and add a trailing `!` after the identifier\",\n+                );\n             }\n             Err(err)\n         } else if self.look_ahead(1, |t| *t == token::Lt) {\n@@ -982,10 +980,7 @@ impl<'a> Parser<'a> {\n                 if token.is_keyword(kw::Move) {\n                     return true;\n                 }\n-                match token.kind {\n-                    token::BinOp(token::Or) | token::OrOr => true,\n-                    _ => false,\n-                }\n+                matches!(token.kind, token::BinOp(token::Or) | token::OrOr)\n             })\n         } else {\n             false"}, {"sha": "ab88362dad954900d4fcebe748048a63fb569ce5", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -38,16 +38,13 @@ impl<'a> Parser<'a> {\n             },\n             NonterminalKind::Block => match token.kind {\n                 token::OpenDelim(token::Brace) => true,\n-                token::Interpolated(ref nt) => match **nt {\n-                    token::NtItem(_)\n+                token::Interpolated(ref nt) => !matches!(**nt, token::NtItem(_)\n                     | token::NtPat(_)\n                     | token::NtTy(_)\n                     | token::NtIdent(..)\n                     | token::NtMeta(_)\n                     | token::NtPath(_)\n-                    | token::NtVis(_) => false, // none of these may start with '{'.\n-                    _ => true,\n-                },\n+                    | token::NtVis(_)),\n                 _ => false,\n             },\n             NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n@@ -76,17 +73,14 @@ impl<'a> Parser<'a> {\n             },\n             NonterminalKind::Lifetime => match token.kind {\n                 token::Lifetime(_) => true,\n-                token::Interpolated(ref nt) => match **nt {\n-                    token::NtLifetime(_) | token::NtTT(_) => true,\n-                    _ => false,\n-                },\n+                token::Interpolated(ref nt) => {\n+                    matches!(**nt, token::NtLifetime(_) | token::NtTT(_))\n+                }\n                 _ => false,\n             },\n-            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => match token.kind\n-            {\n-                token::CloseDelim(_) => false,\n-                _ => true,\n-            },\n+            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => {\n+                !matches!(token.kind, token::CloseDelim(_))\n+            }\n         }\n     }\n "}, {"sha": "196790a0ab3236bdb2d771e18e6257cb650ff427", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -149,17 +149,19 @@ impl<'a> Parser<'a> {\n     /// Note that there are more tokens such as `@` for which we know that the `|`\n     /// is an illegal parse. However, the user's intent is less clear in that case.\n     fn recover_trailing_vert(&mut self, lo: Option<Span>) -> bool {\n-        let is_end_ahead = self.look_ahead(1, |token| match &token.uninterpolate().kind {\n-            token::FatArrow // e.g. `a | => 0,`.\n+        let is_end_ahead = self.look_ahead(1, |token| {\n+            matches!(\n+                &token.uninterpolate().kind,\n+                token::FatArrow // e.g. `a | => 0,`.\n             | token::Ident(kw::If, false) // e.g. `a | if expr`.\n             | token::Eq // e.g. `let a | = 0`.\n             | token::Semi // e.g. `let a |;`.\n             | token::Colon // e.g. `let a | :`.\n             | token::Comma // e.g. `let (a |,)`.\n             | token::CloseDelim(token::Bracket) // e.g. `let [a | ]`.\n             | token::CloseDelim(token::Paren) // e.g. `let (a | )`.\n-            | token::CloseDelim(token::Brace) => true, // e.g. `let A { f: a | }`.\n-            _ => false,\n+            | token::CloseDelim(token::Brace) // e.g. `let A { f: a | }`.\n+            )\n         });\n         match (is_end_ahead, &self.token.kind) {\n             (true, token::BinOp(token::Or) | token::OrOr) => {\n@@ -766,14 +768,12 @@ impl<'a> Parser<'a> {\n         && !self.token.is_path_segment_keyword() // Avoid e.g. `Self` as it is a path.\n         // Avoid `in`. Due to recovery in the list parser this messes with `for ( $pat in $expr )`.\n         && !self.token.is_keyword(kw::In)\n-        && self.look_ahead(1, |t| match t.kind { // Try to do something more complex?\n-            token::OpenDelim(token::Paren) // A tuple struct pattern.\n+        // Try to do something more complex?\n+        && self.look_ahead(1, |t| !matches!(t.kind, token::OpenDelim(token::Paren) // A tuple struct pattern.\n             | token::OpenDelim(token::Brace) // A struct pattern.\n             | token::DotDotDot | token::DotDotEq | token::DotDot // A range pattern.\n             | token::ModSep // A tuple / struct variant pattern.\n-            | token::Not => false, // A macro expanding to a pattern.\n-            _ => true,\n-        })\n+            | token::Not)) // A macro expanding to a pattern.\n     }\n \n     /// Parses `ident` or `ident @ pat`."}, {"sha": "79e737490386c023eaa1d6842ffce0f4fafcca63", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -187,12 +187,14 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n         let ident = self.parse_path_segment_ident()?;\n \n-        let is_args_start = |token: &Token| match token.kind {\n-            token::Lt\n-            | token::BinOp(token::Shl)\n-            | token::OpenDelim(token::Paren)\n-            | token::LArrow => true,\n-            _ => false,\n+        let is_args_start = |token: &Token| {\n+            matches!(\n+                token.kind,\n+                token::Lt\n+                    | token::BinOp(token::Shl)\n+                    | token::OpenDelim(token::Paren)\n+                    | token::LArrow\n+            )\n         };\n         let check_args_start = |this: &mut Self| {\n             this.expected_tokens.extend_from_slice(&["}, {"sha": "fb0b50d1c248a71835ea9c83bc8f9e1a315c554f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -1219,9 +1219,11 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 .maybe_typeck_results\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id)),\n         };\n-        let def = def.filter(|(kind, _)| match kind {\n-            DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n-            _ => false,\n+        let def = def.filter(|(kind, _)| {\n+            matches!(\n+                kind,\n+                DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static\n+            )\n         });\n         if let Some((kind, def_id)) = def {\n             let is_local_static ="}, {"sha": "d9b687c48af01bb0feb29c075bc2ad3e9c6bc655", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -292,10 +292,8 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-            } else {\n-                if print_status {\n-                    eprintln!(\"[task::new] {:?}\", key);\n-                }\n+            } else if print_status {\n+                eprintln!(\"[task::new] {:?}\", key);\n             }\n \n             (result, dep_node_index)"}, {"sha": "426f5bb41d6f23b7532d5dfe8a564a898383bd80", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -612,10 +612,8 @@ where\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-    if unlikely!(!diagnostics.is_empty()) {\n-        if dep_node.kind != DepKind::NULL {\n-            tcx.store_diagnostics(dep_node_index, diagnostics);\n-        }\n+    if unlikely!(!diagnostics.is_empty()) && dep_node.kind != DepKind::NULL {\n+        tcx.store_diagnostics(dep_node_index, diagnostics);\n     }\n \n     let result = job.complete(result, dep_node_index);"}, {"sha": "d2d2a79374e22be272aecc66c694d7b990271bb1", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -344,10 +344,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n-        block.stmts.iter().any(|statement| match statement.kind {\n-            StmtKind::Item(_) | StmtKind::MacCall(_) => true,\n-            _ => false,\n-        })\n+        block\n+            .stmts\n+            .iter()\n+            .any(|statement| matches!(statement.kind, StmtKind::Item(_) | StmtKind::MacCall(_)))\n     }\n \n     // Add an import to the current module."}, {"sha": "4e115c62c9ef894057525eb60ee3505b6ee155e4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -922,15 +922,10 @@ impl<'a> Resolver<'a> {\n         );\n         self.add_typo_suggestion(err, suggestion, ident.span);\n \n-        let import_suggestions = self.lookup_import_candidates(\n-            ident,\n-            Namespace::MacroNS,\n-            parent_scope,\n-            |res| match res {\n-                Res::Def(DefKind::Macro(MacroKind::Bang), _) => true,\n-                _ => false,\n-            },\n-        );\n+        let import_suggestions =\n+            self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, |res| {\n+                matches!(res, Res::Def(DefKind::Macro(MacroKind::Bang), _))\n+            });\n         show_candidates(err, None, &import_suggestions, false, true);\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n@@ -1010,11 +1005,9 @@ impl<'a> Resolver<'a> {\n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         let res = b.res();\n         if b.span.is_dummy() {\n-            let add_built_in = match b.res() {\n-                // These already contain the \"built-in\" prefix or look bad with it.\n-                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n-                _ => true,\n-            };\n+            // These already contain the \"built-in\" prefix or look bad with it.\n+            let add_built_in =\n+                !matches!(b.res(), Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod);\n             let (built_in, from) = if from_prelude {\n                 (\"\", \" from prelude\")\n             } else if b.is_extern_crate()\n@@ -1610,10 +1603,7 @@ fn find_span_immediately_after_crate_name(\n         if *c == ':' {\n             num_colons += 1;\n         }\n-        match c {\n-            ':' if num_colons == 2 => false,\n-            _ => true,\n-        }\n+        !matches!(c, ':' if num_colons == 2)\n     });\n     // Find everything after the second colon.. `foo::{baz, makro};`\n     let from_second_colon = use_span.with_lo(until_second_colon.hi() + BytePos(1));"}, {"sha": "269d25be0a569c197aaecbdd325434e8cff038d5", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -114,10 +114,7 @@ crate struct Import<'a> {\n \n impl<'a> Import<'a> {\n     pub fn is_glob(&self) -> bool {\n-        match self.kind {\n-            ImportKind::Glob { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, ImportKind::Glob { .. })\n     }\n \n     pub fn is_nested(&self) -> bool {\n@@ -898,12 +895,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let msg = \"inconsistent resolution for an import\";\n                         self.r.session.span_err(import.span, msg);\n                     }\n-                } else {\n-                    if self.r.privacy_errors.is_empty() {\n-                        let msg = \"cannot determine resolution for the import\";\n-                        let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n-                    }\n+                } else if self.r.privacy_errors.is_empty() {\n+                    let msg = \"cannot determine resolution for the import\";\n+                    let msg_note = \"import resolution is stuck, try simplifying other imports\";\n+                    self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n@@ -1044,19 +1039,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n                                 span_bug!(import.span, \"inconsistent resolution for an import\");\n                             }\n-                        } else {\n-                            if res != Res::Err\n-                                && this.ambiguity_errors.is_empty()\n-                                && this.privacy_errors.is_empty()\n-                            {\n-                                let msg = \"cannot determine resolution for the import\";\n-                                let msg_note =\n-                                    \"import resolution is stuck, try simplifying other imports\";\n-                                this.session\n-                                    .struct_span_err(import.span, msg)\n-                                    .note(msg_note)\n-                                    .emit();\n-                            }\n+                        } else if res != Res::Err\n+                            && this.ambiguity_errors.is_empty()\n+                            && this.privacy_errors.is_empty()\n+                        {\n+                            let msg = \"cannot determine resolution for the import\";\n+                            let msg_note =\n+                                \"import resolution is stuck, try simplifying other imports\";\n+                            this.session.struct_span_err(import.span, msg).note(msg_note).emit();\n                         }\n                     }\n                     Err(..) => {"}, {"sha": "8d99d8f2455b8ad8d9450874359cf87bf7bd34c6", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -257,16 +257,12 @@ impl<'a> PathSource<'a> {\n     }\n \n     fn is_call(self) -> bool {\n-        match self {\n-            PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })) => true,\n-            _ => false,\n-        }\n+        matches!(self, PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })))\n     }\n \n     crate fn is_expected(self, res: Res) -> bool {\n         match self {\n-            PathSource::Type => match res {\n-                Res::Def(\n+            PathSource::Type => matches!(res, Res::Def(\n                     DefKind::Struct\n                     | DefKind::Union\n                     | DefKind::Enum\n@@ -280,19 +276,12 @@ impl<'a> PathSource<'a> {\n                     _,\n                 )\n                 | Res::PrimTy(..)\n-                | Res::SelfTy(..) => true,\n-                _ => false,\n-            },\n-            PathSource::Trait(AliasPossibility::No) => match res {\n-                Res::Def(DefKind::Trait, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Trait(AliasPossibility::Maybe) => match res {\n-                Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Expr(..) => match res {\n-                Res::Def(\n+                | Res::SelfTy(..)),\n+            PathSource::Trait(AliasPossibility::No) => matches!(res, Res::Def(DefKind::Trait, _)),\n+            PathSource::Trait(AliasPossibility::Maybe) => {\n+                matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n+            }\n+            PathSource::Expr(..) => matches!(res, Res::Def(\n                     DefKind::Ctor(_, CtorKind::Const | CtorKind::Fn)\n                     | DefKind::Const\n                     | DefKind::Static\n@@ -303,33 +292,24 @@ impl<'a> PathSource<'a> {\n                     _,\n                 )\n                 | Res::Local(..)\n-                | Res::SelfCtor(..) => true,\n-                _ => false,\n-            },\n-            PathSource::Pat => match res {\n-                Res::Def(\n+                | Res::SelfCtor(..)),\n+            PathSource::Pat => matches!(res, Res::Def(\n                     DefKind::Ctor(_, CtorKind::Const) | DefKind::Const | DefKind::AssocConst,\n                     _,\n                 )\n-                | Res::SelfCtor(..) => true,\n-                _ => false,\n-            },\n-            PathSource::TupleStruct(..) => match res {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..) => true,\n-                _ => false,\n-            },\n-            PathSource::Struct => match res {\n-                Res::Def(\n+                | Res::SelfCtor(..)),\n+            PathSource::TupleStruct(..) => {\n+                matches!(res, Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..))\n+            }\n+            PathSource::Struct => matches!(res, Res::Def(\n                     DefKind::Struct\n                     | DefKind::Union\n                     | DefKind::Variant\n                     | DefKind::TyAlias\n                     | DefKind::AssocTy,\n                     _,\n                 )\n-                | Res::SelfTy(..) => true,\n-                _ => false,\n-            },\n+                | Res::SelfTy(..)),\n             PathSource::TraitItem(ns) => match res {\n                 Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) if ns == ValueNS => true,\n                 Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n@@ -1450,10 +1430,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn is_base_res_local(&self, nid: NodeId) -> bool {\n-        match self.r.partial_res_map.get(&nid).map(|res| res.base_res()) {\n-            Some(Res::Local(..)) => true,\n-            _ => false,\n-        }\n+        matches!(self.r.partial_res_map.get(&nid).map(|res| res.base_res()), Some(Res::Local(..)))\n     }\n \n     /// Checks that all of the arms in an or-pattern have exactly the"}, {"sha": "7b355f7238f0e25da2b7d378a52da6a9c3abf12b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -702,10 +702,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 _ => break,\n             }\n         }\n-        let followed_by_brace = match sm.span_to_snippet(sp) {\n-            Ok(ref snippet) if snippet == \"{\" => true,\n-            _ => false,\n-        };\n+        let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n         // by parentheses, find the appropriate span.\n         let mut i = 0;\n@@ -1788,12 +1785,11 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         }\n                         msg = \"consider introducing a named lifetime parameter\".to_string();\n                         should_break = true;\n-                        if let Some(param) = generics.params.iter().find(|p| match p.kind {\n-                            hir::GenericParamKind::Type {\n+                        if let Some(param) = generics.params.iter().find(|p| {\n+                            !matches!(p.kind, hir::GenericParamKind::Type {\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n                                 ..\n-                            } => false,\n-                            _ => true,\n+                            })\n                         }) {\n                             (param.span.shrink_to_lo(), \"'a, \".to_string())\n                         } else {"}, {"sha": "c79d670737edd163356c0f7add862bd643459ec1", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -351,10 +351,7 @@ fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n /// We have to account for this when computing the index of the other generic parameters.\n /// This function returns whether there is such an implicit parameter defined on the given item.\n fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n-    match *node {\n-        hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => true,\n-        _ => false,\n-    }\n+    matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n@@ -417,10 +414,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n-                let track_lifetime_uses = match item.kind {\n-                    hir::ItemKind::Impl { .. } => true,\n-                    _ => false,\n-                };\n+                let track_lifetime_uses = matches!(item.kind, hir::ItemKind::Impl { .. });\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let mut index = if sub_items_have_self_param(&item.kind) {\n                     1 // Self comes before lifetimes\n@@ -970,10 +964,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let trait_ref_hack = take(&mut self.trait_ref_hack);\n         if !trait_ref_hack\n-            || trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => true,\n-                _ => false,\n-            })\n+            || trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .any(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n         {\n             if trait_ref_hack {\n                 struct_span_err!(\n@@ -1384,18 +1378,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n                 if in_band {\n                     Some(param.span)\n+                } else if generics.params.len() == 1 {\n+                    // if sole lifetime, remove the entire `<>` brackets\n+                    Some(generics.span)\n                 } else {\n-                    if generics.params.len() == 1 {\n-                        // if sole lifetime, remove the entire `<>` brackets\n-                        Some(generics.span)\n+                    // if removing within `<>` brackets, we also want to\n+                    // delete a leading or trailing comma as appropriate\n+                    if i >= generics.params.len() - 1 {\n+                        Some(generics.params[i - 1].span.shrink_to_hi().to(param.span))\n                     } else {\n-                        // if removing within `<>` brackets, we also want to\n-                        // delete a leading or trailing comma as appropriate\n-                        if i >= generics.params.len() - 1 {\n-                            Some(generics.params[i - 1].span.shrink_to_hi().to(param.span))\n-                        } else {\n-                            Some(param.span.to(generics.params[i + 1].span.shrink_to_lo()))\n-                        }\n+                        Some(param.span.to(generics.params[i + 1].span.shrink_to_lo()))\n                     }\n                 }\n             } else {\n@@ -2047,10 +2039,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         //\n         // This is intended to leave room for us to implement the\n         // correct behavior in the future.\n-        let has_lifetime_parameter = generic_args.args.iter().any(|arg| match arg {\n-            GenericArg::Lifetime(_) => true,\n-            _ => false,\n-        });\n+        let has_lifetime_parameter =\n+            generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n \n         // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in generic_args.bindings {"}, {"sha": "30cd9944b1a2abfde12f59bf8c58cfb40278cdd2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 30, "deletions": 50, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -313,17 +313,17 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => {\n-                    if self.span.map_or(true, |span| item.span < span) {\n-                        if !item.span.from_expansion() {\n-                            // don't insert between attributes and an item\n-                            if item.attrs.is_empty() {\n-                                self.span = Some(item.span.shrink_to_lo());\n-                            } else {\n-                                // find the first attribute on the item\n-                                for attr in &item.attrs {\n-                                    if self.span.map_or(true, |span| attr.span < span) {\n-                                        self.span = Some(attr.span.shrink_to_lo());\n-                                    }\n+                    if self.span.map_or(true, |span| item.span < span)\n+                        && !item.span.from_expansion()\n+                    {\n+                        // don't insert between attributes and an item\n+                        if item.attrs.is_empty() {\n+                            self.span = Some(item.span.shrink_to_lo());\n+                        } else {\n+                            // find the first attribute on the item\n+                            for attr in &item.attrs {\n+                                if self.span.map_or(true, |span| attr.span < span) {\n+                                    self.span = Some(attr.span.shrink_to_lo());\n                                 }\n                             }\n                         }\n@@ -558,17 +558,11 @@ impl<'a> ModuleData<'a> {\n \n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n-        match self.kind {\n-            ModuleKind::Def(DefKind::Mod, _, _) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, ModuleKind::Def(DefKind::Mod, _, _))\n     }\n \n     fn is_trait(&self) -> bool {\n-        match self.kind {\n-            ModuleKind::Def(DefKind::Trait, _, _) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, ModuleKind::Def(DefKind::Trait, _, _))\n     }\n \n     fn nearest_item_scope(&'a self) -> Module<'a> {\n@@ -628,10 +622,7 @@ enum NameBindingKind<'a> {\n impl<'a> NameBindingKind<'a> {\n     /// Is this a name binding of a import?\n     fn is_import(&self) -> bool {\n-        match *self {\n-            NameBindingKind::Import { .. } => true,\n-            _ => false,\n-        }\n+        matches!(*self, NameBindingKind::Import { .. })\n     }\n }\n \n@@ -750,13 +741,10 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_variant(&self) -> bool {\n-        match self.kind {\n-            NameBindingKind::Res(\n+        matches!(self.kind, NameBindingKind::Res(\n                 Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n                 _,\n-            ) => true,\n-            _ => false,\n-        }\n+            ))\n     }\n \n     fn is_extern_crate(&self) -> bool {\n@@ -774,10 +762,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_import(&self) -> bool {\n-        match self.kind {\n-            NameBindingKind::Import { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, NameBindingKind::Import { .. })\n     }\n \n     fn is_glob_import(&self) -> bool {\n@@ -788,17 +773,14 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_importable(&self) -> bool {\n-        match self.res() {\n-            Res::Def(DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy, _) => false,\n-            _ => true,\n-        }\n+        !matches!(\n+            self.res(),\n+            Res::Def(DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy, _)\n+        )\n     }\n \n     fn is_macro_def(&self) -> bool {\n-        match self.kind {\n-            NameBindingKind::Res(Res::Def(DefKind::Macro(..), _), _) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, NameBindingKind::Res(Res::Def(DefKind::Macro(..), _), _))\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n@@ -1380,7 +1362,7 @@ impl<'a> Resolver<'a> {\n         let maybe_unused_extern_crates = self.maybe_unused_extern_crates;\n         let glob_map = self.glob_map;\n         ResolverOutputs {\n-            definitions: definitions,\n+            definitions,\n             cstore: Box::new(self.crate_loader.into_cstore()),\n             visibilities,\n             extern_crate_map,\n@@ -1992,11 +1974,12 @@ impl<'a> Resolver<'a> {\n                 // The macro is a proc macro derive\n                 if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n                     if let Some(ext) = self.get_macro_by_def_id(def_id) {\n-                        if !ext.is_builtin && ext.macro_kind() == MacroKind::Derive {\n-                            if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n-                                *poisoned = Some(node_id);\n-                                return module.parent;\n-                            }\n+                        if !ext.is_builtin\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n+                        {\n+                            *poisoned = Some(node_id);\n+                            return module.parent;\n                         }\n                     }\n                 }\n@@ -2390,10 +2373,7 @@ impl<'a> Resolver<'a> {\n                         _ => None,\n                     };\n                     let (label, suggestion) = if module_res == self.graph_root.res() {\n-                        let is_mod = |res| match res {\n-                            Res::Def(DefKind::Mod, _) => true,\n-                            _ => false,\n-                        };\n+                        let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n                         // Don't look up import candidates if this is a speculative resolve\n                         let mut candidates = if record_used {\n                             self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod)"}, {"sha": "b632bfbed301cf596a8555764106f1d0d6a2ad66", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -2057,10 +2057,7 @@ impl PpMode {\n \n     pub fn needs_analysis(&self) -> bool {\n         use PpMode::*;\n-        match *self {\n-            PpmMir | PpmMirCFG => true,\n-            _ => false,\n-        }\n+        matches!(*self, PpmMir | PpmMirCFG)\n     }\n }\n "}, {"sha": "130c3a061228b61ecbe0bdd1261e27b8079c294a", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -199,10 +199,8 @@ pub fn invalid_output_for_target(sess: &Session, crate_type: CrateType) -> bool\n             _ => {}\n         }\n     }\n-    if !sess.target.options.executables {\n-        if crate_type == CrateType::Executable {\n-            return true;\n-        }\n+    if !sess.target.options.executables && crate_type == CrateType::Executable {\n+        return true;\n     }\n \n     false"}, {"sha": "e8d470297ea6ce331092ff0969a550b351c6842c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -326,10 +326,8 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     ) -> Result<Self::Path, Self::Error> {\n         self = print_prefix(self)?;\n \n-        let args = args.iter().cloned().filter(|arg| match arg.unpack() {\n-            GenericArgKind::Lifetime(_) => false,\n-            _ => true,\n-        });\n+        let args =\n+            args.iter().cloned().filter(|arg| !matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n \n         if args.clone().next().is_some() {\n             self.generic_delimiters(|cx| cx.comma_sep(args))"}, {"sha": "10245d21b63a5f843c22cf35040ffe74ba8c349e", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -174,10 +174,7 @@ fn compute_symbol_name(\n             return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        match tcx.hir().get(hir_id) {\n-            Node::ForeignItem(_) => true,\n-            _ => false,\n-        }\n+        matches!(tcx.hir().get(hir_id), Node::ForeignItem(_))\n     } else {\n         tcx.is_foreign_item(def_id)\n     };\n@@ -200,15 +197,14 @@ fn compute_symbol_name(\n     //   show up in the `wasm-import-name` custom attribute in LLVM IR.\n     //\n     // [1]: https://bugs.llvm.org/show_bug.cgi?id=44316\n-    if is_foreign {\n-        if tcx.sess.target.arch != \"wasm32\"\n-            || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id)\n-        {\n-            if let Some(name) = attrs.link_name {\n-                return name.to_string();\n-            }\n-            return tcx.item_name(def_id).to_string();\n+    if is_foreign\n+        && (tcx.sess.target.arch != \"wasm32\"\n+            || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id))\n+    {\n+        if let Some(name) = attrs.link_name {\n+            return name.to_string();\n         }\n+        return tcx.item_name(def_id).to_string();\n     }\n \n     if let Some(name) = attrs.export_name {\n@@ -234,10 +230,7 @@ fn compute_symbol_name(\n         // codegen units) then this symbol may become an exported (but hidden\n         // visibility) symbol. This means that multiple crates may do the same\n         // and we want to be sure to avoid any symbol conflicts here.\n-        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n-            InstantiationMode::GloballyShared { may_conflict: true } => true,\n-            _ => false,\n-        };\n+        matches!(MonoItem::Fn(instance).instantiation_mode(tcx), InstantiationMode::GloballyShared { may_conflict: true });\n \n     let instantiating_crate =\n         if avoid_cross_crate_conflicts { Some(compute_instantiating_crate()) } else { None };"}, {"sha": "507ae10877b8540b78c47114a9baab6b0b1fe11c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -474,31 +474,19 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        match self.mode {\n-            PassMode::Indirect(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.mode, PassMode::Indirect(..))\n     }\n \n     pub fn is_sized_indirect(&self) -> bool {\n-        match self.mode {\n-            PassMode::Indirect(_, None) => true,\n-            _ => false,\n-        }\n+        matches!(self.mode, PassMode::Indirect(_, None))\n     }\n \n     pub fn is_unsized_indirect(&self) -> bool {\n-        match self.mode {\n-            PassMode::Indirect(_, Some(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.mode, PassMode::Indirect(_, Some(_)))\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        match self.mode {\n-            PassMode::Ignore => true,\n-            _ => false,\n-        }\n+        matches!(self.mode, PassMode::Ignore)\n     }\n }\n "}, {"sha": "47530eeacd0cd64c798416770a998162cf5d380b", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -333,10 +333,8 @@ where\n     let mut avail_gprs = 8;\n     let mut avail_fprs = 8;\n \n-    if !fn_abi.ret.is_ignore() {\n-        if classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n-            avail_gprs -= 1;\n-        }\n+    if !fn_abi.ret.is_ignore() && classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+        avail_gprs -= 1;\n     }\n \n     for (i, arg) in fn_abi.args.iter_mut().enumerate() {"}, {"sha": "ff2c0e9bb6fcc2aca8f0d81e5cd029785eea74e7", "filename": "compiler/rustc_target/src/abi/call/wasm32.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm32.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -24,10 +24,8 @@ where\n     C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n-    if ret.layout.is_aggregate() {\n-        if !unwrap_trivial_aggregate(cx, ret) {\n-            ret.make_indirect();\n-        }\n+    if ret.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, ret) {\n+        ret.make_indirect();\n     }\n }\n \n@@ -37,10 +35,8 @@ where\n     C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n-    if arg.layout.is_aggregate() {\n-        if !unwrap_trivial_aggregate(cx, arg) {\n-            arg.make_indirect_byval();\n-        }\n+    if arg.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, arg) {\n+        arg.make_indirect_byval();\n     }\n }\n "}, {"sha": "5c87a8f6b3d2698d4c9f801fa6d7daf86a8b1a39", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -557,17 +557,11 @@ impl Primitive {\n     }\n \n     pub fn is_float(self) -> bool {\n-        match self {\n-            F32 | F64 => true,\n-            _ => false,\n-        }\n+        matches!(self, F32 | F64)\n     }\n \n     pub fn is_int(self) -> bool {\n-        match self {\n-            Int(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, Int(..))\n     }\n }\n \n@@ -794,18 +788,12 @@ impl Abi {\n \n     /// Returns `true` if this is an uninhabited type\n     pub fn is_uninhabited(&self) -> bool {\n-        match *self {\n-            Abi::Uninhabited => true,\n-            _ => false,\n-        }\n+        matches!(*self, Abi::Uninhabited)\n     }\n \n     /// Returns `true` is this is a scalar type\n     pub fn is_scalar(&self) -> bool {\n-        match *self {\n-            Abi::Scalar(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Abi::Scalar(_))\n     }\n }\n "}, {"sha": "8e60085262afdd695d05fc83f536e73c203e53e4", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -478,10 +478,7 @@ pub enum InlineAsmType {\n \n impl InlineAsmType {\n     pub fn is_integer(self) -> bool {\n-        match self {\n-            Self::I8 | Self::I16 | Self::I32 | Self::I64 | Self::I128 => true,\n-            _ => false,\n-        }\n+        matches!(self, Self::I8 | Self::I16 | Self::I32 | Self::I64 | Self::I128)\n     }\n \n     pub fn size(self) -> Size {"}, {"sha": "e5ae899a2f356cec904c3f0a4a1a120e3c9bd938", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -342,29 +342,29 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 }\n                 (ty::Bool, Scalar(Bool)) => true,\n                 (ty::Char, Scalar(Char)) => true,\n-                (ty::Int(ty1), Scalar(Int(ty2))) => match (ty1, ty2) {\n+                (ty::Int(ty1), Scalar(Int(ty2))) => matches!(\n+                    (ty1, ty2),\n                     (ast::IntTy::Isize, chalk_ir::IntTy::Isize)\n-                    | (ast::IntTy::I8, chalk_ir::IntTy::I8)\n-                    | (ast::IntTy::I16, chalk_ir::IntTy::I16)\n-                    | (ast::IntTy::I32, chalk_ir::IntTy::I32)\n-                    | (ast::IntTy::I64, chalk_ir::IntTy::I64)\n-                    | (ast::IntTy::I128, chalk_ir::IntTy::I128) => true,\n-                    _ => false,\n-                },\n-                (ty::Uint(ty1), Scalar(Uint(ty2))) => match (ty1, ty2) {\n+                        | (ast::IntTy::I8, chalk_ir::IntTy::I8)\n+                        | (ast::IntTy::I16, chalk_ir::IntTy::I16)\n+                        | (ast::IntTy::I32, chalk_ir::IntTy::I32)\n+                        | (ast::IntTy::I64, chalk_ir::IntTy::I64)\n+                        | (ast::IntTy::I128, chalk_ir::IntTy::I128)\n+                ),\n+                (ty::Uint(ty1), Scalar(Uint(ty2))) => matches!(\n+                    (ty1, ty2),\n                     (ast::UintTy::Usize, chalk_ir::UintTy::Usize)\n-                    | (ast::UintTy::U8, chalk_ir::UintTy::U8)\n-                    | (ast::UintTy::U16, chalk_ir::UintTy::U16)\n-                    | (ast::UintTy::U32, chalk_ir::UintTy::U32)\n-                    | (ast::UintTy::U64, chalk_ir::UintTy::U64)\n-                    | (ast::UintTy::U128, chalk_ir::UintTy::U128) => true,\n-                    _ => false,\n-                },\n-                (ty::Float(ty1), Scalar(Float(ty2))) => match (ty1, ty2) {\n+                        | (ast::UintTy::U8, chalk_ir::UintTy::U8)\n+                        | (ast::UintTy::U16, chalk_ir::UintTy::U16)\n+                        | (ast::UintTy::U32, chalk_ir::UintTy::U32)\n+                        | (ast::UintTy::U64, chalk_ir::UintTy::U64)\n+                        | (ast::UintTy::U128, chalk_ir::UintTy::U128)\n+                ),\n+                (ty::Float(ty1), Scalar(Float(ty2))) => matches!(\n+                    (ty1, ty2),\n                     (ast::FloatTy::F32, chalk_ir::FloatTy::F32)\n-                    | (ast::FloatTy::F64, chalk_ir::FloatTy::F64) => true,\n-                    _ => false,\n-                },\n+                        | (ast::FloatTy::F64, chalk_ir::FloatTy::F64)\n+                ),\n                 (&ty::Tuple(..), Tuple(..)) => true,\n                 (&ty::Array(..), Array) => true,\n                 (&ty::Slice(..), Slice) => true,"}, {"sha": "c44fd1d58593f1060775914aa7e42d37a61445a5", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffe52882ed79be67344dd6085559e308241e7f60/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=ffe52882ed79be67344dd6085559e308241e7f60", "patch": "@@ -62,7 +62,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or(vec![]);\n+            .unwrap_or_default();\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}]}