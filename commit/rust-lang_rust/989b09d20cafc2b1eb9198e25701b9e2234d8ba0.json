{"sha": "989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "node_id": "C_kwDOAAsO6NoAKDk4OWIwOWQyMGNhZmMyYjFlYjkxOThlMjU3MDFiOWUyMjM0ZDhiYTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T13:31:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T13:31:37Z"}, "message": "Auto merge of #13145 - ChayimFriedman2:unmerge-match-arm, r=jonas-schievink\n\nfeat: Add a \"Unmerge match arm\" assist to split or-patterns inside match expressions\n\nFixes #13072.\n\nThe way I implemented it it leaves the `OrPat` in place even if there is only one pattern now but I don't think something will break because of that, and when more code will be typed we'll parse it again anyway. Removing it (but keeping the child pattern) is hard, I don't know how to do that.", "tree": {"sha": "447961d2e0e07a0974a217fdd88d0a71ec308e63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447961d2e0e07a0974a217fdd88d0a71ec308e63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "html_url": "https://github.com/rust-lang/rust/commit/989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f02cd0a41d7381b1ef454b0141adacc188d3eee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f02cd0a41d7381b1ef454b0141adacc188d3eee8", "html_url": "https://github.com/rust-lang/rust/commit/f02cd0a41d7381b1ef454b0141adacc188d3eee8"}, {"sha": "5f132e666db7290e3414d12a71e410afc7e13df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f132e666db7290e3414d12a71e410afc7e13df3", "html_url": "https://github.com/rust-lang/rust/commit/5f132e666db7290e3414d12a71e410afc7e13df3"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "9565f0ee6f26f96833dd35d7977d03070033b619", "filename": "crates/ide-assists/src/handlers/unmerge_match_arm.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs?ref=989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "patch": "@@ -0,0 +1,293 @@\n+use syntax::{\n+    algo::neighbor,\n+    ast::{self, edit::IndentLevel, make, AstNode},\n+    ted::{self, Position},\n+    Direction, SyntaxKind, T,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unmerge_match_arm\n+//\n+// Splits the current match with a `|` pattern into two arms with identical bodies.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move(..) $0| Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move(..) => foo(),\n+//         Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+pub(crate) fn unmerge_match_arm(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let pipe_token = ctx.find_token_syntax_at_offset(T![|])?;\n+    let or_pat = ast::OrPat::cast(pipe_token.parent()?)?.clone_for_update();\n+    let match_arm = ast::MatchArm::cast(or_pat.syntax().parent()?)?;\n+    let match_arm_body = match_arm.expr()?;\n+\n+    // We don't need to check for leading pipe because it is directly under `MatchArm`\n+    // without `OrPat`.\n+\n+    let new_parent = match_arm.syntax().parent()?;\n+    let old_parent_range = new_parent.text_range();\n+\n+    acc.add(\n+        AssistId(\"unmerge_match_arm\", AssistKind::RefactorRewrite),\n+        \"Unmerge match arm\",\n+        pipe_token.text_range(),\n+        |edit| {\n+            let pats_after = pipe_token\n+                .siblings_with_tokens(Direction::Next)\n+                .filter_map(|it| ast::Pat::cast(it.into_node()?));\n+            // FIXME: We should add a leading pipe if the original arm has one.\n+            let new_match_arm = make::match_arm(\n+                pats_after,\n+                match_arm.guard().and_then(|guard| guard.condition()),\n+                match_arm_body,\n+            )\n+            .clone_for_update();\n+\n+            let mut pipe_index = pipe_token.index();\n+            if pipe_token\n+                .prev_sibling_or_token()\n+                .map_or(false, |it| it.kind() == SyntaxKind::WHITESPACE)\n+            {\n+                pipe_index -= 1;\n+            }\n+            or_pat.syntax().splice_children(\n+                pipe_index..or_pat.syntax().children_with_tokens().count(),\n+                Vec::new(),\n+            );\n+\n+            let mut insert_after_old_arm = Vec::new();\n+\n+            // A comma can be:\n+            //  - After the arm. In this case we always want to insert a comma after the newly\n+            //    inserted arm.\n+            //  - Missing after the arm, with no arms after. In this case we want to insert a\n+            //    comma before the newly inserted arm. It can not be necessary if there arm\n+            //    body is a block, but we don't bother to check that.\n+            //  - Missing after the arm with arms after, if the arm body is a block. In this case\n+            //    we don't want to insert a comma at all.\n+            let has_comma_after =\n+                std::iter::successors(match_arm.syntax().last_child_or_token(), |it| {\n+                    it.prev_sibling_or_token()\n+                })\n+                .map(|it| it.kind())\n+                .skip_while(|it| it.is_trivia())\n+                .next()\n+                    == Some(T![,]);\n+            let has_arms_after = neighbor(&match_arm, Direction::Next).is_some();\n+            if !has_comma_after && !has_arms_after {\n+                insert_after_old_arm.push(make::token(T![,]).into());\n+            }\n+\n+            let indent = IndentLevel::from_node(match_arm.syntax());\n+            insert_after_old_arm.push(make::tokens::whitespace(&format!(\"\\n{indent}\")).into());\n+\n+            insert_after_old_arm.push(new_match_arm.syntax().clone().into());\n+\n+            ted::insert_all_raw(Position::after(match_arm.syntax()), insert_after_old_arm);\n+\n+            if has_comma_after {\n+                ted::insert_raw(\n+                    Position::last_child_of(new_match_arm.syntax()),\n+                    make::token(T![,]),\n+                );\n+            }\n+\n+            edit.replace(old_parent_range, new_parent.to_string());\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unmerge_match_arm_single_pipe() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B => { 1i32 }\n+        X::C => { 2i32 }\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A => { 1i32 }\n+        X::B => { 1i32 }\n+        X::C => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_guard() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B if true => { 1i32 }\n+        _ => { 2i32 }\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A if true => { 1i32 }\n+        X::B if true => { 1i32 }\n+        _ => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_leading_pipe() {\n+        check_assist_not_applicable(\n+            unmerge_match_arm,\n+            r#\"\n+\n+fn main() {\n+    let y = match 0 {\n+        |$0 0 => { 1i32 }\n+        1 => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_multiple_pipes() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C, D, E }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A | X::B |$0 X::C | X::D => 1i32,\n+        X::E => 2i32,\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C, D, E }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A | X::B => 1i32,\n+        X::C | X::D => 1i32,\n+        X::E => 2i32,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_inserts_comma_if_required() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B => 1i32\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A => 1i32,\n+        X::B => 1i32\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_inserts_comma_if_had_after() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    match x {\n+        X::A $0| X::B => {},\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    match x {\n+        X::A => {},\n+        X::B => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "c558553b1cbe047985ae186fde1e1c076001b315", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "patch": "@@ -185,6 +185,7 @@ mod handlers {\n     mod replace_string_with_char;\n     mod replace_turbofish_with_explicit_type;\n     mod split_import;\n+    mod unmerge_match_arm;\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n@@ -278,6 +279,7 @@ mod handlers {\n             sort_items::sort_items,\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n+            unmerge_match_arm::unmerge_match_arm,\n             unmerge_use::unmerge_use,\n             unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,"}, {"sha": "7b2c16806b2bad783bb20178fdd96a2ced942f28", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989b09d20cafc2b1eb9198e25701b9e2234d8ba0/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "patch": "@@ -2207,6 +2207,32 @@ fn arithmetics {\n     )\n }\n \n+#[test]\n+fn doctest_unmerge_match_arm() {\n+    check_doc_test(\n+        \"unmerge_match_arm\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) $0| Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) => foo(),\n+        Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unmerge_use() {\n     check_doc_test("}]}