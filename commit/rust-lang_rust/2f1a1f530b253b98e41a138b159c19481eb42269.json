{"sha": "2f1a1f530b253b98e41a138b159c19481eb42269", "node_id": "C_kwDOAAsO6NoAKDJmMWExZjUzMGIyNTNiOThlNDFhMTM4YjE1OWMxOTQ4MWViNDIyNjk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-11-18T03:29:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-11-18T14:10:35Z"}, "message": "fix CTFE/Miri simd_insert/extract on array-style repr(simd) types", "tree": {"sha": "d94a2216178b11d332e462ebc97f50c8b12de3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d94a2216178b11d332e462ebc97f50c8b12de3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1a1f530b253b98e41a138b159c19481eb42269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1a1f530b253b98e41a138b159c19481eb42269", "html_url": "https://github.com/rust-lang/rust/commit/2f1a1f530b253b98e41a138b159c19481eb42269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1a1f530b253b98e41a138b159c19481eb42269/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41301c3b2371365b753c2ad6a74528a38f3815ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/41301c3b2371365b753c2ad6a74528a38f3815ce", "html_url": "https://github.com/rust-lang/rust/commit/41301c3b2371365b753c2ad6a74528a38f3815ce"}], "stats": {"total": 105, "additions": 67, "deletions": 38}, "files": [{"sha": "44da27a43db0a01e08d9c46db4ef4fc8be2c4e70", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2f1a1f530b253b98e41a138b159c19481eb42269", "patch": "@@ -413,48 +413,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n                 let elem = &args[2];\n-                let input = &args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n+                let (dest, dest_len) = self.place_to_simd(dest)?;\n+                assert_eq!(input_len, dest_len, \"Return vector length must match input length\");\n                 assert!(\n-                    index < len,\n-                    \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n+                    index < dest_len,\n+                    \"Index `{}` must be in bounds of vector with length {}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    input.layout, dest.layout,\n-                    \"Return type `{}` must match vector type `{}`\",\n-                    dest.layout.ty, input.layout.ty\n-                );\n-                assert_eq!(\n-                    elem.layout.ty, e_ty,\n-                    \"Scalar element type `{}` must match vector element type `{}`\",\n-                    elem.layout.ty, e_ty\n+                    dest_len\n                 );\n \n-                for i in 0..len {\n-                    let place = self.place_index(dest, i)?;\n-                    let value = if i == index { *elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(&value, &place)?;\n+                for i in 0..dest_len {\n+                    let place = self.mplace_index(&dest, i)?;\n+                    let value =\n+                        if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n+                    self.copy_op(&value, &place.into())?;\n                 }\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n                 assert!(\n-                    index < len,\n-                    \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\",\n+                    index < input_len,\n+                    \"index `{}` must be in bounds of vector with length `{}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    e_ty, dest.layout.ty,\n-                    \"Return type `{}` must match vector element type `{}`\",\n-                    dest.layout.ty, e_ty\n+                    input_len\n                 );\n-                self.copy_op(&self.operand_index(&args[0], index)?, dest)?;\n+                self.copy_op(&self.mplace_index(&input, index)?.into(), dest)?;\n             }\n             sym::likely | sym::unlikely | sym::black_box => {\n                 // These just return their argument"}, {"sha": "de9e94ce2ac0c820137e5edcb9c3f68ce20f848e", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=2f1a1f530b253b98e41a138b159c19481eb42269", "patch": "@@ -437,6 +437,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    /// Converts a repr(simd) operand into an operand where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn operand_to_simd(\n+        &self,\n+        base: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // This only works in memory, but repr(simd) types should never be immediates anyway.\n+        assert!(base.layout.ty.is_simd());\n+        self.mplace_to_simd(&base.assert_mem_place())\n+    }\n+\n     /// Read from a local. Will not actually access the local if reading from a ZST.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///"}, {"sha": "d7f2853fc86f508a26d70aa3b61580c97db0a2f6", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=2f1a1f530b253b98e41a138b159c19481eb42269", "patch": "@@ -200,7 +200,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n             }\n         } else {\n             // Go through the layout.  There are lots of types that support a length,\n-            // e.g., SIMD types.\n+            // e.g., SIMD types. (But not all repr(simd) types even have FieldsShape::Array!)\n             match self.layout.fields {\n                 FieldsShape::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n@@ -533,6 +533,22 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn mplace_to_simd(\n+        &self,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // (Transmuting is okay since this is an in-memory place. We also double-check the size\n+        // stays the same.)\n+        let (len, e_ty) = base.layout.ty.simd_size_and_type(*self.tcx);\n+        let array = self.tcx.mk_array(e_ty, len);\n+        let layout = self.layout_of(array)?;\n+        assert_eq!(layout.size, base.layout.size);\n+        Ok((MPlaceTy { layout, ..*base }, len))\n+    }\n+\n     /// Gets the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n@@ -594,6 +610,16 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn place_to_simd(\n+        &mut self,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        let mplace = self.force_allocation(base)?;\n+        self.mplace_to_simd(&mplace)\n+    }\n+\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place("}, {"sha": "c79e25f4781c83e0e03d90b5b4c8f4cd90dd0fd4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1a1f530b253b98e41a138b159c19481eb42269/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2f1a1f530b253b98e41a138b159c19481eb42269", "patch": "@@ -1805,17 +1805,22 @@ impl<'tcx> TyS<'tcx> {\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n+                assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n                 let variant = def.non_enum_variant();\n                 let f0_ty = variant.fields[0].ty(tcx, substs);\n \n                 match f0_ty.kind() {\n+                    // If the first field is an array, we assume it is the only field and its\n+                    // elements are the SIMD components.\n                     Array(f0_elem_ty, f0_len) => {\n                         // FIXME(repr_simd): https://github.com/rust-lang/rust/pull/78863#discussion_r522784112\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n                         (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty)\n                     }\n+                    // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n+                    // all have the same type).\n                     _ => (variant.fields.len() as u64, f0_ty),\n                 }\n             }"}, {"sha": "a1cd24077c66199673b146c56d5e0dc5ce04b236", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f1a1f530b253b98e41a138b159c19481eb42269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1a1f530b253b98e41a138b159c19481eb42269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=2f1a1f530b253b98e41a138b159c19481eb42269", "patch": "@@ -7,7 +7,8 @@\n \n #[repr(simd)] struct i8x1(i8);\n #[repr(simd)] struct u16x2(u16, u16);\n-#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n+// Make one of them an array type to ensure those also work.\n+#[repr(simd)] struct f32x4([f32; 4]);\n \n extern \"platform-intrinsic\" {\n     #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n@@ -38,12 +39,12 @@ fn main() {\n         assert_eq!(Y1, 42);\n     }\n     {\n-        const U: f32x4 = f32x4(13., 14., 15., 16.);\n+        const U: f32x4 = f32x4([13., 14., 15., 16.]);\n         const V: f32x4 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n-        const X0: f32 = V.0;\n-        const X1: f32 = V.1;\n-        const X2: f32 = V.2;\n-        const X3: f32 = V.3;\n+        const X0: f32 = V.0[0];\n+        const X1: f32 = V.0[1];\n+        const X2: f32 = V.0[2];\n+        const X3: f32 = V.0[3];\n         const Y0: f32 = unsafe { simd_extract(V, 0) };\n         const Y1: f32 = unsafe { simd_extract(V, 1) };\n         const Y2: f32 = unsafe { simd_extract(V, 2) };"}]}