{"sha": "7de925b8abcf0d26869dc96f346510af61663edf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZTkyNWI4YWJjZjBkMjY4NjlkYzk2ZjM0NjUxMGFmNjE2NjNlZGY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-27T00:54:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-27T00:54:49Z"}, "message": "Collapse more CompletionContext booleans into enums", "tree": {"sha": "38bcf6bc8d2cabb051b127e2f1f6cd2a9b94027c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38bcf6bc8d2cabb051b127e2f1f6cd2a9b94027c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7de925b8abcf0d26869dc96f346510af61663edf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7de925b8abcf0d26869dc96f346510af61663edf", "html_url": "https://github.com/rust-lang/rust/commit/7de925b8abcf0d26869dc96f346510af61663edf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7de925b8abcf0d26869dc96f346510af61663edf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ed315806e23d9ebda96ecfbe13da2154a2289c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ed315806e23d9ebda96ecfbe13da2154a2289c", "html_url": "https://github.com/rust-lang/rust/commit/d6ed315806e23d9ebda96ecfbe13da2154a2289c"}], "stats": {"total": 231, "additions": 133, "deletions": 98}, "files": [{"sha": "b7d3ee8ce7bb05a780e7967460b5eb89004dfefb", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -114,8 +114,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         || ctx.attribute_under_caret.is_some()\n         || ctx.mod_declaration_under_caret.is_some()\n         || ctx.record_lit_syntax.is_some()\n-        || ctx.has_trait_parent\n-        || ctx.has_impl_parent\n+        || ctx.has_impl_or_trait_parent()\n     {\n         return None;\n     }"}, {"sha": "58e35bad9b24ae687c49caede155845e48803410", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -49,34 +49,35 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    let has_trait_or_impl_parent = ctx.has_impl_parent || ctx.has_trait_parent;\n-    if ctx.trait_as_prev_sibling || ctx.impl_as_prev_sibling {\n+    let has_trait_or_impl_parent = ctx.has_impl_or_trait_parent();\n+    let has_block_expr_parent = ctx.has_block_expr_parent();\n+    let has_item_list_parent = ctx.has_item_list_parent();\n+    if ctx.has_impl_or_trait_prev_sibling() {\n         add_keyword(ctx, acc, \"where\", \"where \");\n         return;\n     }\n     if ctx.previous_token_is(T![unsafe]) {\n-        if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent {\n+        if has_item_list_parent || has_block_expr_parent {\n             add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\")\n         }\n \n-        if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+        if has_item_list_parent || has_block_expr_parent {\n             add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n             add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n         }\n \n         return;\n     }\n-    if ctx.has_item_list_or_source_file_parent || has_trait_or_impl_parent || ctx.block_expr_parent\n-    {\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"use\", \"use \");\n         add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.has_item_list_or_source_file_parent {\n+    if has_item_list_parent {\n         add_keyword(ctx, acc, \"enum\", \"enum $1 {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"struct\", \"struct $0\");\n         add_keyword(ctx, acc, \"union\", \"union $1 {\\n    $0\\n}\");\n@@ -92,35 +93,31 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(ctx, acc, \"for\", \"for $1 in $2 {\\n    $0\\n}\");\n     }\n \n-    if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || ctx.block_expr_parent {\n+    if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || has_block_expr_parent {\n         add_keyword(ctx, acc, \"let\", \"let \");\n     }\n \n     if ctx.after_if {\n         add_keyword(ctx, acc, \"else\", \"else {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"mod\", \"mod $0\");\n     }\n-    if ctx.bind_pat_parent || ctx.ref_pat_parent {\n+    if ctx.has_ident_or_ref_pat_parent() {\n         add_keyword(ctx, acc, \"mut\", \"mut \");\n     }\n-    if ctx.has_item_list_or_source_file_parent || has_trait_or_impl_parent || ctx.block_expr_parent\n-    {\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"const\", \"const \");\n         add_keyword(ctx, acc, \"type\", \"type \");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"static\", \"static \");\n     };\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"extern\", \"extern \");\n     }\n-    if ctx.has_item_list_or_source_file_parent\n-        || has_trait_or_impl_parent\n-        || ctx.block_expr_parent\n-        || ctx.is_match_arm\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent || ctx.is_match_arm\n     {\n         add_keyword(ctx, acc, \"unsafe\", \"unsafe \");\n     }\n@@ -133,15 +130,15 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n             add_keyword(ctx, acc, \"break\", \"break\");\n         }\n     }\n-    if ctx.has_item_list_or_source_file_parent || ctx.has_impl_parent | ctx.has_field_list_parent {\n+    if has_item_list_parent || ctx.has_impl_parent() || ctx.has_field_list_parent() {\n         add_keyword(ctx, acc, \"pub(crate)\", \"pub(crate) \");\n         add_keyword(ctx, acc, \"pub\", \"pub \");\n     }\n \n     if !ctx.is_trivial_path {\n         return;\n     }\n-    let fn_def = match &ctx.function_syntax {\n+    let fn_def = match &ctx.function_def {\n         Some(it) => it,\n         None => return,\n     };"}, {"sha": "defc25b00892b039407a650f832efac72ca9e901", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -14,7 +14,7 @@ fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str)\n }\n \n pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && ctx.function_syntax.is_some()) {\n+    if !(ctx.is_trivial_path && ctx.function_def.is_some()) {\n         return;\n     }\n     let cap = match ctx.config.snippet_cap {"}, {"sha": "7496d26c4db89b709c6e118863d39b3d9214a388", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -13,8 +13,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         || ctx.record_pat_syntax.is_some()\n         || ctx.attribute_under_caret.is_some()\n         || ctx.mod_declaration_under_caret.is_some()\n-        || ctx.has_impl_parent\n-        || ctx.has_trait_parent\n+        || ctx.has_impl_or_trait_parent()\n     {\n         return;\n     }"}, {"sha": "dfac8f29f49c19cf1402f1ead5d56ecf66cc06f8", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 94, "deletions": 49, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -31,6 +31,24 @@ pub(crate) enum PatternRefutability {\n     Irrefutable,\n }\n \n+/// Direct parent container of the cursor position\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum ImmediateLocation {\n+    Impl,\n+    Trait,\n+    RecordFieldList,\n+    RefPatOrExpr,\n+    IdentPat,\n+    BlockExpr,\n+    ItemList,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum PrevSibling {\n+    Trait,\n+    Impl,\n+}\n+\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -48,14 +66,19 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n-    pub(super) function_syntax: Option<ast::Fn>,\n+\n     pub(super) use_item_syntax: Option<ast::Use>,\n-    pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n-    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n-    pub(super) record_field_syntax: Option<ast::RecordExprField>,\n+\n+    /// The parent function of the cursor position if it exists.\n+    pub(super) function_def: Option<ast::Fn>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n \n+    /// RecordExpr the token is a field of\n+    pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n+    /// RecordPat the token is a field of\n+    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n+\n     // potentially set if we are completing a lifetime\n     pub(super) lifetime_syntax: Option<ast::Lifetime>,\n     pub(super) lifetime_param_syntax: Option<ast::LifetimeParam>,\n@@ -66,6 +89,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_pat_or_const: Option<PatternRefutability>,\n     pub(super) is_param: bool,\n \n+    pub(super) completion_location: Option<ImmediateLocation>,\n+\n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n@@ -94,20 +119,12 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) locals: Vec<(String, Local)>,\n \n     pub(super) mod_declaration_under_caret: Option<ast::Module>,\n-    pub(super) has_trait_parent: bool,\n-    pub(super) has_impl_parent: bool,\n \n     // keyword patterns\n     pub(super) previous_token: Option<SyntaxToken>,\n-    pub(super) block_expr_parent: bool,\n-    pub(super) bind_pat_parent: bool,\n-    pub(super) ref_pat_parent: bool,\n     pub(super) in_loop_body: bool,\n-    pub(super) has_field_list_parent: bool,\n-    pub(super) trait_as_prev_sibling: bool,\n-    pub(super) impl_as_prev_sibling: bool,\n+    pub(super) prev_sibling: Option<PrevSibling>,\n     pub(super) is_match_arm: bool,\n-    pub(super) has_item_list_or_source_file_parent: bool,\n     pub(super) incomplete_let: bool,\n \n     no_completion_required: bool,\n@@ -159,11 +176,10 @@ impl<'a> CompletionContext<'a> {\n             name_ref_syntax: None,\n             lifetime_syntax: None,\n             lifetime_param_syntax: None,\n-            function_syntax: None,\n+            function_def: None,\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_pat_syntax: None,\n-            record_field_syntax: None,\n             impl_def: None,\n             active_parameter: ActiveParameter::at(db, position),\n             is_label_ref: false,\n@@ -185,17 +201,10 @@ impl<'a> CompletionContext<'a> {\n             attribute_under_caret: None,\n             mod_declaration_under_caret: None,\n             previous_token: None,\n-            block_expr_parent: false,\n-            bind_pat_parent: false,\n-            ref_pat_parent: false,\n             in_loop_body: false,\n-            has_trait_parent: false,\n-            has_impl_parent: false,\n-            has_field_list_parent: false,\n-            trait_as_prev_sibling: false,\n-            impl_as_prev_sibling: false,\n+            completion_location: None,\n+            prev_sibling: None,\n             is_match_arm: false,\n-            has_item_list_or_source_file_parent: false,\n             no_completion_required: false,\n             incomplete_let: false,\n             locals,\n@@ -274,23 +283,68 @@ impl<'a> CompletionContext<'a> {\n         self.previous_token.as_ref().map_or(false, |tok| tok.kind() == kind)\n     }\n \n+    pub(crate) fn has_impl_or_trait_parent(&self) -> bool {\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::Trait) | Some(ImmediateLocation::Impl)\n+        )\n+    }\n+\n+    pub(crate) fn has_block_expr_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n+    }\n+\n+    pub(crate) fn has_item_list_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n+    }\n+\n+    pub(crate) fn has_ident_or_ref_pat_parent(&self) -> bool {\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::IdentPat) | Some(ImmediateLocation::RefPatOrExpr)\n+        )\n+    }\n+\n+    pub(crate) fn has_impl_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::Impl))\n+    }\n+\n+    pub(crate) fn has_field_list_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::RecordFieldList))\n+    }\n+\n+    pub(crate) fn has_impl_or_trait_prev_sibling(&self) -> bool {\n+        self.prev_sibling.is_some()\n+    }\n+\n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         self.previous_token = previous_token(syntax_element.clone());\n-        self.block_expr_parent = has_block_expr_parent(syntax_element.clone());\n-        self.bind_pat_parent = has_bind_pat_parent(syntax_element.clone());\n-        self.ref_pat_parent = has_ref_parent(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n-        self.has_trait_parent = has_trait_parent(syntax_element.clone());\n-        self.has_impl_parent = has_impl_parent(syntax_element.clone());\n-        self.has_field_list_parent = has_field_list_parent(syntax_element.clone());\n-        self.impl_as_prev_sibling = has_impl_as_prev_sibling(syntax_element.clone());\n-        self.trait_as_prev_sibling = has_trait_as_prev_sibling(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n+        if has_impl_as_prev_sibling(syntax_element.clone()) {\n+            self.prev_sibling = Some(PrevSibling::Impl)\n+        } else if has_trait_as_prev_sibling(syntax_element.clone()) {\n+            self.prev_sibling = Some(PrevSibling::Trait)\n+        }\n+\n+        if has_block_expr_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::BlockExpr);\n+        } else if has_bind_pat_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::IdentPat);\n+        } else if has_ref_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::RefPatOrExpr);\n+        } else if has_impl_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::Impl);\n+        } else if has_field_list_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::RecordFieldList);\n+        } else if has_trait_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::Trait);\n+        } else if has_item_list_or_source_file_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::ItemList);\n+        }\n \n-        self.has_item_list_or_source_file_parent =\n-            has_item_list_or_source_file_parent(syntax_element.clone());\n         self.mod_declaration_under_caret =\n             find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n                 .filter(|module| module.item_list().is_none());\n@@ -542,31 +596,20 @@ impl<'a> CompletionContext<'a> {\n             .last()\n             .unwrap();\n \n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n-                self.is_new_item = true;\n-                return;\n-            }\n-            _ => (),\n+        if matches!(top_node.parent().map(|it| it.kind()), Some(SOURCE_FILE) | Some(ITEM_LIST)) {\n+            self.is_new_item = true;\n+            return;\n         }\n \n         self.use_item_syntax =\n             self.sema.token_ancestors_with_macros(self.token.clone()).find_map(ast::Use::cast);\n \n-        self.function_syntax = self\n+        self.function_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Fn::cast);\n \n-        self.record_field_syntax = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| {\n-                it.kind() != SOURCE_FILE && it.kind() != MODULE && it.kind() != CALL_EXPR\n-            })\n-            .find_map(ast::RecordExprField::cast);\n-\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,\n@@ -639,6 +682,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n         }\n+\n         if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n             // The receiver comes before the point of insertion of the fake\n             // ident, so it should have the same range in the non-modified file\n@@ -656,6 +700,7 @@ impl<'a> CompletionContext<'a> {\n                     false\n                 };\n         }\n+\n         if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n             // As above\n             self.dot_receiver = method_call_expr"}, {"sha": "8f0d76661678e54a7a50b34a3f6d6cd4ecc8f3d2", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de925b8abcf0d26869dc96f346510af61663edf/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=7de925b8abcf0d26869dc96f346510af61663edf", "patch": "@@ -91,11 +91,10 @@ fn test_has_ref_parent() {\n }\n \n pub(crate) fn has_item_list_or_source_file_parent(element: SyntaxElement) -> bool {\n-    let ancestor = not_same_range_ancestor(element);\n-    if !ancestor.is_some() {\n-        return true;\n+    match not_same_range_ancestor(element) {\n+        Some(it) => it.kind() == SOURCE_FILE || it.kind() == ITEM_LIST,\n+        None => true,\n     }\n-    ancestor.filter(|it| it.kind() == SOURCE_FILE || it.kind() == ITEM_LIST).is_some()\n }\n #[test]\n fn test_has_item_list_or_source_file_parent() {\n@@ -151,25 +150,21 @@ fn test_has_impl_as_prev_sibling() {\n }\n \n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n-    for node in element.ancestors() {\n-        if node.kind() == FN || node.kind() == CLOSURE_EXPR {\n-            break;\n-        }\n-        let loop_body = match_ast! {\n-            match node {\n-                ast::ForExpr(it) => it.loop_body(),\n-                ast::WhileExpr(it) => it.loop_body(),\n-                ast::LoopExpr(it) => it.loop_body(),\n-                _ => None,\n-            }\n-        };\n-        if let Some(body) = loop_body {\n-            if body.syntax().text_range().contains_range(element.text_range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n+    element\n+        .ancestors()\n+        .take_while(|it| it.kind() != FN && it.kind() != CLOSURE_EXPR)\n+        .find_map(|it| {\n+            let loop_body = match_ast! {\n+                match it {\n+                    ast::ForExpr(it) => it.loop_body(),\n+                    ast::WhileExpr(it) => it.loop_body(),\n+                    ast::LoopExpr(it) => it.loop_body(),\n+                    _ => None,\n+                }\n+            };\n+            loop_body.filter(|it| it.syntax().text_range().contains_range(element.text_range()))\n+        })\n+        .is_some()\n }\n \n fn not_same_range_ancestor(element: SyntaxElement) -> Option<SyntaxNode> {"}]}