{"sha": "64a70342e67f09b5326538b08990d1b0d2900a5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YTcwMzQyZTY3ZjA5YjUzMjY1MzhiMDg5OTBkMWIwZDI5MDBhNWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-30T21:48:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-05T14:37:28Z"}, "message": "rustc: Remove a number of mutable fields in cstore\n\nThis commit started by moving methods from `CrateStore` to queries, but it ended\nup necessitating some deeper refactorings to move more items in general to\nqueries.\n\nBefore this commit the *resolver* would walk over the AST and process foreign\nmodules (`extern { .. }` blocks) and collect `#[link]` annotations. It would\nthen also process the command line `-l` directives and such. This information\nwas then stored as precalculated lists in the `CrateStore` object for iterating\nover later.\n\nAfter this, commit, however, this pass no longer happens during resolution but\nnow instead happens through queries. A query for the linked libraries of a crate\nwill crawl the crate for `extern` blocks and then process the linkage\nannotations at that time.", "tree": {"sha": "0fef98b42f025e8f13769e92b353e14e994f6ba1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fef98b42f025e8f13769e92b353e14e994f6ba1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a70342e67f09b5326538b08990d1b0d2900a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a70342e67f09b5326538b08990d1b0d2900a5b", "html_url": "https://github.com/rust-lang/rust/commit/64a70342e67f09b5326538b08990d1b0d2900a5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a70342e67f09b5326538b08990d1b0d2900a5b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87ea0a19bf3a4dccac890b33646fa3460dff5a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ea0a19bf3a4dccac890b33646fa3460dff5a8b", "html_url": "https://github.com/rust-lang/rust/commit/87ea0a19bf3a4dccac890b33646fa3460dff5a8b"}], "stats": {"total": 675, "additions": 366, "deletions": 309}, "files": [{"sha": "9646d3a7b3bf21005766d52691345e34aded1ab4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -545,6 +545,11 @@ define_dep_nodes!( <'tcx>\n \n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),\n+\n+    [] IsDllimportForeignItem(DefId),\n+    [] IsStaticallyIncludedForeignItem(DefId),\n+    [] NativeLibraryKind(DefId),\n+    [] LinkArgs,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "97b047474101ffeb2bc09713b99c57035bc4e3b7", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -236,10 +236,6 @@ pub trait CrateStore {\n     // trait/impl-item info\n     fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n \n-    // flags\n-    fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n-\n     // crate metadata\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n     fn export_macros(&self, cnum: CrateNum);\n@@ -265,8 +261,6 @@ pub trait CrateStore {\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n-    fn used_libraries(&self) -> Vec<NativeLibrary>;\n-    fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n@@ -329,10 +323,6 @@ impl CrateStore for DummyCrateStore {\n     fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n         { bug!(\"associated_item_cloned\") }\n \n-    // flags\n-    fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n-\n     // crate metadata\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n@@ -368,8 +358,6 @@ impl CrateStore for DummyCrateStore {\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<NativeLibrary> { vec![] }\n-    fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>"}, {"sha": "1312bd3a7a6beaaf38f322262bb61c82b266c559", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -17,6 +17,7 @@ use hir::svh::Svh;\n use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n+use middle::cstore::NativeLibraryKind;\n use middle::privacy::AccessLevels;\n use middle::region;\n use mir;\n@@ -642,6 +643,12 @@ impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up link arguments for a crate\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1230,6 +1237,12 @@ define_maps! { <'tcx>\n         -> Rc<Vec<DefId>>,\n     [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n         -> Rc<Vec<DefId>>,\n+\n+    [] is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+    [] is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+    [] native_library_kind: NativeLibraryKind(DefId)\n+        -> Option<NativeLibraryKind>,\n+    [] link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1315,3 +1328,7 @@ fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n {\n     DepConstructor::ImplementationsOfTrait { krate, trait_id }\n }\n+\n+fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LinkArgs\n+}"}, {"sha": "10b591432eeede6df36781a5878cd8c8ac812d79", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -694,7 +694,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // this back at some point.\n     let _ignore = sess.dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n-    crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,\n                                      &krate,"}, {"sha": "aba5949c5a74975a32b87a93bceda1d9310d9bc7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 220, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -12,6 +12,7 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n+use native_libs::relevant_lib;\n use schema::{CrateRoot, Tracked};\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n@@ -26,7 +27,6 @@ use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n-use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -36,10 +36,8 @@ use std::rc::Rc;\n use std::{cmp, fs};\n \n use syntax::ast;\n-use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::Symbol;\n use syntax::visit;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -81,56 +79,6 @@ struct ExternCrateInfo {\n     dep_kind: DepKind,\n }\n \n-fn register_native_lib(sess: &Session,\n-                       cstore: &CStore,\n-                       span: Option<Span>,\n-                       lib: NativeLibrary) {\n-    if lib.name.as_str().is_empty() {\n-        match span {\n-            Some(span) => {\n-                struct_span_err!(sess, span, E0454,\n-                                 \"#[link(name = \\\"\\\")] given with empty name\")\n-                    .span_label(span, \"empty name given\")\n-                    .emit();\n-            }\n-            None => {\n-                sess.err(\"empty library name given via `-l`\");\n-            }\n-        }\n-        return\n-    }\n-    let is_osx = sess.target.target.options.is_like_osx;\n-    if lib.kind == cstore::NativeFramework && !is_osx {\n-        let msg = \"native frameworks are only available on macOS targets\";\n-        match span {\n-            Some(span) => span_err!(sess, span, E0455, \"{}\", msg),\n-            None => sess.err(msg),\n-        }\n-    }\n-    if lib.cfg.is_some() && !sess.features.borrow().link_cfg {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"link_cfg\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"is feature gated\");\n-    }\n-    if lib.kind == cstore::NativeStaticNobundle && !sess.features.borrow().static_nobundle {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"static_nobundle\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"kind=\\\"static-nobundle\\\" is feature gated\");\n-    }\n-    cstore.add_used_library(lib);\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n // Extra info about a crate loaded for plugins or exported macros.\n struct ExtensionCrate {\n     metadata: PMDSource,\n@@ -721,33 +669,6 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn get_foreign_items_of_kind(&self, kind: cstore::NativeLibraryKind) -> Vec<DefIndex> {\n-        let mut items = vec![];\n-        let libs = self.cstore.get_used_libraries();\n-        for lib in libs.borrow().iter() {\n-            if relevant_lib(self.sess, lib) && lib.kind == kind {\n-                items.extend(&lib.foreign_items);\n-            }\n-        }\n-        items\n-    }\n-\n-    fn register_statically_included_foreign_items(&mut self) {\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStatic) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStaticNobundle) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-    }\n-\n-    fn register_dllimport_foreign_items(&mut self) {\n-        let mut dllimports = self.cstore.dllimport_foreign_items.borrow_mut();\n-        for id in self.get_foreign_items_of_kind(cstore::NativeUnknown) {\n-            dllimports.insert(id);\n-        }\n-    }\n-\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n@@ -1152,84 +1073,6 @@ impl<'a> CrateLoader<'a> {\n     }\n }\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn preprocess(&mut self, krate: &ast::Crate) {\n-        for attr in &krate.attrs {\n-            if attr.path == \"link_args\" {\n-                if let Some(linkarg) = attr.value_str() {\n-                    self.cstore.add_used_link_args(&linkarg.as_str());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod,\n-                           definitions: &Definitions) {\n-        if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n-            return;\n-        }\n-\n-        // First, add all of the custom #[link_args] attributes\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n-            if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg.as_str());\n-            }\n-        }\n-\n-        // Next, process all of the #[link(..)]-style arguments\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link\")) {\n-            let items = match m.meta_item_list() {\n-                Some(item) => item,\n-                None => continue,\n-            };\n-            let kind = items.iter().find(|k| {\n-                k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n-            let kind = match kind.as_ref().map(|s| &s[..]) {\n-                Some(\"static\") => cstore::NativeStatic,\n-                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n-                Some(\"dylib\") => cstore::NativeUnknown,\n-                Some(\"framework\") => cstore::NativeFramework,\n-                Some(k) => {\n-                    struct_span_err!(self.sess, m.span, E0458,\n-                              \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, \"unknown kind\").emit();\n-                    cstore::NativeUnknown\n-                }\n-                None => cstore::NativeUnknown\n-            };\n-            let n = items.iter().find(|n| {\n-                n.check_name(\"name\")\n-            }).and_then(|a| a.value_str());\n-            let n = match n {\n-                Some(n) => n,\n-                None => {\n-                    struct_span_err!(self.sess, m.span, E0459,\n-                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, \"missing `name` argument\").emit();\n-                    Symbol::intern(\"foo\")\n-                }\n-            };\n-            let cfg = items.iter().find(|k| {\n-                k.check_name(\"cfg\")\n-            }).and_then(|a| a.meta_item_list());\n-            let cfg = cfg.map(|list| {\n-                list[0].meta_item().unwrap().clone()\n-            });\n-            let foreign_items = fm.items.iter()\n-                .map(|it| definitions.opt_def_index(it.id).unwrap())\n-                .collect();\n-            let lib = NativeLibrary {\n-                name: n,\n-                kind,\n-                cfg,\n-                foreign_items,\n-            };\n-            register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n-        }\n-    }\n-}\n-\n impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     fn postprocess(&mut self, krate: &ast::Crate) {\n         // inject the sanitizer runtime before the allocator runtime because all\n@@ -1242,72 +1085,10 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         if log_enabled!(log::LogLevel::Info) {\n             dump_crates(&self.cstore);\n         }\n-\n-        // Process libs passed on the command line\n-        // First, check for errors\n-        let mut renames = FxHashSet();\n-        for &(ref name, ref new_name, _) in &self.sess.opts.libs {\n-            if let &Some(ref new_name) = new_name {\n-                if new_name.is_empty() {\n-                    self.sess.err(\n-                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n-                } else if !self.cstore.get_used_libraries().borrow().iter()\n-                                                           .any(|lib| lib.name == name as &str) {\n-                    self.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n-                                            however this crate contains no #[link(...)] \\\n-                                            attributes referencing this library.\", name));\n-                } else if renames.contains(name) {\n-                    self.sess.err(&format!(\"multiple renamings were specified for library `{}` .\",\n-                                            name));\n-                } else {\n-                    renames.insert(name);\n-                }\n-            }\n-        }\n-        // Update kind and, optionally, the name of all native libaries\n-        // (there may be more than one) with the specified name.\n-        for &(ref name, ref new_name, kind) in &self.sess.opts.libs {\n-            let mut found = false;\n-            for lib in self.cstore.get_used_libraries().borrow_mut().iter_mut() {\n-                if lib.name == name as &str {\n-                    let mut changed = false;\n-                    if let Some(k) = kind {\n-                        lib.kind = k;\n-                        changed = true;\n-                    }\n-                    if let &Some(ref new_name) = new_name {\n-                        lib.name = Symbol::intern(new_name);\n-                        changed = true;\n-                    }\n-                    if !changed {\n-                        self.sess.warn(&format!(\"redundant linker flag specified for library `{}`\",\n-                                                name));\n-                    }\n-\n-                    found = true;\n-                }\n-            }\n-            if !found {\n-                // Add if not found\n-                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n-                let lib = NativeLibrary {\n-                    name: Symbol::intern(new_name.unwrap_or(name)),\n-                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n-                    cfg: None,\n-                    foreign_items: Vec::new(),\n-                };\n-                register_native_lib(self.sess, self.cstore, None, lib);\n-            }\n-        }\n-        self.register_statically_included_foreign_items();\n-        self.register_dllimport_foreign_items();\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ForeignMod(ref fm) => {\n-                self.process_foreign_mod(item, fm, definitions)\n-            },\n             ast::ItemKind::ExternCrate(_) => {\n                 let info = self.extract_crate_info(item).unwrap();\n                 let (cnum, ..) = self.resolve_crate("}, {"sha": "543d257018d0aaf0b03dd3735d9c2a728daba439", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -14,7 +14,7 @@\n use schema::{self, Tracked};\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n@@ -95,10 +95,6 @@ pub struct CStore {\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_libraries: RefCell<Vec<NativeLibrary>>,\n-    used_link_args: RefCell<Vec<String>>,\n-    statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n     pub metadata_loader: Box<MetadataLoader>,\n }\n@@ -109,10 +105,6 @@ impl CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n-            used_libraries: RefCell::new(Vec::new()),\n-            used_link_args: RefCell::new(Vec::new()),\n-            statically_included_foreign_items: RefCell::new(FxHashSet()),\n-            dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n             metadata_loader,\n         }\n@@ -208,38 +200,10 @@ impl CStore {\n         libs\n     }\n \n-    pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.as_str().is_empty());\n-        self.used_libraries.borrow_mut().push(lib);\n-    }\n-\n-    pub fn get_used_libraries(&self) -> &RefCell<Vec<NativeLibrary>> {\n-        &self.used_libraries\n-    }\n-\n-    pub fn add_used_link_args(&self, args: &str) {\n-        for s in args.split(' ').filter(|s| !s.is_empty()) {\n-            self.used_link_args.borrow_mut().push(s.to_string());\n-        }\n-    }\n-\n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String>> {\n-        &self.used_link_args\n-    }\n-\n     pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn add_statically_included_foreign_item(&self, id: DefIndex) {\n-        self.statically_included_foreign_items.borrow_mut().insert(id);\n-    }\n-\n-    pub fn do_is_statically_included_foreign_item(&self, def_id: DefId) -> bool {\n-        assert!(def_id.krate == LOCAL_CRATE);\n-        self.statically_included_foreign_items.borrow().contains(&def_id.index)\n-    }\n-\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }"}, {"sha": "3f7a314c755d60403ab544146c124de31aceef0a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -10,19 +10,21 @@\n \n use cstore;\n use encoder;\n+use link_args;\n+use native_libs;\n use schema;\n \n use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            NativeLibrary, MetadataLoader, LinkMeta,\n+                            MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata,\n-                            EncodedMetadataHashes};\n+                            EncodedMetadataHashes, NativeLibraryKind};\n use rustc::hir::def;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n@@ -199,6 +201,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         cdata.get_implementations_for_trait(None, &tcx.dep_graph, &mut result);\n         Rc::new(result)\n     }\n+\n+    is_dllimport_foreign_item => {\n+        cdata.is_dllimport_foreign_item(def_id.index, &tcx.dep_graph)\n+    }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -215,6 +221,31 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n \n     *providers = Providers {\n         is_const_fn,\n+        is_dllimport_foreign_item: |tcx, id| {\n+            tcx.native_library_kind(id) == Some(NativeLibraryKind::NativeUnknown)\n+        },\n+        is_statically_included_foreign_item: |tcx, id| {\n+            match tcx.native_library_kind(id) {\n+                Some(NativeLibraryKind::NativeStatic) |\n+                Some(NativeLibraryKind::NativeStaticNobundle) => true,\n+                _ => false,\n+            }\n+        },\n+        native_library_kind: |tcx, id| {\n+            tcx.native_libraries(id.krate)\n+                .iter()\n+                .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n+                .find(|l| l.foreign_items.contains(&id.index))\n+                .map(|l| l.kind)\n+        },\n+        native_libraries: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(native_libs::collect(tcx))\n+        },\n+        link_args: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(link_args::collect(tcx))\n+        },\n         ..*providers\n     };\n }\n@@ -244,20 +275,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n-    {\n-        self.do_is_statically_included_foreign_item(def_id)\n-    }\n-\n-    fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n-        if def_id.krate == LOCAL_CRATE {\n-            self.dllimport_foreign_items.borrow().contains(&def_id.index)\n-        } else {\n-            self.get_crate_data(def_id.krate)\n-                .is_dllimport_foreign_item(def_id.index, &self.dep_graph)\n-        }\n-    }\n-\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind\n     {\n         let data = self.get_crate_data(cnum);\n@@ -400,15 +417,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn used_libraries(&self) -> Vec<NativeLibrary>\n-    {\n-        self.get_used_libraries().borrow().clone()\n-    }\n-\n-    fn used_link_args(&self) -> Vec<String>\n-    {\n-        self.get_used_link_args().borrow().clone()\n-    }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)"}, {"sha": "8ff2acbac9d5fc45a90593952bd10fc3165ee428", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -14,7 +14,7 @@ register_long_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n-```compile_fail,E0454\n+```ignore (cannot-test-this-because-???)\n #[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n ```\n \n@@ -51,7 +51,7 @@ https://doc.rust-lang.org/book/first-edition/conditional-compilation.html\n E0458: r##\"\n An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n-```compile_fail,E0458\n+```ignore (cannot-test-this-because-???)\n #[link(kind = \"wonderful_unicorn\")] extern {}\n // error: unknown kind: `wonderful_unicorn`\n ```\n@@ -67,7 +67,7 @@ Please specify a valid \"kind\" value, from one of the following:\n E0459: r##\"\n A link was used without a name parameter. Erroneous code example:\n \n-```compile_fail,E0459\n+```ignore (cannot-test-this-because-???)\n #[link(kind = \"dylib\")] extern {}\n // error: #[link(...)] specified without `name = \"foo\"`\n ```"}, {"sha": "4fd610ac79b82f176383201490d913512fde24bd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -1283,8 +1283,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n-        let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries)\n+        let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n+        self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n     fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {"}, {"sha": "54dbb68667b3a4aabeb268103806471d1b88bbf5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -50,6 +50,8 @@ mod decoder;\n mod cstore_impl;\n mod isolated_encoder;\n mod schema;\n+mod native_libs;\n+mod link_args;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "6fafde0d09c16f04e8f2e62e6a071db442cbc2c1", "filename": "src/librustc_metadata/link_args.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n+use syntax::abi::Abi;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n+    let mut collector = Collector {\n+        args: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+\n+    for attr in tcx.hir.krate().attrs.iter() {\n+        if attr.path == \"link_args\" {\n+            if let Some(linkarg) = attr.value_str() {\n+                collector.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    return collector.args\n+}\n+\n+struct Collector {\n+    args: Vec<String>,\n+}\n+\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // First, add all of the custom #[link_args] attributes\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+            if let Some(linkarg) = m.value_str() {\n+                self.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl Collector {\n+    fn add_link_args(&mut self, args: &str) {\n+        self.args.extend(args.split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n+    }\n+}"}, {"sha": "669681d2aadde5ea71d462fedc11bdba0ef761e5", "filename": "src/librustc_metadata/native_libs.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::middle::cstore::{self, NativeLibrary};\n+use rustc::session::Session;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::abi::Abi;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::feature_gate::{self, GateIssue};\n+use syntax::symbol::Symbol;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+    let mut collector = Collector {\n+        tcx,\n+        libs: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    collector.process_command_line();\n+    return collector.libs\n+}\n+\n+pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+struct Collector<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    libs: Vec<NativeLibrary>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // Process all of the #[link(..)]-style arguments\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+            let items = match m.meta_item_list() {\n+                Some(item) => item,\n+                None => continue,\n+            };\n+            let kind = items.iter().find(|k| {\n+                k.check_name(\"kind\")\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n+            let kind = match kind.as_ref().map(|s| &s[..]) {\n+                Some(\"static\") => cstore::NativeStatic,\n+                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n+                Some(\"dylib\") => cstore::NativeUnknown,\n+                Some(\"framework\") => cstore::NativeFramework,\n+                Some(k) => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0458,\n+                              \"unknown kind: `{}`\", k)\n+                        .span_label(m.span, \"unknown kind\").emit();\n+                    cstore::NativeUnknown\n+                }\n+                None => cstore::NativeUnknown\n+            };\n+            let n = items.iter().find(|n| {\n+                n.check_name(\"name\")\n+            }).and_then(|a| a.value_str());\n+            let n = match n {\n+                Some(n) => n,\n+                None => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0459,\n+                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n+                        .span_label(m.span, \"missing `name` argument\").emit();\n+                    Symbol::intern(\"foo\")\n+                }\n+            };\n+            let cfg = items.iter().find(|k| {\n+                k.check_name(\"cfg\")\n+            }).and_then(|a| a.meta_item_list());\n+            let cfg = cfg.map(|list| {\n+                list[0].meta_item().unwrap().clone()\n+            });\n+            let foreign_items = fm.items.iter()\n+                .map(|it| self.tcx.hir.local_def_id(it.id).index)\n+                .collect();\n+            let lib = NativeLibrary {\n+                name: n,\n+                kind,\n+                cfg,\n+                foreign_items,\n+            };\n+            self.register_native_lib(Some(m.span), lib);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl<'a, 'tcx> Collector<'a, 'tcx> {\n+    fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n+        if lib.name.as_str().is_empty() {\n+            match span {\n+                Some(span) => {\n+                    struct_span_err!(self.tcx.sess, span, E0454,\n+                                     \"#[link(name = \\\"\\\")] given with empty name\")\n+                        .span_label(span, \"empty name given\")\n+                        .emit();\n+                }\n+                None => {\n+                    self.tcx.sess.err(\"empty library name given via `-l`\");\n+                }\n+            }\n+            return\n+        }\n+        let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n+        if lib.kind == cstore::NativeFramework && !is_osx {\n+            let msg = \"native frameworks are only available on macOS targets\";\n+            match span {\n+                Some(span) => span_err!(self.tcx.sess, span, E0455, \"{}\", msg),\n+                None => self.tcx.sess.err(msg),\n+            }\n+        }\n+        if lib.cfg.is_some() && !self.tcx.sess.features.borrow().link_cfg {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"link_cfg\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"is feature gated\");\n+        }\n+        if lib.kind == cstore::NativeStaticNobundle &&\n+           !self.tcx.sess.features.borrow().static_nobundle {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"static_nobundle\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"kind=\\\"static-nobundle\\\" is feature gated\");\n+        }\n+        self.libs.push(lib);\n+    }\n+\n+    // Process libs passed on the command line\n+    fn process_command_line(&mut self) {\n+        // First, check for errors\n+        let mut renames = FxHashSet();\n+        for &(ref name, ref new_name, _) in &self.tcx.sess.opts.libs {\n+            if let &Some(ref new_name) = new_name {\n+                if new_name.is_empty() {\n+                    self.tcx.sess.err(\n+                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n+                } else if !self.libs.iter().any(|lib| lib.name == name as &str) {\n+                    self.tcx.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n+                                                however this crate contains no #[link(...)] \\\n+                                                attributes referencing this library.\", name));\n+                } else if renames.contains(name) {\n+                    self.tcx.sess.err(&format!(\"multiple renamings were \\\n+                                                specified for library `{}` .\",\n+                                               name));\n+                } else {\n+                    renames.insert(name);\n+                }\n+            }\n+        }\n+\n+        // Update kind and, optionally, the name of all native libaries\n+        // (there may be more than one) with the specified name.\n+        for &(ref name, ref new_name, kind) in &self.tcx.sess.opts.libs {\n+            let mut found = false;\n+            for lib in self.libs.iter_mut() {\n+                if lib.name == name as &str {\n+                    let mut changed = false;\n+                    if let Some(k) = kind {\n+                        lib.kind = k;\n+                        changed = true;\n+                    }\n+                    if let &Some(ref new_name) = new_name {\n+                        lib.name = Symbol::intern(new_name);\n+                        changed = true;\n+                    }\n+                    if !changed {\n+                        let msg = format!(\"redundant linker flag specified for \\\n+                                           library `{}`\", name);\n+                        self.tcx.sess.warn(&msg);\n+                    }\n+\n+                    found = true;\n+                }\n+            }\n+            if !found {\n+                // Add if not found\n+                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n+                let lib = NativeLibrary {\n+                    name: Symbol::intern(new_name.unwrap_or(name)),\n+                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n+                    cfg: None,\n+                    foreign_items: Vec::new(),\n+                };\n+                self.register_native_lib(None, lib);\n+            }\n+        }\n+    }\n+}"}, {"sha": "d5d980da39f5090ef7a153b02fb04791cf6a0ba6", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -431,7 +431,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // feature then we'll need to figure out how to record what objects were\n     // loaded from the libraries found here and then encode that into the\n     // metadata of the rlib we're generating somehow.\n-    for lib in sess.cstore.used_libraries() {\n+    for lib in trans.crate_info.used_libraries.iter() {\n         match lib.kind {\n             NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeStaticNobundle |\n@@ -930,7 +930,7 @@ fn link_args(cmd: &mut Linker,\n         cmd.gc_sections(keep_metadata);\n     }\n \n-    let used_link_args = sess.cstore.used_link_args();\n+    let used_link_args = &trans.crate_info.link_args;\n \n     if crate_type == config::CrateTypeExecutable &&\n        t.options.position_independent_executables {\n@@ -1000,7 +1000,7 @@ fn link_args(cmd: &mut Linker,\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g. other native deps).\n-    add_local_native_libraries(cmd, sess);\n+    add_local_native_libraries(cmd, sess, trans);\n     add_upstream_rust_crates(cmd, sess, trans, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess, trans, crate_type);\n \n@@ -1057,15 +1057,17 @@ fn link_args(cmd: &mut Linker,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Linker,\n+                              sess: &Session,\n+                              trans: &CrateTranslation) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n             PathKind::Framework => { cmd.framework_path(path); }\n             _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n     });\n \n-    let relevant_libs = sess.cstore.used_libraries().into_iter().filter(|l| {\n+    let relevant_libs = trans.crate_info.used_libraries.iter().filter(|l| {\n         relevant_lib(sess, l)\n     });\n "}, {"sha": "28929afc281d696addeadeae8f7c73ef8091195e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -905,7 +905,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(..) => {\n                 let def_id = tcx.hir.local_def_id(id);\n-                tcx.sess.cstore.is_statically_included_foreign_item(def_id)\n+                tcx.is_statically_included_foreign_item(def_id)\n             }\n \n             // Only consider nodes that actually have exported symbols.\n@@ -1516,6 +1516,8 @@ impl CrateInfo {\n             sanitizer_runtime: None,\n             is_no_builtins: FxHashSet(),\n             native_libraries: FxHashMap(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n         };\n \n         for cnum in tcx.sess.cstore.crates() {\n@@ -1537,6 +1539,7 @@ impl CrateInfo {\n             }\n         }\n \n+\n         return info\n     }\n }"}, {"sha": "71d476c31ac3314f4ddc6cfe36a47eb85c33b479", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -125,7 +125,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         if ccx.use_dll_storage_attrs() &&\n-            ccx.sess().cstore.is_dllimport_foreign_item(instance_def_id)\n+            tcx.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "282e960aab3029b2f98c71c403949c69ee2ffda8", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -211,7 +211,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n+    if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n         // For foreign (native) libs we know the exact storage type to use.\n         unsafe {\n             llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);"}, {"sha": "babc030b59c9272525d548591e17d4c9da5ab31d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -234,6 +234,8 @@ pub struct CrateInfo {\n     sanitizer_runtime: Option<CrateNum>,\n     is_no_builtins: FxHashSet<CrateNum>,\n     native_libraries: FxHashMap<CrateNum, Rc<Vec<NativeLibrary>>>,\n+    used_libraries: Rc<Vec<NativeLibrary>>,\n+    link_args: Rc<Vec<String>>,\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "20e0f9cd0b2516d6dbffee47c3e09f8b0196a009", "filename": "src/test/compile-fail/empty-linkname.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -11,3 +11,5 @@\n #[link(name = \"\")] //~ ERROR: given with empty name\n extern {\n }\n+\n+fn main() {}"}, {"sha": "0d13a4937c468ccb397a1e8cefe68687e4709323", "filename": "src/test/compile-fail/feature-gate-static-nobundle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a70342e67f09b5326538b08990d1b0d2900a5b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs?ref=64a70342e67f09b5326538b08990d1b0d2900a5b", "patch": "@@ -11,3 +11,5 @@\n #[link(name=\"foo\", kind=\"static-nobundle\")]\n //~^ ERROR: kind=\"static-nobundle\" is feature gated\n extern {}\n+\n+fn main() {}"}]}