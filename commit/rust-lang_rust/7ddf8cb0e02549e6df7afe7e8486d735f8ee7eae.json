{"sha": "7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZGY4Y2IwZTAyNTQ5ZTZkZjdhZmU3ZTg0ODZkNzM1ZjhlZTdlYWU=", "commit": {"author": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-09-03T21:56:35Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-11-08T01:49:40Z"}, "message": "libtime: alter strftime to use a TmFmt\n\nThe internals of strftime were converted to use a single formatter,\ninstead of creating and concatenating a bunch of small strings. This\nshowed ~3x improvement in the benches.\n\nAlso, since the formatted time may be going straight to a Writer, TmFmt\nwas introduced, and is returned from all formatting methods on Tm. This\nallows the saving of another string allocation. Anyone wanting a String\ncan just call .to_string() on the returned value.\n\n[breaking-change]", "tree": {"sha": "52efef8f11f9d34186d16cbc876cbe885bb2557e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52efef8f11f9d34186d16cbc876cbe885bb2557e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae", "html_url": "https://github.com/rust-lang/rust/commit/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee56c9a5febad45865b7d41422b7ae4d996fcaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee56c9a5febad45865b7d41422b7ae4d996fcaa", "html_url": "https://github.com/rust-lang/rust/commit/6ee56c9a5febad45865b7d41422b7ae4d996fcaa"}], "stats": {"total": 774, "additions": 454, "deletions": 320}, "files": [{"sha": "bbe6002717c8f2ada9ee8718ee15d814e5dfd6c9", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 454, "deletions": 320, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae", "patch": "@@ -343,72 +343,83 @@ impl Tm {\n     }\n \n     /**\n-     * Returns a time string formatted according to the `asctime` format in ISO\n+     * Returns a TmFmt that outputs according to the `asctime` format in ISO\n      * C, in the local timezone.\n      *\n      * Example: \"Thu Jan  1 00:00:00 1970\"\n      */\n-    pub fn ctime(&self) -> String {\n-        self.to_local().asctime()\n+    pub fn ctime(&self) -> TmFmt {\n+        TmFmt {\n+            tm: self,\n+            format: FmtCtime,\n+        }\n     }\n \n     /**\n-     * Returns a time string formatted according to the `asctime` format in ISO\n+     * Returns a TmFmt that outputs according to the `asctime` format in ISO\n      * C.\n      *\n      * Example: \"Thu Jan  1 00:00:00 1970\"\n      */\n-    pub fn asctime(&self) -> String {\n-        self.strftime(\"%c\").unwrap()\n+    pub fn asctime(&self) -> TmFmt {\n+        TmFmt {\n+            tm: self,\n+            format: FmtStr(\"%c\"),\n+        }\n     }\n \n     /// Formats the time according to the format string.\n-    #[inline(always)]\n-    pub fn strftime(&self, format: &str) -> Result<String, ParseError> {\n-        strftime(format, self)\n+    pub fn strftime<'a>(&'a self, format: &'a str) -> Result<TmFmt<'a>, ParseError> {\n+        validate_format(TmFmt {\n+            tm: self,\n+            format: FmtStr(format),\n+        })\n     }\n \n     /**\n-     * Returns a time string formatted according to RFC 822.\n+     * Returns a TmFmt that outputs according to RFC 822.\n      *\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 GMT\"\n      */\n-    pub fn rfc822(&self) -> String {\n+    pub fn rfc822(&self) -> TmFmt {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%a, %d %b %Y %T GMT\").unwrap()\n+            TmFmt {\n+                tm: self,\n+                format: FmtStr(\"%a, %d %b %Y %T GMT\"),\n+            }\n         } else {\n-            self.strftime(\"%a, %d %b %Y %T %Z\").unwrap()\n+            TmFmt {\n+                tm: self,\n+                format: FmtStr(\"%a, %d %b %Y %T %Z\"),\n+            }\n         }\n     }\n \n     /**\n-     * Returns a time string formatted according to RFC 822 with Zulu time.\n+     * Returns a TmFmt that outputs according to RFC 822 with Zulu time.\n      *\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pub fn rfc822z(&self) -> String {\n-        self.strftime(\"%a, %d %b %Y %T %z\").unwrap()\n+    pub fn rfc822z(&self) -> TmFmt {\n+        TmFmt {\n+            tm: self,\n+            format: FmtStr(\"%a, %d %b %Y %T %z\"),\n+        }\n     }\n \n     /**\n-     * Returns a time string formatted according to RFC 3339. RFC 3339 is\n+     * Returns a TmFmt that outputs according to RFC 3339. RFC 3339 is\n      * compatible with ISO 8601.\n      *\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pub fn rfc3339(&self) -> String {\n-        if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\").unwrap()\n-        } else {\n-            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\").unwrap();\n-            let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-            let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n-            let h = m / 60_i32;\n-            m -= h * 60_i32;\n-            format!(\"{}{}{:02d}:{:02d}\", s, sign, h as int, m as int)\n+    pub fn rfc3339<'a>(&'a self) -> TmFmt {\n+        TmFmt {\n+            tm: self,\n+            format: FmtRfc3339,\n         }\n     }\n }\n@@ -452,6 +463,352 @@ impl Show for ParseError {\n     }\n }\n \n+/// A wrapper around a `Tm` and format string that implements Show.\n+pub struct TmFmt<'a> {\n+    tm: &'a Tm,\n+    format: Fmt<'a>\n+}\n+\n+enum Fmt<'a> {\n+    FmtStr(&'a str),\n+    FmtRfc3339,\n+    FmtCtime,\n+}\n+\n+fn validate_format<'a>(fmt: TmFmt<'a>) -> Result<TmFmt<'a>, ParseError> {\n+\n+    match (fmt.tm.tm_wday, fmt.tm.tm_mon) {\n+        (0...6, 0...11) => (),\n+        (_wday, 0...11) => return Err(InvalidDayOfWeek),\n+        (0...6, _mon) => return Err(InvalidMonth),\n+        _ => return Err(InvalidDay)\n+    }\n+    match fmt.format {\n+        FmtStr(ref s) => {\n+            let mut chars = s.chars();\n+            loop {\n+                match chars.next() {\n+                    Some('%') => {\n+                        match chars.next() {\n+                            Some('A') |\n+                            Some('a') |\n+                            Some('B') |\n+                            Some('b') |\n+                            Some('C') |\n+                            Some('c') |\n+                            Some('D') |\n+                            Some('d') |\n+                            Some('e') |\n+                            Some('F') |\n+                            Some('f') |\n+                            Some('G') |\n+                            Some('g') |\n+                            Some('H') |\n+                            Some('h') |\n+                            Some('I') |\n+                            Some('j') |\n+                            Some('k') |\n+                            Some('l') |\n+                            Some('M') |\n+                            Some('m') |\n+                            Some('n') |\n+                            Some('P') |\n+                            Some('p') |\n+                            Some('R') |\n+                            Some('r') |\n+                            Some('S') |\n+                            Some('s') |\n+                            Some('T') |\n+                            Some('t') |\n+                            Some('U') |\n+                            Some('u') |\n+                            Some('V') |\n+                            Some('v') |\n+                            Some('W') |\n+                            Some('w') |\n+                            Some('X') |\n+                            Some('x') |\n+                            Some('Y') |\n+                            Some('y') |\n+                            Some('Z') |\n+                            Some('z') |\n+                            Some('+') |\n+                            Some('%')\n+                                => (),\n+                            Some(c) => return Err(InvalidFormatSpecifier(c)),\n+                            None => return Err(MissingFormatConverter),\n+                        }\n+                    },\n+                    None => break,\n+                    _ => ()\n+                }\n+            }\n+        },\n+        _ => ()\n+    }\n+    Ok(fmt)\n+}\n+\n+impl<'a> fmt::Show for TmFmt<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fn days_in_year(year: int) -> i32 {\n+            if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n+                366    /* Days in a leap year */\n+            } else {\n+                365    /* Days in a non-leap year */\n+            }\n+        }\n+\n+        fn iso_week_days(yday: i32, wday: i32) -> int {\n+            /* The number of days from the first day of the first ISO week of this\n+            * year to the year day YDAY with week day WDAY.\n+            * ISO weeks start on Monday. The first ISO week has the year's first\n+            * Thursday.\n+            * YDAY may be as small as yday_minimum.\n+            */\n+            let yday: int = yday as int;\n+            let wday: int = wday as int;\n+            let iso_week_start_wday: int = 1;                     /* Monday */\n+            let iso_week1_wday: int = 4;                          /* Thursday */\n+            let yday_minimum: int = 366;\n+            /* Add enough to the first operand of % to make it nonnegative. */\n+            let big_enough_multiple_of_7: int = (yday_minimum / 7 + 2) * 7;\n+\n+            yday - (yday - wday + iso_week1_wday + big_enough_multiple_of_7) % 7\n+                + iso_week1_wday - iso_week_start_wday\n+        }\n+\n+        fn iso_week(fmt: &mut fmt::Formatter, ch:char, tm: &Tm) -> fmt::Result {\n+            let mut year: int = tm.tm_year as int + 1900;\n+            let mut days: int = iso_week_days (tm.tm_yday, tm.tm_wday);\n+\n+            if days < 0 {\n+                /* This ISO week belongs to the previous year. */\n+                year -= 1;\n+                days = iso_week_days (tm.tm_yday + (days_in_year(year)), tm.tm_wday);\n+            } else {\n+                let d: int = iso_week_days (tm.tm_yday - (days_in_year(year)),\n+                                            tm.tm_wday);\n+                if 0 <= d {\n+                    /* This ISO week belongs to the next year. */\n+                    year += 1;\n+                    days = d;\n+                }\n+            }\n+\n+            match ch {\n+                'G' => write!(fmt, \"{}\", year),\n+                'g' => write!(fmt, \"{:02d}\", (year % 100 + 100) % 100),\n+                'V' => write!(fmt, \"{:02d}\", days / 7 + 1),\n+                _ => Ok(())\n+            }\n+        }\n+\n+        fn parse_type(fmt: &mut fmt::Formatter, ch: char, tm: &Tm) -> fmt::Result {\n+            let die = || {\n+                unreachable!()\n+            };\n+            match ch {\n+              'A' => match tm.tm_wday as int {\n+                0 => \"Sunday\",\n+                1 => \"Monday\",\n+                2 => \"Tuesday\",\n+                3 => \"Wednesday\",\n+                4 => \"Thursday\",\n+                5 => \"Friday\",\n+                6 => \"Saturday\",\n+                _ => return die()\n+              },\n+             'a' => match tm.tm_wday as int {\n+                0 => \"Sun\",\n+                1 => \"Mon\",\n+                2 => \"Tue\",\n+                3 => \"Wed\",\n+                4 => \"Thu\",\n+                5 => \"Fri\",\n+                6 => \"Sat\",\n+                _ => return die()\n+              },\n+              'B' => match tm.tm_mon as int {\n+                0 => \"January\",\n+                1 => \"February\",\n+                2 => \"March\",\n+                3 => \"April\",\n+                4 => \"May\",\n+                5 => \"June\",\n+                6 => \"July\",\n+                7 => \"August\",\n+                8 => \"September\",\n+                9 => \"October\",\n+                10 => \"November\",\n+                11 => \"December\",\n+                _ => return die()\n+              },\n+              'b' | 'h' => match tm.tm_mon as int {\n+                0 => \"Jan\",\n+                1 => \"Feb\",\n+                2 => \"Mar\",\n+                3 => \"Apr\",\n+                4 => \"May\",\n+                5 => \"Jun\",\n+                6 => \"Jul\",\n+                7 => \"Aug\",\n+                8 => \"Sep\",\n+                9 => \"Oct\",\n+                10 => \"Nov\",\n+                11 => \"Dec\",\n+                _  => return die()\n+              },\n+              'C' => return write!(fmt, \"{:02d}\", (tm.tm_year as int + 1900) / 100),\n+              'c' => {\n+                    try!(parse_type(fmt, 'a', tm));\n+                    try!(' '.fmt(fmt));\n+                    try!(parse_type(fmt, 'b', tm));\n+                    try!(' '.fmt(fmt));\n+                    try!(parse_type(fmt, 'e', tm));\n+                    try!(' '.fmt(fmt));\n+                    try!(parse_type(fmt, 'T', tm));\n+                    try!(' '.fmt(fmt));\n+                    return parse_type(fmt, 'Y', tm);\n+              }\n+              'D' | 'x' => {\n+                    try!(parse_type(fmt, 'm', tm));\n+                    try!('/'.fmt(fmt));\n+                    try!(parse_type(fmt, 'd', tm));\n+                    try!('/'.fmt(fmt));\n+                    return parse_type(fmt, 'y', tm);\n+              }\n+              'd' => return write!(fmt, \"{:02d}\", tm.tm_mday),\n+              'e' => return write!(fmt, \"{:2d}\", tm.tm_mday),\n+              'f' => return write!(fmt, \"{:09d}\", tm.tm_nsec),\n+              'F' => {\n+                    try!(parse_type(fmt, 'Y', tm));\n+                    try!('-'.fmt(fmt));\n+                    try!(parse_type(fmt, 'm', tm));\n+                    try!('-'.fmt(fmt));\n+                    return parse_type(fmt, 'd', tm);\n+              }\n+              'G' => return iso_week(fmt, 'G', tm),\n+              'g' => return iso_week(fmt, 'g', tm),\n+              'H' => return write!(fmt, \"{:02d}\", tm.tm_hour),\n+              'I' => {\n+                let mut h = tm.tm_hour;\n+                if h == 0 { h = 12 }\n+                if h > 12 { h -= 12 }\n+                return write!(fmt, \"{:02d}\", h)\n+              }\n+              'j' => return write!(fmt, \"{:03d}\", tm.tm_yday + 1),\n+              'k' => return write!(fmt, \"{:2d}\", tm.tm_hour),\n+              'l' => {\n+                let mut h = tm.tm_hour;\n+                if h == 0 { h = 12 }\n+                if h > 12 { h -= 12 }\n+                return write!(fmt, \"{:2d}\", h)\n+              }\n+              'M' => return write!(fmt, \"{:02d}\", tm.tm_min),\n+              'm' => return write!(fmt, \"{:02d}\", tm.tm_mon + 1),\n+              'n' => \"\\n\",\n+              'P' => if (tm.tm_hour as int) < 12 { \"am\" } else { \"pm\" },\n+              'p' => if (tm.tm_hour as int) < 12 { \"AM\" } else { \"PM\" },\n+              'R' => {\n+                    try!(parse_type(fmt, 'H', tm));\n+                    try!(':'.fmt(fmt));\n+                    return parse_type(fmt, 'M', tm);\n+              }\n+              'r' => {\n+                    try!(parse_type(fmt, 'I', tm));\n+                    try!(':'.fmt(fmt));\n+                    try!(parse_type(fmt, 'M', tm));\n+                    try!(':'.fmt(fmt));\n+                    try!(parse_type(fmt, 'S', tm));\n+                    try!(' '.fmt(fmt));\n+                    return parse_type(fmt, 'p', tm);\n+              }\n+              'S' => return write!(fmt, \"{:02d}\", tm.tm_sec),\n+              's' => return write!(fmt, \"{}\", tm.to_timespec().sec),\n+              'T' | 'X' => {\n+                    try!(parse_type(fmt, 'H', tm));\n+                    try!(':'.fmt(fmt));\n+                    try!(parse_type(fmt, 'M', tm));\n+                    try!(':'.fmt(fmt));\n+                    return parse_type(fmt, 'S', tm);\n+              }\n+              't' => \"\\t\",\n+              'U' => return write!(fmt, \"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n+              'u' => {\n+                let i = tm.tm_wday as int;\n+                return (if i == 0 { 7 } else { i }).fmt(fmt);\n+              }\n+              'V' => return iso_week(fmt, 'V', tm),\n+              'v' => {\n+                  try!(parse_type(fmt, 'e', tm));\n+                  try!('-'.fmt(fmt));\n+                  try!(parse_type(fmt, 'b', tm));\n+                  try!('-'.fmt(fmt));\n+                  return parse_type(fmt, 'Y', tm);\n+              }\n+              'W' => {\n+                  return write!(fmt, \"{:02d}\",\n+                                 (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n+              }\n+              'w' => return (tm.tm_wday as int).fmt(fmt),\n+              'Y' => return (tm.tm_year as int + 1900).fmt(fmt),\n+              'y' => return write!(fmt, \"{:02d}\", (tm.tm_year as int + 1900) % 100),\n+              'Z' => if tm.tm_gmtoff == 0_i32 { \"GMT\"} else { \"\" }, // FIXME (#2350): support locale\n+              'z' => {\n+                let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n+                let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n+                let h = m / 60_i32;\n+                m -= h * 60_i32;\n+                return write!(fmt, \"{}{:02d}{:02d}\", sign, h, m);\n+              }\n+              '+' => return tm.rfc3339().fmt(fmt),\n+              '%' => \"%\",\n+              _   => return die()\n+            }.fmt(fmt)\n+        }\n+\n+        match self.format {\n+            FmtStr(ref s) => {\n+                let mut chars = s.chars();\n+                loop {\n+                    match chars.next() {\n+                        Some('%') => {\n+                            // we've already validated that % always precedes another char\n+                            try!(parse_type(fmt, chars.next().unwrap(), self.tm));\n+                        }\n+                        Some(ch) => try!(ch.fmt(fmt)),\n+                        None => break,\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+            FmtCtime => {\n+                self.tm.to_local().asctime().fmt(fmt)\n+            }\n+            FmtRfc3339 => {\n+                if self.tm.tm_gmtoff == 0_i32 {\n+                    TmFmt {\n+                        tm: self.tm,\n+                        format: FmtStr(\"%Y-%m-%dT%H:%M:%SZ\"),\n+                    }.fmt(fmt)\n+                } else {\n+                    let s = TmFmt {\n+                        tm: self.tm,\n+                        format: FmtStr(\"%Y-%m-%dT%H:%M:%S\"),\n+                    };\n+                    let sign = if self.tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n+                    let mut m = num::abs(self.tm.tm_gmtoff) / 60_i32;\n+                    let h = m / 60_i32;\n+                    m -= h * 60_i32;\n+                    write!(fmt, \"{}{}{:02d}:{:02d}\", s, sign, h as int, m as int)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Parses the time from the string according to the format string.\n pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n@@ -908,243 +1265,15 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n \n /// Formats the time according to the format string.\n pub fn strftime(format: &str, tm: &Tm) -> Result<String, ParseError> {\n-    fn days_in_year(year: int) -> i32 {\n-        if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n-            366    /* Days in a leap year */\n-        } else {\n-            365    /* Days in a non-leap year */\n-        }\n-    }\n-\n-    fn iso_week_days(yday: i32, wday: i32) -> int {\n-        /* The number of days from the first day of the first ISO week of this\n-        * year to the year day YDAY with week day WDAY.\n-        * ISO weeks start on Monday. The first ISO week has the year's first\n-        * Thursday.\n-        * YDAY may be as small as yday_minimum.\n-        */\n-        let yday: int = yday as int;\n-        let wday: int = wday as int;\n-        let iso_week_start_wday: int = 1;                     /* Monday */\n-        let iso_week1_wday: int = 4;                          /* Thursday */\n-        let yday_minimum: int = 366;\n-        /* Add enough to the first operand of % to make it nonnegative. */\n-        let big_enough_multiple_of_7: int = (yday_minimum / 7 + 2) * 7;\n-\n-        yday - (yday - wday + iso_week1_wday + big_enough_multiple_of_7) % 7\n-            + iso_week1_wday - iso_week_start_wday\n-    }\n-\n-    fn iso_week(ch:char, tm: &Tm) -> String {\n-        let mut year: int = tm.tm_year as int + 1900;\n-        let mut days: int = iso_week_days (tm.tm_yday, tm.tm_wday);\n-\n-        if days < 0 {\n-            /* This ISO week belongs to the previous year. */\n-            year -= 1;\n-            days = iso_week_days (tm.tm_yday + (days_in_year(year)), tm.tm_wday);\n-        } else {\n-            let d: int = iso_week_days (tm.tm_yday - (days_in_year(year)),\n-                                        tm.tm_wday);\n-            if 0 <= d {\n-                /* This ISO week belongs to the next year. */\n-                year += 1;\n-                days = d;\n-            }\n-        }\n-\n-        match ch {\n-            'G' => format!(\"{}\", year),\n-            'g' => format!(\"{:02d}\", (year % 100 + 100) % 100),\n-            'V' => format!(\"{:02d}\", days / 7 + 1),\n-            _ => \"\".to_string()\n-        }\n-    }\n-\n-    fn parse_type(ch: char, tm: &Tm) -> Result<String, ParseError> {\n-        match ch {\n-          'A' => match tm.tm_wday as int {\n-            0 => Ok(\"Sunday\".to_string()),\n-            1 => Ok(\"Monday\".to_string()),\n-            2 => Ok(\"Tuesday\".to_string()),\n-            3 => Ok(\"Wednesday\".to_string()),\n-            4 => Ok(\"Thursday\".to_string()),\n-            5 => Ok(\"Friday\".to_string()),\n-            6 => Ok(\"Saturday\".to_string()),\n-            _ => Err(InvalidFormatSpecifier(ch))\n-          },\n-         'a' => match tm.tm_wday as int {\n-            0 => Ok(\"Sun\".to_string()),\n-            1 => Ok(\"Mon\".to_string()),\n-            2 => Ok(\"Tue\".to_string()),\n-            3 => Ok(\"Wed\".to_string()),\n-            4 => Ok(\"Thu\".to_string()),\n-            5 => Ok(\"Fri\".to_string()),\n-            6 => Ok(\"Sat\".to_string()),\n-            _ => Err(InvalidFormatSpecifier(ch))\n-          },\n-          'B' => match tm.tm_mon as int {\n-            0 => Ok(\"January\".to_string()),\n-            1 => Ok(\"February\".to_string()),\n-            2 => Ok(\"March\".to_string()),\n-            3 => Ok(\"April\".to_string()),\n-            4 => Ok(\"May\".to_string()),\n-            5 => Ok(\"June\".to_string()),\n-            6 => Ok(\"July\".to_string()),\n-            7 => Ok(\"August\".to_string()),\n-            8 => Ok(\"September\".to_string()),\n-            9 => Ok(\"October\".to_string()),\n-            10 => Ok(\"November\".to_string()),\n-            11 => Ok(\"December\".to_string()),\n-            _ => Err(InvalidFormatSpecifier(ch))\n-          },\n-          'b' | 'h' => match tm.tm_mon as int {\n-            0 => Ok(\"Jan\".to_string()),\n-            1 => Ok(\"Feb\".to_string()),\n-            2 => Ok(\"Mar\".to_string()),\n-            3 => Ok(\"Apr\".to_string()),\n-            4 => Ok(\"May\".to_string()),\n-            5 => Ok(\"Jun\".to_string()),\n-            6 => Ok(\"Jul\".to_string()),\n-            7 => Ok(\"Aug\".to_string()),\n-            8 => Ok(\"Sep\".to_string()),\n-            9 => Ok(\"Oct\".to_string()),\n-            10 => Ok(\"Nov\".to_string()),\n-            11 => Ok(\"Dec\".to_string()),\n-            _ => Err(InvalidFormatSpecifier(ch))\n-          },\n-          'C' => Ok(format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100)),\n-          'c' => {\n-            Ok(format!(\"{} {} {} {} {}\",\n-                parse_type('a', tm).unwrap(),\n-                parse_type('b', tm).unwrap(),\n-                parse_type('e', tm).unwrap(),\n-                parse_type('T', tm).unwrap(),\n-                parse_type('Y', tm).unwrap()))\n-          }\n-          'D' | 'x' => {\n-            Ok(format!(\"{}/{}/{}\",\n-                parse_type('m', tm).unwrap(),\n-                parse_type('d', tm).unwrap(),\n-                parse_type('y', tm).unwrap()))\n-          }\n-          'd' => Ok(format!(\"{:02d}\", tm.tm_mday)),\n-          'e' => Ok(format!(\"{:2d}\", tm.tm_mday)),\n-          'F' => {\n-            Ok(format!(\"{}-{}-{}\",\n-                parse_type('Y', tm).unwrap(),\n-                parse_type('m', tm).unwrap(),\n-                parse_type('d', tm).unwrap()))\n-          }\n-          'f' => Ok(format!(\"{:09d}\", tm.tm_nsec)),\n-          'G' => Ok(iso_week('G', tm)),\n-          'g' => Ok(iso_week('g', tm)),\n-          'H' => Ok(format!(\"{:02d}\", tm.tm_hour)),\n-          'I' => {\n-            let mut h = tm.tm_hour;\n-            if h == 0 { h = 12 }\n-            if h > 12 { h -= 12 }\n-            Ok(format!(\"{:02d}\", h))\n-          }\n-          'j' => Ok(format!(\"{:03d}\", tm.tm_yday + 1)),\n-          'k' => Ok(format!(\"{:2d}\", tm.tm_hour)),\n-          'l' => {\n-            let mut h = tm.tm_hour;\n-            if h == 0 { h = 12 }\n-            if h > 12 { h -= 12 }\n-            Ok(format!(\"{:2d}\", h))\n-          }\n-          'M' => Ok(format!(\"{:02d}\", tm.tm_min)),\n-          'm' => Ok(format!(\"{:02d}\", tm.tm_mon + 1)),\n-          'n' => Ok(\"\\n\".to_string()),\n-          'P' => Ok(if (tm.tm_hour as int) < 12 { \"am\".to_string() } else { \"pm\".to_string() }),\n-          'p' => Ok(if (tm.tm_hour as int) < 12 { \"AM\".to_string() } else { \"PM\".to_string() }),\n-          'R' => {\n-            Ok(format!(\"{}:{}\",\n-                parse_type('H', tm).unwrap(),\n-                parse_type('M', tm).unwrap()))\n-          }\n-          'r' => {\n-            Ok(format!(\"{}:{}:{} {}\",\n-                parse_type('I', tm).unwrap(),\n-                parse_type('M', tm).unwrap(),\n-                parse_type('S', tm).unwrap(),\n-                parse_type('p', tm).unwrap()))\n-          }\n-          'S' => Ok(format!(\"{:02d}\", tm.tm_sec)),\n-          's' => Ok(format!(\"{}\", tm.to_timespec().sec)),\n-          'T' | 'X' => {\n-            Ok(format!(\"{}:{}:{}\",\n-                parse_type('H', tm).unwrap(),\n-                parse_type('M', tm).unwrap(),\n-                parse_type('S', tm).unwrap()))\n-          }\n-          't' => Ok(\"\\t\".to_string()),\n-          'U' => Ok(format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7)),\n-          'u' => {\n-            let i = tm.tm_wday as int;\n-            Ok((if i == 0 { 7 } else { i }).to_string())\n-          }\n-          'V' => Ok(iso_week('V', tm)),\n-          'v' => {\n-            Ok(format!(\"{}-{}-{}\",\n-                parse_type('e', tm).unwrap(),\n-                parse_type('b', tm).unwrap(),\n-                parse_type('Y', tm).unwrap()))\n-          }\n-          'W' => {\n-              Ok(format!(\"{:02d}\",\n-                         (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7))\n-          }\n-          'w' => Ok((tm.tm_wday as int).to_string()),\n-          'Y' => Ok((tm.tm_year as int + 1900).to_string()),\n-          'y' => Ok(format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100)),\n-          'Z' => Ok(if tm.tm_gmtoff == 0_i32 { \"GMT\".to_string() }\n-                    else { \"\".to_string() }), // FIXME (#2350): support locale\n-          'z' => {\n-            let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-            let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n-            let h = m / 60_i32;\n-            m -= h * 60_i32;\n-            Ok(format!(\"{}{:02d}{:02d}\", sign, h, m))\n-          }\n-          '+' => Ok(tm.rfc3339()),\n-          '%' => Ok(\"%\".to_string()),\n-          _ => Err(InvalidFormatSpecifier(ch))\n-        }\n-    }\n-\n-    let mut buf = Vec::new();\n-\n-    let mut rdr = BufReader::new(format.as_bytes());\n-    loop {\n-        let mut b = [0];\n-        let ch = match rdr.read(b) {\n-            Ok(_) => b[0],\n-            Err(_) => break, // EOF.\n-        };\n-        match ch as char {\n-            '%' => {\n-                if rdr.read(b).is_err() {\n-                    return Err(MissingFormatConverter)\n-                }\n-                match parse_type(b[0] as char, tm) {\n-                    Ok(s) => buf.push_all(s.as_bytes()),\n-                    Err(e) => return Err(e)\n-                }\n-            }\n-            ch => buf.push(ch as u8)\n-        }\n-    }\n-\n-    Ok(String::from_utf8(buf).unwrap())\n+    tm.strftime(format).map(|fmt| fmt.to_string())\n }\n \n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use super::{Timespec, InvalidTime, InvalidYear, InvalidFormatSpecifier, MissingFormatConverter,\n-                get_time, precise_time_ns, precise_time_s, tzset, at_utc, at, strptime};\n+    use super::{Timespec, InvalidTime, InvalidYear, get_time, precise_time_ns,\n+                precise_time_s, tzset, at_utc, at, strptime, MissingFormatConverter,\n+                InvalidFormatSpecifier};\n \n     use std::f64;\n     use std::result::{Err, Ok};\n@@ -1323,7 +1452,9 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format).unwrap() == s.to_string(),\n+              Ok(ref tm) => {\n+                tm.strftime(format).unwrap().to_string() == s.to_string()\n+              },\n               Err(e) => panic!(e)\n             }\n         }\n@@ -1447,8 +1578,8 @@ mod tests {\n \n         debug!(\"test_ctime: {} {}\", utc.asctime(), local.asctime());\n \n-        assert_eq!(utc.asctime(), \"Fri Feb 13 23:31:30 2009\".to_string());\n-        assert_eq!(local.asctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\".to_string());\n+        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n     }\n \n     fn test_ctime() {\n@@ -1460,8 +1591,8 @@ mod tests {\n \n         debug!(\"test_ctime: {} {}\", utc.ctime(), local.ctime());\n \n-        assert_eq!(utc.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n     }\n \n     fn test_strftime() {\n@@ -1471,71 +1602,74 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\").unwrap(), \"\".to_string());\n-        assert_eq!(local.strftime(\"%A\").unwrap(), \"Friday\".to_string());\n-        assert_eq!(local.strftime(\"%a\").unwrap(), \"Fri\".to_string());\n-        assert_eq!(local.strftime(\"%B\").unwrap(), \"February\".to_string());\n-        assert_eq!(local.strftime(\"%b\").unwrap(), \"Feb\".to_string());\n-        assert_eq!(local.strftime(\"%C\").unwrap(), \"20\".to_string());\n-        assert_eq!(local.strftime(\"%c\").unwrap(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.strftime(\"%D\").unwrap(), \"02/13/09\".to_string());\n-        assert_eq!(local.strftime(\"%d\").unwrap(), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%e\").unwrap(), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%F\").unwrap(), \"2009-02-13\".to_string());\n-        assert_eq!(local.strftime(\"%f\").unwrap(), \"000054321\".to_string());\n-        assert_eq!(local.strftime(\"%G\").unwrap(), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%g\").unwrap(), \"09\".to_string());\n-        assert_eq!(local.strftime(\"%H\").unwrap(), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%h\").unwrap(), \"Feb\".to_string());\n-        assert_eq!(local.strftime(\"%I\").unwrap(), \"03\".to_string());\n-        assert_eq!(local.strftime(\"%j\").unwrap(), \"044\".to_string());\n-        assert_eq!(local.strftime(\"%k\").unwrap(), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%l\").unwrap(), \" 3\".to_string());\n-        assert_eq!(local.strftime(\"%M\").unwrap(), \"31\".to_string());\n-        assert_eq!(local.strftime(\"%m\").unwrap(), \"02\".to_string());\n-        assert_eq!(local.strftime(\"%n\").unwrap(), \"\\n\".to_string());\n-        assert_eq!(local.strftime(\"%P\").unwrap(), \"pm\".to_string());\n-        assert_eq!(local.strftime(\"%p\").unwrap(), \"PM\".to_string());\n-        assert_eq!(local.strftime(\"%R\").unwrap(), \"15:31\".to_string());\n-        assert_eq!(local.strftime(\"%r\").unwrap(), \"03:31:30 PM\".to_string());\n-        assert_eq!(local.strftime(\"%S\").unwrap(), \"30\".to_string());\n-        assert_eq!(local.strftime(\"%s\").unwrap(), \"1234567890\".to_string());\n-        assert_eq!(local.strftime(\"%T\").unwrap(), \"15:31:30\".to_string());\n-        assert_eq!(local.strftime(\"%t\").unwrap(), \"\\t\".to_string());\n-        assert_eq!(local.strftime(\"%U\").unwrap(), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%u\").unwrap(), \"5\".to_string());\n-        assert_eq!(local.strftime(\"%V\").unwrap(), \"07\".to_string());\n-        assert_eq!(local.strftime(\"%v\").unwrap(), \"13-Feb-2009\".to_string());\n-        assert_eq!(local.strftime(\"%W\").unwrap(), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%w\").unwrap(), \"5\".to_string());\n+        assert_eq!(local.strftime(\"\").unwrap().to_string(), \"\".to_string());\n+        assert_eq!(local.strftime(\"%A\").unwrap().to_string(), \"Friday\".to_string());\n+        assert_eq!(local.strftime(\"%a\").unwrap().to_string(), \"Fri\".to_string());\n+        assert_eq!(local.strftime(\"%B\").unwrap().to_string(), \"February\".to_string());\n+        assert_eq!(local.strftime(\"%b\").unwrap().to_string(), \"Feb\".to_string());\n+        assert_eq!(local.strftime(\"%C\").unwrap().to_string(), \"20\".to_string());\n+        assert_eq!(local.strftime(\"%c\").unwrap().to_string(),\n+                   \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.strftime(\"%D\").unwrap().to_string(), \"02/13/09\".to_string());\n+        assert_eq!(local.strftime(\"%d\").unwrap().to_string(), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%e\").unwrap().to_string(), \"13\".to_string());\n+        assert_eq!(local.strftime(\"%F\").unwrap().to_string(), \"2009-02-13\".to_string());\n+        assert_eq!(local.strftime(\"%f\").unwrap().to_string(), \"000054321\".to_string());\n+        assert_eq!(local.strftime(\"%G\").unwrap().to_string(), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%g\").unwrap().to_string(), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%H\").unwrap().to_string(), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%h\").unwrap().to_string(), \"Feb\".to_string());\n+        assert_eq!(local.strftime(\"%I\").unwrap().to_string(), \"03\".to_string());\n+        assert_eq!(local.strftime(\"%j\").unwrap().to_string(), \"044\".to_string());\n+        assert_eq!(local.strftime(\"%k\").unwrap().to_string(), \"15\".to_string());\n+        assert_eq!(local.strftime(\"%l\").unwrap().to_string(), \" 3\".to_string());\n+        assert_eq!(local.strftime(\"%M\").unwrap().to_string(), \"31\".to_string());\n+        assert_eq!(local.strftime(\"%m\").unwrap().to_string(), \"02\".to_string());\n+        assert_eq!(local.strftime(\"%n\").unwrap().to_string(), \"\\n\".to_string());\n+        assert_eq!(local.strftime(\"%P\").unwrap().to_string(), \"pm\".to_string());\n+        assert_eq!(local.strftime(\"%p\").unwrap().to_string(), \"PM\".to_string());\n+        assert_eq!(local.strftime(\"%R\").unwrap().to_string(), \"15:31\".to_string());\n+        assert_eq!(local.strftime(\"%r\").unwrap().to_string(), \"03:31:30 PM\".to_string());\n+        assert_eq!(local.strftime(\"%S\").unwrap().to_string(), \"30\".to_string());\n+        assert_eq!(local.strftime(\"%s\").unwrap().to_string(), \"1234567890\".to_string());\n+        assert_eq!(local.strftime(\"%T\").unwrap().to_string(), \"15:31:30\".to_string());\n+        assert_eq!(local.strftime(\"%t\").unwrap().to_string(), \"\\t\".to_string());\n+        assert_eq!(local.strftime(\"%U\").unwrap().to_string(), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%u\").unwrap().to_string(), \"5\".to_string());\n+        assert_eq!(local.strftime(\"%V\").unwrap().to_string(), \"07\".to_string());\n+        assert_eq!(local.strftime(\"%v\").unwrap().to_string(), \"13-Feb-2009\".to_string());\n+        assert_eq!(local.strftime(\"%W\").unwrap().to_string(), \"06\".to_string());\n+        assert_eq!(local.strftime(\"%w\").unwrap().to_string(), \"5\".to_string());\n+        // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%X\").unwrap().to_string(), \"15:31:30\".to_string());\n         // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%X\").unwrap(), \"15:31:30\".to_string());\n+        assert_eq!(local.strftime(\"%x\").unwrap().to_string(), \"02/13/09\".to_string());\n+        assert_eq!(local.strftime(\"%Y\").unwrap().to_string(), \"2009\".to_string());\n+        assert_eq!(local.strftime(\"%y\").unwrap().to_string(), \"09\".to_string());\n         // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\").unwrap(), \"02/13/09\".to_string());\n-        assert_eq!(local.strftime(\"%Y\").unwrap(), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%y\").unwrap(), \"09\".to_string());\n-        assert_eq!(local.strftime(\"%Z\").unwrap(), \"\".to_string()); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%z\").unwrap(), \"-0800\".to_string());\n-        assert_eq!(local.strftime(\"%+\").unwrap(), \"2009-02-13T15:31:30-08:00\".to_string());\n-        assert_eq!(local.strftime(\"%%\").unwrap(), \"%\".to_string());\n-\n-        let invalid_specifiers = [\"%E\", \"%J\", \"%K\", \"%L\", \"%N\", \"%O\", \"%o\", \"%Q\", \"%q\"];\n+        assert_eq!(local.strftime(\"%Z\").unwrap().to_string(), \"\".to_string());\n+        assert_eq!(local.strftime(\"%z\").unwrap().to_string(), \"-0800\".to_string());\n+        assert_eq!(local.strftime(\"%+\").unwrap().to_string(),\n+                   \"2009-02-13T15:31:30-08:00\".to_string());\n+        assert_eq!(local.strftime(\"%%\").unwrap().to_string(), \"%\".to_string());\n+\n+         let invalid_specifiers = [\"%E\", \"%J\", \"%K\", \"%L\", \"%N\", \"%O\", \"%o\", \"%Q\", \"%q\"];\n         for &sp in invalid_specifiers.iter() {\n             assert_eq!(local.strftime(sp).unwrap_err(), InvalidFormatSpecifier(sp.char_at(1)));\n         }\n         assert_eq!(local.strftime(\"%\").unwrap_err(), MissingFormatConverter);\n         assert_eq!(local.strftime(\"%A %\").unwrap_err(), MissingFormatConverter);\n \n-        assert_eq!(local.asctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_string());\n-        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_string());\n+        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(local.rfc822z().to_string(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_string());\n+        assert_eq!(local.rfc3339().to_string(), \"2009-02-13T15:31:30-08:00\".to_string());\n \n-        assert_eq!(utc.asctime(), \"Fri Feb 13 23:31:30 2009\".to_string());\n-        assert_eq!(utc.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_string());\n-        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_string());\n-        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_string());\n+        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\".to_string());\n+        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(utc.rfc822().to_string(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_string());\n+        assert_eq!(utc.rfc822z().to_string(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_string());\n+        assert_eq!(utc.rfc3339().to_string(), \"2009-02-13T23:31:30Z\".to_string());\n     }\n \n     fn test_timespec_eq_ord() {"}]}