{"sha": "24093fc6bd442be45a3ddb935b7056ab77cf96f5", "node_id": "C_kwDOAAsO6NoAKDI0MDkzZmM2YmQ0NDJiZTQ1YTNkZGI5MzViNzA1NmFiNzdjZjk2ZjU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-28T10:58:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-05T11:46:22Z"}, "message": "resolve: More detailed effective visibility tracking for imports\n\nAlso drop `extern` blocks from the effective visibility table, they are nominally private and it doesn't make sense to keep them there.", "tree": {"sha": "86b53fd52bade7275111a8a0adce3fd982b6fdf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86b53fd52bade7275111a8a0adce3fd982b6fdf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24093fc6bd442be45a3ddb935b7056ab77cf96f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24093fc6bd442be45a3ddb935b7056ab77cf96f5", "html_url": "https://github.com/rust-lang/rust/commit/24093fc6bd442be45a3ddb935b7056ab77cf96f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24093fc6bd442be45a3ddb935b7056ab77cf96f5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "452cf4f7109f58433ac38be7d3da527408571054", "url": "https://api.github.com/repos/rust-lang/rust/commits/452cf4f7109f58433ac38be7d3da527408571054", "html_url": "https://github.com/rust-lang/rust/commit/452cf4f7109f58433ac38be7d3da527408571054"}], "stats": {"total": 318, "additions": 212, "deletions": 106}, "files": [{"sha": "3d7a379c56cd1fcdf299f5d7bd3f0e72451336c6", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n+use std::hash::Hash;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -74,9 +75,9 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Default, Clone, Debug)]\n-pub struct EffectiveVisibilities {\n-    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n+#[derive(Clone, Debug)]\n+pub struct EffectiveVisibilities<Id = LocalDefId> {\n+    map: FxHashMap<Id, EffectiveVisibility>,\n }\n \n impl EffectiveVisibilities {\n@@ -111,10 +112,6 @@ impl EffectiveVisibilities {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n-        self.map.get(&id)\n-    }\n-\n     pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n@@ -136,27 +133,31 @@ impl EffectiveVisibilities {\n         }\n         self.map.insert(id, effective_vis);\n     }\n+}\n+\n+impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n+    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+        self.map.get(&id)\n+    }\n \n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: LocalDefId,\n+        id: Id,\n         nominal_vis: Visibility,\n-        default_vis: impl FnOnce() -> Visibility,\n-        parent_id: LocalDefId,\n+        default_vis: Visibility,\n+        inherited_eff_vis: Option<EffectiveVisibility>,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.is_top_level_module() {\n-                EffectiveVisibility::from_vis(Visibility::Public)\n-            } else {\n-                EffectiveVisibility::from_vis(default_vis())\n-            }\n-        });\n-        if let Some(inherited_effective_vis) = self.effective_vis(parent_id) {\n+        let mut current_effective_vis = self\n+            .map\n+            .get(&id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n+        if let Some(inherited_effective_vis) = inherited_eff_vis {\n             let mut inherited_effective_vis_at_prev_level =\n                 *inherited_effective_vis.at_level(level);\n             let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n@@ -194,6 +195,12 @@ impl EffectiveVisibilities {\n     }\n }\n \n+impl<Id> Default for EffectiveVisibilities<Id> {\n+    fn default() -> Self {\n+        EffectiveVisibilities { map: Default::default() }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}, {"sha": "56dde6f8ca74e52e19c8f4db9e35e68a15b0ca2c", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 122, "deletions": 83, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -1,16 +1,38 @@\n-use crate::{ImportKind, NameBindingKind, Resolver};\n+use crate::{ImportKind, NameBinding, NameBindingKind, Resolver, ResolverTree};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{DefIdTree, Visibility};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::ty::Visibility;\n+\n+type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n+\n+#[derive(Clone, Copy)]\n+enum ParentId<'a> {\n+    Def(LocalDefId),\n+    Import(ImportId<'a>),\n+}\n+\n+impl ParentId<'_> {\n+    fn level(self) -> Level {\n+        match self {\n+            ParentId::Def(_) => Level::Direct,\n+            ParentId::Import(_) => Level::Reexported,\n+        }\n+    }\n+}\n \n pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n+    /// While walking import chains we need to track effective visibilities per-binding, and def id\n+    /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n+    /// bindings can correspond to a single def id in imports. So we keep a separate table.\n+    import_effective_visibilities: EffectiveVisibilities<ImportId<'a>>,\n     changed: bool,\n }\n \n@@ -19,21 +41,25 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor = EffectiveVisibilitiesVisitor { r, changed: false };\n+        let mut visitor = EffectiveVisibilitiesVisitor {\n+            r,\n+            import_effective_visibilities: Default::default(),\n+            changed: false,\n+        };\n \n-        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, Level::Direct);\n+        visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n-            visitor.reset();\n+            visitor.changed = false;\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n-    fn reset(&mut self) {\n-        self.changed = false;\n+    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n+        self.r.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n     }\n \n     /// Update effective visibilities of bindings in the given module,\n@@ -48,92 +74,114 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 // Set the given effective visibility level to `Level::Direct` and\n                 // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n-\n-                // FIXME: tag and is_public() condition should be removed, but assertions occur.\n-                let tag = if binding.is_import() { Level::Reexported } else { Level::Direct };\n-                if binding.vis.is_public() {\n-                    let mut prev_parent_id = module_id;\n-                    let mut level = Level::Direct;\n-                    while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n-                        binding.kind\n-                    {\n+                let mut parent_id = ParentId::Def(module_id);\n+                while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n+                    binding.kind\n+                {\n+                    let binding_id = ImportId::new_unchecked(binding);\n+                    self.update_import(binding_id, parent_id);\n+\n+                    // Update visibilities for import ids. These are not used during this pass,\n+                    // because we have more detailed binding-based information, but are used by\n+                    // later passes. Effective visibility of an import def id is the maximum value\n+                    // among visibilities of bindings corresponding to that def id.\n+                    if let Some(node_id) = import.id() {\n                         let mut update = |node_id| {\n-                            self.update(\n+                            self.update_def(\n                                 self.r.local_def_id(node_id),\n                                 binding.vis.expect_local(),\n-                                prev_parent_id,\n-                                level,\n+                                parent_id,\n                             )\n                         };\n-                        match import.kind {\n-                            ImportKind::Single { id, additional_ids, .. } => {\n-                                // In theory all the import IDs have individual visibilities and\n-                                // effective visibilities, but in practice these IDs go straigth to\n-                                // HIR where all their few uses assume that their (effective)\n-                                // visibility applies to the whole syntactic `use` item. So we\n-                                // update them all to the maximum value among the potential\n-                                // individual effective visibilities. Maybe HIR for imports\n-                                // shouldn't use three IDs at all.\n-                                update(id);\n-                                update(additional_ids.0);\n-                                update(additional_ids.1);\n-                                prev_parent_id = self.r.local_def_id(id);\n-                            }\n-                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n-                                update(id);\n-                                prev_parent_id = self.r.local_def_id(id);\n+                        update(node_id);\n+                        if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n+                            // In theory all the single import IDs have individual visibilities and\n+                            // effective visibilities, but in practice these IDs go straigth to HIR\n+                            // where all their few uses assume that their (effective) visibility\n+                            // applies to the whole syntactic `use` item. So they all get the same\n+                            // value which is the maximum of all bindings. Maybe HIR for imports\n+                            // shouldn't use three IDs at all.\n+                            if id1 != ast::DUMMY_NODE_ID {\n+                                update(id1);\n                             }\n-                            ImportKind::MacroUse => {\n-                                // In theory we should reset the parent id to something private\n-                                // here, but `macro_use` imports always refer to external items,\n-                                // so it doesn't matter and we can just do nothing.\n-                            }\n-                            ImportKind::MacroExport => {\n-                                // In theory we should reset the parent id to something public\n-                                // here, but it has the same effect as leaving the previous parent,\n-                                // so we can just do nothing.\n+                            if id2 != ast::DUMMY_NODE_ID {\n+                                update(id2);\n                             }\n                         }\n-\n-                        level = Level::Reexported;\n-                        binding = nested_binding;\n                     }\n+\n+                    parent_id = ParentId::Import(binding_id);\n+                    binding = nested_binding;\n                 }\n \n                 if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                    self.update(def_id, binding.vis.expect_local(), module_id, tag);\n+                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n                 }\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        def_id: LocalDefId,\n+    fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n+        match parent_id {\n+            ParentId::Def(def_id) => self.r.effective_visibilities.effective_vis(def_id),\n+            ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n+        }\n+        .copied()\n+    }\n+\n+    /// The update is guaranteed to not change the table and we can skip it.\n+    fn is_noop_update(\n+        &self,\n+        parent_id: ParentId<'a>,\n         nominal_vis: Visibility,\n-        parent_id: LocalDefId,\n-        tag: Level,\n-    ) {\n-        let module_id = self\n-            .r\n-            .get_nearest_non_block_module(def_id.to_def_id())\n-            .nearest_parent_mod()\n-            .expect_local();\n-        if nominal_vis == Visibility::Restricted(module_id)\n-            || self.r.visibilities[&parent_id] == Visibility::Restricted(module_id)\n-        {\n+        default_vis: Visibility,\n+    ) -> bool {\n+        nominal_vis == default_vis\n+            || match parent_id {\n+                ParentId::Def(def_id) => self.r.visibilities[&def_id],\n+                ParentId::Import(binding) => binding.vis.expect_local(),\n+            } == default_vis\n+    }\n+\n+    fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n+        let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+        let nominal_vis = binding.vis.expect_local();\n+        let default_vis = Visibility::Restricted(\n+            import\n+                .id()\n+                .map(|id| self.nearest_normal_mod(self.r.local_def_id(id)))\n+                .unwrap_or(CRATE_DEF_ID),\n+        );\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n+            return;\n+        }\n+        self.changed |= self.import_effective_visibilities.update(\n+            binding,\n+            nominal_vis,\n+            default_vis,\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+        );\n+    }\n+\n+    fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n+        let default_vis = Visibility::Restricted(self.nearest_normal_mod(def_id));\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n             return;\n         }\n-        let mut effective_visibilities = std::mem::take(&mut self.r.effective_visibilities);\n-        self.changed |= effective_visibilities.update(\n+        self.changed |= self.r.effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            || Visibility::Restricted(module_id),\n-            parent_id,\n-            tag,\n-            &*self.r,\n+            if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis },\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n         );\n-        self.r.effective_visibilities = effective_visibilities;\n+    }\n+\n+    fn update(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n+        self.update_def(def_id, self.r.visibilities[&def_id], ParentId::Def(parent_id));\n     }\n }\n \n@@ -151,12 +199,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n             ),\n \n-            // Foreign modules inherit level from parents.\n-            ast::ItemKind::ForeignMod(..) => {\n-                let parent_id = self.r.local_parent(def_id);\n-                self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n@@ -167,18 +209,14 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n-                        let field_def_id = self.r.local_def_id(field.id);\n-                        let vis = self.r.visibilities[&field_def_id];\n-                        self.update(field_def_id, vis, variant_def_id, Level::Direct);\n+                        self.update(self.r.local_def_id(field.id), variant_def_id);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n-                    let field_def_id = self.r.local_def_id(field.id);\n-                    let vis = self.r.visibilities[&field_def_id];\n-                    self.update(field_def_id, vis, def_id, Level::Direct);\n+                    self.update(self.r.local_def_id(field.id), def_id);\n                 }\n             }\n \n@@ -194,6 +232,7 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n             | ast::ItemKind::TyAlias(..)\n             | ast::ItemKind::TraitAlias(..)\n             | ast::ItemKind::MacroDef(..)\n+            | ast::ItemKind::ForeignMod(..)\n             | ast::ItemKind::Fn(..) => return,\n         }\n     }"}, {"sha": "a1ff477c6fefbf99859477c43bc3181b61559fc2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -1106,17 +1106,30 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n     }\n }\n \n-impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+/// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n+/// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n+#[derive(Clone, Copy)]\n+struct ResolverTree<'a, 'b>(&'a Definitions, &'a CrateLoader<'b>);\n+\n+impl DefIdTree for ResolverTree<'_, '_> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        let ResolverTree(definitions, crate_loader) = self;\n         match id.as_local() {\n-            Some(id) => self.definitions.def_key(id).parent,\n-            None => self.cstore().def_key(id).parent,\n+            Some(id) => definitions.def_key(id).parent,\n+            None => crate_loader.cstore().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n }\n \n+impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+    #[inline]\n+    fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        ResolverTree(&self.definitions, &self.crate_loader).opt_parent(id)\n+    }\n+}\n+\n impl Resolver<'_> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()"}, {"sha": "187bd75933048f0c49c4964dd0ac46710a971e1a", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -6,7 +6,7 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n     pub mod inner1 { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n \n         #[rustc_effective_visibility]\n-        extern \"C\" {} //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+        extern \"C\" {} //~ ERROR not in the table\n \n         #[rustc_effective_visibility]\n         pub trait PubTrait { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub"}, {"sha": "10ed14aa1503576f093ee68addc45735be07e3e4", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -10,7 +10,7 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |     pub mod inner1 {\n    |     ^^^^^^^^^^^^^^\n \n-error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+error: not in the table\n   --> $DIR/effective_visibilities.rs:9:9\n    |\n LL |         extern \"C\" {}"}, {"sha": "eb9dcd6cd1fa4cecdc32f1baaa907bbee7487294", "filename": "src/test/ui/privacy/effective_visibilities_glob.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -0,0 +1,21 @@\n+// Effective visibility tracking for imports is fine-grained, so `S2` is not fully exported\n+// even if its parent import (`m::*`) is fully exported as a `use` item.\n+\n+#![feature(rustc_attrs)]\n+\n+mod m {\n+    #[rustc_effective_visibility]\n+    pub struct S1 {} //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    #[rustc_effective_visibility]\n+    pub struct S2 {} //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+}\n+\n+mod glob {\n+    #[rustc_effective_visibility]\n+    pub use crate::m::*; //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+}\n+\n+#[rustc_effective_visibility]\n+pub use glob::S1; //~ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+fn main() {}"}, {"sha": "0496cd5df8db01b0934cad4e3475129eba0fe598", "filename": "src/test/ui/privacy/effective_visibilities_glob.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24093fc6bd442be45a3ddb935b7056ab77cf96f5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr?ref=24093fc6bd442be45a3ddb935b7056ab77cf96f5", "patch": "@@ -0,0 +1,26 @@\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:8:5\n+   |\n+LL |     pub struct S1 {}\n+   |     ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+  --> $DIR/effective_visibilities_glob.rs:10:5\n+   |\n+LL |     pub struct S2 {}\n+   |     ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:15:13\n+   |\n+LL |     pub use crate::m::*;\n+   |             ^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:19:9\n+   |\n+LL | pub use glob::S1;\n+   |         ^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}