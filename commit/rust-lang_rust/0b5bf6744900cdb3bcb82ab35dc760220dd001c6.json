{"sha": "0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWJmNjc0NDkwMGNkYjNiY2I4MmFiMzVkYzc2MDIyMGRkMDAxYzY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-01T03:55:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-01T03:55:31Z"}, "message": "Rollup merge of #40128 - cengizIO:master, r=nikomatsakis\n\nMove two large error_reporting fn's to a separate file\n\nHello!\n\nI tried to make `librustc/infer/error_reporting,rs` more readable by modularizing it and moving its two largest functions to a separate file.\n\nIf you have any suggestions, please send it right away! \ud83d\ude80\n\nThanks goes to @nikomatsakis for supporting.", "tree": {"sha": "be000760e8ca562315bf3a95faf32a16bd1c51c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be000760e8ca562315bf3a95faf32a16bd1c51c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "html_url": "https://github.com/rust-lang/rust/commit/0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a008b949e4ea5ccec83a6a7a90b695f9a0f55df", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a008b949e4ea5ccec83a6a7a90b695f9a0f55df", "html_url": "https://github.com/rust-lang/rust/commit/0a008b949e4ea5ccec83a6a7a90b695f9a0f55df"}, {"sha": "e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "url": "https://api.github.com/repos/rust-lang/rust/commits/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "html_url": "https://github.com/rust-lang/rust/commit/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621"}], "stats": {"total": 912, "additions": 445, "deletions": 467}, "files": [{"sha": "21139c8dde2a4b34b96c22becfc1b483728c9dfb", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "renamed", "additions": 8, "deletions": 462, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "patch": "@@ -55,32 +55,25 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use super::InferCtxt;\n-use super::TypeTrace;\n-use super::SubregionOrigin;\n-use super::RegionVariableOrigin;\n-use super::ValuePairs;\n-use super::region_inference::RegionResolutionError;\n-use super::region_inference::ConcreteFailure;\n-use super::region_inference::SubSupConflict;\n-use super::region_inference::GenericBoundFailure;\n-use super::region_inference::GenericKind;\n+use infer;\n+use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::region_inference::{RegionResolutionError, ConcreteFailure, SubSupConflict,\n+                              GenericBoundFailure, GenericKind};\n \n-use hir::map as hir_map;\n+use std::fmt;\n use hir;\n-\n+use hir::map as hir_map;\n use hir::def_id::DefId;\n-use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n-\n-use std::fmt;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n+mod note;\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n@@ -584,289 +577,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: &'tcx Region,\n-                               sup: &'tcx Region)\n-                                -> DiagnosticBuilder<'tcx> {\n-        match origin {\n-            infer::Subtype(trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n-                    \"lifetime of reference outlives \\\n-                     lifetime of borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n-                    \"lifetime of borrowed pointer outlives \\\n-                            lifetime of captured variable `{}`...\",\n-                            self.tcx.local_var_name_str(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    &format!(\"...but `{}` is only valid for \",\n-                             self.tcx.local_var_name_str(upvar_id.var_id)),\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InfStackClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n-                    \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the closure's stack frame is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n-                    \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n-                          \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::FreeVariable(span, id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n-                          \"captured variable `{}` does not outlive the enclosing closure\",\n-                          self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n-                          \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n-                          \"lifetime of the source pointer does not outlive \\\n-                           lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n-                          \"the type `{}` does not fulfill the required lifetime\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n-                          \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n-                          \"the type `{}` (provided as the value of \\\n-                           a type parameter) is not valid at this point\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n-                          \"lifetime of method receiver does not outlive \\\n-                           the method call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n-                          \"lifetime of function argument does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallReturn(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n-                          \"lifetime of return value does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the return value is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n-                          \"lifetime of operand does not outlive \\\n-                           the operation\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n-                          \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n-                          \"automatically reference is not valid \\\n-                           at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n-                          \"type of expression contains references \\\n-                           that are not valid during the expression: `{}`\",\n-                          self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n-                          \"unsafe use of destructor: destructor might be called \\\n-                           while references are dead\");\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n-                          \"lifetime of variable does not enclose its declaration\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n-                          \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n-                          \"a value of type `{}` is borrowed for too long\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n-                          \"in type `{}`, reference has a longer lifetime \\\n-                           than the data it references\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CompareImplMethodObligation { span,\n-                                                 item_name,\n-                                                 impl_item_def_id,\n-                                                 trait_item_def_id,\n-                                                 lint_id } => {\n-                self.report_extra_impl_obligation(span,\n-                                                  item_name,\n-                                                  impl_item_def_id,\n-                                                  trait_item_def_id,\n-                                                  &format!(\"`{}: {}`\", sup, sub),\n-                                                  lint_id)\n-            }\n-        }\n-    }\n-\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n@@ -939,170 +649,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                    due to conflicting requirements\",\n                   var_description)\n     }\n-\n-    fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    // FIXME: do we want a \"the\" here?\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.cause.as_requirement_str(), expected, found));\n-                } else {\n-                    // FIXME: this really should be handled at some earlier stage. Our\n-                    // handling of region checking when type errors are present is\n-                    // *terrible*.\n-\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\",\n-                                 trace.cause.as_requirement_str()));\n-                }\n-            }\n-            infer::Reborrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference does not outlive \\\n-                    borrowed content\");\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that closure can access `{}`\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id)\n-                            .to_string()));\n-            }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that pointer is not dereferenced \\\n-                    outside its lifetime\");\n-            }\n-            infer::FreeVariable(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that captured variable `{}` \\\n-                            does not outlive the enclosing closure\",\n-                            self.tcx.local_var_name_str(id)));\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that slice is not indexed outside the lifetime\");\n-            }\n-            infer::RelateObjectBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that it can be closed over into an object\");\n-            }\n-            infer::CallRcvr(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that argument is valid for the call\");\n-            }\n-            infer::CallReturn(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that return value is valid for the call\");\n-            }\n-            infer::Operand(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that auto-reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so type `{}` of expression is valid during the \\\n-                             expression\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that a type/lifetime parameter is in scope here\");\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n-                             self.ty_to_string(ty)));\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the reference type `{}` \\\n-                             does not outlive the data it points at\",\n-                            self.ty_to_string(ty)));\n-            }\n-            infer::RelateParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` \\\n-                             will meet its required lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that type parameter \\\n-                             instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\");\n-            }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that references are valid when the destructor \\\n-                     runs\");\n-            }\n-            infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\");\n-            }\n-        }\n-    }\n }\n \n impl<'tcx> ObligationCause<'tcx> {", "previous_filename": "src/librustc/infer/error_reporting.rs"}, {"sha": "8f8b2603dad8496de6358bdfa77c7748d5165c43", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "patch": "@@ -0,0 +1,432 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::{self, InferCtxt, SubregionOrigin};\n+use ty::Region;\n+use ty::error::TypeError;\n+use errors::DiagnosticBuilder;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn note_region_origin(&self,\n+                                     err: &mut DiagnosticBuilder,\n+                                     origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => {\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {} (expected {}, found {})\",\n+                                           trace.cause.as_requirement_str(),\n+                                           expected,\n+                                           found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {}\", trace.cause.as_requirement_str()));\n+                }\n+            }\n+            infer::Reborrow(span) => {\n+                err.span_note(span,\n+                              \"...so that reference does not outlive borrowed content\");\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                err.span_note(span,\n+                              &format!(\"...so that closure can access `{}`\",\n+                                       self.tcx\n+                                           .local_var_name_str(upvar_id.var_id)\n+                                           .to_string()));\n+            }\n+            infer::InfStackClosure(span) => {\n+                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                err.span_note(span,\n+                              \"...so that closure is not invoked outside its lifetime\");\n+            }\n+            infer::DerefPointer(span) => {\n+                err.span_note(span,\n+                              \"...so that pointer is not dereferenced outside its lifetime\");\n+            }\n+            infer::FreeVariable(span, id) => {\n+                err.span_note(span,\n+                              &format!(\"...so that captured variable `{}` does not outlive the \\\n+                                        enclosing closure\",\n+                                       self.tcx.local_var_name_str(id)));\n+            }\n+            infer::IndexSlice(span) => {\n+                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                err.span_note(span, \"...so that it can be closed over into an object\");\n+            }\n+            infer::CallRcvr(span) => {\n+                err.span_note(span,\n+                              \"...so that method receiver is valid for the method call\");\n+            }\n+            infer::CallArg(span) => {\n+                err.span_note(span, \"...so that argument is valid for the call\");\n+            }\n+            infer::CallReturn(span) => {\n+                err.span_note(span, \"...so that return value is valid for the call\");\n+            }\n+            infer::Operand(span) => {\n+                err.span_note(span, \"...so that operand is valid for operation\");\n+            }\n+            infer::AddrOf(span) => {\n+                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                err.span_note(span,\n+                              \"...so that auto-reference is valid at the time of borrow\");\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so type `{}` of expression is valid during the \\\n+                                        expression\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                err.span_note(span,\n+                              \"...so that variable is valid at time of its declaration\");\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                err.span_note(span,\n+                              \"...so that a type/lifetime parameter is in scope here\");\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                                       self.ty_to_string(ty)));\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the reference type `{}` does not outlive the \\\n+                                        data it points at\",\n+                                       self.ty_to_string(ty)));\n+            }\n+            infer::RelateParamBound(span, t) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` will meet its required \\\n+                                        lifetime bounds\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::RelateDefaultParamBound(span, t) => {\n+                err.span_note(span,\n+                              &format!(\"...so that type parameter instantiated with `{}`, will \\\n+                                        meet its declared lifetime bounds\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                err.span_note(span,\n+                              \"...so that the declared lifetime parameter bounds are satisfied\");\n+            }\n+            infer::SafeDestructor(span) => {\n+                err.span_note(span,\n+                              \"...so that references are valid when the destructor runs\");\n+            }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(span,\n+                              \"...so that the definition in impl matches the definition from the \\\n+                               trait\");\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_concrete_failure(&self,\n+                                          origin: SubregionOrigin<'tcx>,\n+                                          sub: &'tcx Region,\n+                                          sup: &'tcx Region)\n+                                          -> DiagnosticBuilder<'tcx> {\n+        match origin {\n+            infer::Subtype(trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                self.report_and_explain_type_error(trace, &terr)\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0312,\n+                                               \"lifetime of reference outlives lifetime of \\\n+                                                borrowed content...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the reference is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the borrowed content is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0313,\n+                                               \"lifetime of borrowed pointer outlives lifetime \\\n+                                                of captured variable `{}`...\",\n+                                               self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the borrowed pointer is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err,\n+                                             &format!(\"...but `{}` is only valid for \",\n+                                                      self.tcx\n+                                                          .local_var_name_str(upvar_id.var_id)),\n+                                             sup,\n+                                             \"\");\n+                err\n+            }\n+            infer::InfStackClosure(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the closure must be valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the closure's stack frame is only valid \\\n+                                                  for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::InvokeClosure(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0315,\n+                                               \"cannot invoke closure outside of its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::DerefPointer(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0473,\n+                                               \"dereference of reference outside its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::FreeVariable(span, id) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0474,\n+                                               \"captured variable `{}` does not outlive the \\\n+                                                enclosing closure\",\n+                                               self.tcx.local_var_name_str(id));\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n+                err\n+            }\n+            infer::IndexSlice(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0475,\n+                                               \"index of slice outside its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0476,\n+                                               \"lifetime of the source pointer does not outlive \\\n+                                                lifetime bound of the object type\");\n+                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"source pointer is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0477,\n+                                               \"the type `{}` does not fulfill the required \\\n+                                                lifetime\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"lifetime parameter instantiated with \",\n+                                                 sup,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but lifetime parameter must outlive \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateDefaultParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0479,\n+                                               \"the type `{}` (provided as the value of a type \\\n+                                                parameter) is not valid at this point\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                err\n+            }\n+            infer::CallRcvr(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0480,\n+                                               \"lifetime of method receiver does not outlive the \\\n+                                                method call\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::CallArg(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0481,\n+                                               \"lifetime of function argument does not outlive \\\n+                                                the function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the function argument is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CallReturn(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0482,\n+                                               \"lifetime of return value does not outlive the \\\n+                                                function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the return value is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::Operand(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0483,\n+                                               \"lifetime of operand does not outlive the \\\n+                                                operation\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::AddrOf(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0484,\n+                                               \"reference is not valid at the time of borrow\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::AutoBorrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0485,\n+                                               \"automatically reference is not valid at the time \\\n+                                                of borrow\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the automatic borrow is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0486,\n+                                               \"type of expression contains references that are \\\n+                                                not valid during the expression: `{}`\",\n+                                               self.ty_to_string(t));\n+                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::SafeDestructor(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0487,\n+                                               \"unsafe use of destructor: destructor might be \\\n+                                                called while references are dead\");\n+                // FIXME (22171): terms \"super/subregion\" are suboptimal\n+                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n+                err\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0488,\n+                                               \"lifetime of variable does not enclose its \\\n+                                                declaration\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0489,\n+                                               \"type/lifetime parameter not in scope here\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0490,\n+                                               \"a value of type `{}` is borrowed for too long\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0491,\n+                                               \"in type `{}`, reference has a longer lifetime \\\n+                                                than the data it references\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but the referenced data is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub),\n+                                                  lint_id)\n+            }\n+        }\n+    }\n+}"}, {"sha": "b07ef4dfd448e45f1a3651110b4dd6b79838e836", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5bf6744900cdb3bcb82ab35dc760220dd001c6/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "patch": "@@ -210,7 +210,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n /// region that each late-bound region was replaced with.\n pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -221,7 +221,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting.rs` for more details.\n+/// See `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -230,7 +230,7 @@ pub struct TypeTrace<'tcx> {\n \n /// The origin of a `r1 <= r2` constraint.\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n@@ -348,7 +348,7 @@ pub enum LateBoundRegionConversionTime {\n \n /// Reasons to create a region inference variable\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n@@ -1295,7 +1295,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting.rs\n+            self.report_region_errors(&errors); // see error_reporting module\n         }\n     }\n "}]}