{"sha": "068161ea483b1a80a959476cb3e31e6619a72737", "node_id": "C_kwDOAAsO6NoAKDA2ODE2MWVhNDgzYjFhODBhOTU5NDc2Y2IzZTMxZTY2MTlhNzI3Mzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T05:17:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T05:17:58Z"}, "message": "Auto merge of #107940 - BoxyUwU:const_ty_assertion_use_semantic_equality, r=compiler-errors\n\nuse semantic equality for const param type equality assertion\n\nFixes #107898\n\nSee added test for what caused this ICE\n\n---\n\nThe current in assertion in `relate.rs` is rather inadequate when keeping in mind future expansions to const generics:\n- it will ICE when there are infer vars in a projection in a const param ty\n- it will spurriously return false when either ty has infer vars because of using `==` instead of `infcx.at(..).eq`\n- i am also unsure if it would be possible with `adt_const_params` to craft a situation where the const param type is not wf causing `normalize_erasing_regions` to `bug!` when we would have emitted a diagnostic.\n\nThis impl feels pretty Not Great to me  although i am not sure what a better idea would be.\n\n- We have to have the logic behind a query because neither `relate.rs` or `combine.rs` have access to trait solving machinery (without evaluating nested obligations this assert will become _far_ less useful under lazy norm, which consts are already doing)\n- `relate.rs` does not have access to canonicalization machinery which is necessary in order to have types potentially containing infer vars in query arguments.\n\nWe could possible add a method to `TypeRelation` to do this assertion rather than a query but to avoid implementing the same logic over and over we'd probably end up with the logic in a free function somewhere in `rustc_trait_selection` _anyway_ so I don't think that would be much better.\n\nWe could also just remove this assertion, it should not actually be necessary for it to be present. It has caught some bugs in the past though so if possible I would like to keep it.\n\nr? `@compiler-errors`", "tree": {"sha": "f04d49530e15fb3a57e96310b10004153bd62a80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f04d49530e15fb3a57e96310b10004153bd62a80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/068161ea483b1a80a959476cb3e31e6619a72737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/068161ea483b1a80a959476cb3e31e6619a72737", "html_url": "https://github.com/rust-lang/rust/commit/068161ea483b1a80a959476cb3e31e6619a72737", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/068161ea483b1a80a959476cb3e31e6619a72737/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0416b1a6f6d5c42696494e1a3a33580fd3f669d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0416b1a6f6d5c42696494e1a3a33580fd3f669d8", "html_url": "https://github.com/rust-lang/rust/commit/0416b1a6f6d5c42696494e1a3a33580fd3f669d8"}, {"sha": "57ad73aa27dcfc1341e62738b3b79690a51beccd", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ad73aa27dcfc1341e62738b3b79690a51beccd", "html_url": "https://github.com/rust-lang/rust/commit/57ad73aa27dcfc1341e62738b3b79690a51beccd"}], "stats": {"total": 262, "additions": 240, "deletions": 22}, "files": [{"sha": "964222307bcafc8158c17ef6e66de65631acd0bc", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -31,8 +31,10 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -152,6 +154,34 @@ impl<'tcx> InferCtxt<'tcx> {\n         let a = self.shallow_resolve(a);\n         let b = self.shallow_resolve(b);\n \n+        // We should never have to relate the `ty` field on `Const` as it is checked elsewhere that consts have the\n+        // correct type for the generic param they are an argument for. However there have been a number of cases\n+        // historically where asserting that the types are equal has found bugs in the compiler so this is valuable\n+        // to check even if it is a bit nasty impl wise :(\n+        //\n+        // This probe is probably not strictly necessary but it seems better to be safe and not accidentally find\n+        // ourselves with a check to find bugs being required for code to compile because it made inference progress.\n+        self.probe(|_| {\n+            if a.ty() == b.ty() {\n+                return;\n+            }\n+\n+            // We don't have access to trait solving machinery in `rustc_infer` so the logic for determining if the\n+            // two const param's types are able to be equal has to go through a canonical query with the actual logic\n+            // in `rustc_trait_selection`.\n+            let canonical = self.canonicalize_query(\n+                (relation.param_env(), a.ty(), b.ty()),\n+                &mut OriginalQueryValues::default(),\n+            );\n+\n+            if let Err(NoSolution) = self.tcx.check_tys_might_be_eq(canonical) {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    &format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n+                );\n+            }\n+        });\n+\n         match (a.kind(), b.kind()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),"}, {"sha": "f02e3a9aa29f61f0e66bbca2cd3acbc4ad8f3cf0", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -2173,4 +2173,11 @@ rustc_queries! {\n         desc { \"traits in scope for documentation links for a module\" }\n         separate_provide_extern\n     }\n+\n+    /// Used in `super_combine_consts` to ICE if the type of the two consts are definitely not going to end up being\n+    /// equal to eachother. This might return `Ok` even if the types are unequal, but will never return `Err` if\n+    /// the types might be equal.\n+    query check_tys_might_be_eq(arg: Canonical<'tcx, (ty::ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>) -> Result<(), NoSolution> {\n+        desc { \"check whether two const param are definitely not equal to eachother\"}\n+    }\n }"}, {"sha": "33b509ec490ba32ec5e2495e305454b2f8f3f9f1", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -9,7 +9,6 @@ use crate::ty::{self, Expr, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldabl\n use crate::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n \n@@ -594,25 +593,6 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    let a_ty;\n-    let b_ty;\n-    if relation.tcx().features().adt_const_params {\n-        a_ty = tcx.normalize_erasing_regions(relation.param_env(), a.ty());\n-        b_ty = tcx.normalize_erasing_regions(relation.param_env(), b.ty());\n-    } else {\n-        a_ty = tcx.erase_regions(a.ty());\n-        b_ty = tcx.erase_regions(b.ty());\n-    }\n-    if a_ty != b_ty {\n-        relation.tcx().sess.delay_span_bug(\n-            DUMMY_SP,\n-            &format!(\n-                \"cannot relate constants ({:?}, {:?}) of different types: {} != {}\",\n-                a, b, a_ty, b_ty\n-            ),\n-        );\n-    }\n-\n     // HACK(const_generics): We still need to eagerly evaluate consts when\n     // relating them because during `normalize_param_env_or_error`,\n     // we may relate an evaluated constant in a obligation against"}, {"sha": "de730773794b6164cf78b6d72b6211eeefae6c5a", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -1,12 +1,15 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::traits::{self, ObligationCause};\n+use crate::traits::{self, ObligationCause, ObligationCtxt};\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n+use rustc_infer::traits::query::NoSolution;\n use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeVisitable};\n+use rustc_span::DUMMY_SP;\n \n use super::outlives_bounds::InferCtxtExt;\n \n@@ -131,3 +134,19 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n \n     Ok(())\n }\n+\n+pub fn check_tys_might_be_eq<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    canonical: Canonical<'tcx, (ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>,\n+) -> Result<(), NoSolution> {\n+    let (infcx, (param_env, ty_a, ty_b), _) =\n+        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical);\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    let result = ocx.eq(&ObligationCause::dummy(), param_env, ty_a, ty_b);\n+    // use `select_where_possible` instead of `select_all_or_error` so that\n+    // we don't get errors from obligations being ambiguous.\n+    let errors = ocx.select_where_possible();\n+\n+    if errors.len() > 0 || result.is_err() { Err(NoSolution) } else { Ok(()) }\n+}"}, {"sha": "41ee8cd9d3fa3a7251b0be3d2ac4fb799ca994c4", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -554,6 +554,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         subst_and_check_impossible_predicates,\n+        check_tys_might_be_eq: misc::check_tys_might_be_eq,\n         is_impossible_method,\n         ..*providers\n     };"}, {"sha": "1e248411830cd103162246c322c690c115b70bf9", "filename": "tests/ui/const-generics/generic_const_exprs/const_kind_expr/relate_ty_with_infer_1.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+// issue #107899\n+// We end up relating `Const(ty: size_of<?0>, kind: Value(Branch([])))` with\n+// `Const(ty: size_of<T>, kind: Value(Branch([])))` which if you were to `==`\n+// the `ty` fields would return `false` and ICE. This test checks that we use\n+// actual semantic equality that takes into account aliases and infer vars.\n+\n+use std::mem::size_of;\n+\n+trait X<T> {\n+    fn f(self);\n+    fn g(self);\n+}\n+\n+struct Y;\n+\n+impl<T> X<T> for Y\n+where\n+    [(); size_of::<T>()]: Sized,\n+{\n+    fn f(self) {\n+        self.g();\n+    }\n+    fn g(self) {}\n+}\n+\n+fn main() {}"}, {"sha": "91a8a7c4a01215d9e92f3091871c2e87e118cf67", "filename": "tests/ui/const-generics/generic_const_exprs/const_kind_expr/relate_ty_with_infer_2.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/068161ea483b1a80a959476cb3e31e6619a72737/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068161ea483b1a80a959476cb3e31e6619a72737/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs?ref=068161ea483b1a80a959476cb3e31e6619a72737", "patch": "@@ -0,0 +1,151 @@\n+// check-pass\n+#![feature(inline_const, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+use std::marker::PhantomData;\n+\n+pub struct Equal<const T: usize, const R: usize>();\n+pub trait True {}\n+impl<const T: usize> True for Equal<T, T> {}\n+\n+// replacement for generativity\n+pub struct Id<'id>(PhantomData<fn(&'id ()) -> &'id ()>);\n+pub struct Guard<'id>(Id<'id>);\n+fn make_guard<'id>(i: &'id Id<'id>) -> Guard<'id> {\n+    Guard(Id(PhantomData))\n+}\n+\n+impl<'id> Into<Id<'id>> for Guard<'id> {\n+    fn into(self) -> Id<'id> {\n+        self.0\n+    }\n+}\n+\n+pub struct Arena<'life> {\n+    bytes: *mut [u8],\n+    //bitmap: RefCell<RoaringBitmap>,\n+    _token: PhantomData<Id<'life>>,\n+}\n+\n+#[repr(transparent)]\n+pub struct Item<'life, T> {\n+    data: T,\n+    _phantom: PhantomData<Id<'life>>,\n+}\n+\n+#[repr(transparent)]\n+pub struct Token<'life, 'borrow, 'compact, 'reborrow, T>\n+where\n+    'life: 'reborrow,\n+    T: Tokenize<'life, 'borrow, 'compact, 'reborrow>,\n+{\n+    //ptr: *mut <T as Tokenize>::Tokenized,\n+    ptr: core::ptr::NonNull<T::Tokenized>,\n+    _phantom: PhantomData<Id<'life>>,\n+    _compact: PhantomData<&'borrow Guard<'compact>>,\n+    _result: PhantomData<&'reborrow T::Untokenized>,\n+}\n+\n+impl<'life> Arena<'life> {\n+    pub fn tokenize<'before, 'compact, 'borrow, 'reborrow, T, U>(\n+        &self,\n+        guard: &'borrow Guard<'compact>,\n+        item: Item<'life, &'before mut T>,\n+    ) -> Token<'life, 'borrow, 'compact, 'reborrow, U>\n+    where\n+        T: Tokenize<'life, 'borrow, 'compact, 'reborrow, Untokenized = U>,\n+        T::Untokenized: Tokenize<'life, 'borrow, 'compact, 'reborrow>,\n+        Equal<{ core::mem::size_of::<T>() }, { core::mem::size_of::<U>() }>: True,\n+        'compact: 'borrow,\n+        'life: 'reborrow,\n+        'life: 'compact,\n+        'life: 'borrow,\n+        // 'borrow: 'before ??\n+    {\n+        let dst = item.data as *mut T as *mut T::Tokenized;\n+        Token {\n+            ptr: core::ptr::NonNull::new(dst as *mut _).unwrap(),\n+            _phantom: PhantomData,\n+            _compact: PhantomData,\n+            _result: PhantomData,\n+        }\n+    }\n+}\n+\n+pub trait Tokenize<'life, 'borrow, 'compact, 'reborrow>\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized;\n+    type Untokenized;\n+    const TO: fn(&Arena<'life>, &'borrow Guard<'compact>, Self) -> Self::Tokenized;\n+    const FROM: fn(&'reborrow Arena<'life>, Self::Tokenized) -> Self::Untokenized;\n+}\n+\n+macro_rules! tokenize {\n+    ($to:expr, $from:expr) => {\n+        const TO: fn(&Arena<'life>, &'borrow Guard<'compact>, Self) -> Self::Tokenized = $to;\n+        const FROM: fn(&'reborrow Arena<'life>, Self::Tokenized) -> Self::Untokenized = $from;\n+    };\n+}\n+\n+struct Foo<'life, 'borrow>(Option<Item<'life, &'borrow mut Bar>>);\n+struct TokenFoo<'life, 'borrow, 'compact, 'reborrow>(\n+    Option<Token<'life, 'borrow, 'compact, 'reborrow, Bar>>,\n+);\n+struct Bar(u8);\n+\n+impl<'life, 'before, 'borrow, 'compact, 'reborrow> Tokenize<'life, 'borrow, 'compact, 'reborrow>\n+    for Foo<'life, 'before>\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized = TokenFoo<'life, 'borrow, 'compact, 'reborrow>;\n+    type Untokenized = Foo<'life, 'reborrow>;\n+    tokenize!(foo_to, foo_from);\n+}\n+\n+impl<'life, 'borrow, 'compact, 'reborrow> Tokenize<'life, 'borrow, 'compact, 'reborrow> for Bar\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized = Bar;\n+    type Untokenized = Bar;\n+    tokenize!(bar_to, bar_from);\n+}\n+\n+fn bar_to<'life, 'borrow, 'compact>(\n+    arena: &Arena<'life>,\n+    guard: &'borrow Guard<'compact>,\n+    s: Bar,\n+) -> Bar {\n+    s\n+}\n+fn bar_from<'life, 'reborrow>(arena: &'reborrow Arena<'life>, s: Bar) -> Bar {\n+    s\n+}\n+\n+fn foo_to<'life, 'borrow, 'compact, 'reborrow, 'before>(\n+    arena: &'before Arena<'life>,\n+    guard: &'borrow Guard<'compact>,\n+    s: Foo<'life, 'before>,\n+) -> TokenFoo<'life, 'borrow, 'compact, 'reborrow> {\n+    let Foo(bar) = s;\n+    TokenFoo(bar.map(|bar| arena.tokenize(guard, bar)))\n+}\n+fn foo_from<'life, 'borrow, 'compact, 'reborrow>(\n+    arena: &'reborrow Arena<'life>,\n+    s: TokenFoo<'life, 'borrow, 'compact, 'reborrow>,\n+) -> Foo<'life, 'reborrow> {\n+    Foo(s.0.map(|bar| panic!()))\n+}\n+\n+fn main() {}"}]}