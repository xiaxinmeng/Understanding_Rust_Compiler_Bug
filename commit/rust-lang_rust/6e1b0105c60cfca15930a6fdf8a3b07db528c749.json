{"sha": "6e1b0105c60cfca15930a6fdf8a3b07db528c749", "node_id": "C_kwDOAAsO6NoAKDZlMWIwMTA1YzYwY2ZjYTE1OTMwYTZmZGY4YTNiMDdkYjUyOGM3NDk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-12-04T20:20:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-02T17:23:39Z"}, "message": "Diagnose shadowing on AST.", "tree": {"sha": "dac5293ac5c171fad2499c893401bde4bdba10ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac5293ac5c171fad2499c893401bde4bdba10ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e1b0105c60cfca15930a6fdf8a3b07db528c749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1b0105c60cfca15930a6fdf8a3b07db528c749", "html_url": "https://github.com/rust-lang/rust/commit/6e1b0105c60cfca15930a6fdf8a3b07db528c749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e1b0105c60cfca15930a6fdf8a3b07db528c749/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20976bae5c426c738262db376eadbd8859aafc08", "url": "https://api.github.com/repos/rust-lang/rust/commits/20976bae5c426c738262db376eadbd8859aafc08", "html_url": "https://github.com/rust-lang/rust/commit/20976bae5c426c738262db376eadbd8859aafc08"}], "stats": {"total": 534, "additions": 209, "deletions": 325}, "files": [{"sha": "533302a758f17f763ae3f78d7bd3554cc41c3001", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 93, "deletions": 26, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6e1b0105c60cfca15930a6fdf8a3b07db528c749", "patch": "@@ -12,6 +12,10 @@ use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n+use diagnostics::{\n+    original_label, original_lifetime, original_lifetime_param, shadower_label, shadower_lifetime,\n+};\n+\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n@@ -172,6 +176,23 @@ impl RibKind<'_> {\n             AssocItemRibKind | ItemRibKind(_) | ForwardGenericParamBanRibKind => true,\n         }\n     }\n+\n+    /// This rib forbids referring to labels defined in upwards ribs.\n+    fn is_label_barrier(self) -> bool {\n+        match self {\n+            NormalRibKind | MacroDefinition(..) => false,\n+\n+            AssocItemRibKind\n+            | ClosureOrAsyncRibKind\n+            | FnItemRibKind\n+            | ItemRibKind(..)\n+            | ConstantItemRibKind(..)\n+            | ModuleRibKind(..)\n+            | ForwardGenericParamBanRibKind\n+            | ConstParamTyRibKind\n+            | InlineAsmSymRibKind => true,\n+        }\n+    }\n }\n \n /// A single local scope.\n@@ -732,7 +753,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         // Create a value rib for the function.\n         self.with_rib(ValueNS, rib_kind, |this| {\n             // Create a label rib for the function.\n-            this.with_label_rib(rib_kind, |this| {\n+            this.with_label_rib(FnItemRibKind, |this| {\n                 let async_node_id = fn_kind.header().and_then(|h| h.asyncness.opt_return_id());\n \n                 if let FnKind::Fn(_, _, _, _, generics, _) = fn_kind {\n@@ -1585,22 +1606,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let ribs = &self.label_ribs[rib_index + 1..];\n \n         for rib in ribs {\n-            match rib.kind {\n-                NormalRibKind | MacroDefinition(..) => {\n-                    // Nothing to do. Continue.\n-                }\n-\n-                AssocItemRibKind\n-                | ClosureOrAsyncRibKind\n-                | FnItemRibKind\n-                | ItemRibKind(..)\n-                | ConstantItemRibKind(..)\n-                | ModuleRibKind(..)\n-                | ForwardGenericParamBanRibKind\n-                | ConstParamTyRibKind\n-                | InlineAsmSymRibKind => {\n-                    return false;\n-                }\n+            if rib.kind.is_label_barrier() {\n+                return false;\n             }\n         }\n \n@@ -1895,6 +1902,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let mut function_value_rib = Rib::new(kind);\n         let mut function_lifetime_rib = LifetimeRib::new(lifetime_kind);\n         let mut seen_bindings = FxHashMap::default();\n+        let mut seen_lifetimes = FxHashMap::default();\n \n         // We also can't shadow bindings from the parent item\n         if let AssocItemRibKind = kind {\n@@ -1910,20 +1918,52 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             add_bindings_for_ns(TypeNS);\n         }\n \n+        // Forbid shadowing lifetime bindings\n+        for rib in self.lifetime_ribs.iter().rev() {\n+            seen_lifetimes.extend(\n+                rib.bindings.iter().map(|(ident, _)| (*ident, original_lifetime(ident.span))),\n+            );\n+            if let LifetimeRibKind::Item = rib.kind {\n+                break;\n+            }\n+        }\n+        for rib in self.label_ribs.iter().rev() {\n+            if rib.kind.is_label_barrier() {\n+                break;\n+            }\n+            seen_lifetimes\n+                .extend(rib.bindings.iter().map(|(ident, _)| (*ident, original_label(ident.span))));\n+        }\n+\n         for param in params {\n             let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n-            match seen_bindings.entry(ident) {\n-                Entry::Occupied(entry) => {\n-                    let span = *entry.get();\n-                    let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n-                    if !matches!(param.kind, GenericParamKind::Lifetime) {\n-                        self.report_error(param.ident.span, err);\n+            if let GenericParamKind::Lifetime = param.kind {\n+                match seen_lifetimes.entry(ident) {\n+                    Entry::Occupied(entry) => {\n+                        let original = *entry.get();\n+                        diagnostics::signal_shadowing_problem(\n+                            self.r.session,\n+                            ident.name,\n+                            original,\n+                            shadower_lifetime(param.ident.span),\n+                        )\n+                    }\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(original_lifetime_param(param.ident.span));\n                     }\n                 }\n-                Entry::Vacant(entry) => {\n-                    entry.insert(param.ident.span);\n+            } else {\n+                match seen_bindings.entry(ident) {\n+                    Entry::Occupied(entry) => {\n+                        let span = *entry.get();\n+                        let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n+                        self.report_error(param.ident.span, err);\n+                    }\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(param.ident.span);\n+                    }\n                 }\n             }\n \n@@ -3114,8 +3154,35 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if label.ident.as_str().as_bytes()[1] != b'_' {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n+\n+            // Forbid shadowing lifetime bindings\n+            let ident = label.ident.normalize_to_macro_rules();\n+            for rib in self.lifetime_ribs.iter().rev() {\n+                if let Some((orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n+                    diagnostics::signal_shadowing_problem(\n+                        self.r.session,\n+                        label.ident.name,\n+                        original_lifetime(orig_ident.span),\n+                        shadower_label(label.ident.span),\n+                    )\n+                }\n+            }\n+            for rib in self.label_ribs.iter_mut().rev() {\n+                if let Some((orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n+                    diagnostics::signal_shadowing_problem(\n+                        self.r.session,\n+                        label.ident.name,\n+                        original_label(orig_ident.span),\n+                        shadower_label(label.ident.span),\n+                    )\n+                }\n+                if rib.kind.is_label_barrier() {\n+                    rib.bindings.insert(ident, id);\n+                    break;\n+                }\n+            }\n+\n             self.with_label_rib(NormalRibKind, |this| {\n-                let ident = label.ident.normalize_to_macro_rules();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });"}, {"sha": "b77bcaad3542e189493ce8b9dac69908fc12f1f5", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6e1b0105c60cfca15930a6fdf8a3b07db528c749", "patch": "@@ -25,6 +25,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -2036,6 +2037,87 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+enum ShadowKind {\n+    Label,\n+    Lifetime,\n+}\n+#[derive(Copy, Clone)]\n+pub struct Original {\n+    kind: ShadowKind,\n+    span: Span,\n+    param: bool,\n+}\n+#[derive(Copy, Clone)]\n+pub struct Shadower {\n+    kind: ShadowKind,\n+    span: Span,\n+}\n+\n+pub fn original_label(span: Span) -> Original {\n+    Original { kind: ShadowKind::Label, span, param: false }\n+}\n+pub fn shadower_label(span: Span) -> Shadower {\n+    Shadower { kind: ShadowKind::Label, span }\n+}\n+pub fn original_lifetime(span: Span) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span, param: false }\n+}\n+pub fn original_lifetime_param(span: Span) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span, param: true }\n+}\n+pub fn shadower_lifetime(span: Span) -> Shadower {\n+    Shadower { kind: ShadowKind::Lifetime, span }\n+}\n+\n+impl ShadowKind {\n+    fn desc(&self) -> &'static str {\n+        match *self {\n+            ShadowKind::Label => \"label\",\n+            ShadowKind::Lifetime => \"lifetime\",\n+        }\n+    }\n+}\n+\n+pub fn signal_shadowing_problem(sess: &Session, name: Symbol, orig: Original, shadower: Shadower) {\n+    let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n+        // lifetime/lifetime shadowing is an error\n+        if orig.param {\n+            struct_span_err!(\n+                sess,\n+                shadower.span,\n+                E0263,\n+                \"lifetime name `{}` declared twice in the same scope\",\n+                name,\n+            )\n+        } else {\n+            struct_span_err!(\n+                sess,\n+                shadower.span,\n+                E0496,\n+                \"lifetime name `{}` shadows a lifetime name that is already in scope\",\n+                name,\n+            )\n+        }\n+        .forget_guarantee()\n+    } else {\n+        // shadowing involving a label is only a warning, due to issues with\n+        // labels and lifetimes not being macro-hygienic.\n+        sess.struct_span_warn(\n+            shadower.span,\n+            &format!(\n+                \"{} name `{}` shadows a {} name that is already in scope\",\n+                shadower.kind.desc(),\n+                name,\n+                orig.kind.desc()\n+            ),\n+        )\n+    };\n+    err.span_label(orig.span, \"first declared here\");\n+    err.span_label(shadower.span, format!(\"{} `{}` already in scope\", orig.kind.desc(), name));\n+    err.emit();\n+}\n+\n impl<'tcx> LifetimeContext<'_, 'tcx> {\n     pub(crate) fn report_missing_lifetime_specifiers(\n         &self,"}, {"sha": "59c2db25b8e05ad63e41b9291a445593581429fa", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 34, "deletions": 299, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1b0105c60cfca15930a6fdf8a3b07db528c749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=6e1b0105c60cfca15930a6fdf8a3b07db528c749", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -161,9 +161,6 @@ pub(crate) struct LifetimeContext<'a, 'tcx> {\n     /// we eventually need lifetimes resolve for trait items.\n     trait_definition_only: bool,\n \n-    /// List of labels in the function/method currently under analysis.\n-    labels_in_fn: Vec<Ident>,\n-\n     /// Cache for cross-crate per-definition object lifetime defaults.\n     xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n \n@@ -434,7 +431,6 @@ fn do_resolve(\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n         trait_definition_only,\n-        labels_in_fn: vec![],\n         xcrate_object_lifetime_defaults: Default::default(),\n         missing_named_lifetime_spots: vec![],\n     };\n@@ -641,14 +637,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        // Each body has their own set of labels, save labels.\n-        let saved = take(&mut self.labels_in_fn);\n         let body = self.tcx.hir().body(body);\n-        extract_labels(self, body);\n-        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n+        self.with(Scope::Body { id: body.id(), s: self.scope }, |this| {\n             this.visit_body(body);\n         });\n-        self.labels_in_fn = saved;\n     }\n \n     fn visit_fn(\n@@ -683,9 +675,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n                 };\n-                self.with(scope, move |_old_scope, this| {\n-                    intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n-                });\n+                self.with(scope, move |this| intravisit::walk_fn(this, fk, fd, b, s, hir_id));\n             }\n         }\n     }\n@@ -720,7 +710,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n                 let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n-                self.with(scope, |_, this| intravisit::walk_item(this, item));\n+                self.with(scope, |this| intravisit::walk_item(this, item));\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 // Opaque types are visited when we visit the\n@@ -807,10 +797,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: ROOT_SCOPE,\n                     allow_late_bound: false,\n                 };\n-                self.with(scope, |old_scope, this| {\n-                    this.check_lifetime_params(old_scope, &generics.params);\n+                self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |_, this| {\n+                    this.with(scope, |this| {\n                         intravisit::walk_item(this, item);\n                     });\n                 });\n@@ -873,18 +862,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n                 };\n-                self.with(scope, |old_scope, this| {\n+                self.with(scope, |this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n-                    this.check_lifetime_params(old_scope, &c.generic_params);\n                     intravisit::walk_ty(this, ty);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n             hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n                 let scope = Scope::TraitRefBoundary { s: self.scope };\n-                self.with(scope, |_, this| {\n+                self.with(scope, |this| {\n                     for bound in bounds {\n                         this.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                     }\n@@ -923,7 +911,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n                     s: self.scope,\n                 };\n-                self.with(scope, |_, this| this.visit_ty(&mt.ty));\n+                self.with(scope, |this| this.visit_ty(&mt.ty));\n             }\n             hir::TyKind::OpaqueDef(item_id, lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n@@ -944,9 +932,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // Elided lifetimes are not allowed in non-return\n                         // position impl Trait\n                         let scope = Scope::TraitRefBoundary { s: self.scope };\n-                        self.with(scope, |_, this| {\n+                        self.with(scope, |this| {\n                             let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n-                            this.with(scope, |_, this| {\n+                            this.with(scope, |this| {\n                                 intravisit::walk_item(this, opaque_ty);\n                             })\n                         });\n@@ -1052,7 +1040,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 if let Some(elision_region) = elision {\n                     let scope =\n                         Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n-                    self.with(scope, |_old_scope, this| {\n+                    self.with(scope, |this| {\n                         let scope = Scope::Binder {\n                             hir_id: ty.hir_id,\n                             lifetimes,\n@@ -1062,10 +1050,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: false,\n                         };\n-                        this.with(scope, |_old_scope, this| {\n+                        this.with(scope, |this| {\n                             this.visit_generics(generics);\n                             let scope = Scope::TraitRefBoundary { s: this.scope };\n-                            this.with(scope, |_, this| {\n+                            this.with(scope, |this| {\n                                 for bound in bounds {\n                                     this.visit_param_bound(bound);\n                                 }\n@@ -1082,9 +1070,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         scope_type: BinderScopeType::Normal,\n                         allow_late_bound: false,\n                     };\n-                    self.with(scope, |_old_scope, this| {\n+                    self.with(scope, |this| {\n                         let scope = Scope::TraitRefBoundary { s: this.scope };\n-                        this.with(scope, |_, this| {\n+                        this.with(scope, |this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n                                 this.visit_param_bound(bound);\n@@ -1141,10 +1129,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: false,\n                 };\n-                self.with(scope, |old_scope, this| {\n-                    this.check_lifetime_params(old_scope, &generics.params);\n+                self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |_, this| {\n+                    this.with(scope, |this| {\n                         this.visit_generics(generics);\n                         for bound in bounds {\n                             this.visit_param_bound(bound);\n@@ -1210,10 +1197,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n                 };\n-                self.with(scope, |old_scope, this| {\n-                    this.check_lifetime_params(old_scope, &generics.params);\n+                self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |_, this| {\n+                    this.with(scope, |this| {\n                         this.visit_generics(generics);\n                         this.visit_ty(ty);\n                     })\n@@ -1300,7 +1286,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         let scope = Scope::TraitRefBoundary { s: self.scope };\n-        self.with(scope, |_, this| {\n+        self.with(scope, |this| {\n             for param in generics.params {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n@@ -1354,8 +1340,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: true,\n                         };\n-                        this.with(scope, |old_scope, this| {\n-                            this.check_lifetime_params(old_scope, &bound_generic_params);\n+                        this.with(scope, |this| {\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_param_bound, bounds);\n                         })\n@@ -1427,7 +1412,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type,\n                     allow_late_bound: true,\n                 };\n-                self.with(scope, |_, this| {\n+                self.with(scope, |this| {\n                     intravisit::walk_param_bound(this, bound);\n                 });\n             }\n@@ -1479,8 +1464,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             scope_type,\n             allow_late_bound: true,\n         };\n-        self.with(scope, |old_scope, this| {\n-            this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n+        self.with(scope, |this| {\n             walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n             this.visit_trait_ref(&trait_ref.trait_ref);\n         });\n@@ -1491,154 +1475,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum ShadowKind {\n-    Label,\n-    Lifetime,\n-}\n-struct Original {\n-    kind: ShadowKind,\n-    span: Span,\n-}\n-struct Shadower {\n-    kind: ShadowKind,\n-    span: Span,\n-}\n-\n-fn original_label(span: Span) -> Original {\n-    Original { kind: ShadowKind::Label, span }\n-}\n-fn shadower_label(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Label, span }\n-}\n-fn original_lifetime(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span }\n-}\n-fn shadower_lifetime(param: &hir::GenericParam<'_>) -> Shadower {\n-    Shadower { kind: ShadowKind::Lifetime, span: param.span }\n-}\n-\n-impl ShadowKind {\n-    fn desc(&self) -> &'static str {\n-        match *self {\n-            ShadowKind::Label => \"label\",\n-            ShadowKind::Lifetime => \"lifetime\",\n-        }\n-    }\n-}\n-\n-fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: Symbol, orig: Original, shadower: Shadower) {\n-    let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n-        // lifetime/lifetime shadowing is an error\n-        struct_span_err!(\n-            tcx.sess,\n-            shadower.span,\n-            E0496,\n-            \"{} name `{}` shadows a \\\n-             {} name that is already in scope\",\n-            shadower.kind.desc(),\n-            name,\n-            orig.kind.desc()\n-        )\n-        .forget_guarantee()\n-    } else {\n-        // shadowing involving a label is only a warning, due to issues with\n-        // labels and lifetimes not being macro-hygienic.\n-        tcx.sess.struct_span_warn(\n-            shadower.span,\n-            &format!(\n-                \"{} name `{}` shadows a \\\n-                 {} name that is already in scope\",\n-                shadower.kind.desc(),\n-                name,\n-                orig.kind.desc()\n-            ),\n-        )\n-    };\n-    err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span, format!(\"{} `{}` already in scope\", orig.kind.desc(), name));\n-    err.emit();\n-}\n-\n-// Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n-// if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n-    struct GatherLabels<'a, 'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        scope: ScopeRef<'a>,\n-        labels_in_fn: &'a mut Vec<Ident>,\n-    }\n-\n-    let mut gather =\n-        GatherLabels { tcx: ctxt.tcx, scope: ctxt.scope, labels_in_fn: &mut ctxt.labels_in_fn };\n-    gather.visit_body(body);\n-\n-    impl<'v, 'a, 'tcx> Visitor<'v> for GatherLabels<'a, 'tcx> {\n-        fn visit_expr(&mut self, ex: &hir::Expr<'_>) {\n-            if let Some(label) = expression_label(ex) {\n-                for prior_label in &self.labels_in_fn[..] {\n-                    // FIXME (#24278): non-hygienic comparison\n-                    if label.name == prior_label.name {\n-                        signal_shadowing_problem(\n-                            self.tcx,\n-                            label.name,\n-                            original_label(prior_label.span),\n-                            shadower_label(label.span),\n-                        );\n-                    }\n-                }\n-\n-                check_if_label_shadows_lifetime(self.tcx, self.scope, label);\n-\n-                self.labels_in_fn.push(label);\n-            }\n-            intravisit::walk_expr(self, ex)\n-        }\n-    }\n-\n-    fn expression_label(ex: &hir::Expr<'_>) -> Option<Ident> {\n-        match ex.kind {\n-            hir::ExprKind::Loop(_, Some(label), ..) => Some(label.ident),\n-            hir::ExprKind::Block(_, Some(label)) => Some(label.ident),\n-            _ => None,\n-        }\n-    }\n-\n-    fn check_if_label_shadows_lifetime(tcx: TyCtxt<'_>, mut scope: ScopeRef<'_>, label: Ident) {\n-        loop {\n-            match *scope {\n-                Scope::Body { s, .. }\n-                | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n-                    scope = s;\n-                }\n-\n-                Scope::Root => {\n-                    return;\n-                }\n-\n-                Scope::Binder { ref lifetimes, s, .. } => {\n-                    // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) =\n-                        lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n-                    {\n-                        signal_shadowing_problem(\n-                            tcx,\n-                            label.name,\n-                            original_lifetime(tcx.def_span(def.id().unwrap().expect_local())),\n-                            shadower_label(label.span),\n-                        );\n-                        return;\n-                    }\n-                    scope = s;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn compute_object_lifetime_defaults<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &hir::Item<'_>,\n@@ -1774,27 +1610,24 @@ fn object_lifetime_defaults_for_item<'tcx>(\n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n-        F: for<'b> FnOnce(ScopeRef<'_>, &mut LifetimeContext<'b, 'tcx>),\n+        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n             trait_definition_only: self.trait_definition_only,\n-            labels_in_fn,\n             xcrate_object_lifetime_defaults,\n             missing_named_lifetime_spots,\n         };\n         let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n-            f(self.scope, &mut this);\n+            f(&mut this);\n         }\n-        self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n     }\n@@ -1891,10 +1724,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             scope_type: BinderScopeType::Normal,\n             allow_late_bound: true,\n         };\n-        self.with(scope, move |old_scope, this| {\n-            this.check_lifetime_params(old_scope, &generics.params);\n-            walk(this);\n-        });\n+        self.with(scope, walk);\n     }\n \n     fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n@@ -2165,7 +1995,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 GenericArg::Type(ty) => {\n                     if let Some(&lt) = object_lifetime_defaults.get(i) {\n                         let scope = Scope::ObjectLifetimeDefault { lifetime: lt, s: self.scope };\n-                        self.with(scope, |_, this| this.visit_ty(ty));\n+                        self.with(scope, |this| this.visit_ty(ty));\n                     } else {\n                         self.visit_ty(ty);\n                     }\n@@ -2222,15 +2052,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     type_def_id,\n                     binding.ident,\n                 );\n-                self.with(scope, |_, this| {\n+                self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n                         lifetimes: lifetimes.unwrap_or_default(),\n                         s: this.scope,\n                     };\n-                    this.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                    this.with(scope, |this| this.visit_assoc_type_binding(binding));\n                 });\n             } else {\n-                self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                self.with(scope, |this| this.visit_assoc_type_binding(binding));\n             }\n         }\n     }\n@@ -2346,7 +2176,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n             s: self.scope,\n         };\n-        self.with(arg_scope, |_, this| {\n+        self.with(arg_scope, |this| {\n             for input in inputs {\n                 this.visit_ty(input);\n             }\n@@ -2466,7 +2296,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             visitor.visit_ty(&inputs[0]);\n             if let Set1::One(lifetime) = visitor.lifetime {\n                 let scope = Scope::Elision { elide: Elide::Exact(lifetime), s: self.scope };\n-                self.with(scope, |_, this| this.visit_ty(output));\n+                self.with(scope, |this| this.visit_ty(output));\n                 return;\n             }\n         }\n@@ -2517,7 +2347,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         debug!(?elide);\n \n         let scope = Scope::Elision { elide, s: self.scope };\n-        self.with(scope, |_, this| this.visit_ty(output));\n+        self.with(scope, |this| this.visit_ty(output));\n \n         struct GatherLifetimes<'a> {\n             map: &'a NamedRegionMap,\n@@ -2789,101 +2619,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_params(\n-        &mut self,\n-        old_scope: ScopeRef<'_>,\n-        params: &'tcx [hir::GenericParam<'tcx>],\n-    ) {\n-        let lifetimes: Vec<_> = params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    Some((param, param.name.normalize_to_macros_2_0()))\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n-            if let hir::ParamName::Plain(_) = lifetime_i_name {\n-                let name = lifetime_i_name.ident().name;\n-                if name == kw::UnderscoreLifetime || name == kw::StaticLifetime {\n-                    self.tcx.sess.delay_span_bug(\n-                        lifetime_i.span,\n-                        &format!(\"invalid lifetime parameter name: `{}`\", lifetime_i.name.ident()),\n-                    );\n-                }\n-            }\n-\n-            // It is a hard error to shadow a lifetime within the same scope.\n-            for (lifetime_j, lifetime_j_name) in lifetimes.iter().skip(i + 1) {\n-                if lifetime_i_name == lifetime_j_name {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        lifetime_j.span,\n-                        E0263,\n-                        \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.name.ident()\n-                    )\n-                    .span_label(lifetime_j.span, \"declared twice\")\n-                    .span_label(lifetime_i.span, \"previous declaration here\")\n-                    .emit();\n-                }\n-            }\n-\n-            // It is a soft error to shadow a lifetime within a parent scope.\n-            self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n-        }\n-    }\n-\n-    fn check_lifetime_param_for_shadowing(\n-        &self,\n-        mut old_scope: ScopeRef<'_>,\n-        param: &'tcx hir::GenericParam<'tcx>,\n-    ) {\n-        for label in &self.labels_in_fn {\n-            // FIXME (#24278): non-hygienic comparison\n-            if param.name.ident().name == label.name {\n-                signal_shadowing_problem(\n-                    self.tcx,\n-                    label.name,\n-                    original_label(label.span),\n-                    shadower_lifetime(&param),\n-                );\n-                return;\n-            }\n-        }\n-\n-        loop {\n-            match *old_scope {\n-                Scope::Body { s, .. }\n-                | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n-                    old_scope = s;\n-                }\n-\n-                Scope::Root => {\n-                    return;\n-                }\n-\n-                Scope::Binder { ref lifetimes, s, .. } => {\n-                    if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        signal_shadowing_problem(\n-                            self.tcx,\n-                            param.name.ident().name,\n-                            original_lifetime(self.tcx.def_span(def.id().unwrap())),\n-                            shadower_lifetime(&param),\n-                        );\n-                        return;\n-                    }\n-\n-                    old_scope = s;\n-                }\n-            }\n-        }\n-    }\n-\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n         debug!("}]}