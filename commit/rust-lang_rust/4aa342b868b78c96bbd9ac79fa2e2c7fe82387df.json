{"sha": "4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYTM0MmI4NjhiNzhjOTZiYmQ5YWM3OWZhMmUyYzdmZTgyMzg3ZGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-26T03:21:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-26T03:21:13Z"}, "message": "Revert \"auto merge of #8745 : brson/rust/metadata, r=cmr\"\n\nThis reverts commit 491bc3568c87dadaba4d342135bd308961c6e0ef, reversing\nchanges made to 05f1bbba16912f63b562a7847801823872f89ec6.", "tree": {"sha": "bafcb39f0a7be2ece506ba9cb3cc20be8804a197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bafcb39f0a7be2ece506ba9cb3cc20be8804a197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "html_url": "https://github.com/rust-lang/rust/commit/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491bc3568c87dadaba4d342135bd308961c6e0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/491bc3568c87dadaba4d342135bd308961c6e0ef", "html_url": "https://github.com/rust-lang/rust/commit/491bc3568c87dadaba4d342135bd308961c6e0ef"}], "stats": {"total": 223, "additions": 90, "deletions": 133}, "files": [{"sha": "f070ae37dda8da2807a11f092f0e4cf27def15af", "filename": "configure", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/configure", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -381,8 +381,7 @@ opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n opt clang 0 \"prefer clang to gcc for building the runtime\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched\n- kernels)\"\n+opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched kernels)\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n valopt local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt llvm-root \"\" \"set LLVM root\""}, {"sha": "f66677c21f7d11c2e40d53e348a14ed5f33bc16b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 20, "deletions": 57, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -12,8 +12,6 @@\n \n \n use std::str;\n-use std::cast;\n-use std::vec;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -31,42 +29,9 @@ struct EbmlState {\n     data_pos: uint,\n }\n \n-#[deriving(Clone)]\n-pub enum EbmlData {\n-    SafeData(@~[u8]),\n-    UnsafeData(*u8, uint)\n-}\n-\n-impl EbmlData {\n-    #[inline]\n-    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [u8] {\n-        match *self {\n-            SafeData(@ref v) => v.slice(start, end),\n-            UnsafeData(buf, len) => unsafe {\n-                do vec::raw::buf_as_slice(buf, len) |s| {\n-                    cast::transmute(s.slice(start, end))\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        self.slice(0, self.len())\n-    }\n-\n-    #[inline]\n-    pub fn len(&self) -> uint {\n-        match *self {\n-            SafeData(@ref v) => v.len(),\n-            UnsafeData(_, len) => len\n-        }\n-    }\n-}\n-\n #[deriving(Clone)]\n pub struct Doc {\n-    data: EbmlData,\n+    data: @~[u8],\n     start: uint,\n     end: uint,\n }\n@@ -220,28 +185,24 @@ pub mod reader {\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n-        Doc { data: SafeData(data), start: 0u, end: data.len() }\n-    }\n-\n-    pub fn unsafe_Doc(buf: *u8, len: uint) -> Doc {\n-        Doc { data: UnsafeData(buf, len), start: 0u, end: len }\n+        Doc { data: data, start: 0u, end: data.len() }\n     }\n \n-    pub fn doc_at(data: &EbmlData, start: uint) -> TaggedDoc {\n-        let elt_tag = vuint_at(data.as_slice(), start);\n-        let elt_size = vuint_at(data.as_slice(), elt_tag.next);\n+    pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n+        let elt_tag = vuint_at(*data, start);\n+        let elt_size = vuint_at(*data, elt_tag.next);\n         let end = elt_size.next + elt_size.val;\n         TaggedDoc {\n             tag: elt_tag.val,\n-            doc: Doc { data: data.clone(), start: elt_size.next, end: end }\n+            doc: Doc { data: data, start: elt_size.next, end: end }\n         }\n     }\n \n     pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data.as_slice(), pos);\n-            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -264,8 +225,8 @@ pub mod reader {\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data.as_slice(), pos);\n-            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -278,8 +239,8 @@ pub mod reader {\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data.as_slice(), pos);\n-            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -299,22 +260,22 @@ pub mod reader {\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n-        d.data.as_slice()[d.start]\n+        (*d.data)[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        io::u64_from_be_bytes(d.data.as_slice(), d.start, 2u) as u16\n+        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        io::u64_from_be_bytes(d.data.as_slice(), d.start, 4u) as u32\n+        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        io::u64_from_be_bytes(d.data.as_slice(), d.start, 8u)\n+        io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -337,7 +298,8 @@ pub mod reader {\n     impl Decoder {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n+                let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                    doc_at(self.parent.data, self.pos);\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n@@ -354,7 +316,8 @@ pub mod reader {\n             if self.pos >= self.parent.end {\n                 fail!(\"no more documents in current node!\");\n             }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n             debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                    self.parent.start,\n                    self.parent.end,"}, {"sha": "e0c5a729b3f88116804e629eb3c7df6b9d890cdc", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -763,7 +763,7 @@ pub fn build_session_options(binary: @str,\n         parse_only: parse_only,\n         no_trans: no_trans,\n         debugging_opts: debugging_opts,\n-        android_cross_path: android_cross_path,\n+        android_cross_path: android_cross_path\n     };\n     return sopts;\n }"}, {"sha": "c8c4a396c87af99c0041f1274fcd3acf92b353c7", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -15,7 +15,6 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n-use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n@@ -309,7 +308,7 @@ fn resolve_crate(e: @mut Env,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: @mut Env, cdata: MetadataSection) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "317b9cf6ce34f7c82abe9594403f448905d1ce1f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -188,7 +188,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                       def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = reader::get_doc(decoder::section_to_ebml_doc(cdata.data), tag_items);\n+    let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "a5f541412ded9b84715b777e58f1c4aabdc093eb", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -15,7 +15,6 @@\n \n use metadata::cstore;\n use metadata::decoder;\n-use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use extra;\n@@ -30,7 +29,7 @@ pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub struct crate_metadata {\n     name: @str,\n-    data: MetadataSection,\n+    data: @~[u8],\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n }"}, {"sha": "9eb09806bc07dc0ea6e12bae27951225772564a3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -20,7 +20,6 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n-use metadata::loader::{MetadataSection, UnsafeSection};\n use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n@@ -57,16 +56,16 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = io::u64_from_be_bytes(d.data.as_slice(), hash_pos, 4) as uint;\n-    let tagged_doc = reader::doc_at(&d.data, pos);\n+    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n+    let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(elt.data.as_slice(), elt.start, 4) as uint;\n+        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n-            ret = Some(reader::doc_at(&d.data, pos).doc);\n+            ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n         } else {\n             true\n@@ -97,8 +96,8 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: MetadataSection) -> ebml::Doc {\n-    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n+fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n+    let items = reader::get_doc(reader::Doc(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -216,13 +215,13 @@ fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n+    parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n+    parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n@@ -231,7 +230,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            cdata: cmd) -> Option<ty::t>\n {\n     do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n-        parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n+        parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n     }\n }\n@@ -242,7 +241,7 @@ pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n-    parse_trait_ref_data(doc.data.as_slice(), cdata.cnum, doc.start, tcx,\n+    parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n@@ -257,7 +256,7 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     let mut bounds = ~[];\n     do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n-            p.data.as_slice(), p.start, cdata.cnum, tcx,\n+            *p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n@@ -360,7 +359,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: MetadataSection, did_: ast::def_id) ->\n+pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let did = ast::def_id { crate: cnum, node: did_.node };\n@@ -419,7 +418,7 @@ pub fn get_region_param(cdata: cmd, id: ast::NodeId)\n     return item_ty_region_param(item);\n }\n \n-pub fn get_type_param_count(data: MetadataSection, id: ast::NodeId) -> uint {\n+pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n@@ -450,7 +449,7 @@ pub fn get_impl_vtables(cdata: cmd,\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n-    let items = reader::get_doc(section_to_ebml_doc(cdata.data), tag_items);\n+    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n@@ -462,7 +461,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     found\n }\n \n-pub fn get_symbol(data: MetadataSection, id: ast::NodeId) -> ~str {\n+pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -483,7 +482,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n-    let root = section_to_ebml_doc(cdata.data);\n+    let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -578,10 +577,10 @@ impl<'self> EachItemContext<'self> {\n     fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n         // This item might not be in this crate. If it's not, look it up.\n         let items = if def_id.crate == self.cdata.cnum {\n-            reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n+            reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n         } else {\n             let crate_data = (self.get_crate_data)(def_id.crate);\n-            let root = section_to_ebml_doc(crate_data.data);\n+            let root = reader::Doc(crate_data.data);\n             reader::get_doc(root, tag_items)\n         };\n \n@@ -607,10 +606,10 @@ impl<'self> EachItemContext<'self> {\n             // a reexport.\n             let other_crates_items = if child_def_id.crate ==\n                     self.cdata.cnum {\n-                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(child_def_id.crate);\n-                let root = section_to_ebml_doc(crate_data.data);\n+                let root = reader::Doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -674,10 +673,10 @@ impl<'self> EachItemContext<'self> {\n \n             // This reexport may be in yet another crate.\n             let other_crates_items = if def_id.crate == self.cdata.cnum {\n-                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(def_id.crate);\n-                let root = section_to_ebml_doc(crate_data.data);\n+                let root = reader::Doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -709,7 +708,7 @@ pub fn each_path(intr: @ident_interner,\n     // make fast. It's the source of most of the performance problems when\n     // compiling small crates.\n \n-    let root_doc = section_to_ebml_doc(cdata.data);\n+    let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -769,7 +768,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n-    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n+    let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -1207,14 +1206,8 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(\"\\n\\n\");\n }\n \n-pub fn get_crate_attributes(data: MetadataSection) -> ~[ast::Attribute] {\n-    return get_attributes(section_to_ebml_doc(data));\n-}\n-\n-pub fn section_to_ebml_doc(data: MetadataSection) -> ebml::Doc {\n-    match data {\n-        UnsafeSection(_, buf, len) => reader::unsafe_Doc(buf, len)\n-    }\n+pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n+    return get_attributes(reader::Doc(data));\n }\n \n #[deriving(Clone)]\n@@ -1225,9 +1218,9 @@ pub struct crate_dep {\n     hash: @str\n }\n \n-pub fn get_crate_deps(data: MetadataSection) -> ~[crate_dep] {\n+pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = section_to_ebml_doc(data);\n+    let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n@@ -1245,7 +1238,7 @@ pub fn get_crate_deps(data: MetadataSection) -> ~[crate_dep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: MetadataSection, out: @io::Writer) {\n+fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n@@ -1258,13 +1251,13 @@ fn list_crate_deps(data: MetadataSection, out: @io::Writer) {\n     out.write_str(\"\\n\");\n }\n \n-pub fn get_crate_hash(data: MetadataSection) -> @str {\n-    let cratedoc = section_to_ebml_doc(data);\n+pub fn get_crate_hash(data: @~[u8]) -> @str {\n+    let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: MetadataSection) -> @str {\n+pub fn get_crate_vers(data: @~[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n@@ -1289,10 +1282,10 @@ fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n     };\n }\n \n-pub fn list_crate_metadata(intr: @ident_interner, bytes: MetadataSection,\n+pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = section_to_ebml_doc(bytes);\n+    let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(bytes, out);\n }\n@@ -1314,7 +1307,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n }\n \n pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n-    let link_args = reader::get_doc(section_to_ebml_doc(cdata.data), tag_link_args);\n+    let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     do reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n         result.push(arg_doc.as_str());"}, {"sha": "dbed508348d03297de14364ec2e9316a6f854fda", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -26,6 +26,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::io;\n use std::str;\n use std::vec;\n+use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n use syntax::abi::AbiSet;\n@@ -1569,7 +1570,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x75, //'u' as u8,\n       0x73, //'s' as u8,\n       0x74, //'t' as u8,\n-      0, 0, 0, 2 ];\n+      0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     let wr = @io::BytesWriter::new();\n@@ -1682,7 +1683,8 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     let writer_bytes: &mut ~[u8] = wr.bytes;\n \n-    return metadata_encoding_version.to_owned() + *writer_bytes;\n+    metadata_encoding_version.to_owned() +\n+        flate::deflate_bytes(*writer_bytes)\n }\n \n // Get the encoded string for a type"}, {"sha": "d0060931a6607eca54c753346ff492fbf8146d20", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -11,7 +11,7 @@\n //! Finds crate binaries and loads their metadata\n \n \n-use lib::llvm::{False, llvm, mk_object_file, mk_section_iter, ObjectFile};\n+use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::FileSearch;\n@@ -32,6 +32,7 @@ use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n use std::str;\n use std::vec;\n+use extra::flate;\n \n pub enum os {\n     os_macos,\n@@ -53,14 +54,7 @@ pub struct Context {\n     intr: @ident_interner\n }\n \n-#[deriving(Clone)]\n-pub enum MetadataSection {\n-    // A pointer to the object file metadata section, along with\n-    // the ObjectFile handle that keeps it from being destructed\n-    UnsafeSection(@ObjectFile, *u8, uint)\n-}\n-\n-pub fn load_library_crate(cx: &Context) -> (~str, MetadataSection) {\n+pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n       Some(t) => t,\n       None => {\n@@ -71,7 +65,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, MetadataSection) {\n     }\n }\n \n-fn find_library_crate(cx: &Context) -> Option<(~str, MetadataSection)> {\n+fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n@@ -93,7 +87,7 @@ fn find_library_crate_aux(\n     cx: &Context,\n     (prefix, suffix): (~str, ~str),\n     filesearch: @filesearch::FileSearch\n-) -> Option<(~str, MetadataSection)> {\n+) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n     let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n@@ -177,7 +171,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n     }\n }\n \n-fn crate_matches(crate_data: MetadataSection,\n+fn crate_matches(crate_data: @~[u8],\n                  metas: &[@ast::MetaItem],\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n@@ -203,24 +197,25 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: &Path) -> Option<MetadataSection> {\n+                        filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n         let mb = do filename.with_c_str |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         };\n-        if mb as int == 0 { return None; }\n-        let of = @match mk_object_file(mb) {\n+        if mb as int == 0 { return option::None::<@~[u8]>; }\n+        let of = match mk_object_file(mb) {\n             option::Some(of) => of,\n-            _ => return None\n+            _ => return option::None::<@~[u8]>\n         };\n-        let si = mk_section_iter((*of).llof);\n+        let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n             debug!(\"get_metadata_section: name %s\", name);\n             if name == read_meta_section_name(os) {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n+                let mut found = None;\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking %u bytes of metadata-version stamp\",\n@@ -234,12 +229,19 @@ fn get_metadata_section(os: os,\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n-\n-                return Some(UnsafeSection(of, cvbuf1, csz-vlen))\n+                debug!(\"inflating %u bytes of compressed metadata\",\n+                       csz - vlen);\n+                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n+                    let inflated = flate::inflate_bytes(bytes);\n+                    found = Some(@(inflated));\n+                }\n+                if found != None {\n+                    return found;\n+                }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return None;\n+        return option::None::<@~[u8]>;\n     }\n }\n "}, {"sha": "a22daac90b5517e7c30fb48ef77850a7f6cb54a3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aa342b868b78c96bbd9ac79fa2e2c7fe82387df/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4aa342b868b78c96bbd9ac79fa2e2c7fe82387df", "patch": "@@ -1022,7 +1022,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         do self.read_opaque |_, doc| {\n             tydecode::parse_ty_data(\n-                doc.data.as_slice(),\n+                *doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n@@ -1044,7 +1044,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n         return do self.read_opaque |this, doc| {\n             let ty = tydecode::parse_ty_data(\n-                doc.data.as_slice(),\n+                *doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n@@ -1060,7 +1060,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for i in range(doc.start, doc.end) {\n-                str.push_char(doc.data.as_slice()[i] as char);\n+                str.push_char(doc.data[i] as char);\n             }\n             str\n         }\n@@ -1074,7 +1074,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                            -> ty::TypeParameterDef {\n         do self.read_opaque |this, doc| {\n             tydecode::parse_type_param_def_data(\n-                doc.data.as_slice(),\n+                *doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,"}]}