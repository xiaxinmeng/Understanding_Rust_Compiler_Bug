{"sha": "0363a23c357e9ace418573b424233353eea62cbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNjNhMjNjMzU3ZTlhY2U0MTg1NzNiNDI0MjMzMzUzZWVhNjJjYmM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-23T14:37:12Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-10T10:21:39Z"}, "message": "incr.comp.: Introduce the concept of anonymous DepNodes.", "tree": {"sha": "25dbc787117a4190653b2d51fd68faf2c9f0ce54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25dbc787117a4190653b2d51fd68faf2c9f0ce54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0363a23c357e9ace418573b424233353eea62cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0363a23c357e9ace418573b424233353eea62cbc", "html_url": "https://github.com/rust-lang/rust/commit/0363a23c357e9ace418573b424233353eea62cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0363a23c357e9ace418573b424233353eea62cbc/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "089860b60387bbd8c21969d7246e2baec4f76805", "url": "https://api.github.com/repos/rust-lang/rust/commits/089860b60387bbd8c21969d7246e2baec4f76805", "html_url": "https://github.com/rust-lang/rust/commit/089860b60387bbd8c21969d7246e2baec4f76805"}], "stats": {"total": 290, "additions": 200, "deletions": 90}, "files": [{"sha": "c6275e84645843296d34ac08bb6781de4c4b9a82", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 117, "deletions": 88, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=0363a23c357e9ace418573b424233353eea62cbc", "patch": "@@ -79,9 +79,14 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n+macro_rules! anon_attr_to_bool {\n+    (anon) => (true)\n+}\n+\n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n+        [$($anon:ident)*]\n         $variant:ident $(( $($tuple_arg:tt),* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n@@ -117,6 +122,19 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn is_anon<$tcx>(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            $(return anon_attr_to_bool!($anon);)*\n+                            false\n+                        }\n+                    )*\n+                }\n+            }\n+\n             #[allow(unreachable_code)]\n             #[inline]\n             pub fn has_params(&self) -> bool {\n@@ -356,100 +374,101 @@ define_dep_nodes!( <'tcx>\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n     // edges yourself for the individual items that you read.\n-    Krate,\n+    [] Krate,\n \n     // Represents the HIR node with the given node-id\n-    Hir(DefId),\n+    [] Hir(DefId),\n \n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n-    HirBody(DefId),\n+    [] HirBody(DefId),\n \n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n-    MetaData(DefId),\n+    [] MetaData(DefId),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n-    WorkProduct(WorkProductId),\n+    [] WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n-    RegionMaps(DefId),\n-    Coherence,\n-    Resolve,\n-    CoherenceCheckTrait(DefId),\n-    PrivacyAccessLevels(CrateNum),\n+    [] RegionMaps(DefId),\n+    [] Coherence,\n+    [] Resolve,\n+    [] CoherenceCheckTrait(DefId),\n+    [] PrivacyAccessLevels(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n-    MirConstQualif(DefId),\n-    MirConst(DefId),\n-    MirValidated(DefId),\n-    MirOptimized(DefId),\n-    MirShim { instance_def: InstanceDef<'tcx> },\n-\n-    BorrowCheckKrate,\n-    BorrowCheck(DefId),\n-    RvalueCheck(DefId),\n-    Reachability,\n-    MirKeys,\n-    TransWriteMetadata,\n-    CrateVariances,\n+    [] MirConstQualif(DefId),\n+    [] MirConst(DefId),\n+    [] MirValidated(DefId),\n+    [] MirOptimized(DefId),\n+    [] MirShim { instance_def: InstanceDef<'tcx> },\n+\n+    [] BorrowCheckKrate,\n+    [] BorrowCheck(DefId),\n+    [] RvalueCheck(DefId),\n+    [] Reachability,\n+    [] MirKeys,\n+    [] TransWriteMetadata,\n+    [] CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n     // nodes.\n-    AssociatedItems(DefId),\n-    TypeOfItem(DefId),\n-    GenericsOfItem(DefId),\n-    PredicatesOfItem(DefId),\n-    SuperPredicatesOfItem(DefId),\n-    TraitDefOfItem(DefId),\n-    AdtDefOfItem(DefId),\n-    IsDefaultImpl(DefId),\n-    ImplTraitRef(DefId),\n-    ImplPolarity(DefId),\n-    ClosureKind(DefId),\n-    FnSignature(DefId),\n-    CoerceUnsizedInfo(DefId),\n-\n-    ItemVarianceConstraints(DefId),\n-    ItemVariances(DefId),\n-    IsConstFn(DefId),\n-    IsForeignItem(DefId),\n-    TypeParamPredicates { item_id: DefId, param_id: DefId },\n-    SizedConstraint(DefId),\n-    DtorckConstraint(DefId),\n-    AdtDestructor(DefId),\n-    AssociatedItemDefIds(DefId),\n-    InherentImpls(DefId),\n-    TypeckBodiesKrate,\n-    TypeckTables(DefId),\n-    HasTypeckTables(DefId),\n-    ConstEval { def_id: DefId, substs: &'tcx Substs<'tcx> },\n-    SymbolName(DefId),\n-    InstanceSymbolName { instance: Instance<'tcx> },\n-    SpecializationGraph(DefId),\n-    ObjectSafety(DefId),\n-    IsCopy(DefId),\n-    IsSized(DefId),\n-    IsFreeze(DefId),\n-    NeedsDrop(DefId),\n-    Layout(DefId),\n+    [] AssociatedItems(DefId),\n+    [] TypeOfItem(DefId),\n+    [] GenericsOfItem(DefId),\n+    [] PredicatesOfItem(DefId),\n+    [] SuperPredicatesOfItem(DefId),\n+    [] TraitDefOfItem(DefId),\n+    [] AdtDefOfItem(DefId),\n+    [] IsDefaultImpl(DefId),\n+    [] ImplTraitRef(DefId),\n+    [] ImplPolarity(DefId),\n+    [] ClosureKind(DefId),\n+    [] FnSignature(DefId),\n+    [] CoerceUnsizedInfo(DefId),\n+\n+    [] ItemVarianceConstraints(DefId),\n+    [] ItemVariances(DefId),\n+    [] IsConstFn(DefId),\n+    [] IsForeignItem(DefId),\n+    [] TypeParamPredicates { item_id: DefId, param_id: DefId },\n+    [] SizedConstraint(DefId),\n+    [] DtorckConstraint(DefId),\n+    [] AdtDestructor(DefId),\n+    [] AssociatedItemDefIds(DefId),\n+    [] InherentImpls(DefId),\n+    [] TypeckBodiesKrate,\n+    [] TypeckTables(DefId),\n+    [] HasTypeckTables(DefId),\n+    [] ConstEval { def_id: DefId, substs: &'tcx Substs<'tcx> },\n+    [] SymbolName(DefId),\n+    [] InstanceSymbolName { instance: Instance<'tcx> },\n+    [] SpecializationGraph(DefId),\n+    [] ObjectSafety(DefId),\n+\n+    [anon] IsCopy(DefId),\n+    [anon] IsSized(DefId),\n+    [anon] IsFreeze(DefId),\n+    [anon] NeedsDrop(DefId),\n+    [anon] Layout(DefId),\n \n     // The set of impls for a given trait.\n-    TraitImpls(DefId),\n-    RelevantTraitImpls(DefId, SimplifiedType),\n+    [] TraitImpls(DefId),\n+    [] RelevantTraitImpls(DefId, SimplifiedType),\n \n-    AllLocalTraitImpls,\n+    [] AllLocalTraitImpls,\n \n     // Nodes representing caches. To properly handle a true cache, we\n     // don't use a DepTrackingMap, but rather we push a task node.\n     // Otherwise the write into the map would be incorrectly\n     // attributed to the first task that happened to fill the cache,\n     // which would yield an overly conservative dep-graph.\n-    TraitItems(DefId),\n-    ReprHints(DefId),\n+    [] TraitItems(DefId),\n+    [] ReprHints(DefId),\n \n     // Trait selection cache is a little funny. Given a trait\n     // reference like `Foo: SomeTrait<Bar>`, there could be\n@@ -476,35 +495,45 @@ define_dep_nodes!( <'tcx>\n     // imprecision in our dep-graph tracking.  The important thing is\n     // that for any given trait-ref, we always map to the **same**\n     // trait-select node.\n-    TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+    [] TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n \n     // For proj. cache, we just keep a list of all def-ids, since it is\n     // not a hotspot.\n-    ProjectionCache { def_ids: DefIdList },\n-\n-    ParamEnv(DefId),\n-    DescribeDef(DefId),\n-    DefSpan(DefId),\n-    Stability(DefId),\n-    Deprecation(DefId),\n-    ItemBodyNestedBodies(DefId),\n-    ConstIsRvaluePromotableToStatic(DefId),\n-    ImplParent(DefId),\n-    TraitOfItem(DefId),\n-    IsExportedSymbol(DefId),\n-    IsMirAvailable(DefId),\n-    ItemAttrs(DefId),\n-    FnArgNames(DefId),\n-    DylibDepFormats(DefId),\n-    IsAllocator(DefId),\n-    IsPanicRuntime(DefId),\n-    ExternCrate(DefId),\n+    [] ProjectionCache { def_ids: DefIdList },\n+\n+    [] ParamEnv(DefId),\n+    [] DescribeDef(DefId),\n+    [] DefSpan(DefId),\n+    [] Stability(DefId),\n+    [] Deprecation(DefId),\n+    [] ItemBodyNestedBodies(DefId),\n+    [] ConstIsRvaluePromotableToStatic(DefId),\n+    [] ImplParent(DefId),\n+    [] TraitOfItem(DefId),\n+    [] IsExportedSymbol(DefId),\n+    [] IsMirAvailable(DefId),\n+    [] ItemAttrs(DefId),\n+    [] FnArgNames(DefId),\n+    [] DylibDepFormats(DefId),\n+    [] IsAllocator(DefId),\n+    [] IsPanicRuntime(DefId),\n+    [] ExternCrate(DefId),\n );\n \n-trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n-    fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint;\n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String;\n+\n+    /// This method turns the parameters of a DepNodeConstructor into an opaque\n+    /// Fingerprint to be used in DepNode.\n+    /// Not all DepNodeParams support being turned into a Fingerprint (they\n+    /// don't need to if the corresponding DepNode is anonymous).\n+    fn to_fingerprint(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n+    }\n+\n+    fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        format!(\"{:?}\", self)\n+    }\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T"}, {"sha": "e67d65841d5923dab9560f03bd113354e59b7688", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=0363a23c357e9ace418573b424233353eea62cbc", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use ich::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::env;\n-use super::{DepGraphQuery, DepNode};\n+use std::hash::Hash;\n+use std::mem;\n+use super::{DepGraphQuery, DepKind, DepNode};\n use super::debug::EdgeFilter;\n \n pub struct DepGraphEdges {\n@@ -44,6 +48,10 @@ enum OpenTask {\n         reads: Vec<DepNode>,\n         read_set: FxHashSet<DepNode>,\n     },\n+    Anon {\n+        reads: Vec<DepNode>,\n+        read_set: FxHashSet<DepNode>,\n+    },\n     Ignore,\n }\n \n@@ -114,6 +122,56 @@ impl DepGraphEdges {\n         }\n     }\n \n+    pub fn push_anon_task(&mut self) {\n+        self.task_stack.push(OpenTask::Anon {\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    pub fn pop_anon_task(&mut self, kind: DepKind) -> DepNode {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Anon {\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            let mut fingerprint = Fingerprint::zero();\n+            let mut hasher = StableHasher::new();\n+\n+            for read in reads.iter() {\n+                mem::discriminant(&read.kind).hash(&mut hasher);\n+\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                fingerprint = fingerprint.combine(read.hash);\n+            }\n+\n+            fingerprint = fingerprint.combine(hasher.finish());\n+\n+            let target_dep_node = DepNode {\n+                kind,\n+                hash: fingerprint,\n+            };\n+\n+            if self.indices.contains_key(&target_dep_node) {\n+                return target_dep_node;\n+            }\n+\n+            let target_id = self.get_or_create_node(target_dep_node);\n+\n+            for read in reads.into_iter() {\n+                let source_id = self.get_or_create_node(read);\n+                self.edges.insert((source_id, target_id));\n+            }\n+\n+            target_dep_node\n+        } else {\n+            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+        }\n+    }\n+\n     /// Indicates that the current task `C` reads `v` by adding an\n     /// edge from `v` to `C`. If there is no current task, has no\n     /// effect. Note that *reading* from tracked state is harmless if\n@@ -138,6 +196,14 @@ impl DepGraphEdges {\n                     }\n                 }\n             }\n+            Some(&mut OpenTask::Anon {\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n             Some(&mut OpenTask::Ignore) | None => {\n                 // ignore\n             }"}, {"sha": "295b402c533eecfe30f430be663de8601c60cb17", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0363a23c357e9ace418573b424233353eea62cbc/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0363a23c357e9ace418573b424233353eea62cbc", "patch": "@@ -13,7 +13,7 @@ use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n \n-use super::dep_node::{DepNode, WorkProductId};\n+use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n@@ -115,6 +115,21 @@ impl DepGraph {\n         task(cx, arg)\n     }\n \n+    /// Execute something within an \"anonymous\" task, that is, a task the\n+    /// DepNode of which is determined by the list of inputs it read from.\n+    pub fn with_anon_task<OP,R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNode)\n+        where OP: FnOnce() -> R\n+    {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().push_anon_task();\n+            let result = op();\n+            let dep_node = data.edges.borrow_mut().pop_anon_task(dep_kind);\n+            (result, dep_node)\n+        } else {\n+            (op(), DepNode::new_no_params(DepKind::Krate))\n+        }\n+    }\n+\n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {"}]}