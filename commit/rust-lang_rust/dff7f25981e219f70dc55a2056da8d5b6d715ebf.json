{"sha": "dff7f25981e219f70dc55a2056da8d5b6d715ebf", "node_id": "C_kwDOAAsO6NoAKGRmZjdmMjU5ODFlMjE5ZjcwZGM1NWEyMDU2ZGE4ZDViNmQ3MTVlYmY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T23:45:39Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T23:47:19Z"}, "message": "suggestion if struct field has method", "tree": {"sha": "213c616bcc93720a75077d10f32509a9883f0bcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/213c616bcc93720a75077d10f32509a9883f0bcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff7f25981e219f70dc55a2056da8d5b6d715ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff7f25981e219f70dc55a2056da8d5b6d715ebf", "html_url": "https://github.com/rust-lang/rust/commit/dff7f25981e219f70dc55a2056da8d5b6d715ebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff7f25981e219f70dc55a2056da8d5b6d715ebf/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f314e7027fe7084aaab8620c624a0d7bd29e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f314e7027fe7084aaab8620c624a0d7bd29e70", "html_url": "https://github.com/rust-lang/rust/commit/18f314e7027fe7084aaab8620c624a0d7bd29e70"}], "stats": {"total": 134, "additions": 113, "deletions": 21}, "files": [{"sha": "ffc4e5f9705737b162321c8534954de9bccb4cc2", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -2277,14 +2277,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n         if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n             for candidate_field in fields.iter() {\n-                if let Some(field_path) = self.check_for_nested_field(\n+                if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n                     span,\n-                    field,\n+                    &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n                     candidate_field,\n                     substs,\n                     vec![],\n                     self.tcx.parent_module(id).to_def_id(),\n                 ) {\n+                    // field_path includes `field` that we're looking for, so pop it.\n+                    field_path.pop();\n+\n                     let field_path_str = field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n@@ -2304,7 +2307,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    fn get_field_candidates(\n+    crate fn get_field_candidates(\n         &self,\n         span: Span,\n         base_t: Ty<'tcx>,\n@@ -2329,49 +2332,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// This method is called after we have encountered a missing field error to recursively\n     /// search for the field\n-    fn check_for_nested_field(\n+    crate fn check_for_nested_field_satisfying(\n         &self,\n         span: Span,\n-        target_field: Ident,\n+        matches: &impl Fn(&ty::FieldDef, Ty<'tcx>) -> bool,\n         candidate_field: &ty::FieldDef,\n         subst: SubstsRef<'tcx>,\n         mut field_path: Vec<Ident>,\n         id: DefId,\n     ) -> Option<Vec<Ident>> {\n         debug!(\n-            \"check_for_nested_field(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n+            \"check_for_nested_field_satisfying(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n             span, candidate_field, field_path\n         );\n \n-        if candidate_field.ident(self.tcx) == target_field {\n-            Some(field_path)\n-        } else if field_path.len() > 3 {\n+        if field_path.len() > 3 {\n             // For compile-time reasons and to avoid infinite recursion we only check for fields\n             // up to a depth of three\n             None\n         } else {\n             // recursively search fields of `candidate_field` if it's a ty::Adt\n-\n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n             if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n                 for field in nested_fields.iter() {\n-                    let accessible = field.vis.is_accessible_from(id, self.tcx);\n-                    if accessible {\n-                        let ident = field.ident(self.tcx).normalize_to_macros_2_0();\n-                        if ident == target_field {\n+                    if field.vis.is_accessible_from(id, self.tcx) {\n+                        if matches(candidate_field, field_ty) {\n                             return Some(field_path);\n-                        }\n-                        let field_path = field_path.clone();\n-                        if let Some(path) = self.check_for_nested_field(\n+                        } else if let Some(field_path) = self.check_for_nested_field_satisfying(\n                             span,\n-                            target_field,\n+                            matches,\n                             field,\n                             subst,\n-                            field_path,\n+                            field_path.clone(),\n                             id,\n                         ) {\n-                            return Some(path);\n+                            return Some(field_path);\n                         }\n                     }\n                 }"}, {"sha": "88e0a4bada845255136d82d431e733ec311994d4", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -28,7 +28,7 @@ use rustc_trait_selection::traits::{\n use std::cmp::Ordering;\n use std::iter;\n \n-use super::probe::Mode;\n+use super::probe::{Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1129,6 +1129,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found();\n                 }\n \n+                if let SelfSource::MethodCall(expr) = source\n+                    && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+                {\n+                    let call_expr =\n+                        self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+                    for candidate_field in fields.iter() {\n+                        if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                            span,\n+                            &|_, field_ty| {\n+                                self.lookup_probe(\n+                                    span,\n+                                    item_name,\n+                                    field_ty,\n+                                    call_expr,\n+                                    ProbeScope::AllTraits,\n+                                )\n+                                .is_ok()\n+                            },\n+                            candidate_field,\n+                            substs,\n+                            vec![],\n+                            self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                        ) {\n+                            let field_path_str = field_path\n+                                .iter()\n+                                .map(|id| id.name.to_ident_string())\n+                                .collect::<Vec<String>>()\n+                                .join(\".\");\n+                            debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                            err.span_suggestion_verbose(\n+                                item_name.span.shrink_to_lo(),\n+                                \"one of the expressions' fields has a method of the same name\",\n+                                format!(\"{field_path_str}.\"),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 bound_spans.sort();\n                 bound_spans.dedup();\n                 for (span, msg) in bound_spans.into_iter() {"}, {"sha": "7157b186fc8ad591967e48e829b074c9ebe3ec3b", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -18,6 +18,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let filter = map.stream.filterx(|x: &_| true);\n+   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -39,6 +43,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let count = filter.stream.countx();\n+   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7157b186fc8ad591967e48e829b074c9ebe3ec3b", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -18,6 +18,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let filter = map.stream.filterx(|x: &_| true);\n+   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -39,6 +43,10 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let count = filter.stream.countx();\n+   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "980000151e2f7f4ea468ef17e246a7523e998539", "filename": "src/test/ui/suggestions/field-has-method.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.rs?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -0,0 +1,23 @@\n+struct Kind;\n+\n+struct Ty {\n+    kind: Kind,\n+}\n+\n+impl Ty {\n+    fn kind(&self) -> Kind {\n+        todo!()\n+    }\n+}\n+\n+struct InferOk<T> {\n+    value: T,\n+    predicates: Vec<()>,\n+}\n+\n+fn foo(i: InferOk<Ty>) {\n+    let k = i.kind();\n+    //~^ no method named `kind` found for struct `InferOk` in the current scope\n+}\n+\n+fn main() {}"}, {"sha": "3a57436f200bab227bda5dc95b008c46cdcf70b5", "filename": "src/test/ui/suggestions/field-has-method.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff7f25981e219f70dc55a2056da8d5b6d715ebf/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-has-method.stderr?ref=dff7f25981e219f70dc55a2056da8d5b6d715ebf", "patch": "@@ -0,0 +1,17 @@\n+error[E0599]: no method named `kind` found for struct `InferOk` in the current scope\n+  --> $DIR/field-has-method.rs:19:15\n+   |\n+LL | struct InferOk<T> {\n+   | ----------------- method `kind` not found for this\n+...\n+LL |     let k = i.kind();\n+   |               ^^^^ method not found in `InferOk<Ty>`\n+   |\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let k = i.value.kind();\n+   |               ++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}