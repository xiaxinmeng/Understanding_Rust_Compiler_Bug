{"sha": "e4c291530e4cc160eca30811e17d614f236147a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YzI5MTUzMGU0Y2MxNjBlY2EzMDgxMWUxN2Q2MTRmMjM2MTQ3YTQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-07T19:18:34Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-21T23:11:11Z"}, "message": "Basic functionality for new ports and chans\n\nThe first benchmark shows about twice the throughput of the old system.", "tree": {"sha": "18ad1871b3bcbed6d53bd7779e0917adceaa91f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ad1871b3bcbed6d53bd7779e0917adceaa91f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c291530e4cc160eca30811e17d614f236147a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c291530e4cc160eca30811e17d614f236147a4", "html_url": "https://github.com/rust-lang/rust/commit/e4c291530e4cc160eca30811e17d614f236147a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c291530e4cc160eca30811e17d614f236147a4/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f54829cf13158e146114b090d40260823bf3a56a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f54829cf13158e146114b090d40260823bf3a56a", "html_url": "https://github.com/rust-lang/rust/commit/f54829cf13158e146114b090d40260823bf3a56a"}], "stats": {"total": 182, "additions": 149, "deletions": 33}, "files": [{"sha": "2fa656f3eebfceb70f1ad0b65f0bc5f4c8e7a976", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=e4c291530e4cc160eca30811e17d614f236147a4", "patch": "@@ -28,6 +28,7 @@ resource arc_destruct<T>(data: *libc::c_void) {\n     unsafe {\n         let data: ~arc_data<T> = unsafe::reinterpret_cast(data);\n         let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n+        let data_ptr : *() = unsafe::reinterpret_cast(data);\n         assert new_count >= 0;\n         if new_count == 0 {\n             // drop glue takes over.\n@@ -68,17 +69,19 @@ allowing them to share the underlying data.\"]\n fn clone<T: const>(rc: &arc<T>) -> arc<T> {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast(**rc);\n-        rustrt::rust_atomic_increment(&mut ptr.count);\n+        let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+        let data_ptr : *() = unsafe::reinterpret_cast(ptr);\n+        assert new_count >= 2;\n         unsafe::forget(ptr);\n     }\n     arc_destruct(**rc)\n }\n \n // An arc over mutable data that is protected by a lock.\n-type ex_data<T> = {lock: sys::lock_and_signal, data: T};\n-type exclusive<T> = arc_destruct<ex_data<T>>;\n+type ex_data<T: send> = {lock: sys::lock_and_signal, data: T};\n+type exclusive<T: send> = arc_destruct<ex_data<T>>;\n \n-fn exclusive<T>(-data: T) -> exclusive<T> {\n+fn exclusive<T:send >(-data: T) -> exclusive<T> {\n     let data = ~{mut count: 1, data: {lock: sys::create_lock(),\n                                       data: data}};\n     unsafe {\n@@ -88,12 +91,14 @@ fn exclusive<T>(-data: T) -> exclusive<T> {\n     }\n }\n \n-impl methods<T> for exclusive<T> {\n+impl methods<T: send> for exclusive<T> {\n     fn clone() -> exclusive<T> {\n         unsafe {\n             // this makes me nervous...\n             let ptr: ~arc_data<ex_data<T>> = unsafe::reinterpret_cast(*self);\n-            rustrt::rust_atomic_increment(&mut ptr.count);\n+            let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+            let data_ptr : *() = unsafe::reinterpret_cast(ptr);\n+            assert new_count > 1;\n             unsafe::forget(ptr);\n         }\n         arc_destruct(*self)"}, {"sha": "3185d8e30c04712aafa1648597f23b639f944b3d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=e4c291530e4cc160eca30811e17d614f236147a4", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, comm, task, future;\n+export arc, newcomm, comm, task, future;\n export extfmt;\n export tuple;\n export to_str;\n@@ -176,6 +176,7 @@ mod dvec_iter {\n \n // Concurrency\n mod arc;\n+mod newcomm;\n mod comm;\n mod task;\n mod future;"}, {"sha": "85d61d3f606fc5260396ba83d69aba5bf669f511", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=e4c291530e4cc160eca30811e17d614f236147a4", "patch": "@@ -132,14 +132,6 @@ impl extensions<A> for dvec<A> {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n-}\n-\n-impl extensions<A:copy> for dvec<A> {\n-    #[doc = \"Append a single item to the end of the list\"]\n-    fn push(t: A) {\n-        self.check_not_borrowed();\n-        vec::push(self.data, t);\n-    }\n \n     #[doc = \"Remove and return the last element\"]\n     fn pop() -> A {\n@@ -151,6 +143,38 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n+    #[doc = \"Insert a single item at the front of the list\"]\n+    fn unshift(-t: A) {\n+        unsafe {\n+            let mut data = unsafe::reinterpret_cast(null::<()>());\n+            data <-> self.data;\n+            let data_ptr: *() = unsafe::reinterpret_cast(data);\n+            if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n+            log(error, \"a\");\n+            self.data <- [mut t] + data;\n+            log(error, \"b\");\n+        }\n+    }\n+\n+    #[doc = \"Append a single item to the end of the list\"]\n+    fn push(+t: A) {\n+        self.check_not_borrowed();\n+        vec::push(self.data, t);\n+    }\n+\n+\n+    #[doc = \"Remove and return the first element\"]\n+    fn shift() -> A {\n+        self.borrow { |v|\n+            let mut v = vec::from_mut(v);\n+            let result = vec::shift(v);\n+            self.return(vec::to_mut(v));\n+            result\n+        }\n+    }\n+}\n+\n+impl extensions<A:copy> for dvec<A> {\n     #[doc = \"\n         Append all elements of a vector to the end of the list\n \n@@ -213,16 +237,6 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Remove and return the first element\"]\n-    fn shift() -> A {\n-        self.borrow { |v|\n-            let mut v = vec::from_mut(v);\n-            let result = vec::shift(v);\n-            self.return(vec::to_mut(v));\n-            result\n-        }\n-    }\n-\n     #[doc = \"Copy out an individual element\"]\n     #[inline(always)]\n     fn [](idx: uint) -> A {"}, {"sha": "6934dba84cded26ba9a0ab91c358a06e889d75f4", "filename": "src/libcore/newcomm.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=e4c291530e4cc160eca30811e17d614f236147a4", "patch": "@@ -0,0 +1,88 @@\n+#[doc=\"A new implementation of communication.\n+\n+This should be implementing almost entirely in Rust, and hopefully\n+avoid needing a single global lock.\"]\n+\n+import arc::methods;\n+import dvec::dvec;\n+import dvec::{extensions};\n+\n+export port;\n+export chan;\n+export send, recv;\n+export methods;\n+\n+type raw_port<T: send> = arc::exclusive<dvec<T>>;\n+\n+enum port<T: send> {\n+    port_(raw_port<T>)\n+}\n+enum chan<T: send> {\n+    chan_(raw_port<T>)\n+}\n+\n+fn port<T: send>() -> port<T> {\n+    port_(arc::exclusive(dvec()))\n+}\n+\n+fn chan<T: send>(p: port<T>) -> chan<T> {\n+    chan_((*p).clone())\n+}\n+\n+fn send<T: send>(c: chan<T>, -x: T) {\n+    let mut x <- some(x);\n+    (*c).with {|cond, data|\n+        let mut xx = none;\n+        xx <-> x;\n+        alt xx {\n+          some(y) {\n+            let mut x <- y;\n+            (*data).push(x);\n+            cond.signal();\n+          }\n+          none { fail }\n+        };\n+    }\n+}\n+\n+fn recv<T: send>(p: port<T>) -> T {\n+    (*p).with {|cond, data|\n+        if (*data).len() == 0u {\n+            cond.wait();\n+        }\n+        assert (*data).len() > 0u;\n+        (*data).shift()\n+    }\n+}\n+\n+impl methods<T: send> for chan<T> {\n+    fn send(-x: T) {\n+        send(self, x)\n+    }\n+\n+    fn clone() -> chan<T> {\n+        chan_((*self).clone())\n+    }\n+}\n+\n+impl methods<T: send> for port<T> {\n+    fn recv() -> T {\n+        recv(self)\n+    }\n+\n+    fn chan() -> chan<T> {\n+        chan(self)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn newport_simple() {\n+        let p = port();\n+        let c = chan(p);\n+\n+        c.send(42);\n+        assert p.recv() == 42;\n+    }\n+}"}, {"sha": "689c641e0614d80a3356b79042ba4beadb085999", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c291530e4cc160eca30811e17d614f236147a4/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e4c291530e4cc160eca30811e17d614f236147a4", "patch": "@@ -371,17 +371,25 @@ fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n // Mutators\n \n #[doc = \"Removes the first element from a vector and return it\"]\n-fn shift<T: copy>(&v: [T]) -> T {\n+fn shift<T>(&v: [T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n-    let e = v[0];\n-    v = slice::<T>(v, 1u, ln);\n-    ret e;\n-}\n \n-#[doc = \"Prepend an element to a vector\"]\n-fn unshift<T: copy>(&v: [T], +t: T) {\n-    v = [t] + v;\n+    let mut vv = [];\n+    v <-> vv;\n+\n+    unsafe {\n+        let vv = unsafe::to_ptr(vv);\n+        let r <- *vv;\n+\n+        for uint::range(1u, ln) {|i|\n+            // FIXME: this isn't legal, per se...\n+            let r <- *ptr::offset(vv, i);\n+            push(v, r);\n+        }\n+\n+        r\n+    }\n }\n \n #[doc = \"Remove the last element from a vector and return it\"]"}]}