{"sha": "bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNjZkOTFjOThkODNhYzVmYzQ1M2YxMjBlZjRhODEwYmM4OTM5YTU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-25T06:08:11Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-07T04:31:45Z"}, "message": "Make `hir::Visibility` non-copyable and add `ty::Visibility`", "tree": {"sha": "c586ee4feff214b64552844813e49ee21333e4e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c586ee4feff214b64552844813e49ee21333e4e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "html_url": "https://github.com/rust-lang/rust/commit/bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffbbf241868588c5ca3880ed023e97aa806ea1d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffbbf241868588c5ca3880ed023e97aa806ea1d3", "html_url": "https://github.com/rust-lang/rust/commit/ffbbf241868588c5ca3880ed023e97aa806ea1d3"}], "stats": {"total": 365, "additions": 200, "deletions": 165}, "files": [{"sha": "55fd58da86635b61ee7eb7e619b70e2bb70e7b4f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -37,10 +37,10 @@ use std::u32;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility, &'a [Attribute]),\n+    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<Visibility>, &'a [Attribute]),\n+    Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n     Closure(&'a [Attribute]),\n@@ -324,7 +324,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             unsafety,\n                                             constness,\n                                             abi,\n-                                            item.vis,\n+                                            &item.vis,\n                                             &item.attrs),\n                              declaration,\n                              body,\n@@ -672,7 +672,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ImplItemKind::Method(ref sig, ref body) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n-                                            Some(impl_item.vis),\n+                                            Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n                              body,"}, {"sha": "8c626226bd3c3588842f2a093863faa5cafa157d", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -113,7 +113,7 @@ struct ItemFnParts<'a> {\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n     abi:      abi::Abi,\n-    vis:      ast::Visibility,\n+    vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     &'a Block,\n     id:       NodeId,\n@@ -208,7 +208,7 @@ impl<'a> FnLikeNode<'a> {\n         M: FnOnce(NodeId,\n                   Name,\n                   &'a ast::MethodSig,\n-                  Option<ast::Visibility>,\n+                  Option<&'a ast::Visibility>,\n                   &'a ast::Block,\n                   Span,\n                   &'a [Attribute])\n@@ -226,7 +226,7 @@ impl<'a> FnLikeNode<'a> {\n                         body: &block,\n                         generics: generics,\n                         abi: abi,\n-                        vis: i.vis,\n+                        vis: &i.vis,\n                         constness: constness,\n                         span: i.span,\n                         attrs: &i.attrs,\n@@ -242,7 +242,7 @@ impl<'a> FnLikeNode<'a> {\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, ref body) => {\n-                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "16dc48d4220e00ccd87d2796c2bb47bb5b64b773", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -430,7 +430,7 @@ impl<'ast> Map<'ast> {\n \n     /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    fn get_module_parent(&self, id: NodeId) -> NodeId {\n+    pub fn get_module_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,"}, {"sha": "8e748875b93f1b4be226f8e73b65acc0348d7436", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -1431,7 +1431,7 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,\n     Inherited,"}, {"sha": "7affb129313c886015b53931c07bbd570bd21acc", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -294,7 +294,7 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                    Some(name),\n                    generics,\n                    opt_explicit_self,\n-                   hir::Inherited)?;\n+                   &hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -322,8 +322,8 @@ pub fn arg_to_string(arg: &hir::Arg) -> String {\n     to_string(|s| s.print_arg(arg, false))\n }\n \n-pub fn visibility_qualified(vis: hir::Visibility, s: &str) -> String {\n-    match vis {\n+pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n+    match *vis {\n         hir::Public => format!(\"pub {}\", s),\n         hir::Inherited => s.to_string(),\n     }\n@@ -573,13 +573,13 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               generics,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -597,7 +597,7 @@ impl<'a> State<'a> {\n                               name: ast::Name,\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n-                              vis: hir::Visibility)\n+                              vis: &hir::Visibility)\n                               -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n@@ -648,7 +648,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n             hir::ItemExternCrate(ref optional_path) => {\n-                self.head(&visibility_qualified(item.vis, \"extern crate\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n@@ -666,14 +666,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemUse(ref vp) => {\n-                self.head(&visibility_qualified(item.vis, \"use\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_view_path(&vp)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemStatic(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -689,7 +689,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"const\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -710,12 +710,12 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               typarams,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n             }\n             hir::ItemMod(ref _mod) => {\n-                self.head(&visibility_qualified(item.vis, \"mod\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -732,7 +732,7 @@ impl<'a> State<'a> {\n             hir::ItemTy(ref ty, ref params) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n-                self.word_nbsp(&visibility_qualified(item.vis, \"type\"))?;\n+                self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generics(params)?;\n                 self.end()?; // end the inner ibox\n@@ -745,16 +745,16 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.name, item.span, item.vis)?;\n+                self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(item.vis, \"struct\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n@@ -771,7 +771,7 @@ impl<'a> State<'a> {\n                           ref ty,\n                           ref impl_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n \n@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_name(item.name)?;\n@@ -867,7 +867,7 @@ impl<'a> State<'a> {\n                           generics: &hir::Generics,\n                           name: ast::Name,\n                           span: codemap::Span,\n-                          visibility: hir::Visibility)\n+                          visibility: &hir::Visibility)\n                           -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n@@ -895,8 +895,8 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: hir::Visibility) -> io::Result<()> {\n-        match vis {\n+    pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n+        match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Inherited => Ok(()),\n         }\n@@ -915,7 +915,7 @@ impl<'a> State<'a> {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n                 self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.print_visibility(field.vis)?;\n+                    s.print_visibility(&field.vis)?;\n                     s.maybe_print_comment(field.span.lo)?;\n                     s.print_type(&field.ty)\n                 })?;\n@@ -937,7 +937,7 @@ impl<'a> State<'a> {\n                 self.hardbreak_if_not_bol()?;\n                 self.maybe_print_comment(field.span.lo)?;\n                 self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(field.vis)?;\n+                self.print_visibility(&field.vis)?;\n                 self.print_name(field.name)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n@@ -964,7 +964,7 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n-                            vis: hir::Visibility)\n+                            vis: &hir::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n@@ -986,13 +986,13 @@ impl<'a> State<'a> {\n                 self.print_associated_const(ti.name,\n                                             &ty,\n                                             default.as_ref().map(|expr| &**expr),\n-                                            hir::Inherited)?;\n+                                            &hir::Inherited)?;\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n-                self.print_method_sig(ti.name, sig, hir::Inherited)?;\n+                self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n@@ -1021,11 +1021,11 @@ impl<'a> State<'a> {\n \n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis)?;\n+                self.print_associated_const(ii.name, &ty, Some(&expr), &ii.vis)?;\n             }\n             hir::ImplItemKind::Method(ref sig, ref body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, ii.vis)?;\n+                self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n                 self.print_block_with_attrs(body, &ii.attrs)?;\n             }\n@@ -1910,7 +1910,7 @@ impl<'a> State<'a> {\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                    vis: hir::Visibility)\n+                    vis: &hir::Visibility)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -2267,7 +2267,7 @@ impl<'a> State<'a> {\n                       name,\n                       &generics,\n                       opt_explicit_self,\n-                      hir::Inherited)?;\n+                      &hir::Inherited)?;\n         self.end()\n     }\n \n@@ -2347,7 +2347,7 @@ impl<'a> State<'a> {\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 abi: Abi,\n-                                vis: hir::Visibility)\n+                                vis: &hir::Visibility)\n                                 -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.print_unsafety(unsafety)?;"}, {"sha": "d3db0804c24229abf30cdc23bbe44d66529518ac", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -116,7 +116,7 @@ pub const LOCAL_CRATE: ast::CrateNum = 0;\n pub struct ChildItem {\n     pub def: DefLike,\n     pub name: ast::Name,\n-    pub vis: hir::Visibility\n+    pub vis: ty::Visibility,\n }\n \n pub enum FoundAst<'ast> {\n@@ -157,7 +157,7 @@ pub trait CrateStore<'tcx> : Any {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n-    fn visibility(&self, def: DefId) -> hir::Visibility;\n+    fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind;\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n@@ -334,7 +334,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n-    fn visibility(&self, def: DefId) -> hir::Visibility { bug!(\"visibility\") }\n+    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)"}, {"sha": "d5409e05246aa5125dc0f04f7c3d45f73a22dcbc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n-    pub fn vis(&self) -> hir::Visibility {\n+    pub fn vis(&self) -> Visibility {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.vis,\n             MethodTraitItem(ref method) => method.vis,\n@@ -273,14 +273,33 @@ impl ImplOrTraitItemId {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+pub enum Visibility {\n+    /// Visible everywhere (including in other crates).\n+    Public,\n+    /// Visible only in the given crate-local module.\n+    Restricted(NodeId),\n+    /// Not visible anywhere in the local crate. This is the visibility of private external items.\n+    PrivateExternal,\n+}\n+\n+impl Visibility {\n+    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n+        match *visibility {\n+            hir::Public => Visibility::Public,\n+            hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -292,7 +311,7 @@ impl<'tcx> Method<'tcx> {\n                predicates: GenericPredicates<'tcx>,\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n-               vis: hir::Visibility,\n+               vis: Visibility,\n                defaultness: hir::Defaultness,\n                def_id: DefId,\n                container: ImplOrTraitItemContainer)\n@@ -336,7 +355,7 @@ impl<'tcx> Hash for Method<'tcx> {\n pub struct AssociatedConst<'tcx> {\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -347,7 +366,7 @@ pub struct AssociatedConst<'tcx> {\n pub struct AssociatedType<'tcx> {\n     pub name: Name,\n     pub ty: Option<Ty<'tcx>>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -1419,7 +1438,7 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n     ///\n@@ -1704,7 +1723,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n-               vis: hir::Visibility) -> Self {\n+               vis: Visibility) -> Self {\n         FieldDefData {\n             did: did,\n             name: name,"}, {"sha": "8e7be0e3a0f5e0d3fd5682de643f90a854c801af", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_deprecation(&cdata, def.index)\n     }\n \n-    fn visibility(&self, def: DefId) -> hir::Visibility {\n+    fn visibility(&self, def: DefId) -> ty::Visibility {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_visibility(&cdata, def.index)\n     }\n@@ -536,7 +536,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n         if !visible_parent_map.is_empty() { return visible_parent_map; }\n \n-        use rustc::hir;\n         use rustc::middle::cstore::{CrateStore, ChildItem};\n         use std::collections::vec_deque::VecDeque;\n         use std::collections::hash_map::Entry;\n@@ -552,7 +551,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             let mut bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: ChildItem, parent: DefId| {\n                 let child = match child.def {\n-                    DefLike::DlDef(def) if child.vis == hir::Public => def.def_id(),\n+                    DefLike::DlDef(def) if child.vis == ty::Visibility::Public => def.def_id(),\n                     _ => return,\n                 };\n "}, {"sha": "a0881f1153e39eec45eb4037852eb2115436b3cf", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -140,13 +140,13 @@ fn item_family(item: rbml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: rbml::Doc) -> hir::Visibility {\n+fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => hir::Public,\n+        None => ty::Visibility::Public,\n         Some(visibility_doc) => {\n             match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => hir::Public,\n-                'i' => hir::Inherited,\n+                'y' => ty::Visibility::Public,\n+                'i' => ty::Visibility::PrivateExternal,\n                 _ => bug!(\"unknown visibility character\")\n             }\n         }\n@@ -541,7 +541,7 @@ pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     })\n }\n \n-pub fn get_visibility(cdata: Cmd, id: DefIndex) -> hir::Visibility {\n+pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n@@ -639,7 +639,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n@@ -723,7 +723,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n-            callback(def_like, token::intern(name), hir::Public);\n+            callback(def_like, token::intern(name), ty::Visibility::Public);\n         }\n     }\n }\n@@ -734,7 +734,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                id: DefIndex,\n                                get_crate_data: G,\n                                callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n@@ -755,7 +755,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           cdata: Cmd,\n                                           get_crate_data: G,\n                                           callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n@@ -1138,11 +1138,11 @@ pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribut\n     }).collect()\n }\n \n-fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n     match family {\n-      PublicField => hir::Public,\n-      InheritedField => hir::Inherited,\n-      _ => bug!()\n+        PublicField => ty::Visibility::Public,\n+        InheritedField => ty::Visibility::PrivateExternal,\n+        _ => bug!()\n     }\n }\n "}, {"sha": "69f61cf97c0b271387ce18fac7eef9d84f23e2c0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -249,7 +249,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n                                       did: DefId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       index: &mut CrateIndex<'tcx>) {\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n@@ -355,7 +355,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        name: Name,\n-                       vis: hir::Visibility) {\n+                       vis: &hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n@@ -383,7 +383,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_deprecation(rbml_w, depr);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == hir::Public {\n+    if *vis == hir::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id);\n     }\n@@ -393,21 +393,31 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: hir::Visibility) {\n-    encode_family(rbml_w, match visibility {\n-        hir::Public => 'g',\n-        hir::Inherited => 'N'\n-    });\n+                              visibility: ty::Visibility) {\n+    encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: hir::Visibility) {\n-    let ch = match visibility {\n-        hir::Public => 'y',\n-        hir::Inherited => 'i',\n-    };\n+fn encode_visibility<T: HasVisibility>(rbml_w: &mut Encoder, visibility: T) {\n+    let ch = if visibility.is_public() { 'y' } else { 'i' };\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n+trait HasVisibility: Sized {\n+    fn is_public(self) -> bool;\n+}\n+\n+impl<'a> HasVisibility for &'a hir::Visibility {\n+    fn is_public(self) -> bool {\n+        *self == hir::Public\n+    }\n+}\n+\n+impl HasVisibility for ty::Visibility {\n+    fn is_public(self) -> bool {\n+        self == ty::Visibility::Public\n+    }\n+}\n+\n fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n     rbml_w.start_tag(tag_items_data_item_constness);\n     let ch = match constness {\n@@ -861,7 +871,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let vis = item.vis;\n+    let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n     let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n     let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n@@ -932,7 +942,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             &item.attrs,\n                             item.id,\n                             item.name,\n-                            item.vis);\n+                            &item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n         index.record(def_id, rbml_w);\n@@ -1336,7 +1346,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n-    encode_visibility(rbml_w, nitem.vis);\n+    encode_visibility(rbml_w, &nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n@@ -1443,7 +1453,7 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         &[],\n                         CRATE_NODE_ID,\n                         syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                        hir::Public);\n+                        &hir::Public);\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,"}, {"sha": "63a5dc71b8fc54cfe9025b7aa3d97009d47e4635", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -383,11 +383,11 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn item_is_visible(&self, did: DefId) -> bool {\n-        let visibility = match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.expect_item(node_id).vis,\n-            None => self.tcx.sess.cstore.visibility(did),\n+        let is_public = match self.tcx.map.as_local_node_id(did) {\n+            Some(node_id) => self.tcx.map.expect_item(node_id).vis == hir::Public,\n+            None => self.tcx.sess.cstore.visibility(did) == ty::Visibility::Public,\n         };\n-        visibility == hir::Public || self.private_accessible(did)\n+        is_public || self.private_accessible(did)\n     }\n \n     /// True if `did` is private-accessible\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n         if def.adt_kind() == ty::AdtKind::Struct &&\n-                field.vis != hir::Public && !self.private_accessible(def.did) {\n+                field.vis != ty::Visibility::Public && !self.private_accessible(def.did) {\n             span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n                       field.name, self.tcx.item_path_str(def.did));\n         }\n@@ -464,7 +464,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.private_accessible(def.did)\n+                        f.vis != ty::Visibility::Public && !self.private_accessible(def.did)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -548,8 +548,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// Such qualifiers can be set by syntax extensions even if the parser doesn't allow them,\n     /// so we check things like variant fields too.\n     fn check_sane_privacy(&self, item: &hir::Item) {\n-        let check_inherited = |sp, vis, note: &str| {\n-            if vis != hir::Inherited {\n+        let check_inherited = |sp, vis: &hir::Visibility, note: &str| {\n+            if *vis != hir::Inherited {\n                 let mut err = struct_span_err!(self.tcx.sess, sp, E0449,\n                                                \"unnecessary visibility qualifier\");\n                 if !note.is_empty() {\n@@ -561,29 +561,29 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n                 for impl_item in impl_items {\n-                    check_inherited(impl_item.span, impl_item.vis,\n+                    check_inherited(impl_item.span, &impl_item.vis,\n                                     \"visibility qualifiers have no effect on trait impl items\");\n                 }\n             }\n             hir::ItemImpl(_, _, _, None, _, _) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual methods instead\");\n             }\n             hir::ItemDefaultImpl(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n             }\n             hir::ItemForeignMod(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual functions instead\");\n             }\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        check_inherited(field.span, field.vis,\n+                        check_inherited(field.span, &field.vis,\n                                         \"visibility qualifiers have no effect on variant fields\");\n                     }\n                 }\n@@ -659,8 +659,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis == hir::Public\n+    fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n+        self.access_levels.is_reachable(*id) || *vis == hir::Public\n     }\n }\n \n@@ -789,7 +789,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&impl_item.id, impl_item.vis) =>\n+                                        if self.item_is_public(&impl_item.id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -831,14 +831,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     for impl_item in impl_items {\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n-                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                if self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n                                 if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n@@ -858,7 +858,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             hir::ItemTy(..) => return,\n \n             // not at all public, so we don't care\n-            _ if !self.item_is_public(&item.id, item.vis) => {\n+            _ if !self.item_is_public(&item.id, &item.vis) => {\n                 return;\n             }\n "}, {"sha": "003450cd6fd7984b81d3e1add6f333175828b371", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::ty::VariantKind;\n+use rustc::ty::{self, VariantKind};\n \n use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n@@ -434,7 +434,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n \n         let name = xcdef.name;\n-        let is_public = xcdef.vis == hir::Public || parent.is_trait();\n+        let is_public = xcdef.vis == ty::Visibility::Public || parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {"}, {"sha": "f684f70565d6746b8102ee43cf8d967b5dd9e0b9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -16,7 +16,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst;\n use rustc::traits;\n-use rustc::ty::{self, TyCtxt, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, TyCtxt, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable, Visibility};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::infer;\n \n@@ -343,7 +343,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let def = pick.item.def();\n \n     if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != hir::Public && !fcx.private_item_is_visible(def.def_id()) {\n+        if pick.item.vis() != Visibility::Public && !fcx.private_item_is_visible(def.def_id()) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n             fcx.tcx().sess.span_err(span, &msg);\n         }"}, {"sha": "bf6394a03d04b155702f01711f8918d3730851c4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -20,7 +20,7 @@ use hir::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable, Visibility};\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -412,7 +412,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if item.vis() != hir::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+        if item.vis() != Visibility::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n             self.private_candidate = Some(item.def());\n             return\n         }"}, {"sha": "0e2bf89947f1612b4a1861c98cba2a94f86f3b1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -95,7 +95,7 @@ use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::error::TypeError;\n@@ -125,8 +125,7 @@ use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir;\n-use rustc::hir::{Visibility, PatKind};\n+use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n use rustc_const_eval::eval_repeat_count;\n@@ -2967,7 +2966,8 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = fcx.field_ty(expr.span, field, substs);\n-                        if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                        if field.vis == Visibility::Public ||\n+                           fcx.private_item_is_visible(base_def.did) {\n                             return Some(field_ty);\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3079,7 +3079,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"tuple struct named {:?}\",  base_t);\n                 if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n                     let field_ty = fcx.field_ty(expr.span, field, substs);\n-                    if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                    if field.vis == Visibility::Public || fcx.private_item_is_visible(base_def.did) {\n                         return Some(field_ty);\n                     }\n                     private_candidate = Some((base_def.did, field_ty));"}, {"sha": "2e1a684684375714582094cfcf31023371eb8e6b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -532,7 +532,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             name: ast::Name,\n                             id: ast::NodeId,\n-                            vis: hir::Visibility,\n+                            vis: &hir::Visibility,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n@@ -555,7 +555,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     ty_generic_predicates,\n                                     fty,\n                                     explicit_self_category,\n-                                    vis,\n+                                    ty::Visibility::from_hir(vis, id, ccx.tcx),\n                                     defaultness,\n                                     def_id,\n                                     container);\n@@ -602,7 +602,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       container: ImplOrTraitItemContainer,\n                                       name: ast::Name,\n                                       id: ast::NodeId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       defaultness: hir::Defaultness,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n@@ -614,7 +614,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n@@ -629,13 +629,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n                                      name: ast::Name,\n                                      id: ast::NodeId,\n-                                     vis: hir::Visibility,\n+                                     vis: &hir::Visibility,\n                                      defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         ty: ty,\n         def_id: ccx.tcx.map.local_def_id(id),\n@@ -761,8 +761,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                ty: ty,\n                                            });\n                     // Trait-associated constants are always public.\n-                    let visibility =\n-                        if opt_trait_ref.is_some() { hir::Public } else { impl_item.vis };\n+                    let public = &hir::Public;\n+                    let visibility = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n                                              visibility,\n@@ -782,16 +782,16 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n                     convert_associated_type(ccx, ImplContainer(def_id),\n-                                            impl_item.name, impl_item.id, impl_item.vis,\n+                                            impl_item.name, impl_item.id, &impl_item.vis,\n                                             impl_item.defaultness, Some(typ));\n                 }\n             }\n \n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                     // Trait methods are always public.\n-                    let method_vis =\n-                        if opt_trait_ref.is_some() { hir::Public } else { impl_item.vis };\n+                    let public = &hir::Public;\n+                    let method_vis = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n@@ -829,7 +829,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                              container,\n                                              trait_item.name,\n                                              trait_item.id,\n-                                             hir::Public,\n+                                             &hir::Public,\n                                              hir::Defaultness::Default,\n                                              ty,\n                                              default.is_some())\n@@ -847,7 +847,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                             container,\n                                             trait_item.name,\n                                             trait_item.id,\n-                                            hir::Public,\n+                                            &hir::Public,\n                                             hir::Defaultness::Default,\n                                             typ);\n                 }\n@@ -860,7 +860,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    container,\n                                    trait_item.name,\n                                    trait_item.id,\n-                                   hir::Inherited,\n+                                   &hir::Inherited,\n                                    sig,\n                                    hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n@@ -977,6 +977,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n                                 disr_val: ty::Disr,\n                                 def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let node_id = tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.map.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n@@ -990,7 +991,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name, f.vis)\n+        ty::FieldDefData::new(fid, f.name, ty::Visibility::from_hir(&f.vis, node_id, tcx))\n     }).collect();\n     ty::VariantDefData {\n         did: did,"}, {"sha": "850975498269bc4a31382f06455a15ed547f138c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -361,7 +361,7 @@ pub fn build_impl(cx: &DocContext,\n                 })\n             }\n             ty::MethodTraitItem(method) => {\n-                if method.vis != hir::Public && associated_trait.is_none() {\n+                if method.vis != ty::Visibility::Public && associated_trait.is_none() {\n                     return None\n                 }\n                 let mut item = method.clean(cx);\n@@ -471,7 +471,7 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 cstore::DlDef(Def::ForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                cstore::DlDef(def) if item.vis == hir::Public => {\n+                cstore::DlDef(def) if item.vis == ty::Visibility::Public => {\n                     if !visited.insert(def) { continue }\n                     if let Some(i) = try_inline_def(cx, tcx, def) {\n                         items.extend(i)"}, {"sha": "673aa17ecd1455b89c4ae2f2851ef26727447e9a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -1754,7 +1754,7 @@ impl Clean<Item> for hir::StructField {\n             name: Some(self.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n@@ -1771,7 +1771,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             name: Some(self.name).clean(cx),\n             attrs: attr_map.get(&self.did).unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n@@ -1784,7 +1784,13 @@ pub type Visibility = hir::Visibility;\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, _: &DocContext) -> Option<Visibility> {\n-        Some(*self)\n+        Some(self.clone())\n+    }\n+}\n+\n+impl Clean<Option<Visibility>> for ty::Visibility {\n+    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n+        Some(if *self == ty::Visibility::Public { hir::Public } else { hir::Inherited })\n     }\n }\n \n@@ -1902,7 +1908,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n                             attrs: cx.tcx().get_attrs(field.did).clean(cx),\n-                            visibility: Some(field.vis),\n+                            visibility: field.vis.clean(cx),\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),"}, {"sha": "ce20ad05acb0e05cc730d1b4d644227bd1f31f0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -31,7 +31,7 @@ use html::render::{cache, CURRENT_LOCATION_KEY};\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n-pub struct VisSpace(pub Option<hir::Visibility>);\n+pub struct VisSpace<'a>(pub &'a Option<hir::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a function style with a\n /// space after it.\n #[derive(Copy, Clone)]\n@@ -56,9 +56,9 @@ pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n-impl VisSpace {\n-    pub fn get(&self) -> Option<hir::Visibility> {\n-        let VisSpace(v) = *self; v\n+impl<'a> VisSpace<'a> {\n+    pub fn get(self) -> &'a Option<hir::Visibility> {\n+        let VisSpace(v) = self; v\n     }\n }\n \n@@ -636,9 +636,9 @@ impl<'a> fmt::Display for Method<'a> {\n     }\n }\n \n-impl fmt::Display for VisSpace {\n+impl<'a> fmt::Display for VisSpace<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n+        match *self.get() {\n             Some(hir::Public) => write!(f, \"pub \"),\n             Some(hir::Inherited) | None => Ok(())\n         }"}, {"sha": "c5850089578cd059a051adde3a952496837b84d7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -1714,21 +1714,21 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(myitem.visibility),\n+                               VisSpace(&myitem.visibility),\n                                src,\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(myitem.visibility), name)?\n+                               VisSpace(&myitem.visibility), name)?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n             }\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(myitem.visibility), *import)?;\n+                       VisSpace(&myitem.visibility), *import)?;\n             }\n \n             _ => {\n@@ -1831,7 +1831,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>{vis}const \\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n            init = Initializer(&c.expr))?;\n@@ -1842,7 +1842,7 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n@@ -1859,7 +1859,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     };\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            constness = ConstnessSpace(vis_constness),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n@@ -1887,7 +1887,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            UnsafetySpace(t.unsafety),\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -2214,7 +2214,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"{}enum {}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n            WhereClause(&e.generics))?;\n@@ -2326,7 +2326,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n     write!(w, \"{}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n@@ -2338,7 +2338,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"    {}{}: {},\\n{}\",\n-                           VisSpace(field.visibility),\n+                           VisSpace(&field.visibility),\n                            field.name.as_ref().unwrap(),\n                            *ty,\n                            tab)?;\n@@ -2361,7 +2361,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n+                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }"}, {"sha": "5c36c38abc5872f626cd7b04b0f9664055c9ce25", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb66d91c98d83ac5fc453f120ef4a810bc8939a5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bb66d91c98d83ac5fc453f120ef4a810bc8939a5", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             id: item.id,\n             struct_type: struct_type,\n             name: name,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n-            vis: it.vis,\n+            vis: it.vis.clone(),\n             stab: self.stability(it.id),\n             depr: self.deprecation(it.id),\n             generics: params.clone(),\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n-        om.vis = vis;\n+        om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = id;\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n                     path: p.map(|x|x.to_string()),\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                 })\n@@ -324,7 +324,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.imports.push(Import {\n                     id: item.id,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     node: node,\n                     whence: item.span,\n@@ -333,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n-                                                     item.vis,\n+                                                     item.vis.clone(),\n                                                      item.id,\n                                                      m,\n                                                      Some(name)));\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     attrs: item.attrs.clone(),\n                     id: item.id,\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };"}]}