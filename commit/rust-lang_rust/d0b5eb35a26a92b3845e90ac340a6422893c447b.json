{"sha": "d0b5eb35a26a92b3845e90ac340a6422893c447b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYjVlYjM1YTI2YTkyYjM4NDVlOTBhYzM0MGE2NDIyODkzYzQ0N2I=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2015-05-14T21:49:32Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2015-05-22T18:46:46Z"}, "message": "Add some convenience methods to go from CStr -> str\n\nA common problem when working with FFI right now is converting from raw\nC strings into `&str` or `String`. Right now you're required to say\nsomething like\n\n    let cstr = unsafe { CStr::from_ptr(ptr) };\n    let result = str::from_utf8(cstr.to_bytes());\n\nThis is slightly awkward, and is not particularly intuitive for people\nwho haven't used the ffi module before. We can do a bit better by\nproviding some convenience methods on CStr:\n\n    fn to_str(&self) -> Result<&str, str::Utf8Error>\n    fn to_string_lossy(&self) -> Cow<str>\n\nThis will make it immediately apparent to new users of CStr how to get a\nstring from a raw C string, so they can say:\n\n    let s = unsafe { CStr::from_ptr(ptr).to_string_lossy() };", "tree": {"sha": "3faf026dc95d65c25e12b1e3e23ee6c226284396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3faf026dc95d65c25e12b1e3e23ee6c226284396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0b5eb35a26a92b3845e90ac340a6422893c447b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b5eb35a26a92b3845e90ac340a6422893c447b", "html_url": "https://github.com/rust-lang/rust/commit/d0b5eb35a26a92b3845e90ac340a6422893c447b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0b5eb35a26a92b3845e90ac340a6422893c447b/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd4dad8c860363077a3d53af025a0c029a613320", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4dad8c860363077a3d53af025a0c029a613320", "html_url": "https://github.com/rust-lang/rust/commit/dd4dad8c860363077a3d53af025a0c029a613320"}], "stats": {"total": 72, "additions": 72, "deletions": 0}, "files": [{"sha": "b22600d5c5ff4009d2dd4b1590c62abf76be1271", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d0b5eb35a26a92b3845e90ac340a6422893c447b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b5eb35a26a92b3845e90ac340a6422893c447b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=d0b5eb35a26a92b3845e90ac340a6422893c447b", "patch": "@@ -10,6 +10,7 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use borrow::Cow;\n use convert::{Into, From};\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use error::Error;\n@@ -22,6 +23,7 @@ use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use slice;\n+use str;\n use string::String;\n use vec::Vec;\n \n@@ -114,6 +116,26 @@ pub struct CString {\n ///     work(&s);\n /// }\n /// ```\n+///\n+/// Converting a foreign C string into a Rust `String`\n+///\n+/// ```no_run\n+/// # #![feature(libc,cstr_to_str)]\n+/// extern crate libc;\n+/// use std::ffi::CStr;\n+///\n+/// extern { fn my_string() -> *const libc::c_char; }\n+///\n+/// fn my_string_safe() -> String {\n+///     unsafe {\n+///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     println!(\"string: {}\", my_string_safe());\n+/// }\n+/// ```\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n@@ -328,6 +350,39 @@ impl CStr {\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n         unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.inner) }\n     }\n+\n+    /// Yields a `&str` slice if the `CStr` contains valid UTF-8.\n+    ///\n+    /// This function will calculate the length of this string and check for\n+    /// UTF-8 validity, and then return the `&str` if it's valid.\n+    ///\n+    /// > **Note**: This method is currently implemented to check for validity\n+    /// > after a 0-cost cast, but it is planned to alter its definition in the\n+    /// > future to perform the length calculation in addition to the UTF-8\n+    /// > check whenever this method is called.\n+    #[unstable(feature = \"cstr_to_str\", reason = \"recently added\")]\n+    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n+        // NB: When CStr is changed to perform the length check in .to_bytes() instead of in\n+        // from_ptr(), it may be worth considering if this should be rewritten to do the UTF-8\n+        // check inline with the length calculation instead of doing it afterwards.\n+        str::from_utf8(self.to_bytes())\n+    }\n+\n+    /// Converts a `CStr` into a `Cow<str>`.\n+    ///\n+    /// This function will calculate the length of this string (which normally\n+    /// requires a linear amount of work to be done) and then return the\n+    /// resulting slice as a `Cow<str>`, replacing any invalid UTF-8 sequences\n+    /// with `U+FFFD REPLACEMENT CHARACTER`.\n+    ///\n+    /// > **Note**: This method is currently implemented to check for validity\n+    /// > after a 0-cost cast, but it is planned to alter its definition in the\n+    /// > future to perform the length calculation in addition to the UTF-8\n+    /// > check whenever this method is called.\n+    #[unstable(feature = \"cstr_to_str\", reason = \"recently added\")]\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(self.to_bytes())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -356,6 +411,7 @@ mod tests {\n     use prelude::v1::*;\n     use super::*;\n     use libc;\n+    use borrow::Cow::{Borrowed, Owned};\n \n     #[test]\n     fn c_to_rust() {\n@@ -405,4 +461,20 @@ mod tests {\n             assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n         }\n     }\n+\n+    #[test]\n+    fn to_str() {\n+        let data = b\"123\\xE2\\x80\\xA6\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n+            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n+        }\n+        let data = b\"123\\xE2\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert!(CStr::from_ptr(ptr).to_str().is_err());\n+            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n+        }\n+    }\n }"}]}