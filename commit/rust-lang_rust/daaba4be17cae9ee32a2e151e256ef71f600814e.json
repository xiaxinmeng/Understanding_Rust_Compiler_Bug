{"sha": "daaba4be17cae9ee32a2e151e256ef71f600814e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYWJhNGJlMTdjYWU5ZWUzMmEyZTE1MWUyNTZlZjcxZjYwMDgxNGU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T17:38:49Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T17:38:49Z"}, "message": "Merge #645\n\n645: WIP: support goto for fields. r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6be4dae706759f94034649a990695df8b274c6bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6be4dae706759f94034649a990695df8b274c6bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daaba4be17cae9ee32a2e151e256ef71f600814e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daaba4be17cae9ee32a2e151e256ef71f600814e", "html_url": "https://github.com/rust-lang/rust/commit/daaba4be17cae9ee32a2e151e256ef71f600814e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daaba4be17cae9ee32a2e151e256ef71f600814e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bce0c6267aab2e8ca33a3e78a1081736abbc1373", "url": "https://api.github.com/repos/rust-lang/rust/commits/bce0c6267aab2e8ca33a3e78a1081736abbc1373", "html_url": "https://github.com/rust-lang/rust/commit/bce0c6267aab2e8ca33a3e78a1081736abbc1373"}, {"sha": "9f2574c97e55e2af1d1b93f60307aa9d41f55f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f2574c97e55e2af1d1b93f60307aa9d41f55f42", "html_url": "https://github.com/rust-lang/rust/commit/9f2574c97e55e2af1d1b93f60307aa9d41f55f42"}], "stats": {"total": 196, "additions": 150, "deletions": 46}, "files": [{"sha": "22bbad964d487fe4bda43a07502dd7dd8ef23b56", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     Name, AsName, Struct, Enum, EnumVariant, Crate,\n-    HirDatabase, HirFileId,\n+    HirDatabase, HirFileId, StructField, FieldSource,\n     type_ref::TypeRef,\n };\n \n@@ -150,7 +150,7 @@ impl VariantData {\n impl VariantData {\n     fn new(flavor: StructFlavor) -> Self {\n         let inner = match flavor {\n-            StructFlavor::Tuple(fl) => {\n+            ast::StructFlavor::Tuple(fl) => {\n                 let fields = fl\n                     .fields()\n                     .enumerate()\n@@ -161,7 +161,7 @@ impl VariantData {\n                     .collect();\n                 VariantDataInner::Tuple(fields)\n             }\n-            StructFlavor::Named(fl) => {\n+            ast::StructFlavor::Named(fl) => {\n                 let fields = fl\n                     .fields()\n                     .map(|fd| StructFieldData {\n@@ -171,8 +171,70 @@ impl VariantData {\n                     .collect();\n                 VariantDataInner::Struct(fields)\n             }\n-            StructFlavor::Unit => VariantDataInner::Unit,\n+            ast::StructFlavor::Unit => VariantDataInner::Unit,\n         };\n         VariantData(inner)\n     }\n }\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum VariantDef {\n+    Struct(Struct),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(VariantDef: Struct, EnumVariant);\n+\n+impl VariantDef {\n+    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        match self {\n+            VariantDef::Struct(it) => it.field(db, name),\n+            VariantDef::EnumVariant(it) => it.field(db, name),\n+        }\n+    }\n+    pub(crate) fn variant_data(self, db: &impl HirDatabase) -> Arc<VariantData> {\n+        match self {\n+            VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::EnumVariant(it) => it.variant_data(db),\n+        }\n+    }\n+}\n+\n+impl StructField {\n+    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> (HirFileId, FieldSource) {\n+        let var_data = self.parent.variant_data(db);\n+        let fields = var_data.fields().unwrap();\n+        let ss;\n+        let es;\n+        let (file_id, struct_flavor) = match self.parent {\n+            VariantDef::Struct(s) => {\n+                let (file_id, source) = s.source(db);\n+                ss = source;\n+                (file_id, ss.flavor())\n+            }\n+            VariantDef::EnumVariant(e) => {\n+                let (file_id, source) = e.source(db);\n+                es = source;\n+                (file_id, es.flavor())\n+            }\n+        };\n+\n+        let field_sources = match struct_flavor {\n+            ast::StructFlavor::Tuple(fl) => fl\n+                .fields()\n+                .map(|it| FieldSource::Pos(it.to_owned()))\n+                .collect(),\n+            ast::StructFlavor::Named(fl) => fl\n+                .fields()\n+                .map(|it| FieldSource::Named(it.to_owned()))\n+                .collect(),\n+            ast::StructFlavor::Unit => Vec::new(),\n+        };\n+        let field = field_sources\n+            .into_iter()\n+            .zip(fields.iter())\n+            .find(|(_syntax, (id, _))| *id == self.id)\n+            .unwrap()\n+            .0;\n+        (file_id, field)\n+    }\n+}"}, {"sha": "fdea5be57181a5ef49b522520408384e950a6c49", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -10,8 +10,8 @@ use crate::{\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n-    ty::{InferenceResult, VariantDef},\n-    adt::{EnumVariantId, StructFieldId},\n+    ty::InferenceResult,\n+    adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n@@ -179,17 +179,27 @@ impl Module {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructField {\n-    parent: VariantDef,\n+    pub(crate) parent: VariantDef,\n     pub(crate) id: StructFieldId,\n }\n \n+#[derive(Debug)]\n+pub enum FieldSource {\n+    Named(TreeArc<ast::NamedFieldDef>),\n+    Pos(TreeArc<ast::PosField>),\n+}\n+\n impl StructField {\n     pub fn name(&self, db: &impl HirDatabase) -> Name {\n         self.parent.variant_data(db).fields().unwrap()[self.id]\n             .name\n             .clone()\n     }\n \n+    pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, FieldSource) {\n+        self.source_impl(db)\n+    }\n+\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_field(*self)\n     }"}, {"sha": "eaf8565eec2f7166173481d1eba297872462e9c6", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -68,7 +68,7 @@ pub use self::code_model_api::{\n     Module, ModuleDef, ModuleSource, Problem,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature, ScopeEntryWithSyntax,\n-    StructField,\n+    StructField, FieldSource,\n     Static, Const,\n     Trait, Type,\n };"}, {"sha": "714eaaae5319fa93a76457e081d1b2de61ef65bb", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -38,7 +38,7 @@ use crate::{\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n     generics::GenericParams,\n     path::GenericArg,\n-    adt::VariantData,\n+    adt::VariantDef,\n };\n \n /// The ID of a type variable.\n@@ -696,28 +696,6 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum VariantDef {\n-    Struct(Struct),\n-    EnumVariant(EnumVariant),\n-}\n-impl_froms!(VariantDef: Struct, EnumVariant);\n-\n-impl VariantDef {\n-    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        match self {\n-            VariantDef::Struct(it) => it.field(db, name),\n-            VariantDef::EnumVariant(it) => it.field(db, name),\n-        }\n-    }\n-    pub(crate) fn variant_data(self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        match self {\n-            VariantDef::Struct(it) => it.variant_data(db),\n-            VariantDef::EnumVariant(it) => it.variant_data(db),\n-        }\n-    }\n-}\n-\n pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     let parent_def = field.parent_def(db);\n     let (generics, module) = match parent_def {\n@@ -732,8 +710,10 @@ pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n-    /// For each method call expr, record the function it resolved to.\n+    /// For each method call expr, records the function it resolves to.\n     method_resolutions: FxHashMap<ExprId, Function>,\n+    /// For each field access expr, records the field it resolves to.\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -742,6 +722,9 @@ impl InferenceResult {\n     pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n         self.method_resolutions.get(&expr).map(|it| *it)\n     }\n+    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+        self.field_resolutions.get(&expr).map(|it| *it)\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -770,6 +753,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -861,6 +845,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ) -> Self {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n+            field_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -886,6 +871,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n         InferenceResult {\n             method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n+            field_resolutions: mem::replace(&mut self.field_resolutions, Default::default()),\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -899,6 +885,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.method_resolutions.insert(expr, func);\n     }\n \n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+        self.field_resolutions.insert(expr, field);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -1251,9 +1241,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n-    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+    fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        let ty = match &body[expr] {\n+        let ty = match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n             Expr::If {\n                 condition,\n@@ -1344,7 +1334,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n                     Some(func) => {\n-                        self.write_method_resolution(expr, func);\n+                        self.write_method_resolution(tgt_expr, func);\n                         self.db.type_for_def(func.into())\n                     }\n                     None => Ty::Unknown,\n@@ -1389,7 +1379,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 expected.ty\n             }\n-            Expr::Path(p) => self.infer_path_expr(expr, p).unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => self.infer_path_expr(tgt_expr, p).unwrap_or(Ty::Unknown),\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n@@ -1436,9 +1426,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             def_id: AdtDef::Struct(s),\n                             ref substs,\n                             ..\n-                        } => s\n-                            .field(self.db, name)\n-                            .map(|field| field.ty(self.db).subst(substs)),\n+                        } => s.field(self.db, name).map(|field| {\n+                            self.write_field_resolution(tgt_expr, field);\n+                            field.ty(self.db).subst(substs)\n+                        }),\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -1545,7 +1536,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(ty);\n-        self.write_expr_ty(expr, ty.clone());\n+        self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n "}, {"sha": "45b4c56ef53bbd287cc819e23ee192dabfc3703a", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -3,6 +3,7 @@ use ra_syntax::{\n     AstNode, ast,\n     algo::find_node_at_offset,\n };\n+use test_utils::tested_by;\n \n use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n@@ -60,6 +61,7 @@ pub(crate) fn reference_definition(\n             .parent()\n             .and_then(ast::MethodCallExpr::cast)\n         {\n+            tested_by!(goto_definition_works_for_methods);\n             let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n@@ -70,6 +72,19 @@ pub(crate) fn reference_definition(\n                 return Exact(NavigationTarget::from_function(db, func));\n             };\n         }\n+        // It could also be a field access\n+        if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n+            tested_by!(goto_definition_works_for_fields);\n+            let infer_result = function.infer(db);\n+            let syntax_mapping = function.body_syntax_mapping(db);\n+            let expr = ast::Expr::cast(field_expr.syntax()).unwrap();\n+            if let Some(field) = syntax_mapping\n+                .node_expr(expr)\n+                .and_then(|it| infer_result.field_resolution(it))\n+            {\n+                return Exact(NavigationTarget::from_field(db, field));\n+            };\n+        }\n     }\n     // Then try module name resolution\n     if let Some(module) = hir::source_binder::module_from_child_node(db, file_id, name_ref.syntax())\n@@ -117,6 +132,8 @@ fn name_definition(\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::covers;\n+\n     use crate::mock_analysis::analysis_and_position;\n \n     fn check_goto(fixuture: &str, expected: &str) {\n@@ -183,6 +200,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_methods() {\n+        covers!(goto_definition_works_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -197,15 +215,23 @@ mod tests {\n             \",\n             \"frobnicate FN_DEF FileId(1) [27; 52) [30; 40)\",\n         );\n+    }\n \n+    #[test]\n+    fn goto_definition_works_for_fields() {\n+        covers!(goto_definition_works_for_fields);\n         check_goto(\n             \"\n             //- /lib.rs\n-            mod <|>foo;\n-            //- /foo/mod.rs\n-            // empty\n+            struct Foo {\n+                spam: u32,\n+            }\n+\n+            fn bar(foo: &Foo) {\n+                foo.spam<|>;\n+            }\n             \",\n-            \"foo SOURCE_FILE FileId(2) [0; 10)\",\n+            \"spam NAMED_FIELD_DEF FileId(1) [17; 26) [17; 21)\",\n         );\n     }\n }"}, {"sha": "e33bf6c913377a47da06288d4a88c2a017febe70", "filename": "crates/ra_ide_api/src/marks.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -1 +1,5 @@\n-test_utils::marks!(inserts_parens_for_function_calls);\n+test_utils::marks!(\n+    inserts_parens_for_function_calls\n+    goto_definition_works_for_methods\n+    goto_definition_works_for_fields\n+);"}, {"sha": "ae2175dbcf131d7c32648fd9663a85a7dc0b960c", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaba4be17cae9ee32a2e151e256ef71f600814e/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=daaba4be17cae9ee32a2e151e256ef71f600814e", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     SyntaxNode, AstNode, SmolStr, TextRange, ast,\n     SyntaxKind::{self, NAME},\n };\n-use hir::{ModuleSource};\n+use hir::{ModuleSource, FieldSource};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -101,6 +101,17 @@ impl NavigationTarget {\n         NavigationTarget::from_named(file_id.original_file(db), &*fn_def)\n     }\n \n+    pub(crate) fn from_field(db: &RootDatabase, field: hir::StructField) -> NavigationTarget {\n+        let (file_id, field) = field.source(db);\n+        let file_id = file_id.original_file(db);\n+        match field {\n+            FieldSource::Named(it) => NavigationTarget::from_named(file_id, &*it),\n+            FieldSource::Pos(it) => {\n+                NavigationTarget::from_syntax(file_id, \"\".into(), None, it.syntax())\n+            }\n+        }\n+    }\n+\n     // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n     pub(crate) fn from_def(\n         db: &RootDatabase,"}]}