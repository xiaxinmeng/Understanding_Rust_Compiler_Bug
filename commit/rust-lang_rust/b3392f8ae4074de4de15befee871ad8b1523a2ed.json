{"sha": "b3392f8ae4074de4de15befee871ad8b1523a2ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzkyZjhhZTQwNzRkZTRkZTE1YmVmZWU4NzFhZDhiMTUyM2EyZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-16T03:54:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-16T03:54:10Z"}, "message": "Auto merge of #46560 - Yoric:incr, r=michaelwoerister\n\nLoading the dependency graph in the background\n\nPatch is a bit longer than I expected, due to the fact that most of this code relies upon a `Session` value, which is not `Sync`.", "tree": {"sha": "ca7b368ddf3b6c47faafec93910a1a0e322dffbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7b368ddf3b6c47faafec93910a1a0e322dffbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3392f8ae4074de4de15befee871ad8b1523a2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3392f8ae4074de4de15befee871ad8b1523a2ed", "html_url": "https://github.com/rust-lang/rust/commit/b3392f8ae4074de4de15befee871ad8b1523a2ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3392f8ae4074de4de15befee871ad8b1523a2ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39cb4c60575b371f6c8d473160ae6dfea4bb83e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/39cb4c60575b371f6c8d473160ae6dfea4bb83e5", "html_url": "https://github.com/rust-lang/rust/commit/39cb4c60575b371f6c8d473160ae6dfea4bb83e5"}, {"sha": "a0fb93ddb4eb5fe1fe59ae10c14795b893ba786a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fb93ddb4eb5fe1fe59ae10c14795b893ba786a", "html_url": "https://github.com/rust-lang/rust/commit/a0fb93ddb4eb5fe1fe59ae10c14795b893ba786a"}], "stats": {"total": 198, "additions": 136, "deletions": 62}, "files": [{"sha": "19528a1403828db66ebfec1a1f6bbe109d53dab0", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=b3392f8ae4074de4de15befee871ad8b1523a2ed", "patch": "@@ -330,6 +330,10 @@ pub struct IndexVec<I: Idx, T> {\n     _marker: PhantomData<Fn(&I)>\n }\n \n+// Whether `IndexVec` is `Send` depends only on the data,\n+// not the phantom data.\n+unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n+\n impl<I: Idx, T: serialize::Encodable> serialize::Encodable for IndexVec<I, T> {\n     fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         serialize::Encodable::encode(&self.raw, s)"}, {"sha": "9e5de8d54e9de459e96f48fd9020feb54fd42b4d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b3392f8ae4074de4de15befee871ad8b1523a2ed", "patch": "@@ -646,14 +646,11 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         disambiguator,\n     );\n \n-    let dep_graph = if sess.opts.build_dep_graph() {\n-        let prev_dep_graph = time(time_passes, \"load prev dep-graph\", || {\n-            rustc_incremental::load_dep_graph(sess)\n-        });\n-\n-        DepGraph::new(prev_dep_graph)\n+    // If necessary, compute the dependency graph (in the background).\n+    let future_dep_graph = if sess.opts.build_dep_graph() {\n+        Some(rustc_incremental::load_dep_graph(sess, time_passes))\n     } else {\n-        DepGraph::new_disabled()\n+        None\n     };\n \n     time(time_passes, \"recursion limit\", || {\n@@ -881,6 +878,17 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     })?;\n \n     // Lower ast -> hir.\n+    // First, we need to collect the dep_graph.\n+    let dep_graph = match future_dep_graph {\n+        None => DepGraph::new_disabled(),\n+        Some(future) => {\n+            let prev_graph = future\n+                .open()\n+                .expect(\"Could not join with background dep_graph thread\")\n+                .open(sess);\n+            DepGraph::new(prev_graph)\n+        }\n+    };\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, &mut resolver);\n "}, {"sha": "108eccf047efe547bdf672f46435f0b5ac1704ca", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=b3392f8ae4074de4de15befee871ad8b1523a2ed", "patch": "@@ -24,7 +24,6 @@ use std::path::Path;\n use std::fs::File;\n use std::env;\n \n-use rustc::session::Session;\n use rustc::session::config::nightly_options;\n \n /// The first few bytes of files generated by incremental compilation\n@@ -60,7 +59,9 @@ pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n ///   incompatible version of the compiler.\n /// - Returns `Err(..)` if some kind of IO error occurred while reading the\n ///   file.\n-pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usize)>> {\n+pub fn read_file(report_incremental_info: bool, path: &Path)\n+    -> io::Result<Option<(Vec<u8>, usize)>>\n+{\n     if !path.exists() {\n         return Ok(None);\n     }\n@@ -79,7 +80,7 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usi\n         let mut file_magic = [0u8; 4];\n         file.read_exact(&mut file_magic)?;\n         if file_magic != FILE_MAGIC {\n-            report_format_mismatch(sess, path, \"Wrong FILE_MAGIC\");\n+            report_format_mismatch(report_incremental_info, path, \"Wrong FILE_MAGIC\");\n             return Ok(None)\n         }\n     }\n@@ -93,7 +94,7 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usi\n                                     ((header_format_version[1] as u16) << 8);\n \n         if header_format_version != HEADER_FORMAT_VERSION {\n-            report_format_mismatch(sess, path, \"Wrong HEADER_FORMAT_VERSION\");\n+            report_format_mismatch(report_incremental_info, path, \"Wrong HEADER_FORMAT_VERSION\");\n             return Ok(None)\n         }\n     }\n@@ -108,7 +109,7 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usi\n         file.read_exact(&mut buffer)?;\n \n         if buffer != rustc_version().as_bytes() {\n-            report_format_mismatch(sess, path, \"Different compiler version\");\n+            report_format_mismatch(report_incremental_info, path, \"Different compiler version\");\n             return Ok(None);\n         }\n     }\n@@ -117,10 +118,10 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usi\n     Ok(Some((file.into_inner(), post_header_start_pos)))\n }\n \n-fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {\n+fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &str) {\n     debug!(\"read_file: {}\", message);\n \n-    if sess.opts.debugging_opts.incremental_info {\n+    if report_incremental_info {\n         println!(\"[incremental] ignoring cache artifact `{}`: {}\",\n                   file.file_name().unwrap().to_string_lossy(),\n                   message);"}, {"sha": "42b1fcccacef2ac900f59670013cf54a9813a498", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=b3392f8ae4074de4de15befee871ad8b1523a2ed", "patch": "@@ -142,6 +142,9 @@ const INT_ENCODE_BASE: u64 = 36;\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n+pub fn dep_graph_path_from(incr_comp_session_dir: &Path) -> PathBuf {\n+    in_incr_comp_dir(incr_comp_session_dir, DEP_GRAPH_FILENAME)\n+}\n \n pub fn work_products_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, WORK_PRODUCTS_FILENAME)"}, {"sha": "0e6d328d947b249350f098bab8d6a23a01c9c593", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 106, "deletions": 48, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3392f8ae4074de4de15befee871ad8b1523a2ed/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=b3392f8ae4074de4de15befee871ad8b1523a2ed", "patch": "@@ -14,9 +14,11 @@ use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::OnDiskCache;\n+use rustc::util::common::time;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::Path;\n+use std;\n \n use super::data::*;\n use super::fs::*;\n@@ -39,7 +41,9 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     let work_products_path = work_products_path(tcx.sess);\n-    if let Some((work_products_data, start_pos)) = load_data(tcx.sess, &work_products_path) {\n+    let load_result = load_data(tcx.sess.opts.debugging_opts.incremental_info, &work_products_path);\n+\n+    if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n         // Decode the list of work_products\n         let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n         let work_products: Vec<SerializedWorkProduct> =\n@@ -74,27 +78,50 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn load_data(sess: &Session, path: &Path) -> Option<(Vec<u8>, usize)> {\n-    match file_format::read_file(sess, path) {\n-        Ok(Some(data_and_pos)) => return Some(data_and_pos),\n+pub enum LoadResult<T> {\n+    Ok { data: T },\n+    DataOutOfDate,\n+    Error { message: String },\n+}\n+\n+\n+impl LoadResult<PreviousDepGraph> {\n+    pub fn open(self, sess: &Session) -> PreviousDepGraph {\n+        match self {\n+            LoadResult::Error { message } => {\n+                sess.fatal(&message) /* never returns */\n+            },\n+            LoadResult::DataOutOfDate => {\n+                if let Err(err) = delete_all_session_dir_contents(sess) {\n+                    sess.err(&format!(\"Failed to delete invalidated or incompatible \\\n+                                      incremental compilation session directory contents `{}`: {}.\",\n+                                      dep_graph_path(sess).display(), err));\n+                }\n+                PreviousDepGraph::new(SerializedDepGraph::new())\n+            }\n+            LoadResult::Ok { data } => data\n+        }\n+    }\n+}\n+\n+\n+fn load_data(report_incremental_info: bool, path: &Path) -> LoadResult<(Vec<u8>, usize)> {\n+    match file_format::read_file(report_incremental_info, path) {\n+        Ok(Some(data_and_pos)) => LoadResult::Ok {\n+            data: data_and_pos\n+        },\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n             // compiler version. Neither is an error.\n+            LoadResult::DataOutOfDate\n         }\n         Err(err) => {\n-            sess.err(\n-                &format!(\"could not load dep-graph from `{}`: {}\",\n-                         path.display(), err));\n+            LoadResult::Error {\n+                message: format!(\"could not load dep-graph from `{}`: {}\",\n+                                  path.display(), err)\n+            }\n         }\n     }\n-\n-    if let Err(err) = delete_all_session_dir_contents(sess) {\n-        sess.err(&format!(\"could not clear incompatible incremental \\\n-                           compilation session directory `{}`: {}\",\n-                          path.display(), err));\n-    }\n-\n-    None\n }\n \n fn delete_dirty_work_product(tcx: TyCtxt,\n@@ -103,41 +130,73 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n     work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n }\n \n-pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n-    let empty = PreviousDepGraph::new(SerializedDepGraph::new());\n-\n-    if sess.opts.incremental.is_none() {\n-        return empty\n+/// Either a result that has already be computed or a\n+/// handle that will let us wait until it is computed\n+/// by a background thread.\n+pub enum MaybeAsync<T> {\n+    Sync(T),\n+    Async(std::thread::JoinHandle<T>)\n+}\n+impl<T> MaybeAsync<T> {\n+    pub fn open(self) -> std::thread::Result<T> {\n+        match self {\n+            MaybeAsync::Sync(result) => Ok(result),\n+            MaybeAsync::Async(handle) => handle.join()\n+        }\n     }\n+}\n \n-    if let Some((bytes, start_pos)) = load_data(sess, &dep_graph_path(sess)) {\n-        let mut decoder = Decoder::new(&bytes, start_pos);\n-        let prev_commandline_args_hash = u64::decode(&mut decoder)\n-            .expect(\"Error reading commandline arg hash from cached dep-graph\");\n-\n-        if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n-            if sess.opts.debugging_opts.incremental_info {\n-                println!(\"[incremental] completely ignoring cache because of \\\n-                          differing commandline arguments\");\n-            }\n-            // We can't reuse the cache, purge it.\n-            debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n+/// Launch a thread and load the dependency graph in the background.\n+pub fn load_dep_graph(sess: &Session, time_passes: bool) ->\n+    MaybeAsync<LoadResult<PreviousDepGraph>>\n+{\n+    // Since `sess` isn't `Sync`, we perform all accesses to `sess`\n+    // before we fire the background thread.\n \n-            delete_all_session_dir_contents(sess)\n-                .expect(\"Failed to delete invalidated incr. comp. session \\\n-                         directory contents.\");\n+    if sess.opts.incremental.is_none() {\n+        // No incremental compilation.\n+        return MaybeAsync::Sync(LoadResult::Ok {\n+            data: PreviousDepGraph::new(SerializedDepGraph::new())\n+        });\n+    }\n \n-            // No need to do any further work\n-            return empty\n-        }\n+    // Calling `sess.incr_comp_session_dir()` will panic if `sess.opts.incremental.is_none()`.\n+    // Fortunately, we just checked that this isn't the case.\n+    let path = dep_graph_path_from(&sess.incr_comp_session_dir());\n+    let report_incremental_info = sess.opts.debugging_opts.incremental_info;\n+    let expected_hash = sess.opts.dep_tracking_hash();\n+\n+    MaybeAsync::Async(std::thread::spawn(move || {\n+        time(time_passes, \"background load prev dep-graph\", move || {\n+            match load_data(report_incremental_info, &path) {\n+                LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n+                LoadResult::Error { message } => LoadResult::Error { message },\n+                LoadResult::Ok { data: (bytes, start_pos) } => {\n+\n+                    let mut decoder = Decoder::new(&bytes, start_pos);\n+                    let prev_commandline_args_hash = u64::decode(&mut decoder)\n+                        .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+\n+                    if prev_commandline_args_hash != expected_hash {\n+                        if report_incremental_info {\n+                            println!(\"[incremental] completely ignoring cache because of \\\n+                                    differing commandline arguments\");\n+                        }\n+                        // We can't reuse the cache, purge it.\n+                        debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n+\n+                        // No need to do any further work\n+                        return LoadResult::DataOutOfDate;\n+                    }\n \n-        let dep_graph = SerializedDepGraph::decode(&mut decoder)\n-            .expect(\"Error reading cached dep-graph\");\n+                    let dep_graph = SerializedDepGraph::decode(&mut decoder)\n+                        .expect(\"Error reading cached dep-graph\");\n \n-        PreviousDepGraph::new(dep_graph)\n-    } else {\n-        empty\n-    }\n+                    LoadResult::Ok { data: PreviousDepGraph::new(dep_graph) }\n+                }\n+            }\n+        })\n+    }))\n }\n \n pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n@@ -146,9 +205,8 @@ pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess\n         return OnDiskCache::new_empty(sess.codemap());\n     }\n \n-    if let Some((bytes, start_pos)) = load_data(sess, &query_cache_path(sess)) {\n-        OnDiskCache::new(sess, bytes, start_pos)\n-    } else {\n-        OnDiskCache::new_empty(sess.codemap())\n+    match load_data(sess.opts.debugging_opts.incremental_info, &query_cache_path(sess)) {\n+        LoadResult::Ok{ data: (bytes, start_pos) } => OnDiskCache::new(sess, bytes, start_pos),\n+        _ => OnDiskCache::new_empty(sess.codemap())\n     }\n }"}]}