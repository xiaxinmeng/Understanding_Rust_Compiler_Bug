{"sha": "a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MGI5YTU4NzJjOWM5MTY3MzM4MTZlMWUwZDhjOTVjYjA5YmZjYmE=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2021-05-04T21:13:51Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2021-05-23T19:50:36Z"}, "message": "implement range formatting", "tree": {"sha": "6b170854407d2ed0e667623c8cdf1fb4a844230c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b170854407d2ed0e667623c8cdf1fb4a844230c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAmCqsg0WHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdKO/B/4m3tJW53ewP2o3zKv0NfbBrx1O\nkMVU1/cDcMnqD/Z2aDIuyplDo1rXmiDPRrnt3t4qkB6qCUKEJWpFG2s9Tpfnx+cZ\n/6C2Vw0MdUvm6k8Q37eDvNTr0AbQ9V18DhNNaFLyOBCSGv+wi8l32OdfZkhmsDt9\njfGN1O5ZOjRM8fpPQWCG0OkGWVJOuSzBjoT+og7VaM/eHpIX8O0vwDLu9KRtzTwt\nLlwu40f3VYhM957AA0ZYh4rTpHukmIp11hhpLq7sVdVGlgJhNUL9Z7deBXJV0MJD\nvCjSLHKbgV0VQa36+orvHVYckaBDmfSi8vYe/Hs96kzCLu+Z0uwJdozW+cqp\n=yJnl\n-----END PGP SIGNATURE-----", "payload": "tree 6b170854407d2ed0e667623c8cdf1fb4a844230c\nparent 16054887102104208f4a0fc0e75e702b85a2eae8\nauthor Andy Russell <arussell123@gmail.com> 1620162831 -0400\ncommitter Andy Russell <arussell123@gmail.com> 1621799436 -0400\n\nimplement range formatting\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "html_url": "https://github.com/rust-lang/rust/commit/a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16054887102104208f4a0fc0e75e702b85a2eae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/16054887102104208f4a0fc0e75e702b85a2eae8", "html_url": "https://github.com/rust-lang/rust/commit/16054887102104208f4a0fc0e75e702b85a2eae8"}], "stats": {"total": 269, "additions": 167, "deletions": 102}, "files": [{"sha": "4d88932ca500a92b56dda56a74ea2121e141b185", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -1,4 +1,4 @@\n-//! Advertizes the capabilities of the LSP Server.\n+//! Advertises the capabilities of the LSP Server.\n use std::env;\n \n use lsp_types::{\n@@ -54,7 +54,7 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         code_action_provider: Some(code_action_capabilities(client_caps)),\n         code_lens_provider: Some(CodeLensOptions { resolve_provider: Some(true) }),\n         document_formatting_provider: Some(OneOf::Left(true)),\n-        document_range_formatting_provider: None,\n+        document_range_formatting_provider: Some(OneOf::Left(true)),\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n             more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string(), \"{\".to_string()]),"}, {"sha": "2e99db36cd21c34acb3eab7f1a366d061282d375", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -218,6 +218,10 @@ config_data! {\n         /// Advanced option, fully override the command rust-analyzer uses for\n         /// formatting.\n         rustfmt_overrideCommand: Option<Vec<String>> = \"null\",\n+        /// Enables the use of rustfmt's unstable range formatting command for the\n+        /// `textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n+        /// available on a nightly build.\n+        rustfmt_enableRangeFormatting: bool = \"false\",\n \n         /// Workspace symbol search scope.\n         workspace_symbol_search_scope: WorskpaceSymbolSearchScopeDef = \"\\\"workspace\\\"\",\n@@ -304,7 +308,7 @@ pub struct NotificationsConfig {\n \n #[derive(Debug, Clone)]\n pub enum RustfmtConfig {\n-    Rustfmt { extra_args: Vec<String> },\n+    Rustfmt { extra_args: Vec<String>, enable_range_formatting: bool },\n     CustomCommand { command: String, args: Vec<String> },\n }\n \n@@ -569,9 +573,10 @@ impl Config {\n                 let command = args.remove(0);\n                 RustfmtConfig::CustomCommand { command, args }\n             }\n-            Some(_) | None => {\n-                RustfmtConfig::Rustfmt { extra_args: self.data.rustfmt_extraArgs.clone() }\n-            }\n+            Some(_) | None => RustfmtConfig::Rustfmt {\n+                extra_args: self.data.rustfmt_extraArgs.clone(),\n+                enable_range_formatting: self.data.rustfmt_enableRangeFormatting,\n+            },\n         }\n     }\n     pub fn flycheck(&self) -> Option<FlycheckConfig> {"}, {"sha": "53161eb3e02e3398d56496b9c4bd4d5e49af827e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 143, "deletions": 96, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -27,7 +27,7 @@ use lsp_types::{\n };\n use project_model::TargetKind;\n use serde::{Deserialize, Serialize};\n-use serde_json::to_value;\n+use serde_json::{json, to_value};\n use stdx::format_to;\n use syntax::{algo, ast, AstNode, TextRange, TextSize};\n \n@@ -946,104 +946,17 @@ pub(crate) fn handle_formatting(\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile::span(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let file = snap.analysis.file_text(file_id)?;\n-    let crate_ids = snap.analysis.crate_for(file_id)?;\n-\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut rustfmt = match snap.config.rustfmt() {\n-        RustfmtConfig::Rustfmt { extra_args } => {\n-            let mut cmd = process::Command::new(toolchain::rustfmt());\n-            cmd.args(extra_args);\n-            // try to chdir to the file so we can respect `rustfmt.toml`\n-            // FIXME: use `rustfmt --config-path` once\n-            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n-            match params.text_document.uri.to_file_path() {\n-                Ok(mut path) => {\n-                    // pop off file name\n-                    if path.pop() && path.is_dir() {\n-                        cmd.current_dir(path);\n-                    }\n-                }\n-                Err(_) => {\n-                    log::error!(\n-                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n-                        params.text_document.uri\n-                    );\n-                }\n-            }\n-            if let Some(&crate_id) = crate_ids.first() {\n-                // Assume all crates are in the same edition\n-                let edition = snap.analysis.crate_edition(crate_id)?;\n-                cmd.arg(\"--edition\");\n-                cmd.arg(edition.to_string());\n-            }\n-            cmd\n-        }\n-        RustfmtConfig::CustomCommand { command, args } => {\n-            let mut cmd = process::Command::new(command);\n-            cmd.args(args);\n-            cmd\n-        }\n-    };\n \n-    let mut rustfmt =\n-        rustfmt.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped()).spawn()?;\n-\n-    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n-\n-    let output = rustfmt.wait_with_output()?;\n-    let captured_stdout = String::from_utf8(output.stdout)?;\n-    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n-\n-    if !output.status.success() {\n-        let rustfmt_not_installed =\n-            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n-\n-        return match output.status.code() {\n-            Some(1) if !rustfmt_not_installed => {\n-                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n-                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n-                // formatting because otherwise an error is surfaced to the user on top of the\n-                // syntax error diagnostics they're already receiving. This is especially jarring\n-                // if they have format on save enabled.\n-                log::info!(\"rustfmt exited with status 1, assuming parse error and ignoring\");\n-                Ok(None)\n-            }\n-            _ => {\n-                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n-                Err(LspError::new(\n-                    -32900,\n-                    format!(\n-                        r#\"rustfmt exited with:\n-                           Status: {}\n-                           stdout: {}\n-                           stderr: {}\"#,\n-                        output.status, captured_stdout, captured_stderr,\n-                    ),\n-                )\n-                .into())\n-            }\n-        };\n-    }\n+    run_rustfmt(&snap, params.text_document, None)\n+}\n \n-    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n+pub(crate) fn handle_range_formatting(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentRangeFormattingParams,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let _p = profile::span(\"handle_range_formatting\");\n \n-    if line_index.endings != new_line_endings {\n-        // If line endings are different, send the entire file.\n-        // Diffing would not work here, as the line endings might be the only\n-        // difference.\n-        Ok(Some(to_proto::text_edit_vec(\n-            &line_index,\n-            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n-        )))\n-    } else if *file == new_text {\n-        // The document is already formatted correctly -- no edits needed.\n-        Ok(None)\n-    } else {\n-        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n-    }\n+    run_rustfmt(&snap, params.text_document, Some(params.range))\n }\n \n pub(crate) fn handle_code_action(\n@@ -1666,6 +1579,140 @@ fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>)\n     }\n }\n \n+fn run_rustfmt(\n+    snap: &GlobalStateSnapshot,\n+    text_document: TextDocumentIdentifier,\n+    range: Option<lsp_types::Range>,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let file_id = from_proto::file_id(&snap, &text_document.uri)?;\n+    let file = snap.analysis.file_text(file_id)?;\n+    let crate_ids = snap.analysis.crate_for(file_id)?;\n+\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut rustfmt = match snap.config.rustfmt() {\n+        RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n+            let mut cmd = process::Command::new(toolchain::rustfmt());\n+            cmd.args(extra_args);\n+            // try to chdir to the file so we can respect `rustfmt.toml`\n+            // FIXME: use `rustfmt --config-path` once\n+            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n+            match text_document.uri.to_file_path() {\n+                Ok(mut path) => {\n+                    // pop off file name\n+                    if path.pop() && path.is_dir() {\n+                        cmd.current_dir(path);\n+                    }\n+                }\n+                Err(_) => {\n+                    log::error!(\n+                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n+                        text_document.uri\n+                    );\n+                }\n+            }\n+            if let Some(&crate_id) = crate_ids.first() {\n+                // Assume all crates are in the same edition\n+                let edition = snap.analysis.crate_edition(crate_id)?;\n+                cmd.arg(\"--edition\");\n+                cmd.arg(edition.to_string());\n+            }\n+\n+            if let Some(range) = range {\n+                if !enable_range_formatting {\n+                    return Err(LspError::new(\n+                        ErrorCode::InvalidRequest as i32,\n+                        String::from(\n+                            \"rustfmt range formatting is unstable. \\\n+                            Opt-in by using a nightly build of rustfmt and setting \\\n+                            `rustfmt.enableRangeFormatting` to true in your LSP configuration\",\n+                        ),\n+                    )\n+                    .into());\n+                }\n+\n+                let frange = from_proto::file_range(&snap, text_document.clone(), range)?;\n+                let start_line = line_index.index.line_col(frange.range.start()).line;\n+                let end_line = line_index.index.line_col(frange.range.end()).line;\n+\n+                cmd.arg(\"--unstable-features\");\n+                cmd.arg(\"--file-lines\");\n+                cmd.arg(\n+                    json!([{\n+                        \"file\": \"stdin\",\n+                        \"range\": [start_line, end_line]\n+                    }])\n+                    .to_string(),\n+                );\n+            }\n+\n+            cmd\n+        }\n+        RustfmtConfig::CustomCommand { command, args } => {\n+            let mut cmd = process::Command::new(command);\n+            cmd.args(args);\n+            cmd\n+        }\n+    };\n+\n+    let mut rustfmt =\n+        rustfmt.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped()).spawn()?;\n+\n+    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n+\n+    let output = rustfmt.wait_with_output()?;\n+    let captured_stdout = String::from_utf8(output.stdout)?;\n+    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n+\n+    if !output.status.success() {\n+        let rustfmt_not_installed =\n+            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n+\n+        return match output.status.code() {\n+            Some(1) if !rustfmt_not_installed => {\n+                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n+                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n+                // formatting because otherwise an error is surfaced to the user on top of the\n+                // syntax error diagnostics they're already receiving. This is especially jarring\n+                // if they have format on save enabled.\n+                log::info!(\"rustfmt exited with status 1, assuming parse error and ignoring\");\n+                Ok(None)\n+            }\n+            _ => {\n+                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n+                Err(LspError::new(\n+                    -32900,\n+                    format!(\n+                        r#\"rustfmt exited with:\n+                           Status: {}\n+                           stdout: {}\n+                           stderr: {}\"#,\n+                        output.status, captured_stdout, captured_stderr,\n+                    ),\n+                )\n+                .into())\n+            }\n+        };\n+    }\n+\n+    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n+\n+    if line_index.endings != new_line_endings {\n+        // If line endings are different, send the entire file.\n+        // Diffing would not work here, as the line endings might be the only\n+        // difference.\n+        Ok(Some(to_proto::text_edit_vec(\n+            &line_index,\n+            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n+        )))\n+    } else if *file == new_text {\n+        // The document is already formatted correctly -- no edits needed.\n+        Ok(None)\n+    } else {\n+        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n+    }\n+}\n+\n #[derive(Debug, Serialize, Deserialize)]\n struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,"}, {"sha": "e202da62175c9c75193043cc9538d143a7e29c32", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -542,6 +542,7 @@ impl GlobalState {\n             .on::<lsp_types::request::Rename>(handlers::handle_rename)\n             .on::<lsp_types::request::References>(handlers::handle_references)\n             .on::<lsp_types::request::Formatting>(handlers::handle_formatting)\n+            .on::<lsp_types::request::RangeFormatting>(handlers::handle_range_formatting)\n             .on::<lsp_types::request::DocumentHighlightRequest>(handlers::handle_document_highlight)\n             .on::<lsp_types::request::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)\n             .on::<lsp_types::request::CallHierarchyIncomingCalls>("}, {"sha": "f3da82febbeeed7c683c568f6f6db1cf4fa3fa75", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -346,6 +346,13 @@ Additional arguments to `rustfmt`.\n Advanced option, fully override the command rust-analyzer uses for\n formatting.\n --\n+[[rust-analyzer.rustfmt.enableRangeFormatting]]rust-analyzer.rustfmt.enableRangeFormatting (default: `false`)::\n++\n+--\n+Enables the use of rustfmt's unstable range formatting command for the\n+`textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n+available on a nightly build.\n+--\n [[rust-analyzer.workspace.symbol.search.scope]]rust-analyzer.workspace.symbol.search.scope (default: `\"workspace\"`)::\n +\n --"}, {"sha": "05cbccf94643726497bdf2d16290d1d4a8392702", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a90b9a5872c9c916733816e1e0d8c95cb09bfcba/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "patch": "@@ -795,6 +795,11 @@\n                         \"type\": \"string\"\n                     }\n                 },\n+                \"rust-analyzer.rustfmt.enableRangeFormatting\": {\n+                    \"markdownDescription\": \"Enables the use of rustfmt's unstable range formatting command for the\\n`textDocument/rangeFormatting` request. The rustfmt option is unstable and only\\navailable on a nightly build.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.workspace.symbol.search.scope\": {\n                     \"markdownDescription\": \"Workspace symbol search scope.\",\n                     \"default\": \"workspace\","}]}