{"sha": "b89fef522043f0fe4dc1977059b70bbd20d6fd75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4OWZlZjUyMjA0M2YwZmU0ZGMxOTc3MDU5YjcwYmJkMjBkNmZkNzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-05T14:28:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-05T14:28:25Z"}, "message": "Merge #7562\n\n7562: add `generate_enum_match` assist r=matklad a=yoshuawuyts\n\nThis adds a `generate_enum_match` assist, which generates `is_` variants for enums (e.g. `Option::{is_none,is_some}` in std). This is my first attempt at contributing to Rust-Analyzer, so I'm not sure if I've gotten everything right. Thanks!\r\n\r\n## Example\r\n\r\n**Input**\r\n```rust\r\npub(crate) enum Variant {\r\n    Undefined,\r\n    Minor, // cursor here\r\n    Major,\r\n}\r\n```\r\n**Output**\r\n```rust\r\npub(crate) enum Variant {\r\n    Undefined,\r\n    Minor,\r\n    Major,\r\n}\r\n\r\nimpl Variant {\r\n    pub(crate) fn is_minor(&self) -> bool {\r\n        matches!(self, Self::Minor)\r\n    }\r\n}\r\n```\r\n\r\n## Future Directions\r\n\r\nI made this as a stepping stone for some of the more involved refactors (e.g. #5944). I'm not sure yet how to create, use, and test `window.showQuickPick`-based asssists in RA. But once that's possible, it'd probably be nice to be able to generate match methods in bulk through the quickpick UI rather than one-by-one:\r\n\r\n```\r\n[x] Select enum members to generate methods for. (3 selected) [ OK ]\r\n---------------------------------------------------------------------------\r\n[x] Undefined\r\n[x] Minor\r\n[x] Major\r\n```\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts+github@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "f9cc2fc85cd7233351c897f725585efe55b867c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9cc2fc85cd7233351c897f725585efe55b867c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b89fef522043f0fe4dc1977059b70bbd20d6fd75", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgHVYJCRBK7hj4Ov3rIwAAdHIIAAGdR5c0zVYeToHRdEhxHmST\nYVbYjppj9arfKFC3LbXghgg8zPejnWVg5CapHWExDN4SgdQ5JjnYXjiIruqk3lmZ\nrabZKztjZUw8IX3YPMkvTCL8y0vynobDeLpoGm0wdXEpLGG9bBrmb6PXyRRl5QZj\nNKbdpptsl9Wr4PBGI8lzOLOrf4r1aGoAq5+j5nRbY6FIaHnLvd6nySFQBEo7yyfH\ngjr0+NTJkRr2sXRXILLPvxZOhEc5532oLFFLrhxZgWIrmFLfN/RVaV7AFRQU6Wxg\nSxA9fGSBsMqRFgGA4ghUmdHENUOVDpmbR7t16uGUUco4eLu8h9y+hCHA1IwQjdY=\n=beIb\n-----END PGP SIGNATURE-----\n", "payload": "tree f9cc2fc85cd7233351c897f725585efe55b867c6\nparent 5009958847efa5d3cd85f2a9a84074069ca2088d\nparent dfd751303ec6336a4a78776eb8030790b7b0b000\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612535305 +0000\ncommitter GitHub <noreply@github.com> 1612535305 +0000\n\nMerge #7562\n\n7562: add `generate_enum_match` assist r=matklad a=yoshuawuyts\n\nThis adds a `generate_enum_match` assist, which generates `is_` variants for enums (e.g. `Option::{is_none,is_some}` in std). This is my first attempt at contributing to Rust-Analyzer, so I'm not sure if I've gotten everything right. Thanks!\r\n\r\n## Example\r\n\r\n**Input**\r\n```rust\r\npub(crate) enum Variant {\r\n    Undefined,\r\n    Minor, // cursor here\r\n    Major,\r\n}\r\n```\r\n**Output**\r\n```rust\r\npub(crate) enum Variant {\r\n    Undefined,\r\n    Minor,\r\n    Major,\r\n}\r\n\r\nimpl Variant {\r\n    pub(crate) fn is_minor(&self) -> bool {\r\n        matches!(self, Self::Minor)\r\n    }\r\n}\r\n```\r\n\r\n## Future Directions\r\n\r\nI made this as a stepping stone for some of the more involved refactors (e.g. #5944). I'm not sure yet how to create, use, and test `window.showQuickPick`-based asssists in RA. But once that's possible, it'd probably be nice to be able to generate match methods in bulk through the quickpick UI rather than one-by-one:\r\n\r\n```\r\n[x] Select enum members to generate methods for. (3 selected) [ OK ]\r\n---------------------------------------------------------------------------\r\n[x] Undefined\r\n[x] Minor\r\n[x] Major\r\n```\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts+github@gmail.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b89fef522043f0fe4dc1977059b70bbd20d6fd75", "html_url": "https://github.com/rust-lang/rust/commit/b89fef522043f0fe4dc1977059b70bbd20d6fd75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b89fef522043f0fe4dc1977059b70bbd20d6fd75/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5009958847efa5d3cd85f2a9a84074069ca2088d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5009958847efa5d3cd85f2a9a84074069ca2088d", "html_url": "https://github.com/rust-lang/rust/commit/5009958847efa5d3cd85f2a9a84074069ca2088d"}, {"sha": "dfd751303ec6336a4a78776eb8030790b7b0b000", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd751303ec6336a4a78776eb8030790b7b0b000", "html_url": "https://github.com/rust-lang/rust/commit/dfd751303ec6336a4a78776eb8030790b7b0b000"}], "stats": {"total": 381, "additions": 317, "deletions": 64}, "files": [{"sha": "270b438b705b1c0f2a3da576cb58a1795173526f", "filename": "crates/assists/src/handlers/generate_enum_match_method.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=b89fef522043f0fe4dc1977059b70bbd20d6fd75", "patch": "@@ -0,0 +1,213 @@\n+use stdx::{format_to, to_lower_snake_case};\n+use syntax::ast::{self, AstNode, NameOwner};\n+use syntax::{ast::VisibilityOwner, T};\n+use test_utils::mark;\n+\n+use crate::{utils::find_struct_impl, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: generate_enum_match_method\n+//\n+// Generate an `is_` method for an enum variant.\n+//\n+// ```\n+// enum Version {\n+//  Undefined,\n+//  Minor$0,\n+//  Major,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Version {\n+//  Undefined,\n+//  Minor,\n+//  Major,\n+// }\n+//\n+// impl Version {\n+//     fn is_minor(&self) -> bool {\n+//         matches!(self, Self::Minor)\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_match_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let variant_name = variant.name()?;\n+    let parent_enum = variant.parent_enum();\n+    if !matches!(variant.kind(), ast::StructKind::Unit) {\n+        mark::hit!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n+        return None;\n+    }\n+\n+    let fn_name = to_lower_snake_case(&variant_name.to_string());\n+\n+    // Return early if we've found an existing new fn\n+    let impl_def = find_struct_impl(\n+        &ctx,\n+        &ast::AdtDef::Enum(parent_enum.clone()),\n+        format!(\"is_{}\", fn_name).as_str(),\n+    )?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(\n+        AssistId(\"generate_enum_match_method\", AssistKind::Generate),\n+        \"Generate an `is_` method for an enum variant\",\n+        target,\n+        |builder| {\n+            let mut buf = String::with_capacity(512);\n+\n+            if impl_def.is_some() {\n+                buf.push('\\n');\n+            }\n+\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+\n+            format_to!(\n+                buf,\n+                \"    {}fn is_{}(&self) -> bool {{\n+        matches!(self, Self::{})\n+    }}\",\n+                vis,\n+                fn_name,\n+                variant_name\n+            );\n+\n+            let start_offset = impl_def\n+                .and_then(|impl_def| {\n+                    buf.push('\\n');\n+                    let start = impl_def\n+                        .syntax()\n+                        .descendants_with_tokens()\n+                        .find(|t| t.kind() == T!['{'])?\n+                        .text_range()\n+                        .end();\n+\n+                    Some(start)\n+                })\n+                .unwrap_or_else(|| {\n+                    buf = generate_impl_text(&parent_enum, &buf);\n+                    parent_enum.syntax().text_range().end()\n+                });\n+\n+            builder.insert(start_offset, buf);\n+        },\n+    )\n+}\n+\n+// Generates the surrounding `impl Type { <code> }` including type and lifetime\n+// parameters\n+fn generate_impl_text(strukt: &ast::Enum, code: &str) -> String {\n+    let mut buf = String::with_capacity(code.len());\n+    buf.push_str(\"\\n\\nimpl \");\n+    buf.push_str(strukt.name().unwrap().text());\n+    format_to!(buf, \" {{\\n{}\\n}}\", code);\n+    buf\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::mark;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    fn check_not_applicable(ra_fixture: &str) {\n+        check_assist_not_applicable(generate_enum_match_method, ra_fixture)\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor,\n+    Major,\n+}\n+\n+impl Variant {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_already_implemented() {\n+        check_not_applicable(\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\n+\n+impl Variant {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_no_element() {\n+        mark::check!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n+        check_not_applicable(\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor(u32)$0,\n+    Major,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant_with_one_variant() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"enum Variant { Undefi$0ned }\"#,\n+            r#\"\n+enum Variant { Undefined }\n+\n+impl Variant {\n+    fn is_undefined(&self) -> bool {\n+        matches!(self, Self::Undefined)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant_with_visibility_marker() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"\n+pub(crate) enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\"#,\n+            r#\"pub(crate) enum Variant {\n+    Undefined,\n+    Minor,\n+    Major,\n+}\n+\n+impl Variant {\n+    pub(crate) fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "84832273f491da9ffd57c532702d77760bc2016e", "filename": "crates/assists/src/handlers/generate_new.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=b89fef522043f0fe4dc1977059b70bbd20d6fd75", "patch": "@@ -1,12 +1,11 @@\n-use hir::Adt;\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, NameOwner, StructKind, VisibilityOwner},\n     SmolStr, T,\n };\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::find_struct_impl, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: generate_new\n //\n@@ -38,7 +37,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     };\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &strukt)?;\n+    let impl_def = find_struct_impl(&ctx, &ast::AdtDef::Struct(strukt.clone()), \"new\")?;\n \n     let target = strukt.syntax().text_range();\n     acc.add(AssistId(\"generate_new\", AssistKind::Generate), \"Generate `new`\", target, |builder| {\n@@ -111,65 +110,6 @@ fn generate_impl_text(strukt: &ast::Struct, code: &str) -> String {\n     buf\n }\n \n-// Uses a syntax-driven approach to find any impl blocks for the struct that\n-// exist within the module/file\n-//\n-// Returns `None` if we've found an existing `new` fn\n-//\n-// FIXME: change the new fn checking to a more semantic approach when that's more\n-// viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistContext, strukt: &ast::Struct) -> Option<Option<ast::Impl>> {\n-    let db = ctx.db();\n-    let module = strukt.syntax().ancestors().find(|node| {\n-        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n-    })?;\n-\n-    let struct_def = ctx.sema.to_def(strukt)?;\n-\n-    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n-        let blk = ctx.sema.to_def(&impl_blk)?;\n-\n-        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n-        // (we currently use the wrong type parameter)\n-        // also we wouldn't want to use e.g. `impl S<u32>`\n-        let same_ty = match blk.target_ty(db).as_adt() {\n-            Some(def) => def == Adt::Struct(struct_def),\n-            None => false,\n-        };\n-        let not_trait_impl = blk.target_trait(db).is_none();\n-\n-        if !(same_ty && not_trait_impl) {\n-            None\n-        } else {\n-            Some(impl_blk)\n-        }\n-    });\n-\n-    if let Some(ref impl_blk) = block {\n-        if has_new_fn(impl_blk) {\n-            return None;\n-        }\n-    }\n-\n-    Some(block)\n-}\n-\n-fn has_new_fn(imp: &ast::Impl) -> bool {\n-    if let Some(il) = imp.assoc_item_list() {\n-        for item in il.assoc_items() {\n-            if let ast::AssocItem::Fn(f) = item {\n-                if let Some(name) = f.name() {\n-                    if name.text().eq_ignore_ascii_case(\"new\") {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};"}, {"sha": "83fbf6986ba0be3d89b5c126d0e88c3805a1b612", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=b89fef522043f0fe4dc1977059b70bbd20d6fd75", "patch": "@@ -127,6 +127,7 @@ mod handlers {\n     mod flip_trait_bound;\n     mod generate_default_from_enum_variant;\n     mod generate_derive;\n+    mod generate_enum_match_method;\n     mod generate_from_impl_for_enum;\n     mod generate_function;\n     mod generate_impl;\n@@ -185,6 +186,7 @@ mod handlers {\n             flip_trait_bound::flip_trait_bound,\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_derive::generate_derive,\n+            generate_enum_match_method::generate_enum_match_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_impl::generate_impl,"}, {"sha": "960815bd99287cff4b6b6d4b3c654b8251e9f655", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=b89fef522043f0fe4dc1977059b70bbd20d6fd75", "patch": "@@ -459,6 +459,33 @@ struct Point {\n     )\n }\n \n+#[test]\n+fn doctest_generate_enum_match_method() {\n+    check_doc_test(\n+        \"generate_enum_match_method\",\n+        r#####\"\n+enum Version {\n+ Undefined,\n+ Minor$0,\n+ Major,\n+}\n+\"#####,\n+        r#####\"\n+enum Version {\n+ Undefined,\n+ Minor,\n+ Major,\n+}\n+\n+impl Version {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_from_impl_for_enum() {\n     check_doc_test("}, {"sha": "3842558d8dafb47e0b35c314897fbbdf3dc52a0f", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89fef522043f0fe4dc1977059b70bbd20d6fd75/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=b89fef522043f0fe4dc1977059b70bbd20d6fd75", "patch": "@@ -2,7 +2,7 @@\n \n use std::ops;\n \n-use hir::HasSource;\n+use hir::{Adt, HasSource};\n use ide_db::{helpers::SnippetCap, RootDatabase};\n use itertools::Itertools;\n use syntax::{\n@@ -15,7 +15,10 @@ use syntax::{\n     SyntaxNode, TextSize, T,\n };\n \n-use crate::ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams};\n+use crate::{\n+    assist_context::AssistContext,\n+    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+};\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)\n@@ -267,3 +270,71 @@ pub(crate) fn does_pat_match_variant(pat: &ast::Pat, var: &ast::Pat) -> bool {\n \n     pat_head == var_head\n }\n+\n+// Uses a syntax-driven approach to find any impl blocks for the struct that\n+// exist within the module/file\n+//\n+// Returns `None` if we've found an existing `new` fn\n+//\n+// FIXME: change the new fn checking to a more semantic approach when that's more\n+// viable (e.g. we process proc macros, etc)\n+pub(crate) fn find_struct_impl(\n+    ctx: &AssistContext,\n+    strukt: &ast::AdtDef,\n+    name: &str,\n+) -> Option<Option<ast::Impl>> {\n+    let db = ctx.db();\n+    let module = strukt.syntax().ancestors().find(|node| {\n+        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n+    })?;\n+\n+    let struct_def = match strukt {\n+        ast::AdtDef::Enum(e) => Adt::Enum(ctx.sema.to_def(e)?),\n+        ast::AdtDef::Struct(s) => Adt::Struct(ctx.sema.to_def(s)?),\n+        ast::AdtDef::Union(u) => Adt::Union(ctx.sema.to_def(u)?),\n+    };\n+\n+    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n+        let blk = ctx.sema.to_def(&impl_blk)?;\n+\n+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n+        // (we currently use the wrong type parameter)\n+        // also we wouldn't want to use e.g. `impl S<u32>`\n+\n+        let same_ty = match blk.target_ty(db).as_adt() {\n+            Some(def) => def == struct_def,\n+            None => false,\n+        };\n+        let not_trait_impl = blk.target_trait(db).is_none();\n+\n+        if !(same_ty && not_trait_impl) {\n+            None\n+        } else {\n+            Some(impl_blk)\n+        }\n+    });\n+\n+    if let Some(ref impl_blk) = block {\n+        if has_fn(impl_blk, name) {\n+            return None;\n+        }\n+    }\n+\n+    Some(block)\n+}\n+\n+fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n+    if let Some(il) = imp.assoc_item_list() {\n+        for item in il.assoc_items() {\n+            if let ast::AssocItem::Fn(f) = item {\n+                if let Some(name) = f.name() {\n+                    if name.text().eq_ignore_ascii_case(rhs_name) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}"}]}