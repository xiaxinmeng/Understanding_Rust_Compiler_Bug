{"sha": "e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZmJmZjMyNDZjZGQzMjc4ZmYxYzM3NmQ1YWJmYzFkNTc5Zjg2YzI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-16T08:08:10Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-16T08:08:10Z"}, "message": "Merge #1406\n\n1406: reuse AnalysisHost in batch analysis r=matklad a=matklad\n\nWe do some custom setup in `AnalysisHost`, like setting up LRU size. I figure it's a good idea to not duplicate this work in batch analysis, *if* we want to keep batch and non-batch close.\r\n\r\nLong-term, I see a value in keeping batch a separate, lighter weight thing. However, because now we use batch to measure performance, keeping them closer makes more sense.\r\n\r\nI'd also like to add ability to get completions by using batch analysis, and that will require ra_ide_api as well.\r\n\r\n@flodiebold were there some reason why we haven't started with this approach from the start?\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "736052286d9c0d8d06798165590bdf145a12d783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/736052286d9c0d8d06798165590bdf145a12d783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "html_url": "https://github.com/rust-lang/rust/commit/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ce9ea0939a1ae94a83d56ddafc7aeb757dcda776", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9ea0939a1ae94a83d56ddafc7aeb757dcda776", "html_url": "https://github.com/rust-lang/rust/commit/ce9ea0939a1ae94a83d56ddafc7aeb757dcda776"}, {"sha": "b0be4207d04b65580e7af10cb256ddd5d9ca006d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0be4207d04b65580e7af10cb256ddd5d9ca006d", "html_url": "https://github.com/rust-lang/rust/commit/b0be4207d04b65580e7af10cb256ddd5d9ca006d"}], "stats": {"total": 197, "additions": 89, "deletions": 108}, "files": [{"sha": "0579d9d39c1baab1ae2e7741798ebdceade7884b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -1023,6 +1023,7 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n+ \"ra_ide_api 0.1.0\",\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_vfs 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "7d8837fc3a151bafa9fee261f1474bff8674bcb3", "filename": "crates/ra_batch/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_batch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_batch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2FCargo.toml?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -11,6 +11,7 @@ rustc-hash = \"1.0\"\n ra_vfs = \"0.2.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n+ra_ide_api = { path = \"../ra_ide_api\" }\n ra_hir = { path = \"../ra_hir\" }\n ra_project_model = { path = \"../ra_project_model\" }\n "}, {"sha": "fa244e86c38c27feb1edf25bc3bb542550d2f25e", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 70, "deletions": 94, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -1,123 +1,99 @@\n mod vfs_filter;\n \n-use std::{sync::Arc, path::Path, collections::HashSet, error::Error};\n+use std::{path::Path, collections::HashSet, error::Error};\n \n use rustc_hash::FxHashMap;\n \n use ra_db::{\n-    CrateGraph, FileId, SourceRoot, SourceRootId, SourceDatabase, salsa::{self, Database},\n+    CrateGraph, FileId, SourceRootId,\n };\n-use ra_hir::db;\n+use ra_ide_api::{AnalysisHost, AnalysisChange};\n use ra_project_model::ProjectWorkspace;\n use ra_vfs::{Vfs, VfsChange};\n use vfs_filter::IncludeRustFiles;\n \n type Result<T> = std::result::Result<T, Box<dyn Error + Send + Sync>>;\n \n-#[salsa::database(\n-    ra_db::SourceDatabaseStorage,\n-    db::AstDatabaseStorage,\n-    db::DefDatabaseStorage,\n-    db::HirDatabaseStorage\n-)]\n-#[derive(Debug)]\n-pub struct BatchDatabase {\n-    runtime: salsa::Runtime<BatchDatabase>,\n-}\n-\n-impl salsa::Database for BatchDatabase {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<BatchDatabase> {\n-        &self.runtime\n-    }\n-}\n-\n fn vfs_file_to_id(f: ra_vfs::VfsFile) -> FileId {\n     FileId(f.0)\n }\n fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n     SourceRootId(r.0)\n }\n \n-impl BatchDatabase {\n-    pub fn load(crate_graph: CrateGraph, vfs: &mut Vfs) -> BatchDatabase {\n-        let mut db = BatchDatabase { runtime: salsa::Runtime::default() };\n-        let lru_cap = std::env::var(\"RA_LRU_CAP\")\n-            .ok()\n-            .and_then(|it| it.parse::<usize>().ok())\n-            .unwrap_or(ra_db::DEFAULT_LRU_CAP);\n-        db.query_mut(ra_db::ParseQuery).set_lru_capacity(lru_cap);\n-        db.query_mut(ra_hir::db::ParseMacroQuery).set_lru_capacity(lru_cap);\n-        db.set_crate_graph(Arc::new(crate_graph));\n+pub fn load_cargo(root: &Path) -> Result<(AnalysisHost, Vec<SourceRootId>)> {\n+    let root = std::env::current_dir()?.join(root);\n+    let ws = ProjectWorkspace::discover(root.as_ref())?;\n+    let mut roots = Vec::new();\n+    roots.push(IncludeRustFiles::member(root.clone()));\n+    roots.extend(IncludeRustFiles::from_roots(ws.to_roots()));\n+    let (mut vfs, roots) = Vfs::new(roots);\n+    let crate_graph = ws.to_crate_graph(&mut |path: &Path| {\n+        let vfs_file = vfs.load(path);\n+        log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n+        vfs_file.map(vfs_file_to_id)\n+    });\n+    log::debug!(\"crate graph: {:?}\", crate_graph);\n+\n+    let local_roots = roots\n+        .into_iter()\n+        .filter(|r| vfs.root2path(*r).starts_with(&root))\n+        .map(vfs_root_to_id)\n+        .collect();\n+\n+    let host = load(root.as_path(), crate_graph, &mut vfs);\n+    Ok((host, local_roots))\n+}\n \n-        // wait until Vfs has loaded all roots\n-        let receiver = vfs.task_receiver().clone();\n-        let mut roots_loaded = HashSet::new();\n-        for task in receiver {\n-            vfs.handle_task(task);\n-            let mut done = false;\n-            for change in vfs.commit_changes() {\n-                match change {\n-                    VfsChange::AddRoot { root, files } => {\n-                        let source_root_id = vfs_root_to_id(root);\n-                        log::debug!(\n-                            \"loaded source root {:?} with path {:?}\",\n-                            source_root_id,\n-                            vfs.root2path(root)\n-                        );\n-                        let mut file_map = FxHashMap::default();\n-                        for (vfs_file, path, text) in files {\n-                            let file_id = vfs_file_to_id(vfs_file);\n-                            db.set_file_text(file_id, text);\n-                            db.set_file_relative_path(file_id, path.clone());\n-                            db.set_file_source_root(file_id, source_root_id);\n-                            file_map.insert(path, file_id);\n-                        }\n-                        let source_root = SourceRoot { files: file_map };\n-                        db.set_source_root(source_root_id, Arc::new(source_root));\n-                        roots_loaded.insert(source_root_id);\n-                        if roots_loaded.len() == vfs.n_roots() {\n-                            done = true;\n-                        }\n+pub fn load(project_root: &Path, crate_graph: CrateGraph, vfs: &mut Vfs) -> AnalysisHost {\n+    let lru_cap = std::env::var(\"RA_LRU_CAP\").ok().and_then(|it| it.parse::<usize>().ok());\n+    let mut host = AnalysisHost::new(lru_cap);\n+    let mut analysis_change = AnalysisChange::new();\n+    analysis_change.set_crate_graph(crate_graph);\n+\n+    // wait until Vfs has loaded all roots\n+    let receiver = vfs.task_receiver().clone();\n+    let mut roots_loaded = HashSet::new();\n+    for task in receiver {\n+        vfs.handle_task(task);\n+        let mut done = false;\n+        for change in vfs.commit_changes() {\n+            match change {\n+                VfsChange::AddRoot { root, files } => {\n+                    let is_local = vfs.root2path(root).starts_with(&project_root);\n+                    let source_root_id = vfs_root_to_id(root);\n+                    log::debug!(\n+                        \"loaded source root {:?} with path {:?}\",\n+                        source_root_id,\n+                        vfs.root2path(root)\n+                    );\n+                    analysis_change.add_root(source_root_id, is_local);\n+\n+                    let mut file_map = FxHashMap::default();\n+                    for (vfs_file, path, text) in files {\n+                        let file_id = vfs_file_to_id(vfs_file);\n+                        analysis_change.add_file(source_root_id, file_id, path.clone(), text);\n+                        file_map.insert(path, file_id);\n                     }\n-                    VfsChange::AddFile { .. }\n-                    | VfsChange::RemoveFile { .. }\n-                    | VfsChange::ChangeFile { .. } => {\n-                        // We just need the first scan, so just ignore these\n+                    roots_loaded.insert(source_root_id);\n+                    if roots_loaded.len() == vfs.n_roots() {\n+                        done = true;\n                     }\n                 }\n-            }\n-            if done {\n-                break;\n+                VfsChange::AddFile { .. }\n+                | VfsChange::RemoveFile { .. }\n+                | VfsChange::ChangeFile { .. } => {\n+                    // We just need the first scan, so just ignore these\n+                }\n             }\n         }\n-\n-        db\n+        if done {\n+            break;\n+        }\n     }\n \n-    pub fn load_cargo(root: impl AsRef<Path>) -> Result<(BatchDatabase, Vec<SourceRootId>)> {\n-        let root = std::env::current_dir()?.join(root);\n-        let ws = ProjectWorkspace::discover(root.as_ref())?;\n-        let mut roots = Vec::new();\n-        roots.push(IncludeRustFiles::member(root.clone()));\n-        roots.extend(IncludeRustFiles::from_roots(ws.to_roots()));\n-        let (mut vfs, roots) = Vfs::new(roots);\n-        let mut load = |path: &Path| {\n-            let vfs_file = vfs.load(path);\n-            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n-            vfs_file.map(vfs_file_to_id)\n-        };\n-        let crate_graph = ws.to_crate_graph(&mut load);\n-        log::debug!(\"crate graph: {:?}\", crate_graph);\n-\n-        let local_roots = roots\n-            .into_iter()\n-            .filter(|r| vfs.root2path(*r).starts_with(&root))\n-            .map(vfs_root_to_id)\n-            .collect();\n-\n-        let db = BatchDatabase::load(crate_graph, &mut vfs);\n-        Ok((db, local_roots))\n-    }\n+    host.apply_change(analysis_change);\n+    host\n }\n \n #[cfg(test)]\n@@ -128,10 +104,10 @@ mod tests {\n     #[test]\n     fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n-        let (db, roots) = BatchDatabase::load_cargo(path).unwrap();\n+        let (host, roots) = load_cargo(path).unwrap();\n         let mut n_crates = 0;\n         for root in roots {\n-            for _krate in Crate::source_root_crates(&db, root) {\n+            for _krate in Crate::source_root_crates(host.raw_database(), root) {\n                 n_crates += 1;\n             }\n         }"}, {"sha": "d76c37d847ae72f3df2dd0ae1cd936df2bd4e9ed", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -1,24 +1,24 @@\n use std::{collections::HashSet, time::Instant, fmt::Write};\n \n use ra_db::SourceDatabase;\n-use ra_batch::BatchDatabase;\n use ra_hir::{Crate, ModuleDef, Ty, ImplItem, HasSource};\n use ra_syntax::AstNode;\n \n use crate::Result;\n \n pub fn run(verbose: bool, path: &str, only: Option<&str>) -> Result<()> {\n     let db_load_time = Instant::now();\n-    let (db, roots) = BatchDatabase::load_cargo(path)?;\n+    let (host, roots) = ra_batch::load_cargo(path.as_ref())?;\n+    let db = host.raw_database();\n     println!(\"Database loaded, {} roots, {:?}\", roots.len(), db_load_time.elapsed());\n     let analysis_time = Instant::now();\n     let mut num_crates = 0;\n     let mut visited_modules = HashSet::new();\n     let mut visit_queue = Vec::new();\n     for root in roots {\n-        for krate in Crate::source_root_crates(&db, root) {\n+        for krate in Crate::source_root_crates(db, root) {\n             num_crates += 1;\n-            let module = krate.root_module(&db).expect(\"crate in source root without root module\");\n+            let module = krate.root_module(db).expect(\"crate in source root without root module\");\n             visit_queue.push(module);\n         }\n     }\n@@ -27,17 +27,17 @@ pub fn run(verbose: bool, path: &str, only: Option<&str>) -> Result<()> {\n     let mut funcs = Vec::new();\n     while let Some(module) = visit_queue.pop() {\n         if visited_modules.insert(module) {\n-            visit_queue.extend(module.children(&db));\n+            visit_queue.extend(module.children(db));\n \n-            for decl in module.declarations(&db) {\n+            for decl in module.declarations(db) {\n                 num_decls += 1;\n                 if let ModuleDef::Function(f) = decl {\n                     funcs.push(f);\n                 }\n             }\n \n-            for impl_block in module.impl_blocks(&db) {\n-                for item in impl_block.items(&db) {\n+            for impl_block in module.impl_blocks(db) {\n+                for item in impl_block.items(db) {\n                     num_decls += 1;\n                     if let ImplItem::Method(f) = item {\n                         funcs.push(f);\n@@ -61,11 +61,11 @@ pub fn run(verbose: bool, path: &str, only: Option<&str>) -> Result<()> {\n     let mut num_exprs_unknown = 0;\n     let mut num_exprs_partially_unknown = 0;\n     for f in funcs {\n-        let name = f.name(&db);\n+        let name = f.name(db);\n         let mut msg = format!(\"processing: {}\", name);\n         if verbose {\n-            let src = f.source(&db);\n-            let original_file = src.file_id.original_file(&db);\n+            let src = f.source(db);\n+            let original_file = src.file_id.original_file(db);\n             let path = db.file_relative_path(original_file);\n             let syntax_range = src.ast.syntax().range();\n             write!(msg, \" ({:?} {})\", path, syntax_range).unwrap();\n@@ -76,8 +76,8 @@ pub fn run(verbose: bool, path: &str, only: Option<&str>) -> Result<()> {\n                 continue;\n             }\n         }\n-        let body = f.body(&db);\n-        let inference_result = f.infer(&db);\n+        let body = f.body(db);\n+        let inference_result = f.infer(db);\n         for (expr_id, _) in body.exprs() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;"}, {"sha": "a68c5e2a5884932e6f5687cf7ac8f95efbbf6ecd", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -276,6 +276,9 @@ impl AnalysisHost {\n     pub fn collect_garbage(&mut self) {\n         self.db.collect_garbage();\n     }\n+    pub fn raw_database(&self) -> &impl hir::db::HirDatabase {\n+        &self.db\n+    }\n }\n \n /// Analysis is a snapshot of a world state at a moment in time. It is the main"}, {"sha": "4aadb5ea87cb5700781ca3ed8b1d58568a62258a", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "patch": "@@ -17,7 +17,7 @@ fn main() -> Result<()> {\n         Err(_) => ra_prof::Filter::disabled(),\n     });\n     log::info!(\"lifecycle: server started\");\n-    match ::std::panic::catch_unwind(main_inner) {\n+    match std::panic::catch_unwind(main_inner) {\n         Ok(res) => {\n             log::info!(\"lifecycle: terminating process with {:?}\", res);\n             res"}]}