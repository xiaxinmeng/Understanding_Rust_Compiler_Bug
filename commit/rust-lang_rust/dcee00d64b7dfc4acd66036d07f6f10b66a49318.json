{"sha": "dcee00d64b7dfc4acd66036d07f6f10b66a49318", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZWUwMGQ2NGI3ZGZjNGFjZDY2MDM2ZDA3ZjZmMTBiNjZhNDkzMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-27T13:10:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-27T13:10:43Z"}, "message": "Auto merge of #6980 - Jarcho:len_without_is_empty_sig, r=llogiq\n\n`len_without_is_empty` improvements\n\nfixes: #6958\nfixes: #6972\n\nchangelog: Check the return type of `len`. Only integral types, or an `Option` or `Result` wrapping one.\nchangelog: Ensure the return type of `is_empty` matches. e.g. `Option<usize>` -> `Option<bool>`", "tree": {"sha": "36982bed1c24c7a3284438678649f4247decaca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36982bed1c24c7a3284438678649f4247decaca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcee00d64b7dfc4acd66036d07f6f10b66a49318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcee00d64b7dfc4acd66036d07f6f10b66a49318", "html_url": "https://github.com/rust-lang/rust/commit/dcee00d64b7dfc4acd66036d07f6f10b66a49318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcee00d64b7dfc4acd66036d07f6f10b66a49318/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2a6fe84fc811c04b5693531042deb44b077233", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2a6fe84fc811c04b5693531042deb44b077233", "html_url": "https://github.com/rust-lang/rust/commit/6f2a6fe84fc811c04b5693531042deb44b077233"}, {"sha": "12985afbcad28eb67c0b5c5903ff21b6fa922b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/12985afbcad28eb67c0b5c5903ff21b6fa922b13", "html_url": "https://github.com/rust-lang/rust/commit/12985afbcad28eb67c0b5c5903ff21b6fa922b13"}], "stats": {"total": 256, "additions": 231, "deletions": 25}, "files": [{"sha": "fb522be2f1ad1d10d61e82f7e828ebdbb25eb836", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dcee00d64b7dfc4acd66036d07f6f10b66a49318/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcee00d64b7dfc4acd66036d07f6f10b66a49318/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=dcee00d64b7dfc4acd66036d07f6f10b66a49318", "patch": "@@ -10,9 +10,12 @@ use rustc_hir::{\n     ItemKind, Mutability, Node, TraitItemRef, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, AssocKind, FnSig};\n+use rustc_middle::ty::{self, AssocKind, FnSig, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::{Span, Spanned, Symbol};\n+use rustc_span::{\n+    source_map::{Span, Spanned, Symbol},\n+    symbol::sym,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for getting the length of something via `.len()`\n@@ -137,6 +140,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if let Some(local_id) = ty_id.as_local();\n             let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n             if !is_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n+            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.def_id).skip_binder());\n             then {\n                 let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n                     Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n@@ -148,7 +152,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n                     }\n                     _ => return,\n                 };\n-                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, ty_id, name, kind)\n+                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, output, ty_id, name, kind)\n             }\n         }\n     }\n@@ -231,10 +235,62 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n }\n \n+#[derive(Debug, Clone, Copy)]\n+enum LenOutput<'tcx> {\n+    Integral,\n+    Option(DefId),\n+    Result(DefId, Ty<'tcx>),\n+}\n+fn parse_len_output(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n+    match *sig.output().kind() {\n+        ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::option_type, adt.did) => {\n+            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did))\n+        },\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::result_type, adt.did) => subs\n+            .type_at(0)\n+            .is_integral()\n+            .then(|| LenOutput::Result(adt.did, subs.type_at(1))),\n+        _ => None,\n+    }\n+}\n+\n+impl LenOutput<'_> {\n+    fn matches_is_empty_output(self, ty: Ty<'_>) -> bool {\n+        match (self, ty.kind()) {\n+            (_, &ty::Bool) => true,\n+            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did => subs.type_at(0).is_bool(),\n+            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did => {\n+                subs.type_at(0).is_bool() && TyS::same_type(subs.type_at(1), err_ty)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    fn expected_sig(self, self_kind: ImplicitSelfKind) -> String {\n+        let self_ref = match self_kind {\n+            ImplicitSelfKind::ImmRef => \"&\",\n+            ImplicitSelfKind::MutRef => \"&mut \",\n+            _ => \"\",\n+        };\n+        match self {\n+            Self::Integral => format!(\"expected signature: `({}self) -> bool`\", self_ref),\n+            Self::Option(_) => format!(\n+                \"expected signature: `({}self) -> bool` or `({}self) -> Option<bool>\",\n+                self_ref, self_ref\n+            ),\n+            Self::Result(..) => format!(\n+                \"expected signature: `({}self) -> bool` or `({}self) -> Result<bool>\",\n+                self_ref, self_ref\n+            ),\n+        }\n+    }\n+}\n+\n /// Checks if the given signature matches the expectations for `is_empty`\n-fn check_is_empty_sig(cx: &LateContext<'_>, sig: FnSig<'_>, self_kind: ImplicitSelfKind) -> bool {\n+fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if *res == cx.tcx.types.bool => {\n+        [arg, res] if len_output.matches_is_empty_output(res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n@@ -250,6 +306,7 @@ fn check_for_is_empty(\n     cx: &LateContext<'_>,\n     span: Span,\n     self_kind: ImplicitSelfKind,\n+    output: LenOutput<'_>,\n     impl_ty: DefId,\n     item_name: Symbol,\n     item_kind: &str,\n@@ -289,7 +346,7 @@ fn check_for_is_empty(\n         },\n         Some(is_empty)\n             if !(is_empty.fn_has_self_parameter\n-                && check_is_empty_sig(cx, cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind)) =>\n+                && check_is_empty_sig(cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind, output)) =>\n         {\n             (\n                 format!(\n@@ -309,14 +366,7 @@ fn check_for_is_empty(\n             db.span_note(span, \"`is_empty` defined here\");\n         }\n         if let Some(self_kind) = self_kind {\n-            db.note(&format!(\n-                \"expected signature: `({}self) -> bool`\",\n-                match self_kind {\n-                    ImplicitSelfKind::ImmRef => \"&\",\n-                    ImplicitSelfKind::MutRef => \"&mut \",\n-                    _ => \"\",\n-                }\n-            ));\n+            db.note(&output.expected_sig(self_kind));\n         }\n     });\n }"}, {"sha": "b9d66347c27487b9857e99e2be575796273ac6b7", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dcee00d64b7dfc4acd66036d07f6f10b66a49318/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcee00d64b7dfc4acd66036d07f6f10b66a49318/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=dcee00d64b7dfc4acd66036d07f6f10b66a49318", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+\n #![warn(clippy::len_without_is_empty)]\n #![allow(dead_code, unused)]\n \n@@ -172,9 +174,9 @@ pub trait DependsOnFoo: Foo {\n     fn len(&mut self) -> usize;\n }\n \n+// issue #1562\n pub struct MultipleImpls;\n \n-// issue #1562\n impl MultipleImpls {\n     pub fn len(&self) -> usize {\n         1\n@@ -187,4 +189,99 @@ impl MultipleImpls {\n     }\n }\n \n+// issue #6958\n+pub struct OptionalLen;\n+\n+impl OptionalLen {\n+    pub fn len(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    pub fn is_empty(&self) -> Option<bool> {\n+        Some(true)\n+    }\n+}\n+\n+pub struct OptionalLen2;\n+impl OptionalLen2 {\n+    pub fn len(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+pub struct OptionalLen3;\n+impl OptionalLen3 {\n+    pub fn len(&self) -> usize {\n+        0\n+    }\n+\n+    // should lint, len is not an option\n+    pub fn is_empty(&self) -> Option<bool> {\n+        None\n+    }\n+}\n+\n+pub struct ResultLen;\n+impl ResultLen {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    // Differing result types\n+    pub fn is_empty(&self) -> Option<bool> {\n+        Some(true)\n+    }\n+}\n+\n+pub struct ResultLen2;\n+impl ResultLen2 {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    pub fn is_empty(&self) -> Result<bool, ()> {\n+        Ok(true)\n+    }\n+}\n+\n+pub struct ResultLen3;\n+impl ResultLen3 {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    // Non-fallible result is ok.\n+    pub fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+pub struct OddLenSig;\n+impl OddLenSig {\n+    // don't lint\n+    pub fn len(&self) -> bool {\n+        true\n+    }\n+}\n+\n+// issue #6958\n+pub struct AsyncLen;\n+impl AsyncLen {\n+    async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> usize {\n+        if self.async_task().await { 0 } else { 1 }\n+    }\n+\n+    pub async fn is_empty(&self) -> bool {\n+        self.len().await == 0\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ff7f5562308349689239af144071f30e1107d2f3", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dcee00d64b7dfc4acd66036d07f6f10b66a49318/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcee00d64b7dfc4acd66036d07f6f10b66a49318/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=dcee00d64b7dfc4acd66036d07f6f10b66a49318", "patch": "@@ -1,64 +1,123 @@\n error: struct `PubOne` has a public `len` method, but no `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:7:5\n+  --> $DIR/len_without_is_empty.rs:9:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::len-without-is-empty` implied by `-D warnings`\n \n error: trait `PubTraitsToo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:55:1\n+  --> $DIR/len_without_is_empty.rs:57:1\n    |\n LL | / pub trait PubTraitsToo {\n LL | |     fn len(&self) -> isize;\n LL | | }\n    | |_^\n \n error: struct `HasIsEmpty` has a public `len` method, but a private `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:68:5\n+  --> $DIR/len_without_is_empty.rs:70:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:72:5\n+  --> $DIR/len_without_is_empty.rs:74:5\n    |\n LL |     fn is_empty(&self) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: struct `HasWrongIsEmpty` has a public `len` method, but the `is_empty` method has an unexpected signature\n-  --> $DIR/len_without_is_empty.rs:80:5\n+  --> $DIR/len_without_is_empty.rs:82:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:84:5\n+  --> $DIR/len_without_is_empty.rs:86:5\n    |\n LL |     pub fn is_empty(&self, x: u32) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected signature: `(&self) -> bool`\n \n error: struct `MismatchedSelf` has a public `len` method, but the `is_empty` method has an unexpected signature\n-  --> $DIR/len_without_is_empty.rs:92:5\n+  --> $DIR/len_without_is_empty.rs:94:5\n    |\n LL |     pub fn len(self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:96:5\n+  --> $DIR/len_without_is_empty.rs:98:5\n    |\n LL |     pub fn is_empty(&self) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected signature: `(self) -> bool`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:171:1\n+  --> $DIR/len_without_is_empty.rs:173:1\n    |\n LL | / pub trait DependsOnFoo: Foo {\n LL | |     fn len(&mut self) -> usize;\n LL | | }\n    | |_^\n \n-error: aborting due to 6 previous errors\n+error: struct `OptionalLen3` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:218:5\n+   |\n+LL |     pub fn len(&self) -> usize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:223:5\n+   |\n+LL |     pub fn is_empty(&self) -> Option<bool> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool`\n+\n+error: struct `ResultLen` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:230:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:235:5\n+   |\n+LL |     pub fn is_empty(&self) -> Option<bool> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool` or `(&self) -> Result<bool>\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/len_without_is_empty.rs:230:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::result-unit-err` implied by `-D warnings`\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/len_without_is_empty.rs:242:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/len_without_is_empty.rs:246:5\n+   |\n+LL |     pub fn is_empty(&self) -> Result<bool, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/len_without_is_empty.rs:253:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: aborting due to 12 previous errors\n "}]}