{"sha": "3250837f4be3046b5634acc0405d30c2cf23bc63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNTA4MzdmNGJlMzA0NmI1NjM0YWNjMDQwNWQzMGMyY2YyM2JjNjM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-10T04:22:06Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-10T04:22:06Z"}, "message": "report: Add \"Flaws\" and \"Current implementation\".", "tree": {"sha": "1da3f707633b4d8e4c47cb3c8bea9220dcc487dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1da3f707633b4d8e4c47cb3c8bea9220dcc487dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3250837f4be3046b5634acc0405d30c2cf23bc63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3250837f4be3046b5634acc0405d30c2cf23bc63", "html_url": "https://github.com/rust-lang/rust/commit/3250837f4be3046b5634acc0405d30c2cf23bc63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3250837f4be3046b5634acc0405d30c2cf23bc63/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998fcb82c583b76fd5a3c65a35abc1c71981e838", "url": "https://api.github.com/repos/rust-lang/rust/commits/998fcb82c583b76fd5a3c65a35abc1c71981e838", "html_url": "https://github.com/rust-lang/rust/commit/998fcb82c583b76fd5a3c65a35abc1c71981e838"}], "stats": {"total": 130, "additions": 118, "deletions": 12}, "files": [{"sha": "3ea16e0ee3cc05e67f587bacacf7177f80ef10b5", "filename": "tex/paper/miri.tex", "status": "modified", "additions": 118, "deletions": 12, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3250837f4be3046b5634acc0405d30c2cf23bc63/tex%2Fpaper%2Fmiri.tex", "raw_url": "https://github.com/rust-lang/rust/raw/3250837f4be3046b5634acc0405d30c2cf23bc63/tex%2Fpaper%2Fmiri.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Fpaper%2Fmiri.tex?ref=3250837f4be3046b5634acc0405d30c2cf23bc63", "patch": "@@ -123,20 +123,126 @@ \\subsection{Function calls}\n \n \\subsection{Flaws}\n \n-% TODO(tsion): Incorporate this text from the slides.\n-% At first I wrote a naive version with a number of downsides:\n-%  * I represented values in a traditional dynamic language format,\n-% where every value was the same size.\n-%  * I didn\u2019t work well for aggregates (structs, enums, arrays, etc.).\n-%  *I made unsafe programming tricks that make assumptions\n-% about low-level value layout essentially impossible\n+This version of Miri was surprisingly easy to write and already supported quite a bit of the Rust\n+language, including booleans, integers, if-conditions, while-loops, structs, enums, arrays, tuples,\n+pointers, and function calls, all in about 400 lines of Rust code. However, it had a particularly\n+naive value representation with a number of downsides. It resembled the data layout of a dynamic\n+language like Ruby or Python, where every value has the same size\\footnote{A Rust \\rust{enum} is a\n+discriminated union with a tag and data the size of the largest variant, regardless of which variant\n+it contains.} in the interpreter:\n+\n+\\begin{minted}[autogobble]{rust}\n+  enum Value {\n+      Uninitialized,\n+      Bool(bool),\n+      Int(i64),\n+      Pointer(Pointer), // index into stack\n+      Adt { variant: usize, data_ptr: Pointer },\n+      // ...\n+  }\n+\\end{minted}\n+\n+This representation did not work well for \\rust{Adt}s\\footnote{Algebraic data types: structs, enums,\n+arrays, and tuples.} and required strange hacks to support them. Their contained values were\n+allocated elsewhere on the stack and pointed to by the \\rust{Adt} value. When it came to copying\n+\\rust{Adt} values from place to place, this made it more complicated.\n+\n+Moreover, while the \\rust{Adt} issues could be worked around, this value representation made common\n+\\rust{unsafe} programming tricks (which make assumptions about the low-level value layout)\n+fundamentally impossible.\n+\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\section{Current implementation}\n+\n+Roughly halfway through my time working on Miri, Rust compiler team member Eduard\n+Burtescu\\footnote{\\href{https://www.rust-lang.org/team.html\\#Compiler}{The Rust compiler team}} made\n+a post on Rust's internal\n+forums\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n+``Rust Abstract Machine'' forum post}} about a ``Rust Abstract Machine'' specification which could\n+be used to implement more powerful compile-time function execution, similar to what is supported by\n+C++14's \\mintinline{cpp}{constexpr} feature. After clarifying some of the details of the abstract\n+machine's data layout with Burtescu via IRC, I started implementing it in Miri.\n+\n+\\subsection{Raw value representation}\n+\n+The main difference in the new value representation was to represent values by ``abstract\n+allocations'' containing arrays of raw bytes with different sizes depending on the types of the\n+values. This closely mimics how Rust values are represented when compiled for traditional machines.\n+In addition to the raw bytes, allocations carry information about pointers and undefined bytes.\n+\n+\\begin{minted}[autogobble]{rust}\n+  struct Memory {\n+      map: HashMap<AllocId, Allocation>,\n+      next_id: AllocId,\n+  }\n+\n+  struct Allocation {\n+      bytes: Vec<u8>,\n+      relocations: BTreeMap<usize, AllocId>,\n+      undef_mask: UndefMask,\n+  }\n+\\end{minted}\n+\n+\\subsubsection{Relocations}\n+\n+The abstract machine represents pointers through ``relocations'', which are analogous to relocations\n+in linkers\\footnote{\\href{https://en.wikipedia.org/wiki/Relocation_(computing)}{Relocation\n+(computing) - Wikipedia}}. Instead of storing a global memory address in the raw byte representation\n+like a traditional machine, we store an offset from the start of the target allocation and add an\n+entry to the relocation table. The entry maps the index of the start of the offset bytes to the\n+\\rust{AllocId} of the target allocation.\n+\n+\\begin{figure}[ht]\n+  \\begin{minted}[autogobble]{rust}\n+    let a: [i16; 3] = [2, 4, 6];\n+    let b = &a[1];\n+    // A: 02 00 04 00 06 00 (6 bytes)\n+    // B: 02 00 00 00 (4 bytes)\n+    //    \u2514\u2500\u2500\u2500(A)\u2500\u2500\u2500\u2518\n+  \\end{minted}\n+  \\caption{Example relocation on 32-bit little-endian}\n+  \\label{fig:reloc}\n+\\end{figure}\n+\n+In effect, the abstract machine treats each allocation as a separate address space and represents\n+pointers as \\rust{(address_space, offset)} pairs. This makes it easy to detect when pointer accesses\n+go out of bounds.\n+\n+See \\autoref{fig:reloc} for an example of a relocation. Variable \\rust{b} points to the second\n+16-bit integer in \\rust{a}, so it contains a relocation with offset 2 and target allocation\n+\\rust{A}.\n+\n+\\subsubsection{Undefined byte mask}\n+\n+The final piece of an abstract allocation is the undefined byte mask. Logically, we store a boolean\n+for the definedness of every byte in the allocation, but there are multiple ways to make the storage\n+more compact. I tried two implementations: one based on the endpoints of alternating ranges of\n+defined and undefined bytes and the other based on a simple bitmask. The former is more compact but\n+I found it surprisingly difficult to update cleanly. I currently use the bitmask system, which is\n+comparatively trivial.\n+\n+See \\autoref{fig:undef} for an example undefined byte, represented by underscores. Note that there\n+would still be a value for the second byte in the byte array, but we don't care what it is. The\n+bitmask would be $10_2$ i.e. \\rust{[true, false]}.\n+\n+\\begin{figure}[hb]\n+  \\begin{minted}[autogobble]{rust}\n+    let a: [u8; 2] = unsafe {\n+        [1, std::mem::uninitialized()]\n+    };\n+    // A: 01 __ (2 bytes)\n+  \\end{minted}\n+  \\caption{Example undefined byte}\n+  \\label{fig:undef}\n+\\end{figure}\n \n % TODO(tsion): Find a place for this text.\n-Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n-of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n-unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n-simulating execution of unsafe code, which allows it to detect when unsafe code does something\n-invalid.\n+% Making Miri work was primarily an implementation problem. Writing an interpreter which models values\n+% of varying sizes, stack and heap allocation, unsafe memory operations, and more requires some\n+% unconventional techniques compared to many interpreters. Miri's execution remains safe even while\n+% simulating execution of unsafe code, which allows it to detect when unsafe code does something\n+% invalid.\n \n \\blindtext\n "}]}