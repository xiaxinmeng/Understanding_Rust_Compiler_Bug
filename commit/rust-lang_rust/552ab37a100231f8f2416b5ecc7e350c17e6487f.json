{"sha": "552ab37a100231f8f2416b5ecc7e350c17e6487f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MmFiMzdhMTAwMjMxZjhmMjQxNmI1ZWNjN2UzNTBjMTdlNjQ4N2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-20T13:11:07Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: replace method_map with Def::Method and node_substs entries.", "tree": {"sha": "013fe2efb07f5f00e0b8066ff23c0e8918e859c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/013fe2efb07f5f00e0b8066ff23c0e8918e859c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/552ab37a100231f8f2416b5ecc7e350c17e6487f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/552ab37a100231f8f2416b5ecc7e350c17e6487f", "html_url": "https://github.com/rust-lang/rust/commit/552ab37a100231f8f2416b5ecc7e350c17e6487f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/552ab37a100231f8f2416b5ecc7e350c17e6487f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "html_url": "https://github.com/rust-lang/rust/commit/9eae6ba7fad883300c83d77782ae78b0db6f3bb7"}], "stats": {"total": 239, "additions": 120, "deletions": 119}, "files": [{"sha": "85b1858c875bc0eae8b513d285daac10e6d9fab1", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -355,11 +355,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n "}, {"sha": "e607a6bf74a60b6d721b9c81768b37f78aeb6892", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -598,11 +598,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n-            ref type_relative_path_defs,\n+            ref type_dependent_defs,\n             ref node_types,\n             ref node_substs,\n             ref adjustments,\n-            ref method_map,\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n@@ -619,11 +618,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_nodemap(hcx, hasher, type_relative_path_defs);\n+            ich::hash_stable_nodemap(hcx, hasher, type_dependent_defs);\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n             ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n-            ich::hash_stable_nodemap(hcx, hasher, method_map);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "6077b7863e2c3d034a59f8548df12fb21e9d8208", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n-        self.check_def_id(self.tables.method_map[&id].def_id);\n+        self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {"}, {"sha": "74e1225f3948b92e9ab52e93f016ba48271a3d9e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -173,8 +173,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let method = self.tables.method_map[&expr.id];\n-                let base_type = self.tcx.type_of(method.def_id);\n+                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let base_type = self.tcx.type_of(def_id);\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "340a929331ffacb8c04cb4943dc06d7156ab3851", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -563,8 +563,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let method = self.mc.infcx.tables.borrow().method_map[&call.id];\n-                match OverloadedCallType::from_method_id(self.tcx(), method.def_id) {\n+                let def_id = self.mc.infcx.tables.borrow().type_dependent_defs[&call.id].def_id();\n+                match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n@@ -849,7 +849,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                 pass_args: PassArgs)\n                                 -> bool\n     {\n-        if !self.mc.infcx.tables.borrow().is_method_call(expr.id) {\n+        if !self.mc.infcx.tables.borrow().is_method_call(expr) {\n             return false;\n         }\n "}, {"sha": "c6a42be6135ccbfb8995eb37cd8509bf0ef2491f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.tables.is_method_call(expr.id) {\n+            if self.tables.is_method_call(expr) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1366,7 +1366,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.tables.is_method_call(expr.id) {\n+        if !this.tables.is_method_call(expr) {\n             this.check_lvalue(&l);\n         }\n "}, {"sha": "f971700b2c86ce3fd8bc656ff78099d3105fa4b3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            if self.infcx.tables.borrow().is_method_call(expr.id) {\n+            if self.infcx.tables.borrow().is_method_call(expr) {\n                 self.cat_overloaded_lvalue(expr, e_base, false)\n             } else {\n                 let base_cmt = self.cat_expr(&e_base)?;\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            if self.infcx.tables.borrow().is_method_call(expr.id()) {\n+            if self.infcx.tables.borrow().is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n                 // will include an implicit deref of the result.\n                 // The call to index() returns a `&T` value, which"}, {"sha": "c2f69147e3a563c64e0c87794debfdf7d1ff20b6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -110,8 +110,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                 Some(self.tables.qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.method_map[&expr.id].def_id;\n-                Some(Def::Method(def_id))\n+                Some(self.tables.type_dependent_defs[&expr.id])\n             }\n             _ => None\n         };"}, {"sha": "f0cee2fe2b1caf4464b1add544abe14bf3cf07f0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -206,8 +206,9 @@ pub struct CommonTypes<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n-    /// Resolved definitions for `<T>::X` associated paths.\n-    pub type_relative_path_defs: NodeMap<Def>,\n+    /// Resolved definitions for `<T>::X` associated paths and\n+    /// method calls, including those of overloaded operators.\n+    pub type_dependent_defs: NodeMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n@@ -222,8 +223,6 @@ pub struct TypeckTables<'tcx> {\n \n     pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n-    pub method_map: NodeMap<ty::MethodCallee<'tcx>>,\n-\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n@@ -271,11 +270,10 @@ pub struct TypeckTables<'tcx> {\n impl<'tcx> TypeckTables<'tcx> {\n     pub fn empty() -> TypeckTables<'tcx> {\n         TypeckTables {\n-            type_relative_path_defs: NodeMap(),\n+            type_dependent_defs: NodeMap(),\n             node_types: FxHashMap(),\n             node_substs: NodeMap(),\n             adjustments: NodeMap(),\n-            method_map: FxHashMap(),\n             upvar_capture_map: FxHashMap(),\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),\n@@ -294,7 +292,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.type_relative_path_defs.get(&id).cloned().unwrap_or(Def::Err)\n+                self.type_dependent_defs.get(&id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n@@ -357,8 +355,17 @@ impl<'tcx> TypeckTables<'tcx> {\n             .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n     }\n \n-    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n-        self.method_map.contains_key(&expr_id)\n+    pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n+        // Only paths and method calls/overloaded operators have\n+        // entries in type_dependent_defs, ignore the former here.\n+        if let hir::ExprPath(_) = expr.node {\n+            return false;\n+        }\n+\n+        match self.type_dependent_defs.get(&expr.id) {\n+            Some(&Def::Method(_)) => true,\n+            _ => false\n+        }\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {"}, {"sha": "76132cab2cd0f340cbb14f366ccfc7a5ae5800d8", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -141,8 +141,6 @@ pub enum TypeVariants<'tcx> {\n     TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n-    /// FIXME: This is currently also used to represent the callee of a method;\n-    /// see ty::MethodCallee etc.\n     TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`."}, {"sha": "04645214ce83ef5b06191159cc7693e3c8ce0e74", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -881,17 +881,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                                       -> bool {\n             use rustc::ty::adjustment::*;\n \n-            // Check for method calls and overloaded operators.\n-            if let Some(m) = cx.tables.method_map.get(&id).cloned() {\n-                if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n-                    return true;\n-                }\n-            }\n+            // Ignore non-expressions.\n+            let expr = if let hir_map::NodeExpr(e) = cx.tcx.hir.get(id) {\n+                e\n+            } else {\n+                return false;\n+            };\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(Adjustment {\n+            if let Some(&Adjustment {\n                 kind: Adjust::DerefRef { ref autoderefs, .. }, ..\n-            }) = cx.tables.adjustments.get(&id).cloned() {\n+            }) = cx.tables.adjustments.get(&id) {\n                 for &overloaded in autoderefs {\n                     if let Some(m) = overloaded {\n                         if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n@@ -901,9 +901,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 }\n             }\n \n+            // Check for method calls and overloaded operators.\n+            if cx.tables.is_method_call(expr) {\n+                let def_id = cx.tables.type_dependent_defs[&id].def_id();\n+                let substs = cx.tables.node_substs(id);\n+                if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                    return true;\n+                }\n+            }\n+\n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n+            match expr.node {\n+                hir::ExprCall(ref callee, _) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.id)\n                     } else {"}, {"sha": "cd540f309b0c2c4068dcecdbb7696b485b225c52", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         overloaded_lvalue(cx,\n                                           self,\n                                           mt.ty,\n-                                          method,\n+                                          Some(method),\n                                           PassArgs::ByRef,\n                                           expr.to_ref(),\n                                           vec![])\n@@ -244,8 +244,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // Here comes the interesting stuff:\n         hir::ExprMethodCall(.., ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-            let method = cx.tables().method_map[&expr.id];\n-            let expr = method_callee(cx, expr, method);\n+            let expr = method_callee(cx, expr, None);\n             let args = args.iter()\n                 .map(|e| e.to_ref())\n                 .collect();\n@@ -257,15 +256,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n                 // callee-object as expr parameter.\n \n                 // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n-                let method = method_callee(cx, expr, method);\n+                let method = method_callee(cx, expr, None);\n \n                 let arg_tys = args.iter().map(|e| cx.tables().expr_ty_adjusted(e));\n                 let tupled_args = Expr {\n@@ -346,15 +345,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n                 };\n                 overloaded_operator(cx,\n                                     expr,\n-                                    method,\n+                                    None,\n                                     pass_args,\n                                     lhs.to_ref(),\n                                     vec![rhs])\n@@ -370,15 +369,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n                 };\n                 overloaded_operator(cx,\n                                     expr,\n-                                    method,\n+                                    None,\n                                     pass_args,\n                                     lhs.to_ref(),\n                                     vec![rhs])\n@@ -430,11 +429,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   expr_ty,\n-                                  method,\n+                                  None,\n                                   PassArgs::ByValue,\n                                   lhs.to_ref(),\n                                   vec![index])\n@@ -447,11 +446,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   expr_ty,\n-                                  method,\n+                                  None,\n                                   PassArgs::ByValue,\n                                   arg.to_ref(),\n                                   vec![])\n@@ -461,10 +460,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx,\n                                     expr,\n-                                    method,\n+                                    None,\n                                     PassArgs::ByValue,\n                                     arg.to_ref(),\n                                     vec![])\n@@ -477,10 +476,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx,\n                                     expr,\n-                                    method,\n+                                    None,\n                                     PassArgs::ByValue,\n                                     arg.to_ref(),\n                                     vec![])\n@@ -699,17 +698,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n-                                 callee: ty::MethodCallee<'tcx>)\n+                                 custom_callee: Option<ty::MethodCallee<'tcx>>)\n                                  -> Expr<'tcx> {\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let (def_id, substs) = custom_callee.map(|m| (m.def_id, m.substs)).unwrap_or_else(|| {\n+        (cx.tables().type_dependent_defs[&expr.id].def_id(),\n+         cx.tables().node_substs(expr.id))\n+    });\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n-        ty: cx.tcx.type_of(callee.def_id).subst(cx.tcx, callee.substs),\n+        ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(callee.def_id, callee.substs),\n+                value: ConstVal::Function(def_id, substs),\n             },\n         },\n     }\n@@ -942,7 +945,7 @@ enum PassArgs {\n \n fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                        expr: &'tcx hir::Expr,\n-                                       method: ty::MethodCallee<'tcx>,\n+                                       custom_callee: Option<ty::MethodCallee<'tcx>>,\n                                        pass_args: PassArgs,\n                                        receiver: ExprRef<'tcx>,\n                                        args: Vec<&'tcx P<hir::Expr>>)\n@@ -985,7 +988,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n \n     // now create the call itself\n-    let fun = method_callee(cx, expr, method);\n+    let fun = method_callee(cx, expr, custom_callee);\n     ExprKind::Call {\n         ty: fun.ty,\n         fun: fun.to_ref(),\n@@ -996,7 +999,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      lvalue_ty: Ty<'tcx>,\n-                                     method: ty::MethodCallee<'tcx>,\n+                                     custom_callee: Option<ty::MethodCallee<'tcx>>,\n                                      pass_args: PassArgs,\n                                      receiver: ExprRef<'tcx>,\n                                      args: Vec<&'tcx P<hir::Expr>>)\n@@ -1025,7 +1028,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n-    let ref_kind = overloaded_operator(cx, expr, method, pass_args, receiver, args);\n+    let ref_kind = overloaded_operator(cx, expr, custom_callee, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,"}, {"sha": "f73ae9d42f619a055e60e2748ff3b26b19c3f7ea", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -283,7 +283,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tables.method_map.contains_key(&e.id) => {\n+        hir::ExprIndex(..) if v.tables.is_method_call(e) => {\n             v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n@@ -380,9 +380,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tables.method_map[&e.id];\n-            match v.tcx.associated_item(method.def_id).container {\n-                ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n+            let def_id = v.tables.type_dependent_defs[&e.id].def_id();\n+            match v.tcx.associated_item(def_id).container {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n             }\n         }"}, {"sha": "b4d74cfb1608425410506352de5a2b2f60ce3972", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -564,7 +564,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_id = self.tables.method_map[&expr.id].def_id;\n+                let method_id = self.tables.type_dependent_defs[&expr.id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "f8560550da49dba04a5b5d649d29d7c0a3a32cfd", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.tables.borrow_mut().method_map.insert(call_expr.id, method_callee);\n+        self.write_method_call(call_expr.id, method_callee);\n         output_type\n     }\n }\n@@ -363,7 +363,7 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                     target: method_sig.inputs()[0]\n                 });\n \n-                fcx.tables.borrow_mut().method_map.insert(self.call_expr.id, method_callee);\n+                fcx.write_method_call(self.call_expr.id, method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "52ed664799448186b882422cced827066ed7ec17", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n                op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().method_map.contains_key(&expr.id) {\n+        if !self.tables.borrow().is_method_call(expr) {\n             debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n             return\n         }\n@@ -497,7 +497,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         };\n         let (_, method) = self.register_infer_ok_obligations(ok);\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.tables.borrow_mut().method_map.insert(expr.id, method);\n+        self.write_method_call(expr.id, method);\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability."}, {"sha": "df5023fb7a68aca6394b063c17b0b5dbde15a3bc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -1758,6 +1758,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn write_method_call(&self, node_id: ast::NodeId, method: ty::MethodCallee<'tcx>) {\n+        self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n+        self.write_substs(node_id, method.substs);\n+    }\n+\n     pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n         if !substs.is_noop() {\n             debug!(\"write_substs({}, {:?}) in fcx {}\",\n@@ -2238,7 +2243,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     target: method.sig.inputs()[0]\n                 });\n \n-                self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                self.write_method_call(expr.id, method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n             });\n             if result.is_some() {\n@@ -2777,7 +2782,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n-                self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                self.write_method_call(expr.id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n@@ -3453,7 +3458,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 target: method.sig.inputs()[0]\n                             });\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                            self.write_method_call(expr.id, method);\n                         } else {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\\n@@ -3918,7 +3923,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n-    // The newly resolved definition is written into `type_relative_path_defs`.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,\n                                     qpath: &hir::QPath,\n                                     path_span: Span,\n@@ -3943,15 +3948,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+                self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n \n                 (def, ty)\n             }\n         }\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n-    // The newly resolved definition is written into `type_relative_path_defs`.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n                                        qpath: &'b hir::QPath,\n                                        node_id: ast::NodeId,\n@@ -3984,7 +3989,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+        self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n "}, {"sha": "0c820d2404a50ff3747098caf20a7b7d405ec119", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     },\n                     target: method.sig.inputs()[0]\n                 });\n-                self.tables.borrow_mut().method_map.insert(expr.id, method);\n+                self.write_method_call(expr.id, method);\n \n                 Ok(method.sig.output())\n             }"}, {"sha": "e1451139d6efcfaf02e1f2882e5738985e2f6771", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -520,14 +520,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n-        let opt_method_callee = self.tables.borrow().method_map.get(&expr.id).cloned();\n-        let has_method_map = opt_method_callee.is_some();\n+        let is_method_call = self.tables.borrow().is_method_call(expr);\n \n         // If we are calling a method (either explicitly or via an\n         // overloaded operator), check that all of the types provided as\n         // arguments for its type parameters are well-formed, and all the regions\n         // provided as arguments outlive the call.\n-        if let Some(callee) = opt_method_callee {\n+        if is_method_call {\n             let origin = match expr.node {\n                 hir::ExprMethodCall(..) =>\n                     infer::ParameterOrigin::MethodCall,\n@@ -537,7 +536,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     infer::ParameterOrigin::OverloadedOperator\n             };\n \n-            self.substs_wf_in_scope(origin, &callee.substs, expr.span, expr_region);\n+            let substs = self.tables.borrow().node_substs(expr.id);\n+            self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n \n@@ -614,7 +614,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprCall(ref callee, ref args) => {\n-                if has_method_map {\n+                if is_method_call {\n                     self.constrain_call(expr, Some(&callee),\n                                         args.iter().map(|e| &*e), false);\n                 } else {\n@@ -634,22 +634,22 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n-                if has_method_map {\n+                if is_method_call {\n                     self.constrain_call(expr, Some(&lhs),\n                                         Some(&**rhs).into_iter(), false);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n+            hir::ExprIndex(ref lhs, ref rhs) if is_method_call => {\n                 self.constrain_call(expr, Some(&lhs),\n                                     Some(&**rhs).into_iter(), true);\n \n                 intravisit::walk_expr(self, expr);\n             },\n \n-            hir::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n+            hir::ExprBinary(op, ref lhs, ref rhs) if is_method_call => {\n                 let implicitly_ref_args = !op.node.is_by_value();\n \n                 // As `expr_method_call`, but the call is via an\n@@ -674,7 +674,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(op, ref lhs) if has_method_map => {\n+            hir::ExprUnary(op, ref lhs) if is_method_call => {\n                 let implicitly_ref_args = !op.is_by_value();\n \n                 // As above.\n@@ -686,7 +686,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n-                if self.tables.borrow().is_method_call(expr.id) {\n+                if self.tables.borrow().is_method_call(expr) {\n                     self.constrain_call(expr, Some(base),\n                                         None::<hir::Expr>.iter(), true);\n                 }"}, {"sha": "4db0475a18b24e92602d2920a3e02c1472f659a9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552ab37a100231f8f2416b5ecc7e350c17e6487f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=552ab37a100231f8f2416b5ecc7e350c17e6487f", "patch": "@@ -106,7 +106,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&e.id);\n+                    let mut tables = self.fcx.tables.borrow_mut();\n+                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.node_substs.remove(&e.id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n@@ -118,7 +120,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&e.id);\n+                    let mut tables = self.fcx.tables.borrow_mut();\n+                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.node_substs.remove(&e.id);\n \n                     // weird but true: the by-ref binops put an\n                     // adjustment on the lhs but not the rhs; the\n@@ -127,11 +131,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                                tables.adjustments.remove(&lhs.id);\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                            tables.adjustments.remove(&lhs.id);\n                         },\n                         _ => {},\n                     }\n@@ -164,7 +168,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(e.span, e.id);\n-        self.visit_method_map_entry(e.span, e.id);\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n@@ -280,9 +283,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n-        // Export associated path extensions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&node_id) {\n-            self.tables.type_relative_path_defs.insert(node_id, def);\n+        // Export associated path extensions and method resultions.\n+        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs.remove(&node_id) {\n+            self.tables.type_dependent_defs.insert(node_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n@@ -358,27 +361,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_method_map_entry(&mut self,\n-                              method_span: Span,\n-                              node_id: ast::NodeId) {\n-        // Resolve any method map entry\n-        let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&node_id) {\n-            Some(method) => {\n-                Some(MethodCallee {\n-                    def_id: method.def_id,\n-                    substs: self.resolve(&method.substs, &method_span),\n-                    sig: self.resolve(&method.sig, &method_span),\n-                })\n-            }\n-            None => None\n-        };\n-\n-        //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n-        if let Some(method) = new_method {\n-            self.tables.method_map.insert(node_id, method);\n-        }\n-    }\n-\n     fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, &node_id);"}]}