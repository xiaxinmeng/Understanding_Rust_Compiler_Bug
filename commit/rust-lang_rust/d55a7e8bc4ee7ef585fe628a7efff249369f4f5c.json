{"sha": "d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NWE3ZThiYzRlZTdlZjU4NWZlNjI4YTdlZmZmMjQ5MzY5ZjRmNWM=", "commit": {"author": {"name": "Johannes Oertel", "email": "johannes.oertel@uni-due.de", "date": "2015-04-27T15:44:42Z"}, "committer": {"name": "Johannes Oertel", "email": "johannes.oertel@uni-due.de", "date": "2015-05-06T07:29:07Z"}, "message": "Implement append and split_off for BitVec (RFC 509)", "tree": {"sha": "e9435737532c27d0ae0f2e4253226822fc5ae0b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9435737532c27d0ae0f2e4253226822fc5ae0b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "html_url": "https://github.com/rust-lang/rust/commit/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/comments", "author": {"login": "jooert", "id": 1774713, "node_id": "MDQ6VXNlcjE3NzQ3MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1774713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jooert", "html_url": "https://github.com/jooert", "followers_url": "https://api.github.com/users/jooert/followers", "following_url": "https://api.github.com/users/jooert/following{/other_user}", "gists_url": "https://api.github.com/users/jooert/gists{/gist_id}", "starred_url": "https://api.github.com/users/jooert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jooert/subscriptions", "organizations_url": "https://api.github.com/users/jooert/orgs", "repos_url": "https://api.github.com/users/jooert/repos", "events_url": "https://api.github.com/users/jooert/events{/privacy}", "received_events_url": "https://api.github.com/users/jooert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jooert", "id": 1774713, "node_id": "MDQ6VXNlcjE3NzQ3MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1774713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jooert", "html_url": "https://github.com/jooert", "followers_url": "https://api.github.com/users/jooert/followers", "following_url": "https://api.github.com/users/jooert/following{/other_user}", "gists_url": "https://api.github.com/users/jooert/gists{/gist_id}", "starred_url": "https://api.github.com/users/jooert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jooert/subscriptions", "organizations_url": "https://api.github.com/users/jooert/orgs", "repos_url": "https://api.github.com/users/jooert/repos", "events_url": "https://api.github.com/users/jooert/events{/privacy}", "received_events_url": "https://api.github.com/users/jooert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0100ce84698dde68a25f05aa4271d84f547c50c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0100ce84698dde68a25f05aa4271d84f547c50c", "html_url": "https://github.com/rust-lang/rust/commit/c0100ce84698dde68a25f05aa4271d84f547c50c"}], "stats": {"total": 237, "additions": 237, "deletions": 0}, "files": [{"sha": "1271a6276aec910bc7761b747a9a51e0ca06cc85", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "patch": "@@ -89,6 +89,7 @@ use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n use core::iter::{self, FromIterator};\n+use core::mem::swap;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};\n@@ -602,6 +603,106 @@ impl BitVec {\n         Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n+    /// Moves all bits from `other` into `Self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// use std::collections::BitVec;\n+    ///\n+    /// let mut a = BitVec::from_bytes(&[0b10000000]);\n+    /// let mut b = BitVec::from_bytes(&[0b01100001]);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 16);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert!(a.eq_vec(&[true, false, false, false, false, false, false, false,\n+    ///                    false, true, true, false, false, false, false, true]));\n+    /// ```\n+    #[unstable(feature = \"bit_vec_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        let b = self.len() % u32::BITS;\n+\n+        self.nbits += other.len();\n+        other.nbits = 0;\n+\n+        if b == 0 {\n+            self.storage.append(&mut other.storage);\n+        } else {\n+            self.storage.reserve(other.storage.len());\n+\n+            for block in other.storage.drain(..) {\n+                *(self.storage.last_mut().unwrap()) |= block << b;\n+                self.storage.push(block >> (u32::BITS - b));\n+            }\n+        }\n+    }\n+\n+    /// Splits the `BitVec` into two at the given bit,\n+    /// retaining the first half in-place and returning the second one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// use std::collections::BitVec;\n+    /// let mut a = BitVec::new();\n+    /// a.push(true);\n+    /// a.push(false);\n+    /// a.push(false);\n+    /// a.push(true);\n+    ///\n+    /// let b = a.split_off(2);\n+    ///\n+    /// assert_eq!(a.len(), 2);\n+    /// assert_eq!(b.len(), 2);\n+    /// assert!(a.eq_vec(&[true, false]));\n+    /// assert!(b.eq_vec(&[false, true]));\n+    /// ```\n+    #[unstable(feature = \"bit_vec_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        assert!(at <= self.len(), \"`at` out of bounds\");\n+\n+        let mut other = BitVec::new();\n+\n+        if at == 0 {\n+            swap(self, &mut other);\n+            return other;\n+        } else if at == self.len() {\n+            return other;\n+        }\n+\n+        let w = at / u32::BITS;\n+        let b = at % u32::BITS;\n+        other.nbits = self.nbits - at;\n+        self.nbits = at;\n+        if b == 0 {\n+            // Split at block boundary\n+            other.storage = self.storage.split_off(w);\n+        } else {\n+            other.storage.reserve(self.storage.len() - w);\n+\n+            {\n+                let mut iter = self.storage[w..].iter();\n+                let mut last = *iter.next().unwrap();\n+                for &cur in iter {\n+                    other.storage.push((last >> b) | (cur << (u32::BITS - b)));\n+                    last = cur;\n+                }\n+                other.storage.push(last >> b);\n+            }\n+\n+            self.storage.truncate(w+1);\n+            self.fix_last_block();\n+        }\n+\n+        other\n+    }\n+\n     /// Returns `true` if all bits are 0.\n     ///\n     /// # Examples"}, {"sha": "a1d2eed0a8b5f13089c7923193a2fbdd2ca4d272", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "patch": "@@ -630,6 +630,141 @@ fn test_bit_vec_extend() {\n                                  0b01001001, 0b10010010, 0b10111101]));\n }\n \n+#[test]\n+fn test_bit_vec_append() {\n+    // Append to BitVec that holds a multiple of u32::BITS bits\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011]);\n+    let mut b = BitVec::new();\n+    b.push(false);\n+    b.push(true);\n+    b.push(true);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 35);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 3);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       false, true, true]));\n+\n+    // Append to arbitrary BitVec\n+    let mut a = BitVec::new();\n+    a.push(true);\n+    a.push(false);\n+\n+    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 42);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 40);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, true, false, false, false,\n+                       false, false, false, false, false, true, false, false,\n+                       true, false, true, false, false, true, false, false,\n+                       true, false, false, false, true, true, false, false,\n+                       true, true, true, false, false, true, false, true,\n+                       false, true]));\n+\n+    // Append to empty BitVec\n+    let mut a = BitVec::new();\n+    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 40);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 40);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       true, false, false, true, false, true, false, true]));\n+\n+    // Append empty BitVec\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+    let mut b = BitVec::new();\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 40);\n+    assert_eq!(b.len(), 0);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       true, false, false, true, false, true, false, true]));\n+}\n+\n+#[test]\n+fn test_bit_vec_split_off() {\n+    // Split at 0\n+    let mut a = BitVec::new();\n+    a.push(true);\n+    a.push(false);\n+    a.push(false);\n+    a.push(true);\n+\n+    let b = a.split_off(0);\n+\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(b.len(), 4);\n+\n+    assert!(b.eq_vec(&[true, false, false, true]));\n+\n+    // Split at last bit\n+    a.truncate(0);\n+    a.push(true);\n+    a.push(false);\n+    a.push(false);\n+    a.push(true);\n+\n+    let b = a.split_off(4);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(b.len(), 0);\n+\n+    assert!(a.eq_vec(&[true, false, false, true]));\n+\n+    // Split at block boundary\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b11110011]);\n+\n+    let b = a.split_off(32);\n+\n+    assert_eq!(a.len(), 32);\n+    assert_eq!(b.len(), 8);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true]));\n+    assert!(b.eq_vec(&[true, true, true, true, false, false, true, true]));\n+\n+    // Don't split at block boundary\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011,\n+                                     0b01101011, 0b10101101]);\n+\n+    let b = a.split_off(13);\n+\n+    assert_eq!(a.len(), 13);\n+    assert_eq!(b.len(), 35);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false]));\n+    assert!(b.eq_vec(&[false, true, false, true, false, false, true, false,\n+                       false, true, false, false, false, true, true, false,\n+                       false, true, true, false, true, true, false, true,\n+                       false, true, true,  true, false, true, false, true,\n+                       true, false, true]));\n+}\n+\n mod bench {\n     use std::collections::BitVec;\n     use std::u32;"}, {"sha": "afbf4272c196c386f77806a22540e5b25dd9679a", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55a7e8bc4ee7ef585fe628a7efff249369f4f5c/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=d55a7e8bc4ee7ef585fe628a7efff249369f4f5c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(bit_vec_append_split_off)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(collections_drain)]"}]}