{"sha": "226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "node_id": "C_kwDOAAsO6NoAKDIyNmVkNDFjY2E0Y2Y4M2NkNmFmYzE4ZjBkM2NlNGVmMmNkYzg2OTE", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-24T21:03:04Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:58Z"}, "message": "Destroy store buffers on non-racy non-atomic accesses", "tree": {"sha": "1d08e8f8cd48c13eb3e3a81df7119a8c6412a82d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d08e8f8cd48c13eb3e3a81df7119a8c6412a82d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRF4ACgkQGBtJ+fOP\nM3TnPQv+N5JFkaboIsDMuKwducPunul/6ufOnDAw1VEOhfOBD4j07jjUKe8ftOWS\nZNjVd++FLBX3I9YlKMTiOGwiY89Ue8Zj5h/WbIgEUo0GvJAgB9PzqOQhtlemZi6u\nGFSVHfJk4IekIpDfj/Pb91KKplTY7JKvFtgHfONiMaMNTCAry9dpvvg9GuYFEao4\nXK4KYfaU8UpVdq6nRAnLnsskDqstBKu6IcDsoEnHnCwYFHZ01HJV5kkKrMaMrWie\nELvVZHoHa8uRcNjJaGGdRr8n6W7qkNXz4HMuMauJqogGWaRjAYBCKiMpMkvxHHJ4\nlMPHHmOCQbSvQWbC0w0FM4C9/IFXEfUsNxxdcRoc3iMvD9hxtfXsJE9wCWFE4Gjh\n6apxR/snZZNwY1Al/U+nFHVJprTm30sBI7J0j8V5Bo7iS/TKIEcvcQD6/EEug5fF\nnMqW9N702s8HetPh9rwZg+uUfQQQSXswAHGNj8JwMaZLXxc21o+wX4NsGLL9rpeO\nweZc9Ab3\n=WZFx\n-----END PGP SIGNATURE-----", "payload": "tree 1d08e8f8cd48c13eb3e3a81df7119a8c6412a82d\nparent 2321b15342b05445ab7d7ac07a28382b454e0206\nauthor Andy Wang <cbeuw.andy@gmail.com> 1653426184 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539358 +0100\n\nDestroy store buffers on non-racy non-atomic accesses\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "html_url": "https://github.com/rust-lang/rust/commit/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2321b15342b05445ab7d7ac07a28382b454e0206", "url": "https://api.github.com/repos/rust-lang/rust/commits/2321b15342b05445ab7d7ac07a28382b454e0206", "html_url": "https://github.com/rust-lang/rust/commit/2321b15342b05445ab7d7ac07a28382b454e0206"}], "stats": {"total": 63, "additions": 53, "deletions": 10}, "files": [{"sha": "62469dcaf43a873f800bbd8ac978a179151bfc0e", "filename": "src/concurrency/allocation_map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fallocation_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fallocation_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fallocation_map.rs?ref=226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "patch": "@@ -125,6 +125,14 @@ impl<T> AllocationMap<T> {\n             debug_assert!(range.end() <= self.v[pos + 1].range.start);\n         }\n     }\n+\n+    pub fn remove_pos_range(&mut self, pos_range: Range<Position>) {\n+        self.v.drain(pos_range);\n+    }\n+\n+    pub fn remove_from_pos(&mut self, pos: Position) {\n+        self.v.remove(pos);\n+    }\n }\n \n impl<T> Index<Position> for AllocationMap<T> {"}, {"sha": "2483bcdf49a2890e238a1b82da19b9b90b67768f", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "patch": "@@ -1200,6 +1200,10 @@ impl GlobalState {\n         self.multi_threaded.get() && !self.ongoing_atomic_access.get()\n     }\n \n+    pub fn ongoing_atomic_access(&self) -> bool {\n+        self.ongoing_atomic_access.get()\n+    }\n+\n     // Try to find vector index values that can potentially be re-used\n     // by a new thread instead of a new vector index being created.\n     fn find_vector_index_reuse_candidate(&self) -> Option<VectorIdx> {"}, {"sha": "7d8d7da6dc4e7fee55dae274950e0c71db6b1666", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "patch": "@@ -11,10 +11,10 @@\n //! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n //! disallows.\n //!\n-//! Rust follows the full C++20 memory model (except for the Consume ordering). It is therefore\n-//! possible for this implementation to generate behaviours never observable when the same program is compiled and\n-//! run natively. Unfortunately, no literature exists at the time of writing which proposes an implementable and C++20-compatible\n-//! relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n+//! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n+//! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n+//! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n+//! an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n //! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf)\n //! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n //!\n@@ -117,6 +117,26 @@ impl StoreBufferAlloc {\n         Self { store_buffers: RefCell::new(AllocationMap::new()) }\n     }\n \n+    /// When a non-atomic access happens on a location that has been atomically accessed\n+    /// before without data race, we can determine that the non-atomic access fully happens\n+    /// before all the prior atomic accesses so the location no longer needs to exhibit\n+    /// any weak memory behaviours until further atomic accesses.\n+    pub fn destroy_atomicity<'tcx>(&self, range: AllocRange) {\n+        let mut buffers = self.store_buffers.borrow_mut();\n+        let access_type = buffers.access_type(range);\n+        match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => {\n+                buffers.remove_from_pos(pos);\n+            }\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                buffers.remove_pos_range(pos_range);\n+            }\n+            AccessType::Empty(_) => {\n+                // Do nothing\n+            }\n+        }\n+    }\n+\n     /// Gets a store buffer associated with an atomic object in this allocation\n     /// Or creates one with the specified initial value\n     fn get_or_create_store_buffer<'tcx>("}, {"sha": "6dc2a75b69fd7016aa8a1eddd92dce698d714b87", "filename": "src/machine.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=226ed41cca4cf83cd6afc18f0d3ce4ef2cdc8691", "patch": "@@ -738,10 +738,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n-            )\n-        } else {\n-            Ok(())\n+            )?;\n         }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            if !machine.data_race.as_ref().unwrap().ongoing_atomic_access() {\n+                // This is a non-atomic access. And if we are accessing a previously atomically\n+                // accessed location without racing with them, then the location no longer needs\n+                // to exhibit weak-memory behaviours until a fresh atomic access happens\n+                weak_memory.destroy_atomicity(range);\n+            }\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -762,10 +769,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n-            )\n-        } else {\n-            Ok(())\n+            )?;\n         }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            if !machine.data_race.as_ref().unwrap().ongoing_atomic_access() {\n+                weak_memory.destroy_atomicity(range);\n+            }\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]"}]}