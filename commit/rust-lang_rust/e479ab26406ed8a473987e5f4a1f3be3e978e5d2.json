{"sha": "e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NzlhYjI2NDA2ZWQ4YTQ3Mzk4N2U1ZjRhMWYzYmUzZTk3OGU1ZDI=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-09-05T16:17:58Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-09-06T09:10:24Z"}, "message": "Rustup", "tree": {"sha": "89fa0b173a64bddb82fdf70a41ce409e40fb1b89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89fa0b173a64bddb82fdf70a41ce409e40fb1b89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "html_url": "https://github.com/rust-lang/rust/commit/e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a58cb9cf2ebcbb1c4766fc4ac8fba5835aff8a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58cb9cf2ebcbb1c4766fc4ac8fba5835aff8a18", "html_url": "https://github.com/rust-lang/rust/commit/a58cb9cf2ebcbb1c4766fc4ac8fba5835aff8a18"}], "stats": {"total": 69, "additions": 27, "deletions": 42}, "files": [{"sha": "e08166b8c2b271611a7f6efe95db5b67f8c44e89", "filename": "src/intptrcast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "patch": "@@ -47,28 +47,28 @@ impl<'mir, 'tcx> GlobalState {\n         }\n \n         let global_state = memory.extra.intptrcast.borrow();\n-        \n+\n         Ok(match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n             Ok(pos) => {\n                 let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n                 // `int` is equal to the starting address for an allocation, the offset should be\n                 // zero. The pointer is untagged because it was created from a cast\n                 Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged)\n             },\n-            Err(0) => throw_unsup!(DanglingPointerDeref), \n+            Err(0) => throw_unsup!(DanglingPointerDeref),\n             Err(pos) => {\n                 // This is the largest of the adresses smaller than `int`,\n                 // i.e. the greatest lower bound (glb)\n                 let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n                 // This never overflows because `int >= glb`\n                 let offset = int - glb;\n                 // If the offset exceeds the size of the allocation, this access is illegal\n-                if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n+                if offset <= memory.get(alloc_id)?.size.bytes() {\n                     // This pointer is untagged because it was created from a cast\n                     Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged)\n                 } else {\n                     throw_unsup!(DanglingPointerDeref)\n-                } \n+                }\n             }\n         })\n     }\n@@ -108,7 +108,7 @@ impl<'mir, 'tcx> GlobalState {\n                 global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n-                global_state.int_to_ptr_map.push((base_addr, ptr.alloc_id)); \n+                global_state.int_to_ptr_map.push((base_addr, ptr.alloc_id));\n \n                 base_addr\n             }"}, {"sha": "95cb31d67b8f577d9004c1efaf758671271dd7b8", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "patch": "@@ -248,7 +248,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             None => tcx.item_name(def_id).as_str(),\n         };\n \n-        let alloc = match link_name.get() {\n+        let alloc = match &*link_name {\n             \"__cxa_thread_atexit_impl\" => {\n                 // This should be all-zero, pointer-sized.\n                 let size = tcx.data_layout.pointer_size;\n@@ -280,40 +280,25 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         } else {\n             let (stacks, base_tag) = Stacks::new_allocation(\n                 id,\n-                Size::from_bytes(alloc.bytes.len() as u64),\n+                alloc.size,\n                 Rc::clone(&memory_extra.stacked_borrows),\n                 kind,\n             );\n             (Some(stacks), base_tag)\n         };\n-        if kind != MiriMemoryKind::Static.into() {\n-            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n-            // Now we can rely on the inner pointers being static, too.\n-        }\n         let mut stacked_borrows = memory_extra.stacked_borrows.borrow_mut();\n-        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n-            bytes: alloc.bytes,\n-            relocations: Relocations::from_presorted(\n-                alloc.relocations.iter()\n-                    // The allocations in the relocations (pointers stored *inside* this allocation)\n-                    // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| {\n-                        let tag = if !memory_extra.validate {\n-                            Tag::Untagged\n-                        } else {\n-                            stacked_borrows.static_base_ptr(alloc)\n-                        };\n-                        (offset, (tag, alloc))\n-                    })\n-                    .collect()\n-            ),\n-            undef_mask: alloc.undef_mask,\n-            align: alloc.align,\n-            mutability: alloc.mutability,\n-            extra: AllocExtra {\n+        let alloc: Allocation<Tag, Self::AllocExtra> = alloc.retag(\n+            |alloc| if !memory_extra.validate {\n+                Tag::Untagged\n+            } else {\n+                // Only statics may already contain pointers at this point\n+                assert_eq!(kind, MiriMemoryKind::Static.into());\n+                stacked_borrows.static_base_ptr(alloc)\n+            },\n+            AllocExtra {\n                 stacked_borrows: stacks,\n             },\n-        };\n+        );\n         (Cow::Owned(alloc), base_tag)\n     }\n "}, {"sha": "90c18265fcf7c9cc93527692b3159656ddb5810d", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "patch": "@@ -138,7 +138,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             None => this.tcx.item_name(def_id).as_str(),\n         };\n         // Strip linker suffixes (seen on 32-bit macOS).\n-        let link_name = link_name.get().trim_end_matches(\"$UNIX2003\");\n+        let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n         let tcx = &{this.tcx.tcx};\n \n         // First: functions that diverge."}, {"sha": "06af6db76ae6b8a5d6bdf481a8c137d9df30af40", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e479ab26406ed8a473987e5f4a1f3be3e978e5d2/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=e479ab26406ed8a473987e5f4a1f3be3e978e5d2", "patch": "@@ -28,8 +28,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // (as opposed to through a place), we have to remember to erase any tag\n         // that might still hang around!\n \n-        let intrinsic_name = this.tcx.item_name(instance.def_id()).as_str();\n-        match intrinsic_name.get() {\n+        let intrinsic_name = &*this.tcx.item_name(instance.def_id()).as_str();\n+        match intrinsic_name {\n             \"arith_offset\" => {\n                 let offset = this.read_scalar(args[1])?.to_isize(this)?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n@@ -228,7 +228,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" | \"roundf32\" => {\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n-                let f = match intrinsic_name.get() {\n+                let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n                     \"fabsf32\" => f.abs(),\n                     \"cosf32\" => f.cos(),\n@@ -251,7 +251,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" | \"roundf64\" => {\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n-                let f = match intrinsic_name.get() {\n+                let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n                     \"fabsf64\" => f.abs(),\n                     \"cosf64\" => f.cos(),\n@@ -273,7 +273,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let a = this.read_immediate(args[0])?;\n                 let b = this.read_immediate(args[1])?;\n-                let op = match intrinsic_name.get() {\n+                let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n                     \"fmul_fast\" => mir::BinOp::Mul,\n@@ -287,7 +287,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"minnumf32\" | \"maxnumf32\" => {\n                 let a = this.read_scalar(args[0])?.to_f32()?;\n                 let b = this.read_scalar(args[1])?.to_f32()?;\n-                let res = if intrinsic_name.get().starts_with(\"min\") {\n+                let res = if intrinsic_name.starts_with(\"min\") {\n                     a.min(b)\n                 } else {\n                     a.max(b)\n@@ -298,7 +298,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"minnumf64\" | \"maxnumf64\" => {\n                 let a = this.read_scalar(args[0])?.to_f64()?;\n                 let b = this.read_scalar(args[1])?.to_f64()?;\n-                let res = if intrinsic_name.get().starts_with(\"min\") {\n+                let res = if intrinsic_name.starts_with(\"min\") {\n                     a.min(b)\n                 } else {\n                     a.max(b)\n@@ -509,15 +509,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" => {\n                 let l = this.read_immediate(args[0])?;\n                 let r = this.read_immediate(args[1])?;\n-                let op = match intrinsic_name.get() {\n+                let op = match intrinsic_name {\n                     \"unchecked_add\" => mir::BinOp::Add,\n                     \"unchecked_sub\" => mir::BinOp::Sub,\n                     \"unchecked_mul\" => mir::BinOp::Mul,\n                     _ => bug!(),\n                 };\n                 let (res, overflowed, _ty) = this.overflowing_binary_op(op, l, r)?;\n                 if overflowed {\n-                    throw_ub_format!(\"Overflowing arithmetic in {}\", intrinsic_name.get());\n+                    throw_ub_format!(\"Overflowing arithmetic in {}\", intrinsic_name);\n                 }\n                 this.write_scalar(res, dest)?;\n             }"}]}