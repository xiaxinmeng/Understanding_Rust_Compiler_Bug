{"sha": "cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmODhjODQ4N2EyZjgyN2Y4YWYwYTM2OWE2M2IzNjAxZTRjOWYwNGM=", "commit": {"author": {"name": "Jane Lusby", "email": "jlusby42@gmail.com", "date": "2019-06-05T00:32:03Z"}, "committer": {"name": "Jane Lusby", "email": "jlusby42@gmail.com", "date": "2019-06-12T19:29:37Z"}, "message": "initial commit for help improvements on clippy-driver", "tree": {"sha": "fc7d89240b434bd812e0e2a8b2b7ebe93ed3cde6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc7d89240b434bd812e0e2a8b2b7ebe93ed3cde6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "html_url": "https://github.com/rust-lang/rust/commit/cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/comments", "author": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1eb60f8ea46c99cab2be80772915506b4ce9cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1eb60f8ea46c99cab2be80772915506b4ce9cee", "html_url": "https://github.com/rust-lang/rust/commit/a1eb60f8ea46c99cab2be80772915506b4ce9cee"}], "stats": {"total": 2332, "additions": 2332, "deletions": 0}, "files": [{"sha": "1c3c53ad49fd8218dfdaf41c113d3a7d2203b41a", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "patch": "@@ -87,6 +87,28 @@ fn print_lints() {\n \n fn update_lints(update_mode: &UpdateMode) {\n     let lint_list: Vec<Lint> = gather_all().collect();\n+\n+    std::fs::write(\n+        \"../src/lintlist.rs\",\n+        &format!(\n+            \"\\\n+/// Lint data parsed from the Clippy source code.\n+#[derive(Clone, PartialEq, Debug)]\n+pub struct Lint {{\n+    pub name: &'static str,\n+    pub group: &'static str,\n+    pub desc: &'static str,\n+    pub deprecation: Option<&'static str>,\n+    pub module: &'static str,\n+}}\n+\n+pub const ALL_LINTS: [Lint; {}] = {:#?};\",\n+            lint_list.len(),\n+            lint_list\n+        ),\n+    )\n+    .expect(\"can write to file\");\n+\n     let usable_lints: Vec<Lint> = Lint::usable_lints(lint_list.clone().into_iter()).collect();\n     let lint_count = usable_lints.len();\n "}, {"sha": "dc4ff3e8e2a7488d4e5582867f9f8016fdc053c7", "filename": "src/driver.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "patch": "@@ -15,6 +15,8 @@ use rustc_tools_util::*;\n use std::path::Path;\n use std::process::{exit, Command};\n \n+mod lintlist;\n+\n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n fn arg_value<'a>(\n@@ -120,6 +122,40 @@ pub fn main() {\n                 exit(0);\n             }\n \n+            if std::env::args().any(|a| a == \"--help\" || a == \"-h\") {\n+                println!(\n+                    \"\\\n+Checks a package to catch common mistakes and improve your Rust code.\n+\n+Usage:\n+    cargo clippy [options] [--] [<opts>...]\n+\n+Common options:\n+    -h, --help               Print this message\n+    -V, --version            Print version info and exit\n+\n+Other options are the same as `cargo check`.\n+\n+To allow or deny a lint from the command line you can use `cargo clippy --`\n+with:\n+\n+    -W --warn OPT       Set lint warnings\n+    -A --allow OPT      Set lint allowed\n+    -D --deny OPT       Set lint denied\n+    -F --forbid OPT     Set lint forbidden\n+\n+You can use tool lints to allow or deny lints from your code, eg.:\n+\n+    #[allow(clippy::needless_lifetimes)]\n+\"\n+                );\n+\n+                for lint in &lintlist::ALL_LINTS[..] {\n+                    println!(\"clippy::{},\", lint.name);\n+                }\n+                exit(0);\n+            }\n+\n             let mut orig_args: Vec<String> = env::args().collect();\n \n             // Get the sysroot, looking from most specific to this invocation to the least:"}, {"sha": "be4d4fc008a82593cf71cfc7216b9d6b9e4bd31d", "filename": "src/lintlist.rs", "status": "added", "additions": 2274, "deletions": 0, "changes": 2274, "blob_url": "https://github.com/rust-lang/rust/blob/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/src%2Flintlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf88c8487a2f827f8af0a369a63b3601e4c9f04c/src%2Flintlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist.rs?ref=cf88c8487a2f827f8af0a369a63b3601e4c9f04c", "patch": "@@ -0,0 +1,2274 @@\n+/// Lint data parsed from the Clippy source code.\n+#[derive(Clone, PartialEq, Debug)]\n+pub struct Lint {\n+    pub name: &'static str,\n+    pub group: &'static str,\n+    pub desc: &'static str,\n+    pub deprecation: Option<&'static str>,\n+    pub module: &'static str,\n+}\n+\n+pub const ALL_LINTS: [Lint; 320] = [\n+    Lint {\n+        name: \"too_many_arguments\",\n+        group: \"complexity\",\n+        desc: \"functions with too many arguments\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n+    Lint {\n+        name: \"too_many_lines\",\n+        group: \"pedantic\",\n+        desc: \"functions with too many lines\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n+    Lint {\n+        name: \"not_unsafe_ptr_arg_deref\",\n+        group: \"correctness\",\n+        desc: \"public functions dereferencing raw pointer arguments but not marked `unsafe`\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n+    Lint {\n+        name: \"precedence\",\n+        group: \"complexity\",\n+        desc: \"operations where precedence may be unclear\",\n+        deprecation: None,\n+        module: \"precedence\",\n+    },\n+    Lint {\n+        name: \"single_match\",\n+        group: \"style\",\n+        desc: \"a match statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"single_match_else\",\n+        group: \"pedantic\",\n+        desc: \"a match statement with a two arms where the second arm\\'s pattern is a placeholder instead of a specific match pattern\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"match_ref_pats\",\n+        group: \"style\",\n+        desc: \"a match or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"match_bool\",\n+        group: \"style\",\n+        desc: \"a match on a boolean expression instead of an `if..else` block\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"match_overlapping_arm\",\n+        group: \"style\",\n+        desc: \"a match with overlapping arms\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"match_wild_err_arm\",\n+        group: \"style\",\n+        desc: \"a match with `Err(_)` arm and take drastic actions\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"match_as_ref\",\n+        group: \"complexity\",\n+        desc: \"a match on an Option value instead of using `as_ref()` or `as_mut`\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"wildcard_enum_match_arm\",\n+        group: \"restriction\",\n+        desc: \"a wildcard enum match arm using `_`\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n+    Lint {\n+        name: \"option_map_unit_fn\",\n+        group: \"complexity\",\n+        desc: \"using `option.map(f)`, where f is a function or closure that returns ()\",\n+        deprecation: None,\n+        module: \"map_unit_fn\",\n+    },\n+    Lint {\n+        name: \"result_map_unit_fn\",\n+        group: \"complexity\",\n+        desc: \"using `result.map(f)`, where f is a function or closure that returns ()\",\n+        deprecation: None,\n+        module: \"map_unit_fn\",\n+    },\n+    Lint {\n+        name: \"else_if_without_else\",\n+        group: \"restriction\",\n+        desc: \"if expression with an `else if`, but without a final `else` branch\",\n+        deprecation: None,\n+        module: \"else_if_without_else\",\n+    },\n+    Lint {\n+        name: \"fallible_impl_from\",\n+        group: \"nursery\",\n+        desc: \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\",\n+        deprecation: None,\n+        module: \"fallible_impl_from\",\n+    },\n+    Lint {\n+        name: \"missing_docs_in_private_items\",\n+        group: \"restriction\",\n+        desc: \"detects missing documentation for public and private members\",\n+        deprecation: None,\n+        module: \"missing_doc\",\n+    },\n+    Lint {\n+        name: \"unused_label\",\n+        group: \"complexity\",\n+        desc: \"unused labels\",\n+        deprecation: None,\n+        module: \"unused_label\",\n+    },\n+    Lint {\n+        name: \"missing_inline_in_public_items\",\n+        group: \"restriction\",\n+        desc: \"detects missing #[inline] attribute for public callables (functions, trait methods, methods...)\",\n+        deprecation: None,\n+        module: \"missing_inline\",\n+    },\n+    Lint {\n+        name: \"wildcard_dependencies\",\n+        group: \"cargo\",\n+        desc: \"wildcard dependencies being used\",\n+        deprecation: None,\n+        module: \"wildcard_dependencies\",\n+    },\n+    Lint {\n+        name: \"neg_multiply\",\n+        group: \"style\",\n+        desc: \"multiplying integers with -1\",\n+        deprecation: None,\n+        module: \"neg_multiply\",\n+    },\n+    Lint {\n+        name: \"unsafe_removed_from_name\",\n+        group: \"style\",\n+        desc: \"`unsafe` removed from API names on import\",\n+        deprecation: None,\n+        module: \"unsafe_removed_from_name\",\n+    },\n+    Lint {\n+        name: \"drop_bounds\",\n+        group: \"correctness\",\n+        desc: \"Bounds of the form `T: Drop` are useless\",\n+        deprecation: None,\n+        module: \"drop_bounds\",\n+    },\n+    Lint {\n+        name: \"integer_arithmetic\",\n+        group: \"restriction\",\n+        desc: \"any integer arithmetic statement\",\n+        deprecation: None,\n+        module: \"arithmetic\",\n+    },\n+    Lint {\n+        name: \"float_arithmetic\",\n+        group: \"restriction\",\n+        desc: \"any floating-point arithmetic statement\",\n+        deprecation: None,\n+        module: \"arithmetic\",\n+    },\n+    Lint {\n+        name: \"derive_hash_xor_eq\",\n+        group: \"correctness\",\n+        desc: \"deriving `Hash` but implementing `PartialEq` explicitly\",\n+        deprecation: None,\n+        module: \"derive\",\n+    },\n+    Lint {\n+        name: \"expl_impl_clone_on_copy\",\n+        group: \"pedantic\",\n+        desc: \"implementing `Clone` explicitly on `Copy` types\",\n+        deprecation: None,\n+        module: \"derive\",\n+    },\n+    Lint {\n+        name: \"enum_clike_unportable_variant\",\n+        group: \"correctness\",\n+        desc: \"C-like enums that are `repr(isize/usize)` and have values that don\\'t fit into an `i32`\",\n+        deprecation: None,\n+        module: \"enum_clike\",\n+    },\n+    Lint {\n+        name: \"serde_api_misuse\",\n+        group: \"correctness\",\n+        desc: \"various things that will negatively affect your serde experience\",\n+        deprecation: None,\n+        module: \"serde_api\",\n+    },\n+    Lint {\n+        name: \"replace_consts\",\n+        group: \"pedantic\",\n+        desc: \"Lint usages of standard library `const`s that could be replaced by `const fn`s\",\n+        deprecation: None,\n+        module: \"replace_consts\",\n+    },\n+    Lint {\n+        name: \"unnecessary_unwrap\",\n+        group: \"nursery\",\n+        desc: \"checks for calls of unwrap[_err]() that cannot fail\",\n+        deprecation: None,\n+        module: \"unwrap\",\n+    },\n+    Lint {\n+        name: \"panicking_unwrap\",\n+        group: \"nursery\",\n+        desc: \"checks for calls of unwrap[_err]() that will always fail\",\n+        deprecation: None,\n+        module: \"unwrap\",\n+    },\n+    Lint {\n+        name: \"transmuting_null\",\n+        group: \"correctness\",\n+        desc: \"transmutes from a null pointer to a reference, which is undefined behavior\",\n+        deprecation: None,\n+        module: \"transmuting_null\",\n+    },\n+    Lint {\n+        name: \"assertions_on_constants\",\n+        group: \"style\",\n+        desc: \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\",\n+        deprecation: None,\n+        module: \"assertions_on_constants\",\n+    },\n+    Lint {\n+        name: \"shadow_same\",\n+        group: \"restriction\",\n+        desc: \"rebinding a name to itself, e.g., `let mut x = &mut x`\",\n+        deprecation: None,\n+        module: \"shadow\",\n+    },\n+    Lint {\n+        name: \"shadow_reuse\",\n+        group: \"restriction\",\n+        desc: \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\",\n+        deprecation: None,\n+        module: \"shadow\",\n+    },\n+    Lint {\n+        name: \"shadow_unrelated\",\n+        group: \"pedantic\",\n+        desc: \"rebinding a name without even using the original value\",\n+        deprecation: None,\n+        module: \"shadow\",\n+    },\n+    Lint {\n+        name: \"use_self\",\n+        group: \"pedantic\",\n+        desc: \"Unnecessary structure name repetition whereas `Self` is applicable\",\n+        deprecation: None,\n+        module: \"use_self\",\n+    },\n+    Lint {\n+        name: \"declare_interior_mutable_const\",\n+        group: \"correctness\",\n+        desc: \"declaring const with interior mutability\",\n+        deprecation: None,\n+        module: \"non_copy_const\",\n+    },\n+    Lint {\n+        name: \"borrow_interior_mutable_const\",\n+        group: \"correctness\",\n+        desc: \"referencing const with interior mutability\",\n+        deprecation: None,\n+        module: \"non_copy_const\",\n+    },\n+    Lint {\n+        name: \"inline_always\",\n+        group: \"pedantic\",\n+        desc: \"use of `#[inline(always)]`\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"useless_attribute\",\n+        group: \"correctness\",\n+        desc: \"use of lint attributes on `extern crate` items\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"deprecated_semver\",\n+        group: \"correctness\",\n+        desc: \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"empty_line_after_outer_attr\",\n+        group: \"nursery\",\n+        desc: \"empty line after outer attribute\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"unknown_clippy_lints\",\n+        group: \"style\",\n+        desc: \"unknown_lints for scoped Clippy lints\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"deprecated_cfg_attr\",\n+        group: \"complexity\",\n+        desc: \"usage of `cfg_attr(rustfmt)` instead of `tool_attributes`\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n+    Lint {\n+        name: \"excessive_precision\",\n+        group: \"style\",\n+        desc: \"excessive precision for float literal\",\n+        deprecation: None,\n+        module: \"excessive_precision\",\n+    },\n+    Lint {\n+        name: \"items_after_statements\",\n+        group: \"pedantic\",\n+        desc: \"blocks where an item comes after a statement\",\n+        deprecation: None,\n+        module: \"items_after_statements\",\n+    },\n+    Lint {\n+        name: \"multiple_inherent_impl\",\n+        group: \"restriction\",\n+        desc: \"Multiple inherent impl that could be grouped\",\n+        deprecation: None,\n+        module: \"inherent_impl\",\n+    },\n+    Lint {\n+        name: \"invalid_regex\",\n+        group: \"correctness\",\n+        desc: \"invalid regular expressions\",\n+        deprecation: None,\n+        module: \"regex\",\n+    },\n+    Lint {\n+        name: \"trivial_regex\",\n+        group: \"style\",\n+        desc: \"trivial regular expressions\",\n+        deprecation: None,\n+        module: \"regex\",\n+    },\n+    Lint {\n+        name: \"regex_macro\",\n+        group: \"style\",\n+        desc: \"use of `regex!(_)` instead of `Regex::new(_)`\",\n+        deprecation: None,\n+        module: \"regex\",\n+    },\n+    Lint {\n+        name: \"question_mark\",\n+        group: \"style\",\n+        desc: \"checks for expressions that could be replaced by the question mark operator\",\n+        deprecation: None,\n+        module: \"question_mark\",\n+    },\n+    Lint {\n+        name: \"partialeq_ne_impl\",\n+        group: \"complexity\",\n+        desc: \"re-implementing `PartialEq::ne`\",\n+        deprecation: None,\n+        module: \"partialeq_ne_impl\",\n+    },\n+    Lint {\n+        name: \"suspicious_assignment_formatting\",\n+        group: \"style\",\n+        desc: \"suspicious formatting of `*=`, `-=` or `!=`\",\n+        deprecation: None,\n+        module: \"formatting\",\n+    },\n+    Lint {\n+        name: \"suspicious_else_formatting\",\n+        group: \"style\",\n+        desc: \"suspicious formatting of `else`\",\n+        deprecation: None,\n+        module: \"formatting\",\n+    },\n+    Lint {\n+        name: \"possible_missing_comma\",\n+        group: \"correctness\",\n+        desc: \"possible missing comma in array\",\n+        deprecation: None,\n+        module: \"formatting\",\n+    },\n+    Lint {\n+        name: \"dbg_macro\",\n+        group: \"restriction\",\n+        desc: \"`dbg!` macro is intended as a debugging tool\",\n+        deprecation: None,\n+        module: \"dbg_macro\",\n+    },\n+    Lint {\n+        name: \"needless_borrowed_reference\",\n+        group: \"complexity\",\n+        desc: \"taking a needless borrowed reference\",\n+        deprecation: None,\n+        module: \"needless_borrowed_ref\",\n+    },\n+    Lint {\n+        name: \"missing_const_for_fn\",\n+        group: \"nursery\",\n+        desc: \"Lint functions definitions that could be made `const fn`\",\n+        deprecation: None,\n+        module: \"missing_const_for_fn\",\n+    },\n+    Lint {\n+        name: \"eq_op\",\n+        group: \"correctness\",\n+        desc: \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\",\n+        deprecation: None,\n+        module: \"eq_op\",\n+    },\n+    Lint {\n+        name: \"op_ref\",\n+        group: \"style\",\n+        desc: \"taking a reference to satisfy the type constraints on `==`\",\n+        deprecation: None,\n+        module: \"eq_op\",\n+    },\n+    Lint {\n+        name: \"identity_op\",\n+        group: \"complexity\",\n+        desc: \"using identity operations, e.g., `x + 0` or `y / 1`\",\n+        deprecation: None,\n+        module: \"identity_op\",\n+    },\n+    Lint {\n+        name: \"boxed_local\",\n+        group: \"perf\",\n+        desc: \"using `Box<T>` where unnecessary\",\n+        deprecation: None,\n+        module: \"escape\",\n+    },\n+    Lint {\n+        name: \"mem_forget\",\n+        group: \"restriction\",\n+        desc: \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\",\n+        deprecation: None,\n+        module: \"mem_forget\",\n+    },\n+    Lint {\n+        name: \"duration_subsec\",\n+        group: \"complexity\",\n+        desc: \"checks for calculation of subsecond microseconds or milliseconds\",\n+        deprecation: None,\n+        module: \"duration_subsec\",\n+    },\n+    Lint {\n+        name: \"blacklisted_name\",\n+        group: \"style\",\n+        desc: \"usage of a blacklisted/placeholder name\",\n+        deprecation: None,\n+        module: \"blacklisted_name\",\n+    },\n+    Lint {\n+        name: \"nonminimal_bool\",\n+        group: \"complexity\",\n+        desc: \"boolean expressions that can be written more concisely\",\n+        deprecation: None,\n+        module: \"booleans\",\n+    },\n+    Lint {\n+        name: \"logic_bug\",\n+        group: \"correctness\",\n+        desc: \"boolean expressions that contain terminals which can be eliminated\",\n+        deprecation: None,\n+        module: \"booleans\",\n+    },\n+    Lint {\n+        name: \"useless_format\",\n+        group: \"complexity\",\n+        desc: \"useless use of `format!`\",\n+        deprecation: None,\n+        module: \"format\",\n+    },\n+    Lint {\n+        name: \"needless_bool\",\n+        group: \"complexity\",\n+        desc: \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\",\n+        deprecation: None,\n+        module: \"needless_bool\",\n+    },\n+    Lint {\n+        name: \"bool_comparison\",\n+        group: \"complexity\",\n+        desc: \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\",\n+        deprecation: None,\n+        module: \"needless_bool\",\n+    },\n+    Lint {\n+        name: \"enum_glob_use\",\n+        group: \"pedantic\",\n+        desc: \"use items that import all variants of an enum\",\n+        deprecation: None,\n+        module: \"enum_glob_use\",\n+    },\n+    Lint {\n+        name: \"zero_divided_by_zero\",\n+        group: \"complexity\",\n+        desc: \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\",\n+        deprecation: None,\n+        module: \"zero_div_zero\",\n+    },\n+    Lint {\n+        name: \"unnecessary_mut_passed\",\n+        group: \"style\",\n+        desc: \"an argument passed as a mutable reference although the callee only demands an immutable reference\",\n+        deprecation: None,\n+        module: \"mut_reference\",\n+    },\n+    Lint {\n+        name: \"out_of_bounds_indexing\",\n+        group: \"correctness\",\n+        desc: \"out of bounds constant indexing\",\n+        deprecation: None,\n+        module: \"indexing_slicing\",\n+    },\n+    Lint {\n+        name: \"indexing_slicing\",\n+        group: \"restriction\",\n+        desc: \"indexing/slicing usage\",\n+        deprecation: None,\n+        module: \"indexing_slicing\",\n+    },\n+    Lint {\n+        name: \"implicit_return\",\n+        group: \"restriction\",\n+        desc: \"use a return statement like `return expr` instead of an expression\",\n+        deprecation: None,\n+        module: \"implicit_return\",\n+    },\n+    Lint {\n+        name: \"enum_variant_names\",\n+        group: \"style\",\n+        desc: \"enums where all variants share a prefix/postfix\",\n+        deprecation: None,\n+        module: \"enum_variants\",\n+    },\n+    Lint {\n+        name: \"pub_enum_variant_names\",\n+        group: \"pedantic\",\n+        desc: \"enums where all variants share a prefix/postfix\",\n+        deprecation: None,\n+        module: \"enum_variants\",\n+    },\n+    Lint {\n+        name: \"module_name_repetitions\",\n+        group: \"pedantic\",\n+        desc: \"type names prefixed/postfixed with their containing module\\'s name\",\n+        deprecation: None,\n+        module: \"enum_variants\",\n+    },\n+    Lint {\n+        name: \"module_inception\",\n+        group: \"style\",\n+        desc: \"modules that have the same name as their parent module\",\n+        deprecation: None,\n+        module: \"enum_variants\",\n+    },\n+    Lint {\n+        name: \"deep_code_inspection\",\n+        group: \"internal_warn\",\n+        desc: \"helper to dump info about code\",\n+        deprecation: None,\n+        module: \"inspector\",\n+    },\n+    Lint {\n+        name: \"lint_author\",\n+        group: \"internal_warn\",\n+        desc: \"helper for writing lints\",\n+        deprecation: None,\n+        module: \"author\",\n+    },\n+    Lint {\n+        name: \"clippy_lints_internal\",\n+        group: \"internal\",\n+        desc: \"various things that will negatively affect your clippy experience\",\n+        deprecation: None,\n+        module: \"internal_lints\",\n+    },\n+    Lint {\n+        name: \"lint_without_lint_pass\",\n+        group: \"internal\",\n+        desc: \"declaring a lint without associating it in a LintPass\",\n+        deprecation: None,\n+        module: \"internal_lints\",\n+    },\n+    Lint {\n+        name: \"compiler_lint_functions\",\n+        group: \"internal\",\n+        desc: \"usage of the lint functions of the compiler instead of the utils::* variant\",\n+        deprecation: None,\n+        module: \"internal_lints\",\n+    },\n+    Lint {\n+        name: \"neg_cmp_op_on_partial_ord\",\n+        group: \"complexity\",\n+        desc: \"The use of negated comparison operators on partially ordered types may produce confusing code.\",\n+        deprecation: None,\n+        module: \"neg_cmp_op_on_partial_ord\",\n+    },\n+    Lint {\n+        name: \"unused_io_amount\",\n+        group: \"correctness\",\n+        desc: \"unused written/read amount\",\n+        deprecation: None,\n+        module: \"unused_io_amount\",\n+    },\n+    Lint {\n+        name: \"infallible_destructuring_match\",\n+        group: \"style\",\n+        desc: \"a match statement with a single infallible arm instead of a `let`\",\n+        deprecation: None,\n+        module: \"infallible_destructuring_match\",\n+    },\n+    Lint {\n+        name: \"nonsensical_open_options\",\n+        group: \"correctness\",\n+        desc: \"nonsensical combination of options for opening a file\",\n+        deprecation: None,\n+        module: \"open_options\",\n+    },\n+    Lint {\n+        name: \"mut_mut\",\n+        group: \"pedantic\",\n+        desc: \"usage of double-mut refs, e.g., `&mut &mut ...`\",\n+        deprecation: None,\n+        module: \"mut_mut\",\n+    },\n+    Lint {\n+        name: \"mutex_atomic\",\n+        group: \"perf\",\n+        desc: \"using a mutex where an atomic value could be used instead\",\n+        deprecation: None,\n+        module: \"mutex_atomic\",\n+    },\n+    Lint {\n+        name: \"mutex_integer\",\n+        group: \"nursery\",\n+        desc: \"using a mutex for an integer type\",\n+        deprecation: None,\n+        module: \"mutex_atomic\",\n+    },\n+    Lint {\n+        name: \"doc_markdown\",\n+        group: \"pedantic\",\n+        desc: \"presence of `_`, `::` or camel-case outside backticks in documentation\",\n+        deprecation: None,\n+        module: \"doc\",\n+    },\n+    Lint {\n+        name: \"deref_addrof\",\n+        group: \"complexity\",\n+        desc: \"use of `*&` or `*&mut` in an expression\",\n+        deprecation: None,\n+        module: \"reference\",\n+    },\n+    Lint {\n+        name: \"ref_in_deref\",\n+        group: \"complexity\",\n+        desc: \"Use of reference in auto dereference expression.\",\n+        deprecation: None,\n+        module: \"reference\",\n+    },\n+    Lint {\n+        name: \"similar_names\",\n+        group: \"pedantic\",\n+        desc: \"similarly named items and bindings\",\n+        deprecation: None,\n+        module: \"non_expressive_names\",\n+    },\n+    Lint {\n+        name: \"many_single_char_names\",\n+        group: \"style\",\n+        desc: \"too many single character bindings\",\n+        deprecation: None,\n+        module: \"non_expressive_names\",\n+    },\n+    Lint {\n+        name: \"just_underscores_and_digits\",\n+        group: \"style\",\n+        desc: \"unclear name\",\n+        deprecation: None,\n+        module: \"non_expressive_names\",\n+    },\n+    Lint {\n+        name: \"manual_memcpy\",\n+        group: \"perf\",\n+        desc: \"manually copying items between slices\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"needless_range_loop\",\n+        group: \"style\",\n+        desc: \"for-looping over a range of indices where an iterator over items would do\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"explicit_iter_loop\",\n+        group: \"pedantic\",\n+        desc: \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"explicit_into_iter_loop\",\n+        group: \"pedantic\",\n+        desc: \"for-looping over `_.into_iter()` when `_` would do\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"iter_next_loop\",\n+        group: \"correctness\",\n+        desc: \"for-looping over `_.next()` which is probably not intended\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"for_loop_over_option\",\n+        group: \"correctness\",\n+        desc: \"for-looping over an `Option`, which is more clearly expressed as an `if let`\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"for_loop_over_result\",\n+        group: \"correctness\",\n+        desc: \"for-looping over a `Result`, which is more clearly expressed as an `if let`\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"while_let_loop\",\n+        group: \"complexity\",\n+        desc: \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"unused_collect\",\n+        group: \"perf\",\n+        desc: \"`collect()`ing an iterator without using the result; this is usually better written as a for loop\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"needless_collect\",\n+        group: \"perf\",\n+        desc: \"collecting an iterator when collect is not needed\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"reverse_range_loop\",\n+        group: \"correctness\",\n+        desc: \"iteration over an empty range, such as `10..0` or `5..5`\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"explicit_counter_loop\",\n+        group: \"complexity\",\n+        desc: \"for-looping with an explicit counter when `_.enumerate()` would do\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"empty_loop\",\n+        group: \"style\",\n+        desc: \"empty `loop {}`, which should block or sleep\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"while_let_on_iterator\",\n+        group: \"style\",\n+        desc: \"using a while-let loop instead of a for loop on an iterator\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"for_kv_map\",\n+        group: \"style\",\n+        desc: \"looping on a map using `iter` when `keys` or `values` would do\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"never_loop\",\n+        group: \"correctness\",\n+        desc: \"any loop that will always `break` or `return`\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"mut_range_bound\",\n+        group: \"complexity\",\n+        desc: \"for loop over a range where one of the bounds is a mutable variable\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"while_immutable_condition\",\n+        group: \"correctness\",\n+        desc: \"variables used within while expression are not mutated in the body\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n+    Lint {\n+        name: \"needless_update\",\n+        group: \"complexity\",\n+        desc: \"using `Foo { ..base }` when there are no missing fields\",\n+        deprecation: None,\n+        module: \"needless_update\",\n+    },\n+    Lint {\n+        name: \"block_in_if_condition_expr\",\n+        group: \"style\",\n+        desc: \"braces that can be eliminated in conditions, e.g., `if { true } ...`\",\n+        deprecation: None,\n+        module: \"block_in_if_condition\",\n+    },\n+    Lint {\n+        name: \"block_in_if_condition_stmt\",\n+        group: \"style\",\n+        desc: \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\",\n+        deprecation: None,\n+        module: \"block_in_if_condition\",\n+    },\n+    Lint {\n+        name: \"drop_ref\",\n+        group: \"correctness\",\n+        desc: \"calls to `std::mem::drop` with a reference instead of an owned value\",\n+        deprecation: None,\n+        module: \"drop_forget_ref\",\n+    },\n+    Lint {\n+        name: \"forget_ref\",\n+        group: \"correctness\",\n+        desc: \"calls to `std::mem::forget` with a reference instead of an owned value\",\n+        deprecation: None,\n+        module: \"drop_forget_ref\",\n+    },\n+    Lint {\n+        name: \"drop_copy\",\n+        group: \"correctness\",\n+        desc: \"calls to `std::mem::drop` with a value that implements Copy\",\n+        deprecation: None,\n+        module: \"drop_forget_ref\",\n+    },\n+    Lint {\n+        name: \"forget_copy\",\n+        group: \"correctness\",\n+        desc: \"calls to `std::mem::forget` with a value that implements Copy\",\n+        deprecation: None,\n+        module: \"drop_forget_ref\",\n+    },\n+    Lint {\n+        name: \"manual_swap\",\n+        group: \"complexity\",\n+        desc: \"manual swap of two variables\",\n+        deprecation: None,\n+        module: \"swap\",\n+    },\n+    Lint {\n+        name: \"almost_swapped\",\n+        group: \"correctness\",\n+        desc: \"`foo = bar; bar = foo` sequence\",\n+        deprecation: None,\n+        module: \"swap\",\n+    },\n+    Lint {\n+        name: \"redundant_pattern_matching\",\n+        group: \"style\",\n+        desc: \"use the proper utility function avoiding an `if let`\",\n+        deprecation: None,\n+        module: \"redundant_pattern_matching\",\n+    },\n+    Lint {\n+        name: \"bad_bit_mask\",\n+        group: \"correctness\",\n+        desc: \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\",\n+        deprecation: None,\n+        module: \"bit_mask\",\n+    },\n+    Lint {\n+        name: \"ineffective_bit_mask\",\n+        group: \"correctness\",\n+        desc: \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\",\n+        deprecation: None,\n+        module: \"bit_mask\",\n+    },\n+    Lint {\n+        name: \"verbose_bit_mask\",\n+        group: \"style\",\n+        desc: \"expressions where a bit mask is less readable than the corresponding method call\",\n+        deprecation: None,\n+        module: \"bit_mask\",\n+    },\n+    Lint {\n+        name: \"inline_fn_without_body\",\n+        group: \"correctness\",\n+        desc: \"use of `#[inline]` on trait methods without bodies\",\n+        deprecation: None,\n+        module: \"inline_fn_without_body\",\n+    },\n+    Lint {\n+        name: \"iterator_step_by_zero\",\n+        group: \"correctness\",\n+        desc: \"using `Iterator::step_by(0)`, which produces an infinite iterator\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n+    Lint {\n+        name: \"range_zip_with_len\",\n+        group: \"complexity\",\n+        desc: \"zipping iterator with a range when `enumerate()` would do\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n+    Lint {\n+        name: \"range_plus_one\",\n+        group: \"complexity\",\n+        desc: \"`x..(y+1)` reads better as `x..=y`\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n+    Lint {\n+        name: \"range_minus_one\",\n+        group: \"complexity\",\n+        desc: \"`x..=(y-1)` reads better as `x..y`\",\n+        deprecation: None,\n+        module: \"ranges\",\n+    },\n+    Lint {\n+        name: \"redundant_closure\",\n+        group: \"style\",\n+        desc: \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\",\n+        deprecation: None,\n+        module: \"eta_reduction\",\n+    },\n+    Lint {\n+        name: \"redundant_closure_for_method_calls\",\n+        group: \"pedantic\",\n+        desc: \"redundant closures for method calls\",\n+        deprecation: None,\n+        module: \"eta_reduction\",\n+    },\n+    Lint {\n+        name: \"needless_continue\",\n+        group: \"pedantic\",\n+        desc: \"`continue` statements that can be replaced by a rearrangement of code\",\n+        deprecation: None,\n+        module: \"needless_continue\",\n+    },\n+    Lint {\n+        name: \"cognitive_complexity\",\n+        group: \"complexity\",\n+        desc: \"functions that should be split up into multiple functions\",\n+        deprecation: None,\n+        module: \"cognitive_complexity\",\n+    },\n+    Lint {\n+        name: \"println_empty_string\",\n+        group: \"style\",\n+        desc: \"using `println!(\\\"\\\")` with an empty string\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"print_with_newline\",\n+        group: \"style\",\n+        desc: \"using `print!()` with a format string that ends in a single newline\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"print_stdout\",\n+        group: \"restriction\",\n+        desc: \"printing on stdout\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"use_debug\",\n+        group: \"restriction\",\n+        desc: \"use of `Debug`-based formatting\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"print_literal\",\n+        group: \"style\",\n+        desc: \"printing a literal with a format string\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"writeln_empty_string\",\n+        group: \"style\",\n+        desc: \"using `writeln!(buf, \\\"\\\")` with an empty string\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"write_with_newline\",\n+        group: \"style\",\n+        desc: \"using `write!()` with a format string that ends in a single newline\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"write_literal\",\n+        group: \"style\",\n+        desc: \"writing a literal with a format string\",\n+        deprecation: None,\n+        module: \"write\",\n+    },\n+    Lint {\n+        name: \"collapsible_if\",\n+        group: \"style\",\n+        desc: \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\",\n+        deprecation: None,\n+        module: \"collapsible_if\",\n+    },\n+    Lint {\n+        name: \"needless_pass_by_value\",\n+        group: \"pedantic\",\n+        desc: \"functions taking arguments by value, but not consuming them in its body\",\n+        deprecation: None,\n+        module: \"needless_pass_by_value\",\n+    },\n+    Lint {\n+        name: \"identity_conversion\",\n+        group: \"complexity\",\n+        desc: \"using always-identical `Into`/`From`/`IntoIter` conversions\",\n+        deprecation: None,\n+        module: \"identity_conversion\",\n+    },\n+    Lint {\n+        name: \"cargo_common_metadata\",\n+        group: \"cargo\",\n+        desc: \"common metadata is defined in `Cargo.toml`\",\n+        deprecation: None,\n+        module: \"cargo_common_metadata\",\n+    },\n+    Lint {\n+        name: \"overflow_check_conditional\",\n+        group: \"complexity\",\n+        desc: \"overflow checks inspired by C which are likely to panic\",\n+        deprecation: None,\n+        module: \"overflow_check_conditional\",\n+    },\n+    Lint {\n+        name: \"min_max\",\n+        group: \"correctness\",\n+        desc: \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\",\n+        deprecation: None,\n+        module: \"minmax\",\n+    },\n+    Lint {\n+        name: \"no_effect\",\n+        group: \"complexity\",\n+        desc: \"statements with no effect\",\n+        deprecation: None,\n+        module: \"no_effect\",\n+    },\n+    Lint {\n+        name: \"unnecessary_operation\",\n+        group: \"complexity\",\n+        desc: \"outer expressions with no effect\",\n+        deprecation: None,\n+        module: \"no_effect\",\n+    },\n+    Lint {\n+        name: \"should_assert_eq\",\n+        group: \"Deprecated\",\n+        desc: \"`assert!()` will be more flexible with RFC 2011\",\n+        deprecation: Some(\n+            \"`assert!()` will be more flexible with RFC 2011\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"extend_from_slice\",\n+        group: \"Deprecated\",\n+        desc: \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\",\n+        deprecation: Some(\n+            \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"range_step_by_zero\",\n+        group: \"Deprecated\",\n+        desc: \"`iterator.step_by(0)` panics nowadays\",\n+        deprecation: Some(\n+            \"`iterator.step_by(0)` panics nowadays\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"unstable_as_slice\",\n+        group: \"Deprecated\",\n+        desc: \"`Vec::as_slice` has been stabilized in 1.7\",\n+        deprecation: Some(\n+            \"`Vec::as_slice` has been stabilized in 1.7\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"unstable_as_mut_slice\",\n+        group: \"Deprecated\",\n+        desc: \"`Vec::as_mut_slice` has been stabilized in 1.7\",\n+        deprecation: Some(\n+            \"`Vec::as_mut_slice` has been stabilized in 1.7\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"str_to_string\",\n+        group: \"Deprecated\",\n+        desc: \"using `str::to_string` is common even today and specialization will likely happen soon\",\n+        deprecation: Some(\n+            \"using `str::to_string` is common even today and specialization will likely happen soon\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"string_to_string\",\n+        group: \"Deprecated\",\n+        desc: \"using `string::to_string` is common even today and specialization will likely happen soon\",\n+        deprecation: Some(\n+            \"using `string::to_string` is common even today and specialization will likely happen soon\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"misaligned_transmute\",\n+        group: \"Deprecated\",\n+        desc: \"this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\",\n+        deprecation: Some(\n+            \"this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"assign_ops\",\n+        group: \"Deprecated\",\n+        desc: \"using compound assignment operators (e.g., `+=`) is harmless\",\n+        deprecation: Some(\n+            \"using compound assignment operators (e.g., `+=`) is harmless\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"if_let_redundant_pattern_matching\",\n+        group: \"Deprecated\",\n+        desc: \"this lint has been changed to redundant_pattern_matching\",\n+        deprecation: Some(\n+            \"this lint has been changed to redundant_pattern_matching\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"unsafe_vector_initialization\",\n+        group: \"Deprecated\",\n+        desc: \"the replacement suggested by this lint had substantially different behavior\",\n+        deprecation: Some(\n+            \"the replacement suggested by this lint had substantially different behavior\",\n+        ),\n+        module: \"deprecated_lints\",\n+    },\n+    Lint {\n+        name: \"int_plus_one\",\n+        group: \"complexity\",\n+        desc: \"instead of using x >= y + 1, use x > y\",\n+        deprecation: None,\n+        module: \"int_plus_one\",\n+    },\n+    Lint {\n+        name: \"map_entry\",\n+        group: \"perf\",\n+        desc: \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\",\n+        deprecation: None,\n+        module: \"entry\",\n+    },\n+    Lint {\n+        name: \"option_unwrap_used\",\n+        group: \"restriction\",\n+        desc: \"using `Option.unwrap()`, which should at least get a better message using `expect()`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"result_unwrap_used\",\n+        group: \"restriction\",\n+        desc: \"using `Result.unwrap()`, which might be better handled\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"should_implement_trait\",\n+        group: \"style\",\n+        desc: \"defining a method that should be implementing a std trait\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"wrong_self_convention\",\n+        group: \"style\",\n+        desc: \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"wrong_pub_self_convention\",\n+        group: \"restriction\",\n+        desc: \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"ok_expect\",\n+        group: \"style\",\n+        desc: \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"option_map_unwrap_or\",\n+        group: \"pedantic\",\n+        desc: \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"option_map_unwrap_or_else\",\n+        group: \"pedantic\",\n+        desc: \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"result_map_unwrap_or_else\",\n+        group: \"pedantic\",\n+        desc: \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `.ok().map_or_else(g, f)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"option_map_or_none\",\n+        group: \"style\",\n+        desc: \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"filter_next\",\n+        group: \"complexity\",\n+        desc: \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"map_flatten\",\n+        group: \"pedantic\",\n+        desc: \"using combinations of `flatten` and `map` which can usually be written as a single method call\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"filter_map\",\n+        group: \"pedantic\",\n+        desc: \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"filter_map_next\",\n+        group: \"pedantic\",\n+        desc: \"using combination of `filter_map` and `next` which can usually be written as a single method call\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"find_map\",\n+        group: \"pedantic\",\n+        desc: \"using a combination of `find` and `map` can usually be written as a single method call\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"search_is_some\",\n+        group: \"complexity\",\n+        desc: \"using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"chars_next_cmp\",\n+        group: \"complexity\",\n+        desc: \"using `.chars().next()` to check if a string starts with a char\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"or_fun_call\",\n+        group: \"perf\",\n+        desc: \"using any `*or` method with a function call, which suggests `*or_else`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"expect_fun_call\",\n+        group: \"perf\",\n+        desc: \"using any `expect` method with a function call\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"clone_on_copy\",\n+        group: \"complexity\",\n+        desc: \"using `clone` on a `Copy` type\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"clone_on_ref_ptr\",\n+        group: \"restriction\",\n+        desc: \"using \\'clone\\' on a ref-counted pointer\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"clone_double_ref\",\n+        group: \"correctness\",\n+        desc: \"using `clone` on `&&T`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"new_ret_no_self\",\n+        group: \"style\",\n+        desc: \"not returning `Self` in a `new` method\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"single_char_pattern\",\n+        group: \"perf\",\n+        desc: \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"temporary_cstring_as_ptr\",\n+        group: \"correctness\",\n+        desc: \"getting the inner pointer of a temporary `CString`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"iter_nth\",\n+        group: \"perf\",\n+        desc: \"using `.iter().nth()` on a standard library type with O(1) element access\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"iter_skip_next\",\n+        group: \"style\",\n+        desc: \"using `.skip(x).next()` on an iterator\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"get_unwrap\",\n+        group: \"restriction\",\n+        desc: \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"string_extend_chars\",\n+        group: \"style\",\n+        desc: \"using `x.extend(s.chars())` where s is a `&str` or `String`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"iter_cloned_collect\",\n+        group: \"style\",\n+        desc: \"using `.cloned().collect()` on slice to create a `Vec`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"chars_last_cmp\",\n+        group: \"style\",\n+        desc: \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"useless_asref\",\n+        group: \"complexity\",\n+        desc: \"using `as_ref` where the types before and after the call are the same\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"unnecessary_fold\",\n+        group: \"style\",\n+        desc: \"using `fold` when a more succinct alternative exists\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"unnecessary_filter_map\",\n+        group: \"complexity\",\n+        desc: \"using `filter_map` when a more succinct alternative exists\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"into_iter_on_array\",\n+        group: \"correctness\",\n+        desc: \"using `.into_iter()` on an array\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"into_iter_on_ref\",\n+        group: \"style\",\n+        desc: \"using `.into_iter()` on a reference\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n+    Lint {\n+        name: \"needless_return\",\n+        group: \"style\",\n+        desc: \"using a return statement like `return expr;` where an expression would suffice\",\n+        deprecation: None,\n+        module: \"returns\",\n+    },\n+    Lint {\n+        name: \"let_and_return\",\n+        group: \"style\",\n+        desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n+        deprecation: None,\n+        module: \"returns\",\n+    },\n+    Lint {\n+        name: \"unused_unit\",\n+        group: \"style\",\n+        desc: \"needless unit expression\",\n+        deprecation: None,\n+        module: \"returns\",\n+    },\n+    Lint {\n+        name: \"copy_iterator\",\n+        group: \"pedantic\",\n+        desc: \"implementing `Iterator` on a `Copy` type\",\n+        deprecation: None,\n+        module: \"copy_iterator\",\n+    },\n+    Lint {\n+        name: \"ifs_same_cond\",\n+        group: \"correctness\",\n+        desc: \"consecutive `ifs` with the same condition\",\n+        deprecation: None,\n+        module: \"copies\",\n+    },\n+    Lint {\n+        name: \"if_same_then_else\",\n+        group: \"correctness\",\n+        desc: \"if with the same *then* and *else* blocks\",\n+        deprecation: None,\n+        module: \"copies\",\n+    },\n+    Lint {\n+        name: \"match_same_arms\",\n+        group: \"pedantic\",\n+        desc: \"`match` with identical arm bodies\",\n+        deprecation: None,\n+        module: \"copies\",\n+    },\n+    Lint {\n+        name: \"checked_conversions\",\n+        group: \"pedantic\",\n+        desc: \"`try_from` could replace manual bounds checking when casting\",\n+        deprecation: None,\n+        module: \"checked_conversions\",\n+    },\n+    Lint {\n+        name: \"eval_order_dependence\",\n+        group: \"complexity\",\n+        desc: \"whether a variable read occurs before a write depends on sub-expression evaluation order\",\n+        deprecation: None,\n+        module: \"eval_order_dependence\",\n+    },\n+    Lint {\n+        name: \"diverging_sub_expression\",\n+        group: \"complexity\",\n+        desc: \"whether an expression contains a diverging sub expression\",\n+        deprecation: None,\n+        module: \"eval_order_dependence\",\n+    },\n+    Lint {\n+        name: \"map_clone\",\n+        group: \"style\",\n+        desc: \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\",\n+        deprecation: None,\n+        module: \"map_clone\",\n+    },\n+    Lint {\n+        name: \"ptr_offset_with_cast\",\n+        group: \"complexity\",\n+        desc: \"unneeded pointer offset cast\",\n+        deprecation: None,\n+        module: \"ptr_offset_with_cast\",\n+    },\n+    Lint {\n+        name: \"infinite_iter\",\n+        group: \"correctness\",\n+        desc: \"infinite iteration\",\n+        deprecation: None,\n+        module: \"infinite_iter\",\n+    },\n+    Lint {\n+        name: \"maybe_infinite_iter\",\n+        group: \"pedantic\",\n+        desc: \"possible infinite iteration\",\n+        deprecation: None,\n+        module: \"infinite_iter\",\n+    },\n+    Lint {\n+        name: \"default_trait_access\",\n+        group: \"pedantic\",\n+        desc: \"checks for literal calls to Default::default()\",\n+        deprecation: None,\n+        module: \"default_trait_access\",\n+    },\n+    Lint {\n+        name: \"double_parens\",\n+        group: \"complexity\",\n+        desc: \"Warn on unnecessary double parentheses\",\n+        deprecation: None,\n+        module: \"double_parens\",\n+    },\n+    Lint {\n+        name: \"multiple_crate_versions\",\n+        group: \"cargo\",\n+        desc: \"multiple versions of the same crate being used\",\n+        deprecation: None,\n+        module: \"multiple_crate_versions\",\n+    },\n+    Lint {\n+        name: \"suspicious_arithmetic_impl\",\n+        group: \"correctness\",\n+        desc: \"suspicious use of operators in impl of arithmetic trait\",\n+        deprecation: None,\n+        module: \"suspicious_trait_impl\",\n+    },\n+    Lint {\n+        name: \"suspicious_op_assign_impl\",\n+        group: \"correctness\",\n+        desc: \"suspicious use of operators in impl of OpAssign trait\",\n+        deprecation: None,\n+        module: \"suspicious_trait_impl\",\n+    },\n+    Lint {\n+        name: \"mem_discriminant_non_enum\",\n+        group: \"correctness\",\n+        desc: \"calling mem::descriminant on non-enum type\",\n+        deprecation: None,\n+        module: \"mem_discriminant\",\n+    },\n+    Lint {\n+        name: \"path_buf_push_overwrite\",\n+        group: \"nursery\",\n+        desc: \"calling `push` with file system root on `PathBuf` can overwrite it\",\n+        deprecation: None,\n+        module: \"path_buf_push_overwrite\",\n+    },\n+    Lint {\n+        name: \"get_last_with_len\",\n+        group: \"complexity\",\n+        desc: \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\",\n+        deprecation: None,\n+        module: \"get_last_with_len\",\n+    },\n+    Lint {\n+        name: \"redundant_field_names\",\n+        group: \"style\",\n+        desc: \"checks for fields in struct literals where shorthands could be used\",\n+        deprecation: None,\n+        module: \"redundant_field_names\",\n+    },\n+    Lint {\n+        name: \"redundant_clone\",\n+        group: \"nursery\",\n+        desc: \"`clone()` of an owned value that is going to be dropped immediately\",\n+        deprecation: None,\n+        module: \"redundant_clone\",\n+    },\n+    Lint {\n+        name: \"ptr_arg\",\n+        group: \"style\",\n+        desc: \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\",\n+        deprecation: None,\n+        module: \"ptr\",\n+    },\n+    Lint {\n+        name: \"cmp_null\",\n+        group: \"style\",\n+        desc: \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\",\n+        deprecation: None,\n+        module: \"ptr\",\n+    },\n+    Lint {\n+        name: \"mut_from_ref\",\n+        group: \"correctness\",\n+        desc: \"fns that create mutable refs from immutable ref args\",\n+        deprecation: None,\n+        module: \"ptr\",\n+    },\n+    Lint {\n+        name: \"empty_enum\",\n+        group: \"pedantic\",\n+        desc: \"enum with no variants\",\n+        deprecation: None,\n+        module: \"empty_enum\",\n+    },\n+    Lint {\n+        name: \"unneeded_field_pattern\",\n+        group: \"style\",\n+        desc: \"struct fields bound to a wildcard instead of using `..`\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"duplicate_underscore_argument\",\n+        group: \"style\",\n+        desc: \"function arguments having names which only differ by an underscore\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"redundant_closure_call\",\n+        group: \"complexity\",\n+        desc: \"throwaway closures called in the expression they are defined\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"double_neg\",\n+        group: \"style\",\n+        desc: \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"mixed_case_hex_literals\",\n+        group: \"style\",\n+        desc: \"hex literals whose letter digits are not consistently upper- or lowercased\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"unseparated_literal_suffix\",\n+        group: \"pedantic\",\n+        desc: \"literals whose suffix is not separated by an underscore\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"zero_prefixed_literal\",\n+        group: \"complexity\",\n+        desc: \"integer literals starting with `0`\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"builtin_type_shadow\",\n+        group: \"style\",\n+        desc: \"shadowing a builtin type\",\n+        deprecation: None,\n+        module: \"misc_early\",\n+    },\n+    Lint {\n+        name: \"useless_vec\",\n+        group: \"perf\",\n+        desc: \"useless `vec!`\",\n+        deprecation: None,\n+        module: \"vec\",\n+    },\n+    Lint {\n+        name: \"explicit_write\",\n+        group: \"complexity\",\n+        desc: \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\",\n+        deprecation: None,\n+        module: \"explicit_write\",\n+    },\n+    Lint {\n+        name: \"toplevel_ref_arg\",\n+        group: \"style\",\n+        desc: \"an entire binding declared as `ref`, in a function argument or a `let` statement\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"cmp_nan\",\n+        group: \"correctness\",\n+        desc: \"comparisons to NAN, which will always return false, probably not intended\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"float_cmp\",\n+        group: \"correctness\",\n+        desc: \"using `==` or `!=` on float values instead of comparing difference with an epsilon\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"cmp_owned\",\n+        group: \"perf\",\n+        desc: \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"modulo_one\",\n+        group: \"correctness\",\n+        desc: \"taking a number modulo 1, which always returns 0\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"redundant_pattern\",\n+        group: \"style\",\n+        desc: \"using `name @ _` in a pattern\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"used_underscore_binding\",\n+        group: \"pedantic\",\n+        desc: \"using a binding which is prefixed with an underscore\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"short_circuit_statement\",\n+        group: \"complexity\",\n+        desc: \"using a short circuit boolean condition as a statement\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"zero_ptr\",\n+        group: \"style\",\n+        desc: \"using 0 as *{const, mut} T\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"float_cmp_const\",\n+        group: \"restriction\",\n+        desc: \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\",\n+        deprecation: None,\n+        module: \"misc\",\n+    },\n+    Lint {\n+        name: \"string_add_assign\",\n+        group: \"pedantic\",\n+        desc: \"using `x = x + ..` where x is a `String` instead of `push_str()`\",\n+        deprecation: None,\n+        module: \"strings\",\n+    },\n+    Lint {\n+        name: \"string_add\",\n+        group: \"restriction\",\n+        desc: \"using `x + ..` where x is a `String` instead of `push_str()`\",\n+        deprecation: None,\n+        module: \"strings\",\n+    },\n+    Lint {\n+        name: \"string_lit_as_bytes\",\n+        group: \"style\",\n+        desc: \"calling `as_bytes` on a string literal instead of using a byte string literal\",\n+        deprecation: None,\n+        module: \"strings\",\n+    },\n+    Lint {\n+        name: \"trivially_copy_pass_by_ref\",\n+        group: \"perf\",\n+        desc: \"functions taking small copyable arguments by reference\",\n+        deprecation: None,\n+        module: \"trivially_copy_pass_by_ref\",\n+    },\n+    Lint {\n+        name: \"double_comparisons\",\n+        group: \"complexity\",\n+        desc: \"unnecessary double comparisons that can be simplified\",\n+        deprecation: None,\n+        module: \"double_comparison\",\n+    },\n+    Lint {\n+        name: \"approx_constant\",\n+        group: \"correctness\",\n+        desc: \"the approximate of a known float constant (in `std::fXX::consts`)\",\n+        deprecation: None,\n+        module: \"approx_const\",\n+    },\n+    Lint {\n+        name: \"assign_op_pattern\",\n+        group: \"style\",\n+        desc: \"assigning the result of an operation on a variable to that same variable\",\n+        deprecation: None,\n+        module: \"assign_ops\",\n+    },\n+    Lint {\n+        name: \"misrefactored_assign_op\",\n+        group: \"complexity\",\n+        desc: \"having a variable on both sides of an assign op\",\n+        deprecation: None,\n+        module: \"assign_ops\",\n+    },\n+    Lint {\n+        name: \"erasing_op\",\n+        group: \"correctness\",\n+        desc: \"using erasing operations, e.g., `x * 0` or `y & 0`\",\n+        deprecation: None,\n+        module: \"erasing_op\",\n+    },\n+    Lint {\n+        name: \"wrong_transmute\",\n+        group: \"correctness\",\n+        desc: \"transmutes that are confusing at best, undefined behaviour at worst and always useless\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"useless_transmute\",\n+        group: \"complexity\",\n+        desc: \"transmutes that have the same to and from types or could be a cast/coercion\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"crosspointer_transmute\",\n+        group: \"complexity\",\n+        desc: \"transmutes that have to or from types that are a pointer to the other\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_ptr_to_ref\",\n+        group: \"complexity\",\n+        desc: \"transmutes from a pointer to a reference type\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_int_to_char\",\n+        group: \"complexity\",\n+        desc: \"transmutes from an integer to a `char`\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_bytes_to_str\",\n+        group: \"complexity\",\n+        desc: \"transmutes from a `&[u8]` to a `&str`\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_int_to_bool\",\n+        group: \"complexity\",\n+        desc: \"transmutes from an integer to a `bool`\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_int_to_float\",\n+        group: \"complexity\",\n+        desc: \"transmutes from an integer to a float\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"transmute_ptr_to_ptr\",\n+        group: \"complexity\",\n+        desc: \"transmutes from a pointer to a pointer / a reference to a reference\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n+    Lint {\n+        name: \"needless_borrow\",\n+        group: \"nursery\",\n+        desc: \"taking a reference that is going to be automatically dereferenced\",\n+        deprecation: None,\n+        module: \"needless_borrow\",\n+    },\n+    Lint {\n+        name: \"if_not_else\",\n+        group: \"pedantic\",\n+        desc: \"`if` branches that could be swapped so no negation operation is necessary on the condition\",\n+        deprecation: None,\n+        module: \"if_not_else\",\n+    },\n+    Lint {\n+        name: \"naive_bytecount\",\n+        group: \"perf\",\n+        desc: \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\",\n+        deprecation: None,\n+        module: \"bytecount\",\n+    },\n+    Lint {\n+        name: \"zero_width_space\",\n+        group: \"correctness\",\n+        desc: \"using a zero-width space in a string literal, which is confusing\",\n+        deprecation: None,\n+        module: \"unicode\",\n+    },\n+    Lint {\n+        name: \"non_ascii_literal\",\n+        group: \"pedantic\",\n+        desc: \"using any literal non-ASCII chars in a string literal instead of using the `\\\\\\\\u` escape\",\n+        deprecation: None,\n+        module: \"unicode\",\n+    },\n+    Lint {\n+        name: \"unicode_not_nfc\",\n+        group: \"pedantic\",\n+        desc: \"using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\",\n+        deprecation: None,\n+        module: \"unicode\",\n+    },\n+    Lint {\n+        name: \"len_zero\",\n+        group: \"style\",\n+        desc: \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\",\n+        deprecation: None,\n+        module: \"len_zero\",\n+    },\n+    Lint {\n+        name: \"len_without_is_empty\",\n+        group: \"style\",\n+        desc: \"traits or impls with a public `len` method but no corresponding `is_empty` method\",\n+        deprecation: None,\n+        module: \"len_zero\",\n+    },\n+    Lint {\n+        name: \"useless_let_if_seq\",\n+        group: \"style\",\n+        desc: \"unidiomatic `let mut` declaration followed by initialization in `if`\",\n+        deprecation: None,\n+        module: \"let_if_seq\",\n+    },\n+    Lint {\n+        name: \"large_enum_variant\",\n+        group: \"perf\",\n+        desc: \"large size difference between variants on an enum\",\n+        deprecation: None,\n+        module: \"large_enum_variant\",\n+    },\n+    Lint {\n+        name: \"new_without_default\",\n+        group: \"style\",\n+        desc: \"`fn new() -> Self` method without `Default` implementation\",\n+        deprecation: None,\n+        module: \"new_without_default\",\n+    },\n+    Lint {\n+        name: \"box_vec\",\n+        group: \"perf\",\n+        desc: \"usage of `Box<Vec<T>>`, vector elements are already on the heap\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"vec_box\",\n+        group: \"complexity\",\n+        desc: \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"option_option\",\n+        group: \"complexity\",\n+        desc: \"usage of `Option<Option<T>>`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"linkedlist\",\n+        group: \"pedantic\",\n+        desc: \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"borrowed_box\",\n+        group: \"complexity\",\n+        desc: \"a borrow of a boxed type\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"let_unit_value\",\n+        group: \"style\",\n+        desc: \"creating a let binding to a value of unit type, which usually can\\'t be used afterwards\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"unit_cmp\",\n+        group: \"correctness\",\n+        desc: \"comparing unit values\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"unit_arg\",\n+        group: \"complexity\",\n+        desc: \"passing unit to a function\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_precision_loss\",\n+        group: \"pedantic\",\n+        desc: \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_sign_loss\",\n+        group: \"pedantic\",\n+        desc: \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_possible_truncation\",\n+        group: \"pedantic\",\n+        desc: \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_possible_wrap\",\n+        group: \"pedantic\",\n+        desc: \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_lossless\",\n+        group: \"complexity\",\n+        desc: \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"unnecessary_cast\",\n+        group: \"complexity\",\n+        desc: \"cast to the same type, e.g., `x as i32` where `x: i32`\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_ptr_alignment\",\n+        group: \"correctness\",\n+        desc: \"cast from a pointer to a more-strictly-aligned pointer\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"fn_to_numeric_cast\",\n+        group: \"style\",\n+        desc: \"casting a function pointer to a numeric type other than usize\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"fn_to_numeric_cast_with_truncation\",\n+        group: \"style\",\n+        desc: \"casting a function pointer to a numeric type not wide enough to store the address\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"type_complexity\",\n+        group: \"complexity\",\n+        desc: \"usage of very complex types that might be better factored into `type` definitions\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"char_lit_as_u8\",\n+        group: \"complexity\",\n+        desc: \"casting a character literal to u8\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"absurd_extreme_comparisons\",\n+        group: \"correctness\",\n+        desc: \"a comparison with a maximum or minimum value that is always true or false\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"invalid_upcast_comparisons\",\n+        group: \"pedantic\",\n+        desc: \"a comparison involving an upcast which is always true or false\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"implicit_hasher\",\n+        group: \"style\",\n+        desc: \"missing generalization over different hashers\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"cast_ref_to_mut\",\n+        group: \"correctness\",\n+        desc: \"a cast of reference to a mutable pointer\",\n+        deprecation: None,\n+        module: \"types\",\n+    },\n+    Lint {\n+        name: \"needless_lifetimes\",\n+        group: \"complexity\",\n+        desc: \"using explicit lifetimes for references in function arguments when elision rules would allow omitting them\",\n+        deprecation: None,\n+        module: \"lifetimes\",\n+    },\n+    Lint {\n+        name: \"extra_unused_lifetimes\",\n+        group: \"complexity\",\n+        desc: \"unused lifetimes in function definitions\",\n+        deprecation: None,\n+        module: \"lifetimes\",\n+    },\n+    Lint {\n+        name: \"temporary_assignment\",\n+        group: \"complexity\",\n+        desc: \"assignments to temporaries\",\n+        deprecation: None,\n+        module: \"temporary_assignment\",\n+    },\n+    Lint {\n+        name: \"slow_vector_initialization\",\n+        group: \"perf\",\n+        desc: \"slow vector initialization\",\n+        deprecation: None,\n+        module: \"slow_vector_initialization\",\n+    },\n+    Lint {\n+        name: \"unreadable_literal\",\n+        group: \"style\",\n+        desc: \"long integer literal without underscores\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n+    Lint {\n+        name: \"mistyped_literal_suffixes\",\n+        group: \"correctness\",\n+        desc: \"mistyped literal suffix\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n+    Lint {\n+        name: \"inconsistent_digit_grouping\",\n+        group: \"style\",\n+        desc: \"integer literals with digits grouped inconsistently\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n+    Lint {\n+        name: \"large_digit_groups\",\n+        group: \"pedantic\",\n+        desc: \"grouping digits into groups that are too large\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n+    Lint {\n+        name: \"decimal_literal_representation\",\n+        group: \"restriction\",\n+        desc: \"using decimal representation when hexadecimal would be better\",\n+        deprecation: None,\n+        module: \"literal_representation\",\n+    },\n+    Lint {\n+        name: \"if_let_some_result\",\n+        group: \"style\",\n+        desc: \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\",\n+        deprecation: None,\n+        module: \"ok_if_let\",\n+    },\n+    Lint {\n+        name: \"panic_params\",\n+        group: \"style\",\n+        desc: \"missing parameters in `panic!` calls\",\n+        deprecation: None,\n+        module: \"panic_unimplemented\",\n+    },\n+    Lint {\n+        name: \"unimplemented\",\n+        group: \"restriction\",\n+        desc: \"`unimplemented!` should not be present in production code\",\n+        deprecation: None,\n+        module: \"panic_unimplemented\",\n+    },\n+    Lint {\n+        name: \"invalid_ref\",\n+        group: \"correctness\",\n+        desc: \"creation of invalid reference\",\n+        deprecation: None,\n+        module: \"invalid_ref\",\n+    },\n+    Lint {\n+        name: \"mem_replace_option_with_none\",\n+        group: \"style\",\n+        desc: \"replacing an `Option` with `None` instead of `take()`\",\n+        deprecation: None,\n+        module: \"mem_replace\",\n+    },\n+    Lint {\n+        name: \"const_static_lifetime\",\n+        group: \"style\",\n+        desc: \"Using explicit `\\'static` lifetime for constants when elision rules would allow omitting them.\",\n+        deprecation: None,\n+        module: \"const_static_lifetime\",\n+    },\n+];\n\\ No newline at end of file"}]}