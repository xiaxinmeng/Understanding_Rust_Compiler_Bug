{"sha": "9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "node_id": "C_kwDOAAsO6NoAKDljN2RjM2UzMGI2YTdjMDQxOTBjZWI5NmZiOWEzZjZlOWJkMTg0OGE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-25T17:35:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-25T17:35:39Z"}, "message": "Rollup merge of #104716 - lcnr:selection-candidate, r=jackh726\n\nmove 2 candidates into builtin candidate\n\nhaving separate candidates for these isn't too helpful i think\n\nr? types", "tree": {"sha": "795b9e4bbdad3b57cc15b51fa8c21636bb30e12d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/795b9e4bbdad3b57cc15b51fa8c21636bb30e12d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjgPzrCRBK7hj4Ov3rIwAAE08IAIW27CXi9RF1e6Kb+CwHj/if\nbYhDeNrOJhrZRWE5XjTIAPC5I148CinwxGNAC7nmF9Lhj3bvj3Fvr/oOU5q0SoP3\nJiMhAZcDlQVwsjQ59zlR2koAA2hGYsX34xd8q+5ui/AySkC+bkDsEqg0A5k8Kfag\n8tSmala0Xo24AH9gc53xglW1bf0Y+dk30rKMlhAuLSG3X9aALizkPVIoPc6fM6Ya\n3jCsnrG4M9K5Ow2zqAt92Z+2XtfvD/Xs1AfLFxR5pmlqCntgem2dtCiTUfiPjn9/\nimnBPL6FnKzEA7FbZxZU43QBsRZbRn1VyGrw552k23f3V5JUuDYfX+C0jj7PfD0=\n=QZkG\n-----END PGP SIGNATURE-----\n", "payload": "tree 795b9e4bbdad3b57cc15b51fa8c21636bb30e12d\nparent e704e95250ff4e949214f390a88f21d08052bea1\nparent 84e97907c64646b6ad960f6721aafc0a1c1c0503\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669397739 +0100\ncommitter GitHub <noreply@github.com> 1669397739 +0100\n\nRollup merge of #104716 - lcnr:selection-candidate, r=jackh726\n\nmove 2 candidates into builtin candidate\n\nhaving separate candidates for these isn't too helpful i think\n\nr? types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "html_url": "https://github.com/rust-lang/rust/commit/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e704e95250ff4e949214f390a88f21d08052bea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e704e95250ff4e949214f390a88f21d08052bea1", "html_url": "https://github.com/rust-lang/rust/commit/e704e95250ff4e949214f390a88f21d08052bea1"}, {"sha": "84e97907c64646b6ad960f6721aafc0a1c1c0503", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e97907c64646b6ad960f6721aafc0a1c1c0503", "html_url": "https://github.com/rust-lang/rust/commit/84e97907c64646b6ad960f6721aafc0a1c1c0503"}], "stats": {"total": 418, "additions": 171, "deletions": 247}, "files": [{"sha": "26f3052b642b27d6af86b56a5d87a14b420347d6", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -651,12 +651,6 @@ pub enum ImplSource<'tcx, N> {\n     /// Same as above, but for a function pointer type with the given signature.\n     FnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n-    /// ImplSource for a builtin `DeterminantKind` trait implementation.\n-    DiscriminantKind(ImplSourceDiscriminantKindData),\n-\n-    /// ImplSource for a builtin `Pointee` trait implementation.\n-    Pointee(ImplSourcePointeeData),\n-\n     /// ImplSource automatically generated for a generator.\n     Generator(ImplSourceGeneratorData<'tcx, N>),\n \n@@ -682,8 +676,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Future(c) => c.nested,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => vec![],\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n             ImplSource::ConstDestruct(i) => i.nested,\n@@ -701,8 +693,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Future(c) => &c.nested,\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n             ImplSource::ConstDestruct(i) => &i.nested,\n@@ -751,12 +741,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n-                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            }\n-            ImplSource::Pointee(ImplSourcePointeeData) => {\n-                ImplSource::Pointee(ImplSourcePointeeData)\n-            }\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -876,13 +860,6 @@ pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-// FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourceDiscriminantKindData;\n-\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourcePointeeData;\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceConstDestructData<N> {"}, {"sha": "ec69864c951d4df347bb0befaf12df9587561fae", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -105,6 +105,12 @@ pub type EvaluationCache<'tcx> = Cache<\n /// parameter environment.\n #[derive(PartialEq, Eq, Debug, Clone, TypeFoldable, TypeVisitable)]\n pub enum SelectionCandidate<'tcx> {\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n     BuiltinCandidate {\n         /// `false` if there are no *further* obligations.\n         has_nested: bool,\n@@ -141,12 +147,6 @@ pub enum SelectionCandidate<'tcx> {\n         is_const: bool,\n     },\n \n-    /// Builtin implementation of `DiscriminantKind`.\n-    DiscriminantKindCandidate,\n-\n-    /// Builtin implementation of `Pointee`.\n-    PointeeCandidate,\n-\n     TraitAliasCandidate,\n \n     /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the"}, {"sha": "6acb7745d654e9552b8adc86c4a61418957c40d0", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -19,10 +19,6 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n \n             super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n-            super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Pointee(ref d) => write!(f, \"{:?}\", d),\n-\n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Param(ref n, ct) => {\n@@ -137,11 +133,3 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n         write!(f, \"ImplSourceConstDestructData(nested={:?})\", self.nested)\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    super::ImplSourceDiscriminantKindData,\n-    super::ImplSourcePointeeData,\n-}"}, {"sha": "8087daf9d458d9102d37a3133579337244d120fa", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 156, "deletions": 176, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -11,8 +11,7 @@ use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::{\n-    ImplSourceClosureData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourcePointeeData,\n+    ImplSourceClosureData, ImplSourceFnPointerData, ImplSourceFutureData, ImplSourceGeneratorData,\n     ImplSourceUserDefinedData,\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n@@ -29,6 +28,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{MaxUniverse, TypeVisitable};\n@@ -1598,128 +1598,126 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     }\n                 }\n             }\n-            super::ImplSource::DiscriminantKind(..) => {\n-                // While `DiscriminantKind` is automatically implemented for every type,\n-                // the concrete discriminant may not be known yet.\n-                //\n-                // Any type with multiple potential discriminant types is therefore not eligible.\n+            super::ImplSource::Builtin(..) => {\n+                // While a builtin impl may be known to exist, the associated type may not yet\n+                // be known. Any type with multiple potential associated types is therefore\n+                // not eligible.\n                 let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n-                match self_ty.kind() {\n-                    ty::Bool\n-                    | ty::Char\n-                    | ty::Int(_)\n-                    | ty::Uint(_)\n-                    | ty::Float(_)\n-                    | ty::Adt(..)\n-                    | ty::Foreign(_)\n-                    | ty::Str\n-                    | ty::Array(..)\n-                    | ty::Slice(_)\n-                    | ty::RawPtr(..)\n-                    | ty::Ref(..)\n-                    | ty::FnDef(..)\n-                    | ty::FnPtr(..)\n-                    | ty::Dynamic(..)\n-                    | ty::Closure(..)\n-                    | ty::Generator(..)\n-                    | ty::GeneratorWitness(..)\n-                    | ty::Never\n-                    | ty::Tuple(..)\n-                    // Integers and floats always have `u8` as their discriminant.\n-                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n-\n-                    ty::Projection(..)\n-                    | ty::Opaque(..)\n-                    | ty::Param(..)\n-                    | ty::Bound(..)\n-                    | ty::Placeholder(..)\n-                    | ty::Infer(..)\n-                    | ty::Error(_) => false,\n-                }\n-            }\n-            super::ImplSource::Pointee(..) => {\n-                // While `Pointee` is automatically implemented for every type,\n-                // the concrete metadata type may not be known yet.\n-                //\n-                // Any type with multiple potential metadata types is therefore not eligible.\n-                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-\n-                let tail = selcx.tcx().struct_tail_with_normalize(\n-                    self_ty,\n-                    |ty| {\n-                        // We throw away any obligations we get from this, since we normalize\n-                        // and confirm these obligations once again during confirmation\n-                        normalize_with_depth(\n-                            selcx,\n-                            obligation.param_env,\n-                            obligation.cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            ty,\n-                        )\n-                        .value\n-                    },\n-                    || {},\n-                );\n-\n-                match tail.kind() {\n-                    ty::Bool\n-                    | ty::Char\n-                    | ty::Int(_)\n-                    | ty::Uint(_)\n-                    | ty::Float(_)\n-                    | ty::Str\n-                    | ty::Array(..)\n-                    | ty::Slice(_)\n-                    | ty::RawPtr(..)\n-                    | ty::Ref(..)\n-                    | ty::FnDef(..)\n-                    | ty::FnPtr(..)\n-                    | ty::Dynamic(..)\n-                    | ty::Closure(..)\n-                    | ty::Generator(..)\n-                    | ty::GeneratorWitness(..)\n-                    | ty::Never\n-                    // Extern types have unit metadata, according to RFC 2850\n-                    | ty::Foreign(_)\n-                    // If returned by `struct_tail_without_normalization` this is a unit struct\n-                    // without any fields, or not a struct, and therefore is Sized.\n-                    | ty::Adt(..)\n-                    // If returned by `struct_tail_without_normalization` this is the empty tuple.\n-                    | ty::Tuple(..)\n-                    // Integers and floats are always Sized, and so have unit type metadata.\n-                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n-\n-                    // type parameters, opaques, and unnormalized projections have pointer\n-                    // metadata if they're known (e.g. by the param_env) to be sized\n-                    ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n-                        if selcx.infcx().predicate_must_hold_modulo_regions(\n-                            &obligation.with(\n-                                selcx.tcx(),\n-                                ty::Binder::dummy(selcx.tcx().at(obligation.cause.span).mk_trait_ref(\n-                                    LangItem::Sized,\n-                                    [self_ty],\n-                                ))\n-                                .without_const(),\n-                            ),\n-                        ) =>\n-                    {\n-                        true\n+                let lang_items = selcx.tcx().lang_items();\n+                if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n+                    match self_ty.kind() {\n+                        ty::Bool\n+                        | ty::Char\n+                        | ty::Int(_)\n+                        | ty::Uint(_)\n+                        | ty::Float(_)\n+                        | ty::Adt(..)\n+                        | ty::Foreign(_)\n+                        | ty::Str\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        | ty::RawPtr(..)\n+                        | ty::Ref(..)\n+                        | ty::FnDef(..)\n+                        | ty::FnPtr(..)\n+                        | ty::Dynamic(..)\n+                        | ty::Closure(..)\n+                        | ty::Generator(..)\n+                        | ty::GeneratorWitness(..)\n+                        | ty::Never\n+                        | ty::Tuple(..)\n+                        // Integers and floats always have `u8` as their discriminant.\n+                        | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                         // type parameters, opaques, and unnormalized projections have pointer\n+                        // metadata if they're known (e.g. by the param_env) to be sized\n+                        ty::Param(_)\n+                        | ty::Projection(..)\n+                        | ty::Opaque(..)\n+                        | ty::Bound(..)\n+                        | ty::Placeholder(..)\n+                        | ty::Infer(..)\n+                        | ty::Error(_) => false,\n                     }\n+                } else if lang_items.pointee_trait() == Some(poly_trait_ref.def_id()) {\n+                    let tail = selcx.tcx().struct_tail_with_normalize(\n+                        self_ty,\n+                        |ty| {\n+                            // We throw away any obligations we get from this, since we normalize\n+                            // and confirm these obligations once again during confirmation\n+                            normalize_with_depth(\n+                                selcx,\n+                                obligation.param_env,\n+                                obligation.cause.clone(),\n+                                obligation.recursion_depth + 1,\n+                                ty,\n+                            )\n+                            .value\n+                        },\n+                        || {},\n+                    );\n \n-                    // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n-                    ty::Param(_)\n-                    | ty::Projection(..)\n-                    | ty::Opaque(..)\n-                    | ty::Bound(..)\n-                    | ty::Placeholder(..)\n-                    | ty::Infer(..)\n-                    | ty::Error(_) => {\n-                        if tail.has_infer_types() {\n-                            candidate_set.mark_ambiguous();\n+                    match tail.kind() {\n+                        ty::Bool\n+                        | ty::Char\n+                        | ty::Int(_)\n+                        | ty::Uint(_)\n+                        | ty::Float(_)\n+                        | ty::Str\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        | ty::RawPtr(..)\n+                        | ty::Ref(..)\n+                        | ty::FnDef(..)\n+                        | ty::FnPtr(..)\n+                        | ty::Dynamic(..)\n+                        | ty::Closure(..)\n+                        | ty::Generator(..)\n+                        | ty::GeneratorWitness(..)\n+                        | ty::Never\n+                        // Extern types have unit metadata, according to RFC 2850\n+                        | ty::Foreign(_)\n+                        // If returned by `struct_tail_without_normalization` this is a unit struct\n+                        // without any fields, or not a struct, and therefore is Sized.\n+                        | ty::Adt(..)\n+                        // If returned by `struct_tail_without_normalization` this is the empty tuple.\n+                        | ty::Tuple(..)\n+                        // Integers and floats are always Sized, and so have unit type metadata.\n+                        | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                        // type parameters, opaques, and unnormalized projections have pointer\n+                        // metadata if they're known (e.g. by the param_env) to be sized\n+                        ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n+                            if selcx.infcx().predicate_must_hold_modulo_regions(\n+                                &obligation.with(\n+                                    selcx.tcx(),\n+                                    ty::Binder::dummy(\n+                                        selcx.tcx().at(obligation.cause.span()).mk_trait_ref(LangItem::Sized, [self_ty]),\n+                                    )\n+                                    .without_const(),\n+                                ),\n+                            ) =>\n+                        {\n+                            true\n+                        }\n+\n+                        // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n+                        ty::Param(_)\n+                        | ty::Projection(..)\n+                        | ty::Opaque(..)\n+                        | ty::Bound(..)\n+                        | ty::Placeholder(..)\n+                        | ty::Infer(..)\n+                        | ty::Error(_) => {\n+                            if tail.has_infer_types() {\n+                                candidate_set.mark_ambiguous();\n+                            }\n+                            false\n                         }\n-                        false\n                     }\n+                } else {\n+                    bug!(\"unexpected builtin trait with associated type: {poly_trait_ref:?}\")\n                 }\n             }\n             super::ImplSource::Param(..) => {\n@@ -1757,7 +1755,6 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 false\n             }\n             super::ImplSource::AutoImpl(..)\n-            | super::ImplSource::Builtin(..)\n             | super::ImplSource::TraitUpcasting(_)\n             | super::ImplSource::ConstDestruct(_) => {\n                 // These traits have no associated types.\n@@ -1837,14 +1834,10 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::ImplSource::Future(data) => confirm_future_candidate(selcx, obligation, data),\n         super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n         super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::ImplSource::DiscriminantKind(data) => {\n-            confirm_discriminant_kind_candidate(selcx, obligation, data)\n-        }\n-        super::ImplSource::Pointee(data) => confirm_pointee_candidate(selcx, obligation, data),\n+        super::ImplSource::Builtin(data) => confirm_builtin_candidate(selcx, obligation, data),\n         super::ImplSource::Object(_)\n         | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n-        | super::ImplSource::Builtin(..)\n         | super::ImplSource::TraitUpcasting(_)\n         | super::ImplSource::TraitAlias(..)\n         | super::ImplSource::ConstDestruct(_) => {\n@@ -1950,68 +1943,55 @@ fn confirm_future_candidate<'cx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n-fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n+fn confirm_builtin_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    _: ImplSourceDiscriminantKindData,\n+    data: ImplSourceBuiltinData<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n-\n-    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-    // We get here from `poly_project_and_unify_type` which replaces bound vars\n-    // with placeholders\n-    debug_assert!(!self_ty.has_escaping_bound_vars());\n+    let self_ty = obligation.predicate.self_ty();\n     let substs = tcx.mk_substs([self_ty.into()].iter());\n-\n-    let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n-\n-    let predicate = ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy { substs, item_def_id: discriminant_def_id },\n-        term: self_ty.discriminant_ty(tcx).into(),\n+    let lang_items = tcx.lang_items();\n+    let item_def_id = obligation.predicate.item_def_id;\n+    let trait_def_id = tcx.trait_of_item(item_def_id).unwrap();\n+    let (term, obligations) = if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+        let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n+        assert_eq!(discriminant_def_id, item_def_id);\n+\n+        (self_ty.discriminant_ty(tcx).into(), Vec::new())\n+    } else if lang_items.pointee_trait() == Some(trait_def_id) {\n+        let metadata_def_id = tcx.require_lang_item(LangItem::Metadata, None);\n+        assert_eq!(metadata_def_id, item_def_id);\n+\n+        let mut obligations = Vec::new();\n+        let (metadata_ty, check_is_sized) = self_ty.ptr_metadata_ty(tcx, |ty| {\n+            normalize_with_depth_to(\n+                selcx,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                ty,\n+                &mut obligations,\n+            )\n+        });\n+        if check_is_sized {\n+            let sized_predicate = ty::Binder::dummy(\n+                tcx.at(obligation.cause.span()).mk_trait_ref(LangItem::Sized, [self_ty]),\n+            )\n+            .without_const();\n+            obligations.push(obligation.with(tcx, sized_predicate));\n+        }\n+        (metadata_ty.into(), obligations)\n+    } else {\n+        bug!(\"unexpected builtin trait with associated type: {:?}\", obligation.predicate);\n     };\n \n-    // We get here from `poly_project_and_unify_type` which replaces bound vars\n-    // with placeholders, so dummy is okay here.\n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n-}\n-\n-fn confirm_pointee_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    _: ImplSourcePointeeData,\n-) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-\n-    let mut obligations = vec![];\n-    let (metadata_ty, check_is_sized) = self_ty.ptr_metadata_ty(tcx, |ty| {\n-        normalize_with_depth_to(\n-            selcx,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            ty,\n-            &mut obligations,\n-        )\n-    });\n-    if check_is_sized {\n-        let sized_predicate = ty::Binder::dummy(\n-            tcx.at(obligation.cause.span).mk_trait_ref(LangItem::Sized, [self_ty]),\n-        )\n-        .without_const();\n-        obligations.push(obligation.with(tcx, sized_predicate));\n-    }\n-\n-    let substs = tcx.mk_substs([self_ty.into()].iter());\n-    let metadata_def_id = tcx.require_lang_item(LangItem::Metadata, Some(obligation.cause.span));\n-\n-    let predicate = ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy { substs, item_def_id: metadata_def_id },\n-        term: metadata_ty.into(),\n-    };\n+    let predicate =\n+        ty::ProjectionPredicate { projection_ty: ty::ProjectionTy { substs, item_def_id }, term };\n \n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n         .with_addl_obligations(obligations)\n+        .with_addl_obligations(data.nested)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>("}, {"sha": "c1e3a6db4f7c6c72154fcec12fb0b3666d750269", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -282,10 +282,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n             } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n                 // `DiscriminantKind` is automatically implemented for every type.\n-                candidates.vec.push(DiscriminantKindCandidate);\n+                candidates.vec.push(BuiltinCandidate { has_nested: false });\n             } else if lang_items.pointee_trait() == Some(def_id) {\n                 // `Pointee` is automatically implemented for every type.\n-                candidates.vec.push(PointeeCandidate);\n+                candidates.vec.push(BuiltinCandidate { has_nested: false });\n             } else if lang_items.sized_trait() == Some(def_id) {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed."}, {"sha": "3454bd40ffec314d6288d2aa5bce3beedfdad2cf", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -22,12 +22,11 @@ use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n-    ImplSourceConstDestructData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData,\n-    ImplSourceTraitAliasData, ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized,\n-    ObjectCastObligation, Obligation, ObligationCause, OutputTypeParameterMismatch,\n-    PredicateObligation, Selection, SelectionError, TraitNotObjectSafe, TraitObligation,\n-    Unimplemented, VtblSegment,\n+    ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n+    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n+    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n+    Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n };\n \n use super::BuiltinImplConditions;\n@@ -100,12 +99,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplSource::FnPointer(data)\n             }\n \n-            DiscriminantKindCandidate => {\n-                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            }\n-\n-            PointeeCandidate => ImplSource::Pointee(ImplSourcePointeeData),\n-\n             TraitAliasCandidate => {\n                 let data = self.confirm_trait_alias_candidate(obligation);\n                 ImplSource::TraitAlias(data)"}, {"sha": "9467ac7646e862dfa8829a23c428b7f9accddb67", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -1569,20 +1569,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n \n             // (*)\n-            (\n-                BuiltinCandidate { has_nested: false }\n-                | DiscriminantKindCandidate\n-                | PointeeCandidate\n-                | ConstDestructCandidate(_),\n-                _,\n-            ) => true,\n-            (\n-                _,\n-                BuiltinCandidate { has_nested: false }\n-                | DiscriminantKindCandidate\n-                | PointeeCandidate\n-                | ConstDestructCandidate(_),\n-            ) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref"}, {"sha": "4a887bc591827f0c77cf5f09e57a4890bac24e9a", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=9c7dc3e30b6a7c04190ceb96fb9a3f6e9bd1848a", "patch": "@@ -270,8 +270,6 @@ fn resolve_associated_item<'tcx>(\n         traits::ImplSource::AutoImpl(..)\n         | traits::ImplSource::Param(..)\n         | traits::ImplSource::TraitAlias(..)\n-        | traits::ImplSource::DiscriminantKind(..)\n-        | traits::ImplSource::Pointee(..)\n         | traits::ImplSource::TraitUpcasting(_)\n         | traits::ImplSource::ConstDestruct(_) => None,\n     })"}]}