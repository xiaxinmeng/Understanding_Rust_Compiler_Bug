{"sha": "8337fa1a545e7958389c6025661990eedd9c1b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMzdmYTFhNTQ1ZTc5NTgzODljNjAyNTY2MTk5MGVlZGQ5YzFiOTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-20T19:23:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-26T22:56:16Z"}, "message": "Camel case the option type", "tree": {"sha": "c8156400e412fe7e4441a42592f2687915d8f2fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8156400e412fe7e4441a42592f2687915d8f2fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8337fa1a545e7958389c6025661990eedd9c1b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8337fa1a545e7958389c6025661990eedd9c1b91", "html_url": "https://github.com/rust-lang/rust/commit/8337fa1a545e7958389c6025661990eedd9c1b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8337fa1a545e7958389c6025661990eedd9c1b91/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9a6a6365327ac156ef3102e2b7efae1b2be5934", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a6a6365327ac156ef3102e2b7efae1b2be5934", "html_url": "https://github.com/rust-lang/rust/commit/d9a6a6365327ac156ef3102e2b7efae1b2be5934"}], "stats": {"total": 9875, "additions": 4939, "deletions": 4936}, "files": [{"sha": "746769046bc4349471ce8a9e13e10193df6580e9", "filename": "doc/rust.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -842,14 +842,14 @@ An example of imports:\n import foo = core::info;\n import core::float::sin;\n import core::str::{slice, to_upper};\n-import core::option::some;\n+import core::option::Some;\n \n fn main() {\n     // Equivalent to 'log(core::info, core::float::sin(1.0));'\n     log(foo, sin(1.0));\n \n-    // Equivalent to 'log(core::info, core::option::some(1.0));'\n-    log(info, some(1.0));\n+    // Equivalent to 'log(core::info, core::option::Some(1.0));'\n+    log(info, Some(1.0));\n \n     // Equivalent to 'log(core::info,\n     //                    core::str::to_upper(core::str::slice(~\"foo\", 0u, 1u)));'\n@@ -2229,14 +2229,14 @@ consist of a bool-typed expression following the `if` keyword. A pattern\n guard may refer to the variables bound within the pattern they follow.\n \n ~~~~\n-# let maybe_digit = some(0);\n+# let maybe_digit = Some(0);\n # fn process_digit(i: int) { }\n # fn process_other(i: int) { }\n \n let message = match maybe_digit {\n-  some(x) if x < 10 => process_digit(x),\n-  some(x) => process_other(x),\n-  none => fail\n+  Some(x) if x < 10 => process_digit(x),\n+  Some(x) => process_other(x),\n+  None => fail\n };\n ~~~~\n "}, {"sha": "f88baf4a19013ef75b2a5c514dd3072ad5672432", "filename": "doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1964,7 +1964,7 @@ Rust's type inferrer works very well with generics, but there are\n programs that just can't be typed.\n \n ~~~~\n-let n = option::none;\n+let n = option::None;\n # option::iter(n, fn&(&&x:int) {})\n ~~~~\n \n@@ -1974,9 +1974,9 @@ you really want to have such a statement, you'll have to write it like\n this:\n \n ~~~~\n-let n2: option<int> = option::none;\n+let n2: Option<int> = option::None;\n // or\n-let n = option::none::<int>;\n+let n = option::None::<int>;\n ~~~~\n \n Note that, in a value expression, `<` already has a meaning as a"}, {"sha": "2c2170bff7a96bd38c3d36c29bdc37d26d8b8b0a", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 95, "deletions": 95, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -20,7 +20,7 @@ type package = {\n     url: ~str,\n     method: ~str,\n     description: ~str,\n-    reference: option<~str>,\n+    reference: Option<~str>,\n     tags: ~[~str],\n     versions: ~[(~str, ~str)]\n };\n@@ -36,8 +36,8 @@ type source = @{\n     name: ~str,\n     mut url: ~str,\n     mut method: ~str,\n-    mut key: option<~str>,\n-    mut keyfp: option<~str>,\n+    mut key: Option<~str>,\n+    mut keyfp: Option<~str>,\n     mut packages: ~[mut package]\n };\n \n@@ -59,9 +59,9 @@ type crate = {\n     name: ~str,\n     vers: ~str,\n     uuid: ~str,\n-    desc: option<~str>,\n-    sigs: option<~str>,\n-    crate_type: option<~str>,\n+    desc: Option<~str>,\n+    sigs: Option<~str>,\n+    crate_type: Option<~str>,\n     deps: ~[~str]\n };\n \n@@ -193,7 +193,7 @@ fn is_archive_url(u: ~str) -> bool {\n     // url parsing, we wouldn't need it\n \n     match str::find_str(u, ~\"://\") {\n-        option::some(_) => has_archive_extension(u),\n+        option::Some(_) => has_archive_extension(u),\n         _ => false\n     }\n }\n@@ -216,19 +216,19 @@ fn assume_source_method(url: ~str) -> ~str {\n     ~\"curl\"\n }\n \n-fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n-                                         option<~str>,\n-                                         option<~str>) {\n-    let mut name = none;\n-    let mut vers = none;\n-    let mut uuid = none;\n+fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                         Option<~str>,\n+                                         Option<~str>) {\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n     for mis.each |a| {\n         match a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n                 match v {\n-                    ~\"name\" => name = some(*s),\n-                    ~\"vers\" => vers = some(*s),\n-                    ~\"uuid\" => uuid = some(*s),\n+                    ~\"name\" => name = Some(*s),\n+                    ~\"vers\" => vers = Some(*s),\n+                    ~\"uuid\" => uuid = Some(*s),\n                     _ => { }\n                 }\n             }\n@@ -238,24 +238,24 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: &Path) -> option<crate> {\n-    let sess = parse::new_parse_sess(none);\n+fn load_crate(filename: &Path) -> Option<crate> {\n+    let sess = parse::new_parse_sess(None);\n     let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n \n-    let mut name = none;\n-    let mut vers = none;\n-    let mut uuid = none;\n-    let mut desc = none;\n-    let mut sigs = none;\n-    let mut crate_type = none;\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    let mut desc = None;\n+    let mut sigs = None;\n+    let mut crate_type = None;\n \n     for c.node.attrs.each |a| {\n         match a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n                 match v {\n-                    ~\"desc\" => desc = some(v),\n-                    ~\"sigs\" => sigs = some(v),\n-                    ~\"crate_type\" => crate_type = some(v),\n+                    ~\"desc\" => desc = Some(v),\n+                    ~\"sigs\" => sigs = Some(v),\n+                    ~\"crate_type\" => crate_type = Some(v),\n                     _ => { }\n                 }\n             }\n@@ -296,7 +296,7 @@ fn load_crate(filename: &Path) -> option<crate> {\n \n               for m.each |item| {\n                     match attr::get_meta_item_value_str(item) {\n-                        some(value) => {\n+                        Some(value) => {\n                             let name = attr::get_meta_item_name(item);\n \n                             match name {\n@@ -305,7 +305,7 @@ fn load_crate(filename: &Path) -> option<crate> {\n                                 _ => ()\n                             }\n                         }\n-                        none => ()\n+                        None => ()\n                     }\n                 }\n \n@@ -342,8 +342,8 @@ fn load_crate(filename: &Path) -> option<crate> {\n     let deps = copy e.deps;\n \n     match (name, vers, uuid) {\n-        (some(name0), some(vers0), some(uuid0)) => {\n-            some({\n+        (Some(name0), Some(vers0), Some(uuid0)) => {\n+            Some({\n                 name: name0,\n                 vers: vers0,\n                 uuid: uuid0,\n@@ -352,7 +352,7 @@ fn load_crate(filename: &Path) -> option<crate> {\n                 crate_type: crate_type,\n                 deps: deps })\n         }\n-        _ => return none\n+        _ => return None\n     }\n }\n \n@@ -395,20 +395,20 @@ fn parse_source(name: ~str, j: json::json) -> source {\n     match j {\n         json::dict(j) => {\n             let mut url = match j.find(~\"url\") {\n-                some(json::string(u)) => *u,\n+                Some(json::string(u)) => *u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n             let method = match j.find(~\"method\") {\n-                some(json::string(u)) => *u,\n+                Some(json::string(u)) => *u,\n                 _ => assume_source_method(url)\n             };\n             let key = match j.find(~\"key\") {\n-                some(json::string(u)) => some(*u),\n-                _ => none\n+                Some(json::string(u)) => Some(*u),\n+                _ => None\n             };\n             let keyfp = match j.find(~\"keyfp\") {\n-                some(json::string(u)) => some(*u),\n-                _ => none\n+                Some(json::string(u)) => Some(*u),\n+                _ => None\n             };\n             if method == ~\"file\" {\n                 url = os::make_absolute(&Path(url)).to_str();\n@@ -442,7 +442,7 @@ fn try_parse_sources(filename: &Path, sources: map::hashmap<~str, source>) {\n \n fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     let name = match p.find(~\"name\") {\n-        some(json::string(n)) => {\n+        Some(json::string(n)) => {\n             if !valid_pkg_name(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -459,7 +459,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let uuid = match p.find(~\"uuid\") {\n-        some(json::string(n)) => {\n+        Some(json::string(n)) => {\n             if !is_uuid(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -475,15 +475,15 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let url = match p.find(~\"url\") {\n-        some(json::string(n)) => *n,\n+        Some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n     let method = match p.find(~\"method\") {\n-        some(json::string(n)) => *n,\n+        Some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n@@ -492,13 +492,13 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let reference = match p.find(~\"ref\") {\n-        some(json::string(n)) => some(*n),\n-        _ => none\n+        Some(json::string(n)) => Some(*n),\n+        _ => None\n     };\n \n     let mut tags = ~[];\n     match p.find(~\"tags\") {\n-        some(json::list(js)) => {\n+        Some(json::list(js)) => {\n           for (*js).each |j| {\n                 match j {\n                     json::string(j) => vec::grow(tags, 1u, *j),\n@@ -510,7 +510,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     }\n \n     let description = match p.find(~\"description\") {\n-        some(json::string(n)) => *n,\n+        Some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n@@ -530,11 +530,11 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     match vec::position(src.packages, |pkg| pkg.uuid == uuid) {\n-      some(idx) => {\n+      Some(idx) => {\n         src.packages[idx] = newpkg;\n         log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n       }\n-      none => {\n+      None => {\n         vec::grow(src.packages, 1u, newpkg);\n       }\n     }\n@@ -704,7 +704,7 @@ fn run_programs(buildpath: &Path) {\n // Runs rustc in <path + subdir> with the given flags\n // and returns <patho + subdir>\n fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n-                    extra_flags: ~[~str]) -> option<Path> {\n+                    extra_flags: ~[~str]) -> Option<Path> {\n     let buildpath = path.push_rel(subdir);\n     need_dir(&buildpath);\n     debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n@@ -714,18 +714,18 @@ fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n                                   cf.to_str()] + extra_flags);\n     if p.status != 0 {\n         error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n-        return none;\n+        return None;\n     }\n-    some(buildpath)\n+    Some(buildpath)\n }\n \n fn test_one_crate(_c: cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"testing\", path,\n                                            &Path(\"test\"),\n                                            cf,\n                                            ~[ ~\"--test\"]) {\n-      none => return,\n-    some(bp) => bp\n+      None => return,\n+    Some(bp) => bp\n   };\n   run_programs(&buildpath);\n }\n@@ -734,8 +734,8 @@ fn install_one_crate(c: cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"installing\", path,\n                                            &Path(\"build\"),\n                                            cf, ~[]) {\n-      none => return,\n-      some(bp) => bp\n+      None => return,\n+      Some(bp) => bp\n     };\n     let newv = os::list_dir_path(&buildpath);\n     let exec_suffix = os::exe_suffix();\n@@ -762,12 +762,12 @@ fn install_one_crate(c: cargo, path: &Path, cf: &Path) {\n \n fn rustc_sysroot() -> ~str {\n     match os::self_exe_path() {\n-        some(path) => {\n+        Some(path) => {\n             let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n             debug!(\"  rustc: %s\", rustc.to_str());\n             rustc.to_str()\n         }\n-        none => ~\"rustc\"\n+        None => ~\"rustc\"\n     }\n }\n \n@@ -777,7 +777,7 @@ fn install_source(c: cargo, path: &Path) {\n \n     let mut cratefiles = ~[];\n     for os::walk_dir(&Path(\".\")) |p| {\n-        if p.filetype() == some(~\"rc\") {\n+        if p.filetype() == Some(~\"rc\") {\n             vec::push(cratefiles, *p);\n         }\n     }\n@@ -788,8 +788,8 @@ fn install_source(c: cargo, path: &Path) {\n \n     for cratefiles.each |cf| {\n         match load_crate(&cf) {\n-            none => again,\n-            some(crate) => {\n+            None => again,\n+            Some(crate) => {\n               for crate.deps.each |query| {\n                     // FIXME (#1356): handle cyclic dependencies\n                     // (n.b. #1356 says \"Cyclic dependency is an error\n@@ -810,7 +810,7 @@ fn install_source(c: cargo, path: &Path) {\n     }\n }\n \n-fn install_git(c: cargo, wd: &Path, url: ~str, reference: option<~str>) {\n+fn install_git(c: cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if option::is_some(reference) {\n         let r = option::get(reference);\n@@ -919,7 +919,7 @@ fn install_named(c: cargo, wd: &Path, name: ~str) {\n \n fn install_uuid_specific(c: cargo, wd: &Path, src: ~str, uuid: ~str) {\n     match c.sources.find(src) {\n-      some(s) => {\n+      Some(s) => {\n         let packages = copy s.packages;\n         if vec::any(packages, |p| {\n             if p.uuid == uuid {\n@@ -935,7 +935,7 @@ fn install_uuid_specific(c: cargo, wd: &Path, src: ~str, uuid: ~str) {\n \n fn install_named_specific(c: cargo, wd: &Path, src: ~str, name: ~str) {\n     match c.sources.find(src) {\n-        some(s) => {\n+        Some(s) => {\n           let packages = copy s.packages;\n           if vec::any(packages, |p| {\n                 if p.name == name {\n@@ -978,22 +978,22 @@ fn cmd_uninstall(c: cargo) {\n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n             match str::find_str(file, ~\"-\" + target + ~\"-\") {\n-              some(_) => if !try_uninstall(&lib.push(file)) { return },\n-              none => ()\n+              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              None => ()\n             }\n         }\n         error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n             match str::find_str(file, ~\"lib\" + target + ~\"-\") {\n-              some(_) => if !try_uninstall(&lib.push(file)) { return },\n-              none => ()\n+              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              None => ()\n             }\n         }\n         for os::list_dir(bin).each |file| {\n             match str::find_str(file, target) {\n-              some(_) => if !try_uninstall(&lib.push(file)) { return },\n-              none => ()\n+              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+              None => ()\n             }\n         }\n \n@@ -1003,12 +1003,12 @@ fn cmd_uninstall(c: cargo) {\n \n fn install_query(c: cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n-        some(inst) => {\n+        Some(inst) => {\n             if inst {\n                 return;\n             }\n         }\n-        none => ()\n+        None => ()\n     }\n \n     c.dep_cache.insert(target, true);\n@@ -1018,9 +1018,9 @@ fn install_query(c: cargo, wd: &Path, target: ~str) {\n         return;\n     } else if is_git_url(target) {\n         let reference = if c.opts.free.len() >= 4u {\n-            some(c.opts.free[3u])\n+            Some(c.opts.free[3u])\n         } else {\n-            none\n+            None\n         };\n         install_git(c, wd, target, reference);\n     } else if !valid_pkg_name(target) && has_archive_extension(target) {\n@@ -1030,7 +1030,7 @@ fn install_query(c: cargo, wd: &Path, target: ~str) {\n         let mut ps = copy target;\n \n         match str::find_char(ps, '/') {\n-            option::some(idx) => {\n+            option::Some(idx) => {\n                 let source = str::slice(ps, 0u, idx);\n                 ps = str::slice(ps, idx + 1u, str::len(ps));\n                 if is_uuid(ps) {\n@@ -1039,7 +1039,7 @@ fn install_query(c: cargo, wd: &Path, target: ~str) {\n                     install_named_specific(c, wd, source, ps);\n                 }\n             }\n-            option::none => {\n+            option::None => {\n                 if is_uuid(ps) {\n                     install_uuid(c, wd, ps);\n                 } else {\n@@ -1063,8 +1063,8 @@ fn install_query(c: cargo, wd: &Path, target: ~str) {\n \n fn get_temp_workdir(c: cargo) -> Path {\n     match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n-      some(wd) => wd,\n-      none => fail fmt!(\"needed temp dir: %s\",\n+      Some(wd) => wd,\n+      None => fail fmt!(\"needed temp dir: %s\",\n                         c.workdir.to_str())\n     }\n }\n@@ -1127,7 +1127,7 @@ fn sync_one_file(c: cargo, dir: &Path, src: source) -> bool {\n     os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n \n     match copy src.key {\n-        some(u) => {\n+        Some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\",\n                                           ~\"-o\", keyfile.to_str(), u]);\n@@ -1140,7 +1140,7 @@ fn sync_one_file(c: cargo, dir: &Path, src: source) -> bool {\n         _ => ()\n     }\n     match (src.key, src.keyfp) {\n-        (some(_), some(f)) => {\n+        (Some(_), Some(f)) => {\n             let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n \n             if !r {\n@@ -1237,7 +1237,7 @@ fn sync_one_git(c: cargo, dir: &Path, src: source) -> bool {\n     let has_src_file = os::path_exists(&srcfile);\n \n     match copy src.key {\n-        some(u) => {\n+        Some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\",\n                                           ~\"-o\", keyfile.to_str(), u]);\n@@ -1251,7 +1251,7 @@ fn sync_one_git(c: cargo, dir: &Path, src: source) -> bool {\n         _ => ()\n     }\n     match (src.key, src.keyfp) {\n-        (some(_), some(f)) => {\n+        (Some(_), Some(f)) => {\n             let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n \n             if !r {\n@@ -1320,7 +1320,7 @@ fn sync_one_curl(c: cargo, dir: &Path, src: source) -> bool {\n     }\n \n     match copy src.key {\n-        some(u) => {\n+       Some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\",\n                                           ~\"-o\", keyfile.to_str(), u]);\n@@ -1333,7 +1333,7 @@ fn sync_one_curl(c: cargo, dir: &Path, src: source) -> bool {\n         _ => ()\n     }\n     match (src.key, src.keyfp) {\n-        (some(_), some(f)) => {\n+        (Some(_), Some(f)) => {\n             if smart {\n                 url = src.url + ~\"/packages.json.sig\";\n             }\n@@ -1498,10 +1498,10 @@ fn cmd_list(c: cargo) {\n                 error(fmt!(\"'%s' is an invalid source name\", name));\n             } else {\n                 match c.sources.find(name) {\n-                    some(source) => {\n+                    Some(source) => {\n                         print_source(source);\n                     }\n-                    none => {\n+                    None => {\n                         error(fmt!(\"no such source: %s\", name));\n                     }\n                 }\n@@ -1583,13 +1583,13 @@ fn dump_sources(c: cargo) {\n                 chash.insert(~\"method\", json::string(@v.method));\n \n                 match copy v.key {\n-                    some(key) => {\n+                    Some(key) => {\n                         chash.insert(~\"key\", json::string(@key));\n                     }\n                     _ => ()\n                 }\n                 match copy v.keyfp {\n-                    some(keyfp) => {\n+                    Some(keyfp) => {\n                         chash.insert(~\"keyfp\", json::string(@keyfp));\n                     }\n                     _ => ()\n@@ -1653,8 +1653,8 @@ fn cmd_sources(c: cargo) {\n                     name: name,\n                     mut url: url,\n                     mut method: assume_source_method(url),\n-                    mut key: none,\n-                    mut keyfp: none,\n+                    mut key: None,\n+                    mut keyfp: None,\n                     mut packages: ~[mut]\n                 });\n                 info(fmt!(\"added source: %s\", name));\n@@ -1695,7 +1695,7 @@ fn cmd_sources(c: cargo) {\n             }\n \n             match c.sources.find(name) {\n-                some(source) => {\n+                Some(source) => {\n                     let old = copy source.url;\n                     let method = assume_source_method(url);\n \n@@ -1706,7 +1706,7 @@ fn cmd_sources(c: cargo) {\n \n                     info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n                 }\n-                none => {\n+                None => {\n                     error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n@@ -1726,7 +1726,7 @@ fn cmd_sources(c: cargo) {\n             }\n \n             match c.sources.find(name) {\n-                some(source) => {\n+                Some(source) => {\n                     let old = copy source.method;\n \n                     source.method = match method {\n@@ -1740,7 +1740,7 @@ fn cmd_sources(c: cargo) {\n                     info(fmt!(\"changed source method: '%s' to '%s'\", old,\n                          method));\n                 }\n-                none => {\n+                None => {\n                     error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n@@ -1764,12 +1764,12 @@ fn cmd_sources(c: cargo) {\n             }\n \n             match c.sources.find(name) {\n-                some(source) => {\n+                Some(source) => {\n                     c.sources.remove(name);\n                     c.sources.insert(newn, source);\n                     info(fmt!(\"renamed source: %s to %s\", name, newn));\n                 }\n-                none => {\n+                None => {\n                     error(fmt!(\"no such source: %s\", name));\n                 }\n             }"}, {"sha": "b5a20f49de43b40fccc4d81c0e5ff71cf4409728", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -31,17 +31,17 @@ type config = {\n     run_ignored: bool,\n \n     // Only run tests that match this filter\n-    filter: option<~str>,\n+    filter: Option<~str>,\n \n     // Write out a parseable log of tests that were run\n-    logfile: option<Path>,\n+    logfile: Option<Path>,\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n-    runtool: option<~str>,\n+    runtool: Option<~str>,\n \n     // Flags to pass to the compiler\n-    rustcflags: option<~str>,\n+    rustcflags: Option<~str>,\n \n     // Explain what's going on\n     verbose: bool};"}, {"sha": "072cec2e8a82a94617fcf44a301895876385c0e0", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -57,8 +57,8 @@ fn parse_config(args: ~[~str]) -> config {\n          run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n          filter:\n              if vec::len(matches.free) > 0u {\n-                 option::some(matches.free[0])\n-             } else { option::none },\n+                 option::Some(matches.free[0])\n+             } else { option::None },\n          logfile: option::map(getopts::opt_maybe_str(matches,\n                                                      ~\"logfile\"),\n                               |s| Path(s)),\n@@ -85,12 +85,12 @@ fn log_config(config: config) {\n     logv(c, fmt!(\"\\n\"));\n }\n \n-fn opt_str(maybestr: option<~str>) -> ~str {\n-    match maybestr { option::some(s) => s, option::none => ~\"(none)\" }\n+fn opt_str(maybestr: Option<~str>) -> ~str {\n+    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n }\n \n-fn str_opt(maybestr: ~str) -> option<~str> {\n-    if maybestr != ~\"(none)\" { option::some(maybestr) } else { option::none }\n+fn str_opt(maybestr: ~str) -> Option<~str> {\n+    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n }\n \n fn str_mode(s: ~str) -> mode {\n@@ -122,14 +122,14 @@ fn run_tests(config: config) {\n fn test_opts(config: config) -> test::test_opts {\n     {filter:\n          match config.filter {\n-           option::some(s) => option::some(s),\n-           option::none => option::none\n+           option::Some(s) => option::Some(s),\n+           option::None => option::None\n          },\n      run_ignored: config.run_ignored,\n      logfile:\n          match config.logfile {\n-           option::some(s) => option::some(s.to_str()),\n-           option::none => option::none\n+           option::Some(s) => option::Some(s.to_str()),\n+           option::None => option::None\n          }\n     }\n }"}, {"sha": "d321cde31421525a34b71db0afb6a3f0db49e003", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -23,8 +23,8 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     let error_tag = ~\"//~\";\n     let mut idx;\n     match str::find_str(line, error_tag) {\n-      option::none => return ~[],\n-      option::some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+      option::None => return ~[],\n+      option::Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n     }\n \n     // \"//~^^^ kind msg\" denotes a message expected"}, {"sha": "0458d86f4661f5d3f6b3ff1e7e90683a276a5123", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -12,10 +12,10 @@ type test_props = {\n     // Lines that should be expected, in order, on standard out\n     error_patterns: ~[~str],\n     // Extra flags to pass to the compiler\n-    compile_flags: option<~str>,\n+    compile_flags: Option<~str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option<Path>,\n+    pp_exact: Option<Path>,\n     // Modules from aux directory that should be compiled\n     aux_builds: ~[~str],\n     // Environment settings to use during execution\n@@ -27,12 +27,12 @@ fn load_props(testfile: &Path) -> test_props {\n     let mut error_patterns = ~[];\n     let mut aux_builds = ~[];\n     let mut exec_env = ~[];\n-    let mut compile_flags = option::none;\n-    let mut pp_exact = option::none;\n+    let mut compile_flags = option::None;\n+    let mut pp_exact = option::None;\n     for iter_header(testfile) |ln| {\n         match parse_error_pattern(ln) {\n-          option::some(ep) => vec::push(error_patterns, ep),\n-          option::none => ()\n+          option::Some(ep) => vec::push(error_patterns, ep),\n+          option::None => ()\n         };\n \n         if option::is_none(compile_flags) {\n@@ -91,19 +91,19 @@ fn iter_header(testfile: &Path, it: fn(~str) -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: ~str) -> option<~str> {\n+fn parse_error_pattern(line: ~str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"error-pattern\")\n }\n \n-fn parse_aux_build(line: ~str) -> option<~str> {\n+fn parse_aux_build(line: ~str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"aux-build\")\n }\n \n-fn parse_compile_flags(line: ~str) -> option<~str> {\n+fn parse_compile_flags(line: ~str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"compile-flags\")\n }\n \n-fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n+fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n@@ -115,14 +115,14 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n     }\n }\n \n-fn parse_pp_exact(line: ~str, testfile: &Path) -> option<Path> {\n+fn parse_pp_exact(line: ~str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n-      option::some(s) => option::some(Path(s)),\n-      option::none => {\n+      option::Some(s) => option::Some(Path(s)),\n+      option::None => {\n         if parse_name_directive(line, ~\"pp-exact\") {\n-            option::some(testfile.file_path())\n+            option::Some(testfile.file_path())\n         } else {\n-            option::none\n+            option::None\n         }\n       }\n     }\n@@ -133,15 +133,15 @@ fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n }\n \n fn parse_name_value_directive(line: ~str,\n-                              directive: ~str) -> option<~str> unsafe {\n+                              directive: ~str) -> Option<~str> unsafe {\n     let keycolon = directive + ~\":\";\n     match str::find_str(line, keycolon) {\n-        option::some(colon) => {\n+        option::Some(colon) => {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));\n             debug!(\"%s: %s\", directive,  value);\n-            option::some(value)\n+            option::Some(value)\n         }\n-        option::none => option::none\n+        option::None => option::None\n     }\n }"}, {"sha": "f2e9e03d7dbae546174ceb6acfa9ce37e3a97bf3", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -38,14 +38,14 @@ fn run(lib_path: ~str,\n        prog: ~str,\n        args: ~[~str],\n        env: ~[(~str, ~str)],\n-       input: option<~str>) -> {status: int, out: ~str, err: ~str} {\n+       input: Option<~str>) -> {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n     let pid = spawn_process(prog, args,\n-                            &some(env + target_env(lib_path, prog)),\n-                            &none, pipe_in.in, pipe_out.out, pipe_err.out);\n+                            &Some(env + target_env(lib_path, prog)),\n+                            &None, pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n     os::close(pipe_out.out);\n@@ -89,7 +89,7 @@ fn run(lib_path: ~str,\n     return {status: status, out: outs, err: errs};\n }\n \n-fn writeclose(fd: c_int, s: option<~str>) {\n+fn writeclose(fd: c_int, s: Option<~str>) {\n     if option::is_some(s) {\n         let writer = io::fd_writer(fd, false);\n         writer.write_str(option::get(s));"}, {"sha": "f93dda87f3820ab744bdc296186f6ec0857475c0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -91,7 +91,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n \n     let rounds =\n-        match props.pp_exact { option::some(_) => 1, option::none => 2 };\n+        match props.pp_exact { option::Some(_) => 1, option::None => 2 };\n \n     let mut srcs = ~[result::get(io::read_whole_file_str(testfile))];\n \n@@ -111,11 +111,11 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n \n     let mut expected =\n         match props.pp_exact {\n-          option::some(file) => {\n+          option::Some(file) => {\n             let filepath = testfile.dir_path().push_rel(&file);\n             result::get(io::read_whole_file_str(&filepath))\n           }\n-          option::none => { srcs[vec::len(srcs) - 2u] }\n+          option::None => { srcs[vec::len(srcs) - 2u] }\n         };\n     let mut actual = srcs[vec::len(srcs) - 1u];\n \n@@ -139,7 +139,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n \n     fn print_source(config: config, testfile: &Path, src: ~str) -> procres {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n-                        ~[], config.compile_lib_path, option::some(src))\n+                        ~[], config.compile_lib_path, option::Some(src))\n     }\n \n     fn make_pp_args(config: config, _testfile: &Path) -> procargs {\n@@ -173,7 +173,7 @@ actual:\\n\\\n         compose_and_run_compiler(\n             config, props, testfile,\n             make_typecheck_args(config, testfile),\n-            option::some(src))\n+            option::Some(src))\n     }\n \n     fn make_typecheck_args(config: config, testfile: &Path) -> procargs {\n@@ -300,23 +300,23 @@ fn compile_test(config: config, props: test_props,\n         config, props, testfile,\n         make_compile_args(config, props, link_args,\n                           make_exe_name, testfile),\n-        none)\n+        None)\n }\n \n fn exec_compiled_test(config: config, props: test_props,\n                       testfile: &Path) -> procres {\n     compose_and_run(config, testfile,\n                     make_run_args(config, props, testfile),\n                     props.exec_env,\n-                    config.run_lib_path, option::none)\n+                    config.run_lib_path, option::None)\n }\n \n fn compose_and_run_compiler(\n     config: config,\n     props: test_props,\n     testfile: &Path,\n     args: procargs,\n-    input: option<~str>) -> procres {\n+    input: Option<~str>) -> procres {\n \n     if props.aux_builds.is_not_empty() {\n         ensure_dir(&aux_output_dir_name(config, testfile));\n@@ -331,7 +331,7 @@ fn compose_and_run_compiler(\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);\n         let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n-                                     config.compile_lib_path, option::none);\n+                                     config.compile_lib_path, option::None);\n         if auxres.status != 0 {\n             fatal_procres(\n                 fmt!(\"auxiliary build of %s failed to compile: \",\n@@ -355,7 +355,7 @@ fn compose_and_run(config: config, testfile: &Path,\n                    procargs: procargs,\n                    procenv: ~[(~str, ~str)],\n                    lib_path: ~str,\n-                   input: option<~str>) -> procres {\n+                   input: Option<~str>) -> procres {\n     return program_output(config, testfile, lib_path,\n                        procargs.prog, procargs.args, procenv, input);\n }\n@@ -391,8 +391,8 @@ fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n             // then split apart its command\n             let runtool =\n                 match config.runtool {\n-                  option::some(s) => option::some(s),\n-                  option::none => option::none\n+                  option::Some(s) => option::Some(s),\n+                  option::None => option::None\n                 };\n             split_maybe_args(runtool)\n         };\n@@ -401,23 +401,23 @@ fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n     return {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n+fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n     fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        fn flt(&&s: ~str) -> option<~str> {\n-          if !str::is_whitespace(s) { option::some(s) } else { option::none }\n+        fn flt(&&s: ~str) -> Option<~str> {\n+          if !str::is_whitespace(s) { option::Some(s) } else { option::None }\n         }\n         vec::filter_map(v, flt)\n     }\n \n     match argstr {\n-      option::some(s) => rm_whitespace(str::split_char(s, ' ')),\n-      option::none => ~[]\n+      option::Some(s) => rm_whitespace(str::split_char(s, ' ')),\n+      option::None => ~[]\n     }\n }\n \n fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n                   args: ~[~str], env: ~[(~str, ~str)],\n-                  input: option<~str>) -> procres {\n+                  input: Option<~str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);"}, {"sha": "30ba4c0a34358fa3f85aa4be484e164574268274", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -8,10 +8,10 @@ fn make_new_path(path: ~str) -> ~str {\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match getenv(lib_path_env_var()) {\n-      option::some(curr) => {\n+      option::Some(curr) => {\n         fmt!(\"%s%s%s\", path, path_div(), curr)\n       }\n-      option::none => path\n+      option::None => path\n     }\n }\n "}, {"sha": "eb9fb2df297551047320e6389fa6c0674d4d545f", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -19,7 +19,7 @@ fn contains(haystack: ~str, needle: ~str) -> bool {\n }\n \n fn find_rust_files(files: &mut ~[Path], path: &Path) {\n-    if path.filetype() == some(~\"rs\") && !contains(path.to_str(), ~\"utf8\") {\n+    if path.filetype() == Some(~\"rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n         vec::push(*files, *path);\n     } else if os::path_is_dir(path)\n@@ -41,12 +41,12 @@ fn common_exprs() -> ~[ast::expr] {\n         { node: l, span: ast_util::dummy_sp() }\n     }\n \n-    ~[dse(ast::expr_break(option::none)),\n-     dse(ast::expr_again(option::none)),\n-     dse(ast::expr_fail(option::none)),\n-     dse(ast::expr_fail(option::some(\n+    ~[dse(ast::expr_break(option::None)),\n+     dse(ast::expr_again(option::None)),\n+     dse(ast::expr_fail(option::None)),\n+     dse(ast::expr_fail(option::Some(\n          @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n-     dse(ast::expr_ret(option::none)),\n+     dse(ast::expr_ret(option::None)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n@@ -76,11 +76,11 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           ast::expr_binary(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) => { false }\n \n-          ast::expr_fail(option::none) |\n-          ast::expr_ret(option::none) => { false }\n+          ast::expr_fail(option::None) |\n+          ast::expr_ret(option::None) => { false }\n \n           // https://github.com/mozilla/rust/issues/953\n-          ast::expr_fail(option::some(_)) => { false }\n+          ast::expr_fail(option::Some(_)) => { false }\n \n           // https://github.com/mozilla/rust/issues/928\n           //ast::expr_cast(_, _) { false }\n@@ -259,7 +259,7 @@ fn check_variants_T<T: copy>(\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n-                let handler = diagnostic::mk_handler(none);\n+                let handler = diagnostic::mk_handler(None);\n                 let str3 = do io::with_str_reader(\"\") |rdr| {\n                     @as_str(|a|pprust::print_crate(\n                         codemap,\n@@ -418,7 +418,7 @@ fn check_compiling(filename: &Path) -> happiness {\n \n fn parse_and_print(code: @~str) -> ~str {\n     let filename = Path(\"tmp.rs\");\n-    let sess = parse::new_parse_sess(option::none);\n+    let sess = parse::new_parse_sess(option::None);\n     write_file(&filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n         filename.to_str(), code, ~[], sess);\n@@ -570,7 +570,7 @@ fn check_variants(files: &[Path], cx: context) {\n         }\n \n         log(error, ~\"check_variants: \" + file.to_str());\n-        let sess = parse::new_parse_sess(option::none);\n+        let sess = parse::new_parse_sess(option::None);\n         let crate =\n             parse::parse_crate_from_source_str(\n                 file.to_str(),"}, {"sha": "569d54262706e2ed0471993969c96c706cb9648c", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -82,7 +82,7 @@ pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: option<uint>,\n+pure fn build_sized_opt<A>(size: Option<uint>,\n                            builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(size.get_default(4), builder)\n }"}, {"sha": "58ea0787b7c2447d3a47489b7f5788eaaee789ce", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -42,13 +42,13 @@ pure fn is_true(v: bool) -> bool { v }\n pure fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n-pure fn from_str(s: &str) -> option<bool> {\n+pure fn from_str(s: &str) -> Option<bool> {\n     if s == \"true\" {\n-        some(true)\n+        Some(true)\n     } else if s == \"false\" {\n-        some(false)\n+        Some(false)\n     } else {\n-        none\n+        None\n     }\n }\n \n@@ -70,7 +70,7 @@ pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n #[test]\n fn test_bool_from_str() {\n     do all_values |v| {\n-        assert some(v) == from_str(bool::to_str(v))\n+        assert Some(v) == from_str(bool::to_str(v))\n     }\n }\n "}, {"sha": "8fc0a578d8c05b662f0201d560344a2cbda3bb9a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -116,15 +116,15 @@ pure fn is_digit(c: char) -> bool {\n  * 'b' or 'B', 11, etc. Returns none if the char does not\n  * refer to a digit in the given radix.\n  */\n-pure fn to_digit(c: char, radix: uint) -> option<uint> {\n+pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n     let val = match c {\n       '0' to '9' => c as uint - ('0' as uint),\n       'a' to 'z' => c as uint + 10u - ('a' as uint),\n       'A' to 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return none\n+      _ => return None\n     };\n-    if val < radix { some(val) }\n-    else { none }\n+    if val < radix { Some(val) }\n+    else { None }\n }\n \n /**\n@@ -219,19 +219,19 @@ fn test_is_whitespace() {\n \n #[test]\n fn test_to_digit() {\n-    assert to_digit('0', 10u) == some(0u);\n-    assert to_digit('1', 2u) == some(1u);\n-    assert to_digit('2', 3u) == some(2u);\n-    assert to_digit('9', 10u) == some(9u);\n-    assert to_digit('a', 16u) == some(10u);\n-    assert to_digit('A', 16u) == some(10u);\n-    assert to_digit('b', 16u) == some(11u);\n-    assert to_digit('B', 16u) == some(11u);\n-    assert to_digit('z', 36u) == some(35u);\n-    assert to_digit('Z', 36u) == some(35u);\n+    assert to_digit('0', 10u) == Some(0u);\n+    assert to_digit('1', 2u) == Some(1u);\n+    assert to_digit('2', 3u) == Some(2u);\n+    assert to_digit('9', 10u) == Some(9u);\n+    assert to_digit('a', 16u) == Some(10u);\n+    assert to_digit('A', 16u) == Some(10u);\n+    assert to_digit('b', 16u) == Some(11u);\n+    assert to_digit('B', 16u) == Some(11u);\n+    assert to_digit('z', 36u) == Some(35u);\n+    assert to_digit('Z', 36u) == Some(35u);\n \n-    assert to_digit(' ', 10u) == none;\n-    assert to_digit('$', 36u) == none;\n+    assert to_digit(' ', 10u) == None;\n+    assert to_digit('$', 36u) == None;\n }\n \n #[test]"}, {"sha": "afa5216ab511cdd00be9a7c51e535730b111a16e", "filename": "src/libcore/core.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -2,8 +2,11 @@\n \n // Export various ubiquitous types, constructors, methods.\n \n-import option::{some, none};\n-import option = option::option;\n+import option::{Some, None};\n+import Option = option::Option;\n+// XXX: snapshot rustc is generating code that wants lower-case option\n+#[cfg(stage0)]\n+import option = option::Option;\n \n import Path = path2::Path;\n import GenericPath = path2::GenericPath;\n@@ -20,7 +23,7 @@ import ptr::Ptr;\n import to_str::ToStr;\n \n export Path, WindowsPath, PosixPath, GenericPath;\n-export option, some, none, unreachable;\n+export Option, Some, None, unreachable;\n export extensions;\n // The following exports are the extension impls for numeric types\n export Num, Times, TimesIx;"}, {"sha": "131b14e59c6219ddbfa8f0fffbcd85b7609d19f2", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -11,7 +11,7 @@\n export DList, dlist, dlist_node;\n export new_dlist, from_elem, from_vec, extensions;\n \n-type DListLink<T> = option<DListNode<T>>;\n+type DListLink<T> = Option<DListNode<T>>;\n \n enum DListNode<T> = @{\n     data: T,\n@@ -29,62 +29,62 @@ enum DList<T> = @{\n priv impl<T> DListNode<T> {\n     pure fn assert_links() {\n         match self.next {\n-            some(neighbour) => match neighbour.prev {\n-              some(me) => if !box::ptr_eq(*self, *me) {\n+            Some(neighbour) => match neighbour.prev {\n+              Some(me) => if !box::ptr_eq(*self, *me) {\n                   fail ~\"Asymmetric next-link in dlist node.\"\n               },\n-              none => fail ~\"One-way next-link in dlist node.\"\n+              None => fail ~\"One-way next-link in dlist node.\"\n             },\n-            none => ()\n+            None => ()\n         }\n         match self.prev {\n-            some(neighbour) => match neighbour.next {\n-              some(me) => if !box::ptr_eq(*me, *self) {\n+            Some(neighbour) => match neighbour.next {\n+              Some(me) => if !box::ptr_eq(*me, *self) {\n                   fail ~\"Asymmetric prev-link in dlist node.\"\n               },\n-              none => fail ~\"One-way prev-link in dlist node.\"\n+              None => fail ~\"One-way prev-link in dlist node.\"\n             },\n-            none => ()\n+            None => ()\n         }\n     }\n }\n \n impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link() -> option<DListNode<T>> {\n+    pure fn next_link() -> Option<DListNode<T>> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n     pure fn next_node() -> DListNode<T> {\n         match self.next_link() {\n-            some(nobe) => nobe,\n-            none       => fail ~\"This dlist node has no next neighbour.\"\n+            Some(nobe) => nobe,\n+            None       => fail ~\"This dlist node has no next neighbour.\"\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link() -> option<DListNode<T>> {\n+    pure fn prev_link() -> Option<DListNode<T>> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n     pure fn prev_node() -> DListNode<T> {\n         match self.prev_link() {\n-            some(nobe) => nobe,\n-            none       => fail ~\"This dlist node has no previous neighbour.\"\n+            Some(nobe) => nobe,\n+            None       => fail ~\"This dlist node has no previous neighbour.\"\n         }\n     }\n }\n \n /// Creates a new dlist node with the given data.\n pure fn new_dlist_node<T>(+data: T) -> DListNode<T> {\n     DListNode(@{data: data, mut linked: false,\n-                 mut prev: none, mut next: none})\n+                 mut prev: None, mut next: None})\n }\n \n /// Creates a new, empty dlist.\n pure fn new_dlist<T>() -> DList<T> {\n-    DList(@{mut size: 0, mut hd: none, mut tl: none})\n+    DList(@{mut size: 0, mut hd: None, mut tl: None})\n }\n \n /// Creates a new dlist with a single element\n@@ -113,8 +113,8 @@ fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n \n priv impl<T> DList<T> {\n     pure fn new_link(-data: T) -> DListLink<T> {\n-        some(DListNode(@{data: data, mut linked: true,\n-                          mut prev: none, mut next: none}))\n+        Some(DListNode(@{data: data, mut linked: true,\n+                          mut prev: None, mut next: None}))\n     }\n     pure fn assert_mine(nobe: DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n@@ -141,21 +141,21 @@ priv impl<T> DList<T> {\n     #[inline(always)]\n     fn link(+before: DListLink<T>, +after: DListLink<T>) {\n         match before {\n-            some(neighbour) => neighbour.next = after,\n-            none            => self.hd        = after\n+            Some(neighbour) => neighbour.next = after,\n+            None            => self.hd        = after\n         }\n         match after {\n-            some(neighbour) => neighbour.prev = before,\n-            none            => self.tl        = before\n+            Some(neighbour) => neighbour.prev = before,\n+            None            => self.tl        = before\n         }\n     }\n     // Remove a node from the list.\n     fn unlink(nobe: DListNode<T>) {\n         self.assert_mine(nobe);\n         assert self.size > 0;\n         self.link(nobe.prev, nobe.next);\n-        nobe.prev = none; // Release extraneous references.\n-        nobe.next = none;\n+        nobe.prev = None; // Release extraneous references.\n+        nobe.next = None;\n         nobe.linked = false;\n         self.size -= 1;\n     }\n@@ -174,14 +174,14 @@ priv impl<T> DList<T> {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(neighbour.prev, nobe);\n-        self.link(nobe, some(neighbour));\n+        self.link(nobe, Some(neighbour));\n         self.size += 1;\n     }\n     fn insert_right(neighbour: DListNode<T>, nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(nobe, neighbour.next);\n-        self.link(some(neighbour), nobe);\n+        self.link(Some(neighbour), nobe);\n         self.size += 1;\n     }\n }\n@@ -233,7 +233,7 @@ impl<T> DList<T> {\n      */\n     fn insert_n_before(nobe: DListNode<T>, neighbour: DListNode<T>) {\n         self.make_mine(nobe);\n-        self.insert_left(some(nobe), neighbour);\n+        self.insert_left(Some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n@@ -257,7 +257,7 @@ impl<T> DList<T> {\n      */\n     fn insert_n_after(nobe: DListNode<T>, neighbour: DListNode<T>) {\n         self.make_mine(nobe);\n-        self.insert_right(neighbour, some(nobe));\n+        self.insert_right(neighbour, Some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n@@ -270,34 +270,34 @@ impl<T> DList<T> {\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n() -> option<DListNode<T>> {\n+    fn pop_n() -> Option<DListNode<T>> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n() -> option<DListNode<T>> {\n+    fn pop_tail_n() -> Option<DListNode<T>> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n() -> option<DListNode<T>> { self.hd }\n+    pure fn peek_n() -> Option<DListNode<T>> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n() -> option<DListNode<T>> { self.tl }\n+    pure fn peek_tail_n() -> Option<DListNode<T>> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n     pure fn head_n() -> DListNode<T> {\n         match self.hd {\n-            some(nobe) => nobe,\n-            none       => fail ~\"Attempted to get the head of an empty dlist.\"\n+            Some(nobe) => nobe,\n+            None       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n() -> DListNode<T> {\n         match self.tl {\n-            some(nobe) => nobe,\n-            none       => fail ~\"Attempted to get the tail of an empty dlist.\"\n+            Some(nobe) => nobe,\n+            None       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }\n     }\n \n@@ -317,8 +317,8 @@ impl<T> DList<T> {\n             self.tl    = them.tl;\n             self.size += them.size;\n             them.size  = 0;\n-            them.hd    = none;\n-            them.tl    = none;\n+            them.hd    = None;\n+            them.tl    = None;\n         }\n     }\n     /**\n@@ -334,8 +334,8 @@ impl<T> DList<T> {\n             self.hd    = them.hd;\n             self.size += them.size;\n             them.size  = 0;\n-            them.hd    = none;\n-            them.tl    = none;\n+            them.hd    = None;\n+            them.tl    = None;\n         }\n     }\n \n@@ -345,7 +345,7 @@ impl<T> DList<T> {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n             self.make_mine(nobe);\n-            self.add_head(some(nobe));\n+            self.add_head(Some(nobe));\n             next_nobe\n         }\n     }\n@@ -417,13 +417,13 @@ impl<T> DList<T> {\n \n impl<T: copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n+    fn pop()       -> Option<T> { self.pop_n().map       (|nobe| nobe.data) }\n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail()  -> option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n+    fn pop_tail()  -> Option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n     /// Get data at the list's head. O(1).\n-    pure fn peek() -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n+    pure fn peek() -> Option<T> { self.peek_n().map      (|nobe| nobe.data) }\n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail() -> option<T> {\n+    pure fn peek_tail() -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n     /// Get data at the list's head, failing if empty. O(1).\n@@ -777,7 +777,7 @@ mod tests {\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n         l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); assert l.peek() == none;\n+        l.assert_consistent(); assert l.peek() == None;\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n@@ -847,7 +847,7 @@ mod tests {\n         let l = new_dlist::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n-        two.prev = none;\n+        two.prev = None;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -856,8 +856,8 @@ mod tests {\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n         let three = l.push_n(3);\n-        three.next = some(one);\n-        one.prev = some(three);\n+        three.next = Some(one);\n+        one.prev = Some(three);\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]"}, {"sha": "00c4b148579769823d38354bfe2a649f821ecd49", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -42,7 +42,7 @@ export unwrap;\n  *\n  * The reason that I did not use an unsafe pointer in the structure\n  * itself is that I wanted to ensure that the vector would be freed when\n- * the dvec is dropped.  The reason that I did not use an `option<T>`\n+ * the dvec is dropped.  The reason that I did not use an `Option<T>`\n  * instead of a nullable pointer is that I found experimentally that it\n  * becomes approximately 50% slower. This can probably be improved\n  * through optimization.  You can run your own experiments using\n@@ -247,7 +247,7 @@ impl<A: copy> DVec<A> {\n         do self.swap |v| {\n            let mut v = match ts.size_hint() {\n              none { v }\n-             some(h) {\n+             Some(h) {\n                let len = v.len() + h;\n                let mut v <- v;\n                vec::reserve(v, len);"}, {"sha": "0181fbf9bc79230c4bca8cdbaf03edd1037e303f", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -25,7 +25,7 @@ debug!(\"hello, %s!\", \"world\");\n \n */\n \n-import option::{some, none};\n+import option::{Some, None};\n \n \n /*\n@@ -70,7 +70,7 @@ mod ct {\n \n     // A formatted conversion from an expression to a string\n     type conv =\n-        {param: option<int>,\n+        {param: Option<int>,\n          flags: ~[flag],\n          width: count,\n          precision: count,\n@@ -117,25 +117,25 @@ mod ct {\n         return pieces;\n     }\n     fn peek_num(s: ~str, i: uint, lim: uint) ->\n-       option<{num: uint, next: uint}> {\n+       Option<{num: uint, next: uint}> {\n         let mut j = i;\n         let mut accum = 0u;\n         let mut found = false;\n         while j < lim {\n             match char::to_digit(s[j] as char, 10) {\n-                some(x) => {\n+                Some(x) => {\n                     found = true;\n                     accum *= 10;\n                     accum += x;\n                     j += 1;\n                 },\n-                none => break\n+                None => break\n             }\n         }\n         if found {\n-            some({num: accum, next: j})\n+            Some({num: accum, next: j})\n         } else {\n-            none\n+            None\n         }\n     }\n     fn parse_conversion(s: ~str, i: uint, lim: uint, error: error_fn) ->\n@@ -154,17 +154,17 @@ mod ct {\n              next: ty.next};\n     }\n     fn parse_parameter(s: ~str, i: uint, lim: uint) ->\n-       {param: option<int>, next: uint} {\n-        if i >= lim { return {param: none, next: i}; }\n+       {param: Option<int>, next: uint} {\n+        if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n         return match num {\n-              none => {param: none, next: i},\n-              some(t) => {\n+              None => {param: None, next: i},\n+              Some(t) => {\n                 let n = t.num;\n                 let j = t.next;\n                 if j < lim && s[j] == '$' as u8 {\n-                    {param: some(n as int), next: j + 1u}\n-                } else { {param: none, next: i} }\n+                    {param: Some(n as int), next: j + 1u}\n+                } else { {param: None, next: i} }\n               }\n             };\n     }\n@@ -203,14 +203,14 @@ mod ct {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 match param.param {\n-                  none => {count: count_is_next_param, next: j},\n-                  some(n) => {count: count_is_param(n), next: j}\n+                  None => {count: count_is_next_param, next: j},\n+                  Some(n) => {count: count_is_param(n), next: j}\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 match num {\n-                  none => {count: count_implied, next: i},\n-                  some(num) => {\n+                  None => {count: count_implied, next: i},\n+                  Some(num) => {\n                     count: count_is(num.num as int),\n                     next: num.next\n                   }"}, {"sha": "f71619337cbe5216d8166906278abbe48d0e9a16", "filename": "src/libcore/float.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -241,29 +241,29 @@ fn to_str(num: float, digits: uint) -> ~str {\n  * # Return value\n  *\n  * `none` if the string did not represent a valid number.  Otherwise,\n- * `some(n)` where `n` is the floating-point number represented by `[num]`.\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n-fn from_str(num: &str) -> option<float> {\n+fn from_str(num: &str) -> Option<float> {\n    if num == \"inf\" {\n-       return some(infinity as float);\n+       return Some(infinity as float);\n    } else if num == \"-inf\" {\n-       return some(neg_infinity as float);\n+       return Some(neg_infinity as float);\n    } else if num == \"NaN\" {\n-       return some(NaN as float);\n+       return Some(NaN as float);\n    }\n \n    let mut pos = 0u;               //Current byte position in the string.\n                                    //Used to walk the string in O(n).\n    let len = str::len(num);        //Length of the string, in bytes.\n \n-   if len == 0u { return none; }\n+   if len == 0u { return None; }\n    let mut total = 0f;             //Accumulated result\n    let mut c     = 'z';            //Latest char.\n \n    //The string must start with one of the following characters.\n    match str::char_at(num, 0u) {\n       '-' | '+' | '0' to '9' | '.' => (),\n-      _ => return none\n+      _ => return None\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n@@ -290,7 +290,7 @@ fn from_str(num: &str) -> option<float> {\n            total += ((c as int) - ('0' as int)) as float;\n          }\n          '.' | 'e' | 'E' => break,\n-         _ => return none\n+         _ => return None\n        }\n    }\n \n@@ -306,7 +306,7 @@ fn from_str(num: &str) -> option<float> {\n                  total += (((c as int) - ('0' as int)) as float)*decimal;\n              }\n              'e' | 'E' => break,\n-             _ => return none\n+             _ => return None\n          }\n       }\n    }\n@@ -348,17 +348,17 @@ fn from_str(num: &str) -> option<float> {\n              total = total * multiplier;\n           }\n       } else {\n-         return none;\n+         return None;\n       }\n    }\n \n    if(pos < len) {\n-     return none;\n+     return None;\n    } else {\n      if(neg) {\n         total *= -1f;\n      }\n-     return some(total);\n+     return Some(total);\n    }\n }\n \n@@ -428,45 +428,45 @@ impl float: num::Num {\n \n #[test]\n fn test_from_str() {\n-   assert from_str(~\"3\") == some(3.);\n-   assert from_str(~\"3\") == some(3.);\n-   assert from_str(~\"3.14\") == some(3.14);\n-   assert from_str(~\"+3.14\") == some(3.14);\n-   assert from_str(~\"-3.14\") == some(-3.14);\n-   assert from_str(~\"2.5E10\") == some(25000000000.);\n-   assert from_str(~\"2.5e10\") == some(25000000000.);\n-   assert from_str(~\"25000000000.E-10\") == some(2.5);\n-   assert from_str(~\".\") == some(0.);\n-   assert from_str(~\".e1\") == some(0.);\n-   assert from_str(~\".e-1\") == some(0.);\n-   assert from_str(~\"5.\") == some(5.);\n-   assert from_str(~\".5\") == some(0.5);\n-   assert from_str(~\"0.5\") == some(0.5);\n-   assert from_str(~\"0.5\") == some(0.5);\n-   assert from_str(~\"0.5\") == some(0.5);\n-   assert from_str(~\"-.5\") == some(-0.5);\n-   assert from_str(~\"-.5\") == some(-0.5);\n-   assert from_str(~\"-5\") == some(-5.);\n-   assert from_str(~\"-0\") == some(-0.);\n-   assert from_str(~\"0\") == some(0.);\n-   assert from_str(~\"inf\") == some(infinity);\n-   assert from_str(~\"-inf\") == some(neg_infinity);\n+   assert from_str(~\"3\") == Some(3.);\n+   assert from_str(~\"3\") == Some(3.);\n+   assert from_str(~\"3.14\") == Some(3.14);\n+   assert from_str(~\"+3.14\") == Some(3.14);\n+   assert from_str(~\"-3.14\") == Some(-3.14);\n+   assert from_str(~\"2.5E10\") == Some(25000000000.);\n+   assert from_str(~\"2.5e10\") == Some(25000000000.);\n+   assert from_str(~\"25000000000.E-10\") == Some(2.5);\n+   assert from_str(~\".\") == Some(0.);\n+   assert from_str(~\".e1\") == Some(0.);\n+   assert from_str(~\".e-1\") == Some(0.);\n+   assert from_str(~\"5.\") == Some(5.);\n+   assert from_str(~\".5\") == Some(0.5);\n+   assert from_str(~\"0.5\") == Some(0.5);\n+   assert from_str(~\"0.5\") == Some(0.5);\n+   assert from_str(~\"0.5\") == Some(0.5);\n+   assert from_str(~\"-.5\") == Some(-0.5);\n+   assert from_str(~\"-.5\") == Some(-0.5);\n+   assert from_str(~\"-5\") == Some(-5.);\n+   assert from_str(~\"-0\") == Some(-0.);\n+   assert from_str(~\"0\") == Some(0.);\n+   assert from_str(~\"inf\") == Some(infinity);\n+   assert from_str(~\"-inf\") == Some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n-       some(f) => assert is_NaN(f),\n-       none => fail\n+       Some(f) => assert is_NaN(f),\n+       None => fail\n    }\n \n-   assert from_str(~\"\") == none;\n-   assert from_str(~\"x\") == none;\n-   assert from_str(~\" \") == none;\n-   assert from_str(~\"   \") == none;\n-   assert from_str(~\"e\") == none;\n-   assert from_str(~\"E\") == none;\n-   assert from_str(~\"E1\") == none;\n-   assert from_str(~\"1e1e1\") == none;\n-   assert from_str(~\"1e1.1\") == none;\n-   assert from_str(~\"1e1-1\") == none;\n+   assert from_str(~\"\") == None;\n+   assert from_str(~\"x\") == None;\n+   assert from_str(~\" \") == None;\n+   assert from_str(~\"   \") == None;\n+   assert from_str(~\"e\") == None;\n+   assert from_str(~\"E\") == None;\n+   assert from_str(~\"E1\") == None;\n+   assert from_str(~\"1e1e1\") == None;\n+   assert from_str(~\"1e1.1\") == None;\n+   assert from_str(~\"1e1-1\") == None;\n }\n \n #[test]"}, {"sha": "2d9bfb4c81c31b5f4cff152def667862f2a36568", "filename": "src/libcore/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -72,9 +72,9 @@ fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = ~mut some(port);\n+    let port = ~mut Some(port);\n     do from_fn |move port| {\n-        let mut port_ = none;\n+        let mut port_ = None;\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n         match recv(port) {"}, {"sha": "4688e38995fd79ab8450cef23e52d249d17ceb79", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -133,8 +133,8 @@ impl T: iter::TimesIx {\n  * * buf - A byte buffer\n  * * radix - The base of the number\n  */\n-fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n-    if vec::len(buf) == 0u { return none; }\n+fn parse_buf(buf: ~[u8], radix: uint) -> Option<T> {\n+    if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut start = 0u;\n     let mut power = 1 as T;\n@@ -146,17 +146,17 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     let mut n = 0 as T;\n     loop {\n         match char::to_digit(buf[i] as char, radix) {\n-          some(d) => n += (d as T) * power,\n-          none => return none\n+          Some(d) => n += (d as T) * power,\n+          None => return None\n         }\n         power *= radix as T;\n-        if i <= start { return some(n); }\n+        if i <= start { return Some(n); }\n         i -= 1u;\n     };\n }\n \n /// Parse a string to an int\n-fn from_str(s: ~str) -> option<T> { parse_buf(str::to_bytes(s), 10u) }\n+fn from_str(s: ~str) -> Option<T> { parse_buf(str::to_bytes(s), 10u) }\n \n /// Convert to a string in a given base\n fn to_str(n: T, radix: uint) -> ~str {\n@@ -182,47 +182,47 @@ fn str(i: T) -> ~str { return to_str(i, 10u); }\n #[test]\n #[ignore]\n fn test_from_str() {\n-    assert from_str(~\"0\") == some(0 as T);\n-    assert from_str(~\"3\") == some(3 as T);\n-    assert from_str(~\"10\") == some(10 as T);\n-    assert from_str(~\"123456789\") == some(123456789 as T);\n-    assert from_str(~\"00100\") == some(100 as T);\n-\n-    assert from_str(~\"-1\") == some(-1 as T);\n-    assert from_str(~\"-3\") == some(-3 as T);\n-    assert from_str(~\"-10\") == some(-10 as T);\n-    assert from_str(~\"-123456789\") == some(-123456789 as T);\n-    assert from_str(~\"-00100\") == some(-100 as T);\n-\n-    assert from_str(~\" \") == none;\n-    assert from_str(~\"x\") == none;\n+    assert from_str(~\"0\") == Some(0 as T);\n+    assert from_str(~\"3\") == Some(3 as T);\n+    assert from_str(~\"10\") == Some(10 as T);\n+    assert from_str(~\"123456789\") == Some(123456789 as T);\n+    assert from_str(~\"00100\") == Some(100 as T);\n+\n+    assert from_str(~\"-1\") == Some(-1 as T);\n+    assert from_str(~\"-3\") == Some(-3 as T);\n+    assert from_str(~\"-10\") == Some(-10 as T);\n+    assert from_str(~\"-123456789\") == Some(-123456789 as T);\n+    assert from_str(~\"-00100\") == Some(-100 as T);\n+\n+    assert from_str(~\" \") == None;\n+    assert from_str(~\"x\") == None;\n }\n \n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n fn test_parse_buf() {\n     import str::to_bytes;\n-    assert parse_buf(to_bytes(~\"123\"), 10u) == some(123 as T);\n-    assert parse_buf(to_bytes(~\"1001\"), 2u) == some(9 as T);\n-    assert parse_buf(to_bytes(~\"123\"), 8u) == some(83 as T);\n-    assert parse_buf(to_bytes(~\"123\"), 16u) == some(291 as T);\n-    assert parse_buf(to_bytes(~\"ffff\"), 16u) == some(65535 as T);\n-    assert parse_buf(to_bytes(~\"FFFF\"), 16u) == some(65535 as T);\n-    assert parse_buf(to_bytes(~\"z\"), 36u) == some(35 as T);\n-    assert parse_buf(to_bytes(~\"Z\"), 36u) == some(35 as T);\n-\n-    assert parse_buf(to_bytes(~\"-123\"), 10u) == some(-123 as T);\n-    assert parse_buf(to_bytes(~\"-1001\"), 2u) == some(-9 as T);\n-    assert parse_buf(to_bytes(~\"-123\"), 8u) == some(-83 as T);\n-    assert parse_buf(to_bytes(~\"-123\"), 16u) == some(-291 as T);\n-    assert parse_buf(to_bytes(~\"-ffff\"), 16u) == some(-65535 as T);\n-    assert parse_buf(to_bytes(~\"-FFFF\"), 16u) == some(-65535 as T);\n-    assert parse_buf(to_bytes(~\"-z\"), 36u) == some(-35 as T);\n-    assert parse_buf(to_bytes(~\"-Z\"), 36u) == some(-35 as T);\n-\n-    assert parse_buf(to_bytes(~\"Z\"), 35u) == none;\n-    assert parse_buf(to_bytes(~\"-9\"), 2u) == none;\n+    assert parse_buf(to_bytes(~\"123\"), 10u) == Some(123 as T);\n+    assert parse_buf(to_bytes(~\"1001\"), 2u) == Some(9 as T);\n+    assert parse_buf(to_bytes(~\"123\"), 8u) == Some(83 as T);\n+    assert parse_buf(to_bytes(~\"123\"), 16u) == Some(291 as T);\n+    assert parse_buf(to_bytes(~\"ffff\"), 16u) == Some(65535 as T);\n+    assert parse_buf(to_bytes(~\"FFFF\"), 16u) == Some(65535 as T);\n+    assert parse_buf(to_bytes(~\"z\"), 36u) == Some(35 as T);\n+    assert parse_buf(to_bytes(~\"Z\"), 36u) == Some(35 as T);\n+\n+    assert parse_buf(to_bytes(~\"-123\"), 10u) == Some(-123 as T);\n+    assert parse_buf(to_bytes(~\"-1001\"), 2u) == Some(-9 as T);\n+    assert parse_buf(to_bytes(~\"-123\"), 8u) == Some(-83 as T);\n+    assert parse_buf(to_bytes(~\"-123\"), 16u) == Some(-291 as T);\n+    assert parse_buf(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as T);\n+    assert parse_buf(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as T);\n+    assert parse_buf(to_bytes(~\"-z\"), 36u) == Some(-35 as T);\n+    assert parse_buf(to_bytes(~\"-Z\"), 36u) == Some(-35 as T);\n+\n+    assert parse_buf(to_bytes(~\"Z\"), 35u) == None;\n+    assert parse_buf(to_bytes(~\"-9\"), 2u) == None;\n }\n \n #[test]"}, {"sha": "71d8129b0354875744f4035ac2c5f4b140f51306", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -761,8 +761,8 @@ mod fsync {\n         new(-arg: Arg<t>) { self.arg <- arg; }\n         drop {\n           match self.arg.opt_level {\n-            option::none => (),\n-            option::some(level) => {\n+            option::None => (),\n+            option::Some(level) => {\n               // fail hard if not succesful\n               assert(self.arg.fsync_fn(self.arg.val, level) != -1);\n             }\n@@ -772,14 +772,14 @@ mod fsync {\n \n     type Arg<t> = {\n         val: t,\n-        opt_level: option<Level>,\n+        opt_level: Option<Level>,\n         fsync_fn: fn@(t, Level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    fn FILE_res_sync(&&file: FILERes, opt_level: option<Level>,\n+    fn FILE_res_sync(&&file: FILERes, opt_level: Option<Level>,\n                   blk: fn(&&Res<*libc::FILE>)) {\n         blk(Res({\n             val: file.f, opt_level: opt_level,\n@@ -790,7 +790,7 @@ mod fsync {\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(&&fd: FdRes, opt_level: option<Level>,\n+    fn fd_res_sync(&&fd: FdRes, opt_level: Option<Level>,\n                    blk: fn(&&Res<fd_t>)) {\n         blk(Res({\n             val: fd.fd, opt_level: opt_level,\n@@ -804,7 +804,7 @@ mod fsync {\n     trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(&&o: FSyncable, opt_level: option<Level>,\n+    fn obj_sync(&&o: FSyncable, opt_level: Option<Level>,\n                 blk: fn(&&Res<FSyncable>)) {\n         blk(Res({\n             val: o, opt_level: opt_level,"}, {"sha": "2990d93689811db0bde6d6a13ae1f44969806422", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -7,7 +7,7 @@ export extensions;\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n     pure fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n-    pure fn size_hint() -> option<uint> { SIZE_HINT(self) }\n+    pure fn size_hint() -> Option<uint> { SIZE_HINT(self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n@@ -19,7 +19,7 @@ impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n     }\n     pure fn contains(x: A) -> bool { iter::contains(self, x) }\n     pure fn count(x: A) -> uint { iter::count(self, x) }\n-    pure fn position(f: fn(A) -> bool) -> option<uint> {\n+    pure fn position(f: fn(A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n }\n@@ -40,5 +40,5 @@ impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n \n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n-    pure fn find(p: fn(A) -> bool) -> option<A> { iter::find(self, p) }\n+    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }"}, {"sha": "ae6265409caef7a408f903b48eed7ac8bcbe6208", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -29,6 +29,6 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n-    some(self.len())\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n+    Some(self.len())\n }"}, {"sha": "c50bd1427259256b154b852b9a53c5eb181325fe", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -10,6 +10,6 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     unsafe { self.swap(|v| { vec::each(v, f); v }) }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n-    some(self.len())\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n+    Some(self.len())\n }"}, {"sha": "4970c58b68a9771961fa9377ccae0cfd98e99509", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1,15 +1,15 @@\n-type IMPL_T<A> = option<A>;\n+type IMPL_T<A> = Option<A>;\n \n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     match self {\n-      none => (),\n-      some(a) => { f(a); }\n+      None => (),\n+      Some(a) => { f(a); }\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n     match self {\n-      none => some(0u),\n-      some(_) => some(1u)\n+      None => Some(0u),\n+      Some(_) => Some(1u)\n     }\n }"}, {"sha": "3f11a9b1736155059f724382b71bcd30271fec48", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,7 +3,7 @@ type InitOp<T> = fn(uint) -> T;\n \n trait BaseIter<A> {\n     pure fn each(blk: fn(A) -> bool);\n-    pure fn size_hint() -> option<uint>;\n+    pure fn size_hint() -> Option<uint>;\n }\n \n trait ExtendedIter<A> {\n@@ -13,7 +13,7 @@ trait ExtendedIter<A> {\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n     pure fn contains(x: A) -> bool;\n     pure fn count(x: A) -> uint;\n-    pure fn position(f: fn(A) -> bool) -> option<uint>;\n+    pure fn position(f: fn(A) -> bool) -> Option<uint>;\n }\n \n trait Times {\n@@ -29,7 +29,7 @@ trait CopyableIter<A:copy> {\n     pure fn to_vec() -> ~[A];\n     pure fn min() -> A;\n     pure fn max() -> A;\n-    pure fn find(p: fn(A) -> bool) -> option<A>;\n+    pure fn find(p: fn(A) -> bool) -> Option<A>;\n }\n \n // A trait for sequences that can be by imperatively pushing elements\n@@ -134,13 +134,13 @@ pure fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n }\n \n pure fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n-        -> option<uint> {\n+        -> Option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n-        if f(a) { return some(i); }\n+        if f(a) { return Some(i); }\n         i += 1;\n     }\n-    return none;\n+    return None;\n }\n \n // note: 'rposition' would only make sense to provide with a bidirectional\n@@ -156,43 +156,43 @@ pure fn repeat(times: uint, blk: fn() -> bool) {\n }\n \n pure fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n-    match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n+    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n-          some(a_) if a_ < b => {\n+          Some(a_) if a_ < b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move\n             a\n           }\n-          _ => some(b)\n+          _ => Some(b)\n         }\n     } {\n-        some(val) => val,\n-        none => fail ~\"min called on empty iterator\"\n+        Some(val) => val,\n+        None => fail ~\"min called on empty iterator\"\n     }\n }\n \n pure fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n-    match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n+    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n-          some(a_) if a_ > b => {\n+          Some(a_) if a_ > b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move.\n             a\n           }\n-          _ => some(b)\n+          _ => Some(b)\n         }\n     } {\n-        some(val) => val,\n-        none => fail ~\"max called on empty iterator\"\n+        Some(val) => val,\n+        None => fail ~\"max called on empty iterator\"\n     }\n }\n \n pure fn find<A: copy,IA:BaseIter<A>>(self: IA,\n-                                     p: fn(A) -> bool) -> option<A> {\n+                                     p: fn(A) -> bool) -> Option<A> {\n     for self.each |i| {\n-        if p(i) { return some(i) }\n+        if p(i) { return Some(i) }\n     }\n-    return none;\n+    return None;\n }\n \n // Some functions for just building\n@@ -227,7 +227,7 @@ pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+A))) -> B {\n  */\n #[inline(always)]\n pure fn build_sized_opt<A,B: Buildable<A>>(\n-    size: option<uint>,\n+    size: Option<uint>,\n     builder: fn(push: pure fn(+A))) -> B {\n \n     build_sized(size.get_default(4), builder)\n@@ -339,9 +339,9 @@ fn test_filter_on_uint_range() {\n \n #[test]\n fn test_filter_map() {\n-    fn negativate_the_evens(&&i: int) -> option<int> {\n+    fn negativate_the_evens(&&i: int) -> Option<int> {\n         if i % 2 == 0 {\n-            some(-i)\n+            Some(-i)\n         } else {\n             none\n         }\n@@ -354,8 +354,8 @@ fn test_filter_map() {\n \n #[test]\n fn test_flat_map_with_option() {\n-    fn if_even(&&i: int) -> option<int> {\n-        if (i % 2) == 0 { some(i) }\n+    fn if_even(&&i: int) -> Option<int> {\n+        if (i % 2) == 0 { Some(i) }\n         else { none }\n     }\n "}, {"sha": "99e54e8deb05d70cf826ec4820e66d782a651bc9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,18 +3,18 @@\n  *\n  * Type `option` represents an optional value.\n  *\n- * Every `option<T>` value can either be `some(T)` or `none`. Where in other\n+ * Every `Option<T>` value can either be `Some(T)` or `none`. Where in other\n  * languages you might use a nullable type, in Rust you would use an option\n  * type.\n  */\n \n /// The option type\n-enum option<T> {\n-    none,\n-    some(T),\n+enum Option<T> {\n+    None,\n+    Some(T),\n }\n \n-pure fn get<T: copy>(opt: option<T>) -> T {\n+pure fn get<T: copy>(opt: Option<T>) -> T {\n     /*!\n      * Gets the value out of an option\n      *\n@@ -24,12 +24,12 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n      */\n \n     match opt {\n-      some(x) => return x,\n-      none => fail ~\"option::get none\"\n+      Some(x) => return x,\n+      None => fail ~\"option::get none\"\n     }\n }\n \n-pure fn get_ref<T>(opt: &r/option<T>) -> &r/T {\n+pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n      * Gets an immutable reference to the value inside an option.\n      *\n@@ -38,12 +38,12 @@ pure fn get_ref<T>(opt: &r/option<T>) -> &r/T {\n      * Fails if the value equals `none`\n      */\n     match *opt {\n-        some(ref x) => x,\n-        none => fail ~\"option::get_ref none\"\n+        Some(ref x) => x,\n+        None => fail ~\"option::get_ref none\"\n     }\n }\n \n-pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n+pure fn expect<T: copy>(opt: Option<T>, reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -52,60 +52,60 @@ pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n      *\n      * Fails if the value equals `none`\n      */\n-    match opt { some(x) => x, none => fail reason }\n+    match opt { Some(x) => x, None => fail reason }\n }\n \n-pure fn map<T, U>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n+pure fn map<T, U>(opt: Option<T>, f: fn(T) -> U) -> Option<U> {\n     //! Maps a `some` value from one type to another\n \n-    match opt { some(x) => some(f(x)), none => none }\n+    match opt { Some(x) => Some(f(x)), None => None }\n }\n \n-pure fn map_ref<T, U>(opt: &option<T>, f: fn(x: &T) -> U) -> option<U> {\n+pure fn map_ref<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n-    match *opt { some(ref x) => some(f(x)), none => none }\n+    match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n-pure fn map_consume<T, U>(+opt: option<T>, f: fn(+T) -> U) -> option<U> {\n+pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n-    if opt.is_some() { some(f(option::unwrap(opt))) } else { none }\n+    if opt.is_some() { Some(f(option::unwrap(opt))) } else { None }\n }\n \n-pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n+pure fn chain<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n      */\n \n-    match opt { some(x) => f(x), none => none }\n+    match opt { Some(x) => f(x), None => None }\n }\n \n-pure fn chain_ref<T, U>(opt: &option<T>,\n-                        f: fn(x: &T) -> option<U>) -> option<U> {\n+pure fn chain_ref<T, U>(opt: &Option<T>,\n+                        f: fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n \n-    match *opt { some(ref x) => f(x), none => none }\n+    match *opt { Some(ref x) => f(x), None => None }\n }\n \n-pure fn or<T>(+opta: option<T>, +optb: option<T>) -> option<T> {\n+pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n      */\n     match opta {\n-        some(_) => opta,\n+        Some(_) => opta,\n         _ => optb\n     }\n }\n \n #[inline(always)]\n-pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n+pure fn while_some<T>(+x: Option<T>, blk: fn(+T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt <- x;\n@@ -114,84 +114,84 @@ pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n     }\n }\n \n-pure fn is_none<T>(opt: option<T>) -> bool {\n+pure fn is_none<T>(opt: Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n-    match opt { none => true, some(_) => false }\n+    match opt { None => true, Some(_) => false }\n }\n \n-pure fn is_some<T>(opt: option<T>) -> bool {\n+pure fn is_some<T>(opt: Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n-pure fn get_default<T: copy>(opt: option<T>, def: T) -> T {\n+pure fn get_default<T: copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n-    match opt { some(x) => x, none => def }\n+    match opt { Some(x) => x, None => def }\n }\n \n-pure fn map_default<T, U>(opt: option<T>, +def: U, f: fn(T) -> U) -> U {\n+pure fn map_default<T, U>(opt: Option<T>, +def: U, f: fn(T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match opt { none => def, some(t) => f(t) }\n+    match opt { None => def, Some(t) => f(t) }\n }\n \n // This should replace map_default.\n-pure fn map_default_ref<T, U>(opt: &option<T>, +def: U,\n+pure fn map_default_ref<T, U>(opt: &Option<T>, +def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match *opt { none => def, some(ref t) => f(t) }\n+    match *opt { None => def, Some(ref t) => f(t) }\n }\n \n // This should change to by-copy mode; use iter_ref below for by reference\n-pure fn iter<T>(opt: option<T>, f: fn(T)) {\n+pure fn iter<T>(opt: Option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n-    match opt { none => (), some(t) => f(t) }\n+    match opt { None => (), Some(t) => f(t) }\n }\n \n-pure fn iter_ref<T>(opt: &option<T>, f: fn(x: &T)) {\n+pure fn iter_ref<T>(opt: &Option<T>, f: fn(x: &T)) {\n     //! Performs an operation on the contained value by reference\n-    match *opt { none => (), some(ref t) => f(t) }\n+    match *opt { None => (), Some(ref t) => f(t) }\n }\n \n #[inline(always)]\n-pure fn unwrap<T>(+opt: option<T>) -> T {\n+pure fn unwrap<T>(+opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n      * Useful primarily for getting strings, vectors and unique pointers out\n      * of option types without copying them.\n      */\n     match move opt {\n-        some(move x) => x,\n-        none => fail ~\"option::unwrap none\"\n+        Some(move x) => x,\n+        None => fail ~\"option::unwrap none\"\n     }\n }\n \n /// The ubiquitous option dance.\n #[inline(always)]\n-fn swap_unwrap<T>(opt: &mut option<T>) -> T {\n+fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n-    unwrap(util::replace(opt, none))\n+    unwrap(util::replace(opt, None))\n }\n \n-pure fn unwrap_expect<T>(+opt: option<T>, reason: &str) -> T {\n+pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(opt)\n }\n \n-// Some of these should change to be &option<T>, some should not. See below.\n-impl<T> option<T> {\n+// Some of these should change to be &Option<T>, some should not. See below.\n+impl<T> Option<T> {\n     /**\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n      */\n-    pure fn chain<U>(f: fn(T) -> option<U>) -> option<U> { chain(self, f) }\n+    pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(self, f) }\n     /// Applies a function to the contained value or returns a default\n     pure fn map_default<U>(+def: U, f: fn(T) -> U) -> U\n         { map_default(self, def, f) }\n@@ -202,15 +202,15 @@ impl<T> option<T> {\n     /// Returns true if the option contains some value\n     pure fn is_some() -> bool { is_some(self) }\n     /// Maps a `some` value from one type to another\n-    pure fn map<U>(f: fn(T) -> U) -> option<U> { map(self, f) }\n+    pure fn map<U>(f: fn(T) -> U) -> Option<U> { map(self, f) }\n }\n \n-impl<T> &option<T> {\n+impl<T> &Option<T> {\n     /**\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n-    pure fn chain_ref<U>(f: fn(x: &T) -> option<U>) -> option<U> {\n+    pure fn chain_ref<U>(f: fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n     /// Applies a function to the contained value or returns a default\n@@ -219,12 +219,12 @@ impl<T> &option<T> {\n     /// Performs an operation on the contained value by reference\n     pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n     /// Maps a `some` value from one type to another by reference\n-    pure fn map_ref<U>(f: fn(x: &T) -> U) -> option<U> { map_ref(self, f) }\n+    pure fn map_ref<U>(f: fn(x: &T) -> U) -> Option<U> { map_ref(self, f) }\n     /// Gets an immutable reference to the value inside a `some`.\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }\n \n-impl<T: copy> option<T> {\n+impl<T: copy> Option<T> {\n     /**\n      * Gets the value out of an option\n      *\n@@ -244,14 +244,14 @@ impl<T: copy> option<T> {\n      */\n     pure fn expect(reason: ~str) -> T { expect(self, reason) }\n     /// Applies a function zero or more times until the result is none.\n-    pure fn while_some(blk: fn(+T) -> option<T>) { while_some(self, blk) }\n+    pure fn while_some(blk: fn(+T) -> Option<T>) { while_some(self, blk) }\n }\n \n #[test]\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(*x);\n-    let opt = some(x);\n+    let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = ptr::addr_of(*y);\n     assert addr_x == addr_y;\n@@ -261,7 +261,7 @@ fn test_unwrap_ptr() {\n fn test_unwrap_str() {\n     let x = ~\"test\";\n     let addr_x = str::as_buf(x, |buf, _len| ptr::addr_of(buf));\n-    let opt = some(x);\n+    let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = str::as_buf(y, |buf, _len| ptr::addr_of(buf));\n     assert addr_x == addr_y;\n@@ -277,16 +277,16 @@ fn test_unwrap_resource() {\n     let i = @mut 0;\n     {\n         let x = r(i);\n-        let opt = some(x);\n+        let opt = Some(x);\n         let _y = unwrap(opt);\n     }\n     assert *i == 1;\n }\n \n #[test]\n fn test_option_dance() {\n-    let x = some(());\n-    let mut y = some(5);\n+    let x = Some(());\n+    let mut y = Some(5);\n     let mut y2 = 0;\n     do x.iter |_x| {\n         y2 = swap_unwrap(&mut y);\n@@ -296,20 +296,20 @@ fn test_option_dance() {\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n-    let mut y = some(util::NonCopyable());\n+    let mut y = Some(util::NonCopyable());\n     let _y2 = swap_unwrap(&mut y);\n     let _y3 = swap_unwrap(&mut y);\n }\n \n #[test]\n fn test_option_while_some() {\n     let mut i = 0;\n-    do some(10).while_some |j| {\n+    do Some(10).while_some |j| {\n         i += 1;\n         if (j > 0) {\n-            some(j-1)\n+            Some(j-1)\n         } else {\n-            none\n+            None\n         }\n     }\n     assert i == 11;"}, {"sha": "e9104b48e3f752ed13d0cd6f7ba15fbd76837d8a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -24,7 +24,7 @@ import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n               mode_t, pid_t, FILE};\n import libc::{close, fclose};\n \n-import option::{some, none};\n+import option::{Some, None};\n \n import consts::*;\n import task::TaskBuilder;\n@@ -65,13 +65,13 @@ fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n }\n \n fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n-    -> option<~str> {\n+    -> Option<~str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b, sz| {\n         if f(b, sz as size_t) unsafe {\n-            some(str::unsafe::from_buf(b as *u8))\n+            Some(str::unsafe::from_buf(b as *u8))\n         } else {\n-            none\n+            None\n         }\n     }\n }\n@@ -81,14 +81,14 @@ mod win32 {\n     import dword = libc::types::os::arch::extra::DWORD;\n \n     fn fill_utf16_buf_and_decode(f: fn(*mut u16, dword) -> dword)\n-        -> option<~str> {\n+        -> Option<~str> {\n \n         // FIXME: remove these when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::consts::os::extra::*;\n \n         let mut n = tmpbuf_sz as dword;\n-        let mut res = none;\n+        let mut res = None;\n         let mut done = false;\n         while !done {\n             let buf = vec::to_mut(vec::from_elem(n as uint, 0u16));\n@@ -102,7 +102,7 @@ mod win32 {\n                     n *= (2 as dword);\n                 } else {\n                     let sub = vec::slice(buf, 0u, k as uint);\n-                    res = option::some(str::from_utf16(sub));\n+                    res = option::Some(str::from_utf16(sub));\n                     done = true;\n                 }\n             }\n@@ -118,7 +118,7 @@ mod win32 {\n     }\n }\n \n-fn getenv(n: &str) -> option<~str> {\n+fn getenv(n: &str) -> Option<~str> {\n     global_env::getenv(n)\n }\n \n@@ -142,12 +142,12 @@ mod global_env {\n     }\n \n     enum Msg {\n-        MsgGetEnv(~str, comm::Chan<option<~str>>),\n+        MsgGetEnv(~str, comm::Chan<Option<~str>>),\n         MsgSetEnv(~str, ~str, comm::Chan<()>),\n         MsgEnv(comm::Chan<~[(~str,~str)]>)\n     }\n \n-    fn getenv(n: &str) -> option<~str> {\n+    fn getenv(n: &str) -> Option<~str> {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n         comm::send(env_ch, MsgGetEnv(str::from_slice(n),\n@@ -219,20 +219,20 @@ mod global_env {\n         }\n \n         #[cfg(unix)]\n-        fn getenv(n: &str) -> option<~str> {\n+        fn getenv(n: &str) -> Option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n                 return if unsafe::reinterpret_cast(s) == 0 {\n-                    option::none::<~str>\n+                    option::None::<~str>\n                 } else {\n                     let s = unsafe::reinterpret_cast(s);\n-                    option::some::<~str>(str::unsafe::from_buf(s))\n+                    option::Some::<~str>(str::unsafe::from_buf(s))\n                 };\n             }\n         }\n \n         #[cfg(windows)]\n-        fn getenv(n: &str) -> option<~str> {\n+        fn getenv(n: &str) -> Option<~str> {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n@@ -383,10 +383,10 @@ fn dll_filename(base: &str) -> ~str {\n }\n \n \n-fn self_exe_path() -> option<Path> {\n+fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> option<~str> {\n+    fn load_self() -> Option<~str> {\n         unsafe {\n             import libc::funcs::bsd44::*;\n             import libc::consts::os::extra::*;\n@@ -402,7 +402,7 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn load_self() -> option<~str> {\n+    fn load_self() -> Option<~str> {\n         import libc::funcs::posix01::unistd::readlink;\n         do fill_charp_buf() |buf, sz| {\n             do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n@@ -412,7 +412,7 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> option<~str> {\n+    fn load_self() -> Option<~str> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n         do fill_charp_buf() |buf, sz| {\n@@ -422,7 +422,7 @@ fn self_exe_path() -> option<Path> {\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> option<~str> {\n+    fn load_self() -> Option<~str> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -451,28 +451,28 @@ fn self_exe_path() -> option<Path> {\n  *\n  * Otherwise, homedir returns option::none.\n  */\n-fn homedir() -> option<Path> {\n+fn homedir() -> Option<Path> {\n     return match getenv(~\"HOME\") {\n-        some(p) => if !str::is_empty(p) {\n-          some(Path(p))\n+        Some(p) => if !str::is_empty(p) {\n+          Some(Path(p))\n         } else {\n           secondary()\n         },\n-        none => secondary()\n+        None => secondary()\n     };\n \n     #[cfg(unix)]\n-    fn secondary() -> option<Path> {\n-        none\n+    fn secondary() -> Option<Path> {\n+        None\n     }\n \n     #[cfg(windows)]\n-    fn secondary() -> option<Path> {\n+    fn secondary() -> Option<Path> {\n         do option::chain(getenv(~\"USERPROFILE\")) |p| {\n             if !str::is_empty(p) {\n-                some(Path(p))\n+                Some(Path(p))\n             } else {\n-                none\n+                None\n             }\n         }\n     }\n@@ -491,15 +491,15 @@ fn homedir() -> option<Path> {\n fn tmpdir() -> Path {\n     return lookup();\n \n-    fn getenv_nonempty(v: &str) -> option<Path> {\n+    fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n-            some(x) =>\n+            Some(x) =>\n                 if str::is_empty(x) {\n-                    none\n+                    None\n                 } else {\n-                    some(Path(x))\n+                    Some(Path(x))\n                 },\n-            _ => none\n+            _ => None\n         }\n     }\n \n@@ -843,7 +843,7 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n-        assert getenv(n) == option::some(~\"VALUE\");\n+        assert getenv(n) == option::Some(~\"VALUE\");\n     }\n \n     #[test]\n@@ -853,9 +853,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, ~\"1\");\n         setenv(n, ~\"2\");\n-        assert getenv(n) == option::some(~\"2\");\n+        assert getenv(n) == option::Some(~\"2\");\n         setenv(n, ~\"\");\n-        assert getenv(n) == option::some(~\"\");\n+        assert getenv(n) == option::Some(~\"\");\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -870,7 +870,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, s);\n-        assert getenv(n) == option::some(s);\n+        assert getenv(n) == option::Some(s);\n     }\n \n     #[test]\n@@ -896,7 +896,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert option::is_none(v2) || v2 == option::some(v);\n+            assert option::is_none(v2) || v2 == option::Some(v);\n         }\n     }\n \n@@ -928,10 +928,10 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(Path(\"/home/MountainView\"));\n+        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"\");\n-        assert os::homedir() == none;\n+        assert os::homedir() == None;\n \n         option::iter(oldhome, |s| setenv(~\"HOME\", s));\n     }\n@@ -946,19 +946,19 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         setenv(~\"USERPROFILE\", ~\"\");\n \n-        assert os::homedir() == none;\n+        assert os::homedir() == None;\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(Path(\"/home/MountainView\"));\n+        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        assert os::homedir() == some(Path(\"/home/MountainView\"));\n+        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        assert os::homedir() == some(Path(\"/home/MountainView\"));\n+        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n \n         option::iter(oldhome, |s| setenv(~\"HOME\", s));\n         option::iter(olduserprofile,"}, {"sha": "5352027a5b32491c28510c8af19ce33b9ac558e4", "filename": "src/libcore/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -64,11 +64,11 @@ fn split_dirname_basename (pp: Path) -> {dirname: ~str, basename: ~str} {\n     match str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n     ) {\n-      some(i) => {\n+      Some(i) => {\n         dirname: str::slice(pp, 0u, i),\n         basename: str::slice(pp, i + 1u, str::len(pp))\n       },\n-      none => {dirname: ~\".\", basename: pp}\n+      None => {dirname: ~\".\", basename: pp}\n     }\n }\n \n@@ -236,9 +236,9 @@ fn normalize(p: Path) -> Path {\n     fn strip_dots(s: ~[Path]) -> ~[Path] {\n         vec::filter_map(s, |elem|\n             if elem == ~\".\" {\n-                option::none\n+                option::None\n             } else {\n-                option::some(elem)\n+                option::Some(elem)\n             })\n     }\n "}, {"sha": "bf38887554688c78f5a59d2b5dc3d7a8516a15b0", "filename": "src/libcore/path2.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,8 +3,8 @@\n #[forbid(deprecated_pattern)];\n \n struct WindowsPath {\n-    host: option<~str>;\n-    device: option<~str>;\n+    host: Option<~str>;\n+    device: Option<~str>;\n     is_absolute: bool;\n     components: ~[~str];\n }\n@@ -19,9 +19,9 @@ trait GenericPath {\n     static pure fn from_str((&str)) -> self;\n \n     pure fn dirname() -> ~str;\n-    pure fn filename() -> option<~str>;\n-    pure fn filestem() -> option<~str>;\n-    pure fn filetype() -> option<~str>;\n+    pure fn filename() -> Option<~str>;\n+    pure fn filestem() -> Option<~str>;\n+    pure fn filetype() -> Option<~str>;\n \n     pure fn with_dirname((&str)) -> self;\n     pure fn with_filename((&str)) -> self;\n@@ -82,32 +82,32 @@ impl PosixPath : GenericPath {\n         }\n     }\n \n-    pure fn filename() -> option<~str> {\n+    pure fn filename() -> Option<~str> {\n         match self.components.len() {\n-          0 => none,\n-          n => some(copy self.components[n - 1])\n+          0 => None,\n+          n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem() -> option<~str> {\n+    pure fn filestem() -> Option<~str> {\n         match self.filename() {\n-          none => none,\n-          some(ref f) => {\n+          None => None,\n+          Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              some(p) => some(f.slice(0, p)),\n-              none => some(copy *f)\n+              Some(p) => Some(f.slice(0, p)),\n+              None => Some(copy *f)\n             }\n           }\n         }\n     }\n \n-    pure fn filetype() -> option<~str> {\n+    pure fn filetype() -> Option<~str> {\n         match self.filename() {\n-          none => none,\n-          some(ref f) => {\n+          None => None,\n+          Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              some(p) if p+1 < f.len() => some(f.slice(p+1, f.len())),\n-              _ => none\n+              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n+              _ => None\n             }\n           }\n         }\n@@ -116,8 +116,8 @@ impl PosixPath : GenericPath {\n     pure fn with_dirname(d: &str) -> PosixPath {\n         let dpath = from_str::<PosixPath>(d);\n         match self.filename() {\n-          some(ref f) => dpath.push(*f),\n-          none => dpath\n+          Some(ref f) => dpath.push(*f),\n+          None => dpath\n         }\n     }\n \n@@ -130,23 +130,23 @@ impl PosixPath : GenericPath {\n \n     pure fn with_filestem(s: &str) -> PosixPath {\n         match self.filetype() {\n-          none => self.with_filename(s),\n-          some(ref t) =>\n+          None => self.with_filename(s),\n+          Some(ref t) =>\n           self.with_filename(str::from_slice(s) + \".\" + *t)\n         }\n     }\n \n     pure fn with_filetype(t: &str) -> PosixPath {\n         if t.len() == 0 {\n             match self.filestem() {\n-              none => copy self,\n-              some(s) => self.with_filename(s)\n+              None => copy self,\n+              Some(s) => self.with_filename(s)\n             }\n         } else {\n             let t = ~\".\" + str::from_slice(t);\n             match self.filestem() {\n-              none => self.with_filename(t),\n-              some(ref s) =>\n+              None => self.with_filename(t),\n+              Some(ref s) =>\n               self.with_filename(*s + t)\n             }\n         }\n@@ -162,8 +162,8 @@ impl PosixPath : GenericPath {\n \n     pure fn file_path() -> PosixPath {\n         let cs = match self.filename() {\n-          none => ~[],\n-          some(ref f) => ~[copy *f]\n+          None => ~[],\n+          Some(ref f) => ~[copy *f]\n         };\n         return PosixPath { is_absolute: false,\n                            components: cs }\n@@ -201,12 +201,12 @@ impl WindowsPath : ToStr {\n     fn to_str() -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n-          some(h) => { s += \"\\\\\\\\\"; s += h; }\n-          none => { }\n+          Some(h) => { s += \"\\\\\\\\\"; s += h; }\n+          None => { }\n         }\n         match self.device {\n-          some(d) => { s += d; s += \":\"; }\n-          none => { }\n+          Some(d) => { s += d; s += \":\"; }\n+          None => { }\n         }\n         if self.is_absolute {\n             s += \"\\\\\";\n@@ -224,21 +224,21 @@ impl WindowsPath : GenericPath {\n         let rest;\n \n         match windows::extract_drive_prefix(s) {\n-          some((ref d, ref r)) => {\n-            host = none;\n-            device = some(copy *d);\n+          Some((ref d, ref r)) => {\n+            host = None;\n+            device = Some(copy *d);\n             rest = copy *r;\n           }\n-          none => {\n+          None => {\n             match windows::extract_unc_prefix(s) {\n-              some((ref h, ref r)) => {\n-                host = some(copy *h);\n-                device = none;\n+              Some((ref h, ref r)) => {\n+                host = Some(copy *h);\n+                device = None;\n                 rest = copy *r;\n               }\n-              none => {\n-                host = none;\n-                device = none;\n+              None => {\n+                host = None;\n+                device = None;\n                 rest = str::from_slice(s);\n               }\n             }\n@@ -265,32 +265,32 @@ impl WindowsPath : GenericPath {\n         }\n     }\n \n-    pure fn filename() -> option<~str> {\n+    pure fn filename() -> Option<~str> {\n         match self.components.len() {\n-          0 => none,\n-          n => some(copy self.components[n - 1])\n+          0 => None,\n+          n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem() -> option<~str> {\n+    pure fn filestem() -> Option<~str> {\n         match self.filename() {\n-          none => none,\n-          some(ref f) => {\n+          None => None,\n+          Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              some(p) => some(f.slice(0, p)),\n-              none => some(copy *f)\n+              Some(p) => Some(f.slice(0, p)),\n+              None => Some(copy *f)\n             }\n           }\n         }\n     }\n \n-    pure fn filetype() -> option<~str> {\n+    pure fn filetype() -> Option<~str> {\n         match self.filename() {\n-          none => none,\n-          some(ref f) => {\n+          None => None,\n+          Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              some(p) if p+1 < f.len() => some(f.slice(p+1, f.len())),\n-              _ => none\n+              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n+              _ => None\n             }\n           }\n         }\n@@ -299,8 +299,8 @@ impl WindowsPath : GenericPath {\n     pure fn with_dirname(d: &str) -> WindowsPath {\n         let dpath = from_str::<WindowsPath>(d);\n         match self.filename() {\n-          some(ref f) => dpath.push(*f),\n-          none => dpath\n+          Some(ref f) => dpath.push(*f),\n+          None => dpath\n         }\n     }\n \n@@ -311,23 +311,23 @@ impl WindowsPath : GenericPath {\n \n     pure fn with_filestem(s: &str) -> WindowsPath {\n         match self.filetype() {\n-          none => self.with_filename(s),\n-          some(ref t) =>\n+          None => self.with_filename(s),\n+          Some(ref t) =>\n           self.with_filename(str::from_slice(s) + \".\" + *t)\n         }\n     }\n \n     pure fn with_filetype(t: &str) -> WindowsPath {\n         if t.len() == 0 {\n             match self.filestem() {\n-              none => copy self,\n-              some(s) => self.with_filename(s)\n+              None => copy self,\n+              Some(s) => self.with_filename(s)\n             }\n         } else {\n             let t = ~\".\" + str::from_slice(t);\n             match self.filestem() {\n-              none => self.with_filename(t),\n-              some(ref s) =>\n+              None => self.with_filename(t),\n+              Some(ref s) =>\n               self.with_filename(*s + t)\n             }\n         }\n@@ -343,11 +343,11 @@ impl WindowsPath : GenericPath {\n \n     pure fn file_path() -> WindowsPath {\n         let cs = match self.filename() {\n-          none => ~[],\n-          some(ref f) => ~[copy *f]\n+          None => ~[],\n+          Some(ref f) => ~[copy *f]\n         };\n-        return WindowsPath { host: none,\n-                             device: none,\n+        return WindowsPath { host: None,\n+                             device: None,\n                              is_absolute: false,\n                              components: cs }\n     }\n@@ -471,7 +471,7 @@ mod windows {\n         u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    pure fn extract_unc_prefix(s: &str) -> option<(~str,~str)> {\n+    pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n             s[0] == '\\\\' as u8 &&\n             s[1] == '\\\\' as u8) {\n@@ -480,15 +480,15 @@ mod windows {\n                 if s[i] == '\\\\' as u8 {\n                     let pre = s.slice(2, i);\n                     let rest = s.slice(i, s.len());\n-                    return some((pre, rest));\n+                    return Some((pre, rest));\n                 }\n                 i += 1;\n             }\n         }\n-        none\n+        None\n     }\n \n-    pure fn extract_drive_prefix(s: &str) -> option<(~str,~str)> {\n+    pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n         unchecked {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&\n@@ -498,35 +498,35 @@ mod windows {\n                 } else {\n                     s.slice(2, s.len())\n                 };\n-                return some((s.slice(0,1), rest));\n+                return Some((s.slice(0,1), rest));\n             }\n-            none\n+            None\n         }\n     }\n \n     #[test]\n     fn test_extract_unc_prefixes() {\n-        assert extract_unc_prefix(\"\\\\\\\\\") == none;\n-        assert extract_unc_prefix(\"\\\\\\\\hi\") == none;\n-        assert extract_unc_prefix(\"\\\\\\\\hi\\\\\") == some((~\"hi\", ~\"\\\\\"));\n+        assert extract_unc_prefix(\"\\\\\\\\\") == None;\n+        assert extract_unc_prefix(\"\\\\\\\\hi\") == None;\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\\") == Some((~\"hi\", ~\"\\\\\"));\n         assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n-            some((~\"hi\", ~\"\\\\there\"));\n+            Some((~\"hi\", ~\"\\\\there\"));\n         assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n-            some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n     }\n \n     #[test]\n     fn test_extract_drive_prefixes() {\n-        assert extract_drive_prefix(\"c\") == none;\n-        assert extract_drive_prefix(\"c:\") == some((~\"c\", ~\"\"));\n-        assert extract_drive_prefix(\"d:\") == some((~\"d\", ~\"\"));\n-        assert extract_drive_prefix(\"z:\") == some((~\"z\", ~\"\"));\n-        assert extract_drive_prefix(\"c:\\\\hi\") == some((~\"c\", ~\"\\\\hi\"));\n-        assert extract_drive_prefix(\"d:hi\") == some((~\"d\", ~\"hi\"));\n+        assert extract_drive_prefix(\"c\") == None;\n+        assert extract_drive_prefix(\"c:\") == Some((~\"c\", ~\"\"));\n+        assert extract_drive_prefix(\"d:\") == Some((~\"d\", ~\"\"));\n+        assert extract_drive_prefix(\"z:\") == Some((~\"z\", ~\"\"));\n+        assert extract_drive_prefix(\"c:\\\\hi\") == Some((~\"c\", ~\"\\\\hi\"));\n+        assert extract_drive_prefix(\"d:hi\") == Some((~\"d\", ~\"hi\"));\n         assert extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n-            some((~\"c\", ~\"hi\\\\there.txt\"));\n+            Some((~\"c\", ~\"hi\\\\there.txt\"));\n         assert extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n-            some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n+            Some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n     }\n \n     #[test]"}, {"sha": "9fb09b8b43201473669b204c12e799bf8fc0a194", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -181,7 +181,7 @@ struct packet_header {\n #[doc(hidden)]\n type packet<T: send> = {\n     header: packet_header,\n-    mut payload: option<T>,\n+    mut payload: Option<T>,\n };\n \n #[doc(hidden)]\n@@ -199,7 +199,7 @@ impl<T: send> packet<T>: has_buffer {\n fn mk_packet<T: send>() -> packet<T> {\n     {\n         header: packet_header(),\n-        mut payload: none\n+        mut payload: None\n     }\n }\n \n@@ -209,7 +209,7 @@ fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n         header: buffer_header(),\n         data: {\n             header: packet_header(),\n-            mut payload: none,\n+            mut payload: None,\n         }\n     };\n \n@@ -359,8 +359,8 @@ fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(p.header) == header;\n-    assert p.payload == none;\n-    p.payload <- some(payload);\n+    assert p.payload == None;\n+    p.payload <- Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, full);\n     match old_state {\n         empty => {\n@@ -404,11 +404,11 @@ fn recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>) -> T {\n /** Attempts to receive a message from a pipe.\n \n Returns `none` if the sender has closed the connection without sending\n-a message, or `some(T)` if a message was received.\n+a message, or `Some(T)` if a message was received.\n \n */\n fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n-    -> option<T>\n+    -> Option<T>\n {\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n@@ -433,12 +433,12 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n     // optimistic path\n     match p.header.state {\n       full => {\n-        let mut payload = none;\n+        let mut payload = None;\n         payload <-> p.payload;\n         p.header.state = empty;\n-        return some(option::unwrap(payload))\n+        return Some(option::unwrap(payload))\n       },\n-      terminated => return none,\n+      terminated => return None,\n       _ => {}\n     }\n \n@@ -475,14 +475,14 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n             fail ~\"blocking on already blocked packet\"\n           },\n           full => {\n-            let mut payload = none;\n+            let mut payload = None;\n             payload <-> p.payload;\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::rust_task_deref(old_task);\n             }\n             p.header.state = empty;\n-            return some(option::unwrap(payload))\n+            return Some(option::unwrap(payload))\n           }\n           terminated => {\n             // This assert detects when we've accidentally unsafely\n@@ -493,7 +493,7 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n             if !old_task.is_null() {\n                 rustrt::rust_task_deref(old_task);\n             }\n-            return none;\n+            return None;\n           }\n         }\n         first = false;\n@@ -603,11 +603,11 @@ fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n         let pos = vec::position(pkts, |p| p.header() == event);\n \n         match pos {\n-          some(i) => {\n+          Some(i) => {\n             ready_packet = i;\n             data_avail = true;\n           }\n-          none => debug!(\"ignoring spurious event, %?\", event)\n+          None => debug!(\"ignoring spurious event, %?\", event)\n         }\n     }\n \n@@ -640,10 +640,10 @@ match select2(a, b) {\n   right((a, none)) {\n     // endpoint b was closed.\n   }\n-  left((some(_), b)) {\n+  left((Some(_), b)) {\n     // endpoint a received a message\n   }\n-  right(a, some(_)) {\n+  right(a, Some(_)) {\n     // endpoint b received a message.\n   }\n }\n@@ -656,8 +656,8 @@ this case, `select2` may return either `left` or `right`.\n fn select2<A: send, Ab: send, B: send, Bb: send>(\n     +a: recv_packet_buffered<A, Ab>,\n     +b: recv_packet_buffered<B, Bb>)\n-    -> Either<(option<A>, recv_packet_buffered<B, Bb>),\n-              (recv_packet_buffered<A, Ab>, option<B>)>\n+    -> Either<(Option<A>, recv_packet_buffered<B, Bb>),\n+              (recv_packet_buffered<A, Ab>, Option<B>)>\n {\n     let i = wait_many([a.header(), b.header()]/_);\n \n@@ -696,7 +696,7 @@ fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> Either<(), ()> {\n \n */\n fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n-    -> (uint, option<T>, ~[recv_packet_buffered<T, Tb>])\n+    -> (uint, Option<T>, ~[recv_packet_buffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n     let mut remaining = endpoints;\n@@ -717,13 +717,13 @@ fn send_packet<T: send>(p: *packet<T>) -> send_packet<T> {\n }\n \n struct send_packet_buffered<T: send, Tbuffer: send> {\n-    let mut p: option<*packet<T>>;\n-    let mut buffer: option<buffer_resource<Tbuffer>>;\n+    let mut p: Option<*packet<T>>;\n+    let mut buffer: Option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n         //debug!(\"take send %?\", p);\n-        self.p = some(p);\n+        self.p = Some(p);\n         unsafe {\n-            self.buffer = some(\n+            self.buffer = Some(\n                 buffer_resource(\n                     get_buffer(ptr::addr_of((*p).header))));\n         };\n@@ -732,8 +732,8 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n         //if self.p != none {\n         //    debug!(\"drop send %?\", option::get(self.p));\n         //}\n-        if self.p != none {\n-            let mut p = none;\n+        if self.p != None {\n+            let mut p = None;\n             p <-> self.p;\n             sender_terminate(option::unwrap(p))\n         }\n@@ -743,26 +743,26 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n         //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n-        let mut p = none;\n+        let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n     pure fn header() -> *packet_header {\n         match self.p {\n-          some(packet) => unsafe {\n+          Some(packet) => unsafe {\n             let packet = &*packet;\n             let header = ptr::addr_of(packet.header);\n             //forget(packet);\n             header\n           },\n-          none => fail ~\"packet already consumed\"\n+          None => fail ~\"packet already consumed\"\n         }\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n-        let mut tmp = none;\n+        let mut tmp = None;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n     }\n@@ -778,13 +778,13 @@ fn recv_packet<T: send>(p: *packet<T>) -> recv_packet<T> {\n }\n \n struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n-    let mut p: option<*packet<T>>;\n-    let mut buffer: option<buffer_resource<Tbuffer>>;\n+    let mut p: Option<*packet<T>>;\n+    let mut buffer: Option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n         //debug!(\"take recv %?\", p);\n-        self.p = some(p);\n+        self.p = Some(p);\n         unsafe {\n-            self.buffer = some(\n+            self.buffer = Some(\n                 buffer_resource(\n                     get_buffer(ptr::addr_of((*p).header))));\n         };\n@@ -793,8 +793,8 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n         //if self.p != none {\n         //    debug!(\"drop recv %?\", option::get(self.p));\n         //}\n-        if self.p != none {\n-            let mut p = none;\n+        if self.p != None {\n+            let mut p = None;\n             p <-> self.p;\n             receiver_terminate(option::unwrap(p))\n         }\n@@ -804,26 +804,26 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n         //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n-        let mut p = none;\n+        let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n     pure fn header() -> *packet_header {\n         match self.p {\n-          some(packet) => unsafe {\n+          Some(packet) => unsafe {\n             let packet = &*packet;\n             let header = ptr::addr_of(packet.header);\n             //forget(packet);\n             header\n           },\n-          none => fail ~\"packet already consumed\"\n+          None => fail ~\"packet already consumed\"\n         }\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n-        let mut tmp = none;\n+        let mut tmp = None;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n     }\n@@ -852,9 +852,9 @@ fn spawn_service<T: send, Tb: send>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut some(server);\n+    let server = ~mut Some(server);\n     do task::spawn |move service| {\n-        let mut server_ = none;\n+        let mut server_ = None;\n         server_ <-> *server;\n         service(option::unwrap(server_))\n     }\n@@ -876,9 +876,9 @@ fn spawn_service_recv<T: send, Tb: send>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut some(server);\n+    let server = ~mut Some(server);\n     do task::spawn |move service| {\n-        let mut server_ = none;\n+        let mut server_ = None;\n         server_ <-> *server;\n         service(option::unwrap(server_))\n     }\n@@ -915,7 +915,7 @@ trait recv<T: send> {\n     the connection is closed.\n \n     */\n-    fn try_recv() -> option<T>;\n+    fn try_recv() -> Option<T>;\n \n     /** Returns true if a message is available or the connection is\n     closed.\n@@ -925,15 +925,15 @@ trait recv<T: send> {\n }\n \n #[doc(hidden)]\n-type chan_<T:send> = { mut endp: option<streamp::client::open<T>> };\n+type chan_<T:send> = { mut endp: Option<streamp::client::open<T>> };\n \n /// An endpoint that can send many messages.\n enum chan<T:send> {\n     chan_(chan_<T>)\n }\n \n #[doc(hidden)]\n-type port_<T:send> = { mut endp: option<streamp::server::open<T>> };\n+type port_<T:send> = { mut endp: Option<streamp::server::open<T>> };\n \n /// An endpoint that can receive many messages.\n enum port<T:send> {\n@@ -948,57 +948,57 @@ These allow sending or receiving an unlimited number of messages.\n fn stream<T:send>() -> (chan<T>, port<T>) {\n     let (c, s) = streamp::init();\n \n-    (chan_({ mut endp: some(c) }), port_({ mut endp: some(s) }))\n+    (chan_({ mut endp: Some(c) }), port_({ mut endp: Some(s) }))\n }\n \n impl<T: send> chan<T>: channel<T> {\n     fn send(+x: T) {\n-        let mut endp = none;\n+        let mut endp = None;\n         endp <-> self.endp;\n-        self.endp = some(\n+        self.endp = Some(\n             streamp::client::data(unwrap(endp), x))\n     }\n \n     fn try_send(+x: T) -> bool {\n-        let mut endp = none;\n+        let mut endp = None;\n         endp <-> self.endp;\n         match move streamp::client::try_data(unwrap(endp), x) {\n-            some(move next) => {\n-                self.endp = some(next);\n+            Some(move next) => {\n+                self.endp = Some(next);\n                 true\n             }\n-            none => false\n+            None => false\n         }\n     }\n }\n \n impl<T: send> port<T>: recv<T> {\n     fn recv() -> T {\n-        let mut endp = none;\n+        let mut endp = None;\n         endp <-> self.endp;\n         let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n-        self.endp = some(endp);\n+        self.endp = Some(endp);\n         x\n     }\n \n-    fn try_recv() -> option<T> {\n-        let mut endp = none;\n+    fn try_recv() -> Option<T> {\n+        let mut endp = None;\n         endp <-> self.endp;\n         match move pipes::try_recv(unwrap(endp)) {\n-          some(streamp::data(move x, move endp)) => {\n-            self.endp = some(endp);\n-            some(x)\n+          Some(streamp::data(move x, move endp)) => {\n+            self.endp = Some(endp);\n+            Some(x)\n           }\n-          none => none\n+          None => None\n         }\n     }\n \n     pure fn peek() -> bool unchecked {\n-        let mut endp = none;\n+        let mut endp = None;\n         endp <-> self.endp;\n         let peek = match endp {\n-          some(endp) => pipes::peek(&endp),\n-          none => fail ~\"peeking empty stream\"\n+          Some(endp) => pipes::peek(&endp),\n+          None => fail ~\"peeking empty stream\"\n         };\n         self.endp <-> endp;\n         peek\n@@ -1021,19 +1021,19 @@ struct PortSet<T: send> : recv<T> {\n         ch\n     }\n \n-    fn try_recv() -> option<T> {\n-        let mut result = none;\n+    fn try_recv() -> Option<T> {\n+        let mut result = None;\n         // we have to swap the ports array so we aren't borrowing\n         // aliasable mutable memory.\n         let mut ports = ~[];\n         ports <-> self.ports;\n-        while result == none && ports.len() > 0 {\n+        while result == None && ports.len() > 0 {\n             let i = wait_many(ports);\n             match move ports[i].try_recv() {\n-                some(move m) => {\n-                  result = some(m);\n+                Some(move m) => {\n+                  result = Some(m);\n                 }\n-                none => {\n+                None => {\n                     // Remove this port.\n                     let _ = vec::swap_remove(ports, i);\n                 }\n@@ -1060,8 +1060,8 @@ struct PortSet<T: send> : recv<T> {\n impl<T: send> port<T>: selectable {\n     pure fn header() -> *packet_header unchecked {\n         match self.endp {\n-          some(endp) => endp.header(),\n-          none => fail ~\"peeking empty stream\"\n+          Some(endp) => endp.header(),\n+          None => fail ~\"peeking empty stream\"\n         }\n     }\n }\n@@ -1071,18 +1071,18 @@ type SharedChan<T: send> = unsafe::Exclusive<chan<T>>;\n \n impl<T: send> SharedChan<T>: channel<T> {\n     fn send(+x: T) {\n-        let mut xx = some(x);\n+        let mut xx = Some(x);\n         do self.with |chan| {\n-            let mut x = none;\n+            let mut x = None;\n             x <-> xx;\n             chan.send(option::unwrap(x))\n         }\n     }\n \n     fn try_send(+x: T) -> bool {\n-        let mut xx = some(x);\n+        let mut xx = Some(x);\n         do self.with |chan| {\n-            let mut x = none;\n+            let mut x = None;\n             x <-> xx;\n             chan.try_send(option::unwrap(x))\n         }\n@@ -1097,7 +1097,7 @@ fn SharedChan<T:send>(+c: chan<T>) -> SharedChan<T> {\n /// Receive a message from one of two endpoints.\n trait select2<T: send, U: send> {\n     /// Receive a message or return `none` if a connection closes.\n-    fn try_select() -> Either<option<T>, option<U>>;\n+    fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n     fn select() -> Either<T, U>;\n }\n@@ -1114,7 +1114,7 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n         }\n     }\n \n-    fn try_select() -> Either<option<T>, option<U>> {\n+    fn try_select() -> Either<Option<T>, Option<U>> {\n         match self {\n           (lp, rp) => match select2i(&lp, &rp) {\n             Left(()) => Left (lp.try_recv()),\n@@ -1150,13 +1150,13 @@ fn recv_one<T: send>(+port: port_one<T>) -> T {\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-fn try_recv_one<T: send> (+port: port_one<T>) -> option<T> {\n+fn try_recv_one<T: send> (+port: port_one<T>) -> Option<T> {\n     let message = try_recv(port);\n \n-    if message == none { none }\n+    if message == None { None }\n     else {\n         let oneshot::send(message) = option::unwrap(message);\n-        some(message)\n+        Some(message)\n     }\n }\n \n@@ -1177,8 +1177,8 @@ fn try_send_one<T: send>(+chan: chan_one<T>, +data: T)\n mod rt {\n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    fn make_some<T>(+val: T) -> option<T> { some(val) }\n-    fn make_none<T>() -> option<T> { none }\n+    fn make_some<T>(+val: T) -> Option<T> { Some(val) }\n+    fn make_none<T>() -> Option<T> { None }\n }\n \n #[cfg(test)]"}, {"sha": "9a6dd7f23bfa057261298bcc60c41cf8bb0385b8", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -169,12 +169,12 @@ impl Rng {\n         self.choose_option(values).get()\n     }\n \n-    /// Choose some(item) randomly, returning none if values is empty\n-    fn choose_option<T:copy>(values: ~[T]) -> option<T> {\n+    /// Choose Some(item) randomly, returning None if values is empty\n+    fn choose_option<T:copy>(values: ~[T]) -> Option<T> {\n         if values.is_empty() {\n-            none\n+            None\n         } else {\n-            some(values[self.gen_uint_range(0u, values.len())])\n+            Some(values[self.gen_uint_range(0u, values.len())])\n         }\n     }\n \n@@ -187,23 +187,23 @@ impl Rng {\n     }\n \n     /**\n-     * Choose some(item) respecting the relative weights, returning none if\n+     * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:copy>(v: ~[Weighted<T>]) -> option<T> {\n+    fn choose_weighted_option<T:copy>(v: ~[Weighted<T>]) -> Option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n         }\n         if total == 0u {\n-            return none;\n+            return None;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n         for v.each |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n-                return some(item.item);\n+                return Some(item.item);\n             }\n         }\n         unreachable();\n@@ -408,8 +408,8 @@ mod tests {\n     #[test]\n     fn choose_option() {\n         let r = rand::rng();\n-        assert r.choose_option(~[]) == none::<int>;\n-        assert r.choose_option(~[1, 1, 1]) == some(1);\n+        assert r.choose_option(~[]) == None::<int>;\n+        assert r.choose_option(~[1, 1, 1]) == Some(1);\n     }\n \n     #[test]\n@@ -426,12 +426,12 @@ mod tests {\n     fn choose_weighted_option() {\n         let r = rand::rng();\n         assert r.choose_weighted_option(~[{weight: 1u, item: 42}]) ==\n-               some(42);\n+               Some(42);\n         assert r.choose_weighted_option(~[\n             {weight: 0u, item: 42},\n             {weight: 1u, item: 43}\n-        ]) == some(43);\n-        assert r.choose_weighted_option(~[]) == none::<int>;\n+        ]) == Some(43);\n+        assert r.choose_weighted_option(~[]) == None::<int>;\n     }\n \n     #[test]"}, {"sha": "2afbd833dcf04572d41c9f80eb0ec0d98e7a959f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -280,12 +280,12 @@ fn map_vec<T,U:copy,V:copy>(\n }\n \n fn map_opt<T,U:copy,V:copy>(\n-    o_t: option<T>, op: fn(T) -> result<V,U>) -> result<option<V>,U> {\n+    o_t: Option<T>, op: fn(T) -> result<V,U>) -> result<Option<V>,U> {\n \n     match o_t {\n-      none => ok(none),\n-      some(t) => match op(t) {\n-        ok(v) => ok(some(v)),\n+      None => ok(None),\n+      Some(t) => match op(t) {\n+        ok(v) => ok(Some(v)),\n         err(e) => err(e)\n       }\n     }"}, {"sha": "167ecd9818ace2eea4864df31fa36fb360257a13", "filename": "src/libcore/run.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,7 +3,7 @@\n #[forbid(deprecated_pattern)];\n \n //! Process spawning\n-import option::{some, none};\n+import option::{Some, None};\n import libc::{pid_t, c_void, c_int};\n import io::ReaderUtil;\n \n@@ -68,8 +68,8 @@ trait Program {\n  * The process id of the spawned process\n  */\n fn spawn_process(prog: &str, args: &[~str],\n-                 env: &option<~[(~str,~str)]>,\n-                 dir: &option<~str>,\n+                 env: &Option<~[(~str,~str)]>,\n+                 dir: &Option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n     do with_argv(prog, args) |argv| {\n@@ -96,12 +96,12 @@ fn with_argv<T>(prog: &str, args: &[~str],\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: &option<~[(~str,~str)]>,\n+fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     match *env {\n-      some(es) if !vec::is_empty(es) => {\n+      Some(es) if !vec::is_empty(es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n@@ -121,14 +121,14 @@ fn with_envp<T>(env: &option<~[(~str,~str)]>,\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: &option<~[(~str,~str)]>,\n+fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     unsafe {\n         match *env {\n-          some(es) if !vec::is_empty(es) => {\n+          Some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n                 let (k,v) = e;\n@@ -145,11 +145,11 @@ fn with_envp<T>(env: &option<~[(~str,~str)]>,\n     }\n }\n \n-fn with_dirp<T>(d: &option<~str>,\n+fn with_dirp<T>(d: &Option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n     match *d {\n-      some(dir) => str::as_c_str(dir, cb),\n-      none => cb(ptr::null())\n+      Some(dir) => str::as_c_str(dir, cb),\n+      None => cb(ptr::null())\n     }\n }\n \n@@ -166,7 +166,7 @@ fn with_dirp<T>(d: &option<~str>,\n  * The process id\n  */\n fn run_program(prog: &str, args: &[~str]) -> int {\n-    let pid = spawn_process(prog, args, &none, &none,\n+    let pid = spawn_process(prog, args, &None, &None,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n     return waitpid(pid);\n@@ -193,7 +193,7 @@ fn start_program(prog: &str, args: &[~str]) -> Program {\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n     let pid =\n-        spawn_process(prog, args, &none, &none,\n+        spawn_process(prog, args, &None, &None,\n                       pipe_input.in, pipe_output.out,\n                       pipe_err.out);\n \n@@ -278,7 +278,7 @@ fn program_output(prog: &str, args: &[~str]) ->\n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, &none, &none,\n+    let pid = spawn_process(prog, args, &None, &None,\n                             pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n@@ -415,7 +415,7 @@ mod tests {\n \n         let pid =\n             run::spawn_process(\n-                \"cat\", [], &none, &none,\n+                \"cat\", [], &None, &None,\n                 pipe_in.in, pipe_out.out, pipe_err.out);\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n@@ -436,7 +436,7 @@ mod tests {\n     #[test]\n     fn waitpid() {\n         let pid = run::spawn_process(\"false\", [],\n-                                     &none, &none,\n+                                     &None, &None,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n         assert status == 1;"}, {"sha": "4166d556402176438470b5d43d4843862ea8e367", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -25,7 +25,7 @@ mod linear {\n             eqfn: pure fn~(x: &K, y: &K) -> bool,\n             resize_at: uint,\n             size: uint,\n-            buckets: ~[option<Bucket<K,V>>]})\n+            buckets: ~[Option<Bucket<K,V>>]})\n     }\n \n     // FIXME(#3148) -- we could rewrite found_entry\n@@ -56,7 +56,7 @@ mod linear {\n             eqfn: eqfn,\n             resize_at: resize_at(initial_capacity),\n             size: 0,\n-            buckets: vec::from_fn(initial_capacity, |_i| none)})\n+            buckets: vec::from_fn(initial_capacity, |_i| None)})\n     }\n \n     priv impl<K, V> LinearMap<K,V> {\n@@ -101,23 +101,23 @@ mod linear {\n \n         #[inline(always)]\n         pure fn bucket_for_key(&const self,\n-                               buckets: &[option<Bucket<K,V>>],\n+                               buckets: &[Option<Bucket<K,V>>],\n                                k: &K) -> SearchResult {\n             let hash = self.hashfn(k);\n             self.bucket_for_key_with_hash(buckets, hash, k)\n         }\n \n         #[inline(always)]\n         pure fn bucket_for_key_with_hash(&const self,\n-                                         buckets: &[option<Bucket<K,V>>],\n+                                         buckets: &[Option<Bucket<K,V>>],\n                                          hash: uint,\n                                          k: &K) -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match buckets[i] {\n-                  some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n+                  Some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n                     return FoundEntry(i);\n                   },\n-                  none => return FoundHole(i)\n+                  None => return FoundHole(i)\n                 }\n             };\n             return TableFull;\n@@ -130,19 +130,19 @@ mod linear {\n             let new_capacity = old_capacity * 2;\n             self.resize_at = ((new_capacity as float) * 3.0 / 4.0) as uint;\n \n-            let mut old_buckets = vec::from_fn(new_capacity, |_i| none);\n+            let mut old_buckets = vec::from_fn(new_capacity, |_i| None);\n             self.buckets <-> old_buckets;\n \n             for uint::range(0, old_capacity) |i| {\n-                let mut bucket = none;\n+                let mut bucket = None;\n                 bucket <-> old_buckets[i];\n                 if bucket.is_some() {\n                     self.insert_bucket(bucket);\n                 }\n             }\n         }\n \n-        fn insert_bucket(&mut self, +bucket: option<Bucket<K,V>>) {\n+        fn insert_bucket(&mut self, +bucket: Option<Bucket<K,V>>) {\n             let {hash, key, value} <- option::unwrap(bucket);\n             let _ = self.insert_internal(hash, key, value);\n         }\n@@ -156,22 +156,22 @@ mod linear {\n               FoundHole(idx) => {\n                 debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash);\n-                self.buckets[idx] = some({hash: hash, key: k, value: v});\n+                self.buckets[idx] = Some({hash: hash, key: k, value: v});\n                 self.size += 1;\n                 return true;\n               }\n               FoundEntry(idx) => {\n                 debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash);\n-                self.buckets[idx] = some({hash: hash, key: k, value: v});\n+                self.buckets[idx] = Some({hash: hash, key: k, value: v});\n                 return false;\n               }\n             }\n         }\n \n         fn search(&self,\n                   hash: uint,\n-                  op: fn(x: &option<Bucket<K,V>>) -> bool) {\n+                  op: fn(x: &Option<Bucket<K,V>>) -> bool) {\n             let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n         }\n     }\n@@ -218,10 +218,10 @@ mod linear {\n             };\n \n             let len_buckets = self.buckets.len();\n-            self.buckets[idx] = none;\n+            self.buckets[idx] = None;\n             idx = self.next_bucket(idx, len_buckets);\n             while self.buckets[idx].is_some() {\n-                let mut bucket = none;\n+                let mut bucket = None;\n                 bucket <-> self.buckets[idx];\n                 self.insert_bucket(bucket);\n                 idx = self.next_bucket(idx, len_buckets);\n@@ -232,7 +232,7 @@ mod linear {\n \n         fn clear(&mut self) {\n             for uint::range(0, self.buckets.len()) |idx| {\n-                self.buckets[idx] = none;\n+                self.buckets[idx] = None;\n             }\n             self.size = 0;\n         }\n@@ -292,18 +292,18 @@ mod linear {\n     }\n \n     impl<K,V: copy> LinearMap<K,V> {\n-        fn find(&const self, k: &K) -> option<V> {\n+        fn find(&const self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n               FoundEntry(idx) => {\n                 // FIXME (#3148): Once we rewrite found_entry, this\n                 // failure case won't be necessary\n                 match self.buckets[idx] {\n-                    some(bkt) => {some(copy bkt.value)}\n-                    none => fail ~\"LinearMap::find: internal logic error\"\n+                    Some(bkt) => {Some(copy bkt.value)}\n+                    None => fail ~\"LinearMap::find: internal logic error\"\n                 }\n               }\n               TableFull | FoundHole(_) => {\n-                none\n+                None\n               }\n             }\n         }"}, {"sha": "6a9ba9ff6f69dce417651aaa98521fd59879287a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -362,16 +362,16 @@ fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n /// Returns a string with leading whitespace removed\n pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n-      none => ~\"\",\n-      some(first) => unsafe { unsafe::slice_bytes(s, first, len(s)) }\n+      None => ~\"\",\n+      Some(first) => unsafe { unsafe::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n pure fn trim_right(s: &str) -> ~str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n-      none => ~\"\",\n-      some(last) => {\n+      None => ~\"\",\n+      Some(last) => {\n         let {next, _} = char_range_at(s, last);\n         unsafe { unsafe::slice_bytes(s, 0u, next) }\n       }\n@@ -831,7 +831,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find_char(s: &str, c: char) -> option<uint> {\n+pure fn find_char(s: &str, c: char) -> Option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -855,7 +855,7 @@ pure fn find_char(s: &str, c: char) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_char_from(s: &str, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -881,17 +881,17 @@ pure fn find_char_from(s: &str, c: char, start: uint) -> option<uint> {\n  * as defined by `is_char_boundary`.\n  */\n pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n-    -> option<uint> {\n+    -> Option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n         assert end <= len(s);\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n-            if s[i] == b { return some(i); }\n+            if s[i] == b { return Some(i); }\n             i += 1u;\n         }\n-        return none;\n+        return None;\n     } else {\n         find_between(s, start, end, |x| x == c)\n     }\n@@ -910,7 +910,7 @@ pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind_char(s: &str, c: char) -> option<uint> {\n+pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -934,7 +934,7 @@ pure fn rfind_char(s: &str, c: char) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_from(s: &str, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -960,17 +960,17 @@ pure fn rfind_char_from(s: &str, c: char, start: uint) -> option<uint> {\n  * as defined by `is_char_boundary`.\n  */\n pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n-    -> option<uint> {\n+    -> Option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n         assert start <= len(s);\n         let mut i = start;\n         let b = c as u8;\n         while i > end {\n             i -= 1u;\n-            if s[i] == b { return some(i); }\n+            if s[i] == b { return Some(i); }\n         }\n-        return none;\n+        return None;\n     } else {\n         rfind_between(s, start, end, |x| x == c)\n     }\n@@ -990,7 +990,7 @@ pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find(s: &str, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1015,7 +1015,7 @@ pure fn find(s: &str, f: fn(char) -> bool) -> option<uint> {\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n pure fn find_from(s: &str, start: uint, f: fn(char)\n-    -> bool) -> option<uint> {\n+    -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n@@ -1042,17 +1042,17 @@ pure fn find_from(s: &str, start: uint, f: fn(char)\n  * boundary, as defined by `is_char_boundary`.\n  */\n pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n-    -> option<uint> {\n+    -> Option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i < end {\n         let {ch, next} = char_range_at(s, i);\n-        if f(ch) { return some(i); }\n+        if f(ch) { return Some(i); }\n         i = next;\n     }\n-    return none;\n+    return None;\n }\n \n /**\n@@ -1069,7 +1069,7 @@ pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind(s: &str, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1094,7 +1094,7 @@ pure fn rfind(s: &str, f: fn(char) -> bool) -> option<uint> {\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n-    -> option<uint> {\n+    -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1121,17 +1121,17 @@ pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n  * boundary, as defined by `is_char_boundary`\n  */\n pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n-    -> option<uint> {\n+    -> Option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i > end {\n         let {ch, prev} = char_range_at_reverse(s, i);\n-        if f(ch) { return some(prev); }\n+        if f(ch) { return Some(prev); }\n         i = prev;\n     }\n-    return none;\n+    return None;\n }\n \n // Utility used by various searching functions\n@@ -1154,7 +1154,7 @@ pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pure fn find_str(haystack: &a/str, needle: &b/str) -> option<uint> {\n+pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1178,7 +1178,7 @@ pure fn find_str(haystack: &a/str, needle: &b/str) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`\n  */\n pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n-  -> option<uint> {\n+  -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n@@ -1204,20 +1204,20 @@ pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n  */\n pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n-  -> option<uint> {\n+  -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n     let needle_len = len(needle);\n-    if needle_len == 0u { return some(start); }\n-    if needle_len > end { return none; }\n+    if needle_len == 0u { return Some(start); }\n+    if needle_len > end { return None; }\n \n     let mut i = start;\n     let e = end - needle_len;\n     while i <= e {\n-        if match_at(haystack, needle, i) { return some(i); }\n+        if match_at(haystack, needle, i) { return Some(i); }\n         i += 1u;\n     }\n-    return none;\n+    return None;\n }\n \n /**\n@@ -2167,11 +2167,11 @@ mod tests {\n \n     #[test]\n     fn test_rfind_char() {\n-        assert rfind_char(~\"hello\", 'l') == some(3u);\n-        assert rfind_char(~\"hello\", 'o') == some(4u);\n-        assert rfind_char(~\"hello\", 'h') == some(0u);\n-        assert rfind_char(~\"hello\", 'z') == none;\n-        assert rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == some(30u);\n+        assert rfind_char(~\"hello\", 'l') == Some(3u);\n+        assert rfind_char(~\"hello\", 'o') == Some(4u);\n+        assert rfind_char(~\"hello\", 'h') == Some(0u);\n+        assert rfind_char(~\"hello\", 'z') == None;\n+        assert rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u);\n     }\n \n     #[test]\n@@ -2368,43 +2368,43 @@ mod tests {\n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert find_str(~\"banana\", ~\"apple pie\") == none;\n-        assert find_str(~\"\", ~\"\") == some(0u);\n+        assert find_str(~\"banana\", ~\"apple pie\") == None;\n+        assert find_str(~\"\", ~\"\") == Some(0u);\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert find_str(data, ~\"\")     == some(0u);\n-        assert find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == some( 0u);\n-        assert find_str(data, ~\"\u0e30\u0e40\")   == some( 6u);\n-        assert find_str(data, ~\"\u4e2d\u534e\") == some(27u);\n-        assert find_str(data, ~\"\u0e44\u0e17\u534e\") == none;\n+        assert find_str(data, ~\"\")     == Some(0u);\n+        assert find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u);\n+        assert find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u);\n+        assert find_str(data, ~\"\u4e2d\u534e\") == Some(27u);\n+        assert find_str(data, ~\"\u0e44\u0e17\u534e\") == None;\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert find_str_between(~\"\", ~\"\", 0u, 0u) == some(0u);\n+        assert find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u);\n \n         let data = ~\"abcabc\";\n-        assert find_str_between(data, ~\"ab\", 0u, 6u) == some(0u);\n-        assert find_str_between(data, ~\"ab\", 2u, 6u) == some(3u);\n-        assert find_str_between(data, ~\"ab\", 2u, 4u) == none;\n+        assert find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u);\n+        assert find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u);\n+        assert find_str_between(data, ~\"ab\", 2u, 4u) == None;\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data += data;\n-        assert find_str_between(data, ~\"\", 0u, 43u) == some(0u);\n-        assert find_str_between(data, ~\"\", 6u, 43u) == some(6u);\n-\n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == some( 0u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == some(12u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == some(24u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == some(34u);\n-        assert find_str_between(data, ~\"Nam\", 0u, 43u) == some(40u);\n-\n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == some(43u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == some(55u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == some(67u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == some(77u);\n-        assert find_str_between(data, ~\"Nam\", 43u, 86u) == some(83u);\n+        assert find_str_between(data, ~\"\", 0u, 43u) == Some(0u);\n+        assert find_str_between(data, ~\"\", 6u, 43u) == Some(6u);\n+\n+        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u);\n+        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u);\n+        assert find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u);\n+        assert find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u);\n+        assert find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u);\n+\n+        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u);\n+        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u);\n+        assert find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u);\n+        assert find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u);\n+        assert find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u);\n     }\n \n     #[test]"}, {"sha": "7afd81c01297382ed4919bb38a58c3fd4787140c", "filename": "src/libcore/task.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -139,7 +139,7 @@ enum SchedMode {\n  */\n type SchedOpts = {\n     mode: SchedMode,\n-    foreign_stack_size: option<uint>\n+    foreign_stack_size: Option<uint>\n };\n \n /**\n@@ -172,8 +172,8 @@ type SchedOpts = {\n type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n-    notify_chan: option<comm::Chan<Notification>>,\n-    sched: option<SchedOpts>,\n+    notify_chan: Option<comm::Chan<Notification>>,\n+    sched: Option<SchedOpts>,\n };\n \n /**\n@@ -193,7 +193,7 @@ type TaskOpts = {\n enum TaskBuilder = {\n     opts: TaskOpts,\n     gen_body: fn@(+fn~()) -> fn~(),\n-    can_not_copy: option<util::NonCopyable>,\n+    can_not_copy: Option<util::NonCopyable>,\n     mut consumed: bool,\n };\n \n@@ -206,7 +206,7 @@ fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n         gen_body: |body| body, // Identity function\n-        can_not_copy: none,\n+        can_not_copy: None,\n         mut consumed: false,\n     })\n }\n@@ -217,7 +217,7 @@ priv impl TaskBuilder {\n             fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n         }\n         self.consumed = true;\n-        TaskBuilder({ can_not_copy: none, mut consumed: false, with *self })\n+        TaskBuilder({ can_not_copy: None, mut consumed: false, with *self })\n     }\n }\n \n@@ -229,7 +229,7 @@ impl TaskBuilder {\n     fn unlinked() -> TaskBuilder {\n         TaskBuilder({\n             opts: { linked: false with self.opts },\n-            can_not_copy: none,\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n@@ -241,7 +241,7 @@ impl TaskBuilder {\n     fn supervised() -> TaskBuilder {\n         TaskBuilder({\n             opts: { linked: false, supervised: true with self.opts },\n-            can_not_copy: none,\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n@@ -252,7 +252,7 @@ impl TaskBuilder {\n     fn linked() -> TaskBuilder {\n         TaskBuilder({\n             opts: { linked: true, supervised: false with self.opts },\n-            can_not_copy: none,\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n@@ -296,17 +296,17 @@ impl TaskBuilder {\n \n         // Reconfigure self to use a notify channel.\n         TaskBuilder({\n-            opts: { notify_chan: some(ch) with self.opts },\n-            can_not_copy: none,\n+            opts: { notify_chan: Some(ch) with self.opts },\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n     /// Configure a custom scheduler mode for the task.\n     fn sched_mode(mode: SchedMode) -> TaskBuilder {\n         TaskBuilder({\n-            opts: { sched: some({ mode: mode, foreign_stack_size: none})\n+            opts: { sched: Some({ mode: mode, foreign_stack_size: None})\n                     with self.opts },\n-            can_not_copy: none,\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n@@ -327,7 +327,7 @@ impl TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         TaskBuilder({\n             gen_body: |body| { wrapper(prev_gen_body(body)) },\n-            can_not_copy: none,\n+            can_not_copy: None,\n             with *self.consume()\n         })\n     }\n@@ -350,7 +350,7 @@ impl TaskBuilder {\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: send>(+arg: A, +f: fn~(+A)) {\n-        let arg = ~mut some(arg);\n+        let arg = ~mut Some(arg);\n         do self.spawn {\n             f(option::swap_unwrap(arg))\n         }\n@@ -409,9 +409,9 @@ impl TaskBuilder {\n     fn try<T: send>(+f: fn~() -> T) -> result<T,()> {\n         let po = comm::port();\n         let ch = comm::chan(po);\n-        let mut result = none;\n+        let mut result = None;\n \n-        do self.future_result(|+r| { result = some(r); }).spawn {\n+        do self.future_result(|+r| { result = Some(r); }).spawn {\n             comm::send(ch, f());\n         }\n         match future::get(&option::unwrap(result)) {\n@@ -435,8 +435,8 @@ fn default_task_opts() -> TaskOpts {\n     {\n         linked: true,\n         supervised: false,\n-        notify_chan: none,\n-        sched: none\n+        notify_chan: None,\n+        sched: None\n     }\n }\n \n@@ -734,9 +734,9 @@ type TaskGroupData = {\n     // tasks in this group.\n     mut descendants: TaskSet,\n };\n-type TaskGroupArc = unsafe::Exclusive<option<TaskGroupData>>;\n+type TaskGroupArc = unsafe::Exclusive<Option<TaskGroupData>>;\n \n-type TaskGroupInner = &mut option<TaskGroupData>;\n+type TaskGroupInner = &mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n@@ -759,11 +759,11 @@ type AncestorNode = {\n     // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n     generation:       uint,\n     // Should really be an immutable non-option. This way appeases borrowck.\n-    mut parent_group: option<TaskGroupArc>,\n+    mut parent_group: Option<TaskGroupArc>,\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n };\n-enum AncestorList = option<unsafe::Exclusive<AncestorNode>>;\n+enum AncestorList = Option<unsafe::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n@@ -783,10 +783,10 @@ fn access_ancestors<U>(x: &unsafe::Exclusive<AncestorNode>,\n //     taskgroups that forward_blk already ran on successfully (Note: bail_blk\n //     is NOT called on the block that forward_blk broke on!).\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n-// FIXME(#2190): Change option<fn@(...)> to option<fn&(...)>, to save on\n+// FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n fn each_ancestor(list:        &mut AncestorList,\n-                 bail_opt:    option<fn@(TaskGroupInner)>,\n+                 bail_opt:    Option<fn@(TaskGroupInner)>,\n                  forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n     // \"Kickoff\" call - there was no last generation.\n@@ -795,11 +795,11 @@ fn each_ancestor(list:        &mut AncestorList,\n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n-                bail_opt:        option<fn@(TaskGroupInner)>,\n+                bail_opt:        Option<fn@(TaskGroupInner)>,\n                 forward_blk:     fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n-        let tmp_list = util::replace(list, AncestorList(none));\n+        let tmp_list = util::replace(list, AncestorList(None));\n         let (coalesce_this, early_break) =\n             iterate(&tmp_list, bail_opt, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n@@ -815,17 +815,17 @@ fn each_ancestor(list:        &mut AncestorList,\n     }\n \n     // Returns an optional list-to-coalesce and whether unwinding is needed.\n-    // option<ancestor_list>:\n+    // Option<ancestor_list>:\n     //     Whether or not the ancestor taskgroup being iterated over is\n     //     dead or not; i.e., it has no more tasks left in it, whether or not\n     //     it has descendants. If dead, the caller shall coalesce it away.\n     // bool:\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n     fn iterate(ancestors:       &AncestorList,\n-               bail_opt:        option<fn@(TaskGroupInner)>,\n+               bail_opt:        Option<fn@(TaskGroupInner)>,\n                forward_blk:     fn(TaskGroupInner) -> bool,\n-               last_generation: uint) -> (option<AncestorList>, bool) {\n+               last_generation: uint) -> (Option<AncestorList>, bool) {\n         // At each step of iteration, three booleans are at play which govern\n         // how the iteration should behave.\n         // 'nobe_is_dead' - Should the list should be coalesced at this point?\n@@ -837,7 +837,7 @@ fn each_ancestor(list:        &mut AncestorList,\n \n         // The map defaults to none, because if ancestors is none, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n-        return do (**ancestors).map_default((none,false)) |ancestor_arc| {\n+        return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(&ancestor_arc) |nobe| {\n                 // Check monotonicity\n@@ -852,8 +852,8 @@ fn each_ancestor(list:        &mut AncestorList,\n                         // Decide whether this group is dead. Note that the\n                         // group being *dead* is disjoint from it *failing*.\n                         nobe_is_dead = match *tg_opt {\n-                            some(ref tg) => taskgroup_is_dead(tg),\n-                            none => nobe_is_dead\n+                            Some(ref tg) => taskgroup_is_dead(tg),\n+                            None => nobe_is_dead\n                         };\n                         // Call iterator block. (If the group is dead, it's\n                         // safe to skip it. This will leave our *rust_task\n@@ -889,21 +889,21 @@ fn each_ancestor(list:        &mut AncestorList,\n                 if nobe_is_dead {\n                     // Swap the list out here; the caller replaces us with it.\n                     let rest = util::replace(&mut nobe.ancestors,\n-                                             AncestorList(none));\n-                    (some(rest), need_unwind)\n+                                             AncestorList(None));\n+                    (Some(rest), need_unwind)\n                 } else {\n-                    (none, need_unwind)\n+                    (None, need_unwind)\n                 }\n             }\n         };\n \n         // Wrapper around exclusive::with that appeases borrowck.\n-        fn with_parent_tg<U>(parent_group: &mut option<TaskGroupArc>,\n+        fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n                              blk: fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n-            *parent_group <- some(tmp_arc);\n+            *parent_group <- Some(tmp_arc);\n             result\n         }\n     }\n@@ -917,9 +917,9 @@ struct Tcb {\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n     let mut ancestors: AncestorList;\n     let is_main:       bool;\n-    let notifier:      option<AutoNotify>;\n+    let notifier:      Option<AutoNotify>;\n     new(me: *rust_task, -tasks: TaskGroupArc, -ancestors: AncestorList,\n-        is_main: bool, -notifier: option<AutoNotify>) {\n+        is_main: bool, -notifier: Option<AutoNotify>) {\n         self.me        = me;\n         self.tasks     = tasks;\n         self.ancestors = ancestors;\n@@ -945,7 +945,7 @@ struct Tcb {\n         // It doesn't matter whether this happens before or after dealing with\n         // our own taskgroup, so long as both happen before we die. We need to\n         // remove ourself from every ancestor we can, so no cleanup; no break.\n-        for each_ancestor(&mut self.ancestors, none) |ancestor_group| {\n+        for each_ancestor(&mut self.ancestors, None) |ancestor_group| {\n             leave_taskgroup(ancestor_group, self.me, false);\n         };\n     }\n@@ -966,13 +966,13 @@ struct AutoNotify {\n \n fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) -> bool {\n-    let newstate = util::replace(state, none);\n+    let newstate = util::replace(state, None);\n     // If 'none', the group was failing. Can't enlist.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = some(group);\n+        *state = Some(group);\n         true\n     } else {\n         false\n@@ -981,13 +981,13 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n-    let newstate = util::replace(state, none);\n+    let newstate = util::replace(state, None);\n     // If 'none', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = some(group);\n+        *state = Some(group);\n     }\n }\n \n@@ -1001,7 +1001,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // so if we're failing, all concurrently exiting tasks must wait for us.\n     // To do it differently, we'd have to use the runtime's task refcounting,\n     // but that could leave task structs around long after their task exited.\n-    let newstate = util::replace(state, none);\n+    let newstate = util::replace(state, None);\n     // Might already be none, if somebody is failing simultaneously.\n     // That's ok; only one task needs to do the dirty work. (Might also\n     // see 'none' if somebody already failed and we got a kill signal.)\n@@ -1021,7 +1021,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         if is_main {\n             rustrt::rust_task_kill_all(me);\n         }\n-        // Do NOT restore state to some(..)! It stays none to indicate\n+        // Do NOT restore state to Some(..)! It stays none to indicate\n         // that the whole taskgroup is failing, to forbid new spawns.\n     }\n     // (note: multiple tasks may reach this point)\n@@ -1042,20 +1042,20 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n      *######################################################################*/\n     let spawner_group = match unsafe { local_get(spawner,\n                                                  taskgroup_key!()) } {\n-        none => {\n+        None => {\n             // Main task, doing first spawn ever. Lazily initialise here.\n             let mut members = new_taskset();\n             taskset_insert(&mut members, spawner);\n             let tasks =\n-                unsafe::exclusive(some({ mut members:     members,\n+                unsafe::exclusive(Some({ mut members:     members,\n                                          mut descendants: new_taskset() }));\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n-                @Tcb(spawner, tasks, AncestorList(none), true, none);\n+                @Tcb(spawner, tasks, AncestorList(None), true, None);\n             unsafe { local_set(spawner, taskgroup_key!(), group); }\n             group\n         }\n-        some(group) => group\n+        Some(group) => group\n     };\n     /*######################################################################*\n      * Step 2. Process spawn options for child.\n@@ -1069,7 +1069,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         (g, a, spawner_group.is_main)\n     } else {\n         // Child is in a separate group from spawner.\n-        let g = unsafe::exclusive(some({ mut members:     new_taskset(),\n+        let g = unsafe::exclusive(Some({ mut members:     new_taskset(),\n                                          mut descendants: new_taskset() }));\n         let a = if supervised {\n             // Child's ancestors start with the spawner.\n@@ -1079,35 +1079,35 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // it should be enabled only in debug builds.\n             let new_generation =\n                 match *old_ancestors {\n-                    some(arc) => access_ancestors(&arc, |a| a.generation+1),\n-                    none      => 0 // the actual value doesn't really matter.\n+                    Some(arc) => access_ancestors(&arc, |a| a.generation+1),\n+                    None      => 0 // the actual value doesn't really matter.\n                 };\n             assert new_generation < uint::max_value;\n             // Build a new node in the ancestor list.\n-            AncestorList(some(unsafe::exclusive(\n+            AncestorList(Some(unsafe::exclusive(\n                 { generation:       new_generation,\n-                  mut parent_group: some(spawner_group.tasks.clone()),\n+                  mut parent_group: Some(spawner_group.tasks.clone()),\n                   mut ancestors:    old_ancestors })))\n         } else {\n             // Child has no ancestors.\n-            AncestorList(none)\n+            AncestorList(None)\n         };\n         (g,a, false)\n     };\n \n     fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n         // Appease the borrow-checker. Really this wants to be written as:\n         // match ancestors\n-        //    some(ancestor_arc) { ancestor_list(some(ancestor_arc.clone())) }\n+        //    Some(ancestor_arc) { ancestor_list(Some(ancestor_arc.clone())) }\n         //    none               { ancestor_list(none) }\n-        let tmp = util::replace(&mut **ancestors, none);\n+        let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n             let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n-            **ancestors <- some(ancestor_arc);\n-            AncestorList(some(result))\n+            **ancestors <- Some(ancestor_arc);\n+            AncestorList(Some(result))\n         } else {\n-            AncestorList(none)\n+            AncestorList(None)\n         }\n     }\n }\n@@ -1117,15 +1117,15 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut some((child_tg, ancestors, f));\n+        let child_data = ~mut Some((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n             let new_task = match opts.sched {\n-              none             => rustrt::new_task(),\n-              some(sched_opts) => new_task_in_new_sched(sched_opts)\n+              None             => rustrt::new_task(),\n+              Some(sched_opts) => new_task_in_new_sched(sched_opts)\n             };\n             assert !new_task.is_null();\n             // Getting killed after here would leak the task.\n@@ -1152,9 +1152,9 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     // (4) ...and runs the provided body function.\n     fn make_child_wrapper(child: *rust_task, +child_arc: TaskGroupArc,\n                           +ancestors: AncestorList, is_main: bool,\n-                          notify_chan: option<comm::Chan<Notification>>,\n+                          notify_chan: Option<comm::Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n-        let child_data = ~mut some((child_arc, ancestors));\n+        let child_data = ~mut Some((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n@@ -1191,7 +1191,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n                 };\n                 // Attempt to join every ancestor group.\n                 result =\n-                    for each_ancestor(ancestors, some(bail)) |ancestor_tg| {\n+                    for each_ancestor(ancestors, Some(bail)) |ancestor_tg| {\n                         // Enlist as a descendant, not as an actual member.\n                         // Descendants don't kill ancestor groups on failure.\n                         if !enlist_in_taskgroup(ancestor_tg, child, false) {\n@@ -1210,7 +1210,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     }\n \n     fn new_task_in_new_sched(opts: SchedOpts) -> *rust_task {\n-        if opts.foreign_stack_size != none {\n+        if opts.foreign_stack_size != None {\n             fail ~\"foreign_stack_size scheduler option unimplemented\";\n         }\n \n@@ -1277,7 +1277,7 @@ impl<T: owned> @T: LocalData { }\n // heavily in future, this could be made more efficient with a proper map.\n type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<option<TaskLocalElement>>;\n+type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n@@ -1318,16 +1318,16 @@ unsafe fn key_to_key_value<T: owned>(\n     pair.first()\n }\n \n-// If returning some(..), returns with @T with the map's reference. Careful!\n+// If returning Some(..), returns with @T with the map's reference. Careful!\n unsafe fn local_data_lookup<T: owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n-    -> option<(uint, *libc::c_void)> {\n+    -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n         match entry {\n-            some((k,_,_)) => k == key_value,\n-            none => false\n+            Some((k,_,_)) => k == key_value,\n+            None => false\n         }\n     );\n     do map_pos.map |index| {\n@@ -1339,7 +1339,7 @@ unsafe fn local_data_lookup<T: owned>(\n \n unsafe fn local_get_helper<T: owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n-    do_pop: bool) -> option<@T> {\n+    do_pop: bool) -> Option<@T> {\n \n     let map = get_task_local_map(task);\n     // Interpreturn our findings from the map\n@@ -1352,22 +1352,22 @@ unsafe fn local_get_helper<T: owned>(\n         let data: @T = unsafe::transmute(data_ptr);\n         unsafe::bump_box_refcount(data);\n         if do_pop {\n-            (*map).set_elt(index, none);\n+            (*map).set_elt(index, None);\n         }\n         data\n     }\n }\n \n unsafe fn local_pop<T: owned>(\n     task: *rust_task,\n-    key: LocalDataKey<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n unsafe fn local_get<T: owned>(\n     task: *rust_task,\n-    key: LocalDataKey<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, false)\n }\n@@ -1386,27 +1386,27 @@ unsafe fn local_set<T: owned>(\n     let data_ptr = unsafe::reinterpret_cast(data);\n     let data_box = data as LocalData;\n     // Construct new entry to store in the map.\n-    let new_entry = some((keyval, data_ptr, data_box));\n+    let new_entry = Some((keyval, data_ptr, data_box));\n     // Find a place to put it.\n     match local_data_lookup(map, key) {\n-        some((index, _old_data_ptr)) => {\n+        Some((index, _old_data_ptr)) => {\n             // Key already had a value set, _old_data_ptr, whose reference\n             // will get dropped when the local_data box is overwritten.\n             (*map).set_elt(index, new_entry);\n         }\n-        none => {\n+        None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).position(|x| x == none) {\n-                some(empty_index) => (*map).set_elt(empty_index, new_entry),\n-                none => (*map).push(new_entry)\n+            match (*map).position(|x| x == None) {\n+                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n+                None => (*map).push(new_entry)\n             }\n         }\n     }\n }\n \n unsafe fn local_modify<T: owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n-    modify_fn: fn(option<@T>) -> option<@T>) {\n+    modify_fn: fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n@@ -1421,7 +1421,7 @@ unsafe fn local_modify<T: owned>(\n  * reference that was originally created to insert it.\n  */\n unsafe fn local_data_pop<T: owned>(\n-    key: LocalDataKey<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> Option<@T> {\n \n     local_pop(rustrt::rust_get_task(), key)\n }\n@@ -1430,7 +1430,7 @@ unsafe fn local_data_pop<T: owned>(\n  * table until explicitly removed.\n  */\n unsafe fn local_data_get<T: owned>(\n-    key: LocalDataKey<T>) -> option<@T> {\n+    key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get(rustrt::rust_get_task(), key)\n }\n@@ -1449,7 +1449,7 @@ unsafe fn local_data_set<T: owned>(\n  */\n unsafe fn local_data_modify<T: owned>(\n     key: LocalDataKey<T>,\n-    modify_fn: fn(option<@T>) -> option<@T>) {\n+    modify_fn: fn(Option<@T>) -> Option<@T>) {\n \n     local_modify(rustrt::rust_get_task(), key, modify_fn)\n }\n@@ -1570,7 +1570,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     let b0 = task();\n     let b1 = TaskBuilder({\n         opts: { linked: true, supervised: true with b0.opts },\n-        can_not_copy: none,\n+        can_not_copy: None,\n         with *b0\n     });\n     do b1.spawn { fail; }\n@@ -1583,7 +1583,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     let b0 = task();\n     let b1 = TaskBuilder({\n         opts: { linked: true, supervised: true with b0.opts },\n-        can_not_copy: none,\n+        can_not_copy: None,\n         with *b0\n     });\n     do b1.spawn { loop { task::yield(); } }\n@@ -1670,7 +1670,7 @@ fn test_spawn_raw_notify() {\n     let notify_ch = comm::chan(notify_po);\n \n     let opts = {\n-        notify_chan: some(notify_ch)\n+        notify_chan: Some(notify_ch)\n         with default_task_opts()\n     };\n     do spawn_raw(opts) {\n@@ -1681,7 +1681,7 @@ fn test_spawn_raw_notify() {\n \n     let opts = {\n         linked: false,\n-        notify_chan: some(notify_ch)\n+        notify_chan: Some(notify_ch)\n         with default_task_opts()\n     };\n     do spawn_raw(opts) {\n@@ -1720,12 +1720,12 @@ fn test_add_wrapper() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_future_result() {\n-    let mut result = none;\n-    do task().future_result(|+r| { result = some(r); }).spawn { }\n+    let mut result = None;\n+    do task().future_result(|+r| { result = Some(r); }).spawn { }\n     assert future::get(&option::unwrap(result)) == Success;\n \n-    result = none;\n-    do task().future_result(|+r| { result = some(r); }).unlinked().spawn {\n+    result = None;\n+    do task().future_result(|+r| { result = Some(r); }).unlinked().spawn {\n         fail;\n     }\n     assert future::get(&option::unwrap(result)) == Failure;\n@@ -2090,7 +2090,7 @@ fn test_tls_multitask() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n-        assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n+        assert local_data_get(my_key) == None; // TLS shouldn't carry over.\n         local_data_set(my_key, @~\"child data\");\n         assert *(local_data_get(my_key).get()) == ~\"child data\";\n         // should be cleaned up for us\n@@ -2115,23 +2115,23 @@ fn test_tls_pop() unsafe {\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n     // Pop must remove the data from the map.\n-    assert local_data_pop(my_key) == none;\n+    assert local_data_pop(my_key) == None;\n }\n \n #[test]\n fn test_tls_modify() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n-            some(@val) => fail ~\"unwelcome value: \" + val,\n-            none       => some(@~\"first data\")\n+            Some(@val) => fail ~\"unwelcome value: \" + val,\n+            None       => Some(@~\"first data\")\n         }\n     });\n     local_data_modify(my_key, |data| {\n         match data {\n-            some(@~\"first data\") => some(@~\"next data\"),\n-            some(@val)           => fail ~\"wrong value: \" + val,\n-            none                 => fail ~\"missing value\"\n+            Some(@~\"first data\") => Some(@~\"next data\"),\n+            Some(@val)           => fail ~\"wrong value: \" + val,\n+            None                 => fail ~\"missing value\"\n         }\n     });\n     assert *(local_data_pop(my_key).get()) == ~\"next data\";"}, {"sha": "1aa46e628252c9f91195f0e8e4a22b37c7532dc8", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -121,37 +121,37 @@ impl T: iter::TimesIx {\n  *\n  * `buf` must not be empty\n  */\n-fn parse_buf(buf: &[const u8], radix: uint) -> option<T> {\n-    if vec::len(buf) == 0u { return none; }\n+fn parse_buf(buf: &[const u8], radix: uint) -> Option<T> {\n+    if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u as T;\n     let mut n = 0u as T;\n     loop {\n         match char::to_digit(buf[i] as char, radix) {\n-          some(d) => n += d as T * power,\n-          none => return none\n+          Some(d) => n += d as T * power,\n+          None => return None\n         }\n         power *= radix as T;\n-        if i == 0u { return some(n); }\n+        if i == 0u { return Some(n); }\n         i -= 1u;\n     };\n }\n \n /// Parse a string to an int\n-fn from_str(s: ~str) -> option<T> { parse_buf(str::to_bytes(s), 10u) }\n+fn from_str(s: ~str) -> Option<T> { parse_buf(str::to_bytes(s), 10u) }\n \n /// Parse a string as an unsigned integer.\n-fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n-    if str::len(buf) == 0u { return none; }\n+fn from_str_radix(buf: ~str, radix: u64) -> Option<u64> {\n+    if str::len(buf) == 0u { return None; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n     loop {\n         match char::to_digit(buf[i] as char, radix as uint) {\n-          some(d) => n += d as u64 * power,\n-          none => return none\n+          Some(d) => n += d as u64 * power,\n+          None => return None\n         }\n         power *= radix;\n-        if i == 0u { return some(n); }\n+        if i == 0u { return Some(n); }\n         i -= 1u;\n     };\n }\n@@ -253,30 +253,30 @@ fn test_to_str() {\n #[test]\n #[ignore]\n fn test_from_str() {\n-    assert from_str(~\"0\") == some(0u as T);\n-    assert from_str(~\"3\") == some(3u as T);\n-    assert from_str(~\"10\") == some(10u as T);\n-    assert from_str(~\"123456789\") == some(123456789u as T);\n-    assert from_str(~\"00100\") == some(100u as T);\n-\n-    assert from_str(~\"\") == none;\n-    assert from_str(~\" \") == none;\n-    assert from_str(~\"x\") == none;\n+    assert from_str(~\"0\") == Some(0u as T);\n+    assert from_str(~\"3\") == Some(3u as T);\n+    assert from_str(~\"10\") == Some(10u as T);\n+    assert from_str(~\"123456789\") == Some(123456789u as T);\n+    assert from_str(~\"00100\") == Some(100u as T);\n+\n+    assert from_str(~\"\") == None;\n+    assert from_str(~\" \") == None;\n+    assert from_str(~\"x\") == None;\n }\n \n #[test]\n #[ignore]\n fn test_parse_buf() {\n     import str::to_bytes;\n-    assert parse_buf(to_bytes(~\"123\"), 10u) == some(123u as T);\n-    assert parse_buf(to_bytes(~\"1001\"), 2u) == some(9u as T);\n-    assert parse_buf(to_bytes(~\"123\"), 8u) == some(83u as T);\n-    assert parse_buf(to_bytes(~\"123\"), 16u) == some(291u as T);\n-    assert parse_buf(to_bytes(~\"ffff\"), 16u) == some(65535u as T);\n-    assert parse_buf(to_bytes(~\"z\"), 36u) == some(35u as T);\n-\n-    assert parse_buf(to_bytes(~\"Z\"), 10u) == none;\n-    assert parse_buf(to_bytes(~\"_\"), 2u) == none;\n+    assert parse_buf(to_bytes(~\"123\"), 10u) == Some(123u as T);\n+    assert parse_buf(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n+    assert parse_buf(to_bytes(~\"123\"), 8u) == Some(83u as T);\n+    assert parse_buf(to_bytes(~\"123\"), 16u) == Some(291u as T);\n+    assert parse_buf(to_bytes(~\"ffff\"), 16u) == Some(65535u as T);\n+    assert parse_buf(to_bytes(~\"z\"), 36u) == Some(35u as T);\n+\n+    assert parse_buf(to_bytes(~\"Z\"), 10u) == None;\n+    assert parse_buf(to_bytes(~\"_\"), 2u) == None;\n }\n \n #[test]"}, {"sha": "97c08e98945b79ce0ba8075c708aa142459f6100", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -73,14 +73,14 @@ unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n // An unwrapper uses this protocol to communicate with the \"other\" task that\n // drops the last refcount on an arc. Unfortunately this can't be a proper\n // pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~mut option<(pipes::chan_one<()>, pipes::port_one<bool>)>;\n+type UnwrapProto = ~mut Option<(pipes::chan_one<()>, pipes::port_one<bool>)>;\n \n struct ArcData<T> {\n     mut count:     libc::intptr_t;\n     mut unwrapper: libc::uintptr_t; // either a UnwrapProto or 0\n     // FIXME(#3224) should be able to make this non-option to save memory, and\n     // in unwrap() use \"let ~ArcData { data: result, _ } = thing\" to unwrap it\n-    mut data:      option<T>;\n+    mut data:      Option<T>;\n }\n \n struct ArcDestruct<T> {\n@@ -125,8 +125,8 @@ struct ArcDestruct<T> {\n unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n-        mut ptr:      option<~ArcData<T>>;\n-        mut response: option<pipes::chan_one<bool>>;\n+        mut ptr:      Option<~ArcData<T>>;\n+        mut response: Option<pipes::chan_one<bool>>;\n         drop unsafe {\n             let response = option::swap_unwrap(&mut self.response);\n             // In case we get killed early, we need to tell the person who\n@@ -147,7 +147,7 @@ unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast(rc.data);\n         let (c1,p1) = pipes::oneshot(); // ()\n         let (c2,p2) = pipes::oneshot(); // bool\n-        let server: UnwrapProto = ~mut some((c1,p2));\n+        let server: UnwrapProto = ~mut Some((c1,p2));\n         let serverp: libc::uintptr_t = unsafe::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n         if rustrt::rust_compare_and_swap_ptr(&mut ptr.unwrapper, 0, serverp) {\n@@ -165,8 +165,8 @@ unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n             } else {\n                 // The *next* person who sees the refcount hit 0 will wake us.\n                 let end_result =\n-                    DeathThroes { ptr: some(ptr), response: some(c2) };\n-                let mut p1 = some(p1); // argh\n+                    DeathThroes { ptr: Some(ptr), response: Some(c2) };\n+                let mut p1 = Some(p1); // argh\n                 do task::rekillable {\n                     pipes::recv_one(option::swap_unwrap(&mut p1));\n                 }\n@@ -195,7 +195,7 @@ unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n type SharedMutableState<T: send> = ArcDestruct<T>;\n \n unsafe fn shared_mutable_state<T: send>(+data: T) -> SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, unwrapper: 0, data: some(data) };\n+    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n     unsafe {\n         let ptr = unsafe::transmute(data);\n         ArcDestruct(ptr)\n@@ -433,7 +433,7 @@ mod tests {\n     #[test]\n     fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut some(x.clone());\n+        let x2 = ~mut Some(x.clone());\n         do task::spawn {\n             let x2 = option::swap_unwrap(x2);\n             do x2.with |_hello| { }\n@@ -443,9 +443,9 @@ mod tests {\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut some(x.clone());\n-        let mut res = none;\n-        do task::task().future_result(|+r| res = some(r)).spawn {\n+        let x2 = ~mut Some(x.clone());\n+        let mut res = None;\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n             let x2 = option::swap_unwrap(x2);\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n@@ -458,9 +458,9 @@ mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut some(x.clone());\n-        let mut res = none;\n-        do task::task().future_result(|+r| res = some(r)).spawn {\n+        let x2 = ~mut Some(x.clone());\n+        let mut res = None;\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n             let x2 = option::swap_unwrap(x2);\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }"}, {"sha": "cb35fb8ae76ce7aac2b7f3738b1ba78aa2eec2ac", "filename": "src/libcore/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -74,8 +74,8 @@ mod tests {\n     }\n     #[test]\n     fn test_replace() {\n-        let mut x = some(NonCopyable());\n-        let y = replace(&mut x, none);\n+        let mut x = Some(NonCopyable());\n+        let y = replace(&mut x, None);\n         assert x.is_none();\n         assert y.is_some();\n     }"}, {"sha": "dea93905e4bb60444d172badcaab37dc864ab4a1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1,6 +1,6 @@\n //! Vectors\n \n-import option::{some, none};\n+import option::{Some, None};\n import ptr::addr_of;\n import libc::size_t;\n \n@@ -264,7 +264,7 @@ pure fn build<A>(builder: fn(push: pure fn(+A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: option<uint>,\n+pure fn build_sized_opt<A>(size: Option<uint>,\n                            builder: fn(push: pure fn(+A))) -> ~[A] {\n     build_sized(size.get_default(4), builder)\n }\n@@ -310,12 +310,12 @@ pure fn last<T: copy>(v: &[const T]) -> T {\n }\n \n /**\n- * Returns `some(x)` where `x` is the last element of the slice `v`,\n+ * Returns `Some(x)` where `x` is the last element of the slice `v`,\n  * or `none` if the vector is empty.\n  */\n-pure fn last_opt<T: copy>(v: &[const T]) -> option<T> {\n-    if len(v) == 0u { return none; }\n-    some(v[len(v) - 1u])\n+pure fn last_opt<T: copy>(v: &[const T]) -> Option<T> {\n+    if len(v) == 0u { return None; }\n+    Some(v[len(v) - 1u])\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n@@ -374,8 +374,8 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln {\n         match position_between(v, start, ln, f) {\n-          none => break,\n-          some(i) => {\n+          None => break,\n+          Some(i) => {\n             push(result, slice(v, start, i));\n             start = i + 1u;\n           }\n@@ -398,8 +398,8 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln && count > 0u {\n         match position_between(v, start, ln, f) {\n-          none => break,\n-          some(i) => {\n+          None => break,\n+          Some(i) => {\n             push(result, slice(v, start, i));\n             // Make sure to skip the separator.\n             start = i + 1u;\n@@ -423,8 +423,8 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          none => break,\n-          some(i) => {\n+          None => break,\n+          Some(i) => {\n             push(result, slice(v, i + 1u, end));\n             end = i;\n           }\n@@ -447,8 +447,8 @@ fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          none => break,\n-          some(i) => {\n+          None => break,\n+          Some(i) => {\n             push(result, slice(v, i + 1u, end));\n             // Make sure to skip the separator.\n             end = i;\n@@ -751,13 +751,13 @@ pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n  * If function `f` returns `none` then that element is excluded from\n  * the resulting vector.\n  */\n-pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n+pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         match f(elem) {\n-          none => {/* no-op */ }\n-          some(result_elem) => unsafe { push(result, result_elem); }\n+          None => {/* no-op */ }\n+          Some(result_elem) => unsafe { push(result, result_elem); }\n         }\n     }\n     return result;\n@@ -899,7 +899,7 @@ pure fn count<T>(v: &[T], x: T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n+pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -911,7 +911,7 @@ pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n-                      f: fn(T) -> bool) -> option<T> {\n+                      f: fn(T) -> bool) -> Option<T> {\n     option::map(position_between(v, start, end, f), |i| v[i])\n }\n \n@@ -922,7 +922,7 @@ pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n+pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -934,12 +934,12 @@ pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n-                               f: fn(T) -> bool) -> option<T> {\n+                               f: fn(T) -> bool) -> Option<T> {\n     option::map(rposition_between(v, start, end, f), |i| v[i])\n }\n \n /// Find the first index containing a matching value\n-pure fn position_elem<T>(v: &[T], x: T) -> option<uint> {\n+pure fn position_elem<T>(v: &[T], x: T) -> Option<uint> {\n     position(v, |y| x == y)\n }\n \n@@ -950,7 +950,7 @@ pure fn position_elem<T>(v: &[T], x: T) -> option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pure fn position<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n+pure fn position<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -962,16 +962,16 @@ pure fn position<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: fn(T) -> bool) -> option<uint> {\n+                            f: fn(T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = start;\n-    while i < end { if f(v[i]) { return some::<uint>(i); } i += 1u; }\n-    return none;\n+    while i < end { if f(v[i]) { return Some::<uint>(i); } i += 1u; }\n+    return None;\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T>(v: &[T], x: T) -> option<uint> {\n+pure fn rposition_elem<T>(v: &[T], x: T) -> Option<uint> {\n     rposition(v, |y| x == y)\n }\n \n@@ -982,7 +982,7 @@ pure fn rposition_elem<T>(v: &[T], x: T) -> option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n+pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -995,15 +995,15 @@ pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n  * returned.\n  */\n pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: fn(T) -> bool) -> option<uint> {\n+                             f: fn(T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = end;\n     while i > start {\n-        if f(v[i - 1u]) { return some::<uint>(i - 1u); }\n+        if f(v[i - 1u]) { return Some::<uint>(i - 1u); }\n         i -= 1u;\n     }\n-    return none;\n+    return None;\n }\n \n // FIXME: if issue #586 gets implemented, could have a postcondition\n@@ -1439,18 +1439,18 @@ trait ImmutableVector<T> {\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n     pure fn iter(f: fn(T));\n     pure fn iteri(f: fn(uint, T));\n-    pure fn position(f: fn(T) -> bool) -> option<uint>;\n-    pure fn position_elem(x: T) -> option<uint>;\n+    pure fn position(f: fn(T) -> bool) -> Option<uint>;\n+    pure fn position_elem(x: T) -> Option<uint>;\n     pure fn riter(f: fn(T));\n     pure fn riteri(f: fn(uint, T));\n-    pure fn rposition(f: fn(T) -> bool) -> option<uint>;\n-    pure fn rposition_elem(x: T) -> option<uint>;\n+    pure fn rposition(f: fn(T) -> bool) -> Option<uint>;\n+    pure fn rposition_elem(x: T) -> Option<uint>;\n     pure fn map<U>(f: fn(T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(f: fn(uint, T) -> bool) -> bool;\n     pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> ~[U];\n+    pure fn filter_map<U: copy>(f: fn(T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1482,10 +1482,10 @@ impl<T> &[T]: ImmutableVector<T> {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n+    pure fn position(f: fn(T) -> bool) -> Option<uint> { position(self, f) }\n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n+    pure fn position_elem(x: T) -> Option<uint> { position_elem(self, x) }\n     /**\n      * Iterates over a vector in reverse\n      *\n@@ -1510,10 +1510,10 @@ impl<T> &[T]: ImmutableVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n+    pure fn rposition(f: fn(T) -> bool) -> Option<uint> { rposition(self, f) }\n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n+    pure fn rposition_elem(x: T) -> Option<uint> { rposition_elem(self, x) }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n@@ -1557,14 +1557,14 @@ impl<T> &[T]: ImmutableVector<T> {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> ~[U] {\n+    pure fn filter_map<U: copy>(f: fn(T) -> Option<U>) -> ~[U] {\n         filter_map(self, f)\n     }\n }\n \n trait ImmutableCopyableVector<T> {\n     pure fn filter(f: fn(T) -> bool) -> ~[T];\n-    pure fn rfind(f: fn(T) -> bool) -> option<T>;\n+    pure fn rfind(f: fn(T) -> bool) -> Option<T>;\n }\n \n /// Extension methods for vectors\n@@ -1586,7 +1586,7 @@ impl<T: copy> &[T]: ImmutableCopyableVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n+    pure fn rfind(f: fn(T) -> bool) -> Option<T> { rfind(self, f) }\n }\n \n /// Unsafe operations\n@@ -1682,9 +1682,9 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn set<T>(v: &[mut T], i: uint, +val: T) {\n-        let mut box = some(val);\n+        let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n-            let mut box2 = none;\n+            let mut box2 = None;\n             box2 <-> box;\n             rusti::move_val_init(*ptr::mut_offset(p, i),\n                                  option::unwrap(box2));\n@@ -1806,7 +1806,7 @@ mod u8 {\n \n impl<A> &[A]: iter::BaseIter<A> {\n     pure fn each(blk: fn(A) -> bool) { each(self, blk) }\n-    pure fn size_hint() -> option<uint> { some(len(self)) }\n+    pure fn size_hint() -> Option<uint> { Some(len(self)) }\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n@@ -1818,7 +1818,7 @@ impl<A> &[A]: iter::ExtendedIter<A> {\n     }\n     pure fn contains(x: A) -> bool { iter::contains(self, x) }\n     pure fn count(x: A) -> uint { iter::count(self, x) }\n-    pure fn position(f: fn(A) -> bool) -> option<uint> {\n+    pure fn position(f: fn(A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n }\n@@ -1839,7 +1839,7 @@ impl<A: copy> &[A]: iter::CopyableIter<A> {\n \n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n-    pure fn find(p: fn(A) -> bool) -> option<A> { iter::find(self, p) }\n+    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }\n // ___________________________________________________________________________\n \n@@ -1856,8 +1856,8 @@ mod tests {\n \n     pure fn is_equal(&&x: uint, &&y:uint) -> bool { return x == y; }\n \n-    fn square_if_odd(&&n: uint) -> option<uint> {\n-        return if n % 2u == 1u { some(n * n) } else { none };\n+    fn square_if_odd(&&n: uint) -> Option<uint> {\n+        return if n % 2u == 1u { Some(n * n) } else { None };\n     }\n \n     fn add(&&x: uint, &&y: uint) -> uint { return x + y; }\n@@ -1954,11 +1954,11 @@ mod tests {\n     #[test]\n     fn test_last() {\n         let mut n = last_opt(~[]);\n-        assert (n == none);\n+        assert (n == None);\n         n = last_opt(~[1, 2, 3]);\n-        assert (n == some(3));\n+        assert (n == Some(3));\n         n = last_opt(~[1, 2, 3, 4, 5]);\n-        assert (n == some(5));\n+        assert (n == Some(5));\n     }\n \n     #[test]\n@@ -2140,10 +2140,10 @@ mod tests {\n         assert (w[1] == 9u);\n         assert (w[2] == 25u);\n \n-        fn halve(&&i: int) -> option<int> {\n+        fn halve(&&i: int) -> Option<int> {\n             if i % 2 == 0 {\n-                return option::some::<int>(i / 2);\n-            } else { return option::none::<int>; }\n+                return option::Some::<int>(i / 2);\n+            } else { return option::None::<int>; }\n         }\n         fn halve_for_sure(&&i: int) -> int { return i / 2; }\n         let all_even: ~[int] = ~[0, 2, 8, 6];\n@@ -2318,173 +2318,173 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem(~[], 1) == none;\n+        assert position_elem(~[], 1) == None;\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert position_elem(v1, 1) == some(0u);\n-        assert position_elem(v1, 2) == some(1u);\n-        assert position_elem(v1, 5) == some(5u);\n-        assert position_elem(v1, 4) == none;\n+        assert position_elem(v1, 1) == Some(0u);\n+        assert position_elem(v1, 2) == Some(1u);\n+        assert position_elem(v1, 5) == Some(5u);\n+        assert position_elem(v1, 4) == None;\n     }\n \n     #[test]\n     fn test_position() {\n         fn less_than_three(&&i: int) -> bool { return i < 3; }\n         fn is_eighteen(&&i: int) -> bool { return i == 18; }\n \n-        assert position(~[], less_than_three) == none;\n+        assert position(~[], less_than_three) == None;\n \n         let v1 = ~[5, 4, 3, 2, 1];\n-        assert position(v1, less_than_three) == some(3u);\n-        assert position(v1, is_eighteen) == none;\n+        assert position(v1, less_than_three) == Some(3u);\n+        assert position(v1, is_eighteen) == None;\n     }\n \n     #[test]\n     fn test_position_between() {\n-        assert position_between(~[], 0u, 0u, f) == none;\n+        assert position_between(~[], 0u, 0u, f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position_between(v, 0u, 0u, f) == none;\n-        assert position_between(v, 0u, 1u, f) == none;\n-        assert position_between(v, 0u, 2u, f) == some(1u);\n-        assert position_between(v, 0u, 3u, f) == some(1u);\n-        assert position_between(v, 0u, 4u, f) == some(1u);\n+        assert position_between(v, 0u, 0u, f) == None;\n+        assert position_between(v, 0u, 1u, f) == None;\n+        assert position_between(v, 0u, 2u, f) == Some(1u);\n+        assert position_between(v, 0u, 3u, f) == Some(1u);\n+        assert position_between(v, 0u, 4u, f) == Some(1u);\n \n-        assert position_between(v, 1u, 1u, f) == none;\n-        assert position_between(v, 1u, 2u, f) == some(1u);\n-        assert position_between(v, 1u, 3u, f) == some(1u);\n-        assert position_between(v, 1u, 4u, f) == some(1u);\n+        assert position_between(v, 1u, 1u, f) == None;\n+        assert position_between(v, 1u, 2u, f) == Some(1u);\n+        assert position_between(v, 1u, 3u, f) == Some(1u);\n+        assert position_between(v, 1u, 4u, f) == Some(1u);\n \n-        assert position_between(v, 2u, 2u, f) == none;\n-        assert position_between(v, 2u, 3u, f) == none;\n-        assert position_between(v, 2u, 4u, f) == some(3u);\n+        assert position_between(v, 2u, 2u, f) == None;\n+        assert position_between(v, 2u, 3u, f) == None;\n+        assert position_between(v, 2u, 4u, f) == Some(3u);\n \n-        assert position_between(v, 3u, 3u, f) == none;\n-        assert position_between(v, 3u, 4u, f) == some(3u);\n+        assert position_between(v, 3u, 3u, f) == None;\n+        assert position_between(v, 3u, 4u, f) == Some(3u);\n \n-        assert position_between(v, 4u, 4u, f) == none;\n+        assert position_between(v, 4u, 4u, f) == None;\n     }\n \n     #[test]\n     fn test_find() {\n-        assert find(~[], f) == none;\n+        assert find(~[], f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find(v, f) == some((1, 'b'));\n-        assert find(v, g) == none;\n+        assert find(v, f) == Some((1, 'b'));\n+        assert find(v, g) == None;\n     }\n \n     #[test]\n     fn test_find_between() {\n-        assert find_between(~[], 0u, 0u, f) == none;\n+        assert find_between(~[], 0u, 0u, f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find_between(v, 0u, 0u, f) == none;\n-        assert find_between(v, 0u, 1u, f) == none;\n-        assert find_between(v, 0u, 2u, f) == some((1, 'b'));\n-        assert find_between(v, 0u, 3u, f) == some((1, 'b'));\n-        assert find_between(v, 0u, 4u, f) == some((1, 'b'));\n+        assert find_between(v, 0u, 0u, f) == None;\n+        assert find_between(v, 0u, 1u, f) == None;\n+        assert find_between(v, 0u, 2u, f) == Some((1, 'b'));\n+        assert find_between(v, 0u, 3u, f) == Some((1, 'b'));\n+        assert find_between(v, 0u, 4u, f) == Some((1, 'b'));\n \n-        assert find_between(v, 1u, 1u, f) == none;\n-        assert find_between(v, 1u, 2u, f) == some((1, 'b'));\n-        assert find_between(v, 1u, 3u, f) == some((1, 'b'));\n-        assert find_between(v, 1u, 4u, f) == some((1, 'b'));\n+        assert find_between(v, 1u, 1u, f) == None;\n+        assert find_between(v, 1u, 2u, f) == Some((1, 'b'));\n+        assert find_between(v, 1u, 3u, f) == Some((1, 'b'));\n+        assert find_between(v, 1u, 4u, f) == Some((1, 'b'));\n \n-        assert find_between(v, 2u, 2u, f) == none;\n-        assert find_between(v, 2u, 3u, f) == none;\n-        assert find_between(v, 2u, 4u, f) == some((3, 'b'));\n+        assert find_between(v, 2u, 2u, f) == None;\n+        assert find_between(v, 2u, 3u, f) == None;\n+        assert find_between(v, 2u, 4u, f) == Some((3, 'b'));\n \n-        assert find_between(v, 3u, 3u, f) == none;\n-        assert find_between(v, 3u, 4u, f) == some((3, 'b'));\n+        assert find_between(v, 3u, 3u, f) == None;\n+        assert find_between(v, 3u, 4u, f) == Some((3, 'b'));\n \n-        assert find_between(v, 4u, 4u, f) == none;\n+        assert find_between(v, 4u, 4u, f) == None;\n     }\n \n     #[test]\n     fn test_rposition() {\n-        assert find(~[], f) == none;\n+        assert find(~[], f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position(v, f) == some(1u);\n-        assert position(v, g) == none;\n+        assert position(v, f) == Some(1u);\n+        assert position(v, g) == None;\n     }\n \n     #[test]\n     fn test_rposition_between() {\n-        assert rposition_between(~[], 0u, 0u, f) == none;\n+        assert rposition_between(~[], 0u, 0u, f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rposition_between(v, 0u, 0u, f) == none;\n-        assert rposition_between(v, 0u, 1u, f) == none;\n-        assert rposition_between(v, 0u, 2u, f) == some(1u);\n-        assert rposition_between(v, 0u, 3u, f) == some(1u);\n-        assert rposition_between(v, 0u, 4u, f) == some(3u);\n+        assert rposition_between(v, 0u, 0u, f) == None;\n+        assert rposition_between(v, 0u, 1u, f) == None;\n+        assert rposition_between(v, 0u, 2u, f) == Some(1u);\n+        assert rposition_between(v, 0u, 3u, f) == Some(1u);\n+        assert rposition_between(v, 0u, 4u, f) == Some(3u);\n \n-        assert rposition_between(v, 1u, 1u, f) == none;\n-        assert rposition_between(v, 1u, 2u, f) == some(1u);\n-        assert rposition_between(v, 1u, 3u, f) == some(1u);\n-        assert rposition_between(v, 1u, 4u, f) == some(3u);\n+        assert rposition_between(v, 1u, 1u, f) == None;\n+        assert rposition_between(v, 1u, 2u, f) == Some(1u);\n+        assert rposition_between(v, 1u, 3u, f) == Some(1u);\n+        assert rposition_between(v, 1u, 4u, f) == Some(3u);\n \n-        assert rposition_between(v, 2u, 2u, f) == none;\n-        assert rposition_between(v, 2u, 3u, f) == none;\n-        assert rposition_between(v, 2u, 4u, f) == some(3u);\n+        assert rposition_between(v, 2u, 2u, f) == None;\n+        assert rposition_between(v, 2u, 3u, f) == None;\n+        assert rposition_between(v, 2u, 4u, f) == Some(3u);\n \n-        assert rposition_between(v, 3u, 3u, f) == none;\n-        assert rposition_between(v, 3u, 4u, f) == some(3u);\n+        assert rposition_between(v, 3u, 3u, f) == None;\n+        assert rposition_between(v, 3u, 4u, f) == Some(3u);\n \n-        assert rposition_between(v, 4u, 4u, f) == none;\n+        assert rposition_between(v, 4u, 4u, f) == None;\n     }\n \n     #[test]\n     fn test_rfind() {\n-        assert rfind(~[], f) == none;\n+        assert rfind(~[], f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind(v, f) == some((3, 'b'));\n-        assert rfind(v, g) == none;\n+        assert rfind(v, f) == Some((3, 'b'));\n+        assert rfind(v, g) == None;\n     }\n \n     #[test]\n     fn test_rfind_between() {\n-        assert rfind_between(~[], 0u, 0u, f) == none;\n+        assert rfind_between(~[], 0u, 0u, f) == None;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind_between(v, 0u, 0u, f) == none;\n-        assert rfind_between(v, 0u, 1u, f) == none;\n-        assert rfind_between(v, 0u, 2u, f) == some((1, 'b'));\n-        assert rfind_between(v, 0u, 3u, f) == some((1, 'b'));\n-        assert rfind_between(v, 0u, 4u, f) == some((3, 'b'));\n+        assert rfind_between(v, 0u, 0u, f) == None;\n+        assert rfind_between(v, 0u, 1u, f) == None;\n+        assert rfind_between(v, 0u, 2u, f) == Some((1, 'b'));\n+        assert rfind_between(v, 0u, 3u, f) == Some((1, 'b'));\n+        assert rfind_between(v, 0u, 4u, f) == Some((3, 'b'));\n \n-        assert rfind_between(v, 1u, 1u, f) == none;\n-        assert rfind_between(v, 1u, 2u, f) == some((1, 'b'));\n-        assert rfind_between(v, 1u, 3u, f) == some((1, 'b'));\n-        assert rfind_between(v, 1u, 4u, f) == some((3, 'b'));\n+        assert rfind_between(v, 1u, 1u, f) == None;\n+        assert rfind_between(v, 1u, 2u, f) == Some((1, 'b'));\n+        assert rfind_between(v, 1u, 3u, f) == Some((1, 'b'));\n+        assert rfind_between(v, 1u, 4u, f) == Some((3, 'b'));\n \n-        assert rfind_between(v, 2u, 2u, f) == none;\n-        assert rfind_between(v, 2u, 3u, f) == none;\n-        assert rfind_between(v, 2u, 4u, f) == some((3, 'b'));\n+        assert rfind_between(v, 2u, 2u, f) == None;\n+        assert rfind_between(v, 2u, 3u, f) == None;\n+        assert rfind_between(v, 2u, 4u, f) == Some((3, 'b'));\n \n-        assert rfind_between(v, 3u, 3u, f) == none;\n-        assert rfind_between(v, 3u, 4u, f) == some((3, 'b'));\n+        assert rfind_between(v, 3u, 3u, f) == None;\n+        assert rfind_between(v, 3u, 4u, f) == Some((3, 'b'));\n \n-        assert rfind_between(v, 4u, 4u, f) == none;\n+        assert rfind_between(v, 4u, 4u, f) == None;\n     }\n \n     #[test]"}, {"sha": "8dfaa647573e2235387e644492ff596469b7e237", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -470,7 +470,7 @@ mod tests {\n         let arc = ~mutex_arc(false);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::oneshot();\n-        let (c,p) = (~mut some(c), ~mut some(p));\n+        let (c,p) = (~mut Some(c), ~mut Some(p));\n         do task::spawn {\n             // wait until parent gets in\n             pipes::recv_one(option::swap_unwrap(p));"}, {"sha": "0ba57866da0339096fd7c52932ae148431e9328b", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -43,12 +43,12 @@ enum c_vec<T> {\n }\n \n struct dtor_res {\n-  let dtor: option<fn@()>;\n-  new(dtor: option<fn@()>) { self.dtor = dtor; }\n+  let dtor: Option<fn@()>;\n+  new(dtor: Option<fn@()>) { self.dtor = dtor; }\n   drop {\n     match self.dtor {\n-      option::none => (),\n-      option::some(f) => f()\n+      option::None => (),\n+      option::Some(f) => f()\n     }\n   }\n }\n@@ -69,7 +69,7 @@ unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n     return c_vec_({\n         base: base,\n         len: len,\n-        rsrc: @dtor_res(option::none)\n+        rsrc: @dtor_res(option::None)\n     });\n }\n \n@@ -89,7 +89,7 @@ unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n     return c_vec_({\n         base: base,\n         len: len,\n-        rsrc: @dtor_res(option::some(dtor))\n+        rsrc: @dtor_res(option::Some(dtor))\n     });\n }\n "}, {"sha": "5310f10cd7a4610ab0a746833eb3189031216e15", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,16 +3,16 @@\n /// Similar to a mutable option type, but friendlier.\n \n struct Cell<T> {\n-    mut value: option<T>;\n+    mut value: Option<T>;\n }\n \n /// Creates a new full cell with the given value.\n fn Cell<T>(+value: T) -> Cell<T> {\n-    Cell { value: some(move value) }\n+    Cell { value: Some(move value) }\n }\n \n fn empty_cell<T>() -> Cell<T> {\n-    Cell { value: none }\n+    Cell { value: None }\n }\n \n impl<T> Cell<T> {\n@@ -22,7 +22,7 @@ impl<T> Cell<T> {\n             fail ~\"attempt to take an empty cell\";\n         }\n \n-        let mut value = none;\n+        let mut value = None;\n         value <-> self.value;\n         return option::unwrap(value);\n     }\n@@ -32,7 +32,7 @@ impl<T> Cell<T> {\n         if !self.is_empty() {\n             fail ~\"attempt to put a value back into a full cell\";\n         }\n-        self.value = some(move value);\n+        self.value = Some(move value);\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full."}, {"sha": "639b21e208a57af232b7b8ba5e327f4eef12312d", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -32,7 +32,7 @@ struct DuplexStream<T: send, U: send> : channel<T>, recv<U>, selectable {\n         self.port.recv()\n     }\n \n-    fn try_recv() -> option<U> {\n+    fn try_recv() -> Option<U> {\n         self.port.try_recv()\n     }\n "}, {"sha": "215f1667922a528e1cc123878a46abbffc410312", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1,6 +1,6 @@\n //! A deque. Untested as of yet. Likely buggy\n \n-import option::{some, none};\n+import option::{Some, None};\n import dvec::{DVec, dvec};\n \n trait t<T> {\n@@ -17,7 +17,7 @@ trait t<T> {\n // FIXME (#2343) eventually, a proper datatype plus an exported impl would\n // be preferrable.\n fn create<T: copy>() -> t<T> {\n-    type cell<T> = option<T>;\n+    type cell<T> = Option<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n@@ -34,14 +34,14 @@ fn create<T: copy>() -> t<T> {\n         while i < nalloc {\n             if i < nelts {\n                 vec::push(rv, elts[(lo + i) % nelts]);\n-            } else { vec::push(rv, none); }\n+            } else { vec::push(rv, None); }\n             i += 1u;\n         }\n \n         return rv;\n     }\n     fn get<T: copy>(elts: DVec<cell<T>>, i: uint) -> T {\n-        match elts.get_elt(i) { some(t) => t, _ => fail }\n+        match elts.get_elt(i) { Some(t) => t, _ => fail }\n     }\n \n     type repr<T> = {mut nelts: uint,\n@@ -61,7 +61,7 @@ fn create<T: copy>() -> t<T> {\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n-            self.elts.set_elt(self.lo, some(t));\n+            self.elts.set_elt(self.lo, Some(t));\n             self.nelts += 1u;\n         }\n         fn add_back(t: T) {\n@@ -70,7 +70,7 @@ fn create<T: copy>() -> t<T> {\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }\n-            self.elts.set_elt(self.hi, some(t));\n+            self.elts.set_elt(self.hi, Some(t));\n             self.hi = (self.hi + 1u) % self.elts.len();\n             self.nelts += 1u;\n         }\n@@ -80,7 +80,7 @@ fn create<T: copy>() -> t<T> {\n          */\n         fn pop_front() -> T {\n             let t: T = get(self.elts, self.lo);\n-            self.elts.set_elt(self.lo, none);\n+            self.elts.set_elt(self.lo, None);\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n             return t;\n@@ -90,7 +90,7 @@ fn create<T: copy>() -> t<T> {\n                 self.hi = self.elts.len() - 1u;\n             } else { self.hi -= 1u; }\n             let t: T = get(self.elts, self.hi);\n-            self.elts.set_elt(self.hi, none);\n+            self.elts.set_elt(self.hi, None);\n             self.nelts -= 1u;\n             return t;\n         }\n@@ -109,7 +109,7 @@ fn create<T: copy>() -> t<T> {\n         elts:\n             dvec::from_vec(\n                 vec::to_mut(\n-                    vec::from_elem(initial_capacity, none)))\n+                    vec::from_elem(initial_capacity, None)))\n     };\n     repr as t::<T>\n }"}, {"sha": "934c3ae9b6b6a0f565f2fb9f7fb0ba05d1b830f1", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,8 +3,8 @@\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n-import core::option;\n-import option::{some, none};\n+import core::Option;\n+import option::{Some, None};\n \n export doc;\n export doc_at;\n@@ -85,27 +85,27 @@ fn doc_at(data: @~[u8], start: uint) -> tagged_doc {\n          doc: {data: data, start: elt_size.next, end: end}};\n }\n \n-fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n+fn maybe_get_doc(d: doc, tg: uint) -> Option<doc> {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            return some::<doc>({\n+            return Some::<doc>({\n                 data: d.data,\n                 start: elt_size.next,\n                 end: pos\n             });\n         }\n     }\n-    return none::<doc>;\n+    return None::<doc>;\n }\n \n fn get_doc(d: doc, tg: uint) -> doc {\n     match maybe_get_doc(d, tg) {\n-      some(d) => return d,\n-      none => {\n+      Some(d) => return d,\n+      None => {\n         error!(\"failed to find block with tag %u\", tg);\n         fail;\n       }\n@@ -575,12 +575,12 @@ fn test_option_int() {\n         s.emit_i64(v as i64);\n     }\n \n-    fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n+    fn serialize_0<S: serialization::serializer>(s: S, v: Option<int>) {\n         do s.emit_enum(~\"core::option::t\") {\n             match v {\n-              none => s.emit_enum_variant(\n-                  ~\"core::option::none\", 0u, 0u, || { } ),\n-              some(v0) => {\n+              None => s.emit_enum_variant(\n+                  ~\"core::option::None\", 0u, 0u, || { } ),\n+              Some(v0) => {\n                 do s.emit_enum_variant(~\"core::option::some\", 1u, 1u) {\n                     s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n                 }\n@@ -593,16 +593,16 @@ fn test_option_int() {\n         s.read_i64() as int\n     }\n \n-    fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n+    fn deserialize_0<S: serialization::deserializer>(s: S) -> Option<int> {\n         do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n                 match i {\n-                  0 => none,\n+                  0 => None,\n                   1 => {\n                     let v0 = do s.read_enum_variant_arg(0u) {\n                         deserialize_1(s)\n                     };\n-                    some(v0)\n+                    Some(v0)\n                   }\n                   _ => {\n                     fail #fmt(\"deserialize_0: unexpected variant %u\", i);\n@@ -612,7 +612,7 @@ fn test_option_int() {\n         }\n     }\n \n-    fn test_v(v: option<int>) {\n+    fn test_v(v: Option<int>) {\n         debug!(\"v == %?\", v);\n         let mbuf = io::mem_buffer();\n         let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n@@ -624,7 +624,7 @@ fn test_option_int() {\n         assert v == v1;\n     }\n \n-    test_v(some(22));\n-    test_v(none);\n-    test_v(some(3));\n+    test_v(Some(22));\n+    test_v(None);\n+    test_v(Some(3));\n }"}, {"sha": "d9bfd6a04b16c85c55961e2e23041a28e9df322d", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -9,7 +9,7 @@\n  * of features.\n  */\n \n-import option::{some, none};\n+import option::{Some, None};\n import option = option;\n \n export treemap;\n@@ -43,12 +43,12 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n }\n \n /// Find a value based on the key\n-fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n+fn find<K, V: copy>(m: treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n-      empty => none,\n+      empty => None,\n       node(@kk, @v, left, right) => {\n         if k == kk {\n-            some(v)\n+            Some(v)\n         } else if k < kk { find(left, k) } else { find(right, k) }\n       }\n     }"}, {"sha": "cac17b319e13676ed0bc3a1fad545191ad5d882b", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -23,7 +23,7 @@\n  *     import std::getopts::{optopt,optflag,getopts,opt_present,opt_maybe_str,\n  *         fail_str};\n  *\n- *     fn do_work(in: str, out: option<str>) {\n+ *     fn do_work(in: str, out: Option<str>) {\n  *         // ...\n  *     }\n  *\n@@ -64,7 +64,7 @@\n \n import core::result::{err, ok};\n import core::option;\n-import core::option::{some, none};\n+import core::option::{Some, None};\n export opt;\n export reqopt;\n export optopt;\n@@ -146,7 +146,7 @@ fn name_str(nm: name) -> ~str {\n     };\n }\n \n-fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n+fn find_opt(opts: ~[opt], nm: name) -> Option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n@@ -206,7 +206,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n             break;\n         } else {\n             let mut names;\n-            let mut i_arg = option::none::<~str>;\n+            let mut i_arg = option::None::<~str>;\n             if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let tail_eq = str::splitn_char(tail, '=', 1u);\n@@ -216,11 +216,11 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                     names =\n                         ~[long(tail_eq[0])];\n                     i_arg =\n-                        option::some::<~str>(tail_eq[1]);\n+                        option::Some::<~str>(tail_eq[1]);\n                 }\n             } else {\n                 let mut j = 1u;\n-                let mut last_valid_opt_id = option::none;\n+                let mut last_valid_opt_id = option::None;\n                 names = ~[];\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n@@ -234,8 +234,8 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                     */\n \n                     match find_opt(opts, opt) {\n-                      some(id) => last_valid_opt_id = option::some(id),\n-                      none => {\n+                      Some(id) => last_valid_opt_id = option::Some(id),\n+                      None => {\n                         let arg_follows =\n                             option::is_some(last_valid_opt_id) &&\n                             match opts[option::get(last_valid_opt_id)]\n@@ -245,10 +245,10 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                               no => false\n                             };\n                         if arg_follows && j + 1 < curlen {\n-                            i_arg = option::some(str::slice(cur, j, curlen));\n+                            i_arg = option::Some(str::slice(cur, j, curlen));\n                             break;\n                         } else {\n-                            last_valid_opt_id = option::none;\n+                            last_valid_opt_id = option::None;\n                         }\n                       }\n                     }\n@@ -260,8 +260,8 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n             for vec::each(names) |nm| {\n                 name_pos += 1u;\n                 let optid = match find_opt(opts, nm) {\n-                  some(id) => id,\n-                  none => return err(unrecognized_option(name_str(nm)))\n+                  Some(id) => id,\n+                  None => return err(unrecognized_option(name_str(nm)))\n                 };\n                 match opts[optid].hasarg {\n                   no => {\n@@ -312,8 +312,8 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n \n fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n     return match find_opt(m.opts, mkname(nm)) {\n-      some(id) => m.vals[id],\n-      none => {\n+      Some(id) => m.vals[id],\n+      None => {\n         error!(\"No option '%s' defined\", nm);\n         fail\n       }\n@@ -331,7 +331,7 @@ fn opt_present(m: matches, nm: ~str) -> bool {\n fn opts_present(m: matches, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n         match find_opt(m.opts, mkname(nm)) {\n-          some(_) => return true,\n+          Some(_) => return true,\n           _ => ()\n         }\n     }\n@@ -381,10 +381,10 @@ fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n+fn opt_maybe_str(m: matches, nm: ~str) -> Option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return match vals[0] { val(s) => some::<~str>(s), _ => none::<~str> };\n+    if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n+    return match vals[0] { val(s) => Some::<~str>(s), _ => None::<~str> };\n }\n \n \n@@ -395,10 +395,10 @@ fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(m: matches, nm: ~str, def: ~str) -> option<~str> {\n+fn opt_default(m: matches, nm: ~str, def: ~str) -> Option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return match vals[0] { val(s) => some::<~str>(s), _ => some::<~str>(def) }\n+    if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n+    return match vals[0] { val(s) => Some::<~str>(s), _ => Some::<~str>(def) }\n }\n \n #[cfg(test)]"}, {"sha": "d0571059e86ae6bae09c8cd9c186fbedf3d6f8a1", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -486,8 +486,8 @@ fn eq(value0: json, value1: json) -> bool {\n               let mut equal = true;\n               for d0.each |k, v0| {\n                   match d1.find(k) {\n-                    some(v1) => if !eq(v0, v1) { equal = false },\n-                    none => equal = false\n+                    Some(v1) => if !eq(v0, v1) { equal = false },\n+                    None => equal = false\n                   }\n               };\n               equal\n@@ -613,11 +613,11 @@ impl <A: to_json copy> hashmap<~str, A>: to_json {\n     }\n }\n \n-impl <A: to_json> option<A>: to_json {\n+impl <A: to_json> Option<A>: to_json {\n     fn to_json() -> json {\n         match self {\n-          none => null,\n-          some(value) => value.to_json()\n+          None => null,\n+          Some(value) => value.to_json()\n         }\n     }\n }"}, {"sha": "7af94cc9c0b15f9dad0a631d7f7deca15bf17c8c", "filename": "src/libstd/list.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -2,7 +2,7 @@\n \n import core::option;\n import option::*;\n-import option::{some, none};\n+import option::{Some, None};\n \n enum list<T> {\n     cons(T, @list<T>),\n@@ -40,15 +40,15 @@ fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n+fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n           cons(hd, tl) => {\n-            if f(hd) { return some(hd); }\n+            if f(hd) { return Some(hd); }\n             tl\n           }\n-          nil => return none\n+          nil => return None\n         }\n     };\n }\n@@ -201,16 +201,16 @@ mod tests {\n     fn test_find_success() {\n         fn match_(&&i: int) -> bool { return i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        assert (list::find(l, match_) == option::some(2));\n+        assert (list::find(l, match_) == option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match_(&&_i: int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::nil::<int>;\n-        assert (list::find(l, match_) == option::none::<int>);\n-        assert (list::find(empty, match_) == option::none::<int>);\n+        assert (list::find(l, match_) == option::None::<int>);\n+        assert (list::find(empty, match_) == option::None::<int>);\n     }\n \n     #[test]"}, {"sha": "3f19720eb8e231cae9e636aaf3c0d535bea38d5f", "filename": "src/libstd/map.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -59,7 +59,7 @@ trait map<K: copy, V: copy> {\n      * Get the value for the specified key. If the key does not exist in\n      * the map then returns none.\n      */\n-    fn find(+key: K) -> option<V>;\n+    fn find(+key: K) -> Option<V>;\n \n     /**\n      * Remove and return a value from the map. Returns true if the\n@@ -111,12 +111,12 @@ mod chained {\n         hash: uint;\n         key: K;\n         value: V;\n-        mut next: option<@entry<K, V>>;\n+        mut next: Option<@entry<K, V>>;\n     }\n \n     struct hashmap_<K, V> {\n         mut count: uint;\n-        mut chains: ~[mut option<@entry<K,V>>];\n+        mut chains: ~[mut Option<@entry<K,V>>];\n         hasher: hashfn<K>;\n         eqer: eqfn<K>;\n     }\n@@ -136,12 +136,12 @@ mod chained {\n             let mut comp = 1u;   // for logging\n             loop {\n                 match copy e0.next {\n-                  none => {\n+                  None => {\n                     debug!(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx);\n                     return not_found;\n                   }\n-                  some(e1) => {\n+                  Some(e1) => {\n                     comp += 1u;\n                     if e1.hash == h && self.eqer(&e1.key, k) {\n                         debug!(\"search_tbl: present, comp %u, \\\n@@ -159,12 +159,12 @@ mod chained {\n         fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n             match copy self.chains[idx] {\n-              none => {\n+              None => {\n                 debug!(\"search_tbl: none, comp %u, hash %u, idx %u\",\n                        0u, h, idx);\n                 return not_found;\n               }\n-              some(e) => {\n+              Some(e) => {\n                 if e.hash == h && self.eqer(&e.key, k) {\n                     debug!(\"search_tbl: present, comp %u, hash %u, idx %u\",\n                            1u, h, idx);\n@@ -183,7 +183,7 @@ mod chained {\n             for self.each_entry |entry| {\n                 let idx = entry.hash % n_new_chains;\n                 entry.next = new_chains[idx];\n-                new_chains[idx] = some(entry);\n+                new_chains[idx] = Some(entry);\n             }\n             self.chains = new_chains;\n         }\n@@ -196,8 +196,8 @@ mod chained {\n                 let mut chain = self.chains[i];\n                 loop {\n                     chain = match chain {\n-                      none => break,\n-                      some(entry) => {\n+                      None => break,\n+                      Some(entry) => {\n                         let next = entry.next;\n                         if !blk(entry) { return; }\n                         next\n@@ -231,7 +231,7 @@ mod chained {\n                 self.count += 1u;\n                 let idx = hash % vec::len(self.chains);\n                 let old_chain = self.chains[idx];\n-                self.chains[idx] = some(@entry {\n+                self.chains[idx] = Some(@entry {\n                     hash: hash,\n                     key: k,\n                     value: v,\n@@ -248,15 +248,15 @@ mod chained {\n                 return true;\n               }\n               found_first(idx, entry) => {\n-                self.chains[idx] = some(@entry {\n+                self.chains[idx] = Some(@entry {\n                     hash: hash,\n                     key: k,\n                     value: v,\n                     next: entry.next});\n                 return false;\n               }\n               found_after(prev, entry) => {\n-                prev.next = some(@entry {\n+                prev.next = Some(@entry {\n                     hash: hash,\n                     key: k,\n                     value: v,\n@@ -266,11 +266,11 @@ mod chained {\n             }\n         }\n \n-        fn find(+k: K) -> option<V> {\n+        fn find(+k: K) -> Option<V> {\n             match self.search_tbl(&k, self.hasher(&k)) {\n-              not_found => none,\n-              found_first(_, entry) => some(entry.value),\n-              found_after(_, entry) => some(entry.value)\n+              not_found => None,\n+              found_first(_, entry) => Some(entry.value),\n+              found_after(_, entry) => Some(entry.value)\n             }\n         }\n \n@@ -364,8 +364,8 @@ mod chained {\n         }\n     }\n \n-    fn chains<K,V>(nchains: uint) -> ~[mut option<@entry<K,V>>] {\n-        vec::to_mut(vec::from_elem(nchains, none))\n+    fn chains<K,V>(nchains: uint) -> ~[mut Option<@entry<K,V>>] {\n+        vec::to_mut(vec::from_elem(nchains, None))\n     }\n \n     fn mk<K, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>) -> t<K,V> {\n@@ -503,7 +503,7 @@ impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n         }\n     }\n \n-    fn find(+key: K) -> option<V> {\n+    fn find(+key: K) -> Option<V> {\n         do self.borrow_const |p| {\n             p.find(&key)\n         }"}, {"sha": "165982749869f86527764c6e4bdc5622b5a644c1", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -156,7 +156,7 @@ mod v4 {\n     fn parse_to_ipv4_rep(ip: ~str) -> result::result<ipv4_rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             match uint::from_str(s) {\n-              some(n) if n <= 255u => n,\n+              Some(n) if n <= 255u => n,\n               _ => 256u\n             }\n         });"}, {"sha": "d2d447f8b147ef9a9ed115e0cdaf87cc3429c374", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -488,7 +488,7 @@ fn accept(new_conn: tcp_new_connection)\n         let client_stream_handle_ptr =\n             (*client_socket_data_ptr).stream_handle_ptr;\n \n-        let result_po = core::comm::port::<option<tcp_err_data>>();\n+        let result_po = core::comm::port::<Option<tcp_err_data>>();\n         let result_ch = core::comm::chan(result_po);\n \n         // UNSAFE LIBUV INTERACTION BEGIN\n@@ -511,25 +511,25 @@ fn accept(new_conn: tcp_new_connection)\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n                                                client_socket_data_ptr\n                                                    as *libc::c_void);\n-                core::comm::send(result_ch, none);\n+                core::comm::send(result_ch, None);\n               }\n               _ => {\n                 log(debug, ~\"failed to accept client conn\");\n-                core::comm::send(result_ch, some(\n+                core::comm::send(result_ch, Some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n           }\n           _ => {\n             log(debug, ~\"failed to init client stream\");\n-            core::comm::send(result_ch, some(\n+            core::comm::send(result_ch, Some(\n                 uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n           }\n         }\n         // UNSAFE LIBUV INTERACTION END\n         match core::comm::recv(result_po) {\n-          some(err_data) => result::err(err_data),\n-          none => result::ok(tcp_socket(client_socket_data))\n+          Some(err_data) => result::err(err_data),\n+          None => result::ok(tcp_socket(client_socket_data))\n         }\n       }\n     }\n@@ -565,9 +565,9 @@ fn accept(new_conn: tcp_new_connection)\n  */\n fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n-          on_establish_cb: fn~(comm::Chan<option<tcp_err_data>>),\n+          on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n-                               comm::Chan<option<tcp_err_data>>))\n+                               comm::Chan<Option<tcp_err_data>>))\n     -> result::result<(), tcp_listen_err_data> unsafe {\n     do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n@@ -582,11 +582,11 @@ fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n-          on_establish_cb: fn~(comm::Chan<option<tcp_err_data>>),\n+          on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::result<(), tcp_listen_err_data> unsafe {\n     let stream_closed_po = core::comm::port::<()>();\n-    let kill_po = core::comm::port::<option<tcp_err_data>>();\n+    let kill_po = core::comm::port::<Option<tcp_err_data>>();\n     let kill_ch = core::comm::chan(kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(server_stream);\n@@ -634,32 +634,32 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                     match uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n-                      0i32 => core::comm::send(setup_ch, none),\n+                      0i32 => core::comm::send(setup_ch, None),\n                       _ => {\n                         log(debug, ~\"failure to uv_listen()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        core::comm::send(setup_ch, some(err_data));\n+                        core::comm::send(setup_ch, Some(err_data));\n                       }\n                     }\n                   }\n                   _ => {\n                     log(debug, ~\"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    core::comm::send(setup_ch, some(err_data));\n+                    core::comm::send(setup_ch, Some(err_data));\n                   }\n                 }\n               }\n               _ => {\n                 log(debug, ~\"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                core::comm::send(setup_ch, some(err_data));\n+                core::comm::send(setup_ch, Some(err_data));\n               }\n             }\n         };\n         setup_ch.recv()\n     };\n     match setup_result {\n-      some(err_data) => {\n+      Some(err_data) => {\n         do iotask::interact(iotask) |loop_ptr| unsafe {\n             log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr));\n@@ -684,7 +684,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           }\n         }\n       }\n-      none => {\n+      None => {\n         on_establish_cb(kill_ch);\n         let kill_result = core::comm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| unsafe {\n@@ -696,10 +696,10 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         stream_closed_po.recv();\n         match kill_result {\n           // some failure post bind/listen\n-          some(err_data) => result::err(generic_listen_err(err_data.err_name,\n+          Some(err_data) => result::err(generic_listen_err(err_data.err_name,\n                                                            err_data.err_msg)),\n           // clean exit\n-          none => result::ok(())\n+          None => result::ok(())\n         }\n       }\n     }\n@@ -874,11 +874,11 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n             timer::recv_timeout(\n                iotask, timeout_msecs, result::get(rs_result))\n         } else {\n-            some(core::comm::recv(result::get(rs_result)))\n+            Some(core::comm::recv(result::get(rs_result)))\n         };\n         log(debug, ~\"tcp::read after recv_timeout\");\n         match read_result {\n-          none => {\n+          None => {\n             log(debug, ~\"tcp::read: timed out..\");\n             let err_data = {\n                 err_name: ~\"TIMEOUT\",\n@@ -887,7 +887,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n             read_stop_common_impl(socket_data);\n             result::err(err_data)\n           }\n-          some(data_result) => {\n+          Some(data_result) => {\n             log(debug, ~\"tcp::read got data\");\n             read_stop_common_impl(socket_data);\n             data_result\n@@ -900,25 +900,25 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     result::result<(), tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = core::comm::port::<option<tcp_err_data>>();\n+    let stop_po = core::comm::port::<Option<tcp_err_data>>();\n     let stop_ch = core::comm::chan(stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 => {\n             log(debug, ~\"successfully called uv_read_stop\");\n-            core::comm::send(stop_ch, none);\n+            core::comm::send(stop_ch, None);\n           }\n           _ => {\n             log(debug, ~\"failure in calling uv_read_stop\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send(stop_ch, some(err_data.to_tcp_err()));\n+            core::comm::send(stop_ch, Some(err_data.to_tcp_err()));\n           }\n         }\n     };\n     match core::comm::recv(stop_po) {\n-      some(err_data) => result::err(err_data.to_tcp_err()),\n-      none => result::ok(())\n+      Some(err_data) => result::err(err_data.to_tcp_err()),\n+      None => result::ok(())\n     }\n }\n \n@@ -927,7 +927,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     -> result::result<comm::Port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let start_po = core::comm::port::<option<uv::ll::uv_err_data>>();\n+    let start_po = core::comm::port::<Option<uv::ll::uv_err_data>>();\n     let start_ch = core::comm::chan(start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n@@ -937,18 +937,18 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n                                on_tcp_read_cb) {\n           0i32 => {\n             log(debug, ~\"success doing uv_read_start\");\n-            core::comm::send(start_ch, none);\n+            core::comm::send(start_ch, None);\n           }\n           _ => {\n             log(debug, ~\"error attempting uv_read_start\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send(start_ch, some(err_data));\n+            core::comm::send(start_ch, Some(err_data));\n           }\n         }\n     };\n     match core::comm::recv(start_po) {\n-      some(err_data) => result::err(err_data.to_tcp_err()),\n-      none => result::ok((*socket_data).reader_po)\n+      Some(err_data) => result::err(err_data.to_tcp_err()),\n+      None => result::ok((*socket_data).reader_po)\n     }\n }\n \n@@ -1005,7 +1005,7 @@ enum tcp_new_connection {\n type tcp_listen_fc_data = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: comm::Chan<()>,\n-    kill_ch: comm::Chan<option<tcp_err_data>>,\n+    kill_ch: comm::Chan<Option<tcp_err_data>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: iotask,\n     mut active: bool\n@@ -1028,7 +1028,7 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n           _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n             core::comm::send(kill_ch,\n-                       some(uv::ll::get_last_err_data(loop_ptr)\n+                       Some(uv::ll::get_last_err_data(loop_ptr)\n                             .to_tcp_err()));\n             (*server_data_ptr).active = false;\n           }\n@@ -1505,7 +1505,7 @@ mod test {\n                     if result::is_err(accept_result) {\n                         log(debug, ~\"SERVER: error accept connection\");\n                         let err_data = result::get_err(accept_result);\n-                        core::comm::send(kill_ch, some(err_data));\n+                        core::comm::send(kill_ch, Some(err_data));\n                         log(debug,\n                             ~\"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n@@ -1528,12 +1528,12 @@ mod test {\n                             log(debug, ~\"SERVER: before write\");\n                             tcp_write_single(sock, str::to_bytes(resp));\n                             log(debug, ~\"SERVER: after write.. die\");\n-                            core::comm::send(kill_ch, none);\n+                            core::comm::send(kill_ch, None);\n                           }\n                           result::err(err_data) => {\n                             log(debug, fmt!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg));\n-                            core::comm::send(kill_ch, some(err_data));\n+                            core::comm::send(kill_ch, Some(err_data));\n                             server_ch.send(~\"\");\n                           }\n                         }"}, {"sha": "470a00fb6bca3d908fcd42ae8c1897ce56254ab0", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -15,29 +15,29 @@ export encode_form_urlencoded, decode_form_urlencoded;\n \n type url = {\n     scheme: ~str,\n-    user: option<userinfo>,\n+    user: Option<userinfo>,\n     host: ~str,\n-    port: option<~str>,\n+    port: Option<~str>,\n     path: ~str,\n     query: query,\n-    fragment: option<~str>\n+    fragment: Option<~str>\n };\n \n type userinfo = {\n     user: ~str,\n-    pass: option<~str>\n+    pass: Option<~str>\n };\n \n type query = ~[(~str, ~str)];\n \n-fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str,\n-       -port: option<~str>, -path: ~str, -query: query,\n-       -fragment: option<~str>) -> url {\n+fn url(-scheme: ~str, -user: Option<userinfo>, -host: ~str,\n+       -port: Option<~str>, -path: ~str, -query: query,\n+       -fragment: Option<~str>) -> url {\n     { scheme: scheme, user: user, host: host, port: port,\n      path: path, query: query, fragment: fragment }\n }\n \n-fn userinfo(-user: ~str, -pass: option<~str>) -> userinfo {\n+fn userinfo(-user: ~str, -pass: Option<~str>) -> userinfo {\n     {user: user, pass: pass}\n }\n \n@@ -215,8 +215,8 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n               '&' | ';' => {\n                 if key != ~\"\" && value != ~\"\" {\n                     let values = match m.find(key) {\n-                      some(values) => values,\n-                      none => {\n+                      Some(values) => values,\n+                      None => {\n                         let values = @dvec();\n                         m.insert(key, values);\n                         values\n@@ -250,8 +250,8 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n \n         if key != ~\"\" && value != ~\"\" {\n             let values = match m.find(key) {\n-              some(values) => values,\n-              none => {\n+              Some(values) => values,\n+              None => {\n                 let values = @dvec();\n                 m.insert(key, values);\n                 values\n@@ -292,9 +292,9 @@ fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n fn userinfo_from_str(uinfo: ~str) -> userinfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n-        option::none\n+        option::None\n     } else {\n-        option::some(p)\n+        option::Some(p)\n     };\n     return userinfo(user, pass);\n }\n@@ -358,10 +358,10 @@ fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: ~str) ->\n-    result::result<(option<userinfo>, ~str, option<~str>, ~str), @~str> {\n+    result::result<(Option<userinfo>, ~str, Option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n-        return result::ok((option::none, ~\"\", option::none, copy rawurl));\n+        return result::ok((option::None, ~\"\", option::None, copy rawurl));\n     }\n \n     enum state {\n@@ -381,9 +381,9 @@ fn get_authority(rawurl: ~str) ->\n     let mut st : state = start;\n     let mut in : input = digit; // most restricted, start here.\n \n-    let mut userinfo : option<userinfo> = option::none;\n+    let mut userinfo : Option<userinfo> = option::None;\n     let mut host : ~str = ~\"\";\n-    let mut port : option::option<~str> = option::none;\n+    let mut port : option::Option<~str> = option::None;\n \n     let mut colon_count = 0;\n     let mut pos : uint = 0, begin : uint = 2, end : uint = len;\n@@ -462,15 +462,15 @@ fn get_authority(rawurl: ~str) ->\n             match st {\n               start => {\n                 let user = str::slice(rawurl, begin, i);\n-                userinfo = option::some({user : user,\n-                                         pass: option::none});\n+                userinfo = option::Some({user : user,\n+                                         pass: option::None});\n                 st = in_host;\n               }\n               pass_host_port => {\n                 let user = str::slice(rawurl, begin, pos);\n                 let pass = str::slice(rawurl, pos+1, i);\n-                userinfo = option::some({user: user,\n-                                         pass: option::some(pass)});\n+                userinfo = option::Some({user: user,\n+                                         pass: option::Some(pass)});\n                 st = in_host;\n               }\n               _ => {\n@@ -510,7 +510,7 @@ fn get_authority(rawurl: ~str) ->\n             return result::err(@~\"Non-digit characters in port.\");\n         }\n         host = str::slice(rawurl, begin, pos);\n-        port = option::some(str::slice(rawurl, pos+1, end));\n+        port = option::Some(str::slice(rawurl, pos+1, end));\n       }\n       ip6_host | in_host => {\n         host = str::slice(rawurl, begin, end);\n@@ -519,7 +519,7 @@ fn get_authority(rawurl: ~str) ->\n         if in != digit {\n             return result::err(@~\"Non-digit characters in port.\");\n         }\n-        port = option::some(str::slice(rawurl, pos+1, end));\n+        port = option::Some(str::slice(rawurl, pos+1, end));\n       }\n     }\n \n@@ -562,21 +562,21 @@ fn get_path(rawurl: ~str, authority : bool) ->\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: ~str) ->\n-    result::result<(query, option<~str>), @~str> {\n+    result::result<(query, Option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n             let f = decode_component(str::slice(rawurl,\n                                                 1,\n                                                 str::len(rawurl)));\n-            return result::ok((~[], option::some(f)));\n+            return result::ok((~[], option::Some(f)));\n         } else {\n-            return result::ok((~[], option::none));\n+            return result::ok((~[], option::None));\n         }\n     }\n     let (q, r) = split_char_first(str::slice(rawurl, 1,\n                                              str::len(rawurl)), '#');\n     let f = if str::len(r) != 0 {\n-        option::some(decode_component(r)) } else { option::none };\n+        option::Some(decode_component(r)) } else { option::None };\n     return result::ok((query_from_str(q), f));\n }\n \n@@ -696,8 +696,8 @@ mod tests {\n     fn test_get_authority() {\n         let (u, h, p, r) = result::unwrap(get_authority(\n             ~\"//user:pass@rust-lang.org/something\"));\n-        assert u == option::some({user: ~\"user\",\n-                                  pass: option::some(~\"pass\")});\n+        assert u == option::Some({user: ~\"user\",\n+                                  pass: option::Some(~\"pass\")});\n         assert h == ~\"rust-lang.org\";\n         assert option::is_none(p);\n         assert r == ~\"/something\";\n@@ -706,7 +706,7 @@ mod tests {\n             ~\"//rust-lang.org:8000?something\"));\n         assert option::is_none(u);\n         assert h == ~\"rust-lang.org\";\n-        assert p == option::some(~\"8000\");\n+        assert p == option::Some(~\"8000\");\n         assert r == ~\"?something\";\n \n         let (u, h, p, r) = result::unwrap(get_authority(\n@@ -724,13 +724,13 @@ mod tests {\n         let (_, h, p, _) = result::unwrap(get_authority(\n             ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-        assert p == option::some(~\"8000\");\n+        assert p == option::Some(~\"8000\");\n \n         let (u, h, p, _) = result::unwrap(get_authority(\n             ~\"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n-        assert u == option::some({user: ~\"us\", pass : option::some(~\"p\")});\n+        assert u == option::Some({user: ~\"us\", pass : option::Some(~\"p\")});\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-        assert p == option::some(~\"8000\");\n+        assert p == option::Some(~\"8000\");\n \n         // invalid authorities;\n         assert result::is_err(get_authority("}, {"sha": "2a7cdeefc7d7f42a9c7fa3c5ff5a0104cda348ec", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -200,8 +200,8 @@ fn bal(rope:rope) -> rope {\n     match (rope) {\n       node::empty => return rope,\n       node::content(x) => match (node::bal(x)) {\n-        option::none    => rope,\n-        option::some(y) => node::content(y)\n+        option::None    => rope,\n+        option::Some(y) => node::content(y)\n       }\n     }\n }\n@@ -436,7 +436,7 @@ mod iterator {\n               node::content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n-        fn next(it: node::leaf_iterator::t) -> option<node::leaf> {\n+        fn next(it: node::leaf_iterator::t) -> Option<node::leaf> {\n             return node::leaf_iterator::next(it);\n         }\n     }\n@@ -447,7 +447,7 @@ mod iterator {\n               node::content(x) => return node::char_iterator::start(x)\n             }\n         }\n-        fn next(it: node::char_iterator::t) -> option<char> {\n+        fn next(it: node::char_iterator::t) -> Option<char> {\n             return node::char_iterator::next(it)\n         }\n     }\n@@ -801,8 +801,8 @@ mod node {\n         let it = leaf_iterator::start(node);\n         loop {\n             match (leaf_iterator::next(it)) {\n-              option::none => break,\n-              option::some(x) => {\n+              option::None => break,\n+              option::Some(x) => {\n                 //FIXME (#2744): Replace with memcpy or something similar\n                 let mut local_buf: ~[u8] =\n                     unsafe::reinterpret_cast(*x.content);\n@@ -851,24 +851,24 @@ mod node {\n      *\n      * # Return value\n      *\n-     * * `option::none` if no transformation happened\n+     * * `option::None` if no transformation happened\n      * * `option::some(x)` otherwise, in which case `x` has the same contents\n      *    as `node` bot lower height and/or fragmentation.\n      */\n-    fn bal(node: @node) -> option<@node> {\n-        if height(node) < hint_max_node_height { return option::none; }\n+    fn bal(node: @node) -> Option<@node> {\n+        if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[mut];\n         let it = leaf_iterator::start(node);\n         loop {\n             match (leaf_iterator::next(it)) {\n-              option::none    => break,\n-              option::some(x) => vec::push(forest, @leaf(x))\n+              option::None    => break,\n+              option::Some(x) => vec::push(forest, @leaf(x))\n             }\n         }\n         //2. Rebuild tree from forest\n         let root = @*tree_from_forest_destructive(forest);\n-        return option::some(root);\n+        return option::Some(root);\n \n     }\n \n@@ -1019,14 +1019,14 @@ mod node {\n         let mut result = 0;\n         while result == 0 {\n             match ((char_iterator::next(ita), char_iterator::next(itb))) {\n-              (option::none, option::none) => break,\n-              (option::some(chara), option::some(charb)) => {\n+              (option::None, option::None) => break,\n+              (option::Some(chara), option::Some(charb)) => {\n                 result = char::cmp(chara, charb);\n               }\n-              (option::some(_), _) => {\n+              (option::Some(_), _) => {\n                 result = 1;\n               }\n-              (_, option::some(_)) => {\n+              (_, option::Some(_)) => {\n                 result = -1;\n               }\n             }\n@@ -1121,8 +1121,8 @@ mod node {\n             }\n         }\n \n-        fn next(it: t) -> option<leaf> {\n-            if it.stackpos < 0 { return option::none; }\n+        fn next(it: t) -> Option<leaf> {\n+            if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n@@ -1133,7 +1133,7 @@ mod node {\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.left;\n                   }\n-                  leaf(x) => return option::some(x)\n+                  leaf(x) => return option::Some(x)\n                 }\n             };\n         }\n@@ -1142,49 +1142,49 @@ mod node {\n     mod char_iterator {\n         type t = {\n             leaf_iterator: leaf_iterator::t,\n-            mut leaf:  option<leaf>,\n+            mut leaf:  Option<leaf>,\n             mut leaf_byte_pos: uint\n         };\n \n         fn start(node: @node) -> t {\n             return {\n                 leaf_iterator: leaf_iterator::start(node),\n-                mut leaf:          option::none,\n+                mut leaf:          option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n         fn empty() -> t {\n             return {\n                 leaf_iterator: leaf_iterator::empty(),\n-                mut leaf:  option::none,\n+                mut leaf:  option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n-        fn next(it: t) -> option<char> {\n+        fn next(it: t) -> Option<char> {\n             loop {\n                 match (get_current_or_next_leaf(it)) {\n-                  option::none => return option::none,\n-                  option::some(_) => {\n+                  option::None => return option::None,\n+                  option::Some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n                     match (next_char) {\n-                      option::none => again,\n-                      option::some(_) => return next_char\n+                      option::None => again,\n+                      option::Some(_) => return next_char\n                     }\n                   }\n                 }\n             };\n         }\n \n-        fn get_current_or_next_leaf(it: t) -> option<leaf> {\n+        fn get_current_or_next_leaf(it: t) -> Option<leaf> {\n             match (it.leaf) {\n-              option::some(_) => return it.leaf,\n-              option::none => {\n+              option::Some(_) => return it.leaf,\n+              option::None => {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n                 match (next) {\n-                  option::none => return option::none,\n-                  option::some(_) => {\n+                  option::None => return option::None,\n+                  option::Some(_) => {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n                     return next;\n@@ -1194,20 +1194,20 @@ mod node {\n             }\n         }\n \n-        fn get_next_char_in_leaf(it: t) -> option<char> {\n+        fn get_next_char_in_leaf(it: t) -> Option<char> {\n             match copy it.leaf {\n-              option::none => return option::none,\n-              option::some(aleaf) => {\n+              option::None => return option::None,\n+              option::Some(aleaf) => {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n-                    it.leaf = option::none;\n-                    return option::none\n+                    it.leaf = option::None;\n+                    return option::None\n                 } else {\n                     let {ch, next} =\n                         str::char_range_at(*aleaf.content,\n                                      it.leaf_byte_pos + aleaf.byte_offset);\n                     it.leaf_byte_pos = next - aleaf.byte_offset;\n-                    return option::some(ch)\n+                    return option::Some(ch)\n                 }\n               }\n             }\n@@ -1275,11 +1275,11 @@ mod tests {\n         let mut equal   = true;\n         while equal {\n             match (node::char_iterator::next(rope_iter)) {\n-              option::none => {\n+              option::None => {\n                 if string_iter < string_len {\n                     equal = false;\n                 } break; }\n-              option::some(c) => {\n+              option::Some(c) => {\n                 let {ch, next} = str::char_range_at(*sample, string_iter);\n                 string_iter = next;\n                 if ch != c { equal = false; break; }\n@@ -1302,8 +1302,8 @@ mod tests {\n         let it  = iterator::char::start(r);\n         loop {\n             match (node::char_iterator::next(it)) {\n-              option::none => break,\n-              option::some(_) => len += 1u\n+              option::None => break,\n+              option::Some(_) => len += 1u\n             }\n         }\n "}, {"sha": "411d18b72fc0c59c73d01325f874f66f54f3d36f", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -241,13 +241,13 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n     d.read_bool()\n }\n \n-fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n+fn serialize_Option<S: serializer,T>(s: S, v: Option<T>, st: fn(T)) {\n     do s.emit_enum(~\"option\") {\n         match v {\n-          none => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+          None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n           },\n \n-          some(v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+          Some(v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n             do s.emit_enum_variant_arg(0u) {\n                 st(v)\n             }\n@@ -256,13 +256,13 @@ fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n     }\n }\n \n-fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n-    -> option<T> {\n+fn deserialize_Option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n+    -> Option<T> {\n     do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {\n             match i {\n-              0 => none,\n-              1 => some(d.read_enum_variant_arg(0u, || st() )),\n+              0 => None,\n+              1 => Some(d.read_enum_variant_arg(0u, || st() )),\n               _ => fail(#fmt(\"Bad variant for option: %u\", i))\n             }\n         }"}, {"sha": "8883e0eb07990c3ec5711db8fe0bf099376e31ee", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,13 +3,13 @@\n  * are O(highest integer key).\n  */\n import core::option;\n-import core::option::{some, none};\n+import core::option::{Some, None};\n import dvec::{DVec, dvec};\n import map::map;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type smallintmap_<T: copy> = {v: DVec<option<T>>};\n+type smallintmap_<T: copy> = {v: DVec<Option<T>>};\n \n enum smallintmap<T:copy> {\n     smallintmap_(@smallintmap_<T>)\n@@ -28,16 +28,16 @@ fn mk<T: copy>() -> smallintmap<T> {\n #[inline(always)]\n fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n     //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, none, some(val));\n+    self.v.grow_set_elt(key, None, Some(val));\n }\n \n /**\n  * Get the value for the specified key. If the key does not exist\n  * in the map then returns none\n  */\n-pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n+pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> Option<T> {\n     if key < self.v.len() { return self.v.get_elt(key); }\n-    return none::<T>;\n+    return None::<T>;\n }\n \n /**\n@@ -49,11 +49,11 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n  */\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     match find(self, key) {\n-      none => {\n+      None => {\n         error!(\"smallintmap::get(): key not present\");\n         fail;\n       }\n-      some(v) => return v\n+      Some(v) => return v\n     }\n }\n \n@@ -68,7 +68,7 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n         let mut sz = 0u;\n         for self.v.each |item| {\n             match item {\n-              some(_) => sz += 1u,\n+              Some(_) => sz += 1u,\n               _ => ()\n             }\n         }\n@@ -85,7 +85,7 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n             return false;\n         }\n         let old = self.v.get_elt(key);\n-        self.v.set_elt(key, none);\n+        self.v.set_elt(key, None);\n         old.is_some()\n     }\n     fn clear() {\n@@ -98,14 +98,14 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n         contains_key(self, *key)\n     }\n     fn get(+key: uint) -> V { get(self, key) }\n-    fn find(+key: uint) -> option<V> { find(self, key) }\n+    fn find(+key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n     fn each(it: fn(+key: uint, +value: V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             match self.v.get_elt(idx) {\n-              some(elt) => if !it(idx, elt) { break },\n-              none => ()\n+              Some(elt) => if !it(idx, elt) { break },\n+              None => ()\n             }\n             idx += 1u;\n         }\n@@ -120,8 +120,8 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             match self.v.get_elt(idx) {\n-              some(elt) => if !it(&idx, &elt) { break },\n-              none => ()\n+              Some(elt) => if !it(&idx, &elt) { break },\n+              None => ()\n             }\n             idx += 1u;\n         }"}, {"sha": "775dcbd09383209c50346a3b795ff09a5b886ba0", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -90,15 +90,15 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n #[doc(hidden)]\n impl<Q: send> &sem<Q> {\n     fn acquire() {\n-        let mut waiter_nobe = none;\n+        let mut waiter_nobe = None;\n         unsafe {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe.\n                     let (signal_end, wait_end) = pipes::oneshot();\n                     // Tell outer scope we need to block.\n-                    waiter_nobe = some(wait_end);\n+                    waiter_nobe = Some(wait_end);\n                     // Enqueue ourself.\n                     state.waiters.tail.send(signal_end);\n                 }\n@@ -126,11 +126,11 @@ impl<Q: send> &sem<Q> {\n #[doc(hidden)]\n impl &sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n-        let mut release = none;\n+        let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = some(sem_release(self));\n+                release = Some(sem_release(self));\n             }\n         }\n         blk()\n@@ -139,11 +139,11 @@ impl &sem<()> {\n #[doc(hidden)]\n impl &sem<~[mut waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n-        let mut release = none;\n+        let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = some(sem_and_signal_release(self));\n+                release = Some(sem_and_signal_release(self));\n             }\n         }\n         blk()\n@@ -191,10 +191,10 @@ impl &condvar {\n     fn wait_on(condvar_id: uint) {\n         // Create waiter nobe.\n         let (signal_end, wait_end) = pipes::oneshot();\n-        let mut wait_end   = some(wait_end);\n-        let mut signal_end = some(signal_end);\n-        let mut reacquire = none;\n-        let mut out_of_bounds = none;\n+        let mut wait_end   = Some(wait_end);\n+        let mut signal_end = Some(signal_end);\n+        let mut reacquire = None;\n+        let mut out_of_bounds = None;\n         unsafe {\n             do task::unkillable {\n                 // Release lock, 'atomically' enqueuing ourselves in so doing.\n@@ -209,7 +209,7 @@ impl &condvar {\n                         let signal_end = option::swap_unwrap(&mut signal_end);\n                         state.blocked[condvar_id].tail.send(signal_end);\n                     } else {\n-                        out_of_bounds = some(vec::len(state.blocked));\n+                        out_of_bounds = Some(vec::len(state.blocked));\n                     }\n                 }\n \n@@ -218,7 +218,7 @@ impl &condvar {\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n                 if out_of_bounds.is_none() {\n-                    reacquire = some(sem_and_signal_reacquire(self.sem));\n+                    reacquire = Some(sem_and_signal_reacquire(self.sem));\n                 }\n             }\n         }\n@@ -248,14 +248,14 @@ impl &condvar {\n     fn signal() -> bool { self.signal_on(0) }\n     /// As signal, but with a specified condvar_id. See wait_on.\n     fn signal_on(condvar_id: uint) -> bool {\n-        let mut out_of_bounds = none;\n+        let mut out_of_bounds = None;\n         let mut result = false;\n         unsafe {\n             do (**self.sem).with |state| {\n                 if condvar_id < vec::len(state.blocked) {\n                     result = signal_waitqueue(&state.blocked[condvar_id]);\n                 } else {\n-                    out_of_bounds = some(vec::len(state.blocked));\n+                    out_of_bounds = Some(vec::len(state.blocked));\n                 }\n             }\n         }\n@@ -268,18 +268,18 @@ impl &condvar {\n     fn broadcast() -> uint { self.broadcast_on(0) }\n     /// As broadcast, but with a specified condvar_id. See wait_on.\n     fn broadcast_on(condvar_id: uint) -> uint {\n-        let mut out_of_bounds = none;\n-        let mut queue = none;\n+        let mut out_of_bounds = None;\n+        let mut queue = None;\n         unsafe {\n             do (**self.sem).with |state| {\n                 if condvar_id < vec::len(state.blocked) {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n-                    queue = some(util::replace(&mut state.blocked[condvar_id],\n+                    queue = Some(util::replace(&mut state.blocked[condvar_id],\n                                                new_waitqueue()));\n                 } else {\n-                    out_of_bounds = some(vec::len(state.blocked));\n+                    out_of_bounds = Some(vec::len(state.blocked));\n                 }\n             }\n         }\n@@ -294,16 +294,16 @@ impl &condvar {\n // something else next on success.\n #[inline(always)]\n #[doc(hidden)]\n-fn check_cvar_bounds<U>(out_of_bounds: option<uint>, id: uint, act: &str,\n+fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: fn() -> U) -> U {\n     match out_of_bounds {\n-        some(0) =>\n+        Some(0) =>\n             fail fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n                       act, id),\n-        some(length) =>\n+        Some(length) =>\n             fail fmt!(\"%s with illegal ID %u - ID must be less than %u\",\n                       act, id, length),\n-        none => blk()\n+        None => blk()\n     }\n }\n \n@@ -438,7 +438,7 @@ impl &rwlock {\n      * tasks may run concurrently with this one.\n      */\n     fn read<U>(blk: fn() -> U) -> U {\n-        let mut release = none;\n+        let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 do (&self.order_lock).access {\n@@ -458,7 +458,7 @@ impl &rwlock {\n                         }\n                     }\n                 }\n-                release = some(rwlock_release_read(self));\n+                release = Some(rwlock_release_read(self));\n             }\n         }\n         blk()\n@@ -524,14 +524,14 @@ impl &rwlock {\n     fn write_downgrade<U>(blk: fn(+rwlock_write_mode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n-        let mut _release = none;\n+        let mut _release = None;\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n                 (&self.access_lock).acquire();\n                 (&self.order_lock).release();\n             }\n-            _release = some(rwlock_release_downgrade(self));\n+            _release = Some(rwlock_release_downgrade(self));\n         }\n         blk(rwlock_write_mode { lock: self })\n     }\n@@ -723,7 +723,7 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (c,p) = pipes::stream();\n-            let child_data = ~mut some((s2,c));\n+            let child_data = ~mut Some((s2,c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n                 do task::spawn {\n@@ -900,7 +900,7 @@ mod tests {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (c,p) = pipes::stream();\n-                let c = ~mut some(c);\n+                let c = ~mut Some(c);\n                 vec::push(sibling_convos, p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n@@ -1234,7 +1234,7 @@ mod tests {\n         let x = ~rwlock();\n         let y = ~rwlock();\n         do x.write_downgrade |xwrite| {\n-            let mut xopt = some(xwrite);\n+            let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(option::swap_unwrap(&mut xopt));\n                 error!(\"oops, y.downgrade(x) should have failed!\");"}, {"sha": "2abaaa11fa0f0be3fc257ddc90bea64dd4993527", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1,28 +1,28 @@\n //! Temporary files and directories\n \n import core::option;\n-import option::{none, some};\n+import option::{None, Some};\n import rand;\n \n-fn mkdtemp(tmpdir: &Path, suffix: &str) -> option<Path> {\n+fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let r = rand::rng();\n     let mut i = 0u;\n     while (i < 1000u) {\n         let p = tmpdir.push(r.gen_str(16u) +\n                             str::from_slice(suffix));\n         if os::make_dir(&p, 0x1c0i32) {  // FIXME: u+rwx (#2349)\n-            return some(p);\n+            return Some(p);\n         }\n         i += 1u;\n     }\n-    return none;\n+    return None;\n }\n \n #[test]\n fn test_mkdtemp() {\n     let r = mkdtemp(&Path(\".\"), \"foobar\");\n     match r {\n-        some(p) => {\n+        Some(p) => {\n             os::remove_dir(&p);\n             assert(str::ends_with(p.to_str(), \"foobar\"));\n         }"}, {"sha": "424e4b61eb094472be40354e74fab719f029d104", "filename": "src/libstd/term.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -1,6 +1,6 @@\n //! Simple ANSI color library\n \n-import core::option;\n+import core::Option;\n \n // FIXME (#2807): Windows support.\n \n@@ -36,13 +36,13 @@ fn color_supported() -> bool {\n     let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n     return match os::getenv(~\"TERM\") {\n-          option::some(env) => {\n+          option::Some(env) => {\n             for vec::each(supported_terms) |term| {\n                 if term == env { return true; }\n             }\n             false\n           }\n-          option::none => false\n+          option::None => false\n         };\n }\n "}, {"sha": "803916f64a1a898fa84d4445d3ee33547c7c5d22", "filename": "src/libstd/test.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -60,8 +60,8 @@ fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n-type test_opts = {filter: option<~str>, run_ignored: bool,\n-                  logfile: option<~str>};\n+type test_opts = {filter: Option<~str>, run_ignored: bool,\n+                  logfile: Option<~str>};\n \n type opt_res = Either<test_opts, ~str>;\n \n@@ -77,8 +77,8 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n \n     let filter =\n         if vec::len(matches.free) > 0u {\n-            option::some(matches.free[0])\n-        } else { option::none };\n+            option::Some(matches.free[0])\n+        } else { option::None };\n \n     let run_ignored = getopts::opt_present(matches, ~\"ignored\");\n     let logfile = getopts::opt_maybe_str(matches, ~\"logfile\");\n@@ -93,7 +93,7 @@ enum test_result { tr_ok, tr_failed, tr_ignored, }\n \n type console_test_state =\n     @{out: io::Writer,\n-      log_out: option<io::Writer>,\n+      log_out: Option<io::Writer>,\n       use_color: bool,\n       mut total: uint,\n       mut passed: uint,\n@@ -115,8 +115,8 @@ fn run_tests_console(opts: test_opts,\n           te_wait(test) => st.out.write_str(fmt!(\"test %s ... \", test.name)),\n           te_result(test, result) => {\n             match st.log_out {\n-                some(f) => write_log(f, result, test),\n-                none => ()\n+                Some(f) => write_log(f, result, test),\n+                None => ()\n             }\n             match result {\n               tr_ok => {\n@@ -141,14 +141,14 @@ fn run_tests_console(opts: test_opts,\n     }\n \n     let log_out = match opts.logfile {\n-        some(path) => match io::file_writer(&Path(path),\n+        Some(path) => match io::file_writer(&Path(path),\n                                             ~[io::Create, io::Truncate]) {\n-          result::ok(w) => some(w),\n+          result::ok(w) => Some(w),\n           result::err(s) => {\n               fail(fmt!(\"can't open output file: %s\", s))\n           }\n         },\n-        none => none\n+        None => None\n     };\n \n     let st =\n@@ -243,7 +243,7 @@ fn should_sort_failures_before_printing_them() {\n \n     let st =\n         @{out: writer,\n-          log_out: option::none,\n+          log_out: option::None,\n           use_color: false,\n           mut total: 0u,\n           mut passed: 0u,\n@@ -337,15 +337,15 @@ fn filter_tests(opts: test_opts,\n     } else {\n         let filter_str =\n             match opts.filter {\n-          option::some(f) => f,\n-          option::none => ~\"\"\n+          option::Some(f) => f,\n+          option::None => ~\"\"\n         };\n \n         fn filter_fn(test: test_desc, filter_str: ~str) ->\n-            option<test_desc> {\n+            Option<test_desc> {\n             if str::contains(test.name, filter_str) {\n-                return option::some(copy test);\n-            } else { return option::none; }\n+                return option::Some(copy test);\n+            } else { return option::None; }\n         }\n \n         vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n@@ -355,13 +355,13 @@ fn filter_tests(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter(test: test_desc) -> option<test_desc> {\n+        fn filter(test: test_desc) -> Option<test_desc> {\n             if test.ignore {\n-                return option::some({name: test.name,\n+                return option::Some({name: test.name,\n                                   fn: copy test.fn,\n                                   ignore: false,\n                                   should_fail: test.should_fail});\n-            } else { return option::none; }\n+            } else { return option::None; }\n         };\n \n         vec::filter_map(filtered, |x| filter(x))\n@@ -388,9 +388,9 @@ fn run_test(+test: test_desc, monitor_ch: comm::Chan<monitor_msg>) {\n \n     do task::spawn {\n         let testfn = copy test.fn;\n-        let mut result_future = none; // task::future_result(builder);\n+        let mut result_future = None; // task::future_result(builder);\n         task::task().unlinked().future_result(|+r| {\n-            result_future = some(r);\n+            result_future = Some(r);\n         }).spawn(testfn);\n         let task_result = future::get(&option::unwrap(result_future));\n         let test_result = calc_result(test, task_result == task::Success);\n@@ -501,8 +501,8 @@ mod tests {\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n-        let opts = {filter: option::none, run_ignored: true,\n-            logfile: option::none};\n+        let opts = {filter: option::None, run_ignored: true,\n+            logfile: option::None};\n         let tests =\n             ~[{name: ~\"1\", fn: fn~() { }, ignore: true, should_fail: false},\n              {name: ~\"2\", fn: fn~() { }, ignore: false, should_fail: false}];\n@@ -515,8 +515,8 @@ mod tests {\n \n     #[test]\n     fn sort_tests() {\n-        let opts = {filter: option::none, run_ignored: false,\n-            logfile: option::none};\n+        let opts = {filter: option::None, run_ignored: false,\n+            logfile: option::None};\n \n         let names =\n             ~[~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\","}, {"sha": "2013728944796c6f7cd43b51e996ac02cfadd6c0", "filename": "src/libstd/time.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -159,23 +159,23 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n     }\n \n     fn match_strs(ss: &str, pos: uint, strs: &[(~str, i32)])\n-      -> option<(i32, uint)> {\n+      -> Option<(i32, uint)> {\n         let mut i = 0u;\n         let len = vec::len(strs);\n         while i < len {\n             let (needle, value) = strs[i];\n \n             if match_str(ss, pos, needle) {\n-                return some((value, pos + str::len(needle)));\n+                return Some((value, pos + str::len(needle)));\n             }\n             i += 1u;\n         }\n \n-        none\n+        None\n     }\n \n     fn match_digits(ss: &str, pos: uint, digits: uint, ws: bool)\n-      -> option<(i32, uint)> {\n+      -> Option<(i32, uint)> {\n         let mut pos = pos;\n         let mut value = 0_i32;\n \n@@ -189,12 +189,12 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n                 value = value * 10_i32 + (ch as i32 - '0' as i32);\n               }\n               ' ' if ws => (),\n-              _ => return none\n+              _ => return None\n             }\n             i += 1u;\n         }\n \n-        some((value, pos))\n+        Some((value, pos))\n     }\n \n     fn parse_char(s: &str, pos: uint, c: char) -> result<uint, ~str> {\n@@ -221,8 +221,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Friday\", 5_i32),\n               (~\"Saturday\", 6_i32)\n           ]) {\n-            some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-            none => err(~\"Invalid day\")\n+            Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+            None => err(~\"Invalid day\")\n           },\n           'a' => match match_strs(s, pos, ~[\n               (~\"Sun\", 0_i32),\n@@ -233,8 +233,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Fri\", 5_i32),\n               (~\"Sat\", 6_i32)\n           ]) {\n-            some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-            none => err(~\"Invalid day\")\n+            Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+            None => err(~\"Invalid day\")\n           },\n           'B' => match match_strs(s, pos, ~[\n               (~\"January\", 0_i32),\n@@ -250,8 +250,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"November\", 10_i32),\n               (~\"December\", 11_i32)\n           ]) {\n-            some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-            none => err(~\"Invalid month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+            None => err(~\"Invalid month\")\n           },\n           'b' | 'h' => match match_strs(s, pos, ~[\n               (~\"Jan\", 0_i32),\n@@ -267,16 +267,16 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Nov\", 10_i32),\n               (~\"Dec\", 11_i32)\n           ]) {\n-            some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-            none => err(~\"Invalid month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+            None => err(~\"Invalid month\")\n           },\n           'C' => match match_digits(s, pos, 2u, false) {\n-            some(item) => {\n+            Some(item) => {\n                 let (v, pos) = item;\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n                   ok(pos)\n               }\n-            none => err(~\"Invalid year\")\n+            None => err(~\"Invalid year\")\n           },\n           'c' => {\n             parse_type(s, pos, 'a', tm)\n@@ -297,12 +297,12 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n                 .chain(|pos| parse_type(s, pos, 'y', tm))\n           }\n           'd' => match match_digits(s, pos, 2u, false) {\n-            some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-            none => err(~\"Invalid day of the month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+            None => err(~\"Invalid day of the month\")\n           },\n           'e' => match match_digits(s, pos, 2u, true) {\n-            some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-            none => err(~\"Invalid day of the month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+            None => err(~\"Invalid day of the month\")\n           },\n           'F' => {\n             parse_type(s, pos, 'Y', tm)\n@@ -314,80 +314,80 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'H' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none => err(~\"Invalid hour\")\n+              Some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              None => err(~\"Invalid hour\")\n             }\n           }\n           'I' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => {\n+              Some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none => err(~\"Invalid hour\")\n+              None => err(~\"Invalid hour\")\n             }\n           }\n           'j' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 3u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_yday = v - 1_i32;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid year\")\n+              None => err(~\"Invalid year\")\n             }\n           }\n           'k' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, true) {\n-              some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none => err(~\"Invalid hour\")\n+              Some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              None => err(~\"Invalid hour\")\n             }\n           }\n           'l' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, true) {\n-              some(item) => {\n+              Some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none => err(~\"Invalid hour\")\n+              None => err(~\"Invalid hour\")\n             }\n           }\n           'M' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n-              none => err(~\"Invalid minute\")\n+              Some(item) => { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n+              None => err(~\"Invalid minute\")\n             }\n           }\n           'm' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_mon = v - 1_i32;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid month\")\n+              None => err(~\"Invalid month\")\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n                                   ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n \n-            some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-            none => err(~\"Invalid hour\")\n+            Some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+            None => err(~\"Invalid hour\")\n           },\n           'p' => match match_strs(s, pos,\n                                   ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n \n-            some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-            none => err(~\"Invalid hour\")\n+            Some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+            None => err(~\"Invalid hour\")\n           },\n           'R' => {\n             parse_type(s, pos, 'H', tm)\n@@ -406,12 +406,12 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'S' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_sec = v;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid second\")\n+              None => err(~\"Invalid second\")\n             }\n           }\n           //'s' {}\n@@ -426,12 +426,12 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'u' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 1u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_wday = v;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid weekday\")\n+              None => err(~\"Invalid weekday\")\n             }\n           }\n           'v' => {\n@@ -445,32 +445,32 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'w' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 1u, false) {\n-              some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none => err(~\"Invalid weekday\")\n+              Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              None => err(~\"Invalid weekday\")\n             }\n           }\n           //'X' {}\n           //'x' {}\n           'Y' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 4u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid weekday\")\n+              None => err(~\"Invalid weekday\")\n             }\n           }\n           'y' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              some(item) => {\n+              Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none => err(~\"Invalid weekday\")\n+              None => err(~\"Invalid weekday\")\n             }\n           }\n           'Z' => {\n@@ -497,7 +497,7 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n \n             if ch == '+' || ch == '-' {\n                 match match_digits(s, next, 4u, false) {\n-                  some(item) => {\n+                  Some(item) => {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n@@ -506,7 +506,7 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n \n                     ok(pos)\n                   }\n-                  none => err(~\"Invalid zone offset\")\n+                  None => err(~\"Invalid zone offset\")\n                 }\n             } else {\n                 err(~\"Invalid zone offset\")"}, {"sha": "3c706bbddc60798b4c76fb8e7982ac093c8100c5", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -104,7 +104,7 @@ fn sleep(iotask: iotask, msecs: uint) {\n  */\n fn recv_timeout<T: copy send>(iotask: iotask,\n                               msecs: uint,\n-                              wait_po: comm::Port<T>) -> option<T> {\n+                              wait_po: comm::Port<T>) -> Option<T> {\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n     delayed_send(iotask, msecs, timeout_ch, ());\n@@ -113,9 +113,9 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n         |left_val| {\n             log(debug, fmt!(\"recv_time .. left_val %?\",\n                            left_val));\n-            none\n+            None\n         }, |right_val| {\n-            some(*right_val)\n+            Some(*right_val)\n         }, &core::comm::select2(timeout_po, wait_po)\n     )\n }\n@@ -249,7 +249,7 @@ mod test {\n             };\n \n             match recv_timeout(hl_loop, 1u, test_po) {\n-              none => successes += 1,\n+              None => successes += 1,\n               _ => failures += 1\n             };\n         }"}, {"sha": "ec44971d756f12b6f32b0f20a141577b17997f74", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -6,8 +6,8 @@\n  * red-black tree or something else.\n  */\n \n-import core::option::{some, none};\n-import option = core::option;\n+import core::option::{Some, None};\n+import Option = core::Option;\n \n export treemap;\n export insert;\n@@ -16,7 +16,7 @@ export traverse;\n \n type treemap<K, V> = @mut tree_edge<K, V>;\n \n-type tree_edge<K, V> = option<@tree_node<K, V>>;\n+type tree_edge<K, V> = Option<@tree_node<K, V>>;\n \n enum tree_node<K, V> = {\n     key: K,\n@@ -26,19 +26,19 @@ enum tree_node<K, V> = {\n };\n \n /// Create a treemap\n-fn treemap<K, V>() -> treemap<K, V> { @mut none }\n+fn treemap<K, V>() -> treemap<K, V> { @mut None }\n \n /// Insert a value into the map\n fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n     match copy *m {\n-      none => {\n-        *m = some(@tree_node({key: k,\n+      None => {\n+        *m = Some(@tree_node({key: k,\n                               mut value: v,\n-                              mut left: none,\n-                              mut right: none}));\n+                              mut left: None,\n+                              mut right: None}));\n         return;\n       }\n-      some(node) => {\n+      Some(node) => {\n         if k == node.key {\n             node.value = v;\n         } else if k < node.key {\n@@ -51,14 +51,14 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n }\n \n /// Find a value based on the key\n-fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n+fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> Option<V> {\n     match copy *m {\n-      none => none,\n+      None => None,\n \n       // FIXME (#2808): was that an optimization?\n-      some(node) => {\n+      Some(node) => {\n         if k == node.key {\n-            some(node.value)\n+            Some(node.value)\n         } else if k < node.key {\n             find(&const node.left, k)\n         } else {\n@@ -71,8 +71,8 @@ fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n /// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: &const tree_edge<K, V>, f: fn(K, V)) {\n     match copy *m {\n-      none => (),\n-      some(node) => {\n+      None => (),\n+      Some(node) => {\n         traverse(&const node.left, f);\n         // copy of value is req'd as f() requires an immutable ptr\n         f(node.key, copy node.value);\n@@ -97,19 +97,19 @@ mod tests {\n     fn insert_find() {\n         let m = treemap();\n         insert(m, 1, 2);\n-        assert (find(m, 1) == some(2));\n+        assert (find(m, 1) == Some(2));\n     }\n \n     #[test]\n     fn find_empty() {\n-        let m = treemap::<int, int>(); assert (find(m, 1) == none);\n+        let m = treemap::<int, int>(); assert (find(m, 1) == None);\n     }\n \n     #[test]\n     fn find_not_found() {\n         let m = treemap();\n         insert(m, 1, 2);\n-        assert (find(m, 2) == none);\n+        assert (find(m, 2) == None);\n     }\n \n     #[test]\n@@ -138,7 +138,7 @@ mod tests {\n         insert(m, k1, ~\"foo\");\n         insert(m, k2, ~\"bar\");\n \n-        assert (find(m, k2) == some(~\"bar\"));\n-        assert (find(m, k1) == some(~\"foo\"));\n+        assert (find(m, k2) == Some(~\"bar\"));\n+        assert (find(m, k1) == Some(~\"foo\"));\n     }\n }"}, {"sha": "a9df28abeba7defab85213a65b003027869a38b8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -3,8 +3,8 @@\n import codemap::{span, filename};\n import std::serialization::{serializer,\n                             deserializer,\n-                            serialize_option,\n-                            deserialize_option,\n+                            serialize_Option,\n+                            deserialize_Option,\n                             serialize_uint,\n                             deserialize_uint,\n                             serialize_int,\n@@ -40,16 +40,16 @@ macro_rules! interner_key (\n \n fn serialize_ident<S: serializer>(s: S, i: ident) {\n     let intr = match unsafe{task::local_data_get(interner_key!())}{\n-        none => fail ~\"serialization: TLS interner not set up\",\n-        some(intr) => intr\n+        None => fail ~\"serialization: TLS interner not set up\",\n+        Some(intr) => intr\n     };\n \n     s.emit_str(*(*intr).get(i));\n }\n fn deserialize_ident<D: deserializer>(d: D) -> ident  {\n     let intr = match unsafe{task::local_data_get(interner_key!())}{\n-        none => fail ~\"deserialization: TLS interner not set up\",\n-        some(intr) => intr\n+        None => fail ~\"deserialization: TLS interner not set up\",\n+        Some(intr) => intr\n     };\n \n     (*intr).intern(@d.read_str())\n@@ -59,13 +59,13 @@ type ident = token::str_num;\n \n // Functions may or may not have names.\n #[auto_serialize]\n-type fn_ident = option<ident>;\n+type fn_ident = Option<ident>;\n \n #[auto_serialize]\n type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n-             rp: option<@region>,\n+             rp: Option<@region>,\n              types: ~[@ty]};\n \n #[auto_serialize]\n@@ -162,7 +162,7 @@ type blk = spanned<blk_>;\n #[auto_serialize]\n type blk_ = {view_items: ~[@view_item],\n              stmts: ~[@stmt],\n-             expr: option<@expr>,\n+             expr: Option<@expr>,\n              id: node_id,\n              rules: blk_check_mode};\n \n@@ -185,13 +185,13 @@ enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n     // or a nullary enum (in which case the second field\n-    // is none).\n+    // is None).\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, @path, option<@pat>),\n-    pat_enum(@path, option<~[@pat]>), // \"none\" means a * pattern where\n+    pat_ident(binding_mode, @path, Option<@pat>),\n+    pat_enum(@path, Option<~[@pat]>), // \"none\" means a * pattern where\n                                   // we don't bind the fields to names\n     pat_rec(~[field_pat], bool),\n     pat_struct(@path, ~[field_pat], bool),\n@@ -216,7 +216,7 @@ enum proto {\n #[auto_serialize]\n enum vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n-    vstore_fixed(option<uint>),   // [1,2,3,4]/_ or 4\n+    vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n     vstore_uniq,                  // ~[1,2,3,4]\n     vstore_box,                   // @[1,2,3,4]\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n@@ -297,7 +297,7 @@ type initializer = {op: init_op, expr: @expr};\n // a refinement on pat.\n #[auto_serialize]\n type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n-                init: option<initializer>, id: node_id};\n+                init: Option<initializer>, id: node_id};\n \n #[auto_serialize]\n type local = spanned<local_>;\n@@ -309,7 +309,7 @@ type decl = spanned<decl_>;\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_serialize]\n-type arm = {pats: ~[@pat], guard: option<@expr>, body: blk};\n+type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n #[auto_serialize]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n@@ -335,19 +335,19 @@ enum alt_mode { alt_check, alt_exhaustive, }\n enum expr_ {\n     expr_vstore(@expr, vstore),\n     expr_vec(~[@expr], mutability),\n-    expr_rec(~[field], option<@expr>),\n+    expr_rec(~[field], Option<@expr>),\n     expr_call(@expr, ~[@expr], bool), // True iff last argument is a block\n     expr_tup(~[@expr]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),\n     expr_cast(@expr, @ty),\n-    expr_if(@expr, blk, option<@expr>),\n+    expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, ret, or fail)\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */\n-    expr_loop(blk, option<ident>),\n+    expr_loop(blk, Option<ident>),\n     expr_match(@expr, ~[arm]),\n     expr_fn(proto, fn_decl, blk, capture_clause),\n     expr_fn_block(fn_decl, blk, capture_clause),\n@@ -369,10 +369,10 @@ enum expr_ {\n     expr_index(@expr, @expr),\n     expr_path(@path),\n     expr_addr_of(mutability, @expr),\n-    expr_fail(option<@expr>),\n-    expr_break(option<ident>),\n-    expr_again(option<ident>),\n-    expr_ret(option<@expr>),\n+    expr_fail(Option<@expr>),\n+    expr_break(Option<ident>),\n+    expr_again(Option<ident>),\n+    expr_ret(Option<@expr>),\n     expr_log(log_level, @expr, @expr),\n \n     /* just an assert */\n@@ -381,7 +381,7 @@ enum expr_ {\n     expr_mac(mac),\n \n     // A struct literal expression.\n-    expr_struct(@path, ~[field], option<@expr>),\n+    expr_struct(@path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n     expr_repeat(@expr /* element */, @expr /* count */, mutability)\n@@ -420,7 +420,7 @@ enum token_tree {\n     tt_tok(span, token::token),\n     tt_delim(~[token_tree]),\n     // These only make sense for right-hand-sides of MBE macros\n-    tt_seq(span, ~[token_tree], option<token::token>, bool),\n+    tt_seq(span, ~[token_tree], Option<token::token>, bool),\n     tt_nonterminal(span, ident)\n }\n \n@@ -485,7 +485,7 @@ enum matcher_ {\n     match_tok(token::token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    match_seq(~[matcher], option<token::token>, bool, uint, uint),\n+    match_seq(~[matcher], Option<token::token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n     match_nonterminal(ident, ident, uint)\n }\n@@ -494,13 +494,13 @@ enum matcher_ {\n type mac = spanned<mac_>;\n \n #[auto_serialize]\n-type mac_arg = option<@expr>;\n+type mac_arg = Option<@expr>;\n \n #[auto_serialize]\n type mac_body_ = {span: span};\n \n #[auto_serialize]\n-type mac_body = option<mac_body_>;\n+type mac_body = Option<mac_body_>;\n \n #[auto_serialize]\n enum mac_ {\n@@ -593,7 +593,7 @@ enum ty_ {\n     ty_fn(proto, purity, @~[ty_param_bound], fn_decl),\n     ty_tup(~[@ty]),\n     ty_path(@path, node_id),\n-    ty_fixed_length(@ty, option<uint>),\n+    ty_fixed_length(@ty, Option<uint>),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -672,11 +672,11 @@ enum variant_kind {\n }\n \n #[auto_serialize]\n-enum enum_def = { variants: ~[variant], common: option<@struct_def> };\n+enum enum_def = { variants: ~[variant], common: Option<@struct_def> };\n \n #[auto_serialize]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n-                 id: node_id, disr_expr: option<@expr>, vis: visibility};\n+                 id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n #[auto_serialize]\n type variant = spanned<variant_>;\n@@ -770,9 +770,9 @@ type struct_def = {\n     methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n     /* ctor is optional, and will soon go away */\n-    ctor: option<class_ctor>,\n+    ctor: Option<class_ctor>,\n     /* dtor is optional */\n-    dtor: option<class_dtor>\n+    dtor: Option<class_dtor>\n };\n \n #[auto_serialize]"}, {"sha": "d0c67f85bb09735cc71eb9231655e306bff51473", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -295,10 +295,10 @@ fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n \n fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n     match map.find(id) {\n-      none => {\n+      None => {\n         fmt!(\"unknown node (id=%d)\", id)\n       }\n-      some(node_item(item, path)) => {\n+      Some(node_item(item, path)) => {\n         let path_str = path_ident_to_str(*path, item.ident, itr);\n         let item_str = match item.node {\n           item_const(*) => ~\"const\",\n@@ -314,48 +314,48 @@ fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n         };\n         fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n       }\n-      some(node_foreign_item(item, abi, path)) => {\n+      Some(node_foreign_item(item, abi, path)) => {\n         fmt!(\"foreign item %s with abi %? (id=%?)\",\n              path_ident_to_str(*path, item.ident, itr), abi, id)\n       }\n-      some(node_method(m, impl_did, path)) => {\n+      Some(node_method(m, impl_did, path)) => {\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n-      some(node_trait_method(tm, impl_did, path)) => {\n+      Some(node_trait_method(tm, impl_did, path)) => {\n         let m = ast_util::trait_method_to_ty_method(*tm);\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n-      some(node_variant(variant, def_id, path)) => {\n+      Some(node_variant(variant, def_id, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n              *itr.get(variant.node.name), path_to_str(*path, itr), id)\n       }\n-      some(node_expr(expr)) => {\n+      Some(node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n       }\n-      some(node_stmt(stmt)) => {\n+      Some(node_stmt(stmt)) => {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(*stmt, itr), id)\n       }\n       // FIXMEs are as per #2410\n-      some(node_export(_, path)) => {\n+      Some(node_export(_, path)) => {\n         fmt!(\"export %s (id=%?)\", // add more info here\n              path_to_str(*path, itr), id)\n       }\n-      some(node_arg(_, _)) => { // add more info here\n+      Some(node_arg(_, _)) => { // add more info here\n         fmt!(\"arg (id=%?)\", id)\n       }\n-      some(node_local(_)) => { // add more info here\n+      Some(node_local(_)) => { // add more info here\n         fmt!(\"local (id=%?)\", id)\n       }\n-      some(node_ctor(*)) => { // add more info here\n+      Some(node_ctor(*)) => { // add more info here\n         fmt!(\"node_ctor (id=%?)\", id)\n       }\n-      some(node_dtor(*)) => { // add more info here\n+      Some(node_dtor(*)) => { // add more info here\n         fmt!(\"node_dtor (id=%?)\", id)\n       }\n-      some(node_block(_)) => {\n+      Some(node_block(_)) => {\n         fmt!(\"block\")\n       }\n     }"}, {"sha": "79df0767ca51674734253d51810ad771a8d28d54", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -15,7 +15,7 @@ pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n \n /* assuming that we're not in macro expansion */\n pure fn mk_sp(lo: uint, hi: uint) -> span {\n-    {lo: lo, hi: hi, expn_info: none}\n+    {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n@@ -93,19 +93,19 @@ pure fn binop_to_str(op: binop) -> ~str {\n     }\n }\n \n-pure fn binop_to_method_name(op: binop) -> option<~str> {\n+pure fn binop_to_method_name(op: binop) -> Option<~str> {\n     match op {\n-      add => return some(~\"add\"),\n-      subtract => return some(~\"sub\"),\n-      mul => return some(~\"mul\"),\n-      div => return some(~\"div\"),\n-      rem => return some(~\"modulo\"),\n-      bitxor => return some(~\"bitxor\"),\n-      bitand => return some(~\"bitand\"),\n-      bitor => return some(~\"bitor\"),\n-      shl => return some(~\"shl\"),\n-      shr => return some(~\"shr\"),\n-      and | or | eq | lt | le | ne | ge | gt => return none\n+      add => return Some(~\"add\"),\n+      subtract => return Some(~\"sub\"),\n+      mul => return Some(~\"mul\"),\n+      div => return Some(~\"div\"),\n+      rem => return Some(~\"modulo\"),\n+      bitxor => return Some(~\"bitxor\"),\n+      bitand => return Some(~\"bitand\"),\n+      bitor => return Some(~\"bitor\"),\n+      shl => return Some(~\"shl\"),\n+      shr => return Some(~\"shr\"),\n+      and | or | eq | lt | le | ne | ge | gt => return None\n     }\n }\n \n@@ -184,15 +184,15 @@ pure fn float_ty_to_str(t: float_ty) -> ~str {\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let mut local = false;\n-    let mut parent_enum : option<ident> = none;\n+    let mut parent_enum : Option<ident> = None;\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n         match it.node {\n           item_enum(enum_definition, _) =>\n             for enum_definition.variants.each |v| {\n                 if v.node.name == i {\n                     local = true;\n-                    parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n+                    parent_enum = Some(/* FIXME (#2543) */ copy it.ident);\n                 }\n             },\n           _ => ()\n@@ -209,7 +209,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                   ast::view_path_simple(id, _, _) => {\n                     if id == i { return true; }\n                     match parent_enum {\n-                      some(parent_enum_id) => {\n+                      Some(parent_enum_id) => {\n                         if id == parent_enum_id { return true; }\n                       }\n                       _ => ()\n@@ -270,30 +270,30 @@ fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = default_block(~[], option::some::<@expr>(e), e.id);\n+    let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);\n     return {node: blk_, span: e.span};\n }\n \n-fn default_block(+stmts1: ~[@stmt], expr1: option<@expr>, id1: node_id) ->\n+fn default_block(+stmts1: ~[@stmt], expr1: Option<@expr>, id1: node_id) ->\n    blk_ {\n     {view_items: ~[], stmts: stmts1,\n      expr: expr1, id: id1, rules: default_blk}\n }\n \n fn ident_to_path(s: span, +i: ident) -> @path {\n     @{span: s, global: false, idents: ~[i],\n-      rp: none, types: ~[]}\n+      rp: None, types: ~[]}\n }\n \n pure fn is_unguarded(&&a: arm) -> bool {\n     match a.guard {\n-      none => true,\n+      None => true,\n       _    => false\n     }\n }\n \n-pure fn unguarded_pat(a: arm) -> option<~[@pat]> {\n-    if is_unguarded(a) { some(/* FIXME (#2543) */ copy a.pats) } else { none }\n+pure fn unguarded_pat(a: arm) -> Option<~[@pat]> {\n+    if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n }\n \n fn public_methods(ms: ~[@method]) -> ~[@method] {\n@@ -583,10 +583,10 @@ pure fn is_item_impl(item: @ast::item) -> bool {\n fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n-      pat_ident(_, _, some(p)) => walk_pat(p, it),\n+      pat_ident(_, _, Some(p)) => walk_pat(p, it),\n       pat_rec(fields, _) | pat_struct(_, fields, _) =>\n         for fields.each |f| { walk_pat(f.pat, it) },\n-      pat_enum(_, some(s)) | pat_tup(s) => for s.each |p| {\n+      pat_enum(_, Some(s)) | pat_tup(s) => for s.each |p| {\n         walk_pat(p, it)\n       },\n       pat_box(s) | pat_uniq(s) => walk_pat(s, it),"}, {"sha": "70ca59bc1fc8b2bd4b1b5bf9e78384711a62a9ba", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -124,35 +124,35 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option<~str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n     match meta.node {\n         ast::meta_name_value(_, v) => match v.node {\n-            ast::lit_str(s) => option::some(*s),\n-            _ => option::none\n+            ast::lit_str(s) => option::Some(*s),\n+            _ => option::None\n         },\n-        _ => option::none\n+        _ => option::None\n     }\n }\n \n /// Gets a list of inner meta items from a list meta_item type\n-fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n+fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n     match meta.node {\n-      ast::meta_list(_, l) => option::some(/* FIXME (#2543) */ copy l),\n-      _ => option::none\n+      ast::meta_list(_, l) => option::Some(/* FIXME (#2543) */ copy l),\n+      _ => option::None\n     }\n }\n \n /**\n  * If the meta item is a nam-value type with a string value then returns\n  * a tuple containing the name and string value, otherwise `none`\n  */\n-fn get_name_value_str_pair(item: @ast::meta_item) -> option<(~str, ~str)> {\n+fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n     match attr::get_meta_item_value_str(item) {\n-      some(value) => {\n+      Some(value) => {\n         let name = attr::get_meta_item_name(item);\n-        some((name, value))\n+        Some((name, value))\n       }\n-      none => none\n+      None => None\n     }\n }\n \n@@ -163,10 +163,10 @@ fn get_name_value_str_pair(item: @ast::meta_item) -> option<(~str, ~str)> {\n fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n    ~[ast::attribute] {\n     let filter = (\n-        fn@(a: ast::attribute) -> option<ast::attribute> {\n+        fn@(a: ast::attribute) -> Option<ast::attribute> {\n             if get_attr_name(a) == name {\n-                option::some(a)\n-            } else { option::none }\n+                option::Some(a)\n+            } else { option::None }\n         }\n     );\n     return vec::filter_map(attrs, filter);\n@@ -175,10 +175,10 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n /// Searcha list of meta items and return only those with a specific name\n fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n-    let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n+    let filter = fn@(&&m: @ast::meta_item) -> Option<@ast::meta_item> {\n         if get_meta_item_name(m) == name {\n-            option::some(m)\n-        } else { option::none }\n+            option::Some(m)\n+        } else { option::None }\n     };\n     return vec::filter_map(metas, filter);\n }\n@@ -225,40 +225,40 @@ fn attrs_contains_name(attrs: ~[ast::attribute], name: ~str) -> bool {\n }\n \n fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n-    -> option<~str> {\n+    -> Option<~str> {\n \n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         return get_meta_item_value_str(attr_meta(mattrs[0]));\n     }\n-    return option::none;\n+    return option::None;\n }\n \n fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> option<@ast::meta_item> {\n+    -> Option<@ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> option<~str> {\n+    -> Option<~str> {\n \n     match last_meta_item_by_name(items, name) {\n-      some(item) => match attr::get_meta_item_value_str(item) {\n-        some(value) => some(value),\n-        none => none\n+      Some(item) => match attr::get_meta_item_value_str(item) {\n+        Some(value) => Some(value),\n+        None => None\n       },\n-      none => none\n+      None => None\n     }\n }\n \n fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> option<~[@ast::meta_item]> {\n+    -> Option<~[@ast::meta_item]> {\n \n     match last_meta_item_by_name(items, name) {\n-      some(item) => attr::get_meta_item_list(item),\n-      none => none\n+      Some(item) => attr::get_meta_item_list(item),\n+      None => None\n     }\n }\n \n@@ -290,9 +290,9 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n \n     return vec::filter_map(items, |item| {\n         if get_meta_item_name(item) != name {\n-            option::some(/* FIXME (#2543) */ copy item)\n+            option::Some(/* FIXME (#2543) */ copy item)\n         } else {\n-            option::none\n+            option::None\n         }\n     });\n }\n@@ -312,19 +312,19 @@ fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n \n fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n     return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n-      option::none => {\n+      option::None => {\n         either::Right(ast::foreign_abi_cdecl)\n       }\n-      option::some(~\"rust-intrinsic\") => {\n+      option::Some(~\"rust-intrinsic\") => {\n         either::Right(ast::foreign_abi_rust_intrinsic)\n       }\n-      option::some(~\"cdecl\") => {\n+      option::Some(~\"cdecl\") => {\n         either::Right(ast::foreign_abi_cdecl)\n       }\n-      option::some(~\"stdcall\") => {\n+      option::Some(~\"stdcall\") => {\n         either::Right(ast::foreign_abi_stdcall)\n       }\n-      option::some(t) => {\n+      option::Some(t) => {\n         either::Left(~\"unsupported abi: \" + t)\n       }\n     };"}, {"sha": "ed2e2589ab153fab07f7e31965d9d0c726e901b1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -121,15 +121,15 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n }\n \n fn lookup_char_pos_adj(map: codemap, pos: uint)\n-    -> {filename: ~str, line: uint, col: uint, file: option<filemap>}\n+    -> {filename: ~str, line: uint, col: uint, file: Option<filemap>}\n {\n     let loc = lookup_char_pos(map, pos);\n     match (loc.file.substr) {\n       fss_none => {\n         {filename: /* FIXME (#2543) */ copy loc.file.name,\n          line: loc.line,\n          col: loc.col,\n-         file: some(loc.file)}\n+         file: Some(loc.file)}\n       }\n       fss_internal(sp) => {\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n@@ -138,7 +138,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n         {filename: /* FIXME (#2543) */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n-         file: none}\n+         file: None}\n       }\n     }\n }\n@@ -158,9 +158,9 @@ fn adjust_span(map: codemap, sp: span) -> span {\n \n enum expn_info_ {\n     expanded_from({call_site: span,\n-                   callie: {name: ~str, span: option<span>}})\n+                   callie: {name: ~str, span: Option<span>}})\n }\n-type expn_info = option<@expn_info_>;\n+type expn_info = Option<@expn_info_>;\n type span = {lo: uint, hi: uint, expn_info: expn_info};\n \n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n@@ -197,8 +197,8 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end = match str::find_char_from(*fm.src, '\\n', begin) {\n-      some(e) => e,\n-      none => str::len(*fm.src)\n+      Some(e) => e,\n+      None => str::len(*fm.src)\n     };\n     str::slice(*fm.src, begin, end)\n }"}, {"sha": "11384078b4355bab21fdd031b391021527ca32d1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -9,7 +9,7 @@ export codemap_span_handler, codemap_handler;\n export ice_msg;\n export expect;\n \n-type emitter = fn@(cmsp: option<(codemap::codemap, span)>,\n+type emitter = fn@(cmsp: Option<(codemap::codemap, span)>,\n                    msg: ~str, lvl: level);\n \n \n@@ -33,7 +33,7 @@ trait handler {\n     fn note(msg: ~str);\n     fn bug(msg: ~str) -> !;\n     fn unimpl(msg: ~str) -> !;\n-    fn emit(cmsp: option<(codemap::codemap, span)>, msg: ~str, lvl: level);\n+    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: ~str, lvl: level);\n }\n \n type handler_t = @{\n@@ -48,18 +48,18 @@ type codemap_t = @{\n \n impl codemap_t: span_handler {\n     fn span_fatal(sp: span, msg: ~str) -> ! {\n-        self.handler.emit(some((self.cm, sp)), msg, fatal);\n+        self.handler.emit(Some((self.cm, sp)), msg, fatal);\n         fail;\n     }\n     fn span_err(sp: span, msg: ~str) {\n-        self.handler.emit(some((self.cm, sp)), msg, error);\n+        self.handler.emit(Some((self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n     fn span_warn(sp: span, msg: ~str) {\n-        self.handler.emit(some((self.cm, sp)), msg, warning);\n+        self.handler.emit(Some((self.cm, sp)), msg, warning);\n     }\n     fn span_note(sp: span, msg: ~str) {\n-        self.handler.emit(some((self.cm, sp)), msg, note);\n+        self.handler.emit(Some((self.cm, sp)), msg, note);\n     }\n     fn span_bug(sp: span, msg: ~str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n@@ -74,11 +74,11 @@ impl codemap_t: span_handler {\n \n impl handler_t: handler {\n     fn fatal(msg: ~str) -> ! {\n-        self.emit(none, msg, fatal);\n+        self.emit(None, msg, fatal);\n         fail;\n     }\n     fn err(msg: ~str) {\n-        self.emit(none, msg, error);\n+        self.emit(None, msg, error);\n         self.bump_err_count();\n     }\n     fn bump_err_count() {\n@@ -98,16 +98,16 @@ impl handler_t: handler {\n         self.fatal(s);\n     }\n     fn warn(msg: ~str) {\n-        self.emit(none, msg, warning);\n+        self.emit(None, msg, warning);\n     }\n     fn note(msg: ~str) {\n-        self.emit(none, msg, note);\n+        self.emit(None, msg, note);\n     }\n     fn bug(msg: ~str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n     fn unimpl(msg: ~str) -> ! { self.bug(~\"unimplemented \" + msg); }\n-    fn emit(cmsp: option<(codemap::codemap, span)>, msg: ~str, lvl: level) {\n+    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: ~str, lvl: level) {\n         self.emit(cmsp, msg, lvl);\n     }\n }\n@@ -120,12 +120,12 @@ fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n     @{ handler: handler, cm: cm } as span_handler\n }\n \n-fn mk_handler(emitter: option<emitter>) -> handler {\n+fn mk_handler(emitter: Option<emitter>) -> handler {\n \n     let emit = match emitter {\n-      some(e) => e,\n-      none => {\n-        let f = fn@(cmsp: option<(codemap::codemap, span)>,\n+      Some(e) => e,\n+      None => {\n+        let f = fn@(cmsp: Option<(codemap::codemap, span)>,\n             msg: ~str, t: level) {\n             emit(cmsp, msg, t);\n         };\n@@ -180,18 +180,18 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-fn emit(cmsp: option<(codemap::codemap, span)>,\n+fn emit(cmsp: Option<(codemap::codemap, span)>,\n         msg: ~str, lvl: level) {\n     match cmsp {\n-      some((cm, sp)) => {\n+      Some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);\n         let ss = codemap::span_to_str(sp, cm);\n         let lines = codemap::span_to_lines(sp, cm);\n         print_diagnostic(ss, lvl, msg);\n         highlight_lines(cm, sp, lines);\n         print_macro_backtrace(cm, sp);\n       }\n-      none => {\n+      None => {\n         print_diagnostic(~\"\", lvl, msg);\n       }\n     }\n@@ -265,9 +265,9 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n }\n \n fn expect<T: copy>(diag: span_handler,\n-                   opt: option<T>, msg: fn() -> ~str) -> T {\n+                   opt: Option<T>, msg: fn() -> ~str) -> T {\n     match opt {\n-       some(t) => t,\n-       none => diag.handler().bug(msg())\n+       Some(t) => t,\n+       None => diag.handler().bug(msg())\n     }\n }"}, {"sha": "bcbe5c8811019f328a13efa71eaa131c51b8e616", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -164,12 +164,12 @@ impl ext_ctxt: ext_ctxt_helpers {\n     }\n \n     fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: none, types: ~[]}\n+        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n     }\n \n     fn path_tps(span: span, strs: ~[ast::ident],\n                 tps: ~[@ast::ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: none, types: tps}\n+        @{span: span, global: false, idents: strs, rp: None, types: tps}\n     }\n \n     fn ty_path(span: span, strs: ~[ast::ident],\n@@ -215,7 +215,7 @@ impl ext_ctxt: ext_ctxt_helpers {\n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n         {node: {view_items: ~[],\n                 stmts: stmts,\n-                expr: none,\n+                expr: None,\n                 id: self.next_id(),\n                 rules: ast::default_blk},\n          span: span}\n@@ -224,19 +224,19 @@ impl ext_ctxt: ext_ctxt_helpers {\n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n         {node: {view_items: ~[],\n                 stmts: ~[],\n-                expr: some(expr),\n+                expr: Some(expr),\n                 id: self.next_id(),\n                 rules: ast::default_blk},\n          span: expr.span}\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n         let path = @{span: span, global: false, idents: ~[nm],\n-                     rp: none, types: ~[]};\n+                     rp: None, types: ~[]};\n         @{id: self.next_id(),\n           node: ast::pat_ident(ast::bind_by_implicit_ref,\n                                path,\n-                               none),\n+                               None),\n           span: span}\n     }\n \n@@ -374,7 +374,7 @@ fn ser_variant(cx: ext_ctxt,\n     let body_blk = cx.blk(span, stmts);\n     let body = cx.blk(span, ~[cx.stmt(bodyfn(s, body_blk))]);\n \n-    {pats: ~[pat], guard: none, body: body}\n+    {pats: ~[pat], guard: None, body: body}\n }\n \n fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n@@ -387,7 +387,7 @@ fn is_vec_or_str(ty: @ast::ty) -> bool {\n       ast::ty_vec(_) => true,\n       // This may be wrong if the user has shadowed (!) str\n       ast::ty_path(@{span: _, global: _, idents: ids,\n-                             rp: none, types: _}, _)\n+                             rp: None, types: _}, _)\n       if ids == ~[parse::token::special_idents::str] => true,\n       _ => false\n     }\n@@ -493,8 +493,8 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             let ident = path.idents[0];\n \n             match tps.find(ident) {\n-              some(f) => f(v),\n-              none => ser_path(cx, tps, path, s, v)\n+              Some(f) => f(v),\n+              None => ser_path(cx, tps, path, s, v)\n             }\n         } else {\n             ser_path(cx, tps, path, s, v)\n@@ -684,7 +684,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n                     expr: #ast{ $(d).read_rec_field($(f), $(i), $(l))} },\n              span: fld.span}\n         };\n-        let fld_expr = cx.expr(ty.span, ast::expr_rec(fields, none));\n+        let fld_expr = cx.expr(ty.span, ast::expr_rec(fields, None));\n         let fld_lambda = cx.lambda(cx.expr_blk(fld_expr));\n         #ast{ $(d).read_rec($(fld_lambda)) }\n       }\n@@ -720,8 +720,8 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n             let ident = path.idents[0];\n \n             match tps.find(ident) {\n-              some(f) => f(),\n-              none => deser_path(cx, tps, path, d)\n+              Some(f) => f(),\n+              None => deser_path(cx, tps, path, d)\n             }\n         } else {\n             deser_path(cx, tps, path, d)\n@@ -850,10 +850,10 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n                         if vec::is_empty(pats) {\n                             ast::pat_ident(ast::bind_by_implicit_ref,\n                                            cx.path(v_span, ~[v_name]),\n-                                           none)\n+                                           None)\n                         } else {\n                             ast::pat_enum(cx.path(v_span, ~[v_name]),\n-                                                  some(pats))\n+                                                  Some(pats))\n                         }\n                     },\n \n@@ -928,17 +928,17 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n         {pats: ~[@{id: cx.next_id(),\n                   node: ast::pat_lit(cx.lit_uint(v_span, vidx)),\n                   span: v_span}],\n-         guard: none,\n+         guard: None,\n          body: cx.expr_blk(body)}\n     };\n \n     let impossible_case = {pats: ~[@{id: cx.next_id(),\n                                      node: ast::pat_wild,\n                                      span: e_span}],\n-                        guard: none,\n+                        guard: None,\n                         // FIXME #3198: proper error message\n                            body: cx.expr_blk(cx.expr(e_span,\n-                                                     ast::expr_fail(none)))};\n+                                                     ast::expr_fail(None)))};\n     arms += ~[impossible_case];\n \n     // Generate code like:"}, {"sha": "7a3eb4b67e93bcd0b43ef64e3fdb71cc98302f2f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -21,7 +21,7 @@ import std::map::str_hash;\n type syntax_expander_ =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> @ast::expr;\n // second argument is the origin of the macro, if user-defined\n-type syntax_expander = {expander: syntax_expander_, span: option<span>};\n+type syntax_expander = {expander: syntax_expander_, span: Option<span>};\n \n type macro_def = {name: ~str, ext: syntax_extension};\n \n@@ -32,12 +32,12 @@ type macro_definer =\n type item_decorator =\n     fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n-type syntax_expander_tt = {expander: syntax_expander_tt_, span: option<span>};\n+type syntax_expander_tt = {expander: syntax_expander_tt_, span: Option<span>};\n type syntax_expander_tt_ = fn@(ext_ctxt, span, ~[ast::token_tree])\n     -> mac_result;\n \n type syntax_expander_tt_item\n-    = {expander: syntax_expander_tt_item_, span: option<span>};\n+    = {expander: syntax_expander_tt_item_, span: Option<span>};\n type syntax_expander_tt_item_\n     = fn@(ext_ctxt, span, ast::ident, ~[ast::token_tree]) -> mac_result;\n \n@@ -67,12 +67,12 @@ enum syntax_extension {\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap<~str, syntax_extension> {\n     fn builtin(f: syntax_expander_) -> syntax_extension\n-        {normal({expander: f, span: none})}\n+        {normal({expander: f, span: None})}\n     fn builtin_expr_tt(f: syntax_expander_tt_) -> syntax_extension {\n-        expr_tt({expander: f, span: none})\n+        expr_tt({expander: f, span: None})\n     }\n     fn builtin_item_tt(f: syntax_expander_tt_item_) -> syntax_extension {\n-        item_tt({expander: f, span: none})\n+        item_tt({expander: f, span: None})\n     }\n     let syntax_expanders = str_hash::<syntax_extension>();\n     syntax_expanders.insert(~\"macro\",\n@@ -166,7 +166,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n             match ei {\n               expanded_from({call_site: cs, callie: callie}) => {\n                 self.backtrace =\n-                    some(@expanded_from({\n+                    Some(@expanded_from({\n                         call_site: {lo: cs.lo, hi: cs.hi,\n                                     expn_info: self.backtrace},\n                         callie: callie}));\n@@ -175,7 +175,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         }\n         fn bt_pop() {\n             match self.backtrace {\n-              some(@expanded_from({call_site: {expn_info: prev, _}, _})) => {\n+              Some(@expanded_from({call_site: {expn_info: prev, _}, _})) => {\n                 self.backtrace = prev\n               }\n               _ => self.bug(~\"tried to pop without a push\")\n@@ -225,7 +225,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n     let imp : ctxt_repr = {\n         parse_sess: parse_sess,\n         cfg: cfg,\n-        mut backtrace: none,\n+        mut backtrace: None,\n         mut mod_path: ~[],\n         mut trace_mac: false\n     };\n@@ -255,22 +255,22 @@ fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n \n fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                        min: uint, name: ~str) -> ~[@ast::expr] {\n-    return get_mac_args(cx, sp, arg, min, none, name);\n+    return get_mac_args(cx, sp, arg, min, None, name);\n }\n \n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                min: uint, max: option<uint>, name: ~str) -> ~[@ast::expr] {\n+                min: uint, max: Option<uint>, name: ~str) -> ~[@ast::expr] {\n     match arg {\n-      some(expr) => match expr.node {\n+      Some(expr) => match expr.node {\n         ast::expr_vec(elts, _) => {\n             let elts_len = vec::len(elts);\n               match max {\n-                some(max) if ! (min <= elts_len && elts_len <= max) => {\n+                Some(max) if ! (min <= elts_len && elts_len <= max) => {\n                   cx.span_fatal(sp,\n                                 fmt!(\"#%s takes between %u and %u arguments.\",\n                                      name, min, max));\n                 }\n-                none if ! (min <= elts_len) => {\n+                None if ! (min <= elts_len) => {\n                   cx.span_fatal(sp, fmt!(\"#%s needs at least %u arguments.\",\n                                          name, min));\n                 }\n@@ -281,16 +281,16 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n             cx.span_fatal(sp, fmt!(\"#%s: malformed invocation\", name))\n         }\n       },\n-      none => cx.span_fatal(sp, fmt!(\"#%s: missing arguments\", name))\n+      None => cx.span_fatal(sp, fmt!(\"#%s: missing arguments\", name))\n     }\n }\n \n fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n     -> ast::mac_body_\n {\n     match (args) {\n-      some(body) => body,\n-      none => cx.span_fatal(sp, ~\"missing macro body\")\n+      Some(body) => body,\n+      None => cx.span_fatal(sp, ~\"missing macro body\")\n     }\n }\n \n@@ -306,16 +306,16 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n \n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        {node: m, span: {lo: 0u, hi: 0u, expn_info: none}}\n+        {node: m, span: {lo: 0u, hi: 0u, expn_info: None}}\n     }\n     let arg_nm = cx.parse_sess().interner.gensym(@~\"arg\");\n \n     let argument_gram = ~[ms(match_seq(~[\n         ms(match_nonterminal(arg_nm, parse::token::special_idents::expr, 0u))\n-    ], some(parse::token::COMMA), true, 0u, 1u))];\n+    ], Some(parse::token::COMMA), true, 0u, 1u))];\n \n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, none, arg);\n+                                   cx.parse_sess().interner, None, arg);\n     let args =\n         match parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n                           argument_gram).get(arg_nm) {\n@@ -331,7 +331,7 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n           _ => fail ~\"badly-structured parse result\"\n         };\n \n-    return some(@{id: parse::next_node_id(cx.parse_sess()),\n+    return Some(@{id: parse::next_node_id(cx.parse_sess()),\n                callee_id: parse::next_node_id(cx.parse_sess()),\n                node: ast::expr_vec(args, ast::m_imm), span: sp});\n }"}, {"sha": "2207dee09c617e3b7fa85b23be2efd953adf7492", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -37,7 +37,7 @@ fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) ->\n     @ast::expr {\n     let path = @{span: sp, global: false, idents: idents,\n-                 rp: none, types: ~[]};\n+                 rp: None, types: ~[]};\n     let pathexpr = ast::expr_path(path);\n     mk_expr(cx, sp, pathexpr)\n }\n@@ -75,7 +75,7 @@ fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n }\n fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n    @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::vstore_fixed(none))\n+    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::vstore_fixed(None))\n }\n fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n@@ -96,7 +96,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n             {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n         vec::push(astfields, astfield);\n     }\n-    let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n+    let recexpr = ast::expr_rec(astfields, option::None::<@ast::expr>);\n     mk_expr(cx, sp, recexpr)\n }\n "}, {"sha": "4e344d626263abad53df91be331a0e91476977a0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -13,6 +13,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     return @{id: cx.next_id(),\n           callee_id: cx.next_id(),\n           node: ast::expr_path(@{span: sp, global: false, idents: ~[res],\n-                                 rp: none, types: ~[]}),\n+                                 rp: None, types: ~[]}),\n           span: sp};\n }"}, {"sha": "9720eb7d4ce6cbc866f95108932408dcf0a54067", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -10,15 +10,15 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"env\");\n+    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"env\");\n \n     // FIXME (#2248): if this was more thorough it would manufacture an\n-    // option<str> rather than just an maybe-empty string.\n+    // Option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n     match os::getenv(var) {\n-      option::none => return mk_uniq_str(cx, sp, ~\"\"),\n-      option::some(s) => return mk_uniq_str(cx, sp, s)\n+      option::None => return mk_uniq_str(cx, sp, ~\"\"),\n+      option::Some(s) => return mk_uniq_str(cx, sp, s)\n     }\n }\n "}, {"sha": "366207ee4275eea605c8c02bd4e95aa827c33f8c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -29,16 +29,16 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n                 match exts.find(*extname) {\n-                  none => {\n+                  None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n-                  some(item_decorator(_)) => {\n+                  Some(item_decorator(_)) => {\n                     cx.span_fatal(\n                         pth.span,\n                         fmt!(\"%s can only be used as a decorator\", *extname));\n                   }\n-                  some(normal({expander: exp, span: exp_sp})) => {\n+                  Some(normal({expander: exp, span: exp_sp})) => {\n                     let expanded = exp(cx, mac.span, args, body);\n \n                     cx.bt_push(expanded_from({call_site: s,\n@@ -49,17 +49,17 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  some(macro_defining(ext)) => {\n+                  Some(macro_defining(ext)) => {\n                     let named_extension = ext(cx, mac.span, args, body);\n                     exts.insert(named_extension.name, named_extension.ext);\n-                    (ast::expr_rec(~[], none), s)\n+                    (ast::expr_rec(~[], None), s)\n                   }\n-                  some(expr_tt(_)) => {\n+                  Some(expr_tt(_)) => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"this tt-style macro should be \\\n                                         invoked '%s!(...)'\", *extname))\n                   }\n-                  some(item_tt(*)) => {\n+                  Some(item_tt(*)) => {\n                     cx.span_fatal(pth.span,\n                                   ~\"cannot use item macros in this context\");\n                   }\n@@ -74,11 +74,11 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n                 match exts.find(*extname) {\n-                  none => {\n+                  None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n-                  some(expr_tt({expander: exp, span: exp_sp})) => {\n+                  Some(expr_tt({expander: exp, span: exp_sp})) => {\n                     let expanded = match exp(cx, mac.span, tts) {\n                       mr_expr(e) => e,\n                       _ => cx.span_fatal(\n@@ -94,11 +94,11 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  some(normal({expander: exp, span: exp_sp})) => {\n+                  Some(normal({expander: exp, span: exp_sp})) => {\n                     //convert the new-style invoc for the old-style macro\n                     let arg = base::tt_args_to_original_flavor(cx, pth.span,\n                                                                tts);\n-                    let expanded = exp(cx, mac.span, arg, none);\n+                    let expanded = exp(cx, mac.span, arg, None);\n \n                     cx.bt_push(expanded_from({call_site: s,\n                                 callie: {name: *extname, span: exp_sp}}));\n@@ -151,9 +151,9 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_list(n, _) => n\n             };\n             match exts.find(mname) {\n-              none | some(normal(_)) | some(macro_defining(_))\n-              | some(expr_tt(_)) | some(item_tt(*)) => items,\n-              some(item_decorator(dec_fn)) => {\n+              None | Some(normal(_)) | Some(macro_defining(_))\n+              | Some(expr_tt(_)) | Some(item_tt(*)) => items,\n+              Some(item_decorator(dec_fn)) => {\n                 dec_fn(cx, attr.span, attr.node.value, items)\n               }\n             }\n@@ -167,26 +167,26 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n // When we enter a module, record it, for the sake of `module!`\n fn expand_item(exts: hashmap<~str, syntax_extension>,\n                cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n-               orig: fn@(&&@ast::item, ast_fold) -> option<@ast::item>)\n-    -> option<@ast::item>\n+               orig: fn@(&&@ast::item, ast_fold) -> Option<@ast::item>)\n+    -> Option<@ast::item>\n {\n     let is_mod = match it.node {\n       ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n       _ => false\n     };\n     let maybe_it = match it.node {\n       ast::item_mac(*) => expand_item_mac(exts, cx, it, fld),\n-      _ => some(it)\n+      _ => Some(it)\n     };\n \n     match maybe_it {\n-      some(it) => {\n+      Some(it) => {\n         if is_mod { cx.mod_push(it.ident); }\n         let ret_val = orig(it, fld);\n         if is_mod { cx.mod_pop(); }\n         return ret_val;\n       }\n-      none => return none\n+      None => return None\n     }\n }\n \n@@ -195,16 +195,16 @@ fn expand_item(exts: hashmap<~str, syntax_extension>,\n // logic as for expression-position macro invocations.\n fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n-                   fld: ast_fold) -> option<@ast::item> {\n+                   fld: ast_fold) -> Option<@ast::item> {\n     match it.node {\n       item_mac({node: mac_invoc_tt(pth, tts), span}) => {\n         let extname = cx.parse_sess().interner.get(pth.idents[0]);\n         match exts.find(*extname) {\n-          none => {\n+          None => {\n             cx.span_fatal(pth.span,\n                           fmt!(\"macro undefined: '%s'\", *extname))\n           }\n-          some(item_tt(expand)) => {\n+          Some(item_tt(expand)) => {\n             let expanded = expand.expander(cx, it.span, it.ident, tts);\n             cx.bt_push(expanded_from({call_site: it.span,\n                                       callie: {name: *extname,\n@@ -216,7 +216,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                                          *extname),\n               mr_def(mdef) => {\n                 exts.insert(mdef.name, mdef.ext);\n-                none\n+                None\n               }\n             };\n             cx.bt_pop();"}, {"sha": "829e16e399201968ec1a03012701d6e367a9fa9f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -135,7 +135,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         let unsupported = ~\"conversion not supported in #fmt string\";\n         match cnv.param {\n-          option::none => (),\n+          option::None => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n         for cnv.flags.each |f| {\n@@ -192,7 +192,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     }\n     fn log_conv(c: conv) {\n         match c.param {\n-          some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n+          Some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n           _ => debug!(\"param: none\")\n         }\n         for c.flags.each |f| {"}, {"sha": "cc083643fc9b4953af76e06688ee1c505168215a", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -4,7 +4,7 @@ import option;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"ident_to_str\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"ident_to_str\");\n \n     return mk_uniq_str(cx, sp, *cx.parse_sess().interner.get(\n         expr_to_ident(cx, args[0u], ~\"expected an ident\")));"}, {"sha": "88e11f375135eb587a9a46dc136019d7cd8a53d3", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -10,5 +10,5 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, tt: ~[ast::token_tree])\n \n     //trivial expression\n     return mr_expr(@{id: cx.next_id(), callee_id: cx.next_id(),\n-                     node: ast::expr_rec(~[], option::none), span: sp});\n+                     node: ast::expr_rec(~[], option::None), span: sp});\n }"}, {"sha": "2e9125d6c2287ca0484ae2c9d44abef6594ebc64", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -50,7 +50,7 @@ fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, none, tt);\n+                               cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n "}, {"sha": "d0a5757ed1f7df70185aec8f82b751db04c8e9ce", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -19,12 +19,12 @@ fn path(ids: ~[ident], span: span) -> @ast::path {\n     @{span: span,\n       global: false,\n       idents: ids,\n-      rp: none,\n+      rp: None,\n       types: ~[]}\n }\n \n fn empty_span() -> span {\n-    {lo: 0, hi: 0, expn_info: none}\n+    {lo: 0, hi: 0, expn_info: None}\n }\n \n trait append_types {\n@@ -90,7 +90,7 @@ trait ext_ctxt_ast_builder {\n \n impl ext_ctxt: ext_ctxt_ast_builder {\n     fn ty_option(ty: @ast::ty) -> @ast::ty {\n-        self.ty_path_ast_builder(path(~[self.ident_of(~\"option\")],\n+        self.ty_path_ast_builder(path(~[self.ident_of(~\"Option\")],\n                                       self.empty_span())\n                                  .add_ty(ty))\n     }\n@@ -125,9 +125,9 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                             node: ast::pat_ident(ast::bind_by_implicit_ref,\n                                                  path(~[ident],\n                                                       self.empty_span()),\n-                                                 none),\n+                                                 None),\n                             span: self.empty_span()},\n-                     init: some({op: ast::init_move,\n+                     init: Some({op: ast::init_move,\n                                  expr: e}),\n                      id: self.next_id()},\n               span: self.empty_span()}]),\n@@ -143,7 +143,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n         @{id: self.next_id(),\n           callee_id: self.next_id(),\n-          node: ast::expr_rec(fields, none),\n+          node: ast::expr_rec(fields, None),\n           span: self.empty_span()}\n     }\n \n@@ -187,7 +187,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = {view_items: ~[],\n                    stmts: stmts,\n-                   expr: some(e),\n+                   expr: Some(e),\n                    id: self.next_id(),\n                    rules: ast::default_blk};\n \n@@ -258,7 +258,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                 attrs: ~[],\n                 kind: ast::tuple_variant_kind(args),\n                 id: self.next_id(),\n-                disr_expr: none,\n+                disr_expr: None,\n                 vis: ast::public},\n          span: span}\n     }"}, {"sha": "3468754b6f8a5c8b770fa9dec21e0a5ec9d59d74", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -41,7 +41,7 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n     fn visit_message(name: ~str, _span: span, _tys: &[@ast::ty],\n                      this: state, next: next_state) {\n         match next {\n-          some({state: next, tys: next_tys}) => {\n+          Some({state: next, tys: next_tys}) => {\n             let proto = this.proto;\n             if !proto.has_state(next) {\n                 // This should be a span fatal, but then we need to\n@@ -65,7 +65,7 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n                 }\n             }\n           }\n-          none => ()\n+          None => ()\n         }\n     }\n }\n\\ No newline at end of file"}, {"sha": "70a2af466259fb822d41837f38d390efcf85d6b7", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -82,10 +82,10 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         //                   *proto.name,\n         //                   states));\n \n-        proto.bounded = some(false);\n+        proto.bounded = Some(false);\n     }\n     else {\n         debug!(\"protocol %s is bounded. yay!\", proto.name);\n-        proto.bounded = some(true);\n+        proto.bounded = Some(true);\n     }\n }\n\\ No newline at end of file"}, {"sha": "c6562b068f3088675986a38e3ccf1b6508308f71", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -15,7 +15,7 @@ impl parser: proto_parser {\n         let proto = protocol(id, self.span);\n \n         self.parse_seq_to_before_end(token::EOF,\n-                                     {sep: none, trailing_sep_allowed: false},\n+                                     {sep: None, trailing_sep_allowed: false},\n                                      |self| self.parse_state(proto));\n \n         return proto;\n@@ -47,7 +47,7 @@ impl parser: proto_parser {\n         // parse the messages\n         self.parse_unspanned_seq(\n             token::LBRACE, token::RBRACE,\n-            {sep: some(token::COMMA), trailing_sep_allowed: true},\n+            {sep: Some(token::COMMA), trailing_sep_allowed: true},\n             |self| self.parse_message(state));\n     }\n \n@@ -57,7 +57,7 @@ impl parser: proto_parser {\n         let args = if self.token == token::LPAREN {\n             self.parse_unspanned_seq(token::LPAREN,\n                                      token::RPAREN,\n-                                     {sep: some(token::COMMA),\n+                                     {sep: Some(token::COMMA),\n                                       trailing_sep_allowed: true},\n                                      |p| p.parse_ty(false))\n         }\n@@ -71,17 +71,17 @@ impl parser: proto_parser {\n             let ntys = if self.token == token::LT {\n                 self.parse_unspanned_seq(token::LT,\n                                          token::GT,\n-                                         {sep: some(token::COMMA),\n+                                         {sep: Some(token::COMMA),\n                                           trailing_sep_allowed: true},\n                                          |p| p.parse_ty(false))\n             }\n             else { ~[] };\n-            some({state: name, tys: ntys})\n+            Some({state: name, tys: ntys})\n           }\n           token::NOT => {\n             // -> !\n             self.bump();\n-            none\n+            None\n           }\n           _ => self.fatal(~\"invalid next state\")\n         };"}, {"sha": "f527d9f79f30606fd5a71e8c6bcaad98a86f920b", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -42,7 +42,7 @@ impl message: gen_send {\n         debug!(\"pipec: gen_send\");\n         match self {\n           message(_id, span, tys, this,\n-                  some({state: next, tys: next_tys})) => {\n+                  Some({state: next, tys: next_tys})) => {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n@@ -126,7 +126,7 @@ impl message: gen_send {\n                             cx.expr_block(body))\n           }\n \n-            message(_id, span, tys, this, none) => {\n+            message(_id, span, tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n@@ -207,7 +207,7 @@ impl state: to_type_decls {\n             let message(name, span, tys, this, next) = m;\n \n             let tys = match next {\n-              some({state: next, tys: next_tys}) => {\n+              Some({state: next, tys: next_tys}) => {\n                 let next = this.proto.get_state(next);\n                 let next_name = cx.str_of(next.data_name());\n \n@@ -222,7 +222,7 @@ impl state: to_type_decls {\n                                            cx.ident_of(next_name)], span)\n                                     .add_tys(next_tys)))\n               }\n-              none => tys\n+              None => tys\n             };\n \n             let v = cx.variant(cx.ident_of(name), span, tys);\n@@ -233,7 +233,7 @@ impl state: to_type_decls {\n         ~[cx.item_enum_poly(name,\n                             self.span,\n                             ast::enum_def({ variants: items_msg,\n-                                            common: none }),\n+                                            common: None }),\n                             self.ty_params)]\n     }\n \n@@ -368,7 +368,7 @@ impl protocol: gen_init {\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  none => vec::push(params, tp),\n+                  None => vec::push(params, tp),\n                   _ => ()\n                 }\n             }\n@@ -384,7 +384,7 @@ impl protocol: gen_init {\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  none => vec::push(params, tp),\n+                  None => vec::push(params, tp),\n                   _ => ()\n                 }\n             }\n@@ -488,8 +488,8 @@ impl ext_ctxt: ext_ctxt_parse_utils {\n             ~[],\n             self.parse_sess());\n         match res {\n-          some(ast) => ast,\n-          none => {\n+          Some(ast) => ast,\n+          None => {\n             error!(\"Parse error with ```\\n%s\\n```\", s);\n             fail\n           }"}, {"sha": "7f9b9acd8e27a4a0adcf738b229ad539f534372a", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -25,7 +25,7 @@ impl direction {\n     }\n }\n \n-type next_state = option<{state: ~str, tys: ~[@ast::ty]}>;\n+type next_state = Option<{state: ~str, tys: ~[@ast::ty]}>;\n \n enum message {\n     // name, span, data, current state, next state\n@@ -93,7 +93,7 @@ impl state {\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n             match m {\n-              message(_, _, _, _, some({state: id, _})) => {\n+              message(_, _, _, _, Some({state: id, _})) => {\n                 let state = self.proto.get_state(id);\n                 if !f(state) { break }\n               }\n@@ -114,13 +114,13 @@ struct protocol_ {\n     let span: span;\n     let states: DVec<state>;\n \n-    let mut bounded: option<bool>;\n+    let mut bounded: Option<bool>;\n \n     new(name: ~str, span: span) {\n         self.name = name;\n         self.span = span;\n         self.states = dvec();\n-        self.bounded = none;\n+        self.bounded = None;\n     }\n \n     /// Get a state.\n@@ -131,7 +131,7 @@ struct protocol_ {\n     fn get_state_by_id(id: uint) -> state { self.states[id] }\n \n     fn has_state(name: ~str) -> bool {\n-        self.states.find(|i| i.name == name) != none\n+        self.states.find(|i| i.name == name) != None\n     }\n \n     fn filename() -> ~str {"}, {"sha": "38108861b47908db8c7fbdb9f4303268424033f9", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -38,15 +38,15 @@ fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n trait qq_helper {\n     fn span() -> span;\n     fn visit(aq_ctxt, vt<aq_ctxt>);\n-    fn extract_mac() -> option<ast::mac_>;\n+    fn extract_mac() -> Option<ast::mac_>;\n     fn mk_parse_fn(ext_ctxt,span) -> @ast::expr;\n     fn get_fold_fn() -> ~str;\n }\n \n impl @ast::crate: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {fail}\n+    fn extract_mac() -> Option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_crate\"]))\n@@ -56,10 +56,10 @@ impl @ast::crate: qq_helper {\n impl @ast::expr: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {\n+    fn extract_mac() -> Option<ast::mac_> {\n         match (self.node) {\n-          ast::expr_mac({node: mac, _}) => some(mac),\n-          _ => none\n+          ast::expr_mac({node: mac, _}) => Some(mac),\n+          _ => None\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n@@ -71,10 +71,10 @@ impl @ast::expr: qq_helper {\n impl @ast::ty: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {\n+    fn extract_mac() -> Option<ast::mac_> {\n         match (self.node) {\n-          ast::ty_mac({node: mac, _}) => some(mac),\n-          _ => none\n+          ast::ty_mac({node: mac, _}) => Some(mac),\n+          _ => None\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n@@ -86,7 +86,7 @@ impl @ast::ty: qq_helper {\n impl @ast::item: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {fail}\n+    fn extract_mac() -> Option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_item\"]))\n@@ -96,7 +96,7 @@ impl @ast::item: qq_helper {\n impl @ast::stmt: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {fail}\n+    fn extract_mac() -> Option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_stmt\"]))\n@@ -106,7 +106,7 @@ impl @ast::stmt: qq_helper {\n impl @ast::pat: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n-    fn extract_mac() -> option<ast::mac_> {fail}\n+    fn extract_mac() -> Option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp, ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n                                       ~\"parse_pat\"]))\n@@ -135,7 +135,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n {\n     match (node.extract_mac()) {\n-      some(mac_aq(sp, e)) => {\n+      Some(mac_aq(sp, e)) => {\n         cx.gather.push(gather_item {\n             lo: sp.lo - cx.lo,\n             hi: sp.hi - cx.lo,\n@@ -194,8 +194,8 @@ fn parse_pat(p: parser) -> @ast::pat { p.parse_pat(true) }\n \n fn parse_item(p: parser) -> @ast::item {\n     match p.parse_item(~[]) {\n-      some(item) => item,\n-      none       => fail ~\"parse_item: parsing an item failed\"\n+      Some(item) => item,\n+      None       => fail ~\"parse_item: parsing an item failed\"\n     }\n }\n "}, {"sha": "ee65d81974e2582181420f6d72ee497b5f29cc53", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -11,11 +11,11 @@ import ast::{ident, path, ty, blk_, expr, expr_path,\n \n export add_new_extension;\n \n-fn path_to_ident(pth: @path) -> option<ident> {\n+fn path_to_ident(pth: @path) -> Option<ident> {\n     if vec::len(pth.idents) == 1u && vec::len(pth.types) == 0u {\n-        return some(pth.idents[0u]);\n+        return Some(pth.idents[0u]);\n     }\n-    return none;\n+    return None;\n }\n \n //a vec of binders might be a little big.\n@@ -57,23 +57,23 @@ fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n // If we want better match failure error messages (like in Fortifying Syntax),\n // we'll want to return something indicating amount of progress and location\n // of failure instead of `none`.\n-type match_result = option<arb_depth<matchable>>;\n+type match_result = Option<arb_depth<matchable>>;\n type selector = fn@(matchable) -> match_result;\n \n fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n-   {pre: ~[@expr], rep: option<@expr>, post: ~[@expr]} {\n+   {pre: ~[@expr], rep: Option<@expr>, post: ~[@expr]} {\n     let mut idx: uint = 0u;\n-    let mut res = none;\n+    let mut res = None;\n     for elts.each |elt| {\n         match elt.node {\n           expr_mac(m) => match m.node {\n             ast::mac_ellipsis => {\n-                if res != none {\n+                if res != None {\n                     cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n-                    some({pre: vec::slice(elts, 0u, idx - 1u),\n-                          rep: some(elts[idx - 1u]),\n+                    Some({pre: vec::slice(elts, 0u, idx - 1u),\n+                          rep: Some(elts[idx - 1u]),\n                           post: vec::slice(elts, idx + 1u, vec::len(elts))});\n             }\n             _ => ()\n@@ -83,38 +83,38 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n         idx += 1u;\n     }\n     return match res {\n-          some(val) => val,\n-          none => {pre: elts, rep: none, post: ~[]}\n+          Some(val) => val,\n+          None => {pre: elts, rep: None, post: ~[]}\n     }\n }\n \n-fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n-   option<~[U]> {\n+fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n+   Option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {\n         match f(elem) {\n-          none => return none,\n-          some(fv) => vec::push(res, fv)\n+          None => return None,\n+          Some(fv) => vec::push(res, fv)\n         }\n     }\n-    return some(res);\n+    return Some(res);\n }\n \n fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     match ad {\n       leaf(x) => return f(x),\n       seq(ads, span) => match option_flatten_map(|x| a_d_map(x, f), *ads) {\n-        none => return none,\n-        some(ts) => return some(seq(@ts, span))\n+        None => return None,\n+        Some(ts) => return Some(seq(@ts, span))\n       }\n     }\n }\n \n fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n         return match s1(m) {\n-              none => none,\n-              some(matches) => a_d_map(matches, s2)\n+              None => None,\n+              Some(matches) => a_d_map(matches, s2)\n             }\n     }\n     return { |x| scomp(s1, s2, x) };\n@@ -140,7 +140,7 @@ fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n     fn trivial_selector(m: matchable) -> match_result {\n-        return some(leaf(m));\n+        return Some(leaf(m));\n     }\n     p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n     return res;\n@@ -152,22 +152,22 @@ fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n-fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n+fn use_selectors_to_bind(b: binders, e: @expr) -> Option<bindings> {\n     let res = uint_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n-        match sel(match_expr(e)) { none => return none, _ => () }\n+        match sel(match_expr(e)) { None => return None, _ => () }\n     }\n     let mut never_mind: bool = false;\n     for b.real_binders.each |key, val| {\n         match val(match_expr(e)) {\n-          none => never_mind = true,\n-          some(mtc) => { res.insert(key, mtc); }\n+          None => never_mind = true,\n+          Some(mtc) => { res.insert(key, mtc); }\n         }\n     };\n     //HACK: `ret` doesn't work in `for each`\n-    if never_mind { return none; }\n-    return some(res);\n+    if never_mind { return None; }\n+    return Some(res);\n }\n \n /* use the bindings on the body to generate the expanded code */\n@@ -217,18 +217,18 @@ pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n     return res;\n }\n \n-fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n-                    idx_path: @mut ~[uint]) -> option<matchable> {\n+fn follow_for_trans(cx: ext_ctxt, mmaybe: Option<arb_depth<matchable>>,\n+                    idx_path: @mut ~[uint]) -> Option<matchable> {\n     match mmaybe {\n-      none => return none,\n-      some(m) => {\n+      None => return None,\n+      Some(m) => {\n         return match follow(m, *idx_path) {\n               seq(_, sp) => {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n                                   ~\"used that way.\")\n               }\n-              leaf(m) => return some(m)\n+              leaf(m) => return Some(m)\n             }\n       }\n     }\n@@ -268,9 +268,9 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n       {pre: pre, rep: repeat_me_maybe, post: post} => {\n         let mut res = vec::map(pre, recur);\n         match repeat_me_maybe {\n-          none => (),\n-          some(repeat_me) => {\n-            let mut repeat: option<{rep_count: uint, name: ident}> = none;\n+          None => (),\n+          Some(repeat_me) => {\n+            let mut repeat: Option<{rep_count: uint, name: ident}> = None;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             do free_vars(b, repeat_me) |fv| {\n@@ -280,10 +280,10 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                   leaf(_) => (),\n                   seq(ms, _) => {\n                     match repeat {\n-                      none => {\n-                        repeat = some({rep_count: vec::len(*ms), name: fv});\n+                      None => {\n+                        repeat = Some({rep_count: vec::len(*ms), name: fv});\n                       }\n-                      some({rep_count: old_len, name: old_name}) => {\n+                      Some({rep_count: old_len, name: old_name}) => {\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg = wrong_occurs(cx, fv, len,\n@@ -296,12 +296,12 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                 }\n             };\n             match repeat {\n-              none => {\n+              None => {\n                 cx.span_fatal(repeat_me.span,\n                               ~\"'...' surrounds an expression without any\" +\n                                   ~\" repeating syntax variables\");\n               }\n-              some({rep_count: rc, _}) => {\n+              Some({rep_count: rc, _}) => {\n                 /* Whew, we now know how how many times to repeat */\n                 let mut idx: uint = 0u;\n                 while idx < rc {\n@@ -326,9 +326,9 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n     return match follow_for_trans(cx, b.find(i), idx_path) {\n-          some(match_ident(a_id)) => a_id.node,\n-          some(m) => match_error(cx, m, ~\"an identifier\"),\n-          none => i\n+          Some(match_ident(a_id)) => a_id.node,\n+          Some(m) => match_error(cx, m, ~\"an identifier\"),\n+          None => i\n         }\n }\n \n@@ -338,13 +338,13 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n     match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-      some(match_ident(id)) => {\n+      Some(match_ident(id)) => {\n         {span: id.span, global: false, idents: ~[id.node],\n-         rp: none, types: ~[]}\n+         rp: None, types: ~[]}\n       }\n-      some(match_path(a_pth)) => *a_pth,\n-      some(m) => match_error(cx, m, ~\"a path\"),\n-      none => p\n+      Some(match_path(a_pth)) => *a_pth,\n+      Some(m) => match_error(cx, m, ~\"a path\"),\n+      None => p\n     }\n }\n \n@@ -361,17 +361,17 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                 (e, s);\n             }\n             match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-              some(match_ident(id)) => {\n+              Some(match_ident(id)) => {\n                 (expr_path(@{span: id.span,\n                              global: false,\n                              idents: ~[id.node],\n-                             rp: none,\n+                             rp: None,\n                              types: ~[]}), id.span)\n               }\n-              some(match_path(a_pth)) => (expr_path(a_pth), s),\n-              some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n-              some(m) => match_error(cx, m, ~\"an expression\"),\n-              none => orig(e, s, fld)\n+              Some(match_path(a_pth)) => (expr_path(a_pth), s),\n+              Some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n+              Some(m) => match_error(cx, m, ~\"an expression\"),\n+              None => orig(e, s, fld)\n             }\n           }\n           _ => orig(e, s, fld)\n@@ -386,14 +386,14 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     return match t {\n           ast::ty_path(pth, _) => {\n             match path_to_ident(pth) {\n-              some(id) => {\n+              Some(id) => {\n                 match follow_for_trans(cx, b.find(id), idx_path) {\n-                  some(match_ty(ty)) => (ty.node, ty.span),\n-                  some(m) => match_error(cx, m, ~\"a type\"),\n-                  none => orig(t, s, fld)\n+                  Some(match_ty(ty)) => (ty.node, ty.span),\n+                  Some(m) => match_error(cx, m, ~\"a type\"),\n+                  None => orig(t, s, fld)\n                 }\n               }\n-              none => orig(t, s, fld)\n+              None => orig(t, s, fld)\n             }\n           }\n           _ => orig(t, s, fld)\n@@ -410,16 +410,16 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     -> (blk_, span)\n {\n     return match block_to_ident(blk) {\n-          some(id) => {\n+          Some(id) => {\n             match follow_for_trans(cx, b.find(id), idx_path) {\n-              some(match_block(new_blk)) => (new_blk.node, new_blk.span),\n+              Some(match_block(new_blk)) => (new_blk.node, new_blk.span),\n \n               // possibly allow promotion of ident/path/expr to blocks?\n-              some(m) => match_error(cx, m, ~\"a block\"),\n-              none => orig(blk, s, fld)\n+              Some(m) => match_error(cx, m, ~\"a block\"),\n+              None => orig(blk, s, fld)\n             }\n           }\n-          none => orig(blk, s, fld)\n+          None => orig(blk, s, fld)\n         }\n }\n \n@@ -435,7 +435,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n           expr_path(p_pth) => p_t_s_r_path(cx, p_pth, s, b),\n           expr_vec(p_elts, _) => {\n             match elts_to_ell(cx, p_elts) {\n-              {pre: pre, rep: some(repeat_me), post: post} => {\n+              {pre: pre, rep: Some(repeat_me), post: post} => {\n                 p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n                                b);\n                 if vec::len(pre) > 0u {\n@@ -448,7 +448,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                                    ~\"matching after `...` not yet supported\");\n                 }\n               }\n-              {pre: pre, rep: none, post: post} => {\n+              {pre: pre, rep: None, post: post} => {\n                 if post != ~[] {\n                     cx.bug(~\"elts_to_ell provided an invalid result\");\n                 }\n@@ -466,7 +466,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                match_result {\n                 return match m {\n                       match_expr(e) => {\n-                        if e == pat { some(leaf(match_exact)) } else { none }\n+                        if e == pat { Some(leaf(match_exact)) } else { None }\n                       }\n                       _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                     }\n@@ -487,8 +487,8 @@ fn specialize_match(m: matchable) -> matchable {\n             match e.node {\n               expr_path(pth) => {\n                 match path_to_ident(pth) {\n-                  some(id) => match_ident(respan(pth.span, id)),\n-                  none => match_path(pth)\n+                  Some(id) => match_ident(respan(pth.span, id)),\n+                  None => match_path(pth)\n                 }\n               }\n               _ => m\n@@ -501,10 +501,10 @@ fn specialize_match(m: matchable) -> matchable {\n /* pattern_to_selectors helper functions */\n fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n     match path_to_ident(p) {\n-      some(p_id) => {\n+      Some(p_id) => {\n         fn select(cx: ext_ctxt, m: matchable) -> match_result {\n             return match m {\n-                  match_expr(e) => some(leaf(specialize_match(m))),\n+                  match_expr(e) => Some(leaf(specialize_match(m))),\n                   _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                 }\n         }\n@@ -513,18 +513,18 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n         }\n         b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n       }\n-      none => ()\n+      None => ()\n     }\n }\n \n-fn block_to_ident(blk: blk_) -> option<ident> {\n-    if vec::len(blk.stmts) != 0u { return none; }\n+fn block_to_ident(blk: blk_) -> Option<ident> {\n+    if vec::len(blk.stmts) != 0u { return None; }\n     return match blk.expr {\n-          some(expr) => match expr.node {\n+          Some(expr) => match expr.node {\n             expr_path(pth) => path_to_ident(pth),\n-            _ => none\n+            _ => None\n           },\n-          none => none\n+          None => None\n         }\n }\n \n@@ -534,7 +534,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n         return match m {\n               match_expr(e) => match e.node {\n                 expr_mac(mac) => fn_m(mac),\n-                _ => none\n+                _ => None\n               },\n               _ => cx.bug(~\"broken traversal in p_t_s_r\")\n             }\n@@ -568,9 +568,9 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n \n                     // using repeat_me.span is a little wacky, but the\n                     // error we want to report is one in the macro def\n-                    some(seq(@elts, repeat_me.span))\n+                    Some(seq(@elts, repeat_me.span))\n                   }\n-                  _ => none\n+                  _ => None\n                 }\n               }\n               _ => cx.bug(~\"broken traversal in p_t_s_r\")\n@@ -591,13 +591,13 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n                   expr_vec(arg_elts, _) => {\n                     let actual_len = vec::len(arg_elts);\n                     if at_least && actual_len >= len || actual_len == len {\n-                        some(leaf(match_exact))\n-                    } else { none }\n+                        Some(leaf(match_exact))\n+                    } else { None }\n                   }\n-                  _ => none\n+                  _ => None\n                 }\n               }\n-              _ => none\n+              _ => None\n             }\n     }\n     b.literal_ast_matchers.push(\n@@ -613,9 +613,9 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n                   match_expr(e) => {\n                     match e.node {\n                       expr_vec(arg_elts, _) => {\n-                        some(leaf(match_expr(arg_elts[idx])))\n+                        Some(leaf(match_expr(arg_elts[idx])))\n                       }\n-                      _ => none\n+                      _ => None\n                     }\n                   }\n                   _ => cx.bug(~\"broken traversal in p_t_s_r\")\n@@ -631,7 +631,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> base::macro_def {\n     let args = get_mac_args_no_max(cx, sp, arg, 0u, ~\"macro\");\n \n-    let mut macro_name: option<~str> = none;\n+    let mut macro_name: Option<~str> = None;\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n         match arg.node {\n@@ -648,23 +648,23 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                 match mac.node {\n                   mac_invoc(pth, invoc_arg, body) => {\n                     match path_to_ident(pth) {\n-                      some(id) => {\n+                      Some(id) => {\n                         let id_str = cx.str_of(id);\n                         match macro_name {\n-                          none => macro_name = some(id_str),\n-                          some(other_id) => if id_str != other_id {\n+                          None => macro_name = Some(id_str),\n+                          Some(other_id) => if id_str != other_id {\n                             cx.span_fatal(pth.span,\n                                           ~\"macro name must be \" +\n                                           ~\"consistent\");\n                           }\n                         }\n                       },\n-                      none => cx.span_fatal(pth.span,\n+                      None => cx.span_fatal(pth.span,\n                                             ~\"macro name must not be a path\")\n                     }\n                     let arg = match invoc_arg {\n-                      some(arg) => arg,\n-                      none => cx.span_fatal(mac.span,\n+                      Some(arg) => arg,\n+                      None => cx.span_fatal(mac.span,\n                                            ~\"macro must have arguments\")\n                     };\n                     vec::push(clauses,\n@@ -698,23 +698,23 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     return {name:\n              match macro_name {\n-               some(id) => id,\n-               none => cx.span_fatal(sp, ~\"macro definition must have \" +\n+               Some(id) => id,\n+               None => cx.span_fatal(sp, ~\"macro definition must have \" +\n                                      ~\"at least one clause\")\n              },\n-         ext: normal({expander: ext, span: some(option::get(arg).span)})};\n+         ext: normal({expander: ext, span: Some(option::get(arg).span)})};\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          _body: ast::mac_body,\n                          clauses: ~[@clause]) -> @expr {\n         let arg = match arg {\n-          some(arg) => arg,\n-          none => cx.span_fatal(sp, ~\"macro must have arguments\")\n+          Some(arg) => arg,\n+          None => cx.span_fatal(sp, ~\"macro must have arguments\")\n         };\n         for clauses.each |c| {\n             match use_selectors_to_bind(c.params, arg) {\n-              some(bindings) => return transcribe(cx, bindings, c.body),\n-              none => again\n+              Some(bindings) => return transcribe(cx, bindings, c.body),\n+              None => again\n             }\n         }\n         cx.span_fatal(sp, ~\"no clauses match macro invocation\");"}, {"sha": "09dc48e0929fefb402281333d8462ea1dac0f228", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -16,15 +16,15 @@ export expand_include_bin;\n /* line!(): expands to the current line number */\n fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"line\");\n+    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"line\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     return mk_uint(cx, sp, loc.line);\n }\n \n /* col!(): expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"col\");\n+    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"col\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     return mk_uint(cx, sp, loc.col);\n }\n@@ -34,29 +34,29 @@ fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n  * out if we wanted. */\n fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n+    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n     let { file: @{ name: filename, _ }, _ } =\n         codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     return mk_uniq_str(cx, sp, filename);\n }\n \n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"stringify\");\n+    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"stringify\");\n     let s = pprust::expr_to_str(args[0], cx.parse_sess().interner);\n     return mk_uniq_str(cx, sp, s);\n }\n \n fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n+    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n     return mk_uniq_str(cx, sp,\n                     str::connect(cx.mod_path().map(|x| cx.str_of(x)), ~\"::\"));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"include\");\n+    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n     let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n                                         &res_rel_file(cx, sp, &Path(file)),\n@@ -66,7 +66,7 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                       _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"include_str\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_str\");\n \n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n \n@@ -83,7 +83,7 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                       _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"include_bin\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_bin\");\n \n     let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n "}, {"sha": "b647e868da535b8b196f970d26550484ef8d1e46", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -11,7 +11,7 @@ fn expand_trace_macros(cx: ext_ctxt, sp: span,\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, none, tt);\n+                               cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n "}, {"sha": "3b04fd502f4c9dd543c42d472943d1dca2509aa0", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -85,19 +85,19 @@ eof: [a $( a )* a b \u00b7]\n nonempty body. */\n \n enum matcher_pos_up { /* to break a circularity */\n-    matcher_pos_up(option<matcher_pos>)\n+    matcher_pos_up(Option<matcher_pos>)\n }\n \n fn is_some(&&mpu: matcher_pos_up) -> bool {\n     match mpu {\n-      matcher_pos_up(none) => false,\n+      matcher_pos_up(None) => false,\n       _ => true\n     }\n }\n \n type matcher_pos = ~{\n     elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n-    sep: option<token>,\n+    sep: Option<token>,\n     mut idx: uint,\n     mut up: matcher_pos_up, // mutable for swapping only\n     matches: ~[DVec<@named_match>],\n@@ -107,7 +107,7 @@ type matcher_pos = ~{\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n     match mpu {\n-      matcher_pos_up(some(mp)) => copy mp,\n+      matcher_pos_up(Some(mp)) => copy mp,\n       _ => fail\n     }\n }\n@@ -122,7 +122,7 @@ fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn initial_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n+fn initial_matcher_pos(ms: ~[matcher], sep: Option<token>, lo: uint)\n     -> matcher_pos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n@@ -136,7 +136,7 @@ fn initial_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n           }\n         }\n     }\n-    ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(none),\n+    ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(None),\n       matches: copy vec::from_fn(count_names(ms), |_i| dvec::dvec()),\n       match_lo: 0u, match_hi: match_idx_hi, sp_lo: lo}\n }\n@@ -208,7 +208,7 @@ fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n     -> parse_result {\n     let mut cur_eis = ~[];\n-    vec::push(cur_eis, initial_matcher_pos(ms, none, rdr.peek().sp.lo));\n+    vec::push(cur_eis, initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -263,7 +263,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n                     // the *_t vars are workarounds for the lack of unary move\n                     match copy ei.sep {\n-                      some(t) if idx == len => { // we need a separator\n+                      Some(t) if idx == len => { // we need a separator\n                         if tok == t { //pass the separator\n                             let ei_t <- ei;\n                             ei_t.idx += 1u;\n@@ -300,7 +300,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                     let ei_t <- ei;\n                     vec::push(cur_eis, ~{\n                         elts: matchers, sep: sep, mut idx: 0u,\n-                        mut up: matcher_pos_up(some(ei_t)),\n+                        mut up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n@@ -381,8 +381,8 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n fn parse_nt(p: parser, name: ~str) -> nonterminal {\n     match name {\n       ~\"item\" => match p.parse_item(~[]) {\n-        some(i) => token::nt_item(i),\n-        none => p.fatal(~\"expected an item keyword\")\n+        Some(i) => token::nt_item(i),\n+        None => p.fatal(~\"expected an item keyword\")\n       },\n       ~\"block\" => token::nt_block(p.parse_block()),\n       ~\"stmt\" => token::nt_stmt(p.parse_stmt(~[])),"}, {"sha": "1fd2f880595e9e66d3430da83877554f97fda5ed", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -14,7 +14,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                      arg: ~[ast::token_tree]) -> base::mac_result {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        {node: m, span: {lo: 0u, hi: 0u, expn_info: none}}\n+        {node: m, span: {lo: 0u, hi: 0u, expn_info: None}}\n     }\n \n     let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");\n@@ -28,15 +28,15 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n             ms(match_nonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(match_tok(FAT_ARROW)),\n             ms(match_nonterminal(rhs_nm, special_idents::tt, 1u)),\n-        ], some(SEMI), false, 0u, 2u)),\n+        ], Some(SEMI), false, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(match_seq(~[ms(match_tok(SEMI))], none, true, 2u, 2u))];\n+        ms(match_seq(~[ms(match_tok(SEMI))], None, true, 2u, 2u))];\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, none, arg);\n+                                   cx.parse_sess().interner, None, arg);\n     let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n                                      arg_reader as reader, argument_gram);\n \n@@ -65,7 +65,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         }\n \n         // Which arm's failure should we report? (the one furthest along)\n-        let mut best_fail_spot = {lo: 0u, hi: 0u, expn_info: none};\n+        let mut best_fail_spot = {lo: 0u, hi: 0u, expn_info: None};\n         let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n         let s_d = cx.parse_sess().span_diagnostic;\n@@ -75,7 +75,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n             match lhs {\n               @matched_nonterminal(nt_matchers(mtcs)) => {\n                 // `none` is because we're not interpolating\n-                let arg_rdr = new_tt_reader(s_d, itr, none, arg) as reader;\n+                let arg_rdr = new_tt_reader(s_d, itr, None, arg) as reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n@@ -84,7 +84,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                       _ => cx.span_bug(sp, ~\"bad thing in rhs\")\n                     };\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n-                    let trncbr = new_tt_reader(s_d, itr, some(named_matches),\n+                    let trncbr = new_tt_reader(s_d, itr, Some(named_matches),\n                                                ~[rhs]);\n                     let p = parser(cx.parse_sess(), cx.cfg(),\n                                    trncbr as reader, SOURCE_FILE);\n@@ -109,6 +109,6 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     return mr_def({\n         name: *cx.parse_sess().interner.get(name),\n-        ext: expr_tt({expander: exp, span: some(sp)})\n+        ext: expr_tt({expander: exp, span: Some(sp)})\n     });\n }\n\\ No newline at end of file"}, {"sha": "f353eecb92602bc616e75550391a0776dbf514b7", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -9,7 +9,7 @@ import std::map::{hashmap, box_str_hash};\n export tt_reader,  new_tt_reader, dup_tt_reader, tt_next_token;\n \n enum tt_frame_up { /* to break a circularity */\n-    tt_frame_up(option<tt_frame>)\n+    tt_frame_up(Option<tt_frame>)\n }\n \n /* FIXME #2811: figure out how to have a uniquely linked stack, and change to\n@@ -19,7 +19,7 @@ type tt_frame = @{\n     readme: ~[ast::token_tree],\n     mut idx: uint,\n     dotdotdoted: bool,\n-    sep: option<token>,\n+    sep: Option<token>,\n     up: tt_frame_up,\n };\n \n@@ -40,15 +40,15 @@ type tt_reader = @{\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n fn new_tt_reader(sp_diag: span_handler, itr: ident_interner,\n-                 interp: option<std::map::hashmap<ident,@named_match>>,\n+                 interp: Option<std::map::hashmap<ident,@named_match>>,\n                  src: ~[ast::token_tree])\n     -> tt_reader {\n     let r = @{sp_diag: sp_diag, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n-                         sep: none, up: tt_frame_up(option::none)},\n+                         sep: None, up: tt_frame_up(option::None)},\n               interpolations: match interp { /* just a convienience */\n-                none => std::map::uint_hash::<@named_match>(),\n-                some(x) => x\n+                None => std::map::uint_hash::<@named_match>(),\n+                Some(x) => x\n               },\n               mut repeat_idx: ~[mut], mut repeat_len: ~[],\n               /* dummy values, never read: */\n@@ -62,8 +62,8 @@ fn new_tt_reader(sp_diag: span_handler, itr: ident_interner,\n pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n     @{readme: f.readme, mut idx: f.idx, dotdotdoted: f.dotdotdoted,\n       sep: f.sep, up: match f.up {\n-        tt_frame_up(some(up_frame)) => {\n-          tt_frame_up(some(dup_tt_frame(up_frame)))\n+        tt_frame_up(Some(up_frame)) => {\n+          tt_frame_up(Some(dup_tt_frame(up_frame)))\n         }\n         tt_frame_up(none) => tt_frame_up(none)\n       }\n@@ -141,11 +141,11 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             || r.repeat_idx.last() == r.repeat_len.last() - 1 {\n \n             match r.cur.up {\n-              tt_frame_up(none) => {\n+              tt_frame_up(None) => {\n                 r.cur_tok = EOF;\n                 return ret_val;\n               }\n-              tt_frame_up(some(tt_f)) => {\n+              tt_frame_up(Some(tt_f)) => {\n                 if r.cur.dotdotdoted {\n                     vec::pop(r.repeat_idx); vec::pop(r.repeat_len);\n                 }\n@@ -159,11 +159,11 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             r.cur.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n             match r.cur.sep {\n-              some(tk) => {\n+              Some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n               }\n-              none => ()\n+              None => ()\n             }\n         }\n     }\n@@ -172,7 +172,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n         match r.cur.readme[r.cur.idx] {\n           tt_delim(tts) => {\n             r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: false,\n-                      sep: none, up: tt_frame_up(option::some(r.cur)) };\n+                      sep: None, up: tt_frame_up(option::Some(r.cur)) };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, tok) => {\n@@ -207,7 +207,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n                     vec::push(r.repeat_len, len);\n                     vec::push(r.repeat_idx, 0u);\n                     r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: true,\n-                              sep: sep, up: tt_frame_up(option::some(r.cur))};\n+                              sep: sep, up: tt_frame_up(option::Some(r.cur))};\n                 }\n               }\n             }"}, {"sha": "2006ccf639c0803da794d16eec0b4ac2c7b90178", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -23,7 +23,7 @@ trait ast_fold {\n     fn fold_crate_directive(&&@crate_directive) -> @crate_directive;\n     fn fold_view_item(&&@view_item) -> @view_item;\n     fn fold_foreign_item(&&@foreign_item) -> @foreign_item;\n-    fn fold_item(&&@item) -> option<@item>;\n+    fn fold_item(&&@item) -> Option<@item>;\n     fn fold_struct_field(&&@struct_field) -> @struct_field;\n     fn fold_item_underscore(item_) -> item_;\n     fn fold_method(&&@method) -> @method;\n@@ -54,7 +54,7 @@ type ast_fold_precursor = @{\n                               ast_fold) -> (crate_directive_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n     fold_foreign_item: fn@(&&@foreign_item, ast_fold) -> @foreign_item,\n-    fold_item: fn@(&&@item, ast_fold) -> option<@item>,\n+    fold_item: fn@(&&@item, ast_fold) -> Option<@item>,\n     fold_struct_field: fn@(&&@struct_field, ast_fold) -> @struct_field,\n     fold_item_underscore: fn@(item_, ast_fold) -> item_,\n     fold_method: fn@(&&@method, ast_fold) -> @method,\n@@ -204,10 +204,10 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n           span: fld.new_span(ni.span)};\n }\n \n-fn noop_fold_item(&&i: @item, fld: ast_fold) -> option<@item> {\n+fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    return some(@{ident: fld.fold_ident(i.ident),\n+    return Some(@{ident: fld.fold_ident(i.ident),\n                attrs: vec::map(i.attrs, fold_attribute),\n                id: fld.new_id(i.id),\n                node: fld.fold_item_underscore(i.node),\n@@ -270,11 +270,11 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 -> @ast::struct_def {\n     let resulting_optional_constructor;\n     match struct_def.ctor {\n-        none => {\n-            resulting_optional_constructor = none;\n+        None => {\n+            resulting_optional_constructor = None;\n         }\n-        some(constructor) => {\n-            resulting_optional_constructor = some({\n+        Some(constructor) => {\n+            resulting_optional_constructor = Some({\n                 node: {\n                     body: fld.fold_block(constructor.node.body),\n                     dec: fold_fn_decl(constructor.node.dec, fld),\n@@ -394,8 +394,8 @@ fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     match d {\n       decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(x))),\n       decl_item(it) => match fld.fold_item(it) {\n-        some(it_folded) => decl_item(it_folded),\n-        none => decl_local(~[])\n+        Some(it_folded) => decl_item(it_folded),\n+        None => decl_local(~[])\n       }\n     }\n }\n@@ -581,7 +581,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                 fields: vec::map(struct_def.fields,\n                                  |f| fld.fold_struct_field(f)),\n                 methods: vec::map(struct_def.methods, |m| fld.fold_method(m)),\n-                ctor: none,\n+                ctor: None,\n                 dtor: dtor\n             })\n         }\n@@ -600,8 +600,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n     let de = match v.disr_expr {\n-      some(e) => some(fld.fold_expr(e)),\n-      none => none\n+      Some(e) => Some(fld.fold_expr(e)),\n+      None => None\n     };\n     return {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n@@ -628,9 +628,9 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n          pat: fld.fold_pat(l.pat),\n          init:\n              match l.init {\n-               option::none::<initializer> => l.init,\n-               option::some::<initializer>(init) => {\n-                 option::some::<initializer>({op: init.op,\n+               option::None::<initializer> => l.init,\n+               option::Some::<initializer>(init) => {\n+                 option::Some::<initializer>({op: init.op,\n                                               expr: fld.fold_expr(init.expr)})\n                }\n              },\n@@ -698,7 +698,7 @@ impl ast_fold_precursor: ast_fold {\n         -> @foreign_item {\n         return self.fold_foreign_item(x, self as ast_fold);\n     }\n-    fn fold_item(&&i: @item) -> option<@item> {\n+    fn fold_item(&&i: @item) -> Option<@item> {\n         return self.fold_item(i, self as ast_fold);\n     }\n     fn fold_struct_field(&&sf: @struct_field) -> @struct_field {"}, {"sha": "41cb285f7db82e36ef4cf3cee680b89d62b0c4dc", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -31,7 +31,7 @@ type parse_sess = @{\n     mut byte_pos: uint\n };\n \n-fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n+fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n     let cm = codemap::new_codemap();\n     return @{cm: cm,\n              mut next_id: 1,\n@@ -51,9 +51,9 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n \n fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: parse_sess) -> @ast::crate {\n-    if input.filetype() == some(~\"rc\") {\n+    if input.filetype() == Some(~\"rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n-    } else if input.filetype() == some(~\"rs\") {\n+    } else if input.filetype() == Some(~\"rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n         sess.span_diagnostic.handler().fatal(~\"unknown input file type: \" +\n@@ -117,7 +117,7 @@ fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n \n fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               +attrs: ~[ast::attribute],\n-                              sess: parse_sess) -> option<@ast::item> {\n+                              sess: parse_sess) -> Option<@ast::item> {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n     let r = p.parse_item(attrs);\n@@ -208,6 +208,6 @@ fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &Path,\n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n                       tt: ~[ast::token_tree]) -> parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n-                                    none, tt);\n+                                    None, tt);\n     return parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }"}, {"sha": "074b7c5829dbf5a112564b71a415fe4e9c6bcb9c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -7,7 +7,7 @@ export parser_attr;\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option<Either<~[ast::attribute], @ast::expr>>;\n+type attr_or_ext = Option<Either<~[ast::attribute], @ast::expr>>;\n \n trait parser_attr {\n     fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n@@ -36,20 +36,20 @@ impl parser: parser_attr {\n                 self.bump();\n                 let first_attr =\n                     self.parse_attribute_naked(ast::attr_outer, lo);\n-                return some(Left(vec::append(~[first_attr],\n+                return Some(Left(vec::append(~[first_attr],\n                                           self.parse_outer_attributes())));\n             } else if !(self.look_ahead(1u) == token::LT\n                         || self.look_ahead(1u) == token::LBRACKET\n                         || self.look_ahead(1u) == token::POUND\n                         || expect_item_next) {\n                 self.bump();\n-                return some(Right(self.parse_syntax_ext_naked(lo)));\n-            } else { return none; }\n+                return Some(Right(self.parse_syntax_ext_naked(lo)));\n+            } else { return None; }\n         }\n         token::DOC_COMMENT(_) => {\n-          return some(Left(self.parse_outer_attributes()));\n+          return Some(Left(self.parse_outer_attributes()));\n         }\n-        _ => return none\n+        _ => return None\n       }\n     }\n "}, {"sha": "3ad33b8f21802bd1bea792b79f10003e25872db4", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -68,7 +68,7 @@ fn ends_in_lit_int(ex: @ast::expr) -> bool {\n         ends_in_lit_int(sub)\n       }\n       ast::expr_fail(osub) | ast::expr_ret(osub) => match osub {\n-        some(ex) => ends_in_lit_int(ex),\n+        Some(ex) => ends_in_lit_int(ex),\n         _ => false\n       },\n       _ => false"}, {"sha": "7b18ca532e06d912f28ffec1219a842de14ff8fc", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -50,7 +50,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n     }\n \n     // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: ~[~str], chars: ~str, max: option<uint>) -> ~[~str] {\n+    fn block_trim(lines: ~[~str], chars: ~str, max: Option<uint>) -> ~[~str] {\n \n         let mut i = max.get_default(uint::max_value);\n         for lines.each |line| {\n@@ -85,9 +85,9 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n     if comment.starts_with(~\"/*\") {\n         let lines = str::lines_any(comment.slice(3u, comment.len() - 2u));\n         let lines = vertical_trim(lines);\n-        let lines = block_trim(lines, ~\"\\t \", none);\n-        let lines = block_trim(lines, ~\"*\", some(1u));\n-        let lines = block_trim(lines, ~\"\\t \", none);\n+        let lines = block_trim(lines, ~\"\\t \", None);\n+        let lines = block_trim(lines, ~\"*\", Some(1u));\n+        let lines = block_trim(lines, ~\"\\t \", None);\n         return str::connect(lines, ~\"\\n\");\n     }\n "}, {"sha": "9cca463c7c3d771b8ce8f43f8db7dd0fc2ea985f", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -4,18 +4,18 @@ import parser::parser;\n import lexer::reader;\n \n type seq_sep = {\n-    sep: option<token::token>,\n+    sep: Option<token::token>,\n     trailing_sep_allowed: bool\n };\n \n fn seq_sep_trailing_disallowed(t: token::token) -> seq_sep {\n-    return {sep: option::some(t), trailing_sep_allowed: false};\n+    return {sep: option::Some(t), trailing_sep_allowed: false};\n }\n fn seq_sep_trailing_allowed(t: token::token) -> seq_sep {\n-    return {sep: option::some(t), trailing_sep_allowed: true};\n+    return {sep: option::Some(t), trailing_sep_allowed: true};\n }\n fn seq_sep_none() -> seq_sep {\n-    return {sep: option::none, trailing_sep_allowed: false};\n+    return {sep: option::None, trailing_sep_allowed: false};\n }\n \n fn token_to_str(reader: reader, ++token: token::token) -> ~str {\n@@ -41,11 +41,11 @@ trait parser_common {\n     fn check_restricted_keywords();\n     fn check_restricted_keywords_(w: ~str);\n     fn expect_gt();\n-    fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_to_before_gt<T: copy>(sep: Option<token::token>,\n                                        f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_to_gt<T: copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_lt_gt<T: copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> spanned<~[T]>;\n     fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n                                  f: fn(parser) -> T) -> ~[T];\n@@ -198,14 +198,14 @@ impl parser: parser_common {\n         }\n     }\n \n-    fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_to_before_gt<T: copy>(sep: Option<token::token>,\n                                        f: fn(parser) -> T) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n             match sep {\n-              some(t) => {\n+              Some(t) => {\n                 if first { first = false; }\n                 else { self.expect(t); }\n               }\n@@ -217,15 +217,15 @@ impl parser: parser_common {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_to_gt<T: copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n         return v;\n     }\n \n-    fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n+    fn parse_seq_lt_gt<T: copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n@@ -249,7 +249,7 @@ impl parser: parser_common {\n         let mut v: ~[T] = ~[];\n         while self.token != ket {\n             match sep.sep {\n-              some(t) => {\n+              Some(t) => {\n                 if first { first = false; }\n                 else { self.expect(t); }\n               }"}, {"sha": "2a4516f80aa7d970e5289825538e638562d1bbda", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -18,7 +18,7 @@ fn eval_crate_directives(cx: ctx,\n }\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                prefix: &Path, suffix: &option<Path>)\n+                                prefix: &Path, suffix: &Option<Path>)\n     -> (ast::_mod, ~[ast::attribute]) {\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n@@ -40,13 +40,13 @@ companion mod is a .rs file with the same name as the directory.\n We build the path to the companion mod by combining the prefix and the\n optional suffix then adding the .rs extension.\n */\n-fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &option<Path>)\n+fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n     -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n \n-    fn companion_file(prefix: &Path, suffix: &option<Path>) -> Path {\n+    fn companion_file(prefix: &Path, suffix: &Option<Path>) -> Path {\n         return match *suffix {\n-          option::some(s) => prefix.push_many(s.components),\n-          option::none => copy *prefix\n+          option::Some(s) => prefix.push_many(s.components),\n+          option::None => copy *prefix\n         }.with_filetype(\"rs\");\n     }\n \n@@ -76,8 +76,8 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &option<Path>)\n \n fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-      some(d) => d,\n-      none => default\n+      Some(d) => d,\n+      None => default\n     }\n }\n \n@@ -117,7 +117,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n             prefix.push_many(path.components)\n         };\n         let (m0, a0) = eval_crate_directives_to_mod(\n-            cx, cdirs, &full_path, &none);\n+            cx, cdirs, &full_path, &None);\n         let i =\n             @{ident: /* FIXME (#2543) */ copy id,\n               attrs: vec::append(attrs, a0),"}, {"sha": "e51064d6ffec83fa2061ebaba3224f3205c3f6d6", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -196,14 +196,14 @@ fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n // might return a sugared-doc-attr\n fn consume_whitespace_and_comments(rdr: string_reader)\n-                                -> option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::token, sp: span}> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n // might return a sugared-doc-attr\n fn consume_any_line_comment(rdr: string_reader)\n-                                -> option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::token, sp: span}> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n           '/' => {\n@@ -217,7 +217,7 @@ fn consume_any_line_comment(rdr: string_reader)\n                     str::push_char(acc, rdr.curr);\n                     bump(rdr);\n                 }\n-                return some({\n+                return Some({\n                     tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n                     sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n                 });\n@@ -241,12 +241,12 @@ fn consume_any_line_comment(rdr: string_reader)\n             }\n         }\n     }\n-    return none;\n+    return None;\n }\n \n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: string_reader)\n-                                -> option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::token, sp: span}> {\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n@@ -262,7 +262,7 @@ fn consume_block_comment(rdr: string_reader)\n             acc += ~\"*/\";\n             bump(rdr);\n             bump(rdr);\n-            return some({\n+            return Some({\n                 tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n                 sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n             });\n@@ -289,7 +289,7 @@ fn consume_block_comment(rdr: string_reader)\n     return consume_whitespace_and_comments(rdr);\n }\n \n-fn scan_exponent(rdr: string_reader) -> option<~str> {\n+fn scan_exponent(rdr: string_reader) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -302,9 +302,9 @@ fn scan_exponent(rdr: string_reader) -> option<~str> {\n         }\n         let exponent = scan_digits(rdr, 10u);\n         if str::len(exponent) > 0u {\n-            return some(rslt + exponent);\n+            return Some(rslt + exponent);\n         } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n-    } else { return none::<~str>; }\n+    } else { return None::<~str>; }\n }\n \n fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n@@ -313,7 +313,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n         let c = rdr.curr;\n         if c == '_' { bump(rdr); again; }\n         match char::to_digit(c, radix) {\n-          some(_) => {\n+          Some(_) => {\n             str::push_char(rslt, c);\n             bump(rdr);\n           }\n@@ -384,11 +384,11 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         num_str += ~\".\" + dec_part;\n     }\n     match scan_exponent(rdr) {\n-      some(s) => {\n+      Some(s) => {\n         is_float = true;\n         num_str += s;\n       }\n-      none => ()\n+      None => ()\n     }\n     if rdr.curr == 'f' {\n         bump(rdr);"}, {"sha": "a98be8ec1d0c3ae602c494570d254d7fae9108f3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -109,7 +109,7 @@ enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n                       members(~[@class_member]) }\n \n type arg_or_capture_item = Either<arg, capture_item>;\n-type item_info = (ident, item_, option<~[attribute]>);\n+type item_info = (ident, item_, Option<~[attribute]>);\n \n enum item_or_view_item {\n     iovi_none,\n@@ -150,8 +150,8 @@ macro_rules! maybe_whole (\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return *x; }\n       _ => ()\n     }} ;\n-    (some $p:expr, $constructor:ident) => { match copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return some(x); }\n+    (Some $p:expr, $constructor:ident) => { match copy $p.token {\n+      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return Some(x); }\n       _ => ()\n     }} ;\n     (iovi $p:expr, $constructor:ident) => { match copy $p.token {\n@@ -169,11 +169,11 @@ macro_rules! maybe_whole (\n )\n \n \n-pure fn maybe_append(+lhs: ~[attribute], rhs: option<~[attribute]>)\n+pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n                   -> ~[attribute] {\n     match rhs {\n-        none => lhs,\n-        some(attrs) => vec::append(lhs, attrs)\n+        None => lhs,\n+        Some(attrs) => vec::append(lhs, attrs)\n     }\n }\n \n@@ -400,10 +400,10 @@ struct parser {\n         }\n     }\n \n-    fn region_from_name(s: option<ident>) -> @region {\n+    fn region_from_name(s: Option<ident>) -> @region {\n         let r = match s {\n-          some (id) => re_named(id),\n-          none => re_anon\n+          Some (id) => re_named(id),\n+          None => re_anon\n         };\n \n         @{id: self.get_id(), node: r}\n@@ -416,10 +416,10 @@ struct parser {\n         match copy self.token {\n           token::IDENT(sid, _) => {\n             self.bump();\n-            self.region_from_name(some(sid))\n+            self.region_from_name(Some(sid))\n           }\n           _ => {\n-            self.region_from_name(none)\n+            self.region_from_name(None)\n           }\n         }\n     }\n@@ -431,12 +431,12 @@ struct parser {\n               token::IDENT(sid, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.bump(); self.bump();\n-                    some(sid)\n+                    Some(sid)\n                 } else {\n-                    none\n+                    None\n                 }\n               }\n-              _ => { none }\n+              _ => { None }\n             };\n         self.region_from_name(name)\n     }\n@@ -447,12 +447,12 @@ struct parser {\n         let lo = self.span.lo;\n \n         match self.maybe_parse_dollar_mac() {\n-          some(e) => {\n+          Some(e) => {\n             return @{id: self.get_id(),\n                   node: ty_mac(spanned(lo, self.span.hi, e)),\n                   span: mk_sp(lo, self.span.hi)};\n           }\n-          none => ()\n+          None => ()\n         }\n \n         let t = if self.token == token::LPAREN {\n@@ -495,8 +495,8 @@ struct parser {\n \n             // Parse the `* 3` in `[ int * 3 ]`\n             match self.maybe_parse_fixed_vstore_with_star() {\n-                none => {}\n-                some(suffix) => {\n+                None => {}\n+                Some(suffix) => {\n                     t = ty_fixed_length(@{\n                         id: self.get_id(),\n                         node: t,\n@@ -529,8 +529,8 @@ struct parser {\n         return @{id: self.get_id(),\n               node: match self.maybe_parse_fixed_vstore() {\n                 // Consider a fixed vstore suffix (/N or /_)\n-                none => t,\n-                some(v) => {\n+                None => t,\n+                Some(v) => {\n                   ty_fixed_length(@{id: self.get_id(), node:t, span: sp}, v)\n                 } },\n               span: sp}\n@@ -615,62 +615,62 @@ struct parser {\n         }\n     }\n \n-    fn maybe_parse_dollar_mac() -> option<mac_> {\n+    fn maybe_parse_dollar_mac() -> Option<mac_> {\n         match copy self.token {\n           token::DOLLAR => {\n             let lo = self.span.lo;\n             self.bump();\n             match copy self.token {\n               token::LIT_INT_UNSUFFIXED(num) => {\n                 self.bump();\n-                some(mac_var(num as uint))\n+                Some(mac_var(num as uint))\n               }\n               token::LPAREN => {\n                 self.bump();\n                 let e = self.parse_expr();\n                 self.expect(token::RPAREN);\n                 let hi = self.last_span.hi;\n-                some(mac_aq(mk_sp(lo,hi), e))\n+                Some(mac_aq(mk_sp(lo,hi), e))\n               }\n               _ => {\n                 self.fatal(~\"expected `(` or unsuffixed integer literal\");\n               }\n             }\n           }\n-          _ => none\n+          _ => None\n         }\n     }\n \n-    fn maybe_parse_fixed_vstore() -> option<option<uint>> {\n+    fn maybe_parse_fixed_vstore() -> Option<Option<uint>> {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n             match copy self.token {\n               token::UNDERSCORE => {\n-                self.bump(); some(none)\n+                self.bump(); Some(None)\n               }\n               token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n-                self.bump(); some(some(i as uint))\n+                self.bump(); Some(Some(i as uint))\n               }\n-              _ => none\n+              _ => None\n             }\n         } else {\n-            none\n+            None\n         }\n     }\n \n-    fn maybe_parse_fixed_vstore_with_star() -> option<option<uint>> {\n+    fn maybe_parse_fixed_vstore_with_star() -> Option<Option<uint>> {\n         if self.eat(token::BINOP(token::STAR)) {\n             match copy self.token {\n               token::UNDERSCORE => {\n-                self.bump(); some(none)\n+                self.bump(); Some(None)\n               }\n               token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n-                self.bump(); some(some(i as uint))\n+                self.bump(); Some(Some(i as uint))\n               }\n-              _ => none\n+              _ => None\n             }\n         } else {\n-            none\n+            None\n         }\n     }\n \n@@ -727,7 +727,7 @@ struct parser {\n             }\n         }\n         @{span: mk_sp(lo, self.last_span.hi), global: global,\n-          idents: ids, rp: none, types: ~[]}\n+          idents: ids, rp: None, types: ~[]}\n     }\n \n     fn parse_value_path() -> @path {\n@@ -757,16 +757,16 @@ struct parser {\n                 && self.look_ahead(1u) == token::BINOP(token::AND) {\n \n                 self.expect(token::BINOP(token::SLASH));\n-                some(self.parse_region())\n+                Some(self.parse_region())\n             } else {\n-                none\n+                None\n             }\n         };\n \n         // Parse any type parameters which may appear:\n         let tps = {\n             if self.token == token::LT {\n-                self.parse_seq_lt_gt(some(token::COMMA),\n+                self.parse_seq_lt_gt(Some(token::COMMA),\n                                      |p| p.parse_ty(false))\n             } else {\n                 {node: ~[], span: path.span}\n@@ -837,7 +837,7 @@ struct parser {\n         let mut ex: expr_;\n \n         match self.maybe_parse_dollar_mac() {\n-          some(x) => return pexpr(self.mk_mac_expr(lo, self.span.hi, x)),\n+          Some(x) => return pexpr(self.mk_mac_expr(lo, self.span.hi, x)),\n           _ => ()\n         }\n \n@@ -941,8 +941,8 @@ struct parser {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n-                ex = expr_fail(some(e));\n-            } else { ex = expr_fail(none); }\n+                ex = expr_fail(Some(e));\n+            } else { ex = expr_fail(None); }\n         } else if self.eat_keyword(~\"log\") {\n             self.expect(token::LPAREN);\n             let lvl = self.parse_expr();\n@@ -959,20 +959,20 @@ struct parser {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n-                ex = expr_ret(some(e));\n-            } else { ex = expr_ret(none); }\n+                ex = expr_ret(Some(e));\n+            } else { ex = expr_ret(None); }\n         } else if self.eat_keyword(~\"break\") {\n             if is_ident(self.token) {\n-                ex = expr_break(some(self.parse_ident()));\n+                ex = expr_break(Some(self.parse_ident()));\n             } else {\n-                ex = expr_break(none);\n+                ex = expr_break(None);\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(~\"again\") {\n             if is_ident(self.token) {\n-                ex = expr_again(some(self.parse_ident()));\n+                ex = expr_again(Some(self.parse_ident()));\n             } else {\n-                ex = expr_again(none);\n+                ex = expr_again(None);\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(~\"copy\") {\n@@ -1020,9 +1020,9 @@ struct parser {\n \n                     let base;\n                     if self.eat_keyword(~\"with\") || self.eat(token::DOTDOT) {\n-                        base = some(self.parse_expr());\n+                        base = Some(self.parse_expr());\n                     } else {\n-                        base = none;\n+                        base = None;\n                     }\n \n                     hi = pth.span.hi;\n@@ -1045,8 +1045,8 @@ struct parser {\n         match ex {\n           expr_lit(@{node: lit_str(_), span: _}) |\n           expr_vec(_, _)  => match self.maybe_parse_fixed_vstore() {\n-            none => (),\n-            some(v) => {\n+            None => (),\n+            Some(v) => {\n                 hi = self.span.hi;\n                 ex = expr_vstore(self.mk_expr(lo, hi, ex), vstore_fixed(v));\n             }\n@@ -1077,7 +1077,7 @@ struct parser {\n         let pth = self.parse_path_without_tps();\n         //temporary for a backwards-compatible cycle:\n         let sep = seq_sep_trailing_disallowed(token::COMMA);\n-        let mut e = none;\n+        let mut e = None;\n         if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n             let lo = self.span.lo;\n             let es =\n@@ -1089,9 +1089,9 @@ struct parser {\n                                              sep, |p| p.parse_expr())\n                 };\n             let hi = self.span.hi;\n-            e = some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n+            e = Some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n         }\n-        let mut b = none;\n+        let mut b = None;\n         if self.token == token::LBRACE {\n             self.bump();\n             let lo = self.span.lo;\n@@ -1106,7 +1106,7 @@ struct parser {\n                 self.bump();\n             }\n             let hi = self.last_span.lo;\n-            b = some({span: mk_sp(lo,hi)});\n+            b = Some({span: mk_sp(lo,hi)});\n         }\n         return self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n     }\n@@ -1133,7 +1133,7 @@ struct parser {\n                     self.bump();\n                     let tys = if self.eat(token::MOD_SEP) {\n                         self.expect(token::LT);\n-                        self.parse_seq_to_gt(some(token::COMMA),\n+                        self.parse_seq_to_gt(Some(token::COMMA),\n                                              |p| p.parse_ty(false))\n                     } else { ~[] };\n                     e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e), i,\n@@ -1172,20 +1172,20 @@ struct parser {\n         return e;\n     }\n \n-    fn parse_sep_and_zerok() -> (option<token::token>, bool) {\n+    fn parse_sep_and_zerok() -> (Option<token::token>, bool) {\n         if self.token == token::BINOP(token::STAR)\n             || self.token == token::BINOP(token::PLUS) {\n             let zerok = self.token == token::BINOP(token::STAR);\n             self.bump();\n-            return (none, zerok);\n+            return (None, zerok);\n         } else {\n             let sep = self.token;\n             self.bump();\n             if self.token == token::BINOP(token::STAR)\n                 || self.token == token::BINOP(token::PLUS) {\n                 let zerok = self.token == token::BINOP(token::STAR);\n                 self.bump();\n-                return (some(sep), zerok);\n+                return (Some(sep), zerok);\n             } else {\n                 self.fatal(~\"expected `*` or `+`\");\n             }\n@@ -1347,7 +1347,7 @@ struct parser {\n                 ex = match e.node {\n                   expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n                   if m == m_imm => {\n-                    expr_vstore(e, vstore_slice(self.region_from_name(none)))\n+                    expr_vstore(e, vstore_slice(self.region_from_name(None)))\n                   }\n                   _ => expr_addr_of(m, e)\n                 };\n@@ -1405,7 +1405,7 @@ struct parser {\n         }\n         let cur_opt   = token_to_binop(peeked);\n         match cur_opt {\n-          some(cur_op) => {\n+          Some(cur_op) => {\n             let cur_prec = operator_prec(cur_op);\n             if cur_prec > min_prec {\n                 self.bump();\n@@ -1476,11 +1476,11 @@ struct parser {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n-        let mut els: option<@expr> = none;\n+        let mut els: Option<@expr> = None;\n         let mut hi = thn.span.hi;\n         if self.eat_keyword(~\"else\") {\n             let elexpr = self.parse_else_expr();\n-            els = some(elexpr);\n+            els = Some(elexpr);\n             hi = elexpr.span.hi;\n         }\n         let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n@@ -1542,7 +1542,7 @@ struct parser {\n         let lo = self.last_span.lo;\n         let (decl, captures) = parse_decl();\n         let body = parse_body();\n-        let fakeblock = {view_items: ~[], stmts: ~[], expr: some(body),\n+        let fakeblock = {view_items: ~[], stmts: ~[], expr: Some(body),\n                          id: self.get_id(), rules: default_blk};\n         let fakeblock = spanned(body.span.lo, body.span.hi,\n                                 fakeblock);\n@@ -1610,10 +1610,10 @@ struct parser {\n     fn parse_loop_expr() -> @expr {\n         let opt_ident;\n         if is_ident(self.token) && !self.is_any_keyword(copy self.token) {\n-            opt_ident = some(self.parse_ident());\n+            opt_ident = Some(self.parse_ident());\n             self.expect(token::COLON);\n         } else {\n-            opt_ident = none;\n+            opt_ident = None;\n         }\n \n         let lo = self.last_span.lo;\n@@ -1634,13 +1634,13 @@ struct parser {\n     fn parse_record_literal() -> expr_ {\n         self.expect(token::LBRACE);\n         let mut fields = ~[self.parse_field(token::COLON)];\n-        let mut base = none;\n+        let mut base = None;\n         while self.token != token::RBRACE {\n             if self.token == token::COMMA\n                 && self.look_ahead(1) == token::DOTDOT {\n                 self.bump();\n                 self.bump();\n-                base = some(self.parse_expr()); break;\n+                base = Some(self.parse_expr()); break;\n             }\n \n             // XXX: Remove \"with\" after all code is converted over and there's\n@@ -1653,7 +1653,7 @@ struct parser {\n                 self.bump();\n             }\n             if self.eat_keyword(~\"with\") {\n-                base = some(self.parse_expr()); break;\n+                base = Some(self.parse_expr()); break;\n             }\n             self.expect(token::COMMA);\n             if self.token == token::RBRACE {\n@@ -1673,8 +1673,8 @@ struct parser {\n         let mut arms: ~[arm] = ~[];\n         while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n-            let mut guard = none;\n-            if self.eat_keyword(~\"if\") { guard = some(self.parse_expr()); }\n+            let mut guard = None;\n+            if self.eat_keyword(~\"if\") { guard = Some(self.parse_expr()); }\n             self.expect(token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n@@ -1690,7 +1690,7 @@ struct parser {\n \n             let blk = {node: {view_items: ~[],\n                               stmts: ~[],\n-                              expr: some(expr),\n+                              expr: Some(expr),\n                               id: self.get_id(),\n                               rules: default_blk},\n                        span: expr.span};\n@@ -1714,25 +1714,25 @@ struct parser {\n         return e;\n     }\n \n-    fn parse_initializer() -> option<initializer> {\n+    fn parse_initializer() -> Option<initializer> {\n         match self.token {\n           token::EQ => {\n             self.bump();\n-            return some({op: init_assign, expr: self.parse_expr()});\n+            return Some({op: init_assign, expr: self.parse_expr()});\n           }\n           token::LARROW => {\n             self.bump();\n-            return some({op: init_move, expr: self.parse_expr()});\n+            return Some({op: init_move, expr: self.parse_expr()});\n           }\n           // Now that the the channel is the first argument to receive,\n           // combining it with an initializer doesn't really make sense.\n           // case (token::RECV) {\n           //     self.bump();\n-          //     return some(rec(op = init_recv,\n+          //     return Some(rec(op = init_recv,\n           //                  expr = self.parse_expr()));\n           // }\n           _ => {\n-            return none;\n+            return None;\n           }\n         }\n     }\n@@ -1783,7 +1783,7 @@ struct parser {\n                     id: self.get_id(),\n                     node: pat_ident(bind_by_implicit_ref,\n                                     fieldpath,\n-                                    none),\n+                                    None),\n                     span: self.last_span\n                 };\n             }\n@@ -1911,9 +1911,9 @@ struct parser {\n                     let name = self.parse_value_path();\n                     let sub;\n                     if self.eat(token::AT) {\n-                        sub = some(self.parse_pat(refutable));\n+                        sub = Some(self.parse_pat(refutable));\n                     } else {\n-                        sub = none;\n+                        sub = None;\n                     };\n                     pat = pat_ident(binding_mode, name, sub);\n                 } else {\n@@ -1950,16 +1950,16 @@ struct parser {\n                             // at this point, we're not sure whether it's a\n                             // enum or a bind\n                             if star_pat {\n-                                pat = pat_enum(enum_path, none);\n+                                pat = pat_enum(enum_path, None);\n                             }\n                             else if vec::is_empty(args) &&\n                                 vec::len(enum_path.idents) == 1u {\n                                 pat = pat_ident(binding_mode,\n                                                 enum_path,\n-                                                none);\n+                                                None);\n                             }\n                             else {\n-                                pat = pat_enum(enum_path, some(args));\n+                                pat = pat_enum(enum_path, Some(args));\n                             }\n                         }\n                     }\n@@ -1980,11 +1980,11 @@ struct parser {\n         }\n         let name = self.parse_value_path();\n         let sub = if self.eat(token::AT) {\n-            some(self.parse_pat(refutable))\n-        } else { none };\n+            Some(self.parse_pat(refutable))\n+        } else { None };\n \n         // just to be friendly, if they write something like\n-        //   ref some(i)\n+        //   ref Some(i)\n         // we end up here with ( as the current token.  This shortly\n         // leads to a parse error.  Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n@@ -2007,19 +2007,19 @@ struct parser {\n                 self.expect(token::LPAREN);\n                 self.expect(token::BINOP(token::STAR));\n                 self.expect(token::RPAREN);\n-                pat_enum(enum_path, none)\n+                pat_enum(enum_path, None)\n               }\n               _ => { // foo(a, ..., z)\n                 let args = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_pat(refutable));\n-                pat_enum(enum_path, some(args))\n+                pat_enum(enum_path, Some(args))\n               }\n             }\n           }\n-          _ => { // option::none\n-            pat_enum(enum_path, some(~[]))\n+          _ => { // option::None\n+            pat_enum(enum_path, Some(~[]))\n           }\n         }\n     }\n@@ -2032,7 +2032,7 @@ struct parser {\n                        node: ty_infer,\n                        span: mk_sp(lo, lo)};\n         if self.eat(token::COLON) { ty = self.parse_ty(false); }\n-        let init = if allow_init { self.parse_initializer() } else { none };\n+        let init = if allow_init { self.parse_initializer() } else { None };\n         return @spanned(lo, self.last_span.hi,\n                      {is_mutbl: is_mutbl, ty: ty, pat: pat,\n                       init: init, id: self.get_id()});\n@@ -2087,9 +2087,9 @@ struct parser {\n         } else {\n             let mut item_attrs;\n             match self.parse_outer_attrs_or_ext(first_item_attrs) {\n-              none => item_attrs = ~[],\n-              some(Left(attrs)) => item_attrs = attrs,\n-              some(Right(ext)) => {\n+              None => item_attrs = ~[],\n+              Some(Left(attrs)) => item_attrs = attrs,\n+              Some(Right(ext)) => {\n                 return @spanned(lo, ext.span.hi,\n                                 stmt_expr(ext, self.get_id()));\n               }\n@@ -2180,7 +2180,7 @@ struct parser {\n     fn parse_block_tail_(lo: uint, s: blk_check_mode,\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n-        let mut expr = none;\n+        let mut expr = None;\n \n         let {attrs_remaining, view_items, items: items} =\n             self.parse_items_and_view_items(first_item_attrs,\n@@ -2215,7 +2215,7 @@ struct parser {\n                              @{node: stmt_semi(e, stmt_id) with *stmt});\n                       }\n                       token::RBRACE => {\n-                        expr = some(e);\n+                        expr = Some(e);\n                       }\n                       t => {\n                         if classify::stmt_ends_with_semi(*stmt) {\n@@ -2274,7 +2274,7 @@ struct parser {\n \n     fn parse_ty_params() -> ~[ty_param] {\n         if self.eat(token::LT) {\n-            self.parse_seq_to_gt(some(token::COMMA), |p| p.parse_ty_param())\n+            self.parse_seq_to_gt(Some(token::COMMA), |p| p.parse_ty_param())\n         } else { ~[] }\n     }\n \n@@ -2444,7 +2444,7 @@ struct parser {\n         let t = self.parse_fn_header();\n         let (decl, _) = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (t.ident, item_fn(decl, purity, t.tps, body), some(inner_attrs))\n+        (t.ident, item_fn(decl, purity, t.tps, body), Some(inner_attrs))\n     }\n \n     fn parse_method_name() -> ident {\n@@ -2490,7 +2490,7 @@ struct parser {\n         }\n \n         let meths = self.parse_trait_methods();\n-        (ident, item_trait(tps, traits, meths), none)\n+        (ident, item_trait(tps, traits, meths), None)\n     }\n \n     // Parses four variants (with the region/type params always optional):\n@@ -2531,7 +2531,7 @@ struct parser {\n         while !self.eat(token::RBRACE) {\n             vec::push(meths, self.parse_method(public));\n         }\n-        (ident, item_impl(tps, traits, ty, meths), none)\n+        (ident, item_impl(tps, traits, ty, meths), None)\n     }\n \n     // Instantiates ident <i> with references to <typarams> as arguments.\n@@ -2542,7 +2542,7 @@ struct parser {\n         let s = self.last_span;\n \n         @{span: s, global: false, idents: ~[i],\n-          rp: none,\n+          rp: None,\n           types: vec::map(typarams, |tp| {\n               @{id: self.get_id(),\n                 node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n@@ -2572,9 +2572,9 @@ struct parser {\n \n         let mut fields: ~[@struct_field];\n         let mut methods: ~[@method] = ~[];\n-        let mut the_ctor: option<(fn_decl, ~[attribute], blk, codemap::span)>\n-            = none;\n-        let mut the_dtor: option<(blk, ~[attribute], codemap::span)> = none;\n+        let mut the_ctor: Option<(fn_decl, ~[attribute], blk, codemap::span)>\n+            = None;\n+        let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let ctor_id = self.get_id();\n \n         if self.eat(token::LBRACE) {\n@@ -2584,29 +2584,29 @@ struct parser {\n                 match self.parse_class_item(class_path) {\n                   ctor_decl(a_fn_decl, attrs, blk, s) => {\n                       match the_ctor {\n-                        some((_, _, _, s_first)) => {\n+                        Some((_, _, _, s_first)) => {\n                           self.span_note(s, #fmt(\"Duplicate constructor \\\n                                      declaration for class %s\",\n                                      *self.interner.get(class_name)));\n                            self.span_fatal(copy s_first, ~\"First constructor \\\n                                                           declared here\");\n                         }\n-                        none    => {\n-                          the_ctor = some((a_fn_decl, attrs, blk, s));\n+                        None    => {\n+                          the_ctor = Some((a_fn_decl, attrs, blk, s));\n                         }\n                       }\n                   }\n                   dtor_decl(blk, attrs, s) => {\n                       match the_dtor {\n-                        some((_, _, s_first)) => {\n+                        Some((_, _, s_first)) => {\n                           self.span_note(s, #fmt(\"Duplicate destructor \\\n                                      declaration for class %s\",\n                                      *self.interner.get(class_name)));\n                           self.span_fatal(copy s_first, ~\"First destructor \\\n                                                           declared here\");\n                         }\n-                        none => {\n-                          the_dtor = some((blk, attrs, s));\n+                        None => {\n+                          the_dtor = Some((blk, attrs, s));\n                         }\n                       }\n                   }\n@@ -2654,13 +2654,13 @@ struct parser {\n                     body: d_body},\n              span: d_s}};\n         match the_ctor {\n-          some((ct_d, ct_attrs, ct_b, ct_s)) => {\n+          Some((ct_d, ct_attrs, ct_b, ct_s)) => {\n             (class_name,\n              item_class(@{\n                 traits: traits,\n                 fields: move fields,\n                 methods: move methods,\n-                ctor: some({\n+                ctor: Some({\n                  node: {id: ctor_id,\n                         attrs: ct_attrs,\n                         self_id: self.get_id(),\n@@ -2669,18 +2669,18 @@ struct parser {\n                  span: ct_s}),\n                 dtor: actual_dtor\n              }, ty_params),\n-             none)\n+             None)\n           }\n-          none => {\n+          None => {\n             (class_name,\n              item_class(@{\n                     traits: traits,\n                     fields: move fields,\n                     methods: move methods,\n-                    ctor: none,\n+                    ctor: None,\n                     dtor: actual_dtor\n              }, ty_params),\n-             none)\n+             None)\n           }\n         }\n     }\n@@ -2829,7 +2829,7 @@ struct parser {\n         self.expect(token::EQ);\n         let e = self.parse_expr();\n         self.expect(token::SEMI);\n-        (id, item_const(ty, e), none)\n+        (id, item_const(ty, e), None)\n     }\n \n     fn parse_item_mod() -> item_info {\n@@ -2838,7 +2838,7 @@ struct parser {\n         let inner_attrs = self.parse_inner_attrs_and_next();\n         let m = self.parse_mod_items(token::RBRACE, inner_attrs.next);\n         self.expect(token::RBRACE);\n-        (id, item_mod(m), some(inner_attrs.inner))\n+        (id, item_mod(m), Some(inner_attrs.inner))\n     }\n \n     fn parse_item_foreign_fn(+attrs: ~[attribute]) -> @foreign_item {\n@@ -2929,7 +2929,7 @@ struct parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                           item_foreign_mod(m), visibility,\n                                           maybe_append(attrs,\n-                                                       some(extra_attrs.\n+                                                       Some(extra_attrs.\n                                                             inner))));\n         }\n \n@@ -2957,7 +2957,7 @@ struct parser {\n         self.expect(token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(token::SEMI);\n-        (t.ident, item_ty(ty, tps), none)\n+        (t.ident, item_ty(ty, tps), None)\n     }\n \n     fn parse_region_param() {\n@@ -2967,7 +2967,7 @@ struct parser {\n     }\n \n     fn parse_struct_def(path: @path) -> @struct_def {\n-        let mut the_dtor: option<(blk, ~[attribute], codemap::span)> = none;\n+        let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n         let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n@@ -2980,15 +2980,15 @@ struct parser {\n                 }\n                 dtor_decl(blk, attrs, s) => {\n                     match the_dtor {\n-                        some((_, _, s_first)) => {\n+                        Some((_, _, s_first)) => {\n                             self.span_note(s, ~\"duplicate destructor \\\n                                                 declaration\");\n                             self.span_fatal(copy s_first,\n                                             ~\"first destructor \\\n                                               declared here\");\n                         }\n-                        none => {\n-                            the_dtor = some((blk, attrs, s));\n+                        None => {\n+                            the_dtor = Some((blk, attrs, s));\n                         }\n                     }\n                 }\n@@ -3018,7 +3018,7 @@ struct parser {\n             traits: ~[],\n             fields: move fields,\n             methods: move methods,\n-            ctor: none,\n+            ctor: None,\n             dtor: actual_dtor\n         };\n     }\n@@ -3027,7 +3027,7 @@ struct parser {\n                    -> enum_def {\n         let mut variants: ~[variant] = ~[];\n         let mut all_nullary = true, have_disr = false;\n-        let mut common_fields = none;\n+        let mut common_fields = None;\n \n         while self.token != token::RBRACE {\n             let variant_attrs = self.parse_outer_attributes();\n@@ -3040,15 +3040,15 @@ struct parser {\n                 }\n                 self.expect(token::LBRACE);\n                 let path = self.ident_to_path_tys(ident, ty_params);\n-                common_fields = some(self.parse_struct_def(path));\n+                common_fields = Some(self.parse_struct_def(path));\n                 again;\n             }\n \n             let vis = self.parse_visibility();\n \n             // Is this a nested enum declaration?\n             let ident, needs_comma, kind;\n-            let mut args = ~[], disr_expr = none;\n+            let mut args = ~[], disr_expr = None;\n             if self.eat_keyword(~\"enum\") {\n                 ident = self.parse_ident();\n                 self.expect(token::LBRACE);\n@@ -3074,7 +3074,7 @@ struct parser {\n                     kind = tuple_variant_kind(args);\n                 } else if self.eat(token::EQ) {\n                     have_disr = true;\n-                    disr_expr = some(self.parse_expr());\n+                    disr_expr = Some(self.parse_expr());\n                     kind = tuple_variant_kind(args);\n                 } else {\n                     kind = tuple_variant_kind(~[]);\n@@ -3115,16 +3115,16 @@ struct parser {\n                          kind: tuple_variant_kind\n                             (~[{ty: ty, id: self.get_id()}]),\n                          id: self.get_id(),\n-                         disr_expr: none,\n+                         disr_expr: None,\n                          vis: public});\n             return (id, item_enum(enum_def({ variants: ~[variant],\n-                                             common: none }),\n-                                  ty_params), none);\n+                                             common: None }),\n+                                  ty_params), None);\n         }\n         self.expect(token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(id, ty_params);\n-        (id, item_enum(enum_definition, ty_params), none)\n+        (id, item_enum(enum_definition, ty_params), None)\n     }\n \n     fn parse_fn_ty_proto() -> proto {\n@@ -3278,7 +3278,7 @@ struct parser {\n             let m: ast::mac = {node: m,\n                                span: {lo: self.span.lo,\n                                       hi: self.span.hi,\n-                                      expn_info: none}};\n+                                      expn_info: None}};\n             let item_ = item_mac(m);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));\n@@ -3287,14 +3287,14 @@ struct parser {\n         };\n     }\n \n-    fn parse_item(+attrs: ~[attribute]) -> option<@ast::item> {\n+    fn parse_item(+attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n-                none,\n+                None,\n             iovi_view_item(_) =>\n                 self.fatal(~\"view items are not allowed here\"),\n             iovi_item(item) =>\n-                some(item)\n+                Some(item)\n         }\n     }\n \n@@ -3326,7 +3326,7 @@ struct parser {\n                 vec::push(path, id);\n             }\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n-                         idents: path, rp: none, types: ~[]};\n+                         idents: path, rp: None, types: ~[]};\n             return @spanned(lo, self.span.hi,\n                          view_path_simple(first_ident, path, self.get_id()));\n           }\n@@ -3351,7 +3351,7 @@ struct parser {\n                         |p| p.parse_path_list_ident());\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n-                                 rp: none, types: ~[]};\n+                                 rp: None, types: ~[]};\n                     return @spanned(lo, self.span.hi,\n                                  view_path_list(path, idents, self.get_id()));\n                   }\n@@ -3361,7 +3361,7 @@ struct parser {\n                     self.bump();\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n-                                 rp: none, types: ~[]};\n+                                 rp: None, types: ~[]};\n                     return @spanned(lo, self.span.hi,\n                                  view_path_glob(path, self.get_id()));\n                   }\n@@ -3374,7 +3374,7 @@ struct parser {\n         }\n         let last = path[vec::len(path) - 1u];\n         let path = @{span: mk_sp(lo, self.span.hi), global: false,\n-                     idents: path, rp: none, types: ~[]};\n+                     idents: path, rp: None, types: ~[]};\n         return @spanned(lo, self.span.hi,\n                      view_path_simple(last, path, self.get_id()));\n     }"}, {"sha": "872ffeb84a5315ce22d99108fbc5c419fe6d1b9f", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -19,27 +19,27 @@ const as_prec: uint = 11u;\n  * Maps a token to a record specifying the corresponding binary\n  * operator and its precedence\n  */\n-fn token_to_binop(tok: token) -> option<ast::binop> {\n+fn token_to_binop(tok: token) -> Option<ast::binop> {\n   match tok {\n-      BINOP(STAR)    => some(mul),\n-      BINOP(SLASH)   => some(div),\n-      BINOP(PERCENT) => some(rem),\n+      BINOP(STAR)    => Some(mul),\n+      BINOP(SLASH)   => Some(div),\n+      BINOP(PERCENT) => Some(rem),\n       // 'as' sits between here with 11\n-      BINOP(PLUS)    => some(add),\n-      BINOP(MINUS)   => some(subtract),\n-      BINOP(SHL)     => some(shl),\n-      BINOP(SHR)     => some(shr),\n-      BINOP(AND)     => some(bitand),\n-      BINOP(CARET)   => some(bitxor),\n-      BINOP(OR)      => some(bitor),\n-      LT             => some(lt),\n-      LE             => some(le),\n-      GE             => some(ge),\n-      GT             => some(gt),\n-      EQEQ           => some(eq),\n-      NE             => some(ne),\n-      ANDAND         => some(and),\n-      OROR           => some(or),\n-      _              => none\n+      BINOP(PLUS)    => Some(add),\n+      BINOP(MINUS)   => Some(subtract),\n+      BINOP(SHL)     => Some(shl),\n+      BINOP(SHR)     => Some(shr),\n+      BINOP(AND)     => Some(bitand),\n+      BINOP(CARET)   => Some(bitxor),\n+      BINOP(OR)      => Some(bitor),\n+      LT             => Some(lt),\n+      LE             => Some(le),\n+      GE             => Some(ge),\n+      GT             => Some(gt),\n+      EQEQ           => Some(eq),\n+      NE             => Some(ne),\n+      ANDAND         => Some(and),\n+      OROR           => Some(or),\n+      _              => None\n   }\n }"}, {"sha": "846a7e7c88e275b59f208e5d56f41f90a958651d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -349,7 +349,7 @@ fn mk_ident_interner() -> ident_interner {\n                                            |x,y| str::eq(*x, *y), init_vec);\n \n     /* having multiple interners will just confuse the serializer */\n-    unsafe{ assert task::local_data_get(interner_key!()) == none };\n+    unsafe{ assert task::local_data_get(interner_key!()) == None };\n     unsafe{ task::local_data_set(interner_key!(), @rv) };\n     rv\n }"}, {"sha": "4ebdcd03040778eea22e0bf06287934e1b9e75cc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -26,10 +26,10 @@ fn no_ann() -> pp_ann {\n \n type ps =\n     @{s: pp::printer,\n-      cm: option<codemap>,\n+      cm: Option<codemap>,\n       intr: token::ident_interner,\n-      comments: option<~[comments::cmnt]>,\n-      literals: option<~[comments::lit]>,\n+      comments: Option<~[comments::cmnt]>,\n+      literals: Option<~[comments::lit]>,\n       mut cur_cmnt: uint,\n       mut cur_lit: uint,\n       boxes: DVec<pp::breaks>,\n@@ -47,10 +47,10 @@ fn end(s: ps) {\n \n fn rust_printer(writer: io::Writer, intr: ident_interner) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n-             cm: none::<codemap>,\n+             cm: None::<codemap>,\n              intr: intr,\n-             comments: none::<~[comments::cmnt]>,\n-             literals: none::<~[comments::lit]>,\n+             comments: None::<~[comments::cmnt]>,\n+             literals: None::<~[comments::lit]>,\n              mut cur_cmnt: 0u,\n              mut cur_lit: 0u,\n              boxes: dvec(),\n@@ -73,13 +73,13 @@ fn print_crate(cm: codemap, intr: ident_interner,\n                                                    filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n-          cm: some(cm),\n+          cm: Some(cm),\n           intr: intr,\n-          comments: some(r.cmnts),\n+          comments: Some(r.cmnts),\n           // If the code is post expansion, don't use the table of\n           // literals, since it doesn't correspond with the literals\n           // in the AST anymore.\n-          literals: if is_expanded { none } else { some(r.lits) },\n+          literals: if is_expanded { None } else { Some(r.lits) },\n           mut cur_cmnt: 0u,\n           mut cur_lit: 0u,\n           boxes: dvec(),\n@@ -129,7 +129,7 @@ fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: ~[ast::ty_param], intr: ident_interner) -> ~str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer), intr);\n-    print_fn(s, decl, none, name, params, none);\n+    print_fn(s, decl, None, name, params, None);\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n@@ -302,7 +302,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n         if i < len {\n             word(s.s, ~\",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n-                                         some(get_span(elts[i]).hi));\n+                                         Some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n@@ -391,7 +391,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         pclose(s);\n       }\n       ast::ty_fn(proto, purity, bounds, d) => {\n-        print_ty_fn(s, some(proto), purity, bounds, d, none, none, none);\n+        print_ty_fn(s, Some(proto), purity, bounds, d, None, None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n       ast::ty_fixed_length(t, v) => {\n@@ -416,7 +416,7 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n       ast::foreign_item_fn(decl, purity, typarams) => {\n-        print_fn(s, decl, some(purity), item.ident, typarams, none);\n+        print_fn(s, decl, Some(purity), item.ident, typarams, None);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n         end(s); // end the outer fn box\n@@ -454,7 +454,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n \n       }\n       ast::item_fn(decl, purity, typarams, body) => {\n-        print_fn(s, decl, some(purity), item.ident, typarams, none);\n+        print_fn(s, decl, Some(purity), item.ident, typarams, None);\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n@@ -595,7 +595,7 @@ fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n         print_variant(s, v);\n         word(s.s, ~\",\");\n         end(s);\n-        maybe_print_trailing_comment(s, v.span, none::<uint>);\n+        maybe_print_trailing_comment(s, v.span, None::<uint>);\n     }\n     bclose(s, span);\n }\n@@ -619,7 +619,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n       cbox(s, indent_unit);\n       ibox(s, 4);\n       word(s.s, ~\"new(\");\n-      print_fn_args(s, ctor.node.dec, ~[], none);\n+      print_fn_args(s, ctor.node.dec, ~[], None);\n       word(s.s, ~\")\");\n       space(s.s);\n       print_block(s, ctor.node.body);\n@@ -681,8 +681,8 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n         for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, ~\")\");\n         match sep {\n-          some(tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n-          none => ()\n+          Some(tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n+          None => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n         s.s.token_tree_last_was_ident = false;\n@@ -717,7 +717,7 @@ fn print_variant(s: ps, v: ast::variant) {\n         }\n     }\n     match v.node.disr_expr {\n-      some(d) => {\n+      Some(d) => {\n         space(s.s);\n         word_space(s, ~\"=\");\n         print_expr(s, d);\n@@ -730,9 +730,9 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, none, m.purity,\n-                @~[], m.decl, some(m.ident), some(m.tps),\n-                some(m.self_ty.node));\n+    print_ty_fn(s, None, m.purity,\n+                @~[], m.decl, Some(m.ident), Some(m.tps),\n+                Some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n \n@@ -747,8 +747,8 @@ fn print_method(s: ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, meth.decl, some(meth.purity),\n-             meth.ident, meth.tps, some(meth.self_ty.node));\n+    print_fn(s, meth.decl, Some(meth.purity),\n+             meth.ident, meth.tps, Some(meth.self_ty.node));\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n@@ -813,7 +813,7 @@ fn print_stmt(s: ps, st: ast::stmt) {\n       }\n     }\n     if parse::classify::stmt_ends_with_semi(st) { word(s.s, ~\";\"); }\n-    maybe_print_trailing_comment(s, st.span, none::<uint>);\n+    maybe_print_trailing_comment(s, st.span, None::<uint>);\n }\n \n fn print_block(s: ps, blk: ast::blk) {\n@@ -866,10 +866,10 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n         print_stmt(s, *st);\n     }\n     match blk.node.expr {\n-      some(expr) => {\n+      Some(expr) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n-        maybe_print_trailing_comment(s, expr.span, some(blk.span.hi));\n+        maybe_print_trailing_comment(s, expr.span, Some(blk.span.hi));\n       }\n       _ => ()\n     }\n@@ -881,7 +881,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig = match e.node {\n-      ast::expr_ret(none) | ast::expr_fail(none) => true,\n+      ast::expr_ret(None) | ast::expr_fail(None) => true,\n       _ => false\n     };\n     if disambig { popen(s); }\n@@ -890,15 +890,15 @@ fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n }\n \n fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n-            elseopt: option<@ast::expr>, chk: bool) {\n+            elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n     print_maybe_parens_discrim(s, test);\n     space(s.s);\n     print_block(s, blk);\n-    fn do_else(s: ps, els: option<@ast::expr>) {\n+    fn do_else(s: ps, els: Option<@ast::expr>) {\n         match els {\n-          some(_else) => {\n+          Some(_else) => {\n             match _else.node {\n               // \"another else-if\"\n               ast::expr_if(i, t, e) => {\n@@ -935,7 +935,7 @@ fn print_mac(s: ps, m: ast::mac) {\n         word(s.s, ~\"#\");\n         print_path(s, path, false);\n         match arg {\n-          some(@{node: ast::expr_vec(_, _), _}) => (),\n+          Some(@{node: ast::expr_vec(_, _), _}) => (),\n           _ => word(s.s, ~\" \")\n         }\n         option::iter(arg, |a| print_expr(s, a));\n@@ -956,8 +956,8 @@ fn print_mac(s: ps, m: ast::mac) {\n \n fn print_vstore(s: ps, t: ast::vstore) {\n     match t {\n-      ast::vstore_fixed(some(i)) => word(s.s, fmt!(\"%u\", i)),\n-      ast::vstore_fixed(none) => word(s.s, ~\"_\"),\n+      ast::vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n+      ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n       ast::vstore_uniq => word(s.s, ~\"~\"),\n       ast::vstore_box => word(s.s, ~\"@\"),\n       ast::vstore_slice(r) => match r.node {\n@@ -1029,7 +1029,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         match wth {\n-          some(expr) => {\n+          Some(expr) => {\n             ibox(s, indent_unit);\n             word(s.s, ~\",\");\n             space(s.s);\n@@ -1046,7 +1046,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         match wth {\n-            some(expr) => {\n+            Some(expr) => {\n                 if vec::len(fields) > 0u { space(s.s); }\n                 ibox(s, indent_unit);\n                 word(s.s, ~\",\");\n@@ -1073,8 +1073,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n               ast::expr_do_body(_) => { head(s, ~\"do\"); }\n               _ => {}\n             }\n-            some(blk_arg)\n-        } else { none };\n+            Some(blk_arg)\n+        } else { None };\n         print_expr_parens_if_not_bot(s, func);\n         if !has_block || vec::len(base_args) > 0u {\n             popen(s);\n@@ -1157,20 +1157,20 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             }\n             space(s.s);\n             match arm.guard {\n-              some(e) => {\n+              Some(e) => {\n                 word_space(s, ~\"if\");\n                 print_expr(s, e);\n                 space(s.s);\n               }\n-              none => ()\n+              None => ()\n             }\n             word_space(s, ~\"=>\");\n             // Extract the expression from the extra block the parser adds\n             assert arm.body.node.view_items.is_empty();\n             assert arm.body.node.stmts.is_empty();\n             assert arm.body.node.rules == ast::default_blk;\n             match arm.body.node.expr {\n-              some(expr) => {\n+              Some(expr) => {\n                 match expr.node {\n                   ast::expr_block(blk) => {\n                     // the block will close the pattern's ibox\n@@ -1187,7 +1187,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                 }\n                 end(s); // close enclosing cbox\n               }\n-              none => fail\n+              None => fail\n             }\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n@@ -1197,8 +1197,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n-        word(s.s, fn_header_info_to_str(none, none, some(proto)));\n-        print_fn_args_and_ret(s, decl, *cap_clause, none);\n+        word(s.s, fn_header_info_to_str(None, None, Some(proto)));\n+        print_fn_args_and_ret(s, decl, *cap_clause, None);\n         space(s.s);\n         print_block(s, body);\n       }\n@@ -1299,7 +1299,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_fail(maybe_fail_val) => {\n         word(s.s, ~\"fail\");\n         match maybe_fail_val {\n-          some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n+          Some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n@@ -1316,7 +1316,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n         match result {\n-          some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n+          Some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n@@ -1389,7 +1389,7 @@ fn print_decl(s: ps, decl: @ast::decl) {\n             print_local_decl(s, loc);\n             end(s);\n             match loc.node.init {\n-              some(init) => {\n+              Some(init) => {\n                 nbsp(s);\n                 match init.op {\n                   ast::init_assign => word_space(s, ~\"=\"),\n@@ -1428,8 +1428,8 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n         if colons_before_params { word(s.s, ~\"::\"); }\n \n         match path.rp {\n-          none => { /* ok */ }\n-          some(r) => {\n+          None => { /* ok */ }\n+          Some(r) => {\n             word(s.s, ~\"/\");\n             print_region(s, r);\n           }\n@@ -1465,15 +1465,15 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         }\n         print_path(s, path, true);\n         match sub {\n-          some(p) => { word(s.s, ~\"@\"); print_pat(s, p); }\n-          none => ()\n+          Some(p) => { word(s.s, ~\"@\"); print_pat(s, p); }\n+          None => ()\n         }\n       }\n       ast::pat_enum(path, args_) => {\n         print_path(s, path, true);\n         match args_ {\n-          none => word(s.s, ~\"(*)\"),\n-          some(args) => {\n+          None => word(s.s, ~\"(*)\"),\n+          Some(args) => {\n             if vec::len(args) > 0u {\n               popen(s);\n               commasep(s, inconsistent, args, print_pat);\n@@ -1553,19 +1553,19 @@ fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     return true;\n }\n \n-fn print_fn(s: ps, decl: ast::fn_decl, purity: option<ast::purity>,\n+fn print_fn(s: ps, decl: ast::fn_decl, purity: Option<ast::purity>,\n             name: ast::ident,\n             typarams: ~[ast::ty_param],\n-            opt_self_ty: option<ast::self_ty_>) {\n-    head(s, fn_header_info_to_str(opt_self_ty, purity, none));\n+            opt_self_ty: Option<ast::self_ty_>) {\n+    head(s, fn_header_info_to_str(opt_self_ty, purity, None));\n     print_ident(s, name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n }\n \n fn print_fn_args(s: ps, decl: ast::fn_decl,\n                  cap_items: ~[ast::capture_item],\n-                 opt_self_ty: option<ast::self_ty_>) {\n+                 opt_self_ty: Option<ast::self_ty_>) {\n     // It is unfortunate to duplicate the commasep logic, but we\n     // we want the self type, the args, and the capture clauses all\n     // in the same box.\n@@ -1592,7 +1592,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n \n fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n                          cap_items: ~[ast::capture_item],\n-                         opt_self_ty: option<ast::self_ty_>) {\n+                         opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n     print_fn_args(s, decl, cap_items, opt_self_ty);\n     pclose(s);\n@@ -1608,7 +1608,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n                        cap_items: ~[ast::capture_item]) {\n     word(s.s, ~\"|\");\n-    print_fn_args(s, decl, cap_items, none);\n+    print_fn_args(s, decl, cap_items, None);\n     word(s.s, ~\"|\");\n     if decl.output.node != ast::ty_infer {\n         space_if_not_bol(s);\n@@ -1779,16 +1779,16 @@ fn print_arg(s: ps, input: ast::arg) {\n     end(s);\n }\n \n-fn print_ty_fn(s: ps, opt_proto: option<ast::proto>, purity: ast::purity,\n+fn print_ty_fn(s: ps, opt_proto: Option<ast::proto>, purity: ast::purity,\n                bounds: @~[ast::ty_param_bound],\n-               decl: ast::fn_decl, id: option<ast::ident>,\n-               tps: option<~[ast::ty_param]>,\n-               opt_self_ty: option<ast::self_ty_>) {\n+               decl: ast::fn_decl, id: Option<ast::ident>,\n+               tps: Option<~[ast::ty_param]>,\n+               opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n-    word(s.s, fn_header_info_to_str(opt_self_ty, some(purity), opt_proto));\n+    word(s.s, fn_header_info_to_str(opt_self_ty, Some(purity), opt_proto));\n     print_bounds(s, bounds);\n-    match id { some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match tps { some(tps) => print_type_params(s, tps), _ => () }\n+    match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n+    match tps { Some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n@@ -1820,16 +1820,16 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>, purity: ast::purity,\n }\n \n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n-                                next_pos: option<uint>) {\n+                                next_pos: Option<uint>) {\n     let mut cm;\n-    match s.cm { some(ccm) => cm = ccm, _ => return }\n+    match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n-      some(cmnt) => {\n+      Some(cmnt) => {\n         if cmnt.style != comments::trailing { return; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n-        match next_pos { none => (), some(p) => next = p }\n+        match next_pos { None => (), Some(p) => next = p }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n             print_comment(s, cmnt);\n@@ -1846,7 +1846,7 @@ fn print_remaining_comments(s: ps) {\n     if option::is_none(next_comment(s)) { hardbreak(s.s); }\n     loop {\n         match next_comment(s) {\n-          some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n+          Some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n           _ => break\n         }\n     }\n@@ -1855,7 +1855,7 @@ fn print_remaining_comments(s: ps) {\n fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n-      some(ltrl) => {\n+      Some(ltrl) => {\n         word(s.s, ltrl.lit);\n         return;\n       }\n@@ -1903,25 +1903,25 @@ fn lit_to_str(l: @ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n+fn next_lit(s: ps, pos: uint) -> Option<comments::lit> {\n     match s.literals {\n-      some(lits) => {\n+      Some(lits) => {\n         while s.cur_lit < vec::len(lits) {\n             let ltrl = lits[s.cur_lit];\n-            if ltrl.pos > pos { return none; }\n+            if ltrl.pos > pos { return None; }\n             s.cur_lit += 1u;\n-            if ltrl.pos == pos { return some(ltrl); }\n+            if ltrl.pos == pos { return Some(ltrl); }\n         }\n-        return none;\n+        return None;\n       }\n-      _ => return none\n+      _ => return None\n     }\n }\n \n fn maybe_print_comment(s: ps, pos: uint) {\n     loop {\n         match next_comment(s) {\n-          some(cmnt) => {\n+          Some(cmnt) => {\n             if cmnt.pos < pos {\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n@@ -1990,43 +1990,43 @@ fn to_str<T>(t: T, f: fn@(ps, T), intr: ident_interner) -> ~str {\n     io::mem_buffer_str(buffer)\n }\n \n-fn next_comment(s: ps) -> option<comments::cmnt> {\n+fn next_comment(s: ps) -> Option<comments::cmnt> {\n     match s.comments {\n-      some(cmnts) => {\n+      Some(cmnts) => {\n         if s.cur_cmnt < vec::len(cmnts) {\n-            return some(cmnts[s.cur_cmnt]);\n-        } else { return none::<comments::cmnt>; }\n+            return Some(cmnts[s.cur_cmnt]);\n+        } else { return None::<comments::cmnt>; }\n       }\n-      _ => return none::<comments::cmnt>\n+      _ => return None::<comments::cmnt>\n     }\n }\n \n-fn fn_header_info_to_str(opt_sty: option<ast::self_ty_>,\n-                         opt_purity: option<ast::purity>,\n-                         opt_p: option<ast::proto>) -> ~str {\n+fn fn_header_info_to_str(opt_sty: Option<ast::self_ty_>,\n+                         opt_purity: Option<ast::purity>,\n+                         opt_p: Option<ast::proto>) -> ~str {\n     let mut s = match opt_sty {\n-      some(ast::sty_static) => ~\"static \",\n+      Some(ast::sty_static) => ~\"static \",\n       _ => ~ \"\"\n     };\n \n     match opt_purity {\n-      some(ast::impure_fn) => { }\n-      some(purity) => {\n+      Some(ast::impure_fn) => { }\n+      Some(purity) => {\n         str::push_str(s, purity_to_str(purity));\n         str::push_char(s, ' ');\n       }\n-      none => {}\n+      None => {}\n     }\n \n     str::push_str(s, opt_proto_to_str(opt_p));\n \n     return s;\n }\n \n-fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n+fn opt_proto_to_str(opt_p: Option<ast::proto>) -> ~str {\n     match opt_p {\n-      none => ~\"fn\",\n-      some(p) => proto_to_str(p)\n+      None => ~\"fn\",\n+      Some(p) => proto_to_str(p)\n     }\n }\n "}, {"sha": "9f738fdc6a2a2195a23c364df8f0335884135403", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -38,8 +38,8 @@ trait interner<T: const copy> {\n impl <T: const copy> hash_interner<T>: interner<T> {\n     fn intern(val: T) -> uint {\n         match self.map.find(val) {\n-          some(idx) => return idx,\n-          none => {\n+          Some(idx) => return idx,\n+          None => {\n             let new_idx = self.vect.len();\n             self.map.insert(val, new_idx);\n             self.vect.push(val);"}, {"sha": "d18869081735ee166d202704747c5c5facb13bf4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -116,8 +116,8 @@ fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n     match loc.node.init {\n-      none => (),\n-      some(i) => v.visit_expr(i.expr, e, v)\n+      None => (),\n+      Some(i) => v.visit_expr(i.expr, e, v)\n     }\n }\n \n@@ -377,8 +377,8 @@ fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n-    match eo { none => (), some(ex) => v.visit_expr(ex, e, v) }\n+fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n+    match eo { None => (), Some(ex) => v.visit_expr(ex, e, v) }\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {"}, {"sha": "671962e168cf60004d4ffee154d0b21e94fba421", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -299,27 +299,27 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n-        {name: option<~str>,\n-         vers: option<~str>,\n+        {name: Option<~str>,\n+         vers: Option<~str>,\n          cmh_items: ~[@ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let mut name: option<~str> = none;\n-        let mut vers: option<~str> = none;\n+        let mut name: Option<~str> = None;\n+        let mut vers: Option<~str> = None;\n         let mut cmh_items: ~[@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n             if attr::get_meta_item_name(meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(meta) {\n-                  some(v) => { name = some(v); }\n-                  none => vec::push(cmh_items, meta)\n+                  Some(v) => { name = Some(v); }\n+                  None => vec::push(cmh_items, meta)\n                 }\n             } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(meta) {\n-                  some(v) => { vers = some(v); }\n-                  none => vec::push(cmh_items, meta)\n+                  Some(v) => { vers = Some(v); }\n+                  None => vec::push(cmh_items, meta)\n                 }\n             } else { vec::push(cmh_items, meta); }\n         }\n@@ -375,13 +375,13 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n     fn crate_meta_name(sess: session, _crate: ast::crate,\n                        output: &Path, metas: provided_metas) -> ~str {\n         return match metas.name {\n-              some(v) => v,\n-              none => {\n+              Some(v) => v,\n+              None => {\n                 let name = match output.filestem() {\n-                  none => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n+                  None => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n                                            appear to have a stem\",\n                                           output.to_str())),\n-                  some(s) => s\n+                  Some(s) => s\n                 };\n                 warn_missing(sess, ~\"name\", name);\n                 name\n@@ -392,8 +392,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n                        metas: provided_metas) -> ~str {\n         return match metas.vers {\n-              some(v) => v,\n-              none => {\n+              Some(v) => v,\n+              None => {\n                 let vers = ~\"0.0\";\n                 warn_missing(sess, ~\"vers\", vers);\n                 vers\n@@ -436,8 +436,8 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n     match ccx.type_hashcodes.find(t) {\n-      some(h) => return h,\n-      none => {\n+      Some(h) => return h,\n+      None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n         return hash;\n@@ -596,7 +596,7 @@ fn link_binary(sess: session,\n \n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each |cratepath| {\n-        if cratepath.filetype() == some(~\"rlib\") {\n+        if cratepath.filetype() == Some(~\"rlib\") {\n             vec::push(cc_args, cratepath.to_str());\n             again;\n         }"}, {"sha": "ceded0cb6d9f28650691c1fb2021442381d1317c", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -131,12 +131,12 @@ enum compile_upto {\n \n fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 input: input, upto: compile_upto,\n-                outputs: option<output_filenames>)\n-    -> {crate: @ast::crate, tcx: option<ty::ctxt>} {\n+                outputs: Option<output_filenames>)\n+    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, ~\"parsing\",\n                          ||parse_input(sess, cfg, input) );\n-    if upto == cu_parse { return {crate: crate, tcx: none}; }\n+    if upto == cu_parse { return {crate: crate, tcx: None}; }\n \n     sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n@@ -151,7 +151,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         syntax::ext::expand::expand_crate(sess.parse_sess, sess.opts.cfg,\n                                           crate));\n \n-    if upto == cu_expand { return {crate: crate, tcx: none}; }\n+    if upto == cu_expand { return {crate: crate, tcx: None}; }\n \n     crate = time(time_passes, ~\"intrinsic injection\", ||\n         front::intrinsic_inject::inject_intrinsic(sess, crate));\n@@ -206,7 +206,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                          method_map, ty_cx));\n \n-    if upto == cu_typeck { return {crate: crate, tcx: some(ty_cx)}; }\n+    if upto == cu_typeck { return {crate: crate, tcx: Some(ty_cx)}; }\n \n     time(time_passes, ~\"loop checking\", ||\n         middle::check_loop::check_crate(ty_cx, crate));\n@@ -226,7 +226,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     time(time_passes, ~\"lint checking\", || lint::check_crate(ty_cx, crate));\n \n-    if upto == cu_no_trans { return {crate: crate, tcx: some(ty_cx)}; }\n+    if upto == cu_no_trans { return {crate: crate, tcx: Some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n     let maps = {mutbl_map: mutbl_map,\n@@ -248,24 +248,24 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         sess.opts.output_type != link::output_type_exe ||\n             sess.opts.static && sess.building_library;\n \n-    if stop_after_codegen { return {crate: crate, tcx: some(ty_cx)}; }\n+    if stop_after_codegen { return {crate: crate, tcx: Some(ty_cx)}; }\n \n     time(time_passes, ~\"linking\", ||\n          link::link_binary(sess,\n                            &outputs.obj_filename,\n                            &outputs.out_filename, link_meta));\n \n-    return {crate: crate, tcx: some(ty_cx)};\n+    return {crate: crate, tcx: Some(ty_cx)};\n }\n \n fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n-                 outdir: &option<Path>, output: &option<Path>) {\n+                 outdir: &Option<Path>, output: &Option<Path>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n                else { cu_everything };\n     let outputs = build_output_filenames(input, outdir, output, sess);\n-    compile_upto(sess, cfg, input, upto, some(outputs));\n+    compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n@@ -320,7 +320,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n       ppm_typed => cu_typeck,\n       _ => cu_parse\n     };\n-    let {crate, tcx} = compile_upto(sess, cfg, input, upto, none);\n+    let {crate, tcx} = compile_upto(sess, cfg, input, upto, None);\n \n     let ann = match ppm {\n       ppm_typed => {\n@@ -342,43 +342,43 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     }\n }\n \n-fn get_os(triple: ~str) -> option<session::os> {\n+fn get_os(triple: ~str) -> Option<session::os> {\n     if str::contains(triple, ~\"win32\") ||\n                str::contains(triple, ~\"mingw32\") {\n-            some(session::os_win32)\n+            Some(session::os_win32)\n         } else if str::contains(triple, ~\"darwin\") {\n-            some(session::os_macos)\n+            Some(session::os_macos)\n         } else if str::contains(triple, ~\"linux\") {\n-            some(session::os_linux)\n+            Some(session::os_linux)\n         } else if str::contains(triple, ~\"freebsd\") {\n-            some(session::os_freebsd)\n-        } else { none }\n+            Some(session::os_freebsd)\n+        } else { None }\n }\n \n-fn get_arch(triple: ~str) -> option<session::arch> {\n+fn get_arch(triple: ~str) -> Option<session::arch> {\n     if str::contains(triple, ~\"i386\") ||\n         str::contains(triple, ~\"i486\") ||\n                str::contains(triple, ~\"i586\") ||\n                str::contains(triple, ~\"i686\") ||\n                str::contains(triple, ~\"i786\") {\n-            some(session::arch_x86)\n+            Some(session::arch_x86)\n         } else if str::contains(triple, ~\"x86_64\") {\n-            some(session::arch_x86_64)\n+            Some(session::arch_x86_64)\n         } else if str::contains(triple, ~\"arm\") ||\n                       str::contains(triple, ~\"xscale\") {\n-            some(session::arch_arm)\n-        } else { none }\n+            Some(session::arch_arm)\n+        } else { None }\n }\n \n fn build_target_config(sopts: @session::options,\n                        demitter: diagnostic::emitter) -> @session::config {\n     let os = match get_os(sopts.target_triple) {\n-      some(os) => os,\n-      none => early_error(demitter, ~\"unknown operating system\")\n+      Some(os) => os,\n+      None => early_error(demitter, ~\"unknown operating system\")\n     };\n     let arch = match get_arch(sopts.target_triple) {\n-      some(arch) => arch,\n-      none => early_error(demitter,\n+      Some(arch) => arch,\n+      None => early_error(demitter,\n                           ~\"unknown architecture: \" + sopts.target_triple)\n     };\n     let (int_type, uint_type, float_type) = match arch {\n@@ -441,11 +441,11 @@ fn build_session_options(matches: getopts::matches,\n         for flags.each |lint_name| {\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n             match lint_dict.find(lint_name) {\n-              none => {\n+              None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));\n               }\n-              some(lint) => {\n+              Some(lint) => {\n                 vec::push(lint_opts, (lint.lint, level));\n               }\n             }\n@@ -514,8 +514,8 @@ fn build_session_options(matches: getopts::matches,\n         } else { No };\n     let target =\n         match target_opt {\n-            none => host_triple(),\n-            some(s) => s\n+            None => host_triple(),\n+            Some(s) => s\n         };\n \n     let addl_lib_search_paths =\n@@ -548,7 +548,7 @@ fn build_session(sopts: @session::options,\n                  demitter: diagnostic::emitter) -> session {\n     let codemap = codemap::new_codemap();\n     let diagnostic_handler =\n-        diagnostic::mk_handler(some(demitter));\n+        diagnostic::mk_handler(Some(demitter));\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n     build_session_(sopts, codemap, demitter, span_diagnostic_handler)\n@@ -575,7 +575,7 @@ fn build_session_(sopts: @session::options,\n                parse_sess: p_s,\n                codemap: cm,\n                // For a library crate, this is always none\n-               mut main_fn: none,\n+               mut main_fn: None,\n                span_diagnostic: span_diagnostic_handler,\n                filesearch: filesearch,\n                mut building_library: false,\n@@ -623,8 +623,8 @@ fn opts() -> ~[getopts::opt] {\n type output_filenames = @{out_filename:Path, obj_filename:Path};\n \n fn build_output_filenames(input: input,\n-                          odir: &option<Path>,\n-                          ofile: &option<Path>,\n+                          odir: &Option<Path>,\n+                          ofile: &Option<Path>,\n                           sess: session)\n         -> output_filenames {\n     let obj_path;\n@@ -646,13 +646,13 @@ fn build_output_filenames(input: input,\n         };\n \n     match *ofile {\n-      none => {\n+      None => {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let dirpath = match *odir {\n-          some(d) => d,\n-          none => match input {\n+          Some(d) => d,\n+          None => match input {\n             str_input(_) => os::getcwd(),\n             file_input(ifile) => ifile.dir_path()\n           }\n@@ -672,7 +672,7 @@ fn build_output_filenames(input: input,\n         }\n       }\n \n-      some(out_file) => {\n+      Some(out_file) => {\n         out_path = out_file;\n         obj_path = if stop_after_codegen {\n             out_file\n@@ -687,7 +687,7 @@ fn build_output_filenames(input: input,\n             // lib<basename>-<hash>-<version>.so no matter what.\n         }\n \n-        if *odir != none {\n+        if *odir != None {\n             sess.warn(~\"ignoring --out-dir flag due to -o flag.\");\n         }\n       }\n@@ -697,7 +697,7 @@ fn build_output_filenames(input: input,\n }\n \n fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n-    emitter(none, msg, diagnostic::fatal);\n+    emitter(None, msg, diagnostic::fatal);\n     fail;\n }\n "}, {"sha": "0b58add33848a755fb2224ddb6b316765aa33dcb", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -177,11 +177,11 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n     match pretty {\n-      some::<pp_mode>(ppm) => {\n+      Some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, input, ppm);\n         return;\n       }\n-      none::<pp_mode> => {/* continue */ }\n+      None::<pp_mode> => {/* continue */ }\n     }\n     let ls = opt_present(matches, ~\"ls\");\n     if ls {\n@@ -224,7 +224,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n \n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n-        let demitter = fn@(cmsp: option<(codemap::codemap, codemap::span)>,\n+        let demitter = fn@(cmsp: Option<(codemap::codemap, codemap::span)>,\n                            msg: ~str, lvl: diagnostic::level) {\n             if lvl == diagnostic::fatal {\n                 comm::send(ch, fatal);\n@@ -247,7 +247,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n             // Task failed without emitting a fatal diagnostic\n             if comm::recv(p) == done {\n                 diagnostic::emit(\n-                    none,\n+                    None,\n                     diagnostic::ice_msg(~\"unexpected failure\"),\n                     diagnostic::error);\n \n@@ -258,7 +258,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n                 ]/_.each |note| {\n-                    diagnostic::emit(none, note, diagnostic::note)\n+                    diagnostic::emit(None, note, diagnostic::note)\n                 }\n             }\n             // Fail so the process returns a failure code"}, {"sha": "0a99c53f83ae81d46251cefff4536036e012c6e0", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -90,7 +90,7 @@ type options =\n      save_temps: bool,\n      output_type: back::link::output_type,\n      addl_lib_search_paths: ~[Path],\n-     maybe_sysroot: option<Path>,\n+     maybe_sysroot: Option<Path>,\n      target_triple: ~str,\n      cfg: ast::crate_cfg,\n      test: bool,\n@@ -107,7 +107,7 @@ type session_ = {targ_cfg: @config,\n                  parse_sess: parse_sess,\n                  codemap: codemap::codemap,\n                  // For a library crate, this is always none\n-                 mut main_fn: option<(node_id, codemap::span)>,\n+                 mut main_fn: Option<(node_id, codemap::span)>,\n                  span_diagnostic: diagnostic::span_handler,\n                  filesearch: filesearch::filesearch,\n                  mut building_library: bool,\n@@ -230,7 +230,7 @@ fn basic_options() -> @options {\n         save_temps: false,\n         output_type: link::output_type_exe,\n         addl_lib_search_paths: ~[],\n-        maybe_sysroot: none,\n+        maybe_sysroot: None,\n         target_triple: driver::host_triple(),\n         cfg: ~[],\n         test: false,\n@@ -241,7 +241,7 @@ fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-fn expect<T: copy>(sess: session, opt: option<T>, msg: fn() -> ~str) -> T {\n+fn expect<T: copy>(sess: session, opt: Option<T>, msg: fn() -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n@@ -257,7 +257,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n-              option::some(~\"lib\") => true,\n+              option::Some(~\"lib\") => true,\n               _ => false\n             }\n         }"}, {"sha": "9c0f30468fc915d770bd4f4905d57a471ca85bc8", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -35,16 +35,16 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n }\n \n fn filter_item(cx: ctxt, &&item: @ast::item) ->\n-   option<@ast::item> {\n-    if item_in_cfg(cx, item) { option::some(item) } else { option::none }\n+   Option<@ast::item> {\n+    if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n-                   )-> option<@ast::view_item> {\n+                   )-> Option<@ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n-        option::some(view_item)\n+        option::Some(view_item)\n     } else {\n-        option::none\n+        option::None\n     }\n }\n \n@@ -61,10 +61,10 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n }\n \n fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n-   option<@ast::foreign_item> {\n+   Option<@ast::foreign_item> {\n     if foreign_item_in_cfg(cx, item) {\n-        option::some(item)\n-    } else { option::none }\n+        option::Some(item)\n+    } else { option::None }\n }\n \n fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n@@ -81,19 +81,19 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n }\n \n fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n-   option<@ast::stmt> {\n+   Option<@ast::stmt> {\n     match stmt.node {\n       ast::stmt_decl(decl, _) => {\n         match decl.node {\n           ast::decl_item(item) => {\n             if item_in_cfg(cx, item) {\n-                option::some(stmt)\n-            } else { option::none }\n+                option::Some(stmt)\n+            } else { option::None }\n           }\n-          _ => option::some(stmt)\n+          _ => option::Some(stmt)\n         }\n       }\n-      _ => option::some(stmt)\n+      _ => option::Some(stmt)\n     }\n }\n "}, {"sha": "3c3195f1e83ee2931cb059e4cdd4abc0ae5349c5", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -16,8 +16,8 @@ fn inject_intrinsic(sess: session,\n                                                  sess.parse_sess);\n     let item =\n         match item {\n-          some(i) => i,\n-          none => {\n+          Some(i) => i,\n+          None => {\n             sess.fatal(~\"no item found in intrinsic module\");\n           }\n         };"}, {"sha": "a3d155a84d6b811241513642b6c203781454e3c9", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -69,14 +69,14 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // FIXME (#2403): This is sloppy. Instead we should have some mechanism to\n     // indicate to the translation pass which function we want to be main.\n-    fn nomain(cx: test_ctxt, item: @ast::item) -> option<@ast::item> {\n+    fn nomain(cx: test_ctxt, item: @ast::item) -> Option<@ast::item> {\n         match item.node {\n           ast::item_fn(*) => {\n             if item.ident == cx.sess.ident_of(~\"main\") {\n-                option::none\n-            } else { option::some(item) }\n+                option::None\n+            } else { option::Some(item) }\n           }\n-          _ => option::some(item)\n+          _ => option::Some(item)\n         }\n     }\n \n@@ -97,7 +97,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n \n \n fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n-   option<@ast::item> {\n+   Option<@ast::item> {\n \n     vec::push(cx.path, i.ident);\n     debug!(\"current path: %s\",\n@@ -214,7 +214,7 @@ fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n }\n \n fn path_node(ids: ~[ast::ident]) -> @ast::path {\n-    @{span: dummy_sp(), global: false, idents: ids, rp: none, types: ~[]}\n+    @{span: dummy_sp(), global: false, idents: ids, rp: None, types: ~[]}\n }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n@@ -229,7 +229,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let test_descs = mk_test_desc_vec(cx);\n \n     let body_: ast::blk_ =\n-        default_block(~[], option::some(test_descs), cx.sess.next_node_id());\n+        default_block(~[], option::Some(test_descs), cx.sess.next_node_id());\n     let body = nospan(body_);\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n@@ -249,7 +249,7 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n-          some(~\"std\") => true,\n+          Some(~\"std\") => true,\n           _ => false\n         }\n     };\n@@ -362,7 +362,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec(~[name_field, fn_field, ignore_field, fail_field],\n-            option::none);\n+            option::None);\n     let desc_rec: ast::expr =\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),\n          node: desc_rec_, span: span};\n@@ -394,7 +394,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let wrapper_body: ast::blk = nospan({\n         view_items: ~[],\n         stmts: ~[@call_stmt],\n-        expr: option::none,\n+        expr: option::None,\n         id: cx.sess.next_node_id(),\n         rules: ast::default_blk\n     });\n@@ -445,7 +445,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let test_main_call_expr = mk_test_main_call(cx);\n \n     let body_: ast::blk_ =\n-        default_block(~[], option::some(test_main_call_expr),\n+        default_block(~[], option::Some(test_main_call_expr),\n                       cx.sess.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n "}, {"sha": "d441869457805874c378994fe95b9661080ae8a9", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -994,11 +994,11 @@ fn associate_type(tn: type_names, s: ~str, t: TypeRef) {\n     assert tn.named_types.insert(s, t);\n }\n \n-fn type_has_name(tn: type_names, t: TypeRef) -> option<~str> {\n+fn type_has_name(tn: type_names, t: TypeRef) -> Option<~str> {\n     return tn.type_names.find(t);\n }\n \n-fn name_has_type(tn: type_names, s: ~str) -> option<TypeRef> {\n+fn name_has_type(tn: type_names, s: ~str) -> Option<TypeRef> {\n     return tn.named_types.find(s);\n }\n \n@@ -1016,7 +1016,7 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n     match type_has_name(names, ty) {\n-      option::some(n) => return n,\n+      option::Some(n) => return n,\n       _ => {}\n     }\n \n@@ -1161,10 +1161,10 @@ struct object_file_res {\n \n type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n \n-fn mk_object_file(llmb: MemoryBufferRef) -> option<object_file> {\n+fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n     let llof = llvm::LLVMCreateObjectFile(llmb);\n-    if llof as int == 0 { return option::none::<object_file>; }\n-    return option::some({llof: llof, dtor: @object_file_res(llof)});\n+    if llof as int == 0 { return option::None::<object_file>; }\n+    return option::Some({llof: llof, dtor: @object_file_res(llof)});\n }\n \n /* Memory-managed interface to section iterators. */"}, {"sha": "b2792124abc32f751e4b819c56fa3fe9157b0e9f", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -121,15 +121,15 @@ fn visit_item(e: env, i: @ast::item) {\n         let cstore = e.cstore;\n         let foreign_name =\n             match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-              some(nn) => {\n+              Some(nn) => {\n                 if nn == ~\"\" {\n                     e.diag.span_fatal(\n                         i.span,\n                         ~\"empty #[link_name] not allowed; use #[nolink].\");\n                 }\n                 nn\n               }\n-              none => *e.intr.get(i.ident)\n+              None => *e.intr.get(i.ident)\n             };\n         let mut already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, ~\"nolink\")) == 0u {\n@@ -142,10 +142,10 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(a)) {\n-              some(linkarg) => {\n+              Some(linkarg) => {\n                 cstore::add_used_link_args(cstore, linkarg);\n               }\n-              none => {/* fallthrough */ }\n+              None => {/* fallthrough */ }\n             }\n         }\n       }\n@@ -169,23 +169,23 @@ fn metas_with_ident(ident: ~str, metas: ~[@ast::meta_item])\n }\n \n fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n-    option<int> {\n+    Option<int> {\n \n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash == hash) {\n-            return some(c.cnum);\n+            return Some(c.cnum);\n         }\n     }\n-    return none;\n+    return None;\n }\n \n fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n                  hash: ~str, span: span) -> ast::crate_num {\n     let metas = metas_with_ident(*e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n-      none => {\n+      None => {\n         let load_ctxt: loader::ctxt = {\n             diag: e.diag,\n             filesearch: e.filesearch,\n@@ -217,8 +217,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n         let cname =\n             match attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n-              option::some(v) => v,\n-              option::none => *e.intr.get(ident)\n+              option::Some(v) => v,\n+              option::None => *e.intr.get(ident)\n             };\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n@@ -228,7 +228,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         cstore::add_used_crate_file(cstore, &cfilename);\n         return cnum;\n       }\n-      some(cnum) => {\n+      Some(cnum) => {\n         return cnum;\n       }\n     }\n@@ -248,12 +248,12 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n                *e.intr.get(dep.name), dep.vers, dep.hash);\n         match existing_match(e, metas_with_ident(*e.intr.get(cname), cmetas),\n                              dep.hash) {\n-          some(local_cnum) => {\n+          Some(local_cnum) => {\n             debug!(\"already have it\");\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n-          none => {\n+          None => {\n             debug!(\"need to load it\");\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus"}, {"sha": "77d1f18eac9d4edbef77ccbd56f63b30509cc3e7", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -5,7 +5,7 @@ import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_map;\n import middle::ty;\n-import option::{some, none};\n+import option::{Some, None};\n import syntax::diagnostic::span_handler;\n import syntax::diagnostic::expect;\n import ast_util::dummy_sp;\n@@ -85,7 +85,7 @@ fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n-                     name: option<ast::ident>)\n+                     name: Option<ast::ident>)\n     -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n@@ -100,7 +100,7 @@ fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n }\n \n fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n-    -> option<@DVec<(ast::ident, ast::self_ty_)>> {\n+    -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n@@ -127,7 +127,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n }\n \n fn get_region_param(cstore: metadata::cstore::cstore,\n-                    def: ast::def_id) -> option<ty::region_variance> {\n+                    def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n }\n@@ -150,7 +150,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     return {bounds: @~[],\n-            region_param: none,\n+            region_param: None,\n             ty: ty};\n }\n \n@@ -183,7 +183,7 @@ fn get_class_method(cstore: cstore::cstore,\n \n /* If def names a class with a dtor, return it. Otherwise, return none. */\n fn class_dtor(cstore: cstore::cstore, def: ast::def_id)\n-    -> option<ast::def_id> {\n+    -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::class_dtor(cdata, def.node)\n }"}, {"sha": "5664cf1bfa722c5e9fb3c801a86c8abf6660e113", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -150,7 +150,7 @@ fn add_use_stmt_cnum(cstore: cstore, use_id: ast::node_id,\n }\n \n fn find_use_stmt_cnum(cstore: cstore,\n-                      use_id: ast::node_id) -> option<ast::crate_num> {\n+                      use_id: ast::node_id) -> Option<ast::crate_num> {\n     p(cstore).use_crate_map.find(use_id)\n }\n "}, {"sha": "7dc3006b79cadd9e5a51fc57647ab2528e28c26e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -64,7 +64,7 @@ export translate_def_id;\n // build.\n \n fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n-   option<ebml::doc> {\n+   Option<ebml::doc> {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n@@ -75,13 +75,13 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n     for ebml::tagged_docs(bucket, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n-            return some(ebml::doc_at(d.data, pos).doc);\n+            return Some(ebml::doc_at(d.data, pos).doc);\n         }\n     };\n-    none\n+    None\n }\n \n-fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n+fn maybe_find_item(item_id: int, items: ebml::doc) -> Option<ebml::doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n@@ -100,8 +100,8 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n-       none => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n-       some(d) => d\n+       None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n+       Some(d) => d\n     }\n }\n \n@@ -162,11 +162,11 @@ fn item_symbol(item: ebml::doc) -> ~str {\n     return str::from_bytes(ebml::doc_data(sym));\n }\n \n-fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n+fn item_parent_item(d: ebml::doc) -> Option<ast::def_id> {\n     for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n+        return Some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n     }\n-    none\n+    None\n }\n \n fn item_def_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n@@ -196,7 +196,7 @@ fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n         })\n }\n \n-fn variant_disr_val(d: ebml::doc) -> option<int> {\n+fn variant_disr_val(d: ebml::doc) -> Option<int> {\n     do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n         int::parse_buf(ebml::doc_data(val_doc), 10u)\n     }\n@@ -237,7 +237,7 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::doc) -> option<ty::region_variance> {\n+fn item_ty_region_param(item: ebml::doc) -> Option<ty::region_variance> {\n     ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n         let d = ebml::ebml_deserializer(doc);\n         ty::deserialize_region_variance(d)\n@@ -310,11 +310,11 @@ fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n       ForeignMod => dl_def(ast::def_foreign_mod(did)),\n       Variant => {\n           match item_parent_item(item) {\n-              some(t) => {\n+              Some(t) => {\n                 let tid = {crate: cnum, node: t.node};\n                 dl_def(ast::def_variant(tid, did))\n               }\n-              none => fail ~\"item_to_def_like: enum item has no parent\"\n+              None => fail ~\"item_to_def_like: enum item has no parent\"\n           }\n       }\n       Trait | Enum => dl_def(ast::def_ty(did)),\n@@ -346,7 +346,7 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n }\n \n fn get_region_param(cdata: cmd, id: ast::node_id)\n-    -> option<ty::region_variance> {\n+    -> Option<ty::region_variance> {\n \n     let item = lookup_item(id, cdata.data);\n     return item_ty_region_param(item);\n@@ -363,11 +363,11 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    let mut found = none;\n+    let mut found = None;\n     for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n         if item_name(intr, find_item(m_did.node, items)) == name {\n-            found = some(translate_def_id(cdata, m_did));\n+            found = Some(translate_def_id(cdata, m_did));\n         }\n     }\n     option::get(found)\n@@ -376,37 +376,37 @@ fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    let mut found = none;\n+    let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n-      some(it) => it,\n-      none => fail (fmt!(\"get_class_method: class id not found \\\n+      Some(it) => it,\n+      None => fail (fmt!(\"get_class_method: class id not found \\\n                               when looking up method %s\", *intr.get(name)))\n     };\n     for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n         if item_name(intr, mid) == name {\n-            found = some(m_did);\n+            found = Some(m_did);\n         }\n     }\n     match found {\n-      some(found) => found,\n-      none => fail (fmt!(\"get_class_method: no method named %s\",\n+      Some(found) => found,\n+      None => fail (fmt!(\"get_class_method: no method named %s\",\n                          *intr.get(name)))\n     }\n }\n \n-fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n+fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    let mut found = none;\n+    let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n-            some(it) => it,\n-            none     => fail (fmt!(\"class_dtor: class id not found \\\n+            Some(it) => it,\n+            None     => fail (fmt!(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n     for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n          let did = ebml::with_doc_data(doc1, |d| parse_def_id(d));\n-         found = some(translate_def_id(cdata, did));\n+         found = Some(translate_def_id(cdata, did));\n     };\n     found\n }\n@@ -495,8 +495,8 @@ fn each_path(intr: ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n \n                     // Get the item.\n                     match maybe_find_item(def_id.node, items) {\n-                        none => {}\n-                        some(item_doc) => {\n+                        None => {}\n+                        Some(item_doc) => {\n                             // Construct the def for this item.\n                             let def_like = item_to_def_like(item_doc,\n                                                             def_id,\n@@ -533,7 +533,7 @@ type decode_inlined_item = fn(\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n-    par_doc: ebml::doc) -> option<ast::inlined_item>;\n+    par_doc: ebml::doc) -> Option<ast::inlined_item>;\n \n fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n@@ -543,19 +543,19 @@ fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(intr, item_doc));\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n-      some(ii) => csearch::found(ii),\n-      none => {\n+      Some(ii) => csearch::found(ii),\n+      None => {\n         match item_parent_item(item_doc) {\n-          some(did) => {\n+          Some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n             match decode_inlined_item(cdata, tcx, path,\n                                                parent_item) {\n-              some(ii) => csearch::found_parent(did, ii),\n-              none => csearch::not_found\n+              Some(ii) => csearch::found_parent(did, ii),\n+              None => csearch::not_found\n             }\n           }\n-          none => csearch::not_found\n+          None => csearch::not_found\n         }\n       }\n     }\n@@ -582,7 +582,7 @@ fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n           _ => { /* Nullary enum variant. */ }\n         }\n         match variant_disr_val(item) {\n-          some(val) => { disr_val = val; }\n+          Some(val) => { disr_val = val; }\n           _         => { /* empty */ }\n         }\n         vec::push(infos, @{args: arg_tys, ctor_ty: ctor_ty, name: name,\n@@ -648,7 +648,7 @@ fn item_impl_methods(intr: ident_interner, cdata: cmd, item: ebml::doc,\n }\n \n fn get_impls_for_mod(intr: ident_interner, cdata: cmd,\n-                     m_id: ast::node_id, name: option<ast::ident>,\n+                     m_id: ast::node_id, name: Option<ast::ident>,\n                      get_cdata: fn(ast::crate_num) -> cmd)\n                   -> @~[@_impl] {\n \n@@ -666,7 +666,7 @@ fn get_impls_for_mod(intr: ident_interner, cdata: cmd,\n         let impl_data = impl_cdata.data;\n         let item = lookup_item(local_did.node, impl_data);\n         let nm = item_name(intr, item);\n-        if match name { some(n) => { n == nm } none => { true } } {\n+        if match name { Some(n) => { n == nm } None => { true } } {\n            let base_tps = item_ty_param_count(item);\n            vec::push(result, @{\n                 did: local_did, ident: nm,\n@@ -707,19 +707,19 @@ fn get_trait_methods(intr: ident_interner, cdata: cmd, id: ast::node_id,\n // annoying way with get_trait_methods.\n fn get_method_names_if_trait(intr: ident_interner, cdata: cmd,\n                              node_id: ast::node_id)\n-                          -> option<@DVec<(ast::ident, ast::self_ty_)>> {\n+                          -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Trait {\n-        return none;\n+        return None;\n     }\n \n     let resulting_methods = @dvec();\n     for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n     }\n-    return some(resulting_methods);\n+    return Some(resulting_methods);\n }\n \n fn get_item_attrs(cdata: cmd,\n@@ -791,8 +791,8 @@ fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n-        some(it) => it,\n-        none => fail (fmt!(\"describe_def: item not found %?\", id))\n+        Some(it) => it,\n+        None => fail (fmt!(\"describe_def: item not found %?\", id))\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -851,7 +851,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     match ebml::maybe_get_doc(md, tag_attributes) {\n-      option::some(attrs_d) => {\n+      option::Some(attrs_d) => {\n         for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n@@ -864,7 +864,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n                        span: ast_util::dummy_sp()});\n         };\n       }\n-      option::none => ()\n+      option::None => ()\n     }\n     return attrs;\n }\n@@ -934,8 +934,8 @@ fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n-      some(ver) => ver,\n-      none => ~\"0.0\"\n+      Some(ver) => ver,\n+      None => ~\"0.0\"\n     };\n }\n \n@@ -997,8 +997,8 @@ fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     }\n \n     match cdata.cnum_map.find(did.crate) {\n-      option::some(n) => return {crate: n, node: did.node},\n-      option::none => fail ~\"didn't find a crate in the cnum_map\"\n+      option::Some(n) => return {crate: n, node: did.node},\n+      option::None => fail ~\"didn't find a crate in the cnum_map\"\n     }\n }\n "}, {"sha": "f865f552364b711ec7a0c3a898cd97baaf9d77a9", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -176,8 +176,8 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n-      some(x) => x,\n-      none => {\n+      Some(x) => x,\n+      None => {\n         ecx.diag.handler().bug(\n             fmt!(\"encode_symbol: id not found %d\", id));\n       }\n@@ -294,7 +294,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n     match ecx.reexports2.find(id) {\n-        some(exports) => {\n+        Some(exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for exports.each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n@@ -309,7 +309,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                 ebml_w.end_tag();\n             }\n         }\n-        none => {\n+        None => {\n             debug!(\"(encoding info for module) found no reexports for %d\",\n                    id);\n         }\n@@ -417,7 +417,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                         id: node_id, ident: ident, path: ast_map::path,\n-                        item: option<inlined_item>, tps: ~[ty_param]) {\n+                        item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n@@ -430,10 +430,10 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n-           some(it) => {\n+           Some(it) => {\n              ecx.encode_inlined_item(ecx, ebml_w, path, it);\n            }\n-           none => {\n+           None => {\n              encode_symbol(ecx, ebml_w, id);\n            }\n         }\n@@ -593,9 +593,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                    ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n                                path, if tps.len() > 0u {\n-                                   some(ii_dtor(dtor, item.ident, tps,\n+                                   Some(ii_dtor(dtor, item.ident, tps,\n                                                 local_def(item.id))) }\n-                               else { none }, tps);\n+                               else { None }, tps);\n         }\n \n         /* Index the class*/\n@@ -605,8 +605,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n \n         match struct_def.ctor {\n-            none => encode_family(ebml_w, 'S'),\n-            some(_) => encode_family(ebml_w, 'C')\n+            None => encode_family(ebml_w, 'S'),\n+            Some(_) => encode_family(ebml_w, 'C')\n         }\n \n         encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -678,9 +678,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             });\n             encode_info_for_ctor(ecx, ebml_w, ctor.node.id, item.ident,\n                                  path, if tps.len() > 0u {\n-                                     some(ii_ctor(ctor, item.ident, tps,\n+                                     Some(ii_ctor(ctor, item.ident, tps,\n                                                   local_def(item.id))) }\n-                                 else { none }, tps);\n+                                 else { None }, tps);\n         }\n       }\n       item_impl(tps, traits, _, methods) => {"}, {"sha": "f1bc93f76eea4dc27b16241da5b5c2c1c5c53724", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -14,11 +14,11 @@ export get_cargo_root;\n export get_cargo_root_nearest;\n export libdir;\n \n-type pick<T> = fn(path: &Path) -> option<T>;\n+type pick<T> = fn(path: &Path) -> Option<T>;\n \n-fn pick_file(file: Path, path: &Path) -> option<Path> {\n-    if path.file_path() == file { option::some(copy *path) }\n-    else { option::none }\n+fn pick_file(file: Path, path: &Path) -> Option<Path> {\n+    if path.file_path() == file { option::Some(copy *path) }\n+    else { option::None }\n }\n \n trait filesearch {\n@@ -28,7 +28,7 @@ trait filesearch {\n     fn get_target_lib_file_path(file: &Path) -> Path;\n }\n \n-fn mk_filesearch(maybe_sysroot: option<Path>,\n+fn mk_filesearch(maybe_sysroot: Option<Path>,\n                  target_triple: &str,\n                  addl_lib_search_paths: ~[Path]) -> filesearch {\n     type filesearch_impl = {sysroot: Path,\n@@ -67,8 +67,8 @@ fn mk_filesearch(maybe_sysroot: option<Path>,\n      target_triple: str::from_slice(target_triple)} as filesearch\n }\n \n-fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n-    let mut rslt = none;\n+fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n+    let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         for os::list_dir_path(&lib_search_path).each |path| {\n@@ -100,15 +100,15 @@ fn make_target_lib_path(sysroot: &Path,\n \n fn get_default_sysroot() -> Path {\n     match os::self_exe_path() {\n-      option::some(p) => p.pop(),\n-      option::none => fail ~\"can't determine value for sysroot\"\n+      option::Some(p) => p.pop(),\n+      option::None => fail ~\"can't determine value for sysroot\"\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: option<Path>) -> Path {\n+fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     match maybe_sysroot {\n-      option::some(sr) => sr,\n-      option::none => get_default_sysroot()\n+      option::Some(sr) => sr,\n+      option::None => get_default_sysroot()\n     }\n }\n \n@@ -118,10 +118,10 @@ fn get_cargo_sysroot() -> result<Path, ~str> {\n \n fn get_cargo_root() -> result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n-        some(_p) => result::ok(Path(_p)),\n-        none => match os::homedir() {\n-          some(_q) => result::ok(_q.push(\".cargo\")),\n-          none => result::err(~\"no CARGO_ROOT or home directory\")\n+        Some(_p) => result::ok(Path(_p)),\n+        None => match os::homedir() {\n+          Some(_q) => result::ok(_q.push(\".cargo\")),\n+          None => result::err(~\"no CARGO_ROOT or home directory\")\n         }\n     }\n }"}, {"sha": "4ca9d8f9b86ff69a9a93b445bc5c01e976f86a29", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -40,16 +40,16 @@ type ctxt = {\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     match find_library_crate(cx) {\n-      some(t) => return t,\n-      none => {\n+      Some(t) => return t,\n+      None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n                           *cx.intr.get(cx.ident)));\n       }\n     }\n }\n \n-fn find_library_crate(cx: ctxt) -> option<{ident: ~str, data: @~[u8]}> {\n+fn find_library_crate(cx: ctxt) -> Option<{ident: ~str, data: @~[u8]}> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n@@ -67,7 +67,7 @@ fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n fn find_library_crate_aux(cx: ctxt,\n                           nn: {prefix: ~str, suffix: ~str},\n                           filesearch: filesearch::filesearch) ->\n-   option<{ident: ~str, data: @~[u8]}> {\n+   Option<{ident: ~str, data: @~[u8]}> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: ~str = nn.prefix + crate_name + ~\"-\";\n     let suffix: ~str = nn.suffix;\n@@ -79,33 +79,33 @@ fn find_library_crate_aux(cx: ctxt,\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n             debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n                    prefix, suffix);\n-            option::none::<()>\n+            option::None::<()>\n         } else {\n             debug!(\"%s is a candidate\", path.to_str());\n             match get_metadata_section(cx.os, path) {\n-              option::some(cvec) => {\n+              option::Some(cvec) => {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n                     debug!(\"skipping %s, metadata doesn't match\",\n                            path.to_str());\n-                    option::none::<()>\n+                    option::None::<()>\n                 } else {\n                     debug!(\"found %s with matching metadata\", path.to_str());\n                     vec::push(matches, {ident: path.to_str(), data: cvec});\n-                    option::none::<()>\n+                    option::None::<()>\n                 }\n               }\n               _ => {\n                 debug!(\"could not load metadata for %s\", path.to_str());\n-                option::none::<()>\n+                option::None::<()>\n               }\n             }\n         }\n     });\n \n     if matches.is_empty() {\n-        none\n+        None\n     } else if matches.len() == 1u {\n-        some(matches[0])\n+        Some(matches[0])\n     } else {\n         cx.diag.span_err(\n             cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n@@ -116,22 +116,22 @@ fn find_library_crate_aux(cx: ctxt,\n             note_linkage_attrs(cx.intr, cx.diag, attrs);\n         }\n         cx.diag.handler().abort_if_errors();\n-        none\n+        None\n     }\n }\n \n fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n-      some(i) => {\n+      Some(i) => {\n         match attr::get_meta_item_value_str(i) {\n-          some(n) => n,\n+          Some(n) => n,\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n           _ => fail\n         }\n       }\n-      none => fail ~\"expected to find the crate name\"\n+      None => fail ~\"expected to find the crate name\"\n     }\n }\n \n@@ -169,14 +169,14 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: &Path) -> option<@~[u8]> unsafe {\n+                        filename: &Path) -> Option<@~[u8]> unsafe {\n     let mb = str::as_c_str(filename.to_str(), |buf| {\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n     });\n-    if mb as int == 0 { return option::none::<@~[u8]>; }\n+    if mb as int == 0 { return option::None::<@~[u8]>; }\n     let of = match mk_object_file(mb) {\n-        option::some(of) => of,\n-        _ => return option::none::<@~[u8]>\n+        option::Some(of) => of,\n+        _ => return option::None::<@~[u8]>\n     };\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -187,12 +187,12 @@ fn get_metadata_section(os: os,\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {\n                 let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n-                return some(@vec::unsafe::from_buf(cvbuf, csz));\n+                return Some(@vec::unsafe::from_buf(cvbuf, csz));\n             }\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    return option::none::<@~[u8]>;\n+    return option::None::<@~[u8]>;\n }\n \n fn meta_section_name(os: os) -> ~str {\n@@ -208,8 +208,8 @@ fn meta_section_name(os: os) -> ~str {\n fn list_file_metadata(intr: ident_interner,\n                       os: os, path: &Path, out: io::Writer) {\n     match get_metadata_section(os, path) {\n-      option::some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n-      option::none => {\n+      option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n+      option::None => {\n         out.write_str(~\"could not find metadata in \"\n                       + path.to_str() + ~\".\\n\");\n       }"}, {"sha": "34676df489e531fa7194b12b92350fb71a3b28f1", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -77,7 +77,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n             if c == '(' {\n                 return @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n-                      rp: none, types: ~[]};\n+                      rp: None, types: ~[]};\n             } else { vec::push(idents, parse_ident_(st, is_last)); }\n           }\n         }\n@@ -172,10 +172,10 @@ fn parse_region(st: @pstate) -> ty::region {\n     }\n }\n \n-fn parse_opt<T>(st: @pstate, f: fn() -> T) -> option<T> {\n+fn parse_opt<T>(st: @pstate, f: fn() -> T) -> Option<T> {\n     match next(st) {\n-      'n' => none,\n-      's' => some(f()),\n+      'n' => None,\n+      's' => Some(f()),\n       _ => fail ~\"parse_opt: bad input\"\n     }\n }\n@@ -292,8 +292,8 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n         match st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n-          some(tt) => return tt,\n-          none => {\n+          Some(tt) => return tt,\n+          None => {\n             let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n@@ -411,13 +411,13 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let def_part = vec::view(buf, colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_buf(crate_part, 10u) {\n-       some(cn) => cn as int,\n-       none => fail (fmt!(\"internal error: parse_def_id: crate number \\\n+       Some(cn) => cn as int,\n+       None => fail (fmt!(\"internal error: parse_def_id: crate number \\\n                                expected, but found %?\", crate_part))\n     };\n     let def_num = match uint::parse_buf(def_part, 10u) {\n-       some(dn) => dn as int,\n-       none => fail (fmt!(\"internal error: parse_def_id: id expected, but \\\n+       Some(dn) => dn as int,\n+       None => fail (fmt!(\"internal error: parse_def_id: id expected, but \\\n                                found %?\", def_part))\n     };\n     return {crate: crate_num, node: def_num};"}, {"sha": "ed313238e6866f04a0efdec61d1fe79010280969", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -44,8 +44,8 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(t) {\n-          some(s) => *s,\n-          none => {\n+          Some(s) => *s,\n+          None => {\n             let buf = io::mem_buffer();\n             enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).struct);\n             cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n@@ -56,11 +56,11 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n       }\n       ac_use_abbrevs(abbrevs) => {\n         match abbrevs.find(t) {\n-          some(a) => { w.write_str(*a.s); return; }\n-          none => {\n+          Some(a) => { w.write_str(*a.s); return; }\n+          None => {\n             let pos = w.tell();\n             match ty::type_def_id(t) {\n-              some(def_id) => {\n+              Some(def_id) => {\n                 // Do not emit node ids that map to unexported names.  Those\n                 // are not helpful.\n                 if def_id.crate != local_crate ||\n@@ -104,10 +104,10 @@ fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: io::Writer, t: option<T>, enc_f: fn(T)) {\n+fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: fn(T)) {\n     match t {\n-      none => w.write_char('n'),\n-      some(v) => {\n+      None => w.write_char('n'),\n+      Some(v) => {\n         w.write_char('s');\n         enc_f(v);\n       }"}, {"sha": "fc311713df0d18d0867df7f3740b86b04f79bd6b", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -104,11 +104,11 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        tcx: ty::ctxt,\n                        maps: maps,\n                        path: ast_map::path,\n-                       par_doc: ebml::doc) -> option<ast::inlined_item> {\n+                       par_doc: ebml::doc) -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n-      none => none,\n-      some(ast_doc) => {\n+      None => None,\n+      Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n@@ -133,7 +133,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n           }\n           _ => { }\n         }\n-        some(ii)\n+        Some(ii)\n       }\n     }\n }\n@@ -771,12 +771,12 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n trait doc_decoder_helpers {\n     fn as_int() -> int;\n-    fn opt_child(tag: c::astencode_tag) -> option<ebml::doc>;\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::doc>;\n }\n \n impl ebml::doc: doc_decoder_helpers {\n     fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn opt_child(tag: c::astencode_tag) -> option<ebml::doc> {\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::doc> {\n         ebml::maybe_get_doc(self, tag as uint)\n     }\n }\n@@ -931,7 +931,7 @@ impl fake_session: fake_ext_ctxt {\n \n #[cfg(test)]\n fn mk_ctxt() -> fake_ext_ctxt {\n-    parse::new_parse_sess(none) as fake_ext_ctxt\n+    parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n #[cfg(test)]"}, {"sha": "6f6c1fe928533800518af3e4f2c8a685ce4e7032", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -90,10 +90,10 @@ to ensure that the box is not collected).\n In other cases, like an enum on the stack, the memory cannot be freed\n but its type can change:\n \n-    let mut x = some(5);\n+    let mut x = Some(5);\n     match x {\n-      some(ref y) => { ... }\n-      none => { ... }\n+      Some(ref y) => { ... }\n+      None => { ... }\n     }\n \n Here as before, the pointer `y` would be invalidated if we were to"}, {"sha": "481addc93dc0fb67e87c5155294eb3da1a29eb2a", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -81,16 +81,16 @@ impl assignment_type {\n impl check_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n+    fn purity(scope_id: ast::node_id) -> Option<purity_cause> {\n         let default_purity = match self.declared_purity {\n           // an unsafe declaration overrides all\n-          ast::unsafe_fn => return none,\n+          ast::unsafe_fn => return None,\n \n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n           // imposed by the borrow check\n-          ast::pure_fn => some(pc_pure_fn),\n-          ast::extern_fn | ast::impure_fn => none\n+          ast::pure_fn => Some(pc_pure_fn),\n+          ast::extern_fn | ast::impure_fn => None\n         };\n \n         // scan to see if this scope or any enclosing scope requires\n@@ -101,13 +101,13 @@ impl check_loan_ctxt {\n         let pure_map = self.req_maps.pure_map;\n         loop {\n             match pure_map.find(scope_id) {\n-              none => (),\n-              some(e) => return some(pc_cmt(e))\n+              None => (),\n+              Some(e) => return Some(pc_cmt(e))\n             }\n \n             match region_map.find(scope_id) {\n-              none => return default_purity,\n-              some(next_scope_id) => scope_id = next_scope_id\n+              None => return default_purity,\n+              Some(next_scope_id) => scope_id = next_scope_id\n             }\n         }\n     }\n@@ -128,8 +128,8 @@ impl check_loan_ctxt {\n             }\n \n             match region_map.find(scope_id) {\n-              none => return,\n-              some(next_scope_id) => scope_id = next_scope_id,\n+              None => return,\n+              Some(next_scope_id) => scope_id = next_scope_id,\n             }\n         }\n     }\n@@ -151,7 +151,7 @@ impl check_loan_ctxt {\n     // overloaded operators the callee has an id but no expr.\n     // annoying.\n     fn check_pure_callee_or_arg(pc: purity_cause,\n-                                opt_expr: option<@ast::expr>,\n+                                opt_expr: Option<@ast::expr>,\n                                 callee_id: ast::node_id,\n                                 callee_span: span) {\n         let tcx = self.tcx();\n@@ -173,7 +173,7 @@ impl check_loan_ctxt {\n         // (d) B is not a fn.\n \n         match opt_expr {\n-          some(expr) => {\n+          Some(expr) => {\n             match expr.node {\n               ast::expr_path(_) if pc == pc_pure_fn => {\n                 let def = self.tcx().def_map.get(expr.id);\n@@ -193,7 +193,7 @@ impl check_loan_ctxt {\n               _ => ()\n             }\n           }\n-          none => ()\n+          None => ()\n         }\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n@@ -238,8 +238,8 @@ impl check_loan_ctxt {\n \n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = match self.req_maps.req_loan_map.find(scope_id) {\n-            none => return,\n-            some(loanss) => loanss\n+            None => return,\n+            Some(loanss) => loanss\n         };\n \n         let par_scope_id = self.tcx().region_map.get(scope_id);\n@@ -318,8 +318,8 @@ impl check_loan_ctxt {\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n         match self.purity(ex.id) {\n-          none => (),\n-          some(pc @ pc_cmt(_)) => {\n+          None => (),\n+          Some(pc @ pc_cmt(_)) => {\n             // Subtle: Issue #3162.  If we are enforcing purity\n             // because there is a reference to aliasable, mutable data\n             // that we require to be immutable, we can't allow writes\n@@ -329,7 +329,7 @@ impl check_loan_ctxt {\n             self.report_purity_error(\n                 pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n-          some(pc_pure_fn) => {\n+          Some(pc_pure_fn) => {\n             if cmt.lp.is_none() {\n                 self.report_purity_error(\n                     pc_pure_fn, ex.span,\n@@ -379,7 +379,7 @@ impl check_loan_ctxt {\n         // is inherited from the thing that the component is embedded\n         // within, then we have to check whether that thing has been\n         // loaned out as immutable!  An example:\n-        //    let mut x = {f: some(3)};\n+        //    let mut x = {f: Some(3)};\n         //    let y = &x; // x loaned out as immutable\n         //    x.f = none; // changes type of y.f, which appears to be imm\n         match *lp {\n@@ -445,8 +445,8 @@ impl check_loan_ctxt {\n \n         // check for a conflicting loan:\n         let lp = match cmt.lp {\n-          none => return,\n-          some(lp) => lp\n+          None => return,\n+          Some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |loan| {\n             self.bccx.span_err(\n@@ -467,8 +467,8 @@ impl check_loan_ctxt {\n     fn check_last_use(expr: @ast::expr) {\n         let cmt = self.bccx.cat_expr(expr);\n         let lp = match cmt.lp {\n-          none => return,\n-          some(lp) => lp\n+          None => return,\n+          Some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n             debug!(\"Removing last use entry %? due to outstanding loan\",\n@@ -479,18 +479,18 @@ impl check_loan_ctxt {\n     }\n \n     fn check_call(expr: @ast::expr,\n-                  callee: option<@ast::expr>,\n+                  callee: Option<@ast::expr>,\n                   callee_id: ast::node_id,\n                   callee_span: span,\n                   args: ~[@ast::expr]) {\n         match self.purity(expr.id) {\n-          none => {}\n-          some(pc) => {\n+          None => {}\n+          Some(pc) => {\n             self.check_pure_callee_or_arg(\n                 pc, callee, callee_id, callee_span);\n             for args.each |arg| {\n                 self.check_pure_callee_or_arg(\n-                    pc, some(arg), arg.id, arg.span);\n+                    pc, Some(arg), arg.id, arg.span);\n             }\n           }\n         }\n@@ -562,10 +562,10 @@ fn check_loans_in_local(local: @ast::local,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n     match local.node.init {\n-      some({op: ast::init_move, expr: expr}) => {\n+      Some({op: ast::init_move, expr: expr}) => {\n         self.check_move_out(expr);\n       }\n-      some({op: ast::init_assign, _}) | none => {}\n+      Some({op: ast::init_assign, _}) | None => {}\n     }\n     visit::visit_local(local, self, vt);\n }\n@@ -624,21 +624,21 @@ fn check_loans_in_expr(expr: @ast::expr,\n         }\n       }\n       ast::expr_call(f, args, _) => {\n-        self.check_call(expr, some(f), f.id, f.span, args);\n+        self.check_call(expr, Some(f), f.id, f.span, args);\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n       if self.bccx.method_map.contains_key(expr.id) => {\n         self.check_call(expr,\n-                        none,\n+                        None,\n                         expr.callee_id,\n                         expr.span,\n                         ~[rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n       if self.bccx.method_map.contains_key(expr.id) => {\n         self.check_call(expr,\n-                        none,\n+                        None,\n                         expr.callee_id,\n                         expr.span,\n                         ~[]);"}, {"sha": "6041989bd8ceb1ac0b2a7fc8a5422242af652c10", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -150,16 +150,16 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // fine).\n                 //\n                 match opt_deref_kind(arg_ty.ty) {\n-                  some(deref_ptr(region_ptr(_))) |\n-                  some(deref_ptr(unsafe_ptr)) => {\n+                  Some(deref_ptr(region_ptr(_))) |\n+                  Some(deref_ptr(unsafe_ptr)) => {\n                     /* region pointers are (by induction) guaranteed */\n                     /* unsafe pointers are the user's problem */\n                   }\n-                  some(deref_comp(_)) |\n-                  none => {\n+                  Some(deref_comp(_)) |\n+                  None => {\n                     /* not a pointer, no worries */\n                   }\n-                  some(deref_ptr(_)) => {\n+                  Some(deref_ptr(_)) => {\n                     let arg_cmt = self.bccx.cat_borrow_of_expr(arg);\n                     self.guarantee_valid(arg_cmt, m_const, scope_r);\n                   }\n@@ -274,7 +274,7 @@ impl gather_loan_ctxt {\n           // duration of the reference: if there is an attempt to move\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n-          some(_) => {\n+          Some(_) => {\n             match self.bccx.loan(cmt, scope_r, req_mutbl) {\n               err(e) => { self.bccx.report(e); }\n               ok(loans) if loans.len() == 0 => {}\n@@ -312,7 +312,7 @@ impl gather_loan_ctxt {\n           // also check that the mutability of the desired pointer\n           // matches with the actual mutability (but if an immutable\n           // pointer is desired, that is ok as long as we are pure)\n-          none => {\n+          None => {\n             let result: bckres<preserve_condition> = {\n                 do self.check_mutbl(req_mutbl, cmt).chain |pc1| {\n                     do self.bccx.preserve(cmt, scope_r,\n@@ -396,10 +396,10 @@ impl gather_loan_ctxt {\n \n     fn add_loans(scope_id: ast::node_id, loans: @DVec<loan>) {\n         match self.req_maps.req_loan_map.find(scope_id) {\n-          some(l) => {\n+          Some(l) => {\n             (*l).push(loans);\n           }\n-          none => {\n+          None => {\n             self.req_maps.req_loan_map.insert(\n                 scope_id, @dvec::from_vec(~[mut loans]));\n           }"}, {"sha": "34bf0eae115bd6fedd7fe4ebe42ab350999ec04b", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -190,7 +190,7 @@ priv impl &preserve_ctxt {\n             // As an example, consider this scenario:\n             //\n             //    let mut x = @some(3);\n-            //    match *x { some(y) {...} none {...} }\n+            //    match *x { Some(y) {...} none {...} }\n             //\n             // Technically, the value `x` need only be rooted\n             // in the `some` arm.  However, we evaluate `x` in trans"}, {"sha": "8f78d286fe69830bdd2c2a84304e2a0a7956c3ec", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -24,7 +24,7 @@ enum capture_mode {\n type capture_var = {\n     def: ast::def,                       // Variable being accessed free\n     span: span,                          // Location of access or cap item\n-    cap_item: option<ast::capture_item>, // Capture item, if any\n+    cap_item: Option<ast::capture_item>, // Capture item, if any\n     mode: capture_mode                   // How variable is being accessed\n };\n \n@@ -78,12 +78,12 @@ fn compute_capture_vars(tcx: ty::ctxt,\n             if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: some(cap_item),\n+                                            cap_item: Some(cap_item),\n                                             mode:cap_move});\n             } else {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: some(cap_item),\n+                                            cap_item: Some(cap_item),\n                                             mode:cap_drop});\n             }\n         } else {\n@@ -92,7 +92,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n             if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: some(cap_item),\n+                                            cap_item: Some(cap_item),\n                                             mode:cap_copy});\n             }\n         }\n@@ -111,11 +111,11 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     do vec::iter(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         match cap_map.find(fvar_def_id) {\n-          option::some(_) => { /* was explicitly named, do nothing */ }\n-          option::none => {\n+          option::Some(_) => { /* was explicitly named, do nothing */ }\n+          option::None => {\n             cap_map.insert(fvar_def_id, {def:fvar.def,\n                                          span: fvar.span,\n-                                         cap_item: none,\n+                                         cap_item: None,\n                                          mode:implicit_mode});\n           }\n         }"}, {"sha": "0f4aa8167da106d739c6256c4286a822eda6a4a1", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -74,7 +74,7 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n \n fn raw_pat(p: @pat) -> @pat {\n     match p.node {\n-      pat_ident(_, _, some(s)) => { raw_pat(s) }\n+      pat_ident(_, _, Some(s)) => { raw_pat(s) }\n       _ => { p }\n     }\n }\n@@ -83,32 +83,32 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n     let ext = match is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n-      useful_ => none,\n+      useful_ => None,\n       useful(ty, ctor) => {\n         match ty::get(ty).struct {\n           ty::ty_bool => {\n             match ctor {\n-              val(const_bool(true)) => some(~\"true\"),\n-              val(const_bool(false)) => some(~\"false\"),\n-              _ => none\n+              val(const_bool(true)) => Some(~\"true\"),\n+              val(const_bool(false)) => Some(~\"false\"),\n+              _ => None\n             }\n           }\n           ty::ty_enum(id, _) => {\n               let vid = match ctor { variant(id) => id,\n               _ => fail ~\"check_exhaustive: non-variant ctor\" };\n             match vec::find(*ty::enum_variants(tcx, id),\n                                 |v| v.id == vid) {\n-                some(v) => some(tcx.sess.str_of(v.name)),\n-              none => fail ~\"check_exhaustive: bad variant in ctor\"\n+                Some(v) => Some(tcx.sess.str_of(v.name)),\n+              None => fail ~\"check_exhaustive: bad variant in ctor\"\n             }\n           }\n-          _ => none\n+          _ => None\n         }\n       }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-      some(s) => ~\": \" + s + ~\" not covered\",\n-      none => ~\"\"\n+      Some(s) => ~\": \" + s + ~\" not covered\",\n+      None => ~\"\"\n     };\n     tcx.sess.span_err(sp, msg);\n }\n@@ -141,15 +141,15 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n-      some(r) => r[0], none => v[0]\n+      Some(r) => r[0], None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil(tcx) }\n                   else { ty::node_id_to_type(tcx, real_pat.id) };\n \n     match pat_ctor_id(tcx, v[0]) {\n-      none => {\n+      None => {\n         match missing_ctor(tcx, m, left_ty) {\n-          none => {\n+          None => {\n             match ty::get(left_ty).struct {\n               ty::ty_bool => {\n                 match is_useful_specialized(tcx, m, v, val(const_bool(true)),\n@@ -177,7 +177,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n               }\n             }\n           }\n-          some(ctor) => {\n+          Some(ctor) => {\n             match is_useful(tcx, vec::filter_map(m, |r| default(tcx, r) ),\n                           vec::tail(v)) {\n               useful_ => useful(left_ty, ctor),\n@@ -186,7 +186,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n           }\n         }\n       }\n-      some(v0_ctor) => {\n+      Some(v0_ctor) => {\n         let arity = ctor_arity(tcx, v0_ctor, left_ty);\n         is_useful_specialized(tcx, m, v, v0_ctor, arity, left_ty)\n       }\n@@ -204,23 +204,23 @@ fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n     }\n }\n \n-fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n+fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-      pat_wild => { none }\n+      pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match tcx.def_map.find(pat.id) {\n-          some(def_variant(_, id)) => some(variant(id)),\n-          _ => none\n+          Some(def_variant(_, id)) => Some(variant(id)),\n+          _ => None\n         }\n       }\n-      pat_lit(expr) => { some(val(eval_const_expr(tcx, expr))) }\n+      pat_lit(expr) => { Some(val(eval_const_expr(tcx, expr))) }\n       pat_range(lo, hi) => {\n-        some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n+        Some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n       }\n       pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) |\n       pat_struct(*) => {\n-        some(single)\n+        Some(single)\n       }\n     }\n }\n@@ -231,22 +231,22 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n         match tcx.def_map.find(pat.id) {\n-          some(def_variant(_, _)) => { false }\n+          Some(def_variant(_, _)) => { false }\n           _ => { true }\n         }\n       }\n       _ => { false }\n     }\n }\n \n-fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n+fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n     match ty::get(left_ty).struct {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) |\n       ty::ty_class(*) => {\n         for m.each |r| {\n-            if !is_wild(tcx, r[0]) { return none; }\n+            if !is_wild(tcx, r[0]) { return None; }\n         }\n-        return some(single);\n+        return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n@@ -259,28 +259,28 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n         if found.len() != (*variants).len() {\n             for vec::each(*variants) |v| {\n                 if !found.contains(variant(v.id)) {\n-                    return some(variant(v.id));\n+                    return Some(variant(v.id));\n                 }\n             }\n             fail;\n-        } else { none }\n+        } else { None }\n       }\n-      ty::ty_nil => none,\n+      ty::ty_nil => None,\n       ty::ty_bool => {\n         let mut true_found = false, false_found = false;\n         for m.each |r| {\n             match pat_ctor_id(tcx, r[0]) {\n-              none => (),\n-              some(val(const_bool(true))) => true_found = true,\n-              some(val(const_bool(false))) => false_found = true,\n+              None => (),\n+              Some(val(const_bool(true))) => true_found = true,\n+              Some(val(const_bool(false))) => false_found = true,\n               _ => fail ~\"impossible case\"\n             }\n         }\n-        if true_found && false_found { none }\n-        else if true_found { some(val(const_bool(false))) }\n-        else { some(val(const_bool(true))) }\n+        if true_found && false_found { None }\n+        else if true_found { Some(val(const_bool(false))) }\n+        else { Some(val(const_bool(true))) }\n       }\n-      _ => some(single)\n+      _ => Some(single)\n     }\n }\n \n@@ -293,8 +293,8 @@ fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n           let id = match ctor { variant(id) => id,\n           _ => fail ~\"impossible case\" };\n         match vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n-            some(v) => v.args.len(),\n-            none => fail ~\"impossible case\"\n+            Some(v) => v.args.len(),\n+            None => fail ~\"impossible case\"\n         }\n       }\n       ty::ty_class(cid, _) => ty::lookup_class_fields(tcx, cid).len(),\n@@ -307,31 +307,31 @@ fn wild() -> @pat {\n }\n \n fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n-              left_ty: ty::t) -> option<~[@pat]> {\n+              left_ty: ty::t) -> Option<~[@pat]> {\n     let r0 = raw_pat(r[0]);\n     match r0.node {\n-      pat_wild => some(vec::append(vec::from_elem(arity, wild()),\n+      pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n                                    vec::tail(r))),\n       pat_ident(_, _, _) => {\n         match tcx.def_map.find(r0.id) {\n-          some(def_variant(_, id)) => {\n-            if variant(id) == ctor_id { some(vec::tail(r)) }\n-            else { none }\n+          Some(def_variant(_, id)) => {\n+            if variant(id) == ctor_id { Some(vec::tail(r)) }\n+            else { None }\n           }\n-          _ => some(vec::append(vec::from_elem(arity, wild()), vec::tail(r)))\n+          _ => Some(vec::append(vec::from_elem(arity, wild()), vec::tail(r)))\n         }\n       }\n       pat_enum(_, args) => {\n         match tcx.def_map.get(r0.id) {\n           def_variant(_, id) if variant(id) == ctor_id => {\n             let args = match args {\n-              some(args) => args,\n-              none => vec::from_elem(arity, wild())\n+              Some(args) => args,\n+              None => vec::from_elem(arity, wild())\n             };\n-            some(vec::append(args, vec::tail(r)))\n+            Some(vec::append(args, vec::tail(r)))\n           }\n-          def_variant(_, _) => none,\n-          _ => none\n+          def_variant(_, _) => None,\n+          _ => None\n         }\n       }\n       pat_rec(flds, _) => {\n@@ -341,11 +341,11 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         };\n         let args = vec::map(ty_flds, |ty_f| {\n             match vec::find(flds, |f| f.ident == ty_f.ident ) {\n-              some(f) => f.pat,\n+              Some(f) => f.pat,\n               _ => wild()\n             }\n         });\n-        some(vec::append(args, vec::tail(r)))\n+        Some(vec::append(args, vec::tail(r)))\n       }\n       pat_struct(_, flds, _) => {\n         // Grab the class data that we care about.\n@@ -362,14 +362,14 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n         let args = vec::map(class_fields, |class_field| {\n             match vec::find(flds, |f| f.ident == class_field.ident ) {\n-              some(f) => f.pat,\n+              Some(f) => f.pat,\n               _ => wild()\n             }\n         });\n-        some(vec::append(args, vec::tail(r)))\n+        Some(vec::append(args, vec::tail(r)))\n       }\n-      pat_tup(args) => some(vec::append(args, vec::tail(r))),\n-      pat_box(a) | pat_uniq(a) => some(vec::append(~[a], vec::tail(r))),\n+      pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n+      pat_box(a) | pat_uniq(a) => Some(vec::append(~[a], vec::tail(r))),\n       pat_lit(expr) => {\n         let e_v = eval_const_expr(tcx, expr);\n         let match_ = match ctor_id {\n@@ -381,27 +381,27 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n           single => true,\n           _ => fail ~\"type error\"\n         };\n-        if match_ { some(vec::tail(r)) } else { none }\n+        if match_ { Some(vec::tail(r)) } else { None }\n       }\n       pat_range(lo, hi) => {\n         let (c_lo, c_hi) = match ctor_id {\n           val(v) => (v, v),\n           range(lo, hi) => (lo, hi),\n-          single => return some(vec::tail(r)),\n+          single => return Some(vec::tail(r)),\n           _ => fail ~\"type error\"\n         };\n         let v_lo = eval_const_expr(tcx, lo),\n             v_hi = eval_const_expr(tcx, hi);\n         let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n-        if match_ { some(vec::tail(r)) } else { none }\n+        if match_ { Some(vec::tail(r)) } else { None }\n       }\n     }\n }\n \n-fn default(tcx: ty::ctxt, r: ~[@pat]) -> option<~[@pat]> {\n-    if is_wild(tcx, r[0]) { some(vec::tail(r)) }\n-    else { none }\n+fn default(tcx: ty::ctxt, r: ~[@pat]) -> Option<~[@pat]> {\n+    if is_wild(tcx, r[0]) { Some(vec::tail(r)) }\n+    else { None }\n }\n \n fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n@@ -414,7 +414,7 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n \n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     match tcx.def_map.find(pat.id) {\n-      some(def_variant(enum_id, var_id)) => {\n+      Some(def_variant(enum_id, var_id)) => {\n         if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u {\n             return true;\n         }\n@@ -423,10 +423,10 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     }\n \n     match pat.node {\n-      pat_box(sub) | pat_uniq(sub) | pat_ident(_, _, some(sub)) => {\n+      pat_box(sub) | pat_uniq(sub) | pat_ident(_, _, Some(sub)) => {\n         is_refutable(tcx, sub)\n       }\n-      pat_wild | pat_ident(_, _, none) => { false }\n+      pat_wild | pat_ident(_, _, None) => { false }\n       pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) => { false } // \"()\"\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_rec(fields, _) => {\n@@ -445,7 +445,7 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n         for elts.each |elt| { if is_refutable(tcx, elt) { return true; } }\n         false\n       }\n-      pat_enum(_, some(args)) => {\n+      pat_enum(_, Some(args)) => {\n         for args.each |p| { if is_refutable(tcx, p) { return true; } };\n         false\n       }"}, {"sha": "07bcc66358b70fa996347ccd5a08242bc150acd5", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -84,7 +84,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n           }\n           expr_path(_) => {\n             match def_map.find(e.id) {\n-              some(def_const(def_id)) => {\n+              Some(def_const(def_id)) => {\n                 if !ast_util::is_local(def_id) {\n                     sess.span_err(\n                         e.span, ~\"paths in constants may only refer to \\\n@@ -181,7 +181,7 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n         match e.node {\n           expr_path(path) => {\n             match env.def_map.find(e.id) {\n-              some(def_const(def_id)) => {\n+              Some(def_const(def_id)) => {\n                 match env.ast_map.get(def_id.node) {\n                   ast_map::node_item(it, _) => {\n                     v.visit_item(it, env, v);"}, {"sha": "328430d9464dcfae4c7295d4efa416356f140ce0", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -59,8 +59,8 @@ fn classify(e: @expr,\n             tcx: ty::ctxt) -> constness {\n     let did = ast_util::local_def(e.id);\n     match tcx.ccache.find(did) {\n-      some(x) => x,\n-      none => {\n+      Some(x) => x,\n+      None => {\n         let cn =\n             match e.node {\n               ast::expr_lit(lit) => {\n@@ -95,8 +95,8 @@ fn classify(e: @expr,\n                 }\n               }\n \n-              ast::expr_struct(_, fs, none) |\n-              ast::expr_rec(fs, none) => {\n+              ast::expr_struct(_, fs, None) |\n+              ast::expr_rec(fs, None) => {\n                 let cs = do vec::map(fs) |f| {\n                     if f.node.mutbl == ast::m_imm {\n                         classify(f.node.expr, def_map, tcx)\n@@ -136,7 +136,7 @@ fn classify(e: @expr,\n               // surrounding nonlocal constants. But we don't yet.\n               ast::expr_path(_) => {\n                 match def_map.find(e.id) {\n-                  some(ast::def_const(def_id)) => {\n+                  Some(ast::def_const(def_id)) => {\n                     if ast_util::is_local(def_id) {\n                         let ty = ty::expr_ty(tcx, e);\n                         if ty::type_is_integral(ty) {\n@@ -148,10 +148,10 @@ fn classify(e: @expr,\n                         non_const\n                     }\n                   }\n-                  some(_) => {\n+                  Some(_) => {\n                     non_const\n                   }\n-                  none => {\n+                  None => {\n                     tcx.sess.span_bug(e.span,\n                                       ~\"unknown path when \\\n                                         classifying constants\");"}, {"sha": "20950b9da1294bc17e783bb41a9339faec03eeaa", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -50,8 +50,8 @@ fn collect_freevars(def_map: resolve3::DefMap, blk: ast::blk)\n               ast::expr_path(path) => {\n                   let mut i = 0;\n                   match def_map.find(expr.id) {\n-                    none => fail ~\"path not found\",\n-                    some(df) => {\n+                    None => fail ~\"path not found\",\n+                    Some(df) => {\n                       let mut def = df;\n                       while i < depth {\n                         match copy def {\n@@ -105,8 +105,8 @@ fn annotate_freevars(def_map: resolve3::DefMap, crate: @ast::crate) ->\n \n fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     match tcx.freevars.find(fid) {\n-      none => fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\",\n-      some(d) => return d\n+      None => fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\",\n+      Some(d) => return d\n     }\n }\n fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {"}, {"sha": "98beb59ec0a408fde63380a741d3b326f24f6883", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -89,14 +89,14 @@ fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = fn@(ctx, node_id, option<@freevar_entry>,\n+type check_fn = fn@(ctx, node_id, Option<@freevar_entry>,\n                     bool, ty::t, sp: span);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n-    fn check_for_uniq(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n+    fn check_for_uniq(cx: ctx, id: node_id, fv: Option<@freevar_entry>,\n                       is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be sendable, regardless of whether it is\n         // moved in or copied in.  Note that send implies owned.\n@@ -106,7 +106,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         let is_implicit = fv.is_some();\n         if !is_move {\n             check_copy(cx, id, var_t, sp, is_implicit,\n-                       some((\"non-copyable value cannot be copied into a \\\n+                       Some((\"non-copyable value cannot be copied into a \\\n                               ~fn closure\",\n                              \"to copy values into a ~fn closure, use a \\\n                               capture clause: `fn~(copy x)` or `|copy x|`\")));\n@@ -118,7 +118,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         }\n     }\n \n-    fn check_for_box(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n+    fn check_for_box(cx: ctx, id: node_id, fv: Option<@freevar_entry>,\n                      is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be owned\n         if !check_owned(cx.tcx, var_t, sp) { return; }\n@@ -127,7 +127,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         let is_implicit = fv.is_some();\n         if !is_move {\n             check_copy(cx, id, var_t, sp, is_implicit,\n-                       some((\"non-copyable value cannot be copied into a \\\n+                       Some((\"non-copyable value cannot be copied into a \\\n                               @fn closure\",\n                              \"to copy values into a @fn closure, use a \\\n                               capture clause: `fn~(copy x)` or `|copy x|`\")));\n@@ -139,7 +139,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         }\n     }\n \n-    fn check_for_block(cx: ctx, _id: node_id, fv: option<@freevar_entry>,\n+    fn check_for_block(cx: ctx, _id: node_id, fv: Option<@freevar_entry>,\n                        _is_move: bool, _var_t: ty::t, sp: span) {\n         // only restriction: no capture clauses (we would have to take\n         // ownership of the moved/copied in data).\n@@ -150,7 +150,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         }\n     }\n \n-    fn check_for_bare(cx: ctx, _id: node_id, _fv: option<@freevar_entry>,\n+    fn check_for_bare(cx: ctx, _id: node_id, _fv: Option<@freevar_entry>,\n                       _is_move: bool,_var_t: ty::t, sp: span) {\n         cx.tcx.sess.span_err(sp, ~\"attempted dynamic environment capture\");\n     }\n@@ -189,7 +189,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n-            chk(cx, fn_id, none, cap_item.is_move, ty, cap_item.span);\n+            chk(cx, fn_id, None, cap_item.is_move, ty, cap_item.span);\n             cap_def_id\n         };\n \n@@ -205,13 +205,13 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             // a move and not a copy\n             let is_move = {\n                 match cx.last_use_map.find(fn_id) {\n-                  some(vars) => (*vars).contains(id),\n-                  none => false\n+                  Some(vars) => (*vars).contains(id),\n+                  None => false\n                 }\n             };\n \n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            chk(cx, fn_id, some(fv), is_move, ty, fv.span);\n+            chk(cx, fn_id, Some(fv), is_move, ty, fv.span);\n         }\n     }\n \n@@ -220,7 +220,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n     match b.node.expr {\n-      some(ex) => maybe_copy(cx, ex, none),\n+      Some(ex) => maybe_copy(cx, ex, None),\n       _ => ()\n     }\n     visit::visit_block(b, cx, v);\n@@ -232,7 +232,7 @@ fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n             if mode == bind_by_value {\n                 let t = ty::node_id_to_type(cx.tcx, id);\n                 let reason = \"consider binding with `ref` or `move` instead\";\n-                check_copy(cx, id, t, span, false, some((reason,reason)));\n+                check_copy(cx, id, t, span, false, Some((reason,reason)));\n             }\n         }\n     }\n@@ -272,24 +272,24 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     match e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n-      expr_ret(some(ex)) => {\n-        maybe_copy(cx, ex, none);\n+      expr_ret(Some(ex)) => {\n+        maybe_copy(cx, ex, None);\n       }\n       expr_cast(source, _) => {\n-        maybe_copy(cx, source, none);\n+        maybe_copy(cx, source, None);\n         check_cast_for_escaping_regions(cx, source, e);\n       }\n-      expr_copy(expr) => check_copy_ex(cx, expr, false, none),\n+      expr_copy(expr) => check_copy_ex(cx, expr, false, None),\n       // Vector add copies, but not \"implicitly\"\n-      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false, none),\n+      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false, None),\n       expr_binary(add, ls, rs) => {\n-        check_copy_ex(cx, ls, false, none);\n-        check_copy_ex(cx, rs, false, none);\n+        check_copy_ex(cx, ls, false, None);\n+        check_copy_ex(cx, rs, false, None);\n       }\n       expr_rec(fields, def) => {\n-        for fields.each |field| { maybe_copy(cx, field.node.expr, none); }\n+        for fields.each |field| { maybe_copy(cx, field.node.expr, None); }\n         match def {\n-          some(ex) => {\n+          Some(ex) => {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = match ty::get(t).struct {\n@@ -308,13 +308,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) => {\n-        for exprs.each |expr| { maybe_copy(cx, expr, none); }\n+        for exprs.each |expr| { maybe_copy(cx, expr, None); }\n       }\n       expr_call(f, args, _) => {\n         let mut i = 0u;\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n             match ty::arg_mode(cx.tcx, arg_t) {\n-              by_copy => maybe_copy(cx, args[i], none),\n+              by_copy => maybe_copy(cx, args[i], None),\n               by_ref | by_val | by_mutbl_ref | by_move => ()\n             }\n             i += 1u;\n@@ -324,17 +324,17 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         // If this is a method call with a by-val argument, we need\n         // to check the copy\n         match cx.method_map.find(e.id) {\n-          some({self_mode: by_copy, _}) => maybe_copy(cx, lhs, none),\n+          Some({self_mode: by_copy, _}) => maybe_copy(cx, lhs, None),\n           _ => ()\n         }\n       }\n       expr_repeat(element, count_expr, _) => {\n         let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n         if count == 1 {\n-            maybe_copy(cx, element, none);\n+            maybe_copy(cx, element, None);\n         } else {\n             let element_ty = ty::expr_ty(cx.tcx, element);\n-            check_copy(cx, element.id, element_ty, element.span, true, none);\n+            check_copy(cx, element.id, element_ty, element.span, true, None);\n         }\n       }\n       _ => { }\n@@ -347,7 +347,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(locals), _}, _) => {\n         for locals.each |local| {\n             match local.node.init {\n-              some({op: init_assign, expr}) => maybe_copy(cx, expr, none),\n+              Some({op: init_assign, expr}) => maybe_copy(cx, expr, None),\n               _ => {}\n             }\n         }\n@@ -399,7 +399,7 @@ fn check_bounds(cx: ctx, id: node_id, sp: span,\n     }\n }\n \n-fn maybe_copy(cx: ctx, ex: @expr, why: option<(&str,&str)>) {\n+fn maybe_copy(cx: ctx, ex: @expr, why: Option<(&str,&str)>) {\n     check_copy_ex(cx, ex, true, why);\n }\n \n@@ -418,14 +418,14 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n }\n \n fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n-                 why: option<(&str,&str)>) {\n+                 why: Option<(&str,&str)>) {\n     if ty::expr_is_lval(cx.method_map, ex) &&\n \n         // this is a move\n         !cx.last_use_map.contains_key(ex.id) &&\n \n         // a reference to a constant like `none`... no need to warn\n-        // about *this* even if the type is option<~int>\n+        // about *this* even if the type is Option<~int>\n         !is_nullary_variant(cx, ex) &&\n \n         // borrowed unique value isn't really a copy\n@@ -466,7 +466,7 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n }\n \n fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n-              implicit_copy: bool, why: option<(&str,&str)>) {\n+              implicit_copy: bool, why: Option<(&str,&str)>) {\n     let k = ty::type_kind(cx.tcx, ty);\n     if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, ~\"copying a noncopyable value\");\n@@ -552,9 +552,9 @@ fn check_cast_for_escaping_regions(\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item):\n     match target_substs.self_r {\n-      some(ty::re_scope(*)) => { return; /* case (1) */ }\n-      none | some(ty::re_static) | some(ty::re_free(*)) => {}\n-      some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n+      Some(ty::re_scope(*)) => { return; /* case (1) */ }\n+      None | Some(ty::re_static) | Some(ty::re_free(*)) => {}\n+      Some(ty::re_bound(*)) | Some(ty::re_var(*)) => {\n         cx.tcx.sess.span_bug(\n             source.span,\n             fmt!(\"bad region found in kind: %?\", target_substs.self_r));"}, {"sha": "b6b88b554855293cfdbd3c645ac1eb5afb44c4ee", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -23,42 +23,42 @@ import std::map::{hashmap, str_hash};\n import str_eq = str::eq;\n \n struct LanguageItems {\n-    let mut const_trait: option<def_id>;\n-    let mut copy_trait: option<def_id>;\n-    let mut send_trait: option<def_id>;\n-    let mut owned_trait: option<def_id>;\n-\n-    let mut add_trait: option<def_id>;\n-    let mut sub_trait: option<def_id>;\n-    let mut mul_trait: option<def_id>;\n-    let mut div_trait: option<def_id>;\n-    let mut modulo_trait: option<def_id>;\n-    let mut neg_trait: option<def_id>;\n-    let mut bitxor_trait: option<def_id>;\n-    let mut bitand_trait: option<def_id>;\n-    let mut bitor_trait: option<def_id>;\n-    let mut shl_trait: option<def_id>;\n-    let mut shr_trait: option<def_id>;\n-    let mut index_trait: option<def_id>;\n+    let mut const_trait: Option<def_id>;\n+    let mut copy_trait: Option<def_id>;\n+    let mut send_trait: Option<def_id>;\n+    let mut owned_trait: Option<def_id>;\n+\n+    let mut add_trait: Option<def_id>;\n+    let mut sub_trait: Option<def_id>;\n+    let mut mul_trait: Option<def_id>;\n+    let mut div_trait: Option<def_id>;\n+    let mut modulo_trait: Option<def_id>;\n+    let mut neg_trait: Option<def_id>;\n+    let mut bitxor_trait: Option<def_id>;\n+    let mut bitand_trait: Option<def_id>;\n+    let mut bitor_trait: Option<def_id>;\n+    let mut shl_trait: Option<def_id>;\n+    let mut shr_trait: Option<def_id>;\n+    let mut index_trait: Option<def_id>;\n \n     new() {\n-        self.const_trait = none;\n-        self.copy_trait = none;\n-        self.send_trait = none;\n-        self.owned_trait = none;\n-\n-        self.add_trait = none;\n-        self.sub_trait = none;\n-        self.mul_trait = none;\n-        self.div_trait = none;\n-        self.modulo_trait = none;\n-        self.neg_trait = none;\n-        self.bitxor_trait = none;\n-        self.bitand_trait = none;\n-        self.bitor_trait = none;\n-        self.shl_trait = none;\n-        self.shr_trait = none;\n-        self.index_trait = none;\n+        self.const_trait = None;\n+        self.copy_trait = None;\n+        self.send_trait = None;\n+        self.owned_trait = None;\n+\n+        self.add_trait = None;\n+        self.sub_trait = None;\n+        self.mul_trait = None;\n+        self.div_trait = None;\n+        self.modulo_trait = None;\n+        self.neg_trait = None;\n+        self.bitxor_trait = None;\n+        self.bitand_trait = None;\n+        self.bitor_trait = None;\n+        self.shl_trait = None;\n+        self.shr_trait = None;\n+        self.index_trait = None;\n     }\n }\n \n@@ -68,7 +68,7 @@ struct LanguageItemCollector {\n     let crate: @crate;\n     let session: session;\n \n-    let item_refs: hashmap<~str,&mut option<def_id>>;\n+    let item_refs: hashmap<~str,&mut Option<def_id>>;\n \n     new(crate: @crate, session: session, items: &self/LanguageItems) {\n         self.crate = crate;\n@@ -117,25 +117,25 @@ struct LanguageItemCollector {\n         }\n \n         match self.item_refs.find(value) {\n-            none => {\n+            None => {\n                 // Didn't match.\n             }\n-            some(item_ref) => {\n+            Some(item_ref) => {\n                 // Check for duplicates.\n                 match copy *item_ref {\n-                    some(original_def_id)\n+                    Some(original_def_id)\n                             if original_def_id != item_def_id => {\n \n                         self.session.err(fmt!(\"duplicate entry for `%s`\",\n                                               value));\n                     }\n-                    some(_) | none => {\n+                    Some(_) | None => {\n                         // OK.\n                     }\n                 }\n \n                 // Matched.\n-                *item_ref = some(item_def_id);\n+                *item_ref = Some(item_def_id);\n             }\n         }\n     }\n@@ -184,10 +184,10 @@ struct LanguageItemCollector {\n     fn check_completeness() {\n         for self.item_refs.each |key, item_ref| {\n             match copy *item_ref {\n-                none => {\n+                None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));\n                 }\n-                some(_) => {\n+                Some(_) => {\n                     // OK.\n                 }\n             }"}, {"sha": "329d7b73f76390d20f395e0010b59a8083d7bd12", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -174,8 +174,8 @@ fn mk_lint_settings() -> lint_settings {\n \n fn get_lint_level(modes: lint_modes, lint: lint) -> level {\n     match modes.find(lint as uint) {\n-      some(c) => c,\n-      none => allow\n+      Some(c) => c,\n+      None => allow\n     }\n }\n \n@@ -184,8 +184,8 @@ fn get_lint_settings_level(settings: lint_settings,\n                               _expr_id: ast::node_id,\n                               item_id: ast::node_id) -> level {\n     match settings.settings_map.find(item_id) {\n-      some(modes) => get_lint_level(modes, lint_mode),\n-      none => get_lint_level(settings.default_settings, lint_mode)\n+      Some(modes) => get_lint_level(modes, lint_mode),\n+      None => get_lint_level(settings.default_settings, lint_mode)\n     }\n }\n \n@@ -263,14 +263,14 @@ impl ctxt {\n         for triples.each |pair| {\n             let (meta, level, lintname) = pair;\n             match self.dict.find(lintname) {\n-              none => {\n+              None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n                     meta.span,\n                     fmt!(\"unknown `%s` attribute: `%s`\",\n                          level_to_str(level), lintname));\n               }\n-              some(lint) => {\n+              Some(lint) => {\n \n                 if new_ctxt.get_level(lint.lint) == forbid &&\n                     level != forbid {\n@@ -461,15 +461,15 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n \n     fn ident_without_trailing_underscores(ident: ~str) -> ~str {\n         match str::rfind(ident, |c| c != '_') {\n-            some(idx) => (ident).slice(0, idx + 1),\n-            none => { ident } // all underscores\n+            Some(idx) => (ident).slice(0, idx + 1),\n+            None => { ident } // all underscores\n         }\n     }\n \n     fn ident_without_leading_underscores(ident: ~str) -> ~str {\n         match str::find(ident, |c| c != '_') {\n-          some(idx) => ident.slice(idx, ident.len()),\n-          none => {\n+          Some(idx) => ident.slice(idx, ident.len()),\n+          None => {\n             // all underscores\n             ident\n           }"}, {"sha": "fe89e45769cd27259ab6e7700371fc1621c90fb6", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -213,15 +213,15 @@ enum VarKind {\n     ImplicitRet\n }\n \n-fn relevant_def(def: def) -> option<RelevantDef> {\n+fn relevant_def(def: def) -> Option<RelevantDef> {\n     match def {\n-      def_self(_) => some(RelevantSelf),\n+      def_self(_) => Some(RelevantSelf),\n \n       def_binding(nid, _) |\n       def_arg(nid, _) |\n-      def_local(nid, _) => some(RelevantVar(nid)),\n+      def_local(nid, _) => Some(RelevantVar(nid)),\n \n-      _ => none\n+      _ => None\n     }\n }\n \n@@ -299,8 +299,8 @@ impl IrMaps {\n \n     fn variable(node_id: node_id, span: span) -> Variable {\n         match self.variable_map.find(node_id) {\n-          some(var) => var,\n-          none => {\n+          Some(var) => var,\n+          None => {\n             self.tcx.sess.span_bug(\n                 span, fmt!(\"No variable registered for id %d\", node_id));\n           }\n@@ -323,8 +323,8 @@ impl IrMaps {\n \n     fn captures(expr: @expr) -> @~[CaptureInfo] {\n         match self.capture_map.find(expr.id) {\n-          some(caps) => caps,\n-          none => {\n+          Some(caps) => caps,\n+          None => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n           }\n         }\n@@ -351,8 +351,8 @@ impl IrMaps {\n           Local(LocalInfo {id:id, ident:name,\n                            kind: FromMatch(bind_by_move), _}) => {\n             let v = match self.last_use_map.find(expr_id) {\n-              some(v) => v,\n-              none => {\n+              Some(v) => v,\n+              None => {\n                 let v = @dvec();\n                 self.last_use_map.insert(expr_id, v);\n                 v\n@@ -442,8 +442,8 @@ fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         let name = ast_util::path_to_ident(path);\n         self.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.node.init {\n-          some(_) => FromLetWithInitializer,\n-          none => FromLetNoInitializer\n+          Some(_) => FromLetWithInitializer,\n+          None => FromLetNoInitializer\n         };\n         self.add_variable(Local(LocalInfo {\n           id: p_id,\n@@ -497,15 +497,15 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n             match relevant_def(cv.def) {\n-              some(rv) => {\n+              Some(rv) => {\n                 let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n                   cap_move | cap_drop => true, // var must be dead afterwards\n                   cap_copy | cap_ref => false // var can still be used\n                 };\n                 vec::push(call_caps, {ln: cv_ln, is_move: is_move, rv: rv});\n               }\n-              none => {}\n+              None => {}\n             }\n         }\n         self.set_captures(expr.id, call_caps);\n@@ -597,8 +597,8 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n impl Liveness {\n     fn live_node(node_id: node_id, span: span) -> LiveNode {\n         match self.ir.live_node_map.find(node_id) {\n-          some(ln) => ln,\n-          none => {\n+          Some(ln) => ln,\n+          None => {\n             // This must be a mismatch between the ir_map construction\n             // above and the propagation code below; the two sets of\n             // code have to agree about which AST nodes are worth\n@@ -617,15 +617,15 @@ impl Liveness {\n         }\n     }\n \n-    fn variable_from_path(expr: @expr) -> option<Variable> {\n+    fn variable_from_path(expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n             relevant_def(def).map(\n                 |rdef| self.variable_from_rdef(rdef, expr.span)\n             )\n           }\n-          _ => none\n+          _ => None\n         }\n     }\n \n@@ -634,14 +634,14 @@ impl Liveness {\n     }\n \n     fn variable_from_def_map(node_id: node_id,\n-                             span: span) -> option<Variable> {\n+                             span: span) -> Option<Variable> {\n         match self.tcx.def_map.find(node_id) {\n-          some(def) => {\n+          Some(def) => {\n             relevant_def(def).map(\n                 |rdef| self.variable_from_rdef(rdef, span)\n             )\n           }\n-          none => {\n+          None => {\n             self.tcx.sess.span_bug(\n                 span, ~\"Not present in def map\")\n           }\n@@ -686,15 +686,15 @@ impl Liveness {\n     }\n \n     fn live_on_entry(ln: LiveNode, var: Variable)\n-        -> option<LiveNodeKind> {\n+        -> Option<LiveNodeKind> {\n \n         assert ln.is_valid();\n         let reader = self.users[self.idx(ln, var)].reader;\n-        if reader.is_valid() {some((*self.ir).lnk(reader))} else {none}\n+        if reader.is_valid() {Some((*self.ir).lnk(reader))} else {None}\n     }\n \n     fn live_on_exit(ln: LiveNode, var: Variable)\n-        -> option<LiveNodeKind> {\n+        -> Option<LiveNodeKind> {\n \n         self.live_on_entry(copy self.successors[*ln], var)\n     }\n@@ -705,15 +705,15 @@ impl Liveness {\n     }\n \n     fn assigned_on_entry(ln: LiveNode, var: Variable)\n-        -> option<LiveNodeKind> {\n+        -> Option<LiveNodeKind> {\n \n         assert ln.is_valid();\n         let writer = self.users[self.idx(ln, var)].writer;\n-        if writer.is_valid() {some((*self.ir).lnk(writer))} else {none}\n+        if writer.is_valid() {Some((*self.ir).lnk(writer))} else {None}\n     }\n \n     fn assigned_on_exit(ln: LiveNode, var: Variable)\n-        -> option<LiveNodeKind> {\n+        -> Option<LiveNodeKind> {\n \n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n@@ -974,7 +974,7 @@ impl Liveness {\n         }\n     }\n \n-    fn propagate_through_opt_expr(opt_expr: option<@expr>,\n+    fn propagate_through_opt_expr(opt_expr: Option<@expr>,\n                                   succ: LiveNode) -> LiveNode {\n         do opt_expr.foldl(succ) |succ, expr| {\n             self.propagate_through_expr(expr, succ)\n@@ -995,12 +995,12 @@ impl Liveness {\n             // Otherwise, we ignore it and just propagate down to\n             // process `e`.\n             match self.as_self_field(e, nm) {\n-              some((ln, var)) => {\n+              Some((ln, var)) => {\n                 self.init_from_succ(ln, succ);\n                 self.acc(ln, var, ACC_READ | ACC_USE);\n                 ln\n               }\n-              none => {\n+              None => {\n                 self.propagate_through_expr(e, succ)\n               }\n             }\n@@ -1041,11 +1041,11 @@ impl Liveness {\n           }\n \n           expr_while(cond, blk) => {\n-            self.propagate_through_loop(expr, some(cond), blk, succ)\n+            self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n           expr_loop(blk, _) => {\n-            self.propagate_through_loop(expr, none, blk, succ)\n+            self.propagate_through_loop(expr, None, blk, succ)\n           }\n \n           expr_match(e, arms) => {\n@@ -1280,8 +1280,8 @@ impl Liveness {\n         match expr.node {\n           expr_path(_) => succ,\n           expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n-            some(_) => succ,\n-            none => self.propagate_through_expr(e, succ)\n+            Some(_) => succ,\n+            None => self.propagate_through_expr(e, succ)\n           },\n           _ => self.propagate_through_expr(expr, succ)\n         }\n@@ -1294,12 +1294,12 @@ impl Liveness {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n           expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n-            some((ln, var)) => {\n+            Some((ln, var)) => {\n                 self.init_from_succ(ln, succ);\n                 self.acc(ln, var, acc);\n                 ln\n             }\n-            none => succ\n+            None => succ\n           },\n \n           // We do not track other lvalues, so just propagate through\n@@ -1313,7 +1313,7 @@ impl Liveness {\n     fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n         let def = self.tcx.def_map.get(expr.id);\n         match relevant_def(def) {\n-          some(RelevantSelf) => {\n+          Some(RelevantSelf) => {\n             // Accessing `self` is like accessing every field of\n             // the current object. This allows something like\n             // `self = ...;` (it will be considered a write to\n@@ -1333,7 +1333,7 @@ impl Liveness {\n             }\n             ln\n           }\n-          some(RelevantVar(nid)) => {\n+          Some(RelevantVar(nid)) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n                 self.init_from_succ(ln, succ);\n@@ -1342,12 +1342,12 @@ impl Liveness {\n             }\n             ln\n           }\n-          none => succ\n+          None => succ\n         }\n     }\n \n     fn as_self_field(expr: @expr,\n-                     fld: ident) -> option<(LiveNode,Variable)> {\n+                     fld: ident) -> Option<(LiveNode,Variable)> {\n         // If we checking a constructor, then we treat self.f as a\n         // variable.  we use the live_node id that will be assigned to\n         // the reference to self but the variable id for `f`.\n@@ -1362,15 +1362,15 @@ impl Liveness {\n                     (ln, var)\n                 });\n               }\n-              _ => return none\n+              _ => return None\n             }\n           }\n-          _ => return none\n+          _ => return None\n         }\n     }\n \n     fn propagate_through_loop(expr: @expr,\n-                              cond: option<@expr>,\n+                              cond: Option<@expr>,\n                               body: blk,\n                               succ: LiveNode) -> LiveNode {\n \n@@ -1438,7 +1438,7 @@ impl Liveness {\n \n fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n-      some({op: op, expr: expr}) => {\n+      Some({op: op, expr: expr}) => {\n \n         // Initializer:\n \n@@ -1451,7 +1451,7 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n             self.check_for_reassignments_in_pat(local.node.pat);\n         }\n       }\n-      none => {\n+      None => {\n \n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n@@ -1460,8 +1460,8 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n         do self.pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 match self.live_on_exit(ln, var) {\n-                  none => { /* not live: good */ }\n-                  some(lnk) => {\n+                  None => { /* not live: good */ }\n+                  Some(lnk) => {\n                     self.report_illegal_read(\n                         local.span, lnk, var,\n                         PossiblyUninitializedVariable);\n@@ -1580,13 +1580,13 @@ impl @Liveness {\n     fn check_fields(sp: span, entry_ln: LiveNode) {\n         for self.ir.field_map.each |nm, var| {\n             match self.live_on_entry(entry_ln, var) {\n-              none => { /* ok */ }\n-              some(ExitNode) => {\n+              None => { /* ok */ }\n+              Some(ExitNode) => {\n                 self.tcx.sess.span_err(\n                     sp, fmt!(\"field `self.%s` is never initialized\",\n                              self.tcx.sess.str_of(nm)));\n               }\n-              some(lnk) => {\n+              Some(lnk) => {\n                 self.report_illegal_read(\n                     sp, lnk, var, PossiblyUninitializedField);\n               }\n@@ -1626,15 +1626,15 @@ impl @Liveness {\n                ln.to_str(), var.to_str());\n \n         match self.live_on_exit(ln, var) {\n-          none => {}\n-          some(lnk) => self.report_illegal_move(span, lnk, var)\n+          None => {}\n+          Some(lnk) => self.report_illegal_move(span, lnk, var)\n         }\n     }\n \n     fn consider_last_use(expr: @expr, ln: LiveNode, var: Variable) {\n         match self.live_on_exit(ln, var) {\n-          some(_) => {}\n-          none => (*self.ir).add_last_use(expr.id, var)\n+          Some(_) => {}\n+          None => (*self.ir).add_last_use(expr.id, var)\n        }\n     }\n \n@@ -1650,11 +1650,11 @@ impl @Liveness {\n         match expr.node {\n           expr_path(_) => {\n             match self.variable_from_path(expr) {\n-              some(var) => {\n+              Some(var) => {\n                 let ln = self.live_node(expr.id, expr.span);\n                 self.check_move_from_var(expr.span, ln, var);\n               }\n-              none => {}\n+              None => {}\n             }\n           }\n \n@@ -1695,13 +1695,13 @@ impl @Liveness {\n               }\n               def => {\n                 match relevant_def(def) {\n-                  some(RelevantVar(nid)) => {\n+                  Some(RelevantVar(nid)) => {\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, ln, var);\n                   }\n-                  some(RelevantSelf) => {}\n-                  none => {}\n+                  Some(RelevantSelf) => {}\n+                  None => {}\n                 }\n               }\n             }\n@@ -1724,7 +1724,7 @@ impl @Liveness {\n     fn check_for_reassignment(ln: LiveNode, var: Variable,\n                               orig_span: span) {\n         match self.assigned_on_exit(ln, var) {\n-          some(ExprNode(span)) => {\n+          Some(ExprNode(span)) => {\n             self.tcx.sess.span_err(\n                 span,\n                 ~\"re-assignment of immutable variable\");\n@@ -1733,12 +1733,12 @@ impl @Liveness {\n                 orig_span,\n                 ~\"prior assignment occurs here\");\n           }\n-          some(lnk) => {\n+          Some(lnk) => {\n             self.tcx.sess.span_bug(\n                 orig_span,\n                 fmt!(\"illegal writer: %?\", lnk));\n           }\n-          none => {}\n+          None => {}\n         }\n     }\n \n@@ -1820,9 +1820,9 @@ impl @Liveness {\n         }\n     }\n \n-    fn should_warn(var: Variable) -> option<~str> {\n+    fn should_warn(var: Variable) -> Option<~str> {\n         let name = (*self.ir).variable_name(var);\n-        if name[0] == ('_' as u8) {none} else {some(name)}\n+        if name[0] == ('_' as u8) {None} else {Some(name)}\n     }\n \n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: LiveNode) {\n@@ -1835,8 +1835,8 @@ impl @Liveness {\n                 // is not worth warning about, as it has visible\n                 // side effects outside the fn.\n                 match self.assigned_on_entry(entry_ln, var) {\n-                  some(_) => { /*ok*/ }\n-                  none => {\n+                  Some(_) => { /*ok*/ }\n+                  None => {\n                     // but if it is not written, it ought to be used\n                     self.warn_about_unused(sp, entry_ln, var);\n                   }"}, {"sha": "2264678b46ecd84177a3ab32ed89abd70f0b4622", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -83,7 +83,7 @@ enum special_kind {\n type cmt = @{id: ast::node_id,        // id of expr/pat producing this value\n              span: span,              // span of same expr/pat\n              cat: categorization,     // categorization of expr\n-             lp: option<@loan_path>,  // loan path for expr, if any\n+             lp: Option<@loan_path>,  // loan path for expr, if any\n              mutbl: ast::mutability,  // mutability of expr as lvalue\n              ty: ty::t};              // type of the expr\n \n@@ -104,50 +104,50 @@ enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n+fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).struct {\n       ty::ty_uniq(*) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n-        some(deref_ptr(uniq_ptr))\n+        Some(deref_ptr(uniq_ptr))\n       }\n \n       ty::ty_rptr(r, _) |\n       ty::ty_evec(_, ty::vstore_slice(r)) |\n       ty::ty_estr(ty::vstore_slice(r)) => {\n-        some(deref_ptr(region_ptr(r)))\n+        Some(deref_ptr(region_ptr(r)))\n       }\n \n       ty::ty_box(*) |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) => {\n-        some(deref_ptr(gc_ptr))\n+        Some(deref_ptr(gc_ptr))\n       }\n \n       ty::ty_ptr(*) => {\n-        some(deref_ptr(unsafe_ptr))\n+        Some(deref_ptr(unsafe_ptr))\n       }\n \n       ty::ty_enum(did, _) => {\n-        some(deref_comp(comp_variant(did)))\n+        Some(deref_comp(comp_variant(did)))\n       }\n \n       ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-        some(deref_comp(comp_index(t, mt.mutbl)))\n+        Some(deref_comp(comp_index(t, mt.mutbl)))\n       }\n \n       ty::ty_estr(ty::vstore_fixed(_)) => {\n-        some(deref_comp(comp_index(t, m_imm)))\n+        Some(deref_comp(comp_index(t, m_imm)))\n       }\n \n-      _ => none\n+      _ => None\n     }\n }\n \n fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     match opt_deref_kind(t) {\n-      some(k) => k,\n-      none => {\n+      Some(k) => k,\n+      None => {\n         tcx.sess.bug(\n             fmt!(\"deref_cat() invoked on non-derefable type %s\",\n                  ty_to_str(tcx, t)));\n@@ -275,8 +275,8 @@ impl &mem_categorization_ctxt {\n \n             let base_cmt = self.cat_expr(e_base);\n             match self.cat_deref(expr, base_cmt, 0u, true) {\n-              some(cmt) => return cmt,\n-              none => {\n+              Some(cmt) => return cmt,\n+              None => {\n                 tcx.sess.span_bug(\n                     e_base.span,\n                     fmt!(\"Explicit deref of non-derefable type `%s`\",\n@@ -338,7 +338,7 @@ impl &mem_categorization_ctxt {\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) => {\n             @{id:id, span:span,\n-              cat:cat_special(sk_static_item), lp:none,\n+              cat:cat_special(sk_static_item), lp:None,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -350,21 +350,21 @@ impl &mem_categorization_ctxt {\n             // lp: loan path, must be none for aliasable things\n             let {m,lp} = match ty::resolved_mode(self.tcx, mode) {\n               ast::by_mutbl_ref => {\n-                {m: m_mutbl, lp: none}\n+                {m: m_mutbl, lp: None}\n               }\n               ast::by_move | ast::by_copy => {\n-                {m: m_imm, lp: some(@lp_arg(vid))}\n+                {m: m_imm, lp: Some(@lp_arg(vid))}\n               }\n               ast::by_ref => {\n-                {m: m_imm, lp: none}\n+                {m: m_imm, lp: None}\n               }\n               ast::by_val => {\n                 // by-value is this hybrid mode where we have a\n                 // pointer but we do not own it.  This is not\n                 // considered loanable because, for example, a by-ref\n                 // and and by-val argument might both actually contain\n                 // the same unique ptr.\n-                {m: m_imm, lp: none}\n+                {m: m_imm, lp: None}\n               }\n             };\n             @{id:id, span:span,\n@@ -374,7 +374,7 @@ impl &mem_categorization_ctxt {\n \n           ast::def_self(_) => {\n             @{id:id, span:span,\n-              cat:cat_special(sk_self), lp:none,\n+              cat:cat_special(sk_self), lp:None,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -393,7 +393,7 @@ impl &mem_categorization_ctxt {\n               ty::proto_vstore(ty::vstore_box) => {\n                 // FIXME #2152 allow mutation of moved upvars\n                 @{id:id, span:span,\n-                  cat:cat_special(sk_heap_upvar), lp:none,\n+                  cat:cat_special(sk_heap_upvar), lp:None,\n                   mutbl:m_imm, ty:expr_ty}\n               }\n               ty::proto_vstore(ty::vstore_fixed(_)) =>\n@@ -404,7 +404,7 @@ impl &mem_categorization_ctxt {\n           ast::def_local(vid, mutbl) => {\n             let m = if mutbl {m_mutbl} else {m_imm};\n             @{id:id, span:span,\n-              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              cat:cat_local(vid), lp:Some(@lp_local(vid)),\n               mutbl:m, ty:expr_ty}\n           }\n \n@@ -413,7 +413,7 @@ impl &mem_categorization_ctxt {\n           ast::def_binding(vid, ast::bind_by_ref(_)) => {\n             // by-value/by-ref bindings are local variables\n             @{id:id, span:span,\n-              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              cat:cat_local(vid), lp:Some(@lp_local(vid)),\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -427,7 +427,7 @@ impl &mem_categorization_ctxt {\n             // dependencies.\n \n             @{id:id, span:span,\n-              cat:cat_binding(pid), lp:none,\n+              cat:cat_binding(pid), lp:None,\n               mutbl:m_imm, ty:expr_ty}\n           }\n         }\n@@ -445,7 +445,7 @@ impl &mem_categorization_ctxt {\n \n     fn cat_rvalue(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n         @{id:expr.id, span:expr.span,\n-          cat:cat_rvalue, lp:none,\n+          cat:cat_rvalue, lp:None,\n           mutbl:m_imm, ty:expr_ty}\n     }\n \n@@ -464,8 +464,8 @@ impl &mem_categorization_ctxt {\n     fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n                              f_name: ast::ident) -> cmt {\n         let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty, f_name) {\n-          some(f_mutbl) => f_mutbl,\n-          none => {\n+          Some(f_mutbl) => f_mutbl,\n+          None => {\n             self.tcx.sess.span_bug(\n                 node.span(),\n                 fmt!(\"Cannot find field `%s` in type `%s`\",\n@@ -482,7 +482,7 @@ impl &mem_categorization_ctxt {\n     }\n \n     fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n-                             expl: bool) -> option<cmt> {\n+                             expl: bool) -> Option<cmt> {\n         do ty::deref(self.tcx, base_cmt.ty, expl).map |mt| {\n             match deref_kind(self.tcx, base_cmt.ty) {\n               deref_ptr(ptr) => {\n@@ -493,8 +493,8 @@ impl &mem_categorization_ctxt {\n                     // Other ptr types admit aliases and are therefore\n                     // not loanable.\n                     match ptr {\n-                      uniq_ptr => {some(@lp_deref(l, ptr))}\n-                      gc_ptr | region_ptr(_) | unsafe_ptr => {none}\n+                      uniq_ptr => {Some(@lp_deref(l, ptr))}\n+                      gc_ptr | region_ptr(_) | unsafe_ptr => {None}\n                     }\n                 };\n \n@@ -529,8 +529,8 @@ impl &mem_categorization_ctxt {\n         let base_cmt = self.cat_autoderef(base);\n \n         let mt = match ty::index(self.tcx, base_cmt.ty) {\n-          some(mt) => mt,\n-          none => {\n+          Some(mt) => mt,\n+          None => {\n             self.tcx.sess.span_bug(\n                 expr.span,\n                 fmt!(\"Explicit index of non-index type `%s`\",\n@@ -544,7 +544,7 @@ impl &mem_categorization_ctxt {\n             // and this is a *unique* vector\n             let deref_lp = match ptr {\n               uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(lp, uniq_ptr))}\n-              _ => {none}\n+              _ => {None}\n             };\n \n             // (b) for unique ptrs, we inherit mutability from the\n@@ -592,7 +592,7 @@ impl &mem_categorization_ctxt {\n \n     fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n         @{id:expr.id, span:expr.span,\n-          cat:cat_special(sk_method), lp:none,\n+          cat:cat_special(sk_method), lp:None,\n           mutbl:m_imm, ty:expr_ty}\n     }\n \n@@ -609,8 +609,8 @@ impl &mem_categorization_ctxt {\n         loop {\n             ctr += 1u;\n             match self.cat_deref(base, cmt, ctr, false) {\n-              none => return cmt,\n-              some(cmt1) => cmt = cmt1\n+              None => return cmt,\n+              Some(cmt1) => cmt = cmt1\n             }\n         }\n     }\n@@ -664,13 +664,13 @@ impl &mem_categorization_ctxt {\n             // _\n           }\n \n-          ast::pat_enum(_, none) => {\n+          ast::pat_enum(_, None) => {\n             // variant(*)\n           }\n-          ast::pat_enum(_, some(subpats)) => {\n+          ast::pat_enum(_, Some(subpats)) => {\n             // variant(x, y, z)\n             let enum_did = match self.tcx.def_map.find(pat.id) {\n-              some(ast::def_variant(enum_did, _)) => enum_did,\n+              Some(ast::def_variant(enum_did, _)) => enum_did,\n               e => tcx.sess.span_bug(pat.span,\n                                      fmt!(\"resolved to %?, not variant\", e))\n             };\n@@ -681,11 +681,11 @@ impl &mem_categorization_ctxt {\n             }\n           }\n \n-          ast::pat_ident(_, _, some(subpat)) => {\n+          ast::pat_ident(_, _, Some(subpat)) => {\n               self.cat_pattern(cmt, subpat, op);\n           }\n \n-          ast::pat_ident(_, _, none) => {\n+          ast::pat_ident(_, _, None) => {\n               // nullary variant or identifier: ignore\n           }\n \n@@ -716,10 +716,10 @@ impl &mem_categorization_ctxt {\n           ast::pat_box(subpat) | ast::pat_uniq(subpat) => {\n             // @p1, ~p1\n             match self.cat_deref(subpat, cmt, 0u, true) {\n-              some(subcmt) => {\n+              Some(subcmt) => {\n                 self.cat_pattern(subcmt, subpat, op);\n               }\n-              none => {\n+              None => {\n                 tcx.sess.span_bug(pat.span, ~\"Non derefable type\");\n               }\n             }\n@@ -846,13 +846,13 @@ impl &mem_categorization_ctxt {\n \n fn field_mutbl(tcx: ty::ctxt,\n                base_ty: ty::t,\n-               f_name: ast::ident) -> option<ast::mutability> {\n+               f_name: ast::ident) -> Option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n     match ty::get(base_ty).struct {\n       ty::ty_rec(fields) => {\n         for fields.each |f| {\n             if f.ident == f_name {\n-                return some(f.mt.mutbl);\n+                return Some(f.mt.mutbl);\n             }\n         }\n       }\n@@ -863,12 +863,12 @@ fn field_mutbl(tcx: ty::ctxt,\n                   ast::class_mutable => ast::m_mutbl,\n                   ast::class_immutable => ast::m_imm\n                 };\n-                return some(m);\n+                return Some(m);\n             }\n         }\n       }\n       _ => { }\n     }\n \n-    return none;\n+    return None;\n }"}, {"sha": "f80d4e2a2397a5efa46d4f8db90f574e20172632", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -24,8 +24,8 @@ fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n     match pat.node {\n       pat_enum(_, _) => true,\n-      pat_ident(_, _, none) => match dm.find(pat.id) {\n-        some(def_variant(_, _)) => true,\n+      pat_ident(_, _, None) => match dm.find(pat.id) {\n+        Some(def_variant(_, _)) => true,\n         _ => false\n       },\n       _ => false"}, {"sha": "e9600b5f11b91f912c2b4f78a2a1e5a49e94de04", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -22,7 +22,7 @@ import std::list;\n import std::list::list;\n import std::map::{hashmap, int_hash};\n \n-type parent = option<ast::node_id>;\n+type parent = Option<ast::node_id>;\n \n /* Records the parameter ID of a region name. */\n type binding = {node_id: ast::node_id,\n@@ -98,8 +98,8 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n     let mut subscope = subscope;\n     while superscope != subscope {\n         match region_map.find(subscope) {\n-            none => return false,\n-            some(scope) => subscope = scope\n+            None => return false,\n+            Some(scope) => subscope = scope\n         }\n     }\n     return true;\n@@ -132,24 +132,24 @@ fn is_subregion_of(region_map: region_map,\n /// is, finds the smallest scope which is greater than or equal to\n /// both `scope_a` and `scope_b`.\n fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n-                           scope_b: ast::node_id) -> option<ast::node_id> {\n+                           scope_b: ast::node_id) -> Option<ast::node_id> {\n \n     fn ancestors_of(region_map: region_map, scope: ast::node_id)\n                     -> ~[ast::node_id] {\n         let mut result = ~[scope];\n         let mut scope = scope;\n         loop {\n             match region_map.find(scope) {\n-                none => return result,\n-                some(superscope) => {\n+                None => return result,\n+                Some(superscope) => {\n                     vec::push(result, superscope);\n                     scope = superscope;\n                 }\n             }\n         }\n     }\n \n-    if scope_a == scope_b { return some(scope_a); }\n+    if scope_a == scope_b { return Some(scope_a); }\n \n     let a_ancestors = ancestors_of(region_map, scope_a);\n     let b_ancestors = ancestors_of(region_map, scope_b);\n@@ -165,29 +165,29 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n     // then the corresponding scope is a superscope of the other.\n \n     if a_ancestors[a_index] != b_ancestors[b_index] {\n-        return none;\n+        return None;\n     }\n \n     loop {\n         // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n         // for all indices between a_index and the end of the array\n-        if a_index == 0u { return some(scope_a); }\n-        if b_index == 0u { return some(scope_b); }\n+        if a_index == 0u { return Some(scope_a); }\n+        if b_index == 0u { return Some(scope_b); }\n         a_index -= 1u;\n         b_index -= 1u;\n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            return some(a_ancestors[a_index + 1u]);\n+            return Some(a_ancestors[a_index + 1u]);\n         }\n     }\n }\n \n /// Extracts that current parent from cx, failing if there is none.\n fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n     match cx.parent {\n-      none => {\n+      None => {\n         cx.sess.span_bug(span, ~\"crate should not be parent here\");\n       }\n-      some(parent_id) => {\n+      Some(parent_id) => {\n         parent_id\n       }\n     }\n@@ -206,7 +206,7 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = ctxt {parent: some(blk.node.id) with cx};\n+    let new_cx: ctxt = ctxt {parent: Some(blk.node.id) with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n@@ -219,7 +219,7 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n       ast::pat_ident(_, path, _) => {\n         let defn_opt = cx.def_map.find(pat.id);\n         match defn_opt {\n-          some(ast::def_variant(_,_)) => {\n+          Some(ast::def_variant(_,_)) => {\n             /* Nothing to do; this names a variant. */\n           }\n           _ => {\n@@ -243,7 +243,7 @@ fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n       ast::stmt_semi(expr, stmt_id) => {\n         record_parent(cx, stmt_id);\n         let mut expr_cx = cx;\n-        expr_cx.parent = some(stmt_id);\n+        expr_cx.parent = Some(stmt_id);\n         visit::visit_stmt(stmt, expr_cx, visitor);\n       }\n     }\n@@ -257,12 +257,12 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n       ast::expr_call(*) => {\n         debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n                                                            cx.sess.intr()));\n-        new_cx.parent = some(expr.id);\n+        new_cx.parent = Some(expr.id);\n       }\n       ast::expr_match(subexpr, _) => {\n         debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n                                                            cx.sess.intr()));\n-        new_cx.parent = some(expr.id);\n+        new_cx.parent = Some(expr.id);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n       ast::expr_fn_block(_, _, cap_clause) => {\n@@ -280,7 +280,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     };\n \n     if new_cx.root_exprs.contains_key(expr.id) {\n-        new_cx.parent = some(expr.id);\n+        new_cx.parent = Some(expr.id);\n     }\n \n     visit::visit_expr(expr, new_cx, visitor);\n@@ -293,7 +293,7 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = ctxt {parent: none with cx};\n+    let new_cx: ctxt = ctxt {parent: None with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n@@ -305,7 +305,7 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n       visit::fk_item_fn(*) | visit::fk_method(*) |\n       visit::fk_ctor(*) | visit::fk_dtor(*) => {\n         // Top-level functions are a root scope.\n-        ctxt {parent: some(id) with cx}\n+        ctxt {parent: Some(id) with cx}\n       }\n \n       visit::fk_anon(*) | visit::fk_fn_block(*) => {\n@@ -331,7 +331,7 @@ fn resolve_crate(sess: session, def_map: resolve3::DefMap,\n                          def_map: def_map,\n                          region_map: int_hash(),\n                          root_exprs: int_hash(),\n-                         parent: none};\n+                         parent: None};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n@@ -437,16 +437,16 @@ impl determine_rp_ctxt {\n         assert id != 0;\n         let old_variance = self.region_paramd_items.find(id);\n         let joined_variance = match old_variance {\n-          none => variance,\n-          some(v) => join_variance(v, variance)\n+          None => variance,\n+          Some(v) => join_variance(v, variance)\n         };\n \n         debug!(\"add_rp() variance for %s: %? == %? ^ %?\",\n                ast_map::node_id_to_str(self.ast_map, id,\n                                        self.sess.parse_sess.interner),\n                joined_variance, old_variance, variance);\n \n-        if some(joined_variance) != old_variance {\n+        if Some(joined_variance) != old_variance {\n             self.region_paramd_items.insert(id, joined_variance);\n             self.worklist.push(id);\n         }\n@@ -466,8 +466,8 @@ impl determine_rp_ctxt {\n                                        self.sess.parse_sess.interner),\n                copy self.ambient_variance);\n         let vec = match self.dep_map.find(from) {\n-            some(vec) => vec,\n-            none => {\n+            Some(vec) => vec,\n+            None => {\n                 let vec = @dvec();\n                 self.dep_map.insert(from, vec);\n                 vec\n@@ -524,12 +524,12 @@ impl determine_rp_ctxt {\n     //\n     // If the region is explicitly specified, then we follows the\n     // normal rules.\n-    fn opt_region_is_relevant(opt_r: option<@ast::region>) -> bool {\n+    fn opt_region_is_relevant(opt_r: Option<@ast::region>) -> bool {\n         debug!(\"opt_region_is_relevant: %? (anon_implies_rp=%b)\",\n                opt_r, self.anon_implies_rp);\n         match opt_r {\n-          none => self.anon_implies_rp,\n-          some(r) => self.region_is_relevant(r)\n+          None => self.anon_implies_rp,\n+          Some(r) => self.region_is_relevant(r)\n         }\n     }\n \n@@ -638,8 +638,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n             } else {\n                 let cstore = cx.sess.cstore;\n                 match csearch::get_region_param(cstore, did) {\n-                  none => {}\n-                  some(variance) => {\n+                  None => {}\n+                  Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, cx.sess.intr()));\n                     if cx.opt_region_is_relevant(path.rp) {\n@@ -783,8 +783,8 @@ fn determine_rp_in_crate(sess: session,\n         let c_variance = cx.region_paramd_items.get(c_id);\n         debug!(\"popped %d from worklist\", c_id);\n         match cx.dep_map.find(c_id) {\n-          none => {}\n-          some(deps) => {\n+          None => {}\n+          Some(deps) => {\n             for deps.each |dep| {\n                 let v = add_variance(dep.ambient_variance, c_variance);\n                 cx.add_rp(dep.id, v);"}, {"sha": "adb50e8b13a7cd90e2f753109c0b58faa3ad3bc4", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 262, "deletions": 262, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -303,9 +303,9 @@ struct ImportResolution {\n \n     let mut outstanding_references: uint;\n \n-    let mut module_target: option<Target>;\n-    let mut value_target: option<Target>;\n-    let mut type_target: option<Target>;\n+    let mut module_target: Option<Target>;\n+    let mut value_target: Option<Target>;\n+    let mut type_target: Option<Target>;\n \n     let mut used: bool;\n \n@@ -314,14 +314,14 @@ struct ImportResolution {\n \n         self.outstanding_references = 0u;\n \n-        self.module_target = none;\n-        self.value_target = none;\n-        self.type_target = none;\n+        self.module_target = None;\n+        self.value_target = None;\n+        self.type_target = None;\n \n         self.used = false;\n     }\n \n-    fn target_for_namespace(namespace: Namespace) -> option<Target> {\n+    fn target_for_namespace(namespace: Namespace) -> Option<Target> {\n         match namespace {\n             ModuleNS    => return copy self.module_target,\n             TypeNS      => return copy self.type_target,\n@@ -340,7 +340,7 @@ enum ParentLink {\n /// One node in the tree of modules.\n struct Module {\n     let parent_link: ParentLink;\n-    let mut def_id: option<def_id>;\n+    let mut def_id: Option<def_id>;\n \n     let children: hashmap<Atom,@NameBindings>;\n     let imports: DVec<@ImportDirective>;\n@@ -379,7 +379,7 @@ struct Module {\n     // The index of the import we're resolving.\n     let mut resolved_import_count: uint;\n \n-    new(parent_link: ParentLink, def_id: option<def_id>) {\n+    new(parent_link: ParentLink, def_id: Option<def_id>) {\n         self.parent_link = parent_link;\n         self.def_id = def_id;\n \n@@ -403,10 +403,10 @@ struct Module {\n // XXX: This is a workaround due to is_none in the standard library mistakenly\n // requiring a T:copy.\n \n-pure fn is_none<T>(x: option<T>) -> bool {\n+pure fn is_none<T>(x: Option<T>) -> bool {\n     match x {\n-        none => return true,\n-        some(_) => return false\n+        None => return true,\n+        Some(_) => return false\n     }\n }\n \n@@ -435,51 +435,51 @@ struct Definition {\n // bound to.\n struct NameBindings {\n     let mut module_def: ModuleDef;         //< Meaning in module namespace.\n-    let mut type_def: option<Definition>;  //< Meaning in type namespace.\n-    let mut value_def: option<Definition>; //< Meaning in value namespace.\n+    let mut type_def: Option<Definition>;  //< Meaning in type namespace.\n+    let mut value_def: Option<Definition>; //< Meaning in value namespace.\n \n     // For error reporting\n     // XXX: Merge me into Definition.\n-    let mut module_span: option<span>;\n-    let mut type_span: option<span>;\n-    let mut value_span: option<span>;\n+    let mut module_span: Option<span>;\n+    let mut type_span: Option<span>;\n+    let mut value_span: Option<span>;\n \n     new() {\n         self.module_def = NoModuleDef;\n-        self.type_def = none;\n-        self.value_def = none;\n-        self.module_span = none;\n-        self.type_span = none;\n-        self.value_span = none;\n+        self.type_def = None;\n+        self.value_def = None;\n+        self.module_span = None;\n+        self.type_span = None;\n+        self.value_span = None;\n     }\n \n     /// Creates a new module in this set of name bindings.\n-    fn define_module(parent_link: ParentLink, def_id: option<def_id>,\n+    fn define_module(parent_link: ParentLink, def_id: Option<def_id>,\n                      sp: span) {\n         if self.module_def == NoModuleDef {\n             let module_ = @Module(parent_link, def_id);\n             self.module_def = ModuleDef(module_);\n-            self.module_span = some(sp);\n+            self.module_span = Some(sp);\n         }\n     }\n \n     /// Records a type definition.\n     fn define_type(privacy: Privacy, def: def, sp: span) {\n-        self.type_def = some(Definition { privacy: privacy, def: def });\n-        self.type_span = some(sp);\n+        self.type_def = Some(Definition { privacy: privacy, def: def });\n+        self.type_span = Some(sp);\n     }\n \n     /// Records a value definition.\n     fn define_value(privacy: Privacy, def: def, sp: span) {\n-        self.value_def = some(Definition { privacy: privacy, def: def });\n-        self.value_span = some(sp);\n+        self.value_def = Some(Definition { privacy: privacy, def: def });\n+        self.value_span = Some(sp);\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available() -> option<@Module> {\n+    fn get_module_if_available() -> Option<@Module> {\n         match self.module_def {\n-            NoModuleDef         => return none,\n-            ModuleDef(module_)  => return some(module_)\n+            NoModuleDef         => return None,\n+            ModuleDef(module_)  => return Some(module_)\n         }\n     }\n \n@@ -502,22 +502,22 @@ struct NameBindings {\n     fn defined_in_namespace(namespace: Namespace) -> bool {\n         match namespace {\n             ModuleNS    => return self.module_def != NoModuleDef,\n-            TypeNS      => return self.type_def != none,\n-            ValueNS     => return self.value_def != none\n+            TypeNS      => return self.type_def != None,\n+            ValueNS     => return self.value_def != None\n         }\n     }\n \n-    fn def_for_namespace(namespace: Namespace) -> option<Definition> {\n+    fn def_for_namespace(namespace: Namespace) -> Option<Definition> {\n         match namespace {\n           TypeNS => return self.type_def,\n           ValueNS => return self.value_def,\n           ModuleNS => match self.module_def {\n-            NoModuleDef => return none,\n+            NoModuleDef => return None,\n             ModuleDef(module_) =>\n                 match module_.def_id {\n-                    none => return none,\n-                    some(def_id) => {\n-                        return some(Definition {\n+                    None => return None,\n+                    Some(def_id) => {\n+                        return Some(Definition {\n                             privacy: Public,\n                             def: def_mod(def_id)\n                         });\n@@ -527,16 +527,16 @@ struct NameBindings {\n         }\n     }\n \n-    fn span_for_namespace(namespace: Namespace) -> option<span> {\n+    fn span_for_namespace(namespace: Namespace) -> Option<span> {\n         match self.def_for_namespace(namespace) {\n-          some(d) => {\n+          Some(d) => {\n             match namespace {\n               TypeNS   => self.type_span,\n               ValueNS  => self.value_span,\n               ModuleNS => self.module_span\n             }\n           }\n-          none => none\n+          None => None\n         }\n     }\n }\n@@ -617,7 +617,7 @@ struct Resolver {\n     let mut xray_context: XrayFlag;\n \n     // The trait that the current context can refer to.\n-    let mut current_trait_refs: option<@DVec<def_id>>;\n+    let mut current_trait_refs: Option<@DVec<def_id>>;\n \n     // The atom for the keyword \"self\".\n     let self_atom: Atom;\n@@ -643,7 +643,7 @@ struct Resolver {\n \n         self.graph_root = @NameBindings();\n         (*self.graph_root).define_module(NoParentLink,\n-                                         some({ crate: 0, node: 0 }),\n+                                         Some({ crate: 0, node: 0 }),\n                                          crate.span);\n \n         self.unused_import_lint_level = unused_import_lint_level(session);\n@@ -659,7 +659,7 @@ struct Resolver {\n         self.label_ribs = @dvec();\n \n         self.xray_context = NoXray;\n-        self.current_trait_refs = none;\n+        self.current_trait_refs = None;\n \n         self.self_atom = syntax::parse::token::special_idents::self_;\n         self.primitive_type_table = @PrimitiveTypeTable(self.session.\n@@ -776,16 +776,16 @@ struct Resolver {\n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n         match module_.children.find(name) {\n-            none => {\n+            None => {\n               let child = @NameBindings();\n               module_.children.insert(name, child);\n               return (child, new_parent);\n             }\n-            some(child) => {\n+            Some(child) => {\n               // We don't want to complain if the multiple definitions\n               // are in different namespaces.\n               match ns.find(|n| child.defined_in_namespace(n)) {\n-                some(ns) => {\n+                Some(ns) => {\n                   self.session.span_err(sp,\n                        #fmt(\"Duplicate definition of %s %s\",\n                             namespace_to_str(ns),\n@@ -858,7 +858,7 @@ struct Resolver {\n \n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n-              (*name_bindings).define_module(parent_link, some(def_id),\n+              (*name_bindings).define_module(parent_link, Some(def_id),\n                                              sp);\n \n                 let new_parent =\n@@ -872,7 +872,7 @@ struct Resolver {\n \n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n-                (*name_bindings).define_module(parent_link, some(def_id),\n+                (*name_bindings).define_module(parent_link, Some(def_id),\n                                                sp);\n \n                 let new_parent =\n@@ -934,7 +934,7 @@ struct Resolver {\n             item_class(struct_definition, _) => {\n                 let new_parent =\n                     match struct_definition.ctor {\n-                    none => {\n+                    None => {\n                         let (name_bindings, new_parent) =\n                             self.add_child(atom, parent, ~[TypeNS], sp);\n \n@@ -944,7 +944,7 @@ struct Resolver {\n                              sp);\n                         new_parent\n                     }\n-                    some(ctor) => {\n+                    Some(ctor) => {\n                         let (name_bindings, new_parent) =\n                             self.add_child(atom, parent, ~[ValueNS, TypeNS],\n                                            sp);\n@@ -1182,7 +1182,7 @@ struct Resolver {\n \n             view_item_use(name, _, node_id) => {\n                 match find_use_stmt_cnum(self.session.cstore, node_id) {\n-                    some(crate_id) => {\n+                    Some(crate_id) => {\n                         let (child_name_bindings, new_parent) =\n                             // should this be in ModuleNS? --tjc\n                             self.add_child(name, parent, ~[ModuleNS],\n@@ -1193,12 +1193,12 @@ struct Resolver {\n                             (self.get_module_from_parent(new_parent), name);\n \n                         (*child_name_bindings).define_module(parent_link,\n-                                                             some(def_id),\n+                                                             Some(def_id),\n                                                              view_item.span);\n                         self.build_reduced_graph_for_external_crate\n                             ((*child_name_bindings).get_module());\n                     }\n-                    none => {\n+                    None => {\n                         /* Ignore. */\n                     }\n                 }\n@@ -1250,7 +1250,7 @@ struct Resolver {\n \n             let parent_module = self.get_module_from_parent(parent);\n             let new_module = @Module(BlockParentLink(parent_module, block_id),\n-                                     none);\n+                                     None);\n             parent_module.anonymous_children.insert(block_id, new_module);\n             new_parent = ModuleReducedGraphParent(new_module);\n         } else {\n@@ -1274,14 +1274,14 @@ struct Resolver {\n                 let parent_link = self.get_parent_link(new_parent, atom);\n \n                 match modules.find(def_id) {\n-                  none => {\n+                  None => {\n                     child_name_bindings.define_module(parent_link,\n-                                                      some(def_id),\n+                                                      Some(def_id),\n                                                       dummy_sp());\n                     modules.insert(def_id,\n                                    child_name_bindings.get_module());\n                   }\n-                  some(existing_module) => {\n+                  Some(existing_module) => {\n                     // Create an import resolution to\n                     // avoid creating cycles in the\n                     // module graph.\n@@ -1299,7 +1299,7 @@ struct Resolver {\n                         let name_bindings = parent_module.children.get(atom);\n \n                         resolution.module_target =\n-                            some(Target(parent_module, name_bindings));\n+                            Some(Target(parent_module, name_bindings));\n                       }\n                     }\n \n@@ -1314,7 +1314,7 @@ struct Resolver {\n                 debug!(\"(building reduced graph for \\\n                         external crate) already created \\\n                         module\");\n-                module_.def_id = some(def_id);\n+                module_.def_id = Some(def_id);\n                 modules.insert(def_id, module_);\n               }\n             }\n@@ -1334,10 +1334,10 @@ struct Resolver {\n \n             match get_method_names_if_trait(self.session.cstore,\n                                             def_id) {\n-              none => {\n+              None => {\n                 // Nothing to do.\n               }\n-              some(method_names) => {\n+              Some(method_names) => {\n                 let interned_method_names = @atom_hashmap();\n                 for method_names.each |method_data| {\n                     let (method_name, self_ty) = method_data;\n@@ -1420,7 +1420,7 @@ struct Resolver {\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n                         (*child_name_bindings).define_module(parent_link,\n-                                                       none, dummy_sp());\n+                                                       None, dummy_sp());\n                     }\n                     ModuleDef(_) => { /* Fall through. */ }\n                 }\n@@ -1472,10 +1472,10 @@ struct Resolver {\n         match *subclass {\n             SingleImport(target, _) => {\n                 match module_.import_resolutions.find(target) {\n-                    some(resolution) => {\n+                    Some(resolution) => {\n                         resolution.outstanding_references += 1u;\n                     }\n-                    none => {\n+                    None => {\n                         let resolution = @ImportResolution(span);\n                         resolution.outstanding_references = 1u;\n                         module_.import_resolutions.insert(target, resolution);\n@@ -1542,10 +1542,10 @@ struct Resolver {\n \n         for module_.children.each |_name, child_node| {\n             match (*child_node).get_module_if_available() {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(child_module) => {\n+                Some(child_module) => {\n                     self.resolve_imports_for_module_subtree(child_module);\n                 }\n             }\n@@ -1725,10 +1725,10 @@ struct Resolver {\n \n         // Search for direct children of the containing module.\n         match containing_module.children.find(source) {\n-            none => {\n+            None => {\n                 // Continue.\n             }\n-            some(child_name_bindings) => {\n+            Some(child_name_bindings) => {\n                 if (*child_name_bindings).defined_in_namespace(ModuleNS) {\n                     module_result = BoundResult(containing_module,\n                                                 child_name_bindings);\n@@ -1766,7 +1766,7 @@ struct Resolver {\n                 // module.\n \n                 match containing_module.import_resolutions.find(source) {\n-                    none => {\n+                    None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n                         // therefore accurately report that the names are\n@@ -1782,7 +1782,7 @@ struct Resolver {\n                             type_result = UnboundResult;\n                         }\n                     }\n-                    some(import_resolution)\n+                    Some(import_resolution)\n                             if import_resolution.outstanding_references\n                                 == 0u => {\n \n@@ -1792,10 +1792,10 @@ struct Resolver {\n \n                             match (*import_resolution).\n                                     target_for_namespace(namespace) {\n-                                none => {\n+                                None => {\n                                     return UnboundResult;\n                                 }\n-                                some(target) => {\n+                                Some(target) => {\n                                     import_resolution.used = true;\n                                     return BoundResult(target.target_module,\n                                                     target.bindings);\n@@ -1819,7 +1819,7 @@ struct Resolver {\n                                                       TypeNS);\n                         }\n                     }\n-                    some(_) => {\n+                    Some(_) => {\n                         // The import is unresolved. Bail out.\n                         debug!(\"(resolving single import) unresolved import; \\\n                                 bailing out\");\n@@ -1837,7 +1837,7 @@ struct Resolver {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found module binding\");\n                 import_resolution.module_target =\n-                    some(Target(target_module, name_bindings));\n+                    Some(Target(target_module, name_bindings));\n             }\n             UnboundResult => {\n                 debug!(\"(resolving single import) didn't find module \\\n@@ -1850,7 +1850,7 @@ struct Resolver {\n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n                 import_resolution.value_target =\n-                    some(Target(target_module, name_bindings));\n+                    Some(Target(target_module, name_bindings));\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n@@ -1860,7 +1860,7 @@ struct Resolver {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 import_resolution.type_target =\n-                    some(Target(target_module, name_bindings));\n+                    Some(Target(target_module, name_bindings));\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n@@ -1874,7 +1874,7 @@ struct Resolver {\n             If this name wasn't found in any of the four namespaces, it's\n             definitely unresolved\n            */\n-          (none, none, none) => { return Failed; }\n+          (None, None, None) => { return Failed; }\n           _ => {}\n         }\n \n@@ -1927,7 +1927,7 @@ struct Resolver {\n \n             // Here we merge two import resolutions.\n             match module_.import_resolutions.find(atom) {\n-                none => {\n+                None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n                         @ImportResolution(target_import_resolution.span);\n@@ -1941,35 +1941,35 @@ struct Resolver {\n                     module_.import_resolutions.insert\n                         (atom, new_import_resolution);\n                 }\n-                some(dest_import_resolution) => {\n+                Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n                     match copy target_import_resolution.module_target {\n-                        none => {\n+                        None => {\n                             // Continue.\n                         }\n-                        some(module_target) => {\n+                        Some(module_target) => {\n                             dest_import_resolution.module_target =\n-                                some(copy module_target);\n+                                Some(copy module_target);\n                         }\n                     }\n                     match copy target_import_resolution.value_target {\n-                        none => {\n+                        None => {\n                             // Continue.\n                         }\n-                        some(value_target) => {\n+                        Some(value_target) => {\n                             dest_import_resolution.value_target =\n-                                some(copy value_target);\n+                                Some(copy value_target);\n                         }\n                     }\n                     match copy target_import_resolution.type_target {\n-                        none => {\n+                        None => {\n                             // Continue.\n                         }\n-                        some(type_target) => {\n+                        Some(type_target) => {\n                             dest_import_resolution.type_target =\n-                                some(copy type_target);\n+                                Some(copy type_target);\n                         }\n                     }\n                 }\n@@ -1986,13 +1986,13 @@ struct Resolver {\n \n             let mut dest_import_resolution;\n             match module_.import_resolutions.find(atom) {\n-                none => {\n+                None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(span);\n                     module_.import_resolutions.insert\n                         (atom, dest_import_resolution);\n                 }\n-                some(existing_import_resolution) => {\n+                Some(existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n                 }\n             }\n@@ -2008,17 +2008,17 @@ struct Resolver {\n             if (*name_bindings).defined_in_namespace(ModuleNS) {\n                 debug!(\"(resolving glob import) ... for module target\");\n                 dest_import_resolution.module_target =\n-                    some(Target(containing_module, name_bindings));\n+                    Some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(ValueNS) {\n                 debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n-                    some(Target(containing_module, name_bindings));\n+                    Some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(TypeNS) {\n                 debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n-                    some(Target(containing_module, name_bindings));\n+                    Some(Target(containing_module, name_bindings));\n             }\n         }\n \n@@ -2139,12 +2139,12 @@ struct Resolver {\n         // its immediate children.\n \n         match module_.children.find(name) {\n-            some(name_bindings)\n+            Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n                 return Success(Target(module_, name_bindings));\n             }\n-            some(_) | none => { /* Not found; continue. */ }\n+            Some(_) | None => { /* Not found; continue. */ }\n         }\n \n         // Now check for its import directives. We don't have to have resolved\n@@ -2153,18 +2153,18 @@ struct Resolver {\n         // current scope.\n \n         match module_.import_resolutions.find(name) {\n-            none => {\n+            None => {\n                 // Not found; continue.\n             }\n-            some(import_resolution) => {\n+            Some(import_resolution) => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n-                    none => {\n+                    None => {\n                         // Not found; continue.\n                         debug!(\"(resolving item in lexical scope) found \\\n                                 import resolution, but not in namespace %?\",\n                                namespace);\n                     }\n-                    some(target) => {\n+                    Some(target) => {\n                         import_resolution.used = true;\n                         return Success(copy target);\n                     }\n@@ -2268,13 +2268,13 @@ struct Resolver {\n \n         // First, check the direct children of the module.\n         match module_.children.find(name) {\n-            some(name_bindings)\n+            Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n                 debug!(\"(resolving name in module) found node as child\");\n                 return Success(Target(module_, name_bindings));\n             }\n-            some(_) | none => {\n+            Some(_) | None => {\n                 // Continue.\n             }\n         }\n@@ -2289,28 +2289,28 @@ struct Resolver {\n \n         // Otherwise, we check the list of resolved imports.\n         match module_.import_resolutions.find(name) {\n-            some(import_resolution) => {\n+            Some(import_resolution) => {\n                 if import_resolution.outstanding_references != 0u {\n                     debug!(\"(resolving name in module) import unresolved; \\\n                             bailing out\");\n                     return Indeterminate;\n                 }\n \n                 match (*import_resolution).target_for_namespace(namespace) {\n-                    none => {\n+                    None => {\n                         debug!(\"(resolving name in module) name found, but \\\n                                 not in namespace %?\",\n                                namespace);\n                     }\n-                    some(target) => {\n+                    Some(target) => {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         import_resolution.used = true;\n                         return Success(copy target);\n                     }\n                 }\n             }\n-            none => {\n+            None => {\n                 // Continue.\n             }\n         }\n@@ -2361,7 +2361,7 @@ struct Resolver {\n             Failed => {\n                 debug!(\"(resolving one-level renaming import) didn't find \\\n                         module result\");\n-                module_result = none;\n+                module_result = None;\n             }\n             Indeterminate => {\n                 debug!(\"(resolving one-level renaming import) module result \\\n@@ -2371,7 +2371,7 @@ struct Resolver {\n             Success(name_bindings) => {\n                 debug!(\"(resolving one-level renaming import) module result \\\n                         found\");\n-                module_result = some(copy name_bindings);\n+                module_result = Some(copy name_bindings);\n             }\n         }\n \n@@ -2384,7 +2384,7 @@ struct Resolver {\n             Failed => {\n                 debug!(\"(resolving one-level renaming import) didn't find \\\n                         value result\");\n-                value_result = none;\n+                value_result = None;\n             }\n             Indeterminate => {\n                 debug!(\"(resolving one-level renaming import) value result \\\n@@ -2394,7 +2394,7 @@ struct Resolver {\n             Success(name_bindings) => {\n                 debug!(\"(resolving one-level renaming import) value result \\\n                         found\");\n-                value_result = some(copy name_bindings);\n+                value_result = Some(copy name_bindings);\n             }\n         }\n \n@@ -2407,7 +2407,7 @@ struct Resolver {\n             Failed => {\n                 debug!(\"(resolving one-level renaming import) didn't find \\\n                         type result\");\n-                type_result = none;\n+                type_result = None;\n             }\n             Indeterminate => {\n                 debug!(\"(resolving one-level renaming import) type result is \\\n@@ -2417,7 +2417,7 @@ struct Resolver {\n             Success(name_bindings) => {\n                 debug!(\"(resolving one-level renaming import) type result \\\n                         found\");\n-                type_result = some(copy name_bindings);\n+                type_result = Some(copy name_bindings);\n             }\n         }\n \n@@ -2450,12 +2450,12 @@ struct Resolver {\n \n         // Otherwise, proceed and write in the bindings.\n         match module_.import_resolutions.find(target_name) {\n-            none => {\n+            None => {\n                 fail ~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n                       import resolution name by now\";\n             }\n-            some(import_resolution) => {\n+            Some(import_resolution) => {\n                 debug!(\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(module_result),\n@@ -2486,10 +2486,10 @@ struct Resolver {\n         // Descend into children and anonymous children.\n         for module_.children.each |_name, child_node| {\n             match (*child_node).get_module_if_available() {\n-                none => {\n+                None => {\n                     // Continue.\n                 }\n-                some(child_module) => {\n+                Some(child_module) => {\n                     self.report_unresolved_imports(child_module);\n                 }\n             }\n@@ -2519,13 +2519,13 @@ struct Resolver {\n         // exports for local crates.\n \n         match module_.def_id {\n-            some(def_id) if def_id.crate == local_crate => {\n+            Some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n             }\n-            none => {\n+            None => {\n                 // Record exports for the root module.\n             }\n-            some(_) => {\n+            Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `%s`\",\n@@ -2538,10 +2538,10 @@ struct Resolver {\n \n         for module_.children.each |_atom, child_name_bindings| {\n             match (*child_name_bindings).get_module_if_available() {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(child_module) => {\n+                Some(child_module) => {\n                     self.record_exports_for_module_subtree(child_module);\n                 }\n             }\n@@ -2601,12 +2601,12 @@ struct Resolver {\n         }\n \n         match copy module_.def_id {\n-            some(def_id) => {\n+            Some(def_id) => {\n                 self.export_map2.insert(def_id.node, move exports2);\n                 debug!(\"(computing exports) writing exports for %d (some)\",\n                        def_id.node);\n             }\n-            none => {}\n+            None => {}\n         }\n     }\n \n@@ -2628,30 +2628,30 @@ struct Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(name: option<Atom>, f: fn()) {\n+    fn with_scope(name: Option<Atom>, f: fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n         match name {\n-            none => {\n+            None => {\n                 // Nothing to do.\n             }\n-            some(name) => {\n+            Some(name) => {\n                 match orig_module.children.find(name) {\n-                    none => {\n+                    None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n-                    some(name_bindings) => {\n+                    Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n-                            none => {\n+                            None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n                                        self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n-                            some(module_) => {\n+                            Some(module_) => {\n                                 self.current_module = module_;\n                             }\n                         }\n@@ -2670,7 +2670,7 @@ struct Resolver {\n \n     fn upvarify(ribs: @DVec<@Rib>, rib_index: uint, def_like: def_like,\n                 span: span, allow_capturing_self: AllowCapturingSelfFlag)\n-             -> option<def_like> {\n+             -> Option<def_like> {\n \n         let mut def;\n         let mut is_ty_param;\n@@ -2691,7 +2691,7 @@ struct Resolver {\n                 is_ty_param = false;\n             }\n             _ => {\n-                return some(def_like);\n+                return Some(def_like);\n             }\n         }\n \n@@ -2715,7 +2715,7 @@ struct Resolver {\n                   // item, it's ok\n                   match def {\n                     def_ty_param(did, _) if self.def_map.find(copy(did.node))\n-                      == some(def_typaram_binder(item_id)) => {\n+                      == Some(def_typaram_binder(item_id)) => {\n                       // ok\n                     }\n                     _ => {\n@@ -2736,7 +2736,7 @@ struct Resolver {\n                                                argument out of scope\");\n                     }\n \n-                    return none;\n+                    return None;\n                     }\n                   }\n                 }\n@@ -2758,19 +2758,19 @@ struct Resolver {\n                                                argument out of scope\");\n                     }\n \n-                    return none;\n+                    return None;\n                 }\n             }\n \n             rib_index += 1u;\n         }\n \n-        return some(dl_def(def));\n+        return Some(dl_def(def));\n     }\n \n     fn search_ribs(ribs: @DVec<@Rib>, name: Atom, span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n-                -> option<def_like> {\n+                -> Option<def_like> {\n \n         // XXX: This should not use a while loop.\n         // XXX: Try caching?\n@@ -2780,17 +2780,17 @@ struct Resolver {\n             i -= 1u;\n             let rib = (*ribs).get_elt(i);\n             match rib.bindings.find(name) {\n-                some(def_like) => {\n+                Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                       allow_capturing_self);\n                 }\n-                none => {\n+                None => {\n                     // Continue.\n                 }\n             }\n         }\n \n-        return none;\n+        return None;\n     }\n \n     fn resolve_crate(@self) {\n@@ -2863,11 +2863,11 @@ struct Resolver {\n                     for traits.each |trt| {\n                         match self.resolve_path(trt.path, TypeNS, true,\n                                                 visitor) {\n-                            none =>\n+                            None =>\n                                 self.session.span_err(trt.path.span,\n                                                       ~\"attempt to derive a \\\n                                                        nonexistent trait\"),\n-                            some(def) => {\n+                            Some(def) => {\n                                 // Write a mapping from the trait ID to the\n                                 // definition of the trait into the definition\n                                 // map.\n@@ -2932,14 +2932,14 @@ struct Resolver {\n             }\n \n             item_mod(module_) => {\n-                do self.with_scope(some(item.ident)) {\n+                do self.with_scope(Some(item.ident)) {\n                     self.resolve_module(module_, item.span, item.ident,\n                                         item.id, visitor);\n                 }\n             }\n \n             item_foreign_mod(foreign_module) => {\n-                do self.with_scope(some(item.ident)) {\n+                do self.with_scope(Some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n                         match foreign_item.node {\n                             foreign_item_fn(_, _, type_parameters) => {\n@@ -2974,11 +2974,11 @@ struct Resolver {\n                     is_none(self.session.main_fn) &&\n                     item.ident == syntax::parse::token::special_idents::main {\n \n-                    self.session.main_fn = some((item.id, item.span));\n+                    self.session.main_fn = Some((item.id, item.span));\n                 }\n \n                 self.resolve_function(OpaqueFunctionRibKind,\n-                                      some(@fn_decl),\n+                                      Some(@fn_decl),\n                                       HasTypeParameters\n                                         (&ty_params,\n                                          item.id,\n@@ -3050,7 +3050,7 @@ struct Resolver {\n     }\n \n     fn resolve_function(rib_kind: RibKind,\n-                        optional_declaration: option<@fn_decl>,\n+                        optional_declaration: Option<@fn_decl>,\n                         type_parameters: TypeParameters,\n                         block: blk,\n                         self_binding: SelfBinding,\n@@ -3069,12 +3069,12 @@ struct Resolver {\n                                                 ValueNS,\n                                                 true,\n                                                 capture_item.span) {\n-                        none => {\n+                        None => {\n                             self.session.span_err(capture_item.span,\n                                                   ~\"unresolved name in \\\n                                                    capture clause\");\n                         }\n-                        some(def) => {\n+                        Some(def) => {\n                             self.record_def(capture_item.id, def);\n                         }\n                     }\n@@ -3116,10 +3116,10 @@ struct Resolver {\n \n             // Add each argument to the rib.\n             match optional_declaration {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(declaration) => {\n+                Some(declaration) => {\n                     for declaration.inputs.each |argument| {\n                         let name = argument.ident;\n                         let def_like = dl_def(def_arg(argument.id,\n@@ -3168,8 +3168,8 @@ struct Resolver {\n                      traits: ~[@trait_ref],\n                      fields: ~[@struct_field],\n                      methods: ~[@method],\n-                     optional_constructor: option<class_ctor>,\n-                     optional_destructor: option<class_dtor>,\n+                     optional_constructor: Option<class_ctor>,\n+                     optional_destructor: Option<class_dtor>,\n                      visitor: ResolveVisitor) {\n \n         // If applicable, create a rib for the type parameters.\n@@ -3185,12 +3185,12 @@ struct Resolver {\n             // Resolve implemented traits.\n             for traits.each |trt| {\n                 match self.resolve_path(trt.path, TypeNS, true, visitor) {\n-                    none => {\n+                    None => {\n                         self.session.span_err(trt.path.span,\n                                               ~\"attempt to implement a \\\n                                                nonexistent trait\");\n                     }\n-                    some(def) => {\n+                    Some(def) => {\n                         // Write a mapping from the trait ID to the\n                         // definition of the trait into the definition\n                         // map.\n@@ -3222,12 +3222,12 @@ struct Resolver {\n \n             // Resolve the constructor, if applicable.\n             match optional_constructor {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(constructor) => {\n+                Some(constructor) => {\n                     self.resolve_function(NormalRibKind,\n-                                          some(@constructor.node.dec),\n+                                          Some(@constructor.node.dec),\n                                           NoTypeParameters,\n                                           constructor.node.body,\n                                           HasSelfBinding(constructor.node.\n@@ -3239,12 +3239,12 @@ struct Resolver {\n \n             // Resolve the destructor, if applicable.\n             match optional_destructor {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(destructor) => {\n+                Some(destructor) => {\n                     self.resolve_function(NormalRibKind,\n-                                          none,\n+                                          None,\n                                           NoTypeParameters,\n                                           destructor.node.body,\n                                           HasSelfBinding\n@@ -3275,7 +3275,7 @@ struct Resolver {\n         };\n \n         self.resolve_function(rib_kind,\n-                              some(@method.decl),\n+                              Some(@method.decl),\n                               type_parameters,\n                               method.body,\n                               self_binding,\n@@ -3308,12 +3308,12 @@ struct Resolver {\n                 for trait_references.each |trait_reference| {\n                     match self.resolve_path(\n                         trait_reference.path, TypeNS, true, visitor) {\n-                        none => {\n+                        None => {\n                             self.session.span_err(span,\n                                                   ~\"attempt to implement an \\\n                                                     unknown trait\");\n                         }\n-                        some(def) => {\n+                        Some(def) => {\n                             self.record_def(trait_reference.ref_id, def);\n \n                             // Record the current trait reference.\n@@ -3323,7 +3323,7 @@ struct Resolver {\n                 }\n \n                 // Record the current set of trait references.\n-                self.current_trait_refs = some(new_trait_refs);\n+                self.current_trait_refs = Some(new_trait_refs);\n             }\n \n             // Resolve the self type.\n@@ -3339,7 +3339,7 @@ struct Resolver {\n /*\n                 let borrowed_type_parameters = &method.tps;\n                 self.resolve_function(MethodRibKind(id, Provided(method.id)),\n-                                      some(@method.decl),\n+                                      Some(@method.decl),\n                                       HasTypeParameters\n                                         (borrowed_type_parameters,\n                                          method.id,\n@@ -3378,17 +3378,17 @@ struct Resolver {\n \n         // Resolve the initializer, if necessary.\n         match local.node.init {\n-            none => {\n+            None => {\n                 // Nothing to do.\n             }\n-            some(initializer) => {\n+            Some(initializer) => {\n                 self.resolve_expr(initializer.expr, visitor);\n             }\n         }\n \n         // Resolve the pattern.\n         self.resolve_pattern(local.node.pat, IrrefutableMode, mutability,\n-                             none, visitor);\n+                             None, visitor);\n     }\n \n     fn binding_mode_map(pat: @pat) -> BindingMap {\n@@ -3410,14 +3410,14 @@ struct Resolver {\n \n             for map_0.each |key, binding_0| {\n                 match map_i.find(key) {\n-                  none => {\n+                  None => {\n                     self.session.span_err(\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n                              self.session.str_of(key), i + 1));\n                   }\n-                  some(binding_i) => {\n+                  Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n@@ -3447,7 +3447,7 @@ struct Resolver {\n         let bindings_list = atom_hashmap();\n         for arm.pats.each |pattern| {\n             self.resolve_pattern(pattern, RefutableMode, Immutable,\n-                                 some(bindings_list), visitor);\n+                                 Some(bindings_list), visitor);\n         }\n \n         // This has to happen *after* we determine which\n@@ -3467,8 +3467,8 @@ struct Resolver {\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(block.node.id) {\n-            none => { /* Nothing to do. */ }\n-            some(anonymous_module) => {\n+            None => { /* Nothing to do. */ }\n+            Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n                         down\");\n                 self.current_module = anonymous_module;\n@@ -3496,21 +3496,21 @@ struct Resolver {\n \n                 let mut result_def;\n                 match self.resolve_path(path, TypeNS, true, visitor) {\n-                    some(def) => {\n+                    Some(def) => {\n                         debug!(\"(resolving type) resolved `%s` to type\",\n                                self.session.str_of(path.idents.last()));\n-                        result_def = some(def);\n+                        result_def = Some(def);\n                     }\n-                    none => {\n-                        result_def = none;\n+                    None => {\n+                        result_def = None;\n                     }\n                 }\n \n                 match result_def {\n-                    some(_) => {\n+                    Some(_) => {\n                         // Continue.\n                     }\n-                    none => {\n+                    None => {\n                         // Check to see whether the name is a primitive type.\n                         if path.idents.len() == 1u {\n                             let name = path.idents.last();\n@@ -3519,11 +3519,11 @@ struct Resolver {\n                                     .primitive_types\n                                     .find(name) {\n \n-                                some(primitive_type) => {\n+                                Some(primitive_type) => {\n                                     result_def =\n-                                        some(def_prim_ty(primitive_type));\n+                                        Some(def_prim_ty(primitive_type));\n                                 }\n-                                none => {\n+                                None => {\n                                     // Continue.\n                                 }\n                             }\n@@ -3532,7 +3532,7 @@ struct Resolver {\n                 }\n \n                 match copy result_def {\n-                    some(def) => {\n+                    Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n@@ -3541,7 +3541,7 @@ struct Resolver {\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n-                    none => {\n+                    None => {\n                         self.session.span_err\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n                                            connect(path.idents.map(\n@@ -3563,7 +3563,7 @@ struct Resolver {\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n-                       bindings_list: option<hashmap<Atom,node_id>>,\n+                       bindings_list: Option<hashmap<Atom,node_id>>,\n                        visitor: ResolveVisitor) {\n \n         let pat_id = pattern.id;\n@@ -3636,15 +3636,15 @@ struct Resolver {\n                             // passes make about or-patterns.)\n \n                             match bindings_list {\n-                                some(bindings_list)\n+                                Some(bindings_list)\n                                 if !bindings_list.contains_key(atom) => {\n                                     let last_rib = (*self.value_ribs).last();\n                                     last_rib.bindings.insert(atom,\n                                                              dl_def(def));\n                                     bindings_list.insert(atom, pat_id);\n                                 }\n-                                some(b) => {\n-                                  if b.find(atom) == some(pat_id) {\n+                                Some(b) => {\n+                                  if b.find(atom) == Some(pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -3656,7 +3656,7 @@ struct Resolver {\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n-                                none => {\n+                                None => {\n                                     let last_rib = (*self.value_ribs).last();\n                                     last_rib.bindings.insert(atom,\n                                                              dl_def(def));\n@@ -3674,17 +3674,17 @@ struct Resolver {\n                 pat_ident(_, path, _) | pat_enum(path, _) => {\n                     // These two must be enum variants.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n-                        some(def @ def_variant(*)) => {\n+                        Some(def @ def_variant(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n-                        some(_) => {\n+                        Some(_) => {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"not an enum variant: %s\",\n                                      self.session.str_of(\n                                          path.idents.last())));\n                         }\n-                        none => {\n+                        None => {\n                             self.session.span_err(path.span,\n                                                   ~\"unresolved enum variant\");\n                         }\n@@ -3707,14 +3707,14 @@ struct Resolver {\n \n                 pat_struct(path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n-                        some(def_ty(class_id))\n+                        Some(def_ty(class_id))\n                                 if self.structs.contains_key(class_id) => {\n                             let has_constructor = self.structs.get(class_id);\n                             let class_def = def_class(class_id,\n                                                       has_constructor);\n                             self.record_def(pattern.id, class_def);\n                         }\n-                        some(definition @ def_variant(_, variant_id))\n+                        Some(definition @ def_variant(_, variant_id))\n                                 if self.structs.contains_key(variant_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -3745,11 +3745,11 @@ struct Resolver {\n \n             Success(target) => {\n                 match target.bindings.value_def {\n-                    none => {\n+                    None => {\n                         fail ~\"resolved name in the value namespace to a set \\\n                               of name bindings with no def?!\";\n                     }\n-                    some(def) => {\n+                    Some(def) => {\n                         match def.def {\n                             def @ def_variant(*) => {\n                                 return FoundEnumVariant(def);\n@@ -3781,7 +3781,7 @@ struct Resolver {\n      */\n     fn resolve_path(path: @path, namespace: Namespace, check_ribs: bool,\n                     visitor: ResolveVisitor)\n-                 -> option<def> {\n+                 -> Option<def> {\n \n         // First, resolve the types.\n         for path.types.each |ty| {\n@@ -3810,16 +3810,16 @@ struct Resolver {\n                           namespace: Namespace,\n                           check_ribs: bool,\n                           span: span)\n-                       -> option<def> {\n+                       -> Option<def> {\n \n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n                                                       span) {\n-                some(def) => {\n-                    return some(def);\n+                Some(def) => {\n+                    return Some(def);\n                 }\n-                none => {\n+                None => {\n                     // Continue.\n                 }\n             }\n@@ -3845,48 +3845,48 @@ struct Resolver {\n \n         // First, search children.\n         match containing_module.children.find(name) {\n-            some(child_name_bindings) => {\n+            Some(child_name_bindings) => {\n                 match (*child_name_bindings).def_for_namespace(namespace) {\n-                    some(def) if def.privacy == Public => {\n+                    Some(def) if def.privacy == Public => {\n                         // Found it. Stop the search here.\n                         return ChildNameDefinition(def.def);\n                     }\n-                    some(_) | none => {\n+                    Some(_) | None => {\n                         // Continue.\n                     }\n                 }\n             }\n-            none => {\n+            None => {\n                 // Continue.\n             }\n         }\n \n         // Next, search import resolutions.\n         match containing_module.import_resolutions.find(name) {\n-            some(import_resolution) => {\n+            Some(import_resolution) => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n-                    some(target) => {\n+                    Some(target) => {\n                         match (*target.bindings)\n                             .def_for_namespace(namespace) {\n-                            some(def) if def.privacy == Public => {\n+                            Some(def) if def.privacy == Public => {\n                                 // Found it.\n                                 import_resolution.used = true;\n                                 return ImportNameDefinition(def.def);\n                             }\n-                            some(_) | none => {\n+                            Some(_) | None => {\n                                 // This can happen with external impls, due to\n                                 // the imperfect way we read the metadata.\n \n                                 return NoNameDefinition;\n                             }\n                         }\n                     }\n-                    none => {\n+                    None => {\n                         return NoNameDefinition;\n                     }\n                 }\n             }\n-            none => {\n+            None => {\n                 return NoNameDefinition;\n             }\n         }\n@@ -3908,7 +3908,7 @@ struct Resolver {\n     fn resolve_module_relative_path(path: @path,\n                                     +xray: XrayFlag,\n                                     namespace: Namespace)\n-                                 -> option<def> {\n+                                 -> Option<def> {\n \n         let module_path_atoms = self.intern_module_part_of_path(path);\n \n@@ -3923,7 +3923,7 @@ struct Resolver {\n                                       fmt!(\"use of undeclared module `%s`\",\n                                            self.atoms_to_str(\n                                                (*module_path_atoms).get())));\n-                return none;\n+                return None;\n             }\n \n             Indeterminate => {\n@@ -3947,18 +3947,18 @@ struct Resolver {\n                     fmt!(\"unresolved name: %s::%s\",\n                          self.atoms_to_str((*module_path_atoms).get()),\n                          self.session.str_of(name)));\n-                return none;\n+                return None;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n-                return some(def);\n+                return Some(def);\n             }\n         }\n     }\n \n     fn resolve_crate_relative_path(path: @path,\n                                    +xray: XrayFlag,\n                                    namespace: Namespace)\n-                                -> option<def> {\n+                                -> Option<def> {\n \n         let module_path_atoms = self.intern_module_part_of_path(path);\n \n@@ -3976,7 +3976,7 @@ struct Resolver {\n                                       fmt!(\"use of undeclared module `::%s`\",\n                                             self.atoms_to_str\n                                               ((*module_path_atoms).get())));\n-                return none;\n+                return None;\n             }\n \n             Indeterminate => {\n@@ -4000,18 +4000,18 @@ struct Resolver {\n                     fmt!(\"unresolved name: %s::%s\", self.atoms_to_str(\n                         (*module_path_atoms).get()),\n                          self.session.str_of(name)));\n-                return none;\n+                return None;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n-                return some(def);\n+                return Some(def);\n             }\n         }\n     }\n \n     fn resolve_identifier_in_local_ribs(ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n-                                     -> option<def> {\n+                                     -> Option<def> {\n         // Check the local set of ribs.\n         let mut search_result;\n         match namespace {\n@@ -4029,22 +4029,22 @@ struct Resolver {\n         }\n \n         match copy search_result {\n-            some(dl_def(def)) => {\n+            Some(dl_def(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n                        self.session.str_of(ident),\n                        def);\n-                return some(def);\n+                return Some(def);\n             }\n-            some(dl_field) | some(dl_impl(_)) | none => {\n-                return none;\n+            Some(dl_field) | Some(dl_impl(_)) | None => {\n+                return None;\n             }\n         }\n     }\n \n     fn resolve_item_by_identifier_in_lexical_scope(ident: ident,\n                                                    namespace: Namespace)\n-                                                -> option<def> {\n+                                                -> Option<def> {\n \n         // Check the items.\n         match self.resolve_item_in_lexical_scope(self.current_module,\n@@ -4053,23 +4053,23 @@ struct Resolver {\n \n             Success(target) => {\n                 match (*target.bindings).def_for_namespace(namespace) {\n-                    none => {\n+                    None => {\n                         fail ~\"resolved name in a namespace to a set of name \\\n                               bindings with no def for that namespace?!\";\n                     }\n-                    some(def) => {\n+                    Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n                                self.session.str_of(ident));\n-                        return some(def.def);\n+                        return Some(def.def);\n                     }\n                 }\n             }\n             Indeterminate => {\n                 fail ~\"unexpected indeterminate result\";\n             }\n             Failed => {\n-                return none;\n+                return None;\n             }\n         }\n     }\n@@ -4131,14 +4131,14 @@ struct Resolver {\n                 // scopes looking for it.\n \n                 match self.resolve_path(path, ValueNS, true, visitor) {\n-                    some(def) => {\n+                    Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n                                connect(path.idents.map(\n                                    |x| self.session.str_of(x)), ~\"::\"));\n                         self.record_def(expr.id, def);\n                     }\n-                    none => {\n+                    None => {\n                         let wrong_name =\n                             connect(path.idents.map(\n                                 |x| self.session.str_of(x)), ~\"::\") ;\n@@ -4163,7 +4163,7 @@ struct Resolver {\n             expr_fn(_, fn_decl, block, capture_clause) |\n             expr_fn_block(fn_decl, block, capture_clause) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n-                                      some(@fn_decl),\n+                                      Some(@fn_decl),\n                                       NoTypeParameters,\n                                       block,\n                                       NoSelfBinding,\n@@ -4188,13 +4188,13 @@ struct Resolver {\n                 //    let bar = Bar { ... } // no type parameters\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n-                    some(def_ty(class_id)) | some(def_class(class_id, _))\n+                    Some(def_ty(class_id)) | Some(def_class(class_id, _))\n                             if self.structs.contains_key(class_id) => {\n                         let has_constructor = self.structs.get(class_id);\n                         let class_def = def_class(class_id, has_constructor);\n                         self.record_def(expr.id, class_def);\n                     }\n-                    some(definition @ def_variant(_, class_id))\n+                    Some(definition @ def_variant(_, class_id))\n                             if self.structs.contains_key(class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n@@ -4211,7 +4211,7 @@ struct Resolver {\n                 visit_expr(expr, (), visitor);\n             }\n \n-            expr_loop(_, some(label)) => {\n+            expr_loop(_, Some(label)) => {\n                 do self.with_label_rib {\n                     let def_like = dl_def(def_label(expr.id));\n                     self.label_ribs.last().bindings.insert(label, def_like);\n@@ -4220,17 +4220,17 @@ struct Resolver {\n                 }\n             }\n \n-            expr_break(some(label)) | expr_again(some(label)) => {\n+            expr_break(Some(label)) | expr_again(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n-                    none =>\n+                    None =>\n                         self.session.span_err(expr.span,\n                                               fmt!(\"use of undeclared label \\\n                                                    `%s`\", self.session.str_of(\n                                                   label))),\n-                    some(dl_def(def @ def_label(id))) =>\n+                    Some(dl_def(def @ def_label(id))) =>\n                         self.record_def(expr.id, def),\n-                    some(_) =>\n+                    Some(_) =>\n                         self.session.span_bug(expr.span,\n                                               ~\"label wasn't mapped to a \\\n                                                 label def!\")\n@@ -4309,21 +4309,21 @@ struct Resolver {\n         loop {\n             // Look for the current trait.\n             match copy self.current_trait_refs {\n-                some(trait_def_ids) => {\n+                Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method\n                             (found_traits, trait_def_id, name);\n                     }\n                 }\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n             }\n \n             // Look for trait children.\n             for search_module.children.each |_name, child_name_bindings| {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n-                    some(def) => {\n+                    Some(def) => {\n                         match def.def {\n                             def_ty(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method\n@@ -4334,7 +4334,7 @@ struct Resolver {\n                             }\n                         }\n                     }\n-                    none => {\n+                    None => {\n                         // Continue.\n                     }\n                 }\n@@ -4345,12 +4345,12 @@ struct Resolver {\n                     |_atom, import_resolution| {\n \n                 match import_resolution.target_for_namespace(TypeNS) {\n-                    none => {\n+                    None => {\n                         // Continue.\n                     }\n-                    some(target) => {\n+                    Some(target) => {\n                         match target.bindings.def_for_namespace(TypeNS) {\n-                            some(def) => {\n+                            Some(def) => {\n                                 match def.def {\n                                     def_ty(trait_def_id) => {\n                                         self.\n@@ -4362,7 +4362,7 @@ struct Resolver {\n                                     }\n                                 }\n                             }\n-                            none => {\n+                            None => {\n                                 // Continue.\n                             }\n                         }\n@@ -4391,21 +4391,21 @@ struct Resolver {\n                                            name: Atom) {\n \n         match self.trait_info.find(trait_def_id) {\n-            some(trait_info) if trait_info.contains_key(name) => {\n+            Some(trait_info) if trait_info.contains_key(name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n                        self.session.str_of(name));\n                 (*found_traits).push(trait_def_id);\n             }\n-            some(_) | none => {\n+            Some(_) | None => {\n                 // Continue.\n             }\n         }\n     }\n \n-    fn add_fixed_trait_for_expr(expr_id: node_id, +trait_id: option<def_id>) {\n+    fn add_fixed_trait_for_expr(expr_id: node_id, +trait_id: Option<def_id>) {\n         let traits = @dvec();\n         traits.push(trait_id.get());\n         self.trait_map.insert(expr_id, traits);\n@@ -4437,13 +4437,13 @@ struct Resolver {\n         // for unused imports in external crates.\n \n         match module_.def_id {\n-            some(def_id) if def_id.crate == local_crate => {\n+            Some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n             }\n-            none => {\n+            None => {\n                 // Check for unused imports in the root module.\n             }\n-            some(_) => {\n+            Some(_) => {\n                 // Bail out.\n                 debug!(\"(checking for unused imports in module subtree) not \\\n                         checking for unused imports for `%s`\",\n@@ -4456,10 +4456,10 @@ struct Resolver {\n \n         for module_.children.each |_atom, child_name_bindings| {\n             match (*child_name_bindings).get_module_if_available() {\n-                none => {\n+                None => {\n                     // Nothing to do.\n                 }\n-                some(child_module) => {\n+                Some(child_module) => {\n                     self.check_for_unused_imports_in_module_subtree\n                         (child_module);\n                 }\n@@ -4554,26 +4554,26 @@ struct Resolver {\n         for module_.import_resolutions.each |name, import_resolution| {\n             let mut module_repr;\n             match (*import_resolution).target_for_namespace(ModuleNS) {\n-                none => { module_repr = ~\"\"; }\n-                some(target) => {\n+                None => { module_repr = ~\"\"; }\n+                Some(target) => {\n                     module_repr = ~\" module:?\";\n                     // XXX\n                 }\n             }\n \n             let mut value_repr;\n             match (*import_resolution).target_for_namespace(ValueNS) {\n-                none => { value_repr = ~\"\"; }\n-                some(target) => {\n+                None => { value_repr = ~\"\"; }\n+                Some(target) => {\n                     value_repr = ~\" value:?\";\n                     // XXX\n                 }\n             }\n \n             let mut type_repr;\n             match (*import_resolution).target_for_namespace(TypeNS) {\n-                none => { type_repr = ~\"\"; }\n-                some(target) => {\n+                None => { type_repr = ~\"\"; }\n+                Some(target) => {\n                     type_repr = ~\" type:?\";\n                     // XXX\n                 }"}, {"sha": "e2d8f706599aa4b660ad5798827d544484f0abef", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -52,7 +52,7 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n                            ast::vstore_uniq) => {\n             let strty = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n             let cell = empty_dest_cell();\n-            bcx = tvec::trans_estr(bcx, s, some(ast::vstore_uniq),\n+            bcx = tvec::trans_estr(bcx, s, Some(ast::vstore_uniq),\n                                    by_val(cell));\n             add_clean_temp_immediate(bcx, *cell, strty);\n             return single_result(rslt(bcx, *cell));\n@@ -93,27 +93,27 @@ type bind_map = ~[{\n     binding: binding\n }];\n \n-fn assoc(key: ast::ident, list: bind_map) -> option<binding> {\n+fn assoc(key: ast::ident, list: bind_map) -> Option<binding> {\n     for vec::each(list) |elt| {\n         if elt.ident == key {\n-            return some(elt.binding);\n+            return Some(elt.binding);\n         }\n     }\n-    return none;\n+    return None;\n }\n \n type match_branch =\n     @{pats: ~[@ast::pat],\n       bound: bind_map,\n       data: @{bodycx: block,\n-              guard: option<@ast::expr>,\n+              guard: Option<@ast::expr>,\n               id_map: pat_id_map}};\n type match_ = ~[match_branch];\n \n fn has_nested_bindings(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n-          ast::pat_ident(_, _, some(_)) => return true,\n+          ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n         }\n     }\n@@ -126,7 +126,7 @@ fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n     let mut result = ~[];\n     for vec::each(m) |br| {\n       match br.pats[col].node {\n-          ast::pat_ident(mode, name, some(inner)) => {\n+          ast::pat_ident(mode, name, Some(inner)) => {\n             let pats = vec::append(\n                 vec::slice(br.pats, 0u, col),\n                 vec::append(~[inner],\n@@ -149,20 +149,20 @@ fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n     result\n }\n \n-type enter_pat = fn(@ast::pat) -> option<~[@ast::pat]>;\n+type enter_pat = fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n                e: enter_pat) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n         match e(br.pats[col]) {\n-          some(sub) => {\n+          Some(sub) => {\n             let pats = vec::append(\n                 vec::append(sub, vec::view(br.pats, 0u, col)),\n                 vec::view(br.pats, col + 1u, br.pats.len()));\n             let self = br.pats[col];\n             let bound = match self.node {\n-              ast::pat_ident(mode, name, none)\n+              ast::pat_ident(mode, name, None)\n                   if !pat_is_variant(dm, self) => {\n                 vec::append(br.bound,\n                             ~[{ident: path_to_ident(name),\n@@ -176,7 +176,7 @@ fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n             };\n             vec::push(result, @{pats: pats, bound: bound with *br});\n           }\n-          none => ()\n+          None => ()\n         }\n     }\n     return result;\n@@ -188,9 +188,9 @@ fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) |\n-          ast::pat_struct(*) => some(~[]),\n-          ast::pat_ident(_, _, none) if !pat_is_variant(dm, p) => some(~[]),\n-          _ => none\n+          ast::pat_struct(*) => Some(~[]),\n+          ast::pat_ident(_, _, None) if !pat_is_variant(dm, p) => Some(~[]),\n+          _ => None\n         }\n     }\n }\n@@ -203,21 +203,21 @@ fn enter_opt(bcx: block, m: match_, opt: opt, col: uint,\n         match p.node {\n           ast::pat_enum(_, subpats) => {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n-              some(option::get_default(subpats,\n+              Some(option::get_default(subpats,\n                      vec::from_elem(variant_size, dummy))) }\n-            else { none }\n+            else { None }\n           }\n-          ast::pat_ident(_, _, none) if pat_is_variant(tcx.def_map, p) => {\n-            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some(~[]) }\n-            else { none }\n+          ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n+            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { Some(~[]) }\n+            else { None }\n           }\n           ast::pat_lit(l) => {\n-            if opt_eq(tcx, lit(l), opt) { some(~[]) } else { none }\n+            if opt_eq(tcx, lit(l), opt) { Some(~[]) } else { None }\n           }\n           ast::pat_range(l1, l2) => {\n-            if opt_eq(tcx, range(l1, l2), opt) { some(~[]) } else { none }\n+            if opt_eq(tcx, range(l1, l2), opt) { Some(~[]) } else { None }\n           }\n-          _ => some(vec::from_elem(variant_size, dummy))\n+          _ => Some(vec::from_elem(variant_size, dummy))\n         }\n     }\n }\n@@ -236,9 +236,9 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: match_, col: uint,\n                 }\n                 vec::push(pats, pat);\n             }\n-            some(pats)\n+            Some(pats)\n           }\n-          _ => some(vec::from_elem(fields.len(), dummy))\n+          _ => Some(vec::from_elem(fields.len(), dummy))\n         }\n     }\n }\n@@ -248,8 +248,8 @@ fn enter_tup(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_tup(elts) => some(elts),\n-          _ => some(vec::from_elem(n_elts, dummy))\n+          ast::pat_tup(elts) => Some(elts),\n+          _ => Some(vec::from_elem(n_elts, dummy))\n         }\n     }\n }\n@@ -259,8 +259,8 @@ fn enter_box(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_box(sub) => some(~[sub]),\n-          _ => some(~[dummy])\n+          ast::pat_box(sub) => Some(~[sub]),\n+          _ => Some(~[dummy])\n         }\n     }\n }\n@@ -270,8 +270,8 @@ fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_uniq(sub) => some(~[sub]),\n-          _ => some(~[dummy])\n+          ast::pat_uniq(sub) => Some(~[sub]),\n+          _ => Some(~[dummy])\n         }\n     }\n }\n@@ -367,8 +367,8 @@ fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n         let pat_id = br.pats[col].id;\n \n         match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n-          none => (),\n-          some(scope_id) => {\n+          None => (),\n+          Some(scope_id) => {\n             // Note: the scope_id will always be the id of the alt.  See the\n             // extended comment in rustc::middle::borrowck::preserve() for\n             // details (look for the case covering cat_discr).\n@@ -419,7 +419,7 @@ fn pick_col(m: match_) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n-          ast::pat_ident(_, _, some(p)) => score(p),\n+          ast::pat_ident(_, _, Some(p)) => score(p),\n           _ => 0u\n         }\n     }\n@@ -444,7 +444,7 @@ fn pick_col(m: match_) -> uint {\n }\n \n fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n-                    chk: option<mk_fail>, &exits: ~[exit_node]) {\n+                    chk: Option<mk_fail>, &exits: ~[exit_node]) {\n     /*\n       For an empty match, a fall-through case must exist\n      */\n@@ -456,7 +456,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         match data.guard {\n-          some(e) => {\n+          Some(e) => {\n             // Temporarily set bindings. They'll be rewritten to PHI nodes\n             // for the actual arm block.\n             //\n@@ -679,7 +679,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n               compare => {\n                 let t = node_id_type(bcx, pat_id);\n                 let {bcx: after_cx, val: matches} = {\n-                    do with_scope_result(bcx, none, ~\"compare_scope\") |bcx| {\n+                    do with_scope_result(bcx, None, ~\"compare_scope\") |bcx| {\n                         match trans_opt(bcx, opt) {\n                           single_result({bcx, val}) => {\n                             trans_compare(bcx, ast::eq, test_val, t, val, t)\n@@ -738,32 +738,32 @@ type phi_bindings_list = ~[phi_binding];\n fn make_phi_bindings(bcx: block,\n                      map: ~[exit_node],\n                      ids: pat_util::pat_id_map)\n-    -> option<phi_bindings_list> {\n+    -> Option<phi_bindings_list> {\n     let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut phi_bindings = ~[];\n     for ids.each |name, node_id| {\n         let mut llbbs = ~[];\n         let mut vals = ~[];\n-        let mut binding = none;\n+        let mut binding = None;\n         for vec::each(map) |ex| {\n             if ex.to as uint == our_block {\n                 match assoc(name, ex.bound) {\n-                  some(b) => {\n+                  Some(b) => {\n                     vec::push(llbbs, ex.from);\n                     vec::push(vals, b.val);\n-                    binding = some(b);\n+                    binding = Some(b);\n                   }\n-                  none => ()\n+                  None => ()\n                 }\n             }\n         }\n \n         let binding = match binding {\n-          some(binding) => binding,\n-          none => {\n+          Some(binding) => binding,\n+          None => {\n             Unreachable(bcx);\n-            return none;\n+            return None;\n           }\n         };\n \n@@ -775,7 +775,7 @@ fn make_phi_bindings(bcx: block,\n             ty: binding.ty\n         });\n     }\n-    return some(move phi_bindings);\n+    return Some(move phi_bindings);\n }\n \n // Copies by-value bindings into their homes.\n@@ -851,22 +851,22 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     }\n \n     fn mk_fail(bcx: block, sp: span, msg: ~str,\n-                   done: @mut option<BasicBlockRef>) -> BasicBlockRef {\n-            match *done { some(bb) => return bb, _ => () }\n+                   done: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n+            match *done { Some(bb) => return bb, _ => () }\n             let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n-            trans_fail(fail_cx, some(sp), msg);\n-            *done = some(fail_cx.llbb);\n+            trans_fail(fail_cx, Some(sp), msg);\n+            *done = Some(fail_cx.llbb);\n             return fail_cx.llbb;\n     }\n     let t = node_id_type(bcx, expr.id);\n-    let mk_fail = { let fail_cx = @mut none;\n+    let mk_fail = { let fail_cx = @mut None;\n           // special case for uninhabited type\n           if ty::type_is_empty(tcx, t) {\n-                  some(|| mk_fail(scope_cx, expr.span,\n+                  Some(|| mk_fail(scope_cx, expr.span,\n                             ~\"scrutinizing value that can't exist\", fail_cx))\n           }\n           else {\n-              none\n+              None\n           }\n     };\n     let mut exit_map = ~[];\n@@ -878,8 +878,8 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         match make_phi_bindings(body_cx, exit_map, id_map) {\n-            none => {}\n-            some(phi_bindings) => {\n+            None => {}\n+            Some(phi_bindings) => {\n                 let body_cx = make_pattern_bindings(body_cx, phi_bindings);\n                 let arm_dest = dup_for_join(dest);\n                 vec::push(arm_dests, arm_dest);\n@@ -915,7 +915,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n         match inner {\n-          some(pat) => { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n+          Some(pat) => { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n           _ => ()\n         }\n       }"}, {"sha": "22d28c90fab9e2896625837df83efc8178d9f7ab", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 269, "deletions": 269, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -123,15 +123,15 @@ impl fn_ctxt: get_insn_ctxt {\n fn join_returns(parent_cx: block, in_cxs: ~[block],\n                 in_ds: ~[dest], out_dest: dest) -> block {\n     let out = sub_block(parent_cx, ~\"join\");\n-    let mut reachable = false, i = 0u, phi = none;\n+    let mut reachable = false, i = 0u, phi = None;\n     for vec::each(in_cxs) |cx| {\n         if !cx.unreachable {\n             Br(cx, out.llbb);\n             reachable = true;\n             match in_ds[i] {\n               by_val(cell) => {\n                 if option::is_none(phi) {\n-                    phi = some(EmptyPhi(out, val_ty(*cell)));\n+                    phi = Some(EmptyPhi(out, val_ty(*cell)));\n                 }\n                 AddIncomingToPhi(option::get(phi), *cell, cx.llbb);\n               }\n@@ -448,7 +448,7 @@ fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n \n fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     match ccx.tydescs.find(t) {\n-      some(inf) => inf,\n+      Some(inf) => inf,\n       _ => {\n         ccx.stats.n_static_tydescs += 1u;\n         let inf = declare_tydesc(ccx, t);\n@@ -557,10 +557,10 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n           size: llsize,\n           align: llalign,\n           addrspace: addrspace,\n-          mut take_glue: none,\n-          mut drop_glue: none,\n-          mut free_glue: none,\n-          mut visit_glue: none};\n+          mut take_glue: None,\n+          mut drop_glue: None,\n+          mut free_glue: None,\n+          mut visit_glue: None};\n     log(debug, ~\"--- declare_tydesc \" + ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n@@ -587,7 +587,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, none);\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n     // All glue functions take values passed *by alias*; this is a\n@@ -598,7 +598,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = top_scope_block(fcx, none);\n+    let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n     helper(bcx, llrawptr0, t);\n@@ -634,32 +634,32 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         // calling it.\n         let take_glue =\n             match copy ti.take_glue {\n-              none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n                 ccx.stats.n_real_glues += 1u;\n                 llvm::LLVMConstPointerCast(v, glue_fn_ty)\n               }\n             };\n         let drop_glue =\n             match copy ti.drop_glue {\n-              none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n                 ccx.stats.n_real_glues += 1u;\n                 llvm::LLVMConstPointerCast(v, glue_fn_ty)\n               }\n             };\n         let free_glue =\n             match copy ti.free_glue {\n-              none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n                 ccx.stats.n_real_glues += 1u;\n                 llvm::LLVMConstPointerCast(v, glue_fn_ty)\n               }\n             };\n         let visit_glue =\n             match copy ti.visit_glue {\n-              none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => {\n+              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              Some(v) => {\n                 ccx.stats.n_real_glues += 1u;\n                 llvm::LLVMConstPointerCast(v, glue_fn_ty)\n               }\n@@ -784,7 +784,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         // Generate code that, dynamically, indexes into the\n         // tydesc and calls the drop glue that got set dynamically\n         call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n-                              none);\n+                              None);\n         trans_free(bcx, v)\n       }\n       ty::ty_uniq(*) => {\n@@ -865,10 +865,10 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_class(did, ref substs) => {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n-          some(dtor) => {\n+          Some(dtor) => {\n             trans_class_drop(bcx, v0, dtor, did, substs)\n           }\n-          none => {\n+          None => {\n             // No dtor? Just the default case\n             iter_structural_ty(bcx, v0, t, drop_ty)\n           }\n@@ -903,7 +903,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n             maybe_instantiate_inline(ccx, did)\n         } else { did };\n         assert did.crate == ast::local_crate;\n-        monomorphic_fn(ccx, did, substs, none, none).val\n+        monomorphic_fn(ccx, did, substs, None, None).val\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n@@ -965,7 +965,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n       ty::ty_uint(_) => return rslt(cx, f(unsigned_int)),\n       ty::ty_float(_) => return rslt(cx, f(floating_point)),\n       ty::ty_type => {\n-        return rslt(trans_fail(cx, none,\n+        return rslt(trans_fail(cx, None,\n                             ~\"attempt to compare values of type type\"),\n                  C_nil());\n       }\n@@ -1170,51 +1170,51 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue {\n-          some(_) => (),\n-          none => {\n+          Some(_) => (),\n+          None => {\n             debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n-            ti.take_glue = some(glue_fn);\n+            ti.take_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, ~\"take\");\n             debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         match ti.drop_glue {\n-          some(_) => (),\n-          none => {\n+          Some(_) => (),\n+          None => {\n             debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n-            ti.drop_glue = some(glue_fn);\n+            ti.drop_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, ~\"drop\");\n             debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         match ti.free_glue {\n-          some(_) => (),\n-          none => {\n+          Some(_) => (),\n+          None => {\n             debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n-            ti.free_glue = some(glue_fn);\n+            ti.free_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, ~\"free\");\n             debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue {\n-          some(_) => (),\n-          none => {\n+          Some(_) => (),\n+          None => {\n             debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n-            ti.visit_glue = some(glue_fn);\n+            ti.visit_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, ~\"visit\");\n             debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n@@ -1225,14 +1225,14 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n \n // See [Note-arg-mode]\n fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n-                         field: uint, static_ti: option<@tydesc_info>) {\n+                         field: uint, static_ti: Option<@tydesc_info>) {\n     let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n         if bcx.unreachable { return; }\n     let ccx = bcx.ccx();\n \n     let static_glue_fn = match static_ti {\n-      none => none,\n-      some(sti) => {\n+      None => None,\n+      Some(sti) => {\n         lazily_emit_tydesc_glue(ccx, field, sti);\n         if field == abi::tydesc_field_take_glue {\n             sti.take_glue\n@@ -1243,18 +1243,18 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n         } else if field == abi::tydesc_field_visit_glue {\n             sti.visit_glue\n         } else {\n-            none\n+            None\n         }\n       }\n     };\n \n     // When available, use static type info to give glue the right type.\n     let static_glue_fn = match static_ti {\n-      none => none,\n-      some(sti) => {\n+      None => None,\n+      Some(sti) => {\n         match static_glue_fn {\n-          none => none,\n-          some(sgf) => some(\n+          None => None,\n+          Some(sgf) => Some(\n               PointerCast(bcx, sgf, T_ptr(type_of_glue_fn(ccx, sti.ty))))\n         }\n       }\n@@ -1270,12 +1270,12 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n \n     let llfn = {\n         match static_glue_fn {\n-          none => {\n+          None => {\n             // Select out the glue function to call from the tydesc\n             let llfnptr = GEPi(bcx, tydesc, ~[0u, field]);\n             Load(bcx, llfnptr)\n           }\n-          some(sgf) => sgf\n+          Some(sgf) => sgf\n         }\n     };\n \n@@ -1288,7 +1288,7 @@ fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n-    call_tydesc_glue_full(cx, v, ti.tydesc, field, some(ti));\n+    call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n@@ -1548,7 +1548,7 @@ fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { return cx; }\n     match lit.node {\n-        ast::lit_str(s) => tvec::trans_estr(cx, s, none, dest),\n+        ast::lit_str(s) => tvec::trans_estr(cx, s, None, dest),\n         _ => store_in_dest(cx, consts::const_lit(cx.ccx(), e, lit), dest)\n     }\n }\n@@ -1569,7 +1569,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_unary\");\n     // Check for user-defined method call\n     match bcx.ccx().maps.method_map.find(un_expr.id) {\n-      some(mentry) => {\n+      Some(mentry) => {\n         let fty = node_id_type(bcx, un_expr.callee_id);\n         return trans_call_inner(\n             bcx, un_expr.info(), fty,\n@@ -1708,7 +1708,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n       }\n     };\n     do with_cond(cx, is_zero) |bcx| {\n-        trans_fail(bcx, some(span), text)\n+        trans_fail(bcx, Some(span), text)\n     }\n }\n \n@@ -1796,7 +1796,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n \n     // A user-defined operator method\n     match bcx.ccx().maps.method_map.find(ex.id) {\n-      some(origin) => {\n+      Some(origin) => {\n         let bcx = lhs_res.bcx;\n         debug!(\"user-defined method callee_id: %s\",\n                ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id,\n@@ -1835,7 +1835,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n \n     if bcx.sess().trace() {\n         trans_trace(\n-            bcx, none,\n+            bcx, None,\n             fmt!(\"preserving until end of scope %d\", scope_id));\n     }\n \n@@ -1862,8 +1862,8 @@ fn autoderef(cx: block, e_id: ast::node_id,\n         // root the autoderef'd value, if necessary:\n         derefs += 1u;\n         match ccx.maps.root_map.find({id:e_id, derefs:derefs}) {\n-          none => (),\n-          some(scope_id) => {\n+          None => (),\n+          Some(scope_id) => {\n             root_value(cx, v1, t1, scope_id);\n           }\n         }\n@@ -1945,7 +1945,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_binary\");\n     // User-defined operators\n     match bcx.ccx().maps.method_map.find(ex.id) {\n-      some(origin) => {\n+      Some(origin) => {\n         let fty = node_id_type(bcx, ex.callee_id);\n         return trans_call_inner(\n             bcx, ex.info(), fty,\n@@ -1979,7 +1979,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n }\n \n fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n-            els: option<@ast::expr>, dest: dest)\n+            els: Option<@ast::expr>, dest: dest)\n     -> block {\n     let _icx = cx.insn_ctxt(\"trans_if\");\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n@@ -1996,7 +1996,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n     // context for the block, but we've already got the\n     // 'else' context\n     let else_bcx = match els {\n-      some(elexpr) => {\n+      Some(elexpr) => {\n         match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n@@ -2054,7 +2054,7 @@ type lval_result = {bcx: block, val: ValueRef, kind: lval_kind};\n enum callee_env {\n     null_env,\n     is_closure,\n-    self_env(ValueRef, ty::t, option<ValueRef>, ast::rmode),\n+    self_env(ValueRef, ty::t, Option<ValueRef>, ast::rmode),\n }\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n@@ -2097,38 +2097,38 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     };\n }\n \n-fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n+fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n     match ty::get(ty).struct {\n       ty::ty_box(*) => {\n-        some(ty::mk_opaque_box(tcx))\n+        Some(ty::mk_opaque_box(tcx))\n       }\n       ty::ty_fn(ref fty) => {\n-        some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                              proto: fty.proto,\n                              bounds: @~[],\n                              inputs: ~[],\n                              output: ty::mk_nil(tcx),\n                              ret_style: ast::return_val}))\n       }\n       ty::ty_trait(_, _, _) => {\n-        some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+        Some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                              proto: ty::proto_vstore(ty::vstore_box),\n                              bounds: @~[],\n                              inputs: ~[],\n                              output: ty::mk_nil(tcx),\n                              ret_style: ast::return_val}))\n       }\n-      ty::ty_ptr(_) => some(ty::mk_uint(tcx)),\n-      _ => none\n+      ty::ty_ptr(_) => Some(ty::mk_uint(tcx)),\n+      _ => None\n     }\n }\n \n fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n-                vtables: option<typeck::vtable_res>,\n-                param_uses: option<~[type_use::type_uses]>) -> mono_id {\n+                vtables: Option<typeck::vtable_res>,\n+                param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n-      some(vts) => {\n+      Some(vts) => {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n         let mut i = 0u;\n         vec::map2(*bounds, substs, |bounds, subst| {\n@@ -2142,19 +2142,19 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                   _ => ()\n                 }\n             }\n-            (subst, if v.len() > 0u { some(v) } else { none })\n+            (subst, if v.len() > 0u { Some(v) } else { None })\n         })\n       }\n-      none => {\n-        vec::map(substs, |subst| (subst, none))\n+      None => {\n+        vec::map(substs, |subst| (subst, None))\n       }\n     };\n     let param_ids = match param_uses {\n-      some(uses) => {\n+      Some(uses) => {\n         vec::map2(precise_param_ids, uses, |id, uses| {\n             match id {\n-                (a, b@some(_)) => mono_precise(a, b),\n-              (subst, none) => {\n+                (a, b@Some(_)) => mono_precise(a, b),\n+              (subst, None) => {\n                 if uses == 0u { mono_any }\n                 else if uses == type_use::use_repr &&\n                         !ty::type_needs_drop(ccx.tcx, subst) {\n@@ -2166,35 +2166,35 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                     if size == 1u && ty::type_is_nil(subst) {\n                         mono_repr(0u, 0u)\n                     } else { mono_repr(size, align) }\n-                } else { mono_precise(subst, none) }\n+                } else { mono_precise(subst, None) }\n               }\n             }\n         })\n       }\n-      none => precise_param_ids.map(|x| { let (a, b) = x;\n+      None => precise_param_ids.map(|x| { let (a, b) = x;\n                 mono_precise(a, b) })\n     };\n     @{def: item, params: param_ids}\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n                   real_substs: ~[ty::t],\n-                  vtables: option<typeck::vtable_res>,\n-                  ref_id: option<ast::node_id>)\n+                  vtables: Option<typeck::vtable_res>,\n+                  ref_id: Option<ast::node_id>)\n     -> {val: ValueRef, must_cast: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n         match normalize_for_monomorphization(ccx.tcx, t) {\n-          some(t) => { must_cast = true; t }\n-          none => t\n+          Some(t) => { must_cast = true; t }\n+          None => t\n         }\n     });\n \n     for real_substs.each() |s| { assert !ty::type_has_params(s); }\n     for substs.each() |s| { assert !ty::type_has_params(s); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n-    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n+    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, Some(param_uses));\n     if vec::any(hash_id.params,\n                 |p| match p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n@@ -2207,12 +2207,12 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n            substs.map(|s| ty_to_str(ccx.tcx, s)), hash_id];\n \n     match ccx.monomorphized.find(hash_id) {\n-      some(val) => {\n+      Some(val) => {\n         debug!(\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id));\n         return {val: val, must_cast: must_cast};\n       }\n-      none => ()\n+      None => ()\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n@@ -2280,7 +2280,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n         lldecl\n     };\n \n-    let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n+    let psubsts = Some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n     let lldecl = match map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, body), _}, _) => {\n         let d = mk_lldecl();\n@@ -2328,19 +2328,19 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n         let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n         trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n                option::get_default(psubsts,\n-                        {tys:tp_tys, vtables: none, bounds: @~[]}),\n+                        {tys:tp_tys, vtables: None, bounds: @~[]}),\n                          fn_id.node, parent_id, ctor.span);\n         d\n       }\n       ast_map::node_dtor(_, dtor, _, pt) => {\n         let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n                                               dtor.node.self_id)) {\n-                some(did) => did,\n-                none      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n+                Some(did) => did,\n+                None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n                                                             dtor\")\n         };\n         trans_class_dtor(ccx, *pt, dtor.node.body,\n-          dtor.node.id, psubsts, some(hash_id), parent_id)\n+          dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n       // Ugh -- but this ensures any new variants won't be forgotten\n       ast_map::node_expr(*) |\n@@ -2363,47 +2363,47 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(fn_id) {\n-      some(some(node_id)) => {\n+      Some(Some(node_id)) => {\n         // Already inline\n         debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n                ty::item_path_str(ccx.tcx, fn_id), node_id);\n         local_def(node_id)\n       }\n-      some(none) => fn_id, // Not inlinable\n-      none => { // Not seen yet\n+      Some(None) => fn_id, // Not inlinable\n+      None => { // Not seen yet\n         match csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             |a,b,c,d| {\n                 astencode::decode_inlined_item(a, b, ccx.maps, c, d)\n             }) {\n \n           csearch::not_found => {\n-            ccx.external.insert(fn_id, none);\n+            ccx.external.insert(fn_id, None);\n             fn_id\n           }\n           csearch::found(ast::ii_item(item)) => {\n-            ccx.external.insert(fn_id, some(item.id));\n+            ccx.external.insert(fn_id, Some(item.id));\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n           csearch::found(ast::ii_ctor(ctor, _, tps, _)) => {\n-            ccx.external.insert(fn_id, some(ctor.node.id));\n+            ccx.external.insert(fn_id, Some(ctor.node.id));\n             local_def(ctor.node.id)\n           }\n           csearch::found(ast::ii_foreign(item)) => {\n-            ccx.external.insert(fn_id, some(item.id));\n+            ccx.external.insert(fn_id, Some(item.id));\n             local_def(item.id)\n           }\n           csearch::found_parent(parent_id, ast::ii_item(item)) => {\n-            ccx.external.insert(parent_id, some(item.id));\n+            ccx.external.insert(parent_id, Some(item.id));\n             let mut my_id = 0;\n             match item.node {\n               ast::item_enum(_, _) => {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n                 do vec::iter2(*vs_here, *vs_there) |here, there| {\n                     if there.id == fn_id { my_id = here.id.node; }\n-                    ccx.external.insert(there.id, some(here.id.node));\n+                    ccx.external.insert(there.id, Some(here.id.node));\n                 }\n               }\n               _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n@@ -2417,7 +2417,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                with a non-item parent\");\n           }\n           csearch::found(ast::ii_method(impl_did, mth)) => {\n-            ccx.external.insert(fn_id, some(mth.id));\n+            ccx.external.insert(fn_id, Some(mth.id));\n             let {bounds: impl_bnds, region_param: _, ty: impl_ty} =\n                 ty::lookup_item_type(ccx.tcx, impl_did);\n             if (*impl_bnds).len() + mth.tps.len() == 0u {\n@@ -2426,12 +2426,12 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                     ty::item_path(ccx.tcx, impl_did),\n                     ~[path_name(mth.ident)]);\n                 trans_fn(ccx, path, mth.decl, mth.body,\n-                         llfn, impl_self(impl_ty), none, mth.id);\n+                         llfn, impl_self(impl_ty), None, mth.id);\n             }\n             local_def(mth.id)\n           }\n           csearch::found(ast::ii_dtor(dtor, _, tps, _)) => {\n-              ccx.external.insert(fn_id, some(dtor.node.id));\n+              ccx.external.insert(fn_id, Some(dtor.node.id));\n               local_def(dtor.node.id)\n           }\n         }\n@@ -2449,7 +2449,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n }\n \n fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n-                        tys: ~[ty::t], vtables: option<typeck::vtable_res>)\n+                        tys: ~[ty::t], vtables: Option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"lval_static_fn_inner\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -2463,7 +2463,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n     if fn_id.crate == ast::local_crate && tys.len() > 0u {\n         let mut {val, must_cast} =\n-            monomorphic_fn(ccx, fn_id, tys, vtables, some(id));\n+            monomorphic_fn(ccx, fn_id, tys, vtables, Some(id));\n         if must_cast {\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n                 ccx, node_id_type(bcx, id))));\n@@ -2503,7 +2503,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n     match ccx.discrims.find(vid) {\n-      none => {\n+      None => {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n@@ -2515,7 +2515,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n         ccx.discrims.insert(vid, gvar);\n         return gvar;\n       }\n-      some(llval) => return llval,\n+      Some(llval) => return llval,\n     }\n }\n \n@@ -2530,9 +2530,9 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         match table.find(id) {\n-          some(local_mem(v)) => {val: v, kind: lv_owned},\n-          some(local_imm(v)) => {val: v, kind: lv_owned_imm},\n-          none => fail(fmt!(\"take_local: internal error, \\\n+          Some(local_mem(v)) => {val: v, kind: lv_owned},\n+          Some(local_imm(v)) => {val: v, kind: lv_owned_imm},\n+          None => fail(fmt!(\"take_local: internal error, \\\n                              found no entry for %?\", id))\n         }\n     }\n@@ -2551,8 +2551,8 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n       }\n       ast::def_self(_) => {\n         let slf = match copy cx.fcx.llself {\n-          some(s) => cast_self(cx, s),\n-          none => cx.sess().bug(~\"trans_local_var: reference to self \\\n+          Some(s) => cast_self(cx, s),\n+          None => cx.sess().bug(~\"trans_local_var: reference to self \\\n                                  out of context\")\n         };\n         return {val: slf, kind: lv_owned};\n@@ -2568,8 +2568,8 @@ fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n     let _icx = cx.insn_ctxt(\"trans_path\");\n     match cx.tcx().def_map.find(id) {\n-      none => cx.sess().bug(~\"trans_path: unbound node ID\"),\n-      some(df) => {\n+      None => cx.sess().bug(~\"trans_path: unbound node ID\"),\n+      Some(df) => {\n           return trans_var(cx, df, id);\n       }\n     }\n@@ -2705,7 +2705,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n     let bcx = do with_cond(bcx, bounds_check) |bcx| {\n         // fail: bad bounds check.\n-        trans_fail(bcx, some(ex.span), ~\"bounds check\")\n+        trans_fail(bcx, Some(ex.span), ~\"bounds check\")\n     };\n     let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n     return lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n@@ -2728,7 +2728,7 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n             match bcx.ccx().maps.method_map.find(e.id) {\n-              some(origin) => { // An impl method\n+              Some(origin) => { // An impl method\n                 return impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n               _ => {\n@@ -2750,11 +2750,11 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n     return match cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       // No need to root this lvalue.\n-      none => unrooted(cx, e),\n+      None => unrooted(cx, e),\n \n       // Lvalue must remain rooted until exit of `scope_id`.  See\n       // add_root_cleanup() for comments on why this works the way it does.\n-      some(scope_id) => {\n+      Some(scope_id) => {\n         let lv = unrooted(cx, e);\n \n         if !cx.sess().no_asm_comments() {\n@@ -2954,16 +2954,16 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n fn trans_loop_body(bcx: block, id: ast::node_id,\n                    decl: ast::fn_decl, body: ast::blk,\n                    proto: ty::fn_proto, cap: ast::capture_clause,\n-                   ret_flag: option<ValueRef>,\n+                   ret_flag: Option<ValueRef>,\n                    dest: dest) -> block {\n     closure::trans_expr_fn(bcx, proto, decl, body, id,\n-                           cap, some(ret_flag), dest)\n+                           cap, Some(ret_flag), dest)\n }\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n-                  &temp_cleanups: ~[ValueRef], ret_flag: option<ValueRef>,\n+                  &temp_cleanups: ~[ValueRef], ret_flag: Option<ValueRef>,\n                   derefs: uint)\n     -> result {\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n@@ -2975,7 +2975,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     // translate the arg expr as an lvalue\n     let lv = match ret_flag {\n       // If there is a ret_flag, this *must* be a loop body\n-      some(_) => match e.node {\n+      Some(_) => match e.node {\n           ast::expr_loop_body(blk@@{node:\n                   ast::expr_fn_block(decl, body, cap),_}) => {\n             let scratch = alloc_ty(cx, expr_ty(cx, blk));\n@@ -2991,7 +2991,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         _ => cx.sess().impossible_case(e.span, ~\"ret_flag with non-loop-\\\n               body expr\")\n       },\n-      none => {\n+      None => {\n         trans_temp_lval(cx, e)\n       }\n     };\n@@ -3154,7 +3154,7 @@ enum call_args {\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n-              dest: dest, ret_flag: option<ValueRef>)\n+              dest: dest, ret_flag: Option<ValueRef>)\n     -> {bcx: block, args: ~[ValueRef], retslot: ValueRef} {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -3193,7 +3193,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n         do vec::iteri(es) |i, e| {\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups, if i == last { ret_flag }\n-                                   else { none }, 0u);\n+                                   else { None }, 0u);\n             bcx = r.bcx;\n             vec::push(llargs, r.val);\n         }\n@@ -3243,7 +3243,7 @@ fn body_contains_ret(body: ast::blk) -> bool {\n // See [Note-arg-mode]\n fn trans_call_inner(\n     ++in_cx: block,\n-    call_info: option<node_info>,\n+    call_info: Option<node_info>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n     get_callee: fn(block) -> lval_maybe_callee,\n@@ -3270,8 +3270,8 @@ fn trans_call_inner(\n         let ret_flag = if ret_in_loop {\n             let flag = alloca(bcx, T_bool());\n             Store(bcx, C_bool(false), flag);\n-            some(flag)\n-        } else { none };\n+            Some(flag)\n+        } else { None };\n \n         let mut faddr = f_res.val;\n         let llenv = match f_res.env {\n@@ -3333,7 +3333,7 @@ fn trans_call_inner(\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }\n-                cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n+                cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n                 Unreachable(bcx);\n                 bcx\n             }\n@@ -3389,8 +3389,8 @@ fn need_invoke(bcx: block) -> bool {\n           _ => ()\n         }\n         cur = match cur.parent {\n-          some(next) => next,\n-          none => return false\n+          Some(next) => next,\n+          None => return false\n         }\n     }\n }\n@@ -3399,8 +3399,8 @@ fn have_cached_lpad(bcx: block) -> bool {\n     let mut res = false;\n     do in_lpad_scope_cx(bcx) |inf| {\n         match inf.landing_pad {\n-          some(_) => res = true,\n-          none => res = false\n+          Some(_) => res = true,\n+          None => res = false\n         }\n     }\n     return res;\n@@ -3424,19 +3424,19 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n-    let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n+    let mut cached = None, pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n         // If there is a valid landing pad still around, use it\n         match copy inf.landing_pad {\n-          some(target) => cached = some(target),\n-          none => {\n+          Some(target) => cached = Some(target),\n+          None => {\n             pad_bcx = lpad_block(bcx, ~\"unwind\");\n-            inf.landing_pad = some(pad_bcx.llbb);\n+            inf.landing_pad = Some(pad_bcx.llbb);\n           }\n         }\n     }\n     // Can't return from block above\n-    match cached { some(b) => return b, none => () }\n+    match cached { Some(b) => return b, None => () }\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3458,16 +3458,16 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n     match copy bcx.fcx.personality {\n-      some(addr) => Store(pad_bcx, llretval, addr),\n-      none => {\n+      Some(addr) => Store(pad_bcx, llretval, addr),\n+      None => {\n         let addr = alloca(pad_bcx, val_ty(llretval));\n-        bcx.fcx.personality = some(addr);\n+        bcx.fcx.personality = Some(addr);\n         Store(pad_bcx, llretval, addr);\n       }\n     }\n \n     // Unwind all parent scopes, and finish with a Resume instr\n-    cleanup_and_leave(pad_bcx, none, none);\n+    cleanup_and_leave(pad_bcx, None, None);\n     return pad_bcx.llbb;\n }\n \n@@ -3495,20 +3495,20 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n }\n \n fn trans_rec(bcx: block, fields: ~[ast::field],\n-             base: option<@ast::expr>, id: ast::node_id,\n+             base: Option<@ast::expr>, id: ast::node_id,\n              // none = ignore; some(x) = save_in(x)\n-             dest: option<ValueRef>) -> block {\n+             dest: Option<ValueRef>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n     let addr = match dest {\n-      none => {\n+      None => {\n         for vec::each(fields) |fld| {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n         return bcx;\n       }\n-      some(pos) => pos\n+      Some(pos) => pos\n     };\n \n     let ty_fields = match ty::get(t).struct {\n@@ -3526,7 +3526,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         vec::push(temp_cleanups, dst);\n     }\n     match base {\n-      some(bexp) => {\n+      Some(bexp) => {\n         let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp);\n         bcx = cx;\n         // Copy over inherited fields\n@@ -3539,7 +3539,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n             }\n         }\n       }\n-      none => ()\n+      None => ()\n     };\n \n     // Now revoke the cleanups as we pass responsibility for the data\n@@ -3561,7 +3561,7 @@ fn get_struct_field(block_context: block, dest_address: ValueRef,\n }\n \n fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n-                base: option<@ast::expr>, id: ast::node_id, dest: dest)\n+                base: Option<@ast::expr>, id: ast::node_id, dest: dest)\n              -> block {\n \n     let _instruction_context = block_context.insn_ctxt(\"trans_struct\");\n@@ -3612,21 +3612,21 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     // Now translate each field.\n     let mut temp_cleanups = ~[];\n     for fields.each |field| {\n-        let mut found = none;\n+        let mut found = None;\n         for class_fields.eachi |i, class_field| {\n             if class_field.ident == field.node.ident {\n-                found = some((i, class_field.id));\n+                found = Some((i, class_field.id));\n                 break;\n             }\n         }\n \n         let index, field_id;\n         match found {\n-            some((found_index, found_field_id)) => {\n+            Some((found_index, found_field_id)) => {\n                 index = found_index;\n                 field_id = found_field_id;\n             }\n-            none => {\n+            None => {\n                 type_context.sess.span_bug(span, ~\"unknown field\");\n             }\n         }\n@@ -3645,7 +3645,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     }\n \n     match base {\n-        some(base_expr) => {\n+        Some(base_expr) => {\n             let { bcx: bcx, val: llbasevalue } =\n                 trans_temp_expr(block_context, base_expr);\n             block_context = bcx;\n@@ -3677,7 +3677,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                                          field_type);\n             }\n         }\n-        none => ()\n+        None => ()\n     }\n \n     // Now revoke the cleanups, as we pass responsibility for the data\n@@ -3771,14 +3771,14 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n         let mut bcx_sid = bcx;\n         loop {\n             bcx_sid = match bcx_sid.node_info {\n-              some({id, _}) if id == scope_id => {\n+              Some({id, _}) if id == scope_id => {\n                 return bcx_sid\n               }\n               _ => {\n                 match bcx_sid.parent {\n-                  none => bcx.tcx().sess.bug(\n+                  None => bcx.tcx().sess.bug(\n                       fmt!(\"no enclosing scope with id %d\", scope_id)),\n-                  some(bcx_par) => bcx_par\n+                  Some(bcx_par) => bcx_par\n                 }\n               }\n             }\n@@ -3799,8 +3799,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     }\n \n     return match bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n-      none => unrooted(bcx, e, dest),\n-      some(scope_id) => {\n+      None => unrooted(bcx, e, dest),\n+      Some(scope_id) => {\n         debug!(\"expression %d found in root map with scope %d\",\n                e.id, scope_id);\n \n@@ -3836,8 +3836,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           }\n           ast::expr_rec(args, base) => {\n               let d = match dest {\n-                  ignore => none,\n-                  save_in(p) => some(p),\n+                  ignore => None,\n+                  save_in(p) => Some(p),\n                   _ => bcx.sess().impossible_case(e.span,\n                         \"trans_expr::unrooted: can't pass a record by val\")\n               };\n@@ -3853,12 +3853,12 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_lit(lit) => return trans_lit(bcx, e, *lit, dest),\n           ast::expr_vec(args, _) => {\n             return tvec::trans_evec(bcx, tvec::individual_evec(args),\n-                                    ast::vstore_fixed(none), e.id, dest);\n+                                    ast::vstore_fixed(None), e.id, dest);\n           }\n           ast::expr_repeat(element, count_expr, _) => {\n             let count = ty::eval_repeat_count(bcx.tcx(), count_expr, e.span);\n             return tvec::trans_evec(bcx, tvec::repeating_evec(element, count),\n-                                    ast::vstore_fixed(none), e.id, dest);\n+                                    ast::vstore_fixed(None), e.id, dest);\n           }\n           ast::expr_binary(op, lhs, rhs) => {\n             return trans_binary(bcx, op, lhs, rhs, dest, e);\n@@ -3889,7 +3889,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             // guess?); @fn() { ... } won't work.\n             return closure::trans_expr_fn(bcx,\n                                           ast_proto_to_proto_simple(proto),\n-                                          decl, body, e.id, cap_clause, none,\n+                                          decl, body, e.id, cap_clause, None,\n                                           dest);\n           }\n           ast::expr_fn_block(decl, body, cap_clause) => {\n@@ -3899,7 +3899,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                        expr_to_str(e, tcx.sess.intr()),\n                        ppaux::ty_to_str(tcx, expr_ty(bcx, e)));\n                 return closure::trans_expr_fn(bcx, proto, decl, body,\n-                                           e.id, cap_clause, none, dest);\n+                                           e.id, cap_clause, None, dest);\n               }\n               _ =>  bcx.sess().impossible_case(e.span, \"fn_block has \\\n                          body with a non-fn type\")\n@@ -3911,7 +3911,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                       match blk.node {\n                           ast::expr_fn_block(decl, body, cap) =>\n                             return trans_loop_body(bcx, blk.id, decl, body,\n-                                                   proto, cap, none, dest),\n+                                                   proto, cap, None, dest),\n                           _ => bcx.sess().impossible_case(e.span, \"loop_body \\\n                                  has the wrong kind of contents\")\n                       }\n@@ -3976,7 +3976,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           }\n           ast::expr_fail(expr) => {\n             assert dest == ignore;\n-            return trans_fail_expr(bcx, some(e.span), expr);\n+            return trans_fail_expr(bcx, Some(e.span), expr);\n           }\n           ast::expr_log(_, lvl, a) => {\n             assert dest == ignore;\n@@ -4171,16 +4171,16 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n         }\n     };\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n-        trans_fail(bcx, some(pred_expr.span), expr_str)\n+        trans_fail(bcx, Some(pred_expr.span), expr_str)\n     }\n }\n \n-fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n-                   fail_expr: option<@ast::expr>) -> block {\n+fn trans_fail_expr(bcx: block, sp_opt: Option<span>,\n+                   fail_expr: Option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n-      some(expr) => {\n+      Some(expr) => {\n         let ccx = bcx.ccx(), tcx = ccx.tcx;\n         let expr_res = trans_temp_expr(bcx, expr);\n         let e_ty = expr_ty(bcx, expr);\n@@ -4202,19 +4202,19 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n     }\n }\n \n-fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n+fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let {V_filename, V_line} = match sp_opt {\n-      some(sp) => {\n+      Some(sp) => {\n         let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n         {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n          V_line: loc.line as int}\n       }\n-      none => {\n+      None => {\n         {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n          V_line: 0}\n       }\n@@ -4226,25 +4226,25 @@ fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n-fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: ~str) ->\n+fn trans_fail(bcx: block, sp_opt: Option<span>, fail_str: ~str) ->\n     block {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: block, sp_opt: option<span>,\n+fn trans_fail_value(bcx: block, sp_opt: Option<span>,\n                     V_fail_str: ValueRef) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let {V_filename, V_line} = match sp_opt {\n-      some(sp) => {\n+      Some(sp) => {\n         let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n         {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n          V_line: loc.line as int}\n       }\n-      none => {\n+      None => {\n         {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n          V_line: 0}\n       }\n@@ -4267,8 +4267,8 @@ fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: dest)\n     };\n     let rty = ty::ty_fn_ret(fty);\n     return trans_call_inner(\n-        bcx, none, fty, rty,\n-        |bcx| lval_static_fn_inner(bcx, did, 0, ~[], none),\n+        bcx, None, fty, rty,\n+        |bcx| lval_static_fn_inner(bcx, did, 0, ~[], None),\n         arg_vals(args), dest);\n }\n \n@@ -4280,7 +4280,7 @@ fn trans_break_cont(bcx: block, to_end: bool)\n     let mut target;\n     loop {\n         match unwind.kind {\n-          block_scope({loop_break: some(brk), _}) => {\n+          block_scope({loop_break: Some(brk), _}) => {\n             target = if to_end {\n                 brk\n             } else {\n@@ -4291,11 +4291,11 @@ fn trans_break_cont(bcx: block, to_end: bool)\n           _ => ()\n         }\n         unwind = match unwind.parent {\n-          some(cx) => cx,\n+          Some(cx) => cx,\n           // This is a return from a loop body block\n-          none => {\n+          None => {\n             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n-            cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n+            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n             return bcx;\n           }\n@@ -4314,31 +4314,31 @@ fn trans_cont(cx: block) -> block {\n     return trans_break_cont(cx, false);\n }\n \n-fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n+fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let retptr = match copy bcx.fcx.loop_ret {\n-      some({flagptr, retptr}) => {\n+      Some({flagptr, retptr}) => {\n         // This is a loop body return. Must set continue flag (our retptr)\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n         Store(bcx, C_bool(false), bcx.fcx.llretptr);\n         match e {\n-          some(x) => PointerCast(bcx, retptr,\n+          Some(x) => PointerCast(bcx, retptr,\n                                  T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n-          none => retptr\n+          None => retptr\n         }\n       }\n-      none => bcx.fcx.llretptr\n+      None => bcx.fcx.llretptr\n     };\n     match e {\n-      some(x) => {\n+      Some(x) => {\n         bcx = trans_expr_save_in(bcx, x, retptr);\n       }\n       _ => ()\n     }\n-    cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n+    cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n     Unreachable(bcx);\n     return bcx;\n }\n@@ -4361,15 +4361,15 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     if ignore_lhs(bcx, local) {\n         // Handle let _ = e; just like e;\n         match local.node.init {\n-            some(init) => {\n+            Some(init) => {\n               return trans_expr(bcx, init.expr, ignore);\n             }\n-            none => { return bcx; }\n+            None => { return bcx; }\n         }\n     }\n \n     let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n-      some(local_mem(v)) => v,\n+      Some(local_mem(v)) => v,\n       _ => { bcx.tcx().sess.span_bug(local.span,\n                         ~\"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n@@ -4378,7 +4378,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n \n     let mut bcx = bcx;\n     match local.node.init {\n-      some(init) => {\n+      Some(init) => {\n         if init.op == ast::init_assign || !expr_is_lval(bcx, init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr);\n         } else { // This is a move from an lval, must perform an actual move\n@@ -4428,8 +4428,8 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n-             is_lpad: bool, name: ~str, opt_node_info: option<node_info>)\n+fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n+             is_lpad: bool, name: ~str, opt_node_info: Option<node_info>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -4446,45 +4446,45 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n }\n \n fn simple_block_scope() -> block_kind {\n-    block_scope({loop_break: none, mut cleanups: ~[],\n-                 mut cleanup_paths: ~[], mut landing_pad: none})\n+    block_scope({loop_break: None, mut cleanups: ~[],\n+                 mut cleanup_paths: ~[], mut landing_pad: None})\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n-    return new_block(fcx, none, simple_block_scope(), false,\n+fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<node_info>) -> block {\n+    return new_block(fcx, None, simple_block_scope(), false,\n                   ~\"function top level\", opt_node_info);\n }\n \n fn scope_block(bcx: block,\n-               opt_node_info: option<node_info>,\n+               opt_node_info: Option<node_info>,\n                n: ~str) -> block {\n-    return new_block(bcx.fcx, some(bcx), simple_block_scope(), bcx.is_lpad,\n+    return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n fn loop_scope_block(bcx: block, loop_break: block, n: ~str,\n-                    opt_node_info: option<node_info>) -> block {\n-    return new_block(bcx.fcx, some(bcx), block_scope({\n-        loop_break: some(loop_break),\n+                    opt_node_info: Option<node_info>) -> block {\n+    return new_block(bcx.fcx, Some(bcx), block_scope({\n+        loop_break: Some(loop_break),\n         mut cleanups: ~[],\n         mut cleanup_paths: ~[],\n-        mut landing_pad: none\n+        mut landing_pad: None\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n // Use this when creating a block for the inside of a landing pad.\n fn lpad_block(bcx: block, n: ~str) -> block {\n-    new_block(bcx.fcx, some(bcx), block_non_scope, true, n, none)\n+    new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n fn sub_block(bcx: block, n: ~str) -> block {\n-    new_block(bcx.fcx, some(bcx), block_non_scope, bcx.is_lpad, n, none)\n+    new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n-    mk_block(llbb, none, block_non_scope, is_lpad, none, fcx)\n+    mk_block(llbb, None, block_non_scope, is_lpad, None, fcx)\n }\n \n \n@@ -4520,20 +4520,20 @@ fn trans_block_cleanups_(bcx: block,\n     return bcx;\n }\n \n-// In the last argument, some(block) mean jump to this block, and none means\n+// In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n-                     leave: option<BasicBlockRef>) {\n+fn cleanup_and_leave(bcx: block, upto: Option<BasicBlockRef>,\n+                     leave: Option<BasicBlockRef>) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n-    let is_lpad = leave == none;\n+    let is_lpad = leave == None;\n     loop {\n         debug!(\"cleanup_and_leave: leaving %s\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n-                bcx, none,\n+                bcx, None,\n                 fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n@@ -4552,24 +4552,24 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n           _ => ()\n         }\n         match upto {\n-          some(bb) => { if cur.llbb == bb { break; } }\n+          Some(bb) => { if cur.llbb == bb { break; } }\n           _ => ()\n         }\n         cur = match cur.parent {\n-          some(next) => next,\n-          none => { assert is_none(upto); break; }\n+          Some(next) => next,\n+          None => { assert is_none(upto); break; }\n         };\n     }\n     match leave {\n-      some(target) => Br(bcx, target),\n-      none => { Resume(bcx, Load(bcx, option::get(bcx.fcx.personality))); }\n+      Some(target) => Br(bcx, target),\n+      None => { Resume(bcx, Load(bcx, option::get(bcx.fcx.personality))); }\n     }\n }\n \n fn cleanup_and_Br(bcx: block, upto: block,\n                   target: BasicBlockRef) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n-    cleanup_and_leave(bcx, some(upto.llbb), some(target));\n+    cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n fn leave_block(bcx: block, out_of: block) -> block {\n@@ -4580,15 +4580,15 @@ fn leave_block(bcx: block, out_of: block) -> block {\n     next_cx\n }\n \n-fn with_scope(bcx: block, opt_node_info: option<node_info>,\n+fn with_scope(bcx: block, opt_node_info: Option<node_info>,\n               name: ~str, f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     leave_block(f(scope_cx), scope_cx)\n }\n \n-fn with_scope_result(bcx: block, opt_node_info: option<node_info>,\n+fn with_scope_result(bcx: block, opt_node_info: Option<node_info>,\n                      name: ~str, f: fn(block) -> result)\n     -> result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n@@ -4637,8 +4637,8 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let _icx = cx.insn_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n-      ast::pat_ident(_, pth, none) => some(path_to_ident(pth)),\n-      _ => none\n+      ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n+      _ => None\n     };\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n@@ -4662,7 +4662,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n         bcx = trans_stmt(bcx, *s);\n     }\n     match b.node.expr {\n-      some(e) => {\n+      Some(e) => {\n         let bt = ty::type_is_bot(expr_ty(bcx, e));\n         debuginfo::update_source_pos(bcx, e.span);\n         bcx = trans_expr(bcx, e, if bt { ignore } else { dest });\n@@ -4692,18 +4692,18 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - trans_args\n fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n-                    param_substs: option<param_substs>,\n-                    sp: option<span>) -> fn_ctxt {\n+                    param_substs: Option<param_substs>,\n+                    sp: Option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n           llretptr: llvm::LLVMGetParam(llfndecl, 0u as c_uint),\n           mut llstaticallocas: llbbs.sa,\n           mut llloadenv: llbbs.ca,\n           mut llreturn: llbbs.rt,\n-          mut llself: none,\n-          mut personality: none,\n-          mut loop_ret: none,\n+          mut llself: None,\n+          mut personality: None,\n+          mut loop_ret: None,\n           llargs: int_hash::<local_val>(),\n           lllocals: int_hash::<local_val>(),\n           llupvars: int_hash::<ValueRef>(),\n@@ -4715,8 +4715,8 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n }\n \n fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n-               sp: option<span>) -> fn_ctxt {\n-    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n+               sp: Option<span>) -> fn_ctxt {\n+    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4741,10 +4741,10 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     let mut arg_n = first_real_arg;\n     match ty_self {\n       impl_self(tt) => {\n-        cx.llself = some({v: cx.llenv, t: tt, is_owned: false});\n+        cx.llself = Some({v: cx.llenv, t: tt, is_owned: false});\n       }\n       impl_owned_self(tt) => {\n-        cx.llself = some({v: cx.llenv, t: tt, is_owned: true});\n+        cx.llself = Some({v: cx.llenv, t: tt, is_owned: true});\n       }\n       no_self => ()\n     }\n@@ -4773,13 +4773,13 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n     };\n \n     match fcx.llself {\n-      some(copy slf) => {\n+      Some(copy slf) => {\n         // We really should do this regardless of whether self is owned,\n         // but it doesn't work right with default method impls yet.\n         if slf.is_owned {\n             let self_val = PointerCast(bcx, slf.v,\n                                        T_ptr(type_of(bcx.ccx(), slf.t)));\n-            fcx.llself = some({v: self_val with slf});\n+            fcx.llself = Some({v: self_val with slf});\n             add_clean(bcx, self_val, slf.t);\n         }\n       }\n@@ -4837,7 +4837,7 @@ enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg,\n-                 param_substs: option<param_substs>,\n+                 param_substs: Option<param_substs>,\n                  id: ast::node_id,\n                  maybe_load_env: fn(fn_ctxt),\n                  finish: fn(block)) {\n@@ -4846,7 +4846,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n-                                  some(body.span));\n+                                  Some(body.span));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n \n     // Set GC for function.\n@@ -4899,7 +4899,7 @@ fn trans_fn(ccx: @crate_ctxt,\n             body: ast::blk,\n             llfndecl: ValueRef,\n             ty_self: self_arg,\n-            param_substs: option<param_substs>,\n+            param_substs: Option<param_substs>,\n             id: ast::node_id) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n@@ -4924,7 +4924,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                       variant: ast::variant,\n                       args: ~[ast::variant_arg],\n                       disr: int, is_degen: bool,\n-                      param_substs: option<param_substs>,\n+                      param_substs: Option<param_substs>,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n@@ -4934,13 +4934,13 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n          ident: special_idents::arg,\n          id: varg.id});\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n-                               param_substs, none);\n+                               param_substs, None);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = match param_substs {\n-      some(substs) => substs.tys,\n-      none => ~[]\n+      Some(substs) => substs.tys,\n+      None => ~[]\n     };\n-    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n@@ -4963,7 +4963,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = match fcx.llargs.find(va.id) {\n-            some(local_mem(x)) => x,\n+            Some(local_mem(x)) => x,\n             _ => fail ~\"trans_enum_variant: how do we know this works?\",\n         };\n         let arg_ty = arg_tys[i].ty;\n@@ -4991,7 +4991,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n   // Make the fn context\n   let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n-                                   some(psubsts), some(sp));\n+                                   Some(psubsts), Some(sp));\n   create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n   let mut bcx_top = top_scope_block(fcx, body.info());\n   let lltop = bcx_top.llbb;\n@@ -5029,23 +5029,23 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   }\n \n   // note we don't want to take *or* drop self.\n-  fcx.llself = some({v: selfptr, t: rslt_ty, is_owned: false});\n+  fcx.llself = Some({v: selfptr, t: rslt_ty, is_owned: false});\n \n   // Translate the body of the ctor\n   bcx = trans_block(bcx_top, body, ignore);\n   let lval_res = {bcx: bcx, val: selfptr, kind: lv_owned};\n   // Generate the return expression\n   bcx = store_temp_expr(bcx, INIT, fcx.llretptr, lval_res,\n                         rslt_ty, true);\n-  cleanup_and_leave(bcx, none, some(fcx.llreturn));\n+  cleanup_and_leave(bcx, None, Some(fcx.llreturn));\n   Unreachable(bcx);\n   finish_fn(fcx, lltop);\n }\n \n fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n     body: ast::blk, dtor_id: ast::node_id,\n-    psubsts: option<param_substs>,\n-    hash_id: option<mono_id>, parent_id: ast::def_id)\n+    psubsts: Option<param_substs>,\n+    hash_id: Option<mono_id>, parent_id: ast::def_id)\n     -> ValueRef {\n   let tcx = ccx.tcx;\n   /* Look up the parent class's def_id */\n@@ -5090,7 +5090,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n             ast::tuple_variant_kind(args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n                 trans_enum_variant(ccx, id, variant, args, disr_val,\n-                                   degen, none, llfn);\n+                                   degen, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n                 // Nothing to do.\n@@ -5127,7 +5127,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(*path, ~[path_name(item.ident)]),\n-                     decl, body, llfndecl, no_self, none, item.id);\n+                     decl, body, llfndecl, no_self, None, item.id);\n         } else {\n             for vec::each(body.node.stmts) |stmt| {\n                 match stmt.node {\n@@ -5177,7 +5177,7 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                     ident: ast::ident, id: ast::node_id) {\n     if tps.len() == 0u {\n       let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n-                     vtables: none,\n+                     vtables: None,\n                      bounds: @~[]};\n       do option::iter(struct_def.ctor) |ctor| {\n         trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n@@ -5186,7 +5186,7 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n       }\n       do option::iter(struct_def.dtor) |dtor| {\n          trans_class_dtor(ccx, *path, dtor.node.body,\n-           dtor.node.id, none, none, local_def(id));\n+           dtor.node.id, None, None, local_def(id));\n       };\n     }\n     // If there are ty params, the ctor will get monomorphized\n@@ -5252,7 +5252,7 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n                        main_node_type: ty::t) {\n \n-    if ccx.main_fn != none::<ValueRef> {\n+    if ccx.main_fn != None::<ValueRef> {\n         ccx.sess.span_fatal(sp, ~\"multiple 'main' functions\");\n     }\n \n@@ -5264,7 +5264,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         };\n \n     let llfn = create_main(ccx, main_llfn, main_takes_argv);\n-    ccx.main_fn = some(llfn);\n+    ccx.main_fn = Some(llfn);\n     create_entry_fn(ccx, llfn);\n \n     fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef,\n@@ -5279,9 +5279,9 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, none);\n+        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, None);\n \n-        let bcx = top_scope_block(fcx, none);\n+        let bcx = top_scope_block(fcx, None);\n         let lltop = bcx.llbb;\n \n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n@@ -5358,31 +5358,31 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n-                   substs: option<param_substs>) -> ~str {\n+                   substs: Option<param_substs>) -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(id) {\n-     some(s) => s,\n-     none if is_none(substs) => {\n+     Some(s) => s,\n+     None if is_none(substs) => {\n        let s = mangle_exported_name(\n            ccx,\n            vec::append(path, ~[path_name(ccx.names(~\"dtor\"))]),\n            t);\n        ccx.item_symbols.insert(id, s);\n        s\n      }\n-     none   => {\n+     None   => {\n        // Monomorphizing, so just make a symbol, don't add\n        // this to item_symbols\n        match substs {\n-         some(ss) => {\n+         Some(ss) => {\n            let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, t);\n            mangle_exported_name(\n                ccx,\n                vec::append(path,\n                            ~[path_name(ccx.names(~\"dtor\"))]),\n                mono_ty)\n          }\n-         none => {\n+         None => {\n              ccx.sess.bug(fmt!(\"get_dtor_symbol: not monomorphizing and \\\n                couldn't find a symbol for dtor %?\", path));\n          }\n@@ -5395,8 +5395,8 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(id) {\n-      some(v) => v,\n-      none => {\n+      Some(v) => v,\n+      None => {\n         let mut exprt = false;\n         let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n@@ -5476,7 +5476,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             let lldty = T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n                     T_ptr(type_of(ccx, class_ty))],\n                                    llvm::LLVMVoidType());\n-            let s = get_dtor_symbol(ccx, *pt, dt.node.id, none);\n+            let s = get_dtor_symbol(ccx, *pt, dt.node.id, None);\n \n             /* Make the declaration for the dtor */\n             let llfn = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n@@ -5642,7 +5642,7 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n     match bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n-      some(x) => { Call(bcx, x, v); },\n+      Some(x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }\n }\n@@ -5662,12 +5662,12 @@ fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n                 attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n             do vec::iter(attr_metas) |attr_meta| {\n                 match attr::get_meta_item_list(attr_meta) {\n-                  some(list) => {\n+                  Some(list) => {\n                     let name = attr::get_meta_item_name(vec::head(list));\n                     push_rtcall(ccx, name, {crate: ast::local_crate,\n                                             node: item.id});\n                   }\n-                  none => ()\n+                  None => ()\n                 }\n             }\n           }\n@@ -5904,9 +5904,9 @@ fn trans_crate(sess: session::session,\n     lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n     let crate_map = decl_crate_map(sess, link_meta, llmod);\n     let dbg_cx = if sess.opts.debuginfo {\n-        option::some(debuginfo::mk_ctxt(llmod_id, sess.parse_sess.interner))\n+        option::Some(debuginfo::mk_ctxt(llmod_id, sess.parse_sess.interner))\n     } else {\n-        option::none\n+        option::None\n     };\n \n     let ccx =\n@@ -5921,7 +5921,7 @@ fn trans_crate(sess: session::session,\n           exp_map2: emap2,\n           reachable: reachable,\n           item_symbols: int_hash::<~str>(),\n-          mut main_fn: none::<ValueRef>,\n+          mut main_fn: None::<ValueRef>,\n           link_meta: link_meta,\n           enum_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_hash::<ValueRef>(),"}, {"sha": "7a5fb3edfad1b0610521848aff052c14b5a8087b", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -50,7 +50,7 @@ fn count_insn(cx: block, category: &str) {\n         s += category;\n \n         let n = match h.find(s) {\n-          some(n) => n,\n+          Some(n) => n,\n           _ => 0u\n         };\n         h.insert(s, n+1u);"}, {"sha": "877c4da486ba0fd579b7c375593b5f7476ce8a43", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91", "patch": "@@ -250,7 +250,7 @@ fn build_closure(bcx0: block,\n                  cap_vars: ~[capture::capture_var],\n                  ck: ty::closure_kind,\n                  id: ast::node_id,\n-                 include_ret_handle: option<ValueRef>) -> closure_result {\n+                 include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut env_vals = ~[];\n@@ -275,8 +275,8 @@ fn build_closure(bcx0: block,\n           }\n           capture::cap_copy => {\n             let mv = match ccx.maps.last_use_map.find(id) {\n-              none => false,\n-              some(vars) => (*vars).contains(nid)\n+              None => false,\n+              Some(vars) => (*vars).contains(nid)\n             };\n             if mv { vec::push(env_vals, env_move(lv.val, ty, lv.kind)); }\n             else { vec::push(env_vals, env_copy(lv.val, ty, lv.kind)); }\n@@ -293,8 +293,8 @@ fn build_closure(bcx0: block,\n     }\n     do option::iter(include_ret_handle) |flagptr| {\n         let our_ret = match bcx.fcx.loop_ret {\n-          some({retptr, _}) => retptr,\n-          none => bcx.fcx.llretptr\n+          Some({retptr, _}) => retptr,\n+          None => bcx.fcx.llretptr\n         };\n         let nil_ret = PointerCast(bcx, our_ret, T_ptr(T_nil()));\n         vec::push(env_vals,\n@@ -344,7 +344,7 @@ fn load_environment(fcx: fn_ctxt,\n         let retptr = Load(bcx,\n                           GEPi(bcx, llcdata,\n                                ~[0u, i+1u]));\n-        fcx.loop_ret = some({flagptr: flagptr, retptr: retptr});\n+        fcx.loop_ret = Some({flagptr: flagptr, retptr: retptr});\n     }\n }\n \n@@ -354,7 +354,7 @@ fn trans_expr_fn(bcx: block,\n                  body: ast::blk,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n-                 is_loop_body: option<option<ValueRef>>,\n+                 is_loop_body: Option<Option<ValueRef>>,\n                  dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n     if dest == ignore { return bcx; }\n@@ -369,7 +369,7 @@ fn trans_expr_fn(bcx: block,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> result {\n         let cap_vars = capture::compute_capture_vars(ccx.tcx, id, proto,\n                                                      cap_clause);\n-        let ret_handle = match is_loop_body { some(x) => x, none => none };\n+        let ret_handle = match is_loop_body { Some(x) => x, None => None };\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id,\n                                                    ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n@@ -392,7 +392,7 @@ fn trans_expr_fn(bcx: block,\n       ty::proto_vstore(ty::vstore_uniq) =>\n         trans_closure_env(ty::ck_uniq),\n       ty::proto_bare => {\n-        trans_closure(ccx, sub_path, decl, body, llfn, no_self, none,\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n                       id, |_fcx| { }, |_bcx| { });\n         {bcx: bcx, val: C_null(T_opaque_box_ptr(ccx))}\n       }\n@@ -484,7 +484,7 @@ fn make_opaque_cbox_take_glue(\n         // Take the data in the tuple\n         let cdata_out = GEPi(bcx, cbox_out, ~[0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata_out, tydesc,\n-                              abi::tydesc_field_take_glue, none);\n+                              abi::tydesc_field_take_glue, None);\n         bcx\n     }\n }\n@@ -531,7 +531,7 @@ fn make_opaque_cbox_free_glue(\n         // Drop the tuple data then free the descriptor\n         let cdata = GEPi(bcx, cbox, ~[0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata, tydesc,\n-                              abi::tydesc_field_drop_glue, none);\n+                              abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n         match ck {"}, {"sha": "aabe76709b5384e5505319f9670840b0103aa884", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "a82afc66cfae47e71243faff391c228c034dd301", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e3a771c7251bce649d63549caac36fd6512d4976", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ae5e77db8ee4871296d6347c4d0988add7efa3ee", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "05f553a377aadc0bb9ec84baea33f57bb7933dfa", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "319a2f5db7dfee3ad5d9ab496ea778ac89e885a5", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7825d412ddd79d5959d62a585a2dc3d6e51eaad9", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "409d6c4f9d7ccb1fc3feced3cf5eb746b49369d3", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "4d8d4e6d9d53a45d7dcde0e827e3f7f0153b264a", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0ea48a1d84407cba2f31dad232f89c84cf026de2", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "841dbe7f82addb09bc57fd610cc4e038973932f5", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7920d376ffb61c03af635f6d958b789f93f52c81", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ec27dfea6edffa1e9a8caad97c81cf991e865d48", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d1e49caa99ab8be8ae461ca7df2672b0930e2e4d", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d0422a6c0a5584866935c75f54cd7f3a3aa29b3d", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "af7855c1ed38df4e306cb3470ea6d7bc211ab801", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8163e367d61222d743ae8d9f6861c3a92e948613", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "9f915051765b01e78e2bea5f6d4b2f296a266c79", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f3036c0a5ae8812cae4fd582f7c55c2a94174b1c", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 175, "deletions": 175, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "bad7ff85ca75edb9b7cdae648743dfcb486c0a48", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8c983c1e957b66870e0f78c5871c68149b305ed3", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "14fc30983676ddc0deeca6ab43896d592d00405e", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "61a59c5dccda65efdffdcf40bf3082b2b63aa4f1", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "43301d5f738dfa40eab8900ac416cdf83f760748", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "218cd9069151ed6975d860d435b5490c295b6c44", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f0b674e350a77073d9fcfec04a74fefa26baf614", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b3d70c0af4ab69da863910ccd75710441630738e", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "a2b39f5db15b36a95012501aa6482ddf878b02f2", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c33f4e4cfa82495b8019dda3fc6835630977977e", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "02727c46322a3479c4625f47f42339987cd19490", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "87b610d433b24ad6fdfc07f111e010575b436ff9", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "96a4a8ab7791cef93a856ce7daeaf050a3c16ef2", "filename": "src/rustc/middle/typeck/infer/integral.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b5b694d6283da966e8063ba7e8dc8e15289f87fd", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "78013a43422ebb9cb12d39cb00b58a6c96d9d9ca", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8a7beaf95c9417bca8e6931978fb5271075af072", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b26c2facbcd921c3cd229439ccc469800a2325d5", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c51ec05b471adb0cd99ad7fdca18b6021a9db50d", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "80a2d631b9aa7fca8d30c3f423782d9c423fba2d", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "11bbc6609f526d862a6c706bfba8b9ecbfecb8e8", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c18bbd12ae1fdd39352a52b8eeac6d49ca098d70", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7bac59f018e4e4c11be6ea2fb09937859655f85c", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2d2cc7ee99a7c93627598152179c1e35a0e83f58", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "a111597d5dfa99324195f2e9b4e6bd68398c2f3b", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b22c66e10252e8051a81a33e1af8bee0eb4480bb", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "33ff45a7d927105fda515cda34b26151a2367ab6", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "4ee4953b3da62d24ea5821d5deeb2ae42fb6731f", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "a04772097e2b546d17e9f988585d3fb7e976386e", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f3be8a9edd7179b54a7f17f1be204ddf463aa79e", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f0286b5948b9b34352c65bf6f8c3991b9a5d7a11", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8bc62aaf422227e21de3eeb37cb1adb21f22c818", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "850f78c8fa4c3eb5cf829f91e0aaa75b051c05e0", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "811a8f409ad56c2c8320e9644938a94359fd73d1", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ea2843707dbd903458a59e74794a7961f5a04caf", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "55609b3daf689e8c55748edc63070984af331bb4", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8d314c508a27448718e9b0297e4e74fabffbae93", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "72869a6a7c4230ba23d7c3b55128f7f20ac40f9f", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "58285f6d857892e5744b37a70aa5d17c836371fd", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "15fe6d3fc6bc7402649c4cbea083cbf4343be3c9", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2be025f9846518ed0ac0d3855a4f274caaeea269", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ef4dcdfbdda2ee15a99fe857747e2937c8fd3487", "filename": "src/test/auxiliary/noexporttypelib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "954e1f66f5140f68d692647852f10b2004b665bd", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "1e7f4077d335b3b99bd0a8eb8e806abefa3000ff", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0eedfafd7a5843da2236dad167bc6b6194082e7f", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e9e2047a4c085d9de48fc832360fd81c2f4da470", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f3edd13cc361ac59279d67adb8bb5a3894986f3e", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "a96e31e7791582693c3cbef15f93d070c97f8033", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "76b2f685841f2f305fcbf6f7fd698b44d002d199", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8e5e750cf69a41efe23cd89284f49933ea5efb1f", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "4895e4dc24e30a82e36943328b87d093dadd4384", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b3e593c3e3256ae188ae9454a737536d7e703d27", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "20110e60998fd1bbbabdbfae4dd21cd9297900fd", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2f020d6cdfd1203d26b4cc0df2793789dfe82505", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "80f8b36de58548e91c542b8895be10506160b704", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "604e6e17b90055626e1fa988d435689c63823853", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e2060ef2c860c7a6c81ef4577627dd0d20b806f2", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "40f114a7879e4edf74a218be398aeb8b112af9a4", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d7db99a4d5b640918af21cd4d0776fe84046c955", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d861fb1cb79f335197a0d2103b32f9511ade7ab4", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "4e0d2b516df6373b445016a56428b9861efc8ef8", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d7d476445219c2b0e6ea78bff886ebae0dc7afc2", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e6c65d22b408008bbadc773c5be947da829fa959", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e8ef5050a65bc94bba6d35816b20af9304c58d46", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "6aa26abf2166246f42139fb230505892a346f872", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c52848efc45146acd14016ff90e4d7533e2737e9", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "bd85086dfb05fd589e05b9785079cd66bf4ad108", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "10db76f5fd804eef2a3f27959c0a91979d2870b8", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "3ff731e77a520d2ad662166fc9aab4269941bcfd", "filename": "src/test/compile-fail/borrowck-assign-to-constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "98947fbd1a2ec19e3ea62cb303ba6ae763b91e72", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f04c323afba6d543ff26fe42511fb27b827ccd7a", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "5f2feee70eb5c79f0d82908fec4b569059d96efa", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d5e0a678467f08c6ecd99b4dd82d6cdd09d2266c", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "cb715c0cdb9e54ac89142ad07c9b89bf647de529", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "9ecd14effa0956760dc7238ac2b153afd54ed23c", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "49bc7ab82178f0972457220031c9aaefbe9100fe", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "4f4201d5a527ade714cbc0836aeb24f846cd8f73", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2d0b4a13f5d6f44b6e55473c568f3bcbd61d3713", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "f8583dbbd819ec826d04dcdc5eab83f74853e942", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "66bb46e74721f55849252232fc3bb6d27feab479", "filename": "src/test/compile-fail/fully-qualified-type-name1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "090bb5e4f48cfcbea7d1e18473cb2a4f7dad1cc2", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "6821e8fc80008b221f0b13205175d17d1dd9272f", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "9e07a3d8ec22c181d522e88d3a13b4660a96f8de", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "e991a2104226c40d5e32031fd190cd497ea59308", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "3dad39eb1f892bbb04ed05e086235338090c759b", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2bf2155e4c5e625c8a787347288fbb5028c3885f", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "33fb087f7f1b1665d4907cf2c6a75d19ae510c90", "filename": "src/test/compile-fail/noexporttypeexe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0e9615c7bd9a35af6588420a425317c3791c5359", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "19ab57d537cea25f8b8429816bfe900daedff25b", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "6bf0f16cc33eddbc3c427dcfd18f23ac6dd94206", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "3bf006a5840bb2266de4da1b0bf57a9fe684c413", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "be989771da22c9f02e6df3a1883b88f57843ecf1", "filename": "src/test/compile-fail/pptypedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ee3f426d3e09838a4c4dcfb8b8b79148f5ed6754", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "5ab26c0673408685a894f5db5ec64e1c2420af06", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "dd170eed8454ab8ae9770c7eb1ce609f7283b19f", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7ce76f71b0f16cb25955907948dec930f5391bfe", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7c8d743b86b02fe42b11130ad379ef180b976bd1", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "397274429541601b2607299dd87cbe2923e0e7e5", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c78fa183e701f3a8655935fff9c4e04b18bfeb98", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "39eb825b80bb9b0c2df40bd339656c8d524b92c3", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "5d91613d7d58f70af4894f1cb46a2e9e019c1b53", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0cd0e1bb5545a399cac4cc0060d813bac99ebe8f", "filename": "src/test/pretty/alt-naked-expr-long.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ba5a064896b48f0a5fbe6403080cd927be5bdd06", "filename": "src/test/pretty/alt-naked-expr-medium.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "55a9d6f4b1cfb8ce44af7374a166791e823fac8a", "filename": "src/test/pretty/alt-naked-expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "24139001cdef9a2091530b8f202651d71317392a", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7492d6646265583194a9f04041bf99917a4fccb4", "filename": "src/test/run-fail/alt-wildcards.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-wildcards.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ba7fb3c93a4bb37f7cb097b4d5862eee5a4d0800", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b9260d6d5309e964886aee032a33b538fdb9dc2d", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "dda856efb37d7a1d05fa7621b45b31092f2ee8d3", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0f7cded15a4afea0c7f1b9ad600f2b5c6c123f16", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7a994985d2dc47a8244f49235bad5f35abb636ca", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b4c36e310572241cb73d040c0748988821091937", "filename": "src/test/run-pass/alt-ref-binding-mut-option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "57b40bbb4b6c355ba319e8f902fd045cd3e93d8e", "filename": "src/test/run-pass/alt-ref-binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "b64abb9e3c891c12fd1c3a019bef9c9e751af431", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d59728db6fcdaa9181796eb19ebda08636725a2e", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0c198fccb3ed4899fb5fadd09251a46bc45f064a", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "3708d8913f4d36154e3641abd4c5638699044f97", "filename": "src/test/run-pass/borrowck-preserve-box-sometimes-needed.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "5713b5b1a31d78082d79a5a6ab1ba3e6ca7cf21e", "filename": "src/test/run-pass/boxed-class-type-substitution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fboxed-class-type-substitution.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2319b20e9df41d2e3d440822ec53fe2a1ce69522", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "7a8a371cb712d2850e9c5682120d8df522c12c2c", "filename": "src/test/run-pass/classes-self-referential.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ea70cbbbc1a733aa4ade5bdbdd9c36823eee26dd", "filename": "src/test/run-pass/compare-generic-enums.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fcompare-generic-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fcompare-generic-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompare-generic-enums.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "24faa53fda4257c5ecf9ea68fb44bddd3d6d48ee", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "c7af251b59638608928295a4d00618e01e3bb64a", "filename": "src/test/run-pass/exec-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fexec-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fexec-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexec-env.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "825e27c86ae9c2cc043e63150a5e6c56f16e36fe", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "2324aa7bc4098cdcd661627edffda81a04d06e4d", "filename": "src/test/run-pass/issue-1701.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "fa249d62e7ff3aea64460c2209bb6caa4d6313af", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "6e2aaf243c79ae1c70f69012fcbe7fcd9a1f7502", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "0b66943b8eab3eed9576b970d42335597fa00da8", "filename": "src/test/run-pass/issue-979.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fissue-979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-979.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "eb5dbd6aa5cfea4e652f097b442cfb8478162786", "filename": "src/test/run-pass/iter-all.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-all.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "d672df09c2473982b53cb9133d4e6730ef740236", "filename": "src/test/run-pass/iter-any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-any.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "43bce3e7dcbb3a24d5d7b176e315f506d1dd967b", "filename": "src/test/run-pass/iter-contains.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-contains.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "ba22cc7710bc30d66e51dfccc4258ee91f660c55", "filename": "src/test/run-pass/iter-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-count.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "fc9b271f1ab5e4718d0e1ff2336e4e0a776c574b", "filename": "src/test/run-pass/iter-eachi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-eachi.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}, {"sha": "8cb9e0e9d5367227f02ac45faf1684e6d2b06217", "filename": "src/test/run-pass/iter-filter-to-vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8337fa1a545e7958389c6025661990eedd9c1b91/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs?ref=8337fa1a545e7958389c6025661990eedd9c1b91"}]}