{"sha": "b92b1a76e175f396d7986177d0a2d5907bbba888", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MmIxYTc2ZTE3NWYzOTZkNzk4NjE3N2QwYTJkNTkwN2JiYmE4ODg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-20T16:46:19Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-03T19:50:09Z"}, "message": "rustc: use DefKind instead of Def, where possible.", "tree": {"sha": "ea1a00ea182d1a529a2b106f81da4c3de95e489d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea1a00ea182d1a529a2b106f81da4c3de95e489d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b92b1a76e175f396d7986177d0a2d5907bbba888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b92b1a76e175f396d7986177d0a2d5907bbba888", "html_url": "https://github.com/rust-lang/rust/commit/b92b1a76e175f396d7986177d0a2d5907bbba888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b92b1a76e175f396d7986177d0a2d5907bbba888/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3fcab36d25317ff2bad24d67f7e932c37f35d19", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3fcab36d25317ff2bad24d67f7e932c37f35d19", "html_url": "https://github.com/rust-lang/rust/commit/a3fcab36d25317ff2bad24d67f7e932c37f35d19"}], "stats": {"total": 738, "additions": 381, "deletions": 357}, "files": [{"sha": "b9ba1aff8f44ffb4e42364872640029bbaa536ae", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 50, "deletions": 34, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -80,6 +80,53 @@ pub enum DefKind {\n     Macro(MacroKind),\n }\n \n+impl DefKind {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            DefKind::Fn => \"function\",\n+            DefKind::Mod => \"module\",\n+            DefKind::Static => \"static\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Variant => \"variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n+            DefKind::Struct => \"struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive) =>\n+                bug!(\"impossible struct constructor\"),\n+            DefKind::Existential => \"existential type\",\n+            DefKind::TyAlias => \"type alias\",\n+            DefKind::TraitAlias => \"trait alias\",\n+            DefKind::AssociatedTy => \"associated type\",\n+            DefKind::AssociatedExistential => \"associated existential type\",\n+            DefKind::Union => \"union\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::ForeignTy => \"foreign type\",\n+            DefKind::Method => \"method\",\n+            DefKind::Const => \"constant\",\n+            DefKind::AssociatedConst => \"associated constant\",\n+            DefKind::TyParam => \"type parameter\",\n+            DefKind::ConstParam => \"const parameter\",\n+            DefKind::Macro(macro_kind) => macro_kind.descr(),\n+        }\n+    }\n+\n+    /// An English article for the def.\n+    pub fn article(&self) -> &'static str {\n+        match *self {\n+            DefKind::AssociatedTy\n+            | DefKind::AssociatedConst\n+            | DefKind::AssociatedExistential\n+            | DefKind::Enum\n+            | DefKind::Existential => \"an\",\n+            DefKind::Macro(macro_kind) => macro_kind.article(),\n+            _ => \"a\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum Def<Id = hir::HirId> {\n     Def(DefKind, DefId),\n@@ -328,39 +375,13 @@ impl<Id> Def<Id> {\n     /// A human readable name for the def kind (\"function\", \"module\", etc.).\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n-            Def::Def(DefKind::Fn, _) => \"function\",\n-            Def::Def(DefKind::Mod, _) => \"module\",\n-            Def::Def(DefKind::Static, _) => \"static\",\n-            Def::Def(DefKind::Enum, _) => \"enum\",\n-            Def::Def(DefKind::Variant, _) => \"variant\",\n-            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), _) => \"tuple variant\",\n-            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), _) => \"unit variant\",\n-            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), _) => \"struct variant\",\n-            Def::Def(DefKind::Struct, _) => \"struct\",\n-            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _) => \"tuple struct\",\n-            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Const), _) => \"unit struct\",\n-            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive), _) =>\n-                bug!(\"impossible struct constructor\"),\n-            Def::Def(DefKind::Existential, _) => \"existential type\",\n-            Def::Def(DefKind::TyAlias, _) => \"type alias\",\n-            Def::Def(DefKind::TraitAlias, _) => \"trait alias\",\n-            Def::Def(DefKind::AssociatedTy, _) => \"associated type\",\n-            Def::Def(DefKind::AssociatedExistential, _) => \"associated existential type\",\n+            Def::Def(kind, _) => kind.descr(),\n             Def::SelfCtor(..) => \"self constructor\",\n-            Def::Def(DefKind::Union, _) => \"union\",\n-            Def::Def(DefKind::Trait, _) => \"trait\",\n-            Def::Def(DefKind::ForeignTy, _) => \"foreign type\",\n-            Def::Def(DefKind::Method, _) => \"method\",\n-            Def::Def(DefKind::Const, _) => \"constant\",\n-            Def::Def(DefKind::AssociatedConst, _) => \"associated constant\",\n-            Def::Def(DefKind::TyParam, _) => \"type parameter\",\n-            Def::Def(DefKind::ConstParam, _) => \"const parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\",\n             Def::Upvar(..) => \"closure capture\",\n             Def::Label(..) => \"label\",\n             Def::SelfTy(..) => \"self type\",\n-            Def::Def(DefKind::Macro(macro_kind), _) => macro_kind.descr(),\n             Def::ToolMod => \"tool module\",\n             Def::NonMacroAttr(attr_kind) => attr_kind.descr(),\n             Def::Err => \"unresolved item\",\n@@ -370,13 +391,8 @@ impl<Id> Def<Id> {\n     /// An English article for the def.\n     pub fn article(&self) -> &'static str {\n         match *self {\n-            Def::Def(DefKind::AssociatedTy, _)\n-            | Def::Def(DefKind::AssociatedConst, _)\n-            | Def::Def(DefKind::AssociatedExistential, _)\n-            | Def::Def(DefKind::Enum, _)\n-            | Def::Def(DefKind::Existential, _)\n-            | Def::Err => \"an\",\n-            Def::Def(DefKind::Macro(macro_kind), _) => macro_kind.article(),\n+            Def::Def(kind, _) => kind.article(),\n+            Def::Err => \"an\",\n             _ => \"a\",\n         }\n     }"}, {"sha": "9c895198ddde993d4b48462cdc03531d9023cd66", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -17,7 +17,7 @@ use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::hir::*;\n-use crate::hir::{Def, DefKind};\n+use crate::hir::DefKind;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir::print::Nested;\n use crate::util::nodemap::FxHashMap;\n@@ -310,14 +310,14 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n     }\n \n-    pub fn describe_def(&self, node_id: NodeId) -> Option<Def> {\n+    fn def_kind(&self, node_id: NodeId) -> Option<DefKind> {\n         let node = if let Some(node) = self.find(node_id) {\n             node\n         } else {\n             return None\n         };\n \n-        let kind = match node {\n+        Some(match node {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Static(..) => DefKind::Static,\n@@ -382,15 +382,11 @@ impl<'hir> Map<'hir> {\n             Node::TraitRef(_) |\n             Node::Pat(_) |\n             Node::Binding(_) |\n+            Node::Local(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n             Node::Crate => return None,\n-            // FIXME(eddyb) this is the only non-`DefKind` case here,\n-            // investigate whether it's actually used, and ideally remove it.\n-            Node::Local(local) => {\n-                return Some(Def::Local(local.hir_id));\n-            }\n             Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             Node::GenericParam(param) => {\n                 match param.kind {\n@@ -399,14 +395,7 @@ impl<'hir> Map<'hir> {\n                     GenericParamKind::Const { .. } => DefKind::ConstParam,\n                 }\n             }\n-        };\n-        Some(Def::Def(kind, self.local_def_id(node_id)))\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn describe_def_by_hir_id(&self, hir_id: HirId) -> Option<Def> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.describe_def(node_id)\n+        })\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -1464,11 +1453,11 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     node_id_to_string(map, node_id, include_id)\n }\n \n-pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n+pub fn def_kind(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefKind> {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        tcx.hir().describe_def(node_id)\n+        tcx.hir().def_kind(node_id)\n     } else {\n-        bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n+        bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n              def_id)\n     }\n }"}, {"sha": "833983d3576f5b4dee6b03578335fb62ae3669bf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -2521,7 +2521,7 @@ pub type GlobMap = NodeMap<FxHashSet<Name>>;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n-    providers.describe_def = map::describe_def;\n+    providers.def_kind = map::def_kind;\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "a68be387d61091603e434a10059208c7bfc55c83", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -98,6 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             hir::ExprKind::MethodCall(..) => {\n                 self.tables.type_dependent_def(expr.hir_id)\n+                    .map(|(kind, def_id)| Def::Def(kind, def_id))\n             }\n             _ => None\n         };"}, {"sha": "c57b62f42d56558a0545b20580de672b1b0507c6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -525,10 +525,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n-        match self.describe_def(def_id) {\n-            Some(Def::Def(DefKind::Method, _)) |\n-            Some(Def::Def(DefKind::AssociatedTy, _)) |\n-            Some(Def::Def(DefKind::AssociatedConst, _)) => {\n+        match self.def_kind(def_id) {\n+            Some(DefKind::Method) |\n+            Some(DefKind::AssociatedTy) |\n+            Some(DefKind::AssociatedConst) => {\n                 if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n                     // Trait methods do not declare visibility (even\n                     // for visibility info in cstore). Use containing"}, {"sha": "e1e115cfe177b6539dc9db6edf551e67a935545c", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -469,7 +469,7 @@ rustc_queries! {\n             cache { true }\n         }\n \n-        query describe_def(_: DefId) -> Option<Def> {}\n+        query def_kind(_: DefId) -> Option<DefKind> {}\n         query def_span(_: DefId) -> Span {\n             // FIXME(mw): DefSpans are not really inputs since they are derived from\n             // HIR. But at the moment HIR hashing still contains some hacks that allow"}, {"sha": "dfc9e8140bbb4d1dd1df28f5ec78cc251d65c503", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -44,6 +44,7 @@ use crate::ty::steal::Steal;\n use crate::ty::subst::{UserSubsts, UnpackedKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n+use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n@@ -347,7 +348,7 @@ pub struct TypeckTables<'tcx> {\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    type_dependent_defs: ItemLocalMap<Def>,\n+    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorReported>>,\n \n     /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n     /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n@@ -481,30 +482,32 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn qpath_def(&self, qpath: &hir::QPath, id: hir::HirId) -> Def {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n-            hir::QPath::TypeRelative(..) => {\n-                validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-                self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n-            }\n+            hir::QPath::TypeRelative(..) => self.type_dependent_def(id)\n+                .map_or(Def::Err, |(kind, def_id)| Def::Def(kind, def_id)),\n         }\n     }\n \n-    pub fn type_dependent_defs(&self) -> LocalTableInContext<'_, Def> {\n+    pub fn type_dependent_defs(\n+        &self,\n+    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorReported>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n             data: &self.type_dependent_defs\n         }\n     }\n \n-    pub fn type_dependent_def(&self, id: HirId) -> Option<Def> {\n+    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n         validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.type_dependent_defs.get(&id.local_id).cloned()\n+        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n     pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n-        self.type_dependent_def(id).map(|def| def.def_id())\n+        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n     }\n \n-    pub fn type_dependent_defs_mut(&mut self) -> LocalTableInContextMut<'_, Def> {\n+    pub fn type_dependent_defs_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorReported>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.type_dependent_defs\n@@ -658,7 +661,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n \n         match self.type_dependent_defs().get(expr.hir_id) {\n-            Some(&Def::Def(DefKind::Method, _)) => true,\n+            Some(Ok((DefKind::Method, _))) => true,\n             _ => false\n         }\n     }"}, {"sha": "3d08dc6700560df86be1ad20ab57ccf33b2909f7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -191,12 +191,12 @@ pub enum AssociatedKind {\n }\n \n impl AssociatedItem {\n-    pub fn def(&self) -> Def {\n+    pub fn def_kind(&self) -> DefKind {\n         match self.kind {\n-            AssociatedKind::Const => Def::Def(DefKind::AssociatedConst, self.def_id),\n-            AssociatedKind::Method => Def::Def(DefKind::Method, self.def_id),\n-            AssociatedKind::Type => Def::Def(DefKind::AssociatedTy, self.def_id),\n-            AssociatedKind::Existential => Def::Def(DefKind::AssociatedExistential, self.def_id),\n+            AssociatedKind::Const => DefKind::AssociatedConst,\n+            AssociatedKind::Method => DefKind::Method,\n+            AssociatedKind::Type => DefKind::AssociatedTy,\n+            AssociatedKind::Existential => DefKind::AssociatedExistential,\n         }\n     }\n \n@@ -2805,10 +2805,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 _ => false,\n             }\n         } else {\n-            match self.describe_def(def_id).expect(\"no def for def-id\") {\n-                Def::Def(DefKind::AssociatedConst, _)\n-                | Def::Def(DefKind::Method, _)\n-                | Def::Def(DefKind::AssociatedTy, _) => true,\n+            match self.def_kind(def_id).expect(\"no def for def-id\") {\n+                DefKind::AssociatedConst\n+                | DefKind::Method\n+                | DefKind::AssociatedTy => true,\n                 _ => false,\n             }\n         };\n@@ -3046,7 +3046,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n-            if let Some(Def::Def(DefKind::Method, _)) = self.describe_def(def_id) {\n+            if let Some(DefKind::Method) = self.def_kind(def_id) {\n                 Some(self.associated_item(def_id))\n             } else {\n                 None"}, {"sha": "18d575f73645c6f4d2427688b855fffd4185bcbf", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph::{self, DepNode};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n-use crate::hir::def::{Def, Export};\n+use crate::hir::def::{DefKind, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use crate::infer::canonical::{self, Canonical};\n use crate::lint;"}, {"sha": "5155ac410aabdd0d6c4e65f3d3c7c0b1a6e7c7bd", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -87,13 +87,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        let maybe_def = match expr.node {\n+        let maybe_def_id = match expr.node {\n             hir::ExprKind::Call(ref callee, _) => {\n                 match callee.node {\n                     hir::ExprKind::Path(ref qpath) => {\n                         let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                         match def {\n-                            Def::Def(DefKind::Fn, _) | Def::Def(DefKind::Method, _) => Some(def),\n+                            Def::Def(DefKind::Fn, def_id)\n+                            | Def::Def(DefKind::Method, def_id) => Some(def_id),\n                             // `Def::Local` if it was a closure, for which we\n                             // do not currently support must-use linting\n                             _ => None\n@@ -103,12 +104,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 }\n             },\n             hir::ExprKind::MethodCall(..) => {\n-                cx.tables.type_dependent_def(expr.hir_id)\n+                cx.tables.type_dependent_def_id(expr.hir_id)\n             },\n             _ => None\n         };\n-        if let Some(def) = maybe_def {\n-            let def_id = def.def_id();\n+        if let Some(def_id) = maybe_def_id {\n             fn_warned = check_must_use(cx, def_id, s.span, \"return value of \", \"\");\n         } else if type_permits_lack_of_use {\n             // We don't warn about unused unit or uninhabited types."}, {"sha": "892a7a8355cb0f424aa58a58510c11c65d73ec35", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -138,7 +138,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n-    describe_def => { cdata.get_def(def_id.index) }\n+    def_kind => { cdata.def_kind(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n     lookup_stability => {\n         cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))"}, {"sha": "5e71a74c9bbb3b50402aa386de3c73e0aa93daf8", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -399,32 +399,32 @@ impl<'a, 'tcx> MetadataBlob {\n }\n \n impl<'tcx> EntryKind<'tcx> {\n-    fn to_def(&self, did: DefId) -> Option<Def> {\n+    fn def_kind(&self) -> Option<DefKind> {\n         Some(match *self {\n-            EntryKind::Const(..) => Def::Def(DefKind::Const, did),\n-            EntryKind::AssociatedConst(..) => Def::Def(DefKind::AssociatedConst, did),\n+            EntryKind::Const(..) => DefKind::Const,\n+            EntryKind::AssociatedConst(..) => DefKind::AssociatedConst,\n             EntryKind::ImmStatic |\n             EntryKind::MutStatic |\n             EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic => Def::Def(DefKind::Static, did),\n-            EntryKind::Struct(_, _) => Def::Def(DefKind::Struct, did),\n-            EntryKind::Union(_, _) => Def::Def(DefKind::Union, did),\n+            EntryKind::ForeignMutStatic => DefKind::Static,\n+            EntryKind::Struct(_, _) => DefKind::Struct,\n+            EntryKind::Union(_, _) => DefKind::Union,\n             EntryKind::Fn(_) |\n-            EntryKind::ForeignFn(_) => Def::Def(DefKind::Fn, did),\n-            EntryKind::Method(_) => Def::Def(DefKind::Method, did),\n-            EntryKind::Type => Def::Def(DefKind::TyAlias, did),\n-            EntryKind::TypeParam => Def::Def(DefKind::TyParam, did),\n-            EntryKind::ConstParam => Def::Def(DefKind::ConstParam, did),\n-            EntryKind::Existential => Def::Def(DefKind::Existential, did),\n-            EntryKind::AssociatedType(_) => Def::Def(DefKind::AssociatedTy, did),\n-            EntryKind::AssociatedExistential(_) => Def::Def(DefKind::AssociatedExistential, did),\n-            EntryKind::Mod(_) => Def::Def(DefKind::Mod, did),\n-            EntryKind::Variant(_) => Def::Def(DefKind::Variant, did),\n-            EntryKind::Trait(_) => Def::Def(DefKind::Trait, did),\n-            EntryKind::TraitAlias(_) => Def::Def(DefKind::TraitAlias, did),\n-            EntryKind::Enum(..) => Def::Def(DefKind::Enum, did),\n-            EntryKind::MacroDef(_) => Def::Def(DefKind::Macro(MacroKind::Bang), did),\n-            EntryKind::ForeignType => Def::Def(DefKind::ForeignTy, did),\n+            EntryKind::ForeignFn(_) => DefKind::Fn,\n+            EntryKind::Method(_) => DefKind::Method,\n+            EntryKind::Type => DefKind::TyAlias,\n+            EntryKind::TypeParam => DefKind::TyParam,\n+            EntryKind::ConstParam => DefKind::ConstParam,\n+            EntryKind::Existential => DefKind::Existential,\n+            EntryKind::AssociatedType(_) => DefKind::AssociatedTy,\n+            EntryKind::AssociatedExistential(_) => DefKind::AssociatedExistential,\n+            EntryKind::Mod(_) => DefKind::Mod,\n+            EntryKind::Variant(_) => DefKind::Variant,\n+            EntryKind::Trait(_) => DefKind::Trait,\n+            EntryKind::TraitAlias(_) => DefKind::TraitAlias,\n+            EntryKind::Enum(..) => DefKind::Enum,\n+            EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n+            EntryKind::ForeignType => DefKind::ForeignTy,\n \n             EntryKind::ForeignMod |\n             EntryKind::GlobalAsm |\n@@ -507,12 +507,12 @@ impl<'a, 'tcx> CrateMetadata {\n             .expect(\"no name in item_name\")\n     }\n \n-    pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n+    pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n-            self.entry(index).kind.to_def(self.local_def_id(index))\n+            self.entry(index).kind.def_kind()\n         } else {\n             let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(Def::Def(DefKind::Macro(kind), self.local_def_id(index)))\n+            Some(DefKind::Macro(kind))\n         }\n     }\n \n@@ -745,10 +745,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let def = Def::Def(\n                         DefKind::Macro(ext.kind()),\n-                        DefId {\n-                            krate: self.cnum,\n-                            index: DefIndex::from_proc_macro_index(id),\n-                        },\n+                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);\n                     callback(def::Export {\n@@ -789,9 +786,9 @@ impl<'a, 'tcx> CrateMetadata {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n                         for child_index in child.children.decode((self, sess)) {\n-                            if let Some(def) = self.get_def(child_index) {\n+                            if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n-                                    def,\n+                                    def: Def::Def(kind, self.local_def_id(child_index)),\n                                     ident: Ident::from_interned_str(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n@@ -807,15 +804,17 @@ impl<'a, 'tcx> CrateMetadata {\n \n                 let def_key = self.def_key(child_index);\n                 let span = child.span.decode((self, sess));\n-                if let (Some(def), Some(name)) =\n-                    (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n+                if let (Some(kind), Some(name)) =\n+                    (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n                     let vis = self.get_visibility(child_index);\n+                    let def_id = self.local_def_id(child_index);\n+                    let def = Def::Def(kind, def_id);\n                     callback(def::Export { def, ident, vis, span });\n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n-                    match def {\n-                        Def::Def(DefKind::Struct, _) => {\n+                    match kind {\n+                        DefKind::Struct => {\n                             if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n                                 let ctor_def = Def::Def(\n@@ -826,7 +825,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 callback(def::Export { def: ctor_def, vis, ident, span });\n                             }\n                         }\n-                        Def::Def(DefKind::Variant, def_id) => {\n+                        DefKind::Variant => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             // It's ok to use the variant's id as a ctor id since an\n@@ -845,7 +844,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n                                 if attr::contains_name(&attrs, \"non_exhaustive\") {\n-                                    let crate_def_id = DefId { index: CRATE_DEF_INDEX, ..def_id };\n+                                    let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }\n                             }"}, {"sha": "866b6492d10bcbfa85cc85f6fe6f3405c11d0988", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -6,7 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n \n-use rustc::hir::def::{Def, DefKind};\n+use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n@@ -634,14 +634,14 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n             }\n         } else if def_id.is_local() {\n             // constant defined in this crate, we can figure out a lint level!\n-            match tcx.describe_def(def_id) {\n+            match tcx.def_kind(def_id) {\n                 // constants never produce a hard error at the definition site. Anything else is\n                 // a backwards compatibility hazard (and will break old versions of winapi for sure)\n                 //\n                 // note that validation may still cause a hard error on this very same constant,\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n-                Some(Def::Def(DefKind::Const, _)) | Some(Def::Def(DefKind::AssociatedConst, _)) => {\n+                Some(DefKind::Const) | Some(DefKind::AssociatedConst) => {\n                     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),"}, {"sha": "51bb41343411085da25d7267b66cc64ab9fc2bf4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -830,13 +830,13 @@ fn method_callee<'a, 'gcx, 'tcx>(\n     let (def_id, substs, user_ty) = match overloaded_callee {\n         Some((def_id, substs)) => (def_id, substs, None),\n         None => {\n-            let def = cx.tables().type_dependent_def(expr.hir_id)\n+            let (kind, def_id) = cx.tables().type_dependent_def(expr.hir_id)\n                 .unwrap_or_else(|| {\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n-            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &Def::Def(kind, def_id));\n             debug!(\"method_callee: user_ty={:?}\", user_ty);\n-            (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n+            (def_id, cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n     let ty = cx.tcx().mk_fn_def(def_id, substs);"}, {"sha": "ad4bc6a91f5a179d9aba993ca1171c45853c0d41", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n \n use syntax::source_map::{self, Span, DUMMY_SP};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::def::{Def, DefKind};\n+use rustc::hir::def::DefKind;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -501,11 +501,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n             // entry in `locals` should never be used. Make it dead, to be sure.\n             locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n-            match self.tcx.describe_def(instance.def_id()) {\n+            match self.tcx.def_kind(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n-                Some(Def::Def(DefKind::Static, _))\n-                | Some(Def::Def(DefKind::Const, _))\n-                | Some(Def::Def(DefKind::AssociatedConst, _)) => {},\n+                Some(DefKind::Static)\n+                | Some(DefKind::Const)\n+                | Some(DefKind::AssociatedConst) => {},\n                 _ => {\n                     trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n                     for block in mir.basic_blocks() {"}, {"sha": "72af02782010679c81cfa69e822e967c049515bb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1,7 +1,7 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use rustc::hir::def::{Def, DefKind};\n+use rustc::hir::def::DefKind;\n use rustc::mir::{\n     Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n     NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n@@ -42,8 +42,8 @@ impl MirPass for ConstProp {\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)).is_some();\n-        let is_assoc_const = match tcx.describe_def(source.def_id()) {\n-            Some(Def::Def(DefKind::AssociatedConst, _)) => true,\n+        let is_assoc_const = match tcx.def_kind(source.def_id()) {\n+            Some(DefKind::AssociatedConst) => true,\n             _ => false,\n         };\n "}, {"sha": "94259fa523ccdf018bb7667074abfec1953a8978", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -575,25 +575,25 @@ fn write_mir_sig(\n     mir: &Mir<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    use rustc::hir::def::{Def, DefKind};\n+    use rustc::hir::def::DefKind;\n \n     trace!(\"write_mir_sig: {:?}\", src.instance);\n-    let descr = tcx.describe_def(src.def_id());\n-    let is_function = match descr {\n-        Some(Def::Def(DefKind::Fn, _))\n-        | Some(Def::Def(DefKind::Method, _))\n-        | Some(Def::Def(DefKind::Ctor(..), _)) => true,\n+    let kind = tcx.def_kind(src.def_id());\n+    let is_function = match kind {\n+        Some(DefKind::Fn)\n+        | Some(DefKind::Method)\n+        | Some(DefKind::Ctor(..)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n-    match (descr, src.promoted) {\n+    match (kind, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(Def::Def(DefKind::Const, _)), _)\n-        | (Some(Def::Def(DefKind::AssociatedConst, _)), _) => write!(w, \"const \")?,\n-        (Some(Def::Def(DefKind::Static, _)), _) =>\n+        (Some(DefKind::Const), _)\n+        | (Some(DefKind::AssociatedConst), _) => write!(w, \"const \")?,\n+        (Some(DefKind::Static), _) =>\n             write!(w, \"static {}\", if tcx.is_mutable_static(src.def_id()) { \"mut \" } else { \"\" })?,\n         (_, _) if is_function => write!(w, \"fn \")?,\n         (None, _) => {}, // things like anon const, not an item\n-        _ => bug!(\"Unexpected def description {:?}\", descr),\n+        _ => bug!(\"Unexpected def kind {:?}\", kind),\n     }\n \n     ty::print::with_forced_impl_filename_line(|| {"}, {"sha": "a7e59e8368f0e8f456cfef2a64f53474e87f94b8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1105,28 +1105,30 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: hir::HirId, span: Span) {\n-        let def = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => match path.def {\n-                Def::Def(DefKind::Method, _) | Def::Def(DefKind::AssociatedConst, _) |\n-                Def::Def(DefKind::AssociatedTy, _) | Def::Def(DefKind::AssociatedExistential, _) |\n-                Def::Def(DefKind::Static, _) => Some(path.def),\n-                _ => None,\n-            }\n-            hir::QPath::TypeRelative(..) => {\n-                self.tables.type_dependent_def(id)\n-            }\n+        let def = match self.tables.qpath_def(qpath, id) {\n+            Def::Def(kind, def_id) => Some((kind, def_id)),\n+            _ => None,\n         };\n-        if let Some(def) = def {\n-            let def_id = def.def_id();\n-            let is_local_static = if let Def::Def(DefKind::Static, _) = def {\n+        let def = def.filter(|(kind, _)| {\n+            match kind {\n+                DefKind::Method\n+                | DefKind::AssociatedConst\n+                | DefKind::AssociatedTy\n+                | DefKind::AssociatedExistential\n+                | DefKind::Static => true,\n+                _ => false,\n+            }\n+        });\n+        if let Some((kind, def_id)) = def {\n+            let is_local_static = if let DefKind::Static = kind {\n                 def_id.is_local()\n             } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n                 let name = match *qpath {\n                     hir::QPath::Resolved(_, ref path) => path.to_string(),\n                     hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n                 };\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), name);\n+                let msg = format!(\"{} `{}` is private\", kind.descr(), name);\n                 self.tcx.sess.span_err(span, &msg);\n                 return;\n             }"}, {"sha": "3be4ff77375ec7319e401883581f38e015a7e3d1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -193,7 +193,7 @@ impl<'a> Resolver<'a> {\n                     if source.ident.name == keywords::DollarCrate.name() && module_path.is_empty() {\n                         let crate_root = self.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n-                            ModuleKind::Def(_, name) => name,\n+                            ModuleKind::Def(.., name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n@@ -424,7 +424,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Mod(..) => {\n                 let def_id = self.definitions.local_def_id(item.id);\n-                let module_kind = ModuleKind::Def(Def::Def(DefKind::Mod, def_id), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -487,8 +487,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let def = Def::Def(DefKind::Enum, self.definitions.local_def_id(item.id));\n-                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module_kind = ModuleKind::Def(\n+                    DefKind::Enum,\n+                    self.definitions.local_def_id(item.id),\n+                    ident.name,\n+                );\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -565,7 +568,7 @@ impl<'a> Resolver<'a> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let module_kind = ModuleKind::Def(Def::Def(DefKind::Trait, def_id), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -658,9 +661,10 @@ impl<'a> Resolver<'a> {\n         let ident = ident.gensym_if_underscore();\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n-            Def::Def(DefKind::Mod, def_id) | Def::Def(DefKind::Enum, def_id) => {\n+            Def::Def(kind @ DefKind::Mod, def_id)\n+            | Def::Def(kind @ DefKind::Enum, def_id) => {\n                 let module = self.new_module(parent,\n-                                             ModuleKind::Def(def, ident.name),\n+                                             ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n@@ -691,7 +695,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             Def::Def(DefKind::Trait, def_id) => {\n-                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -746,7 +750,7 @@ impl<'a> Resolver<'a> {\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Def(DefKind::Mod, def_id), name.as_symbol());\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);"}, {"sha": "0329c78bdf664d690677200a46f0ddbc052df578", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -56,9 +56,9 @@ impl<'a> Resolver<'a> {\n                     mod_path, Some(TypeNS), false, span, CrateLint::No\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def(),\n+                        module.def_kind(),\n                     _ => None,\n-                }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n+                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n                 (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n             };\n             (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n@@ -387,9 +387,9 @@ impl<'a> Resolver<'a> {\n                     return false;\n                 }\n             }\n-            (Def::Def(DefKind::Enum, _), PathSource::TupleStruct)\n-                | (Def::Def(DefKind::Enum, _), PathSource::Expr(..))  => {\n-                if let Some(variants) = self.collect_enum_variants(def) {\n+            (Def::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n+                | (Def::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def_id) {\n                     if !variants.is_empty() {\n                         let msg = if variants.len() == 1 {\n                             \"try using the enum's variant\""}, {"sha": "ad8233fd5543c952870c73c00ef35817f0d58b5e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1133,7 +1133,7 @@ impl ModuleOrUniformRoot<'_> {\n     fn same_def(lhs: Self, rhs: Self) -> bool {\n         match (lhs, rhs) {\n             (ModuleOrUniformRoot::Module(lhs),\n-             ModuleOrUniformRoot::Module(rhs)) => lhs.def() == rhs.def(),\n+             ModuleOrUniformRoot::Module(rhs)) => lhs.def_id() == rhs.def_id(),\n             (ModuleOrUniformRoot::CrateRootAndExternPrelude,\n              ModuleOrUniformRoot::CrateRootAndExternPrelude) |\n             (ModuleOrUniformRoot::ExternPrelude, ModuleOrUniformRoot::ExternPrelude) |\n@@ -1177,15 +1177,15 @@ enum ModuleKind {\n     /// * A normal module \u2012 either `mod from_file;` or `mod from_block { }`.\n     /// * A trait or an enum (it implicitly contains associated types, methods and variant\n     ///   constructors).\n-    Def(Def, Name),\n+    Def(DefKind, DefId, Name),\n }\n \n impl ModuleKind {\n     /// Get name of the module.\n     pub fn name(&self) -> Option<Name> {\n         match self {\n             ModuleKind::Block(..) => None,\n-            ModuleKind::Def(_, name) => Some(*name),\n+            ModuleKind::Def(.., name) => Some(*name),\n         }\n     }\n }\n@@ -1271,26 +1271,36 @@ impl<'a> ModuleData<'a> {\n \n     fn def(&self) -> Option<Def> {\n         match self.kind {\n-            ModuleKind::Def(def, _) => Some(def),\n+            ModuleKind::Def(kind, def_id, _) => Some(Def::Def(kind, def_id)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn def_kind(&self) -> Option<DefKind> {\n+        match self.kind {\n+            ModuleKind::Def(kind, ..) => Some(kind),\n             _ => None,\n         }\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n-        self.def().as_ref().map(Def::def_id)\n+        match self.kind {\n+            ModuleKind::Def(_, def_id, _) => Some(def_id),\n+            _ => None,\n+        }\n     }\n \n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Def(DefKind::Mod, _), _) => true,\n+            ModuleKind::Def(DefKind::Mod, _, _) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Def(DefKind::Trait, _), _) => true,\n+            ModuleKind::Def(DefKind::Trait, _, _) => true,\n             _ => false,\n         }\n     }\n@@ -1477,7 +1487,7 @@ impl<'a> NameBinding<'a> {\n                 }, ..\n             } => true,\n             NameBindingKind::Module(\n-                &ModuleData { kind: ModuleKind::Def(Def::Def(DefKind::Mod, def_id), _), .. }\n+                &ModuleData { kind: ModuleKind::Def(DefKind::Mod, def_id, _), .. }\n             ) => def_id.index == CRATE_DEF_INDEX,\n             _ => false,\n         }\n@@ -1938,7 +1948,8 @@ impl<'a> Resolver<'a> {\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let root_module_kind = ModuleKind::Def(\n-            Def::Def(DefKind::Mod, root_def_id),\n+            DefKind::Mod,\n+            root_def_id,\n             keywords::Invalid.name(),\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n@@ -4788,10 +4799,7 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    fn find_module(&mut self,\n-                   module_def: Def)\n-                   -> Option<(Module<'a>, ImportSuggestion)>\n-    {\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n         let mut result = None;\n         let mut seen_modules = FxHashSet::default();\n         let mut worklist = vec![(self.graph_root, Vec::new())];\n@@ -4811,16 +4819,16 @@ impl<'a> Resolver<'a> {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n                     path_segments.push(ast::PathSegment::from_ident(ident));\n-                    if module.def() == Some(module_def) {\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n                         let path = Path {\n                             span: name_binding.span,\n                             segments: path_segments,\n                         };\n-                        let did = module.def().and_then(|def| def.opt_def_id());\n-                        result = Some((module, ImportSuggestion { did, path }));\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n                     } else {\n                         // add the module to the lookup\n-                        if seen_modules.insert(module.def_id().unwrap()) {\n+                        if seen_modules.insert(module_def_id) {\n                             worklist.push((module, path_segments));\n                         }\n                     }\n@@ -4831,12 +4839,8 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn collect_enum_variants(&mut self, enum_def: Def) -> Option<Vec<Path>> {\n-        if let Def::Def(DefKind::Enum, _) = enum_def {} else {\n-            panic!(\"Non-enum def passed to collect_enum_variants: {:?}\", enum_def)\n-        }\n-\n-        self.find_module(enum_def).map(|(enum_module, enum_import_suggestion)| {\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n             self.populate_module_if_necessary(enum_module);\n \n             let mut variants = Vec::new();\n@@ -5089,8 +5093,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let container = match parent.kind {\n-            ModuleKind::Def(Def::Def(DefKind::Mod, _), _) => \"module\",\n-            ModuleKind::Def(Def::Def(DefKind::Trait, _), _) => \"trait\",\n+            ModuleKind::Def(DefKind::Mod, _, _) => \"module\",\n+            ModuleKind::Def(DefKind::Trait, _, _) => \"trait\",\n             ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };\n@@ -5458,7 +5462,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();\n \n     fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n-        if let ModuleKind::Def(_, name) = module.kind {\n+        if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n                 names.push(Ident::with_empty_ctxt(name));\n                 collect_mod(names, parent);"}, {"sha": "3df09369f89b5effe3c8da623d5ff723a71fc826", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -140,7 +140,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             fn visit_ident(&mut self, ident: Ident) {\n                 if ident.name == keywords::DollarCrate.name() {\n                     let name = match self.resolver.resolve_crate_root(ident).kind {\n-                        ModuleKind::Def(_, name) if name != keywords::Invalid.name() => name,\n+                        ModuleKind::Def(.., name) if name != keywords::Invalid.name() => name,\n                         _ => keywords::Crate.name(),\n                     };\n                     ident.span.ctxt().set_dollar_crate_name(name);"}, {"sha": "7dbc75364401cf94d1385b1e3e6313a300e38ff7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1264,7 +1264,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Skip if we are inside a named module (in contrast to an anonymous\n         // module defined by a block).\n-        if let ModuleKind::Def(_, _) = directive.parent_scope.module.kind {\n+        if let ModuleKind::Def(..) = directive.parent_scope.module.kind {\n             return;\n         }\n "}, {"sha": "241d77c257535b59a1809b7973d8caa66e11e2d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1314,7 +1314,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         qself_def: Def,\n         assoc_segment: &hir::PathSegment,\n         permit_variants: bool,\n-    ) -> (Ty<'tcx>, Def) {\n+    ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorReported> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n \n@@ -1330,13 +1330,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let def = Def::Def(DefKind::Variant, variant_def.def_id);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n-                        return (qself_ty, def);\n+                        return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n-                        variant_resolution = Some(def);\n+                        variant_resolution = Some(variant_def.def_id);\n                     }\n                 }\n             }\n@@ -1352,24 +1351,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     Some(trait_ref) => trait_ref,\n                     None => {\n                         // A cycle error occurred, most likely.\n-                        return (tcx.types.err, Def::Err);\n+                        return Err(ErrorReported);\n                     }\n                 };\n \n                 let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_ident));\n \n-                match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span) {\n-                    Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n-                }\n+                self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span)?\n             }\n             (&ty::Param(_), Def::SelfTy(Some(param_did), None)) |\n             (&ty::Param(_), Def::Def(DefKind::TyParam, param_did)) => {\n-                match self.find_bound_for_assoc_item(param_did, assoc_ident, span) {\n-                    Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n-                }\n+                self.find_bound_for_assoc_item(param_did, assoc_ident, span)?\n             }\n             _ => {\n                 if variant_resolution.is_some() {\n@@ -1413,7 +1406,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                         &assoc_ident.as_str(),\n                     );\n                 }\n-                return (tcx.types.err, Def::Err);\n+                return Err(ErrorReported);\n             }\n         };\n \n@@ -1427,28 +1420,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n \n-        let def = Def::Def(DefKind::AssociatedTy, item.def_id);\n+        let kind = DefKind::AssociatedTy;\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n-            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n+            let msg = format!(\"{} `{}` is private\", kind.descr(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n         }\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n-        if let Some(variant_def) = variant_resolution {\n+        if let Some(variant_def_id) = variant_resolution {\n             let mut err = tcx.struct_span_lint_hir(\n                 AMBIGUOUS_ASSOCIATED_ITEMS,\n                 hir_ref_id,\n                 span,\n                 \"ambiguous associated item\",\n             );\n \n-            let mut could_refer_to = |def: Def, also| {\n+            let mut could_refer_to = |kind: DefKind, def_id, also| {\n                 let note_msg = format!(\"`{}` could{} refer to {} defined here\",\n-                                       assoc_ident, also, def.kind_name());\n-                err.span_note(tcx.def_span(def.def_id()), &note_msg);\n+                                       assoc_ident, also, kind.descr());\n+                err.span_note(tcx.def_span(def_id), &note_msg);\n             };\n-            could_refer_to(variant_def, \"\");\n-            could_refer_to(def, \" also\");\n+            could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+            could_refer_to(kind, item.def_id, \" also\");\n \n             err.span_suggestion(\n                 span,\n@@ -1458,7 +1451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             ).emit();\n         }\n \n-        (ty, def)\n+        Ok((ty, kind, item.def_id))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1554,11 +1547,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n-    pub fn def_ids_for_path_segments(&self,\n-                                     segments: &[hir::PathSegment],\n-                                     self_ty: Option<Ty<'tcx>>,\n-                                     def: Def)\n-                                     -> Vec<PathSeg> {\n+    // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n+    pub fn def_ids_for_value_path_segments(\n+        &self,\n+        segments: &[hir::PathSegment],\n+        self_ty: Option<Ty<'tcx>>,\n+        kind: DefKind,\n+        def_id: DefId,\n+    ) -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n         // tricky-process; the problem is that resolve only tells us the\n@@ -1602,10 +1598,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n         //    final segment, `foo::<B>` contains parameters in fn space.\n         //\n-        // 5. Reference to a local variable\n-        //\n-        //    Local variables can't have any type parameters.\n-        //\n         // The first step then is to categorize the segments appropriately.\n \n         let tcx = self.tcx();\n@@ -1615,10 +1607,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         let mut path_segs = vec![];\n \n-        match def {\n+        match kind {\n             // Case 1. Reference to a struct constructor.\n-            Def::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) |\n-            Def::SelfCtor(.., def_id) => {\n+            DefKind::Ctor(CtorOf::Struct, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n                 let generics = tcx.generics_of(def_id);\n@@ -1629,8 +1620,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 2. Reference to a variant constructor.\n-            Def::Def(DefKind::Ctor(CtorOf::Variant, ..), def_id)\n-            | Def::Def(DefKind::Variant, def_id) => {\n+            DefKind::Ctor(CtorOf::Variant, ..)\n+            | DefKind::Variant => {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n@@ -1641,11 +1632,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     let mut def_id = def_id;\n \n                     // `DefKind::Ctor` -> `DefKind::Variant`\n-                    if let Def::Def(DefKind::Ctor(..), _) = def {\n+                    if let DefKind::Ctor(..) = kind {\n                         def_id = tcx.parent(def_id).unwrap()\n                     }\n \n-                    // `DefKind::Variant` -> `DefKind::Item` (enum)\n+                    // `DefKind::Variant` -> `DefKind::Enum`\n                     let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {\n@@ -1663,27 +1654,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 3. Reference to a top-level value.\n-            Def::Def(DefKind::Fn, def_id) |\n-            Def::Def(DefKind::Const, def_id) |\n-            Def::Def(DefKind::ConstParam, def_id) |\n-            Def::Def(DefKind::Static, def_id) => {\n+            DefKind::Fn\n+            | DefKind::Const\n+            | DefKind::ConstParam\n+            | DefKind::Static => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n             // Case 4. Reference to a method or associated const.\n-            Def::Def(DefKind::Method, def_id) |\n-            Def::Def(DefKind::AssociatedConst, def_id) => {\n+            DefKind::Method\n+            | DefKind::AssociatedConst => {\n                 if segments.len() >= 2 {\n                     let generics = tcx.generics_of(def_id);\n                     path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n                 }\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n-            // Case 5. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n+            kind => bug!(\"unexpected definition kind {:?} for {:?}\", kind, def_id),\n         }\n \n         debug!(\"path_segs = {:?}\", path_segs);\n@@ -1724,12 +1712,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n-            Def::Def(DefKind::Variant, _) if permit_variants => {\n+            Def::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n \n-                let path_segs = self.def_ids_for_path_segments(&path.segments, None, path.def);\n+                let path_segs =\n+                    self.def_ids_for_value_path_segments(&path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics(path.segments.iter().enumerate().filter_map(|(index, seg)| {\n@@ -1854,7 +1843,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     Def::Err\n                 };\n-                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false)\n+                    .map(|(ty, _, _)| ty).unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length = self.ast_const_to_const(length, tcx.types.usize);"}, {"sha": "6fe7abda16de586b658f477cee95f430187e2fea", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -5,7 +5,6 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::def::{Def, DefKind};\n use rustc::hir::Node;\n use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n@@ -206,9 +205,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // This function checks if the method isn't static and takes other arguments than `self`.\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n-        match method.def() {\n-            Def::Def(DefKind::Method, def_id) => {\n-                self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n+        match method.kind {\n+            ty::AssociatedKind::Method => {\n+                self.tcx.fn_sig(method.def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,\n         }"}, {"sha": "bbdc7df4441e808e17a6b520ecbe1c8ebe8fe15c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -15,7 +15,7 @@ use crate::namespace::Namespace;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n-use rustc::hir::def::{CtorOf, Def, DefKind};\n+use rustc::hir::def::{CtorOf, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -53,9 +53,9 @@ pub enum MethodError<'tcx> {\n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n \n-    // Found an applicable method, but it is not visible. The second argument contains a list of\n+    // Found an applicable method, but it is not visible. The third argument contains a list of\n     // not-in-scope traits which may work.\n-    PrivateMatch(Def, Vec<DefId>),\n+    PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n@@ -400,7 +400,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n         expr_id: hir::HirId\n-    ) -> Result<Def, MethodError<'tcx>> {\n+    ) -> Result<(DefKind, DefId), MethodError<'tcx>> {\n         debug!(\n             \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n             method_name, self_ty, expr_id,\n@@ -422,12 +422,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // them as well. It's ok to use the variant's id as a ctor id since an\n                     // error will be reported on any use of such resolution anyway.\n                     let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n-                    let def = Def::Def(\n+                    tcx.check_stability(ctor_def_id, Some(expr_id), span);\n+                    return Ok((\n                         DefKind::Ctor(CtorOf::Variant, variant_def.ctor_kind),\n                         ctor_def_id,\n-                    );\n-                    tcx.check_stability(def.def_id(), Some(expr_id), span);\n-                    return Ok(def);\n+                    ));\n                 }\n             }\n         }\n@@ -442,10 +441,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .unwrap().insert(import_def_id);\n         }\n \n-        let def = pick.item.def();\n-        debug!(\"resolve_ufcs: def={:?}\", def);\n-        tcx.check_stability(def.def_id(), Some(expr_id), span);\n-        Ok(def)\n+        let def_kind = pick.item.def_kind();\n+        debug!(\"resolve_ufcs: def_kind={:?}, def_id={:?}\", def_kind, pick.item.def_id);\n+        tcx.check_stability(pick.item.def_id, Some(expr_id), span);\n+        Ok((def_kind, pick.item.def_id))\n     }\n \n     /// Finds item with name `item_name` defined in impl/trait `def_id`"}, {"sha": "8c61a127d1014cbca72211e373140e777e8c3db5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -6,7 +6,7 @@ use super::suggest;\n use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def_id::DefId;\n-use crate::hir::def::{Def, DefKind};\n+use crate::hir::def::DefKind;\n use crate::namespace::Namespace;\n \n use rustc_data_structures::sync::Lrc;\n@@ -68,7 +68,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n-    private_candidate: Option<Def>,\n+    private_candidate: Option<(DefKind, DefId)>,\n \n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n@@ -520,7 +520,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.extension_candidates.push(candidate);\n             }\n         } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(candidate.item.def());\n+            self.private_candidate =\n+                Some((candidate.item.def_kind(), candidate.item.def_id));\n         }\n     }\n \n@@ -861,9 +862,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                method: &ty::AssociatedItem,\n                                self_ty: Option<Ty<'tcx>>,\n                                expected: Ty<'tcx>) -> bool {\n-        match method.def() {\n-            Def::Def(DefKind::Method, def_id) => {\n-                let fty = self.tcx.fn_sig(def_id);\n+        match method.kind {\n+            ty::AssociatedKind::Method => {\n+                let fty = self.tcx.fn_sig(method.def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n@@ -1004,8 +1005,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             _ => vec![],\n         };\n \n-        if let Some(def) = private_candidate {\n-            return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n+        if let Some((kind, def_id)) = private_candidate {\n+            return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n         let lev_candidate = self.probe_for_lev_candidate()?;\n "}, {"sha": "eef6627789db6cba745aaa41746c296114c29eb3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -483,13 +483,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    let def = lev_candidate.def();\n+                    let def_kind = lev_candidate.def_kind();\n                     err.span_suggestion(\n                         span,\n                         &format!(\n                             \"there is {} {} with a similar name\",\n-                            def.article(),\n-                            def.kind_name(),\n+                            def_kind.article(),\n+                            def_kind.descr(),\n                         ),\n                         lev_candidate.ident.to_string(),\n                         Applicability::MaybeIncorrect,\n@@ -510,9 +510,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::PrivateMatch(def, out_of_scope_traits) => {\n+            MethodError::PrivateMatch(kind, _, out_of_scope_traits) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0624,\n-                                               \"{} `{}` is private\", def.kind_name(), item_name);\n+                                               \"{} `{}` is private\", kind.descr(), item_name);\n                 self.suggest_valid_traits(&mut err, out_of_scope_traits);\n                 err.emit();\n             }"}, {"sha": "95e20e4e170bca708d46ac5d726b246189500af1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -2149,7 +2149,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables\n             .borrow_mut()\n             .type_dependent_defs_mut()\n-            .insert(hir_id, Def::Def(DefKind::Method, method.def_id));\n+            .insert(hir_id, Ok((DefKind::Method, method.def_id)));\n \n         self.write_substs(hir_id, method.substs);\n \n@@ -4797,13 +4797,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     Def::Err\n                 };\n-                let (ty, def) = AstConv::associated_path_to_ty(self, hir_id, path_span,\n-                                                               ty, def, segment, true);\n+                let result = AstConv::associated_path_to_ty(\n+                    self,\n+                    hir_id,\n+                    path_span,\n+                    ty,\n+                    def,\n+                    segment,\n+                    true,\n+                );\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or(self.tcx().types.err);\n+                let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n+                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, result);\n \n-                (def, ty)\n+                (result.map(|(kind, def_id)| Def::Def(kind, def_id)).unwrap_or(Def::Err), ty)\n             }\n         }\n     }\n@@ -4827,34 +4836,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (self.to_ty(qself), qself, segment)\n             }\n         };\n-        if let Some(cached_def) = self.tables.borrow().type_dependent_def(hir_id) {\n+        if let Some(&cached_result) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n-            return (cached_def, Some(ty), slice::from_ref(&**item_segment))\n+            let def = cached_result.map(|(kind, def_id)| Def::Def(kind, def_id))\n+                .unwrap_or(Def::Err);\n+            return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, hir_id) {\n-            Ok(def) => def,\n-            Err(error) => {\n-                let def = match error {\n-                    method::MethodError::PrivateMatch(def, _) => def,\n-                    _ => Def::Err,\n-                };\n-                if item_name.name != keywords::Invalid.name() {\n-                    self.report_method_error(span,\n-                                             ty,\n-                                             item_name,\n-                                             SelfSource::QPath(qself),\n-                                             error,\n-                                             None);\n-                }\n-                def\n+        let result = self.resolve_ufcs(span, item_name, ty, hir_id).or_else(|error| {\n+            let result = match error {\n+                method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n+                _ => Err(ErrorReported),\n+            };\n+            if item_name.name != keywords::Invalid.name() {\n+                self.report_method_error(\n+                    span,\n+                    ty,\n+                    item_name,\n+                    SelfSource::QPath(qself),\n+                    error,\n+                    None,\n+                );\n             }\n-        };\n+            result\n+        });\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n-        (def, Some(ty), slice::from_ref(&**item_segment))\n+        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, result);\n+        (\n+            result.map(|(kind, def_id)| Def::Def(kind, def_id)).unwrap_or(Def::Err),\n+            Some(ty),\n+            slice::from_ref(&**item_segment),\n+        )\n     }\n \n     pub fn check_decl_initializer(&self,\n@@ -5355,7 +5369,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Rewrite `SelfCtor` to `Ctor`\n-    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+    pub fn rewrite_self_ctor(\n+        &self,\n+        def: Def,\n+        span: Span,\n+    ) -> Result<(DefKind, DefId, Ty<'tcx>), ErrorReported> {\n         let tcx = self.tcx;\n         if let Def::SelfCtor(impl_def_id) = def {\n             let ty = self.impl_self_ty(span, impl_def_id).ty;\n@@ -5365,11 +5383,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    let def = Def::Def(\n+                    Ok((\n                         DefKind::Ctor(CtorOf::Struct, variant.ctor_kind),\n                         ctor_def_id,\n-                    );\n-                    (def, ctor_def_id, tcx.type_of(ctor_def_id))\n+                        tcx.type_of(ctor_def_id),\n+                    ))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,\n@@ -5392,16 +5410,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     err.emit();\n \n-                    (def, impl_def_id, tcx.types.err)\n+                    Err(ErrorReported)\n                 }\n             }\n         } else {\n-            let def_id = def.def_id();\n-\n-            // The things we are substituting into the type should not contain\n-            // escaping late-bound regions, and nor should the base type scheme.\n-            let ty = tcx.type_of(def_id);\n-            (def, def_id, ty)\n+            match def {\n+                Def::Def(kind, def_id) => {\n+                    // The things we are substituting into the type should not contain\n+                    // escaping late-bound regions, and nor should the base type scheme.\n+                    let ty = tcx.type_of(def_id);\n+                    Ok((kind, def_id, ty))\n+                }\n+                _ => span_bug!(span, \"unexpected def in rewrite_self_ctor: {:?}\", def),\n+            }\n         }\n     }\n \n@@ -5434,13 +5455,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n-        let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n+        let (kind, def_id, ty) = match self.rewrite_self_ctor(def, span) {\n+            Ok(result) => result,\n+            Err(ErrorReported) => return (tcx.types.err, def),\n+        };\n+        let path_segs =\n+            AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id);\n \n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n-        match def {\n-            Def::Def(DefKind::Ctor(CtorOf::Variant, _), _) => {\n+        match kind {\n+            DefKind::Ctor(CtorOf::Variant, _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {\n@@ -5450,10 +5475,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     is_alias_variant_ctor = true;\n                 }\n             }\n-            Def::Def(DefKind::Method, def_id) |\n-            Def::Def(DefKind::AssociatedConst, def_id) => {\n+            DefKind::Method\n+            | DefKind::AssociatedConst => {\n                 let container = tcx.associated_item(def_id).container;\n-                debug!(\"instantiate_value_path: def={:?} container={:?}\", def, container);\n+                debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n@@ -5643,7 +5668,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, def)\n+        (ty_substituted, Def::Def(kind, def_id))\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "d252a935e3549e6032052569c33ea0e8d4a9d22a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -2787,11 +2787,10 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n-                    return new_ty;\n-                }\n-\n                 if let Def::Def(DefKind::TyParam, did) = path.def {\n+                    if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n+                        return new_ty;\n+                    }\n                     if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n                         return ImplTrait(bounds);\n                     }\n@@ -2811,7 +2810,7 @@ impl Clean<Type> for hir::Ty {\n                     let provided_params = &path.segments.last().expect(\"segments were empty\");\n                     let mut ty_substs = FxHashMap::default();\n                     let mut lt_substs = FxHashMap::default();\n-                    let mut const_substs = FxHashMap::default();\n+                    let mut ct_substs = FxHashMap::default();\n                     provided_params.with_generic_args(|generic_args| {\n                         let mut indices: GenericParamCount = Default::default();\n                         for param in generics.params.iter() {\n@@ -2840,11 +2839,8 @@ impl Clean<Type> for hir::Ty {\n                                     indices.lifetimes += 1;\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n-                                    let ty_param_def =\n-                                        Def::Def(\n-                                            DefKind::TyParam,\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id),\n-                                        );\n+                                    let ty_param_def_id =\n+                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2859,19 +2855,16 @@ impl Clean<Type> for hir::Ty {\n                                         }\n                                     });\n                                     if let Some(ty) = type_.cloned() {\n-                                        ty_substs.insert(ty_param_def, ty.clean(cx));\n+                                        ty_substs.insert(ty_param_def_id, ty.clean(cx));\n                                     } else if let Some(default) = default.clone() {\n-                                        ty_substs.insert(ty_param_def,\n+                                        ty_substs.insert(ty_param_def_id,\n                                                          default.into_inner().clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n                                 hir::GenericParamKind::Const { .. } => {\n-                                    let const_param_def =\n-                                        Def::Def(\n-                                            DefKind::ConstParam,\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id),\n-                                        );\n+                                    let const_param_def_id =\n+                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                                     let mut j = 0;\n                                     let const_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2886,15 +2879,15 @@ impl Clean<Type> for hir::Ty {\n                                         }\n                                     });\n                                     if let Some(ct) = const_.cloned() {\n-                                        const_substs.insert(const_param_def, ct.clean(cx));\n+                                        ct_substs.insert(const_param_def_id, ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n                                     indices.consts += 1;\n                                 }\n                             }\n                         }\n                     });\n-                    return cx.enter_alias(ty_substs, lt_substs, const_substs, || ty.clean(cx));\n+                    return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.hir_id)\n             }"}, {"sha": "5555ea302c96f1aa203c4710eaf5d6a39ad6ae3d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92b1a76e175f396d7986177d0a2d5907bbba888/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b92b1a76e175f396d7986177d0a2d5907bbba888", "patch": "@@ -1,7 +1,6 @@\n use rustc_lint;\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n-use rustc::hir::def::Def;\n use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n@@ -59,12 +58,12 @@ pub struct DocContext<'tcx> {\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n-    /// Table type parameter definition -> substituted type\n-    pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n-    /// Table `NodeId` of lifetime parameter definition -> substituted lifetime\n+    /// Table `DefId` of type parameter -> substituted type\n+    pub ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n+    /// Table `DefId` of lifetime parameter -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n-    /// Table node id of const parameter definition -> substituted const\n-    pub ct_substs: RefCell<FxHashMap<Def, clean::Constant>>,\n+    /// Table `DefId` of const parameter -> substituted const\n+    pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table DefId of `impl Trait` in argument position -> bounds\n     pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::GenericBound>>>,\n     pub send_trait: Option<DefId>,\n@@ -91,9 +90,9 @@ impl<'tcx> DocContext<'tcx> {\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n-                             ty_substs: FxHashMap<Def, clean::Type>,\n+                             ty_substs: FxHashMap<DefId, clean::Type>,\n                              lt_substs: FxHashMap<DefId, clean::Lifetime>,\n-                             ct_substs: FxHashMap<Def, clean::Constant>,\n+                             ct_substs: FxHashMap<DefId, clean::Constant>,\n                              f: F) -> R\n     where F: FnOnce() -> R {\n         let (old_tys, old_lts, old_cts) = ("}]}