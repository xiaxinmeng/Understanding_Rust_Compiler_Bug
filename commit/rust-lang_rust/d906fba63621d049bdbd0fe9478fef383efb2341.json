{"sha": "d906fba63621d049bdbd0fe9478fef383efb2341", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MDZmYmE2MzYyMWQwNDliZGJkMGZlOTQ3OGZlZjM4M2VmYjIzNDE=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-08T01:01:58Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-15T19:41:41Z"}, "message": "Make token tree lexers and their stacks unique.", "tree": {"sha": "a467934c293921ea0430311fbd4a16e1fedd4288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a467934c293921ea0430311fbd4a16e1fedd4288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d906fba63621d049bdbd0fe9478fef383efb2341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d906fba63621d049bdbd0fe9478fef383efb2341", "html_url": "https://github.com/rust-lang/rust/commit/d906fba63621d049bdbd0fe9478fef383efb2341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d906fba63621d049bdbd0fe9478fef383efb2341/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03c04b6ead225860b21b3540681a2ba58b220df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d03c04b6ead225860b21b3540681a2ba58b220df", "html_url": "https://github.com/rust-lang/rust/commit/d03c04b6ead225860b21b3540681a2ba58b220df"}], "stats": {"total": 87, "additions": 50, "deletions": 37}, "files": [{"sha": "28369dbb5a52ac1c9aadf99628ff40ae22ad3ca1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d906fba63621d049bdbd0fe9478fef383efb2341/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d906fba63621d049bdbd0fe9478fef383efb2341/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d906fba63621d049bdbd0fe9478fef383efb2341", "patch": "@@ -27,7 +27,7 @@ type tt_frame = @{\n     up: tt_frame_up\n };\n \n-type tt_reader = @{\n+type tt_reader = ~{\n     span_diagnostic: diagnostic::span_handler,\n     interner: @interner::interner<@str>,\n     mut cur: tt_frame,\n@@ -39,28 +39,29 @@ type tt_reader = @{\n fn new_tt_reader(span_diagnostic: diagnostic::span_handler,\n                  itr: @interner::interner<@str>, src: [ast::token_tree])\n     -> tt_reader {\n-    let r = @{span_diagnostic: span_diagnostic, interner: itr,\n+    let r = ~{span_diagnostic: span_diagnostic, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u,\n                          up: tt_frame_up(option::none)},\n               mut cur_tok: token::EOF, /* dummy value, never read */\n               mut cur_chpos: 0u /* dummy value, never read */\n              };\n-    (r as reader).next_token(); /* get cur_tok and cur_chpos set up */\n+    //tt_next_token(r); /* get cur_tok and cur_chpos set up */\n     ret r;\n }\n \n pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n     @{readme: f.readme, mut idx: f.idx,\n       up: alt f.up {\n-        tt_frame_up(o_f) {\n-          tt_frame_up(option::map(o_f, dup_tt_frame))\n+        tt_frame_up(some(up_frame)) {\n+          tt_frame_up(some(dup_tt_frame(up_frame)))\n         }\n+        tt_frame_up(none) { tt_frame_up(none) }\n       }\n      }\n }\n \n pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n-    @{span_diagnostic: r.span_diagnostic, interner: r.interner,\n+    ~{span_diagnostic: r.span_diagnostic, interner: r.interner,\n       mut cur: dup_tt_frame(r.cur),\n       mut cur_tok: r.cur_tok, mut cur_chpos: r.cur_chpos}\n }\n@@ -114,38 +115,13 @@ impl string_reader_as_reader of reader for string_reader {\n impl tt_reader_as_reader of reader for tt_reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n     fn next_token() -> {tok: token::token, chpos: uint} {\n-        let ret_val = { tok: self.cur_tok, chpos: self.cur_chpos };\n-        if self.cur.idx >= vec::len(self.cur.readme) {\n-            /* done with this set; pop */\n-            alt self.cur.up {\n-              tt_frame_up(option::none) {\n-                self.cur_tok = token::EOF;\n-                ret ret_val;\n-              }\n-              tt_frame_up(option::some(tt_f)) {\n-                self.cur = tt_f;\n-                /* the above `if` would need to be a `while` if we didn't know\n-                that the last thing in a `tt_delim` is always a `tt_flat` */\n-                self.cur.idx += 1u;\n-              }\n-            }\n-        }\n-        /* if `tt_delim`s could be 0-length, we'd need to be able to switch\n-        between popping and pushing until we got to an actual `tt_flat` */\n-        loop { /* because it's easiest, this handles `tt_delim` not starting\n-                  with a `tt_flat`, even though it won't happen */\n-            alt self.cur.readme[self.cur.idx] {\n-              tt_delim(tts) {\n-                self.cur = @{readme: tts, mut idx: 0u,\n-                             up: tt_frame_up(option::some(self.cur)) };\n-              }\n-              tt_flat(chpos, tok) {\n-                self.cur_chpos = chpos; self.cur_tok = tok;\n-                self.cur.idx += 1u;\n-                ret ret_val;\n-              }\n-          }\n+        /* weird resolve bug: if the following `if`, or any of its\n+        statements are removed, we get resolution errors */\n+        if false {\n+            let _ignore_me = 0;\n+            let _me_too = self.cur.readme[self.cur.idx];\n         }\n+        tt_next_token(self)\n     }\n     fn fatal(m: str) -> ! {\n         self.span_diagnostic.span_fatal(\n@@ -155,6 +131,43 @@ impl tt_reader_as_reader of reader for tt_reader {\n     fn interner() -> @interner::interner<@str> { self.interner }\n }\n \n+fn tt_next_token(&&r: tt_reader) -> {tok: token::token, chpos: uint} {\n+    let ret_val = { tok: r.cur_tok, chpos: r.cur_chpos };\n+    if r.cur.idx >= vec::len(r.cur.readme) {\n+        /* done with this set; pop */\n+        alt r.cur.up {\n+          tt_frame_up(option::none) {\n+            r.cur_tok = token::EOF;\n+            ret ret_val;\n+          }\n+          tt_frame_up(option::some(tt_f)) {\n+            r.cur <- tt_f;\n+            /* the above `if` would need to be a `while` if we didn't know\n+            that the last thing in a `tt_delim` is always a `tt_flat` */\n+            r.cur.idx += 1u;\n+          }\n+        }\n+    }\n+    /* if `tt_delim`s could be 0-length, we'd need to be able to switch\n+    between popping and pushing until we got to an actual `tt_flat` */\n+    loop { /* because it's easiest, this handles `tt_delim` not starting\n+    with a `tt_flat`, even though it won't happen */\n+        alt r.cur.readme[r.cur.idx] {\n+          tt_delim(tts) {\n+            /* TODO: this copy should be a unary move, once they exist */\n+            r.cur = @{readme: tts, mut idx: 0u,\n+                      up: tt_frame_up(option::some(copy r.cur)) };\n+          }\n+          tt_flat(chpos, tok) {\n+            r.cur_chpos = chpos; r.cur_tok = tok;\n+            r.cur.idx += 1u;\n+            ret ret_val;\n+          }\n+        }\n+    }\n+\n+}\n+\n fn get_str_from(rdr: string_reader, start: uint) -> str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?"}]}