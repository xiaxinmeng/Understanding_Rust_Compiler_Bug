{"sha": "406280e52f20e25af609d947efbed8b352ca1249", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNjI4MGU1MmYyMGUyNWFmNjA5ZDk0N2VmYmVkOGIzNTJjYTEyNDk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-15T10:50:57Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-17T17:47:45Z"}, "message": "Refactor associated item resolution more\n\nWhen resolving an associated item in value namespace, use the `Ty` lowering code\nfor the segments before the last instead of replicating it.", "tree": {"sha": "3e7e5e284dd323173581b2c8618304f6125791b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e7e5e284dd323173581b2c8618304f6125791b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/406280e52f20e25af609d947efbed8b352ca1249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/406280e52f20e25af609d947efbed8b352ca1249", "html_url": "https://github.com/rust-lang/rust/commit/406280e52f20e25af609d947efbed8b352ca1249", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/406280e52f20e25af609d947efbed8b352ca1249/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "828d60574f8ecbc33fe4987913c6f713e41af1ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/828d60574f8ecbc33fe4987913c6f713e41af1ae", "html_url": "https://github.com/rust-lang/rust/commit/828d60574f8ecbc33fe4987913c6f713e41af1ae"}], "stats": {"total": 244, "additions": 120, "deletions": 124}, "files": [{"sha": "f33479dc4ba44f6d09b74741f175662120d4cccb", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 54, "deletions": 71, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/406280e52f20e25af609d947efbed8b352ca1249/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406280e52f20e25af609d947efbed8b352ca1249/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=406280e52f20e25af609d947efbed8b352ca1249", "patch": "@@ -48,7 +48,7 @@ use crate::{\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, AssocItem, ConstData, DefWithBody, Either, FnData, Function, HasBody, ImplItem, Name, Path,\n+    Adt, AssocItem, ConstData, DefWithBody, Either, FnData, Function, HasBody, Name, Path,\n     StructField,\n };\n \n@@ -508,88 +508,72 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_assoc_item(\n         &mut self,\n-        mut def_or_ty: Either<TypeNs, Ty>,\n+        // mut def_or_ty: Either<TypeNs, Ty>,\n+        def: TypeNs,\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         assert!(remaining_index < path.segments.len());\n         let krate = self.resolver.krate()?;\n \n-        let mut ty = Ty::Unknown;\n-\n-        // resolve intermediate segments\n-        for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n-            let is_last_segment = i == path.segments[remaining_index..].len() - 1;\n-            ty = match def_or_ty {\n-                Either::A(def) => {\n-                    let typable: TypableDef = match def {\n-                        TypeNs::Adt(it) => it.into(),\n-                        TypeNs::TypeAlias(it) => it.into(),\n-                        TypeNs::BuiltinType(it) => it.into(),\n-                        // FIXME associated item of traits, generics, and Self\n-                        TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n-                            return None;\n-                        }\n-                        // FIXME: report error here\n-                        TypeNs::EnumVariant(_) => return None,\n-                    };\n-\n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-\n-                    // For example, this substs will take `Gen::*<u32>*::make`\n-                    assert!(remaining_index > 0);\n-                    let substs = Ty::substs_from_path_segment(\n-                        self.db,\n-                        &self.resolver,\n-                        &path.segments[remaining_index + i - 1],\n-                        typable,\n-                    );\n-                    ty.subst(&substs)\n-                }\n-                Either::B(ty) => ty,\n-            };\n-            if is_last_segment {\n-                break;\n-            }\n+        // there may be more intermediate segments between the resolved one and\n+        // the end. Only the last segment needs to be resolved to a value; from\n+        // the segments before that, we need to get either a type or a trait ref.\n \n-            // Attempt to find an impl_item for the type which has a name matching\n-            // the current segment\n-            log::debug!(\"looking for path segment: {:?}\", segment);\n+        let resolved_segment = &path.segments[remaining_index - 1];\n+        let remaining_segments = &path.segments[remaining_index..];\n+        let is_before_last = remaining_segments.len() == 1;\n \n-            let ty = mem::replace(&mut ty, Ty::Unknown);\n-            def_or_ty = ty.iterate_impl_items(self.db, krate, |item| {\n-                match item {\n-                    crate::ImplItem::Method(_) | crate::ImplItem::Const(_) => None,\n+        let (def, substs) = match (def, is_before_last) {\n+            (TypeNs::Trait(_trait), true) => {\n+                // Associated item of trait, e.g. `Default::default`\n+                // FIXME\n+                return None;\n+            }\n+            (def, _) => {\n+                // Either we already have a type (e.g. `Vec::new`), or we have a\n+                // trait but it's not the last segment, so the next segment\n+                // should resolve to an associated type of that trait (e.g. `<T\n+                // as Iterator>::Item::default`)\n+                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n+                let ty = Ty::from_partly_resolved_hir_path(\n+                    self.db,\n+                    &self.resolver,\n+                    def,\n+                    resolved_segment,\n+                    remaining_segments_for_ty,\n+                );\n+                if let Ty::Unknown = ty {\n+                    return None;\n+                }\n \n-                    // FIXME: Resolve associated types\n-                    crate::ImplItem::TypeAlias(_) => {\n-                        // Some(Either::A(TypeNs::TypeAlias(..)))\n-                        None\n+                let segment =\n+                    remaining_segments.last().expect(\"there should be at least one segment here\");\n+                // Find impl\n+                let def = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n+                    crate::ImplItem::Method(func) => {\n+                        if segment.name == func.name(self.db) {\n+                            Some(ValueNs::Function(func))\n+                        } else {\n+                            None\n+                        }\n                     }\n-                }\n-            })?;\n-        }\n \n-        let segment = path.segments.last().unwrap();\n-        let def = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n-            crate::ImplItem::Method(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(ValueNs::Function(func))\n-                } else {\n-                    None\n-                }\n+                    crate::ImplItem::Const(konst) => {\n+                        if segment.name == konst.name(self.db) {\n+                            Some(ValueNs::Const(konst))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    crate::ImplItem::TypeAlias(_) => None,\n+                })?;\n+                let self_types = self.find_self_types(&def, ty);\n+                (def, self_types)\n             }\n+        };\n \n-            crate::ImplItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(ValueNs::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            crate::ImplItem::TypeAlias(_) => None,\n-        })?;\n         self.write_assoc_resolution(\n             id,\n             match def {\n@@ -598,8 +582,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 _ => unreachable!(),\n             },\n         );\n-        let self_types = self.find_self_types(&def, ty);\n-        Some((def, self_types))\n+        Some((def, substs))\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {"}, {"sha": "e29b68f1a98600a19de0840be807068500d47abd", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/406280e52f20e25af609d947efbed8b352ca1249/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406280e52f20e25af609d947efbed8b352ca1249/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=406280e52f20e25af609d947efbed8b352ca1249", "patch": "@@ -86,81 +86,94 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n-        // Resolve the path (in type namespace)\n-        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n-            Some(it) => it,\n-            None => return Ty::Unknown,\n-        };\n-\n+    pub(crate) fn from_partly_resolved_hir_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        resolution: TypeNs,\n+        resolved_segment: &PathSegment,\n+        remaining_segments: &[PathSegment],\n+    ) -> Ty {\n         let ty = match resolution {\n             TypeNs::Trait(trait_) => {\n-                let segment = match remaining_index {\n-                    None => path.segments.last().expect(\"resolved path has at least one element\"),\n-                    Some(i) => &path.segments[i - 1],\n-                };\n-                let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n-                return if let Some(remaining_index) = remaining_index {\n-                    if remaining_index == path.segments.len() - 1 {\n-                        let segment = &path.segments[remaining_index];\n-                        match trait_ref\n-                            .trait_\n-                            .associated_type_by_name_including_super_traits(db, &segment.name)\n-                        {\n-                            Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n-                                Ty::Projection(ProjectionTy {\n-                                    associated_ty,\n-                                    parameters: trait_ref.substs,\n-                                })\n-                            }\n-                            None => {\n-                                // associated type not found (FIXME: report error)\n-                                Ty::Unknown\n-                            }\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+                return if remaining_segments.len() == 1 {\n+                    let segment = &remaining_segments[0];\n+                    match trait_ref\n+                        .trait_\n+                        .associated_type_by_name_including_super_traits(db, &segment.name)\n+                    {\n+                        Some(associated_ty) => {\n+                            // FIXME handle type parameters on the segment\n+                            Ty::Projection(ProjectionTy {\n+                                associated_ty,\n+                                parameters: trait_ref.substs,\n+                            })\n+                        }\n+                        None => {\n+                            // associated type not found (FIXME: report error)\n+                            Ty::Unknown\n                         }\n-                    } else {\n-                        // FIXME report error (ambiguous associated type)\n-                        Ty::Unknown\n                     }\n+                } else if remaining_segments.len() > 1 {\n+                    // FIXME report error (ambiguous associated type)\n+                    Ty::Unknown\n                 } else {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n             TypeNs::GenericParam(idx) => {\n                 // FIXME: maybe return name in resolution?\n-                let name = match remaining_index {\n-                    None => path\n-                        .as_ident()\n-                        .expect(\"generic param should be single-segment path\")\n-                        .clone(),\n-                    Some(idx) => path.segments[idx - 1].name.clone(),\n-                };\n+                let name = resolved_segment.name.clone();\n                 Ty::Param { idx, name }\n             }\n             TypeNs::SelfType(impl_block) => impl_block.target_ty(db),\n \n-            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n-            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n-            TypeNs::TypeAlias(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n+            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n+            TypeNs::BuiltinType(it) => {\n+                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            }\n+            TypeNs::TypeAlias(it) => {\n+                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            }\n             // FIXME: report error\n             TypeNs::EnumVariant(_) => return Ty::Unknown,\n         };\n \n-        if let Some(remaining_index) = remaining_index {\n+        if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n-            if remaining_index == path.segments.len() - 1 {\n-                let segment = &path.segments[remaining_index];\n-                Ty::select_associated_type(db, resolver, ty, segment)\n-            } else {\n-                // FIXME report error (ambiguous associated type)\n-                Ty::Unknown\n-            }\n+            let segment = &remaining_segments[0];\n+            Ty::select_associated_type(db, resolver, ty, segment)\n+        } else if remaining_segments.len() > 1 {\n+            // FIXME report error (ambiguous associated type)\n+            Ty::Unknown\n         } else {\n             ty\n         }\n     }\n \n+    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n+        // Resolve the path (in type namespace)\n+        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n+            Some(it) => it,\n+            None => return Ty::Unknown,\n+        };\n+        let (resolved_segment, remaining_segments) = match remaining_index {\n+            None => (\n+                path.segments.last().expect(\"resolved path has at least one element\"),\n+                &[] as &[PathSegment],\n+            ),\n+            Some(i) => (&path.segments[i - 1], &path.segments[i..]),\n+        };\n+        Ty::from_partly_resolved_hir_path(\n+            db,\n+            resolver,\n+            resolution,\n+            resolved_segment,\n+            remaining_segments,\n+        )\n+    }\n+\n     fn select_associated_type(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -190,11 +203,11 @@ impl Ty {\n     fn from_hir_path_inner(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        path: &Path,\n+        segment: &PathSegment,\n         typable: TypableDef,\n     ) -> Ty {\n         let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path(db, resolver, path, typable);\n+        let substs = Ty::substs_from_path_segment(db, resolver, segment, typable);\n         ty.subst(&substs)\n     }\n "}]}