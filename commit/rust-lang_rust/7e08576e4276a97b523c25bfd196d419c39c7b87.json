{"sha": "7e08576e4276a97b523c25bfd196d419c39c7b87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMDg1NzZlNDI3NmE5N2I1MjNjMjViZmQxOTZkNDE5YzM5YzdiODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T17:44:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T17:44:13Z"}, "message": "Auto merge of #62081 - RalfJung:miri-pointer-checks, r=oli-obk\n\nRefactor miri pointer checks\n\nCentralize bounds, alignment and NULL checking for memory accesses in one function: `memory.check_ptr_access`. That function also takes care of converting a `Scalar` to a `Pointer`, should that be needed.  Not all accesses need that though: if the access has size 0, `None` is returned. Everyone accessing memory based on a `Scalar` should use this method to get the `Pointer` they need.\n\nAll operations on the `Allocation` work on `Pointer` inputs and expect all the checks to have happened (and will ICE if the bounds are violated). The operations on `Memory` work on `Scalar` inputs and do the checks themselves.\n\nThe only other public method to check pointers is `memory.ptr_may_be_null`, which is needed in a few places. No need for `check_align` or similar methods. That makes the public API surface much easier to use and harder to mis-use.\n\nThis should be largely no-functional-change, except that ZST accesses to a \"true\" pointer that is dangling or out-of-bounds are now considered UB. This is to be conservative wrt. whatever LLVM might be doing.\n\nWhile I am at it, this also removes the assumption that the vtable part of a `dyn Trait`-fat-pointer is a `Pointer` (as opposed to a pointer cast to an integer, stored as raw bits).\n\nr? @oli-obk", "tree": {"sha": "9143b02b594cbc2f5d62201343c97375423c31ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9143b02b594cbc2f5d62201343c97375423c31ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e08576e4276a97b523c25bfd196d419c39c7b87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e08576e4276a97b523c25bfd196d419c39c7b87", "html_url": "https://github.com/rust-lang/rust/commit/7e08576e4276a97b523c25bfd196d419c39c7b87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e08576e4276a97b523c25bfd196d419c39c7b87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbbb3e597482bec1260ea733f7d3fc813bc136ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbbb3e597482bec1260ea733f7d3fc813bc136ae", "html_url": "https://github.com/rust-lang/rust/commit/bbbb3e597482bec1260ea733f7d3fc813bc136ae"}, {"sha": "7e830286c7a0c19e57d1a09e9a0bde7933f68bb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e830286c7a0c19e57d1a09e9a0bde7933f68bb6", "html_url": "https://github.com/rust-lang/rust/commit/7e830286c7a0c19e57d1a09e9a0bde7933f68bb6"}], "stats": {"total": 545, "additions": 292, "deletions": 253}, "files": [{"sha": "c8bf250d02b36cc82f2c77794b52b94e935bae38", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -6,44 +6,13 @@ use super::{\n \n use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n-use std::{iter, fmt::{self, Display}};\n+use std::iter;\n use crate::mir;\n-use std::ops::{Deref, DerefMut};\n+use std::ops::{Range, Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_macros::HashStable;\n use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-/// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n-/// or also inbounds of a *live* allocation.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum InboundsCheck {\n-    Live,\n-    MaybeDead,\n-}\n-\n-/// Used by `check_in_alloc` to indicate context of check\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum CheckInAllocMsg {\n-    MemoryAccessTest,\n-    NullPointerTest,\n-    PointerArithmeticTest,\n-    InboundsTest,\n-}\n-\n-impl Display for CheckInAllocMsg {\n-    /// When this is printed as an error the context looks like this\n-    /// \"{test name} failed: pointer must be in-bounds at offset...\"\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", match *self {\n-            CheckInAllocMsg::MemoryAccessTest => \"Memory access\",\n-            CheckInAllocMsg::NullPointerTest => \"Null pointer test\",\n-            CheckInAllocMsg::PointerArithmeticTest => \"Pointer arithmetic\",\n-            CheckInAllocMsg::InboundsTest => \"Inbounds test\",\n-        })\n-    }\n-}\n-\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n@@ -146,54 +115,48 @@ impl<Tag> Allocation<Tag> {\n \n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n-/// Alignment and bounds checks\n-impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n-    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n-    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n-    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n-    fn check_bounds_ptr(\n-        &self,\n-        ptr: Pointer<Tag>,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n-        let allocation_size = self.bytes.len() as u64;\n-        ptr.check_in_alloc(Size::from_bytes(allocation_size), msg)\n-    }\n-\n-    /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n-    #[inline(always)]\n-    pub fn check_bounds(\n+/// Byte accessors\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+    /// Just a small local helper function to avoid a bit of code repetition.\n+    /// Returns the range of this allocation that was meant.\n+    #[inline]\n+    fn check_bounds(\n         &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, cx)?, msg)\n+        offset: Size,\n+        size: Size\n+    ) -> Range<usize> {\n+        let end = offset + size; // this does overflow checking\n+        assert_eq!(\n+            end.bytes() as usize as u64, end.bytes(),\n+            \"cannot handle this access on this host architecture\"\n+        );\n+        let end = end.bytes() as usize;\n+        assert!(\n+            end <= self.bytes.len(),\n+            \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n+            offset.bytes(), size.bytes(), self.bytes.len()\n+        );\n+        (offset.bytes() as usize)..end\n     }\n-}\n \n-/// Byte accessors\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     fn get_bytes_internal(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n-        msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.check_bounds(cx, ptr, size, msg)?;\n+        let range = self.check_bounds(ptr.offset, size);\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -205,12 +168,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n         AllocationExtra::memory_read(self, ptr, size)?;\n \n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&self.bytes[range])\n     }\n \n+    /// Check that these bytes are initialized and not pointer bytes, and then return them\n+    /// as a slice.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     #[inline]\n     pub fn get_bytes(\n         &self,\n@@ -219,11 +183,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.get_bytes_internal(cx, ptr, size, true, CheckInAllocMsg::MemoryAccessTest)\n+        self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     #[inline]\n     pub fn get_bytes_with_undef_and_ptr(\n         &self,\n@@ -232,30 +198,28 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.get_bytes_internal(cx, ptr, size, false, CheckInAllocMsg::MemoryAccessTest)\n+        self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx, &mut [u8]>\n     {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_bounds(cx, ptr, size, CheckInAllocMsg::MemoryAccessTest)?;\n+        let range = self.check_bounds(ptr.offset, size);\n \n         self.mark_definedness(ptr, size, true);\n         self.clear_relocations(cx, ptr, size)?;\n \n         AllocationExtra::memory_written(self, ptr, size)?;\n \n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&mut self.bytes[range])\n     }\n }\n \n@@ -276,9 +240,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 let size_with_null = Size::from_bytes((size + 1) as u64);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n-                // from the result!\n+                // from the result, so we do subslicing.\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n+            // This includes the case where `offset` is out-of-bounds to begin with.\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n@@ -306,7 +271,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n-    /// Will do bounds checks on the allocation.\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -320,6 +285,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_repeat(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -342,7 +309,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -378,7 +345,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// Read a pointer-sized scalar.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -395,7 +364,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -435,7 +404,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// Write a pointer-sized scalar.\n+    ///\n+    /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "1b294250aa3dca3d409e104c0fa685030a3d1845", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -17,12 +17,9 @@ pub use self::error::{\n \n pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};\n \n-pub use self::allocation::{\n-    InboundsCheck, Allocation, AllocationExtra,\n-    Relocations, UndefMask, CheckInAllocMsg,\n-};\n+pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n-pub use self::pointer::{Pointer, PointerArithmetic};\n+pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n \n use std::fmt;\n use crate::mir;"}, {"sha": "a17bc1f67283de750c005d46541b6b87aef0aa41", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -1,13 +1,35 @@\n-use std::fmt;\n+use std::fmt::{self, Display};\n \n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n \n use super::{\n-    AllocId, InterpResult, CheckInAllocMsg\n+    AllocId, InterpResult,\n };\n \n+/// Used by `check_in_alloc` to indicate context of check\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum CheckInAllocMsg {\n+    MemoryAccessTest,\n+    NullPointerTest,\n+    PointerArithmeticTest,\n+    InboundsTest,\n+}\n+\n+impl Display for CheckInAllocMsg {\n+    /// When this is printed as an error the context looks like this\n+    /// \"{test name} failed: pointer must be in-bounds at offset...\"\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", match *self {\n+            CheckInAllocMsg::MemoryAccessTest => \"Memory access\",\n+            CheckInAllocMsg::NullPointerTest => \"Null pointer test\",\n+            CheckInAllocMsg::PointerArithmeticTest => \"Pointer arithmetic\",\n+            CheckInAllocMsg::InboundsTest => \"Inbounds test\",\n+        })\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Pointer arithmetic\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "c6e762bddd4d940f169affb8dfcf01749db54002", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -442,7 +442,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 Ok(Some((size.align_to(align), align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\").to_ptr()?;\n+                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n                 // the second entry in the vtable is the dynamic size of the object.\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }"}, {"sha": "c3eec677a48500ccdcb8750960f216b976735c61", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 127, "deletions": 83, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -19,8 +19,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n-    InterpError::ValidationFailure,\n+    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -44,6 +43,17 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     }\n }\n \n+/// Used by `get_size_and_align` to indicate whether the allocation needs to be live.\n+#[derive(Debug, Copy, Clone)]\n+pub enum AllocCheck {\n+    /// Allocation must be live and not a function pointer.\n+    Dereferencable,\n+    /// Allocations needs to be live, but may be a function pointer.\n+    Live,\n+    /// Allocation may be dead.\n+    MaybeDead,\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -248,63 +258,93 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Checks that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n-    /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n-    pub fn check_align(\n+    /// Check if the given scalar is allowed to do a memory access of given `size`\n+    /// and `align`. On success, returns `None` for zero-sized accesses (where\n+    /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n+    /// Crucially, if the input is a `Pointer`, we will test it for liveness\n+    /// *even of* the size is 0.\n+    ///\n+    /// Everyone accessing memory based on a `Scalar` should use this method to get the\n+    /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n+    /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n+    /// cause ICEs.\n+    pub fn check_ptr_access(\n         &self,\n-        ptr: Scalar<M::PointerTag>,\n-        required_align: Align\n-    ) -> InterpResult<'tcx> {\n-        // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n-            Err(ptr) => {\n-                // check this is not NULL -- which we can ensure only if this is in-bounds\n-                // of some (potentially dead) allocation.\n-                let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n-                                                  CheckInAllocMsg::NullPointerTest)?;\n-                (ptr.offset.bytes(), align)\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n+            if offset % align.bytes() == 0 {\n+                Ok(())\n+            } else {\n+                // The biggest power of two through which `offset` is divisible.\n+                let offset_pow2 = 1 << offset.trailing_zeros();\n+                err!(AlignmentCheckFailed {\n+                    has: Align::from_bytes(offset_pow2).unwrap(),\n+                    required: align,\n+                })\n             }\n-            Ok(data) => {\n-                // check this is not NULL\n-                if data == 0 {\n+        }\n+\n+        // Normalize to a `Pointer` if we definitely need one.\n+        let normalized = if size.bytes() == 0 {\n+            // Can be an integer, just take what we got.  We do NOT `force_bits` here;\n+            // if this is already a `Pointer` we want to do the bounds checks!\n+            sptr\n+        } else {\n+            // A \"real\" access, we must get a pointer.\n+            Scalar::Ptr(self.force_ptr(sptr)?)\n+        };\n+        Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n+            Ok(bits) => {\n+                let bits = bits as u64; // it's ptr-sized\n+                assert!(size.bytes() == 0);\n+                // Must be non-NULL and aligned.\n+                if bits == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                // the \"base address\" is 0 and hence always aligned\n-                (data as u64, required_align)\n+                check_offset_align(bits, align)?;\n+                None\n             }\n-        };\n-        // Check alignment\n-        if alloc_align.bytes() < required_align.bytes() {\n-            return err!(AlignmentCheckFailed {\n-                has: alloc_align,\n-                required: required_align,\n-            });\n-        }\n-        if offset % required_align.bytes() == 0 {\n-            Ok(())\n-        } else {\n-            let has = offset % required_align.bytes();\n-            err!(AlignmentCheckFailed {\n-                has: Align::from_bytes(has).unwrap(),\n-                required: required_align,\n-            })\n-        }\n+            Err(ptr) => {\n+                let (allocation_size, alloc_align) =\n+                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferencable)?;\n+                // Test bounds. This also ensures non-NULL.\n+                // It is sufficient to check this for the end pointer. The addition\n+                // checks for overflow.\n+                let end_ptr = ptr.offset(size, self)?;\n+                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                // Test align. Check this last; if both bounds and alignment are violated\n+                // we want the error to be about the bounds.\n+                if alloc_align.bytes() < align.bytes() {\n+                    // The allocation itself is not aligned enough.\n+                    // FIXME: Alignment check is too strict, depending on the base address that\n+                    // got picked we might be aligned even if this check fails.\n+                    // We instead have to fall back to converting to an integer and checking\n+                    // the \"real\" alignment.\n+                    return err!(AlignmentCheckFailed {\n+                        has: alloc_align,\n+                        required: align,\n+                    });\n+                }\n+                check_offset_align(ptr.offset.bytes(), align)?;\n+\n+                // We can still be zero-sized in this branch, in which case we have to\n+                // return `None`.\n+                if size.bytes() == 0 { None } else { Some(ptr) }\n+            }\n+        })\n     }\n \n-    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n-    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n-    /// If you want to check bounds before doing a memory access, better first obtain\n-    /// an `Allocation` and call `check_bounds`.\n-    pub fn check_bounds_ptr(\n+    /// Test if the pointer might be NULL.\n+    pub fn ptr_may_be_null(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        liveness: InboundsCheck,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx, Align> {\n-        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n-        ptr.check_in_alloc(allocation_size, msg)?;\n-        Ok(align)\n+    ) -> bool {\n+        let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n+            .expect(\"alloc info with MaybeDead cannot fail\");\n+        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n \n@@ -443,13 +483,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Obtain the size and alignment of an allocation, even if that allocation has been deallocated\n+    /// Obtain the size and alignment of an allocation, even if that allocation has\n+    /// been deallocated.\n     ///\n-    /// If `liveness` is `InboundsCheck::MaybeDead`, this function always returns `Ok`\n+    /// If `liveness` is `AllocCheck::MaybeDead`, this function always returns `Ok`.\n     pub fn get_size_and_align(\n         &self,\n         id: AllocId,\n-        liveness: InboundsCheck,\n+        liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n@@ -459,7 +500,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let alloc = self.tcx.alloc_map.lock().get(id);\n         // Could also be a fn ptr or extern static\n         match alloc {\n-            Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            Some(GlobalAlloc::Function(..)) => {\n+                if let AllocCheck::Dereferencable = liveness {\n+                    // The caller requested no function pointers.\n+                    err!(DerefFunctionPointer)\n+                } else {\n+                    Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+                }\n+            }\n             // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n@@ -471,17 +519,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             _ => {\n                 if let Ok(alloc) = self.get(id) {\n-                    return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+                    Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n                 }\n-                match liveness {\n-                    InboundsCheck::MaybeDead => {\n-                        // Must be a deallocated pointer\n-                        self.dead_alloc_map.get(&id).cloned().ok_or_else(||\n-                            ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n-                                .into()\n-                        )\n-                    },\n-                    InboundsCheck::Live => err!(DanglingPointerDeref),\n+                else if let AllocCheck::MaybeDead = liveness {\n+                    // Deallocated pointers are allowed, we should be able to find\n+                    // them in the map.\n+                    Ok(*self.dead_alloc_map.get(&id)\n+                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n+                } else {\n+                    err!(DanglingPointerDeref)\n                 }\n             },\n         }\n@@ -629,24 +675,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n-/// Byte Accessors\n+/// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    /// Performs appropriate bounds checks.\n     pub fn read_bytes(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        if size.bytes() == 0 {\n-            Ok(&[])\n-        } else {\n-            let ptr = self.force_ptr(ptr)?;\n-            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n-        }\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(&[]), // zero-sized access\n+        };\n+        self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n     }\n-}\n \n-/// Reading and writing.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    /// Performs appropriate bounds checks.\n     pub fn copy(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -659,6 +703,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n+    /// Performs appropriate bounds checks.\n     pub fn copy_repeatedly(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -669,15 +714,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.check_align(src, src_align)?;\n-        self.check_align(dest, dest_align)?;\n-        if size.bytes() == 0 {\n-            // Nothing to do for ZST, other than checking alignment and\n-            // non-NULLness which already happened.\n-            return Ok(());\n-        }\n-        let src = self.force_ptr(src)?;\n-        let dest = self.force_ptr(dest)?;\n+        // We need to check *both* before early-aborting due to the size being 0.\n+        let (src, dest) = match (self.check_ptr_access(src, size, src_align)?,\n+                self.check_ptr_access(dest, size * length, dest_align)?)\n+        {\n+            (Some(src), Some(dest)) => (src, dest),\n+            // One of the two sizes is 0.\n+            _ => return Ok(()),\n+        };\n \n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,"}, {"sha": "259bd6af0d5d4fe68181f01402b457fe172c839f", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -24,7 +24,7 @@ pub use self::eval_context::{\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind};\n+pub use self::memory::{Memory, MemoryKind, AllocCheck};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n "}, {"sha": "c72078fa89cd27e07bf0ec8c6a2bf265696b1138", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -9,9 +9,9 @@ use rustc::ty::layout::{\n };\n \n use rustc::mir::interpret::{\n-    GlobalId, AllocId, CheckInAllocMsg,\n+    GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    InterpResult, InterpError, InboundsCheck,\n+    InterpResult, InterpError,\n     sign_extend, truncate,\n };\n use super::{\n@@ -226,19 +226,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n \n-        if mplace.layout.is_zst() {\n-            // Not all ZSTs have a layout we would handle below, so just short-circuit them\n-            // all here.\n-            self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(ImmTy {\n+        let ptr = match self.memory.check_ptr_access(ptr, mplace.layout.size, ptr_align)? {\n+            Some(ptr) => ptr,\n+            None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Immediate::Scalar(Scalar::zst().into()),\n                 layout: mplace.layout,\n-            }));\n-        }\n+            })),\n+        };\n \n-        // check for integer pointers before alignment to report better errors\n-        let ptr = self.force_ptr(ptr)?;\n-        self.memory.check_align(ptr.into(), ptr_align)?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory\n@@ -250,17 +245,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 }))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n                 let b_offset = a_size.align_to(b.align(self).abi);\n-                assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n+                assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n                 let b_ptr = ptr.offset(b_offset, self)?;\n                 let a_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, a_ptr, a_size)?;\n-                let b_align = ptr_align.restrict_for_offset(b_offset);\n-                self.memory.check_align(b_ptr.into(), b_align)?;\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n@@ -639,8 +635,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n-                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n-                                                         CheckInAllocMsg::NullPointerTest).is_ok();\n+                            !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }"}, {"sha": "1351b5bb8bd88a6684ca967e69559cd7ba588111", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -222,9 +222,9 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> InterpResult<'tcx, Pointer<Tag>> {\n+    pub(super) fn vtable(self) -> Scalar<Tag> {\n         match self.layout.ty.sty {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap().to_ptr(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -746,15 +746,13 @@ where\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n+        assert!(!dest.layout.is_unsized());\n \n-        // Nothing to do for ZSTs, other than checking alignment\n-        if dest.layout.is_zst() {\n-            return self.memory.check_align(ptr, ptr_align);\n-        }\n+        let ptr = match self.memory.check_ptr_access(ptr, dest.layout.size, ptr_align)? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n \n-        // check for integer pointers before alignment to report better errors\n-        let ptr = self.force_ptr(ptr)?;\n-        self.memory.check_align(ptr.into(), ptr_align)?;\n         let tcx = &*self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n@@ -771,18 +769,18 @@ where\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n                     _ => bug!(\"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let b_offset = a_size.align_to(b.align(self).abi);\n-                let b_align = ptr_align.restrict_for_offset(b_offset);\n                 let b_ptr = ptr.offset(b_offset, self)?;\n \n-                self.memory.check_align(b_ptr.into(), b_align)?;\n-\n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n@@ -1053,7 +1051,7 @@ where\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n     -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n-        let vtable = mplace.vtable()?; // also sanity checks the type\n+        let vtable = mplace.vtable(); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "af061f968104e576725c9def03d7adc79ebc344c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -425,12 +425,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // Find and consult vtable\n-                let vtable = receiver_place.vtable()?;\n-                self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n-                let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n-                    self,\n-                    vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n-                )?.to_ptr()?;\n+                let vtable = receiver_place.vtable();\n+                let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+                let vtable_slot = self.memory.check_ptr_access(\n+                    vtable_slot,\n+                    ptr_size,\n+                    self.tcx.data_layout.pointer_align.abi,\n+                )?.expect(\"cannot be a ZST\");\n+                let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n+                    .read_ptr_sized(self, vtable_slot)?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we"}, {"sha": "5d2f268d2663915efb2ce318e6a9b97ded635ea4", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -101,10 +101,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Returns the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: Pointer<M::PointerTag>,\n+        vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n-        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        let vtable = self.memory.check_ptr_access(\n+            vtable,\n+            self.tcx.data_layout.pointer_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n         let drop_fn = self.memory\n             .get(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n@@ -113,20 +117,28 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-        // the drop function takes *mut T where T is the type being dropped, so get that\n+        // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n         Ok((drop_instance, ty))\n     }\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: Pointer<M::PointerTag>,\n+        vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        // We check for size = 3*ptr_size, that covers the drop fn (unused here),\n+        // the size, and the align (which we read below).\n+        let vtable = self.memory.check_ptr_access(\n+            vtable,\n+            3*pointer_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n         let alloc = self.memory.get(vtable.alloc_id)?;\n-        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?\n-            .to_bits(pointer_size)? as u64;\n+        let size = alloc.read_ptr_sized(\n+            self,\n+            vtable.offset(pointer_size, self)?\n+        )?.to_bits(pointer_size)? as u64;\n         let align = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size * 2, self)?,"}, {"sha": "b2a159fef59c616341ca6a7e850edd638237664f", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -3,11 +3,11 @@ use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::{sym, Symbol};\n use rustc::hir;\n-use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n+    GlobalAlloc, InterpResult, InterpError,\n };\n \n use std::hash::Hash;\n@@ -365,8 +365,16 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     let tail = self.ecx.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n-                            let vtable = try_validation!(meta.unwrap().to_ptr(),\n-                                \"non-pointer vtable in fat pointer\", self.path);\n+                            let vtable = meta.unwrap();\n+                            try_validation!(\n+                                self.ecx.memory.check_ptr_access(\n+                                    vtable,\n+                                    3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n+                                    self.ecx.tcx.data_layout.pointer_align.abi,\n+                                ),\n+                                \"dangling or unaligned vtable pointer or too small vtable\",\n+                                self.path\n+                            );\n                             try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", self.path);\n                             try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n@@ -384,40 +392,43 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             bug!(\"Unexpected unsized type tail: {:?}\", tail),\n                     }\n                 }\n-                // Make sure this is non-NULL and aligned\n+                // Make sure this is dereferencable and all.\n                 let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| (layout.size, layout.align.abi));\n-                match self.ecx.memory.check_align(ptr, align) {\n-                    Ok(_) => {},\n+                let ptr: Option<_> = match self.ecx.memory.check_ptr_access(ptr, size, align) {\n+                    Ok(ptr) => ptr,\n                     Err(err) => {\n-                        info!(\"{:?} is not aligned to {:?}\", ptr, align);\n+                        info!(\n+                            \"{:?} did not pass access check for size {:?}, align {:?}\",\n+                            ptr, size, align\n+                        );\n                         match err.kind {\n                             InterpError::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", self.path),\n                             InterpError::AlignmentCheckFailed { required, has } =>\n                                 return validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n+                            InterpError::ReadBytesAsPointer =>\n+                                return validation_failure!(\n+                                    \"integer pointer in non-ZST reference\",\n+                                    self.path\n+                                ),\n                             _ =>\n                                 return validation_failure!(\n-                                    \"dangling (out-of-bounds) reference (might be NULL at \\\n-                                        run-time)\",\n+                                    \"dangling (not entirely in bounds) reference\",\n                                     self.path\n                                 ),\n                         }\n                     }\n-                }\n+                };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n                     let place = self.ecx.ref_to_mplace(value)?;\n-                    // FIXME(RalfJ): check ZST for inbound pointers\n-                    if size != Size::ZERO {\n-                        // Non-ZST also have to be dereferencable\n-                        let ptr = try_validation!(place.ptr.to_ptr(),\n-                            \"integer pointer in non-ZST reference\", self.path);\n+                    if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n@@ -429,18 +440,10 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 return Ok(());\n                             }\n                         }\n-                        // Maintain the invariant that the place we are checking is\n-                        // already verified to be in-bounds.\n-                        try_validation!(\n-                            self.ecx.memory\n-                                .get(ptr.alloc_id)?\n-                                .check_bounds(self.ecx, ptr, size, CheckInAllocMsg::InboundsTest),\n-                            \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n-                    // before.  Proceed recursively even for integer pointers, no\n-                    // reason to skip them! They are (recursively) valid for some ZST,\n-                    // but not for others (e.g., `!` is a ZST).\n+                    // before.  Proceed recursively even for ZST, no\n+                    // reason to skip them! E.g., `!` is a ZST and we want to validate it.\n                     let path = &self.path;\n                     ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n@@ -499,14 +502,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n-                    // only NULL is not allowed.\n-                    // We can call `check_align` to check non-NULL-ness, but have to also look\n-                    // for function pointers.\n-                    let non_null =\n-                        self.ecx.memory.check_align(\n-                            Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n-                        ).is_ok();\n-                    if !non_null {\n+                    // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n+                    if self.ecx.memory.ptr_may_be_null(ptr) {\n                         // These conditions are just here to improve the diagnostics so we can\n                         // differentiate between null pointers and dangling pointers\n                         if self.ref_tracking_for_consts.is_some() &&"}, {"sha": "19db90c1cb53e2ff0bd47e3f1b67b049be0cda16", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e08576e4276a97b523c25bfd196d419c39c7b87/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=7e08576e4276a97b523c25bfd196d419c39c7b87", "patch": "@@ -42,23 +42,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:97:1\n    |\n LL | const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:100:1\n    |\n LL | const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:103:1\n    |\n LL | const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-pointer vtable in fat pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}