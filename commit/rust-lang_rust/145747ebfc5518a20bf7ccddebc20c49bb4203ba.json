{"sha": "145747ebfc5518a20bf7ccddebc20c49bb4203ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NTc0N2ViZmM1NTE4YTIwYmY3Y2NkZGViYzIwYzQ5YmI0MjAzYmE=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-13T15:17:10Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-22T23:18:06Z"}, "message": "Don't suggest using fields in a static method", "tree": {"sha": "bcc9cc1cc39c9f219373d0db8ea1315915f63907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcc9cc1cc39c9f219373d0db8ea1315915f63907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/145747ebfc5518a20bf7ccddebc20c49bb4203ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/145747ebfc5518a20bf7ccddebc20c49bb4203ba", "html_url": "https://github.com/rust-lang/rust/commit/145747ebfc5518a20bf7ccddebc20c49bb4203ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/145747ebfc5518a20bf7ccddebc20c49bb4203ba/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e87cd7e380c89e3f80ceab417e3525e546a1e362", "url": "https://api.github.com/repos/rust-lang/rust/commits/e87cd7e380c89e3f80ceab417e3525e546a1e362", "html_url": "https://github.com/rust-lang/rust/commit/e87cd7e380c89e3f80ceab417e3525e546a1e362"}], "stats": {"total": 117, "additions": 93, "deletions": 24}, "files": [{"sha": "a7188f46ca12b7f674d0beca387fae47b040cd49", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=145747ebfc5518a20bf7ccddebc20c49bb4203ba", "patch": "@@ -67,7 +67,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{PathSegment, PathParameters, SelfKind, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -148,7 +148,13 @@ enum ResolutionError<'a> {\n     /// error E0424: `self` is not available in a static method\n     SelfNotAvailableInStaticMethod,\n     /// error E0425: unresolved name\n-    UnresolvedName(&'a str, &'a str, UnresolvedNameContext<'a>),\n+    UnresolvedName {\n+        path: &'a str,\n+        message: &'a str,\n+        context: UnresolvedNameContext<'a>,\n+        is_static_method: bool,\n+        is_field: bool\n+    },\n     /// error E0426: use of undeclared label\n     UndeclaredLabel(&'a str),\n     /// error E0427: cannot use `ref` binding mode with ...\n@@ -406,16 +412,21 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"`self` is not available in a static method. Maybe a `self` \\\n                              argument is missing?\")\n         }\n-        ResolutionError::UnresolvedName(path, msg, context) => {\n+        ResolutionError::UnresolvedName { path, message: msg, context, is_static_method,\n+                                          is_field } => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0425,\n                                            \"unresolved name `{}`{}\",\n                                            path,\n                                            msg);\n-\n             match context {\n-                UnresolvedNameContext::Other => { } // no help available\n+                UnresolvedNameContext::Other => {\n+                    if msg.is_empty() && is_static_method && is_field {\n+                        err.help(\"this is an associated function, you don't have access to \\\n+                                  this type's fields or methods\");\n+                    }\n+                }\n                 UnresolvedNameContext::PathIsMod(parent) => {\n                     err.help(&match parent.map(|parent| &parent.node) {\n                         Some(&ExprKind::Field(_, ident)) => {\n@@ -596,7 +607,7 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n-                MethodRibKind\n+                MethodRibKind(sig.explicit_self.node == SelfKind::Static)\n             }\n             FnKind::Closure => ClosureRibKind(node_id),\n         };\n@@ -666,7 +677,9 @@ enum RibKind<'a> {\n     // methods. Allow references to ty params that impl or trait\n     // binds. Disallow any other upvars (including other ty params that are\n     // upvars).\n-    MethodRibKind,\n+    //\n+    // The boolean value represents the fact that this method is static or not.\n+    MethodRibKind(bool),\n \n     // We passed through an item scope. Disallow upvars.\n     ItemRibKind,\n@@ -1095,7 +1108,13 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             Err(false) => {\n                 let path_name = &format!(\"{}\", path);\n                 let error =\n-                    ResolutionError::UnresolvedName(path_name, \"\", UnresolvedNameContext::Other);\n+                    ResolutionError::UnresolvedName {\n+                        path: path_name,\n+                        message: \"\",\n+                        context: UnresolvedNameContext::Other,\n+                        is_static_method: false,\n+                        is_field: false\n+                    };\n                 resolve_error(self, path.span, error);\n                 Def::Err\n             }\n@@ -1653,7 +1672,9 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind);\n+                                                          MethodRibKind(\n+                                                             sig.explicit_self.node ==\n+                                                             SelfKind::Static));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n@@ -1772,7 +1793,10 @@ impl<'a> Resolver<'a> {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_function(&mut self, rib_kind: RibKind<'a>, declaration: &FnDecl, block: &Block) {\n+    fn resolve_function(&mut self,\n+                        rib_kind: RibKind<'a>,\n+                        declaration: &FnDecl,\n+                        block: &Block) {\n         // Create a value rib for the function.\n         self.value_ribs.push(Rib::new(rib_kind));\n \n@@ -1979,7 +2003,9 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind);\n+                                                          MethodRibKind(\n+                                                            sig.explicit_self.node ==\n+                                                            SelfKind::Static));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_impl_item(this, impl_item);\n                                     });\n@@ -2673,7 +2699,7 @@ impl<'a> Resolver<'a> {\n                             def = Def::Upvar(node_def_id, node_id, depth, function_id);\n                             seen.insert(node_id, depth);\n                         }\n-                        ItemRibKind | MethodRibKind => {\n+                        ItemRibKind | MethodRibKind(_) => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -2695,7 +2721,7 @@ impl<'a> Resolver<'a> {\n             Def::TyParam(..) | Def::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | MethodRibKind | ClosureRibKind(..) |\n+                        NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n                         ModuleRibKind(..) => {\n                             // Nothing to do. Continue.\n                         }\n@@ -2988,9 +3014,13 @@ impl<'a> Resolver<'a> {\n                             // `resolve_path` already reported the error\n                         } else {\n                             let mut method_scope = false;\n+                            let mut is_static = false;\n                             self.value_ribs.iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n-                                    MethodRibKind => true,\n+                                    MethodRibKind(is_static_) => {\n+                                        is_static = is_static_;\n+                                        true\n+                                    }\n                                     ItemRibKind | ConstantItemRibKind => false,\n                                     _ => return true, // Keep advancing\n                                 };\n@@ -3004,22 +3034,29 @@ impl<'a> Resolver<'a> {\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n-                                let mut msg = match self.find_fallback_in_self_type(last_name) {\n+                                let (mut msg, is_field) =\n+                                    match self.find_fallback_in_self_type(last_name) {\n                                     NoSuggestion => {\n                                         // limit search to 5 to reduce the number\n                                         // of stupid suggestions\n-                                        match self.find_best_match(&path_name) {\n+                                        (match self.find_best_match(&path_name) {\n                                             SuggestionType::Macro(s) => {\n                                                 format!(\"the macro `{}`\", s)\n                                             }\n                                             SuggestionType::Function(s) => format!(\"`{}`\", s),\n                                             SuggestionType::NotFound => \"\".to_string(),\n-                                        }\n+                                        }, false)\n+                                    }\n+                                    Field => {\n+                                        (if is_static && method_scope {\n+                                            \"\".to_string()\n+                                        } else {\n+                                            format!(\"`self.{}`\", path_name)\n+                                        }, true)\n                                     }\n-                                    Field => format!(\"`self.{}`\", path_name),\n-                                    TraitItem => format!(\"to call `self.{}`\", path_name),\n+                                    TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n                                     TraitMethod(path_str) =>\n-                                        format!(\"to call `{}::{}`\", path_str, path_name),\n+                                        (format!(\"to call `{}::{}`\", path_str, path_name), false),\n                                 };\n \n                                 let mut context =  UnresolvedNameContext::Other;\n@@ -3044,8 +3081,13 @@ impl<'a> Resolver<'a> {\n \n                                 resolve_error(self,\n                                               expr.span,\n-                                              ResolutionError::UnresolvedName(\n-                                                  &path_name, &msg, context));\n+                                              ResolutionError::UnresolvedName {\n+                                                  path: &path_name,\n+                                                  message: &msg,\n+                                                  context: context,\n+                                                  is_static_method: method_scope && is_static,\n+                                                  is_field: is_field,\n+                                              });\n                             }\n                         }\n                     }"}, {"sha": "5e816bcfa61e44493aa733db8782595ea55a13c6", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=145747ebfc5518a20bf7ccddebc20c49bb4203ba", "patch": "@@ -32,7 +32,8 @@ impl MaybeDog {\n impl Groom for cat {\n   fn shave(other: usize) {\n     whiskers -= other;\n-    //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n+    //~^ ERROR: unresolved name `whiskers`\n+    //~| HELP this is an associated function\n     shave(4);\n     //~^ ERROR: unresolved name `shave`. Did you mean to call `Groom::shave`?\n     purr();\n@@ -77,7 +78,8 @@ impl cat {\n \n   pub fn grow_older(other:usize) {\n     whiskers = 4;\n-    //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n+    //~^ ERROR: unresolved name `whiskers`\n+    //~| HELP this is an associated function\n     purr_louder();\n     //~^ ERROR: unresolved name `purr_louder`\n   }\n@@ -86,5 +88,6 @@ impl cat {\n fn main() {\n     self += 1;\n     //~^ ERROR: unresolved name `self`\n+    //~| HELP: Module\n     // it's a bug if this suggests a missing `self` as we're not in a method\n }"}, {"sha": "80f6108f02d30a77c8bc5fd0f86bc1fe6f5da414", "filename": "src/test/compile-fail/unresolved_static_type_field.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Ftest%2Fcompile-fail%2Funresolved_static_type_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145747ebfc5518a20bf7ccddebc20c49bb4203ba/src%2Ftest%2Fcompile-fail%2Funresolved_static_type_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved_static_type_field.rs?ref=145747ebfc5518a20bf7ccddebc20c49bb4203ba", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f(_: bool) {}\n+\n+struct Foo {\n+    cx: bool,\n+}\n+\n+impl Foo {\n+    fn bar() {\n+        f(cx); //~ ERROR E0425\n+               //~| HELP this is an associated function\n+    }\n+}\n+\n+fn main() {}"}]}