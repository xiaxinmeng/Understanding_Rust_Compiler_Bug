{"sha": "5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlM2VjZGNlNGU0MmNjYzM0YzQ5ZjMyZjgxYmU3MWFlMDBmMmNmMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-18T01:50:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-18T01:50:52Z"}, "message": "Auto merge of #48917 - petrochenkov:import, r=oli-obk\n\nsyntax: Make imports in AST closer to the source and cleanup their parsing\n\nThis is a continuation of https://github.com/rust-lang/rust/pull/45846 in some sense.", "tree": {"sha": "5e306a69e1f08b96188fb8f19f0bfc79dde37caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e306a69e1f08b96188fb8f19f0bfc79dde37caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "html_url": "https://github.com/rust-lang/rust/commit/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6a98426192f838cc90a18709f92d425b86029e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6a98426192f838cc90a18709f92d425b86029e", "html_url": "https://github.com/rust-lang/rust/commit/ca6a98426192f838cc90a18709f92d425b86029e"}, {"sha": "a02b1d7e2bd329bee0ad2f6a3e281c2004325540", "url": "https://api.github.com/repos/rust-lang/rust/commits/a02b1d7e2bd329bee0ad2f6a3e281c2004325540", "html_url": "https://github.com/rust-lang/rust/commit/a02b1d7e2bd329bee0ad2f6a3e281c2004325540"}], "stats": {"total": 488, "additions": 228, "deletions": 260}, "files": [{"sha": "972278bdf865fb5bd61db6acc405caa4e05f4c16", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -444,10 +444,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n-        ItemExternCrate(opt_name) => {\n+        ItemExternCrate(orig_name) => {\n             visitor.visit_id(item.id);\n-            if let Some(name) = opt_name {\n-                visitor.visit_name(item.span, name);\n+            if let Some(orig_name) = orig_name {\n+                visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemUse(ref path, _) => {"}, {"sha": "1439410f7e9aa2ac025f2d23b92363cc77a1f9ff", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -879,7 +879,7 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n-                let span = t.span.with_hi(t.span.lo());\n+                let span = t.span.shrink_to_lo();\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_lifetime(span)\n@@ -1355,17 +1355,11 @@ impl<'a> LoweringContext<'a> {\n                         id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n-                        param_mode: ParamMode,\n-                        defaults_to_global: bool)\n+                        param_mode: ParamMode)\n                         -> hir::Path {\n-        let mut segments = p.segments.iter();\n-        if defaults_to_global && p.is_global() {\n-            segments.next();\n-        }\n-\n         hir::Path {\n             def: self.expect_full_def(id),\n-            segments: segments.map(|segment| {\n+            segments: p.segments.iter().map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n                                         ParenthesizedGenericArgs::Err,\n                                         ImplTraitContext::Disallowed)\n@@ -1378,10 +1372,9 @@ impl<'a> LoweringContext<'a> {\n     fn lower_path(&mut self,\n                   id: NodeId,\n                   p: &Path,\n-                  param_mode: ParamMode,\n-                  defaults_to_global: bool)\n+                  param_mode: ParamMode)\n                   -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode, defaults_to_global)\n+        self.lower_path_extra(id, p, None, param_mode)\n     }\n \n     fn lower_path_segment(&mut self,\n@@ -1904,7 +1897,7 @@ impl<'a> LoweringContext<'a> {\n                        i: &ItemKind)\n                        -> hir::Item_ {\n         match *i {\n-            ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n+            ItemKind::ExternCrate(orig_name) => hir::ItemExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n                 // Start with an empty prefix\n                 let prefix = Path {\n@@ -2047,8 +2040,8 @@ impl<'a> LoweringContext<'a> {\n         let path = &tree.prefix;\n \n         match tree.kind {\n-            UseTreeKind::Simple(ident) => {\n-                *name = ident.name;\n+            UseTreeKind::Simple(rename) => {\n+                *name = tree.ident().name;\n \n                 // First apply the prefix to the path\n                 let mut path = Path {\n@@ -2064,12 +2057,12 @@ impl<'a> LoweringContext<'a> {\n                 if path.segments.len() > 1 &&\n                    path.segments.last().unwrap().identifier.name == keywords::SelfValue.name() {\n                     let _ = path.segments.pop();\n-                    if ident.name == keywords::SelfValue.name() {\n+                    if rename.is_none() {\n                         *name = path.segments.last().unwrap().identifier.name;\n                     }\n                 }\n \n-                let path = P(self.lower_path(id, &path, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &path, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -2080,7 +2073,7 @@ impl<'a> LoweringContext<'a> {\n                         .cloned()\n                         .collect(),\n                     span: path.span,\n-                }, ParamMode::Explicit, true));\n+                }, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -2136,7 +2129,7 @@ impl<'a> LoweringContext<'a> {\n                 // Privatize the degenerate import base, used only to check\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n-                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n                 *vis = hir::Inherited;\n                 hir::ItemUse(path, hir::UseKind::ListStem)\n             }\n@@ -3379,7 +3372,7 @@ impl<'a> LoweringContext<'a> {\n             VisibilityKind::Crate(..) => hir::Visibility::Crate,\n             VisibilityKind::Restricted { ref path, id, .. } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                     id: if let Some(owner) = explicit_owner {\n                         self.lower_node_id_with_owner(id, owner).node_id\n                     } else {"}, {"sha": "5ae84f5685eafca61a09c0716dd2de7ff76d7a56", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -2011,9 +2011,9 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n-    /// An `extern crate` item, with optional original crate name,\n+    /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n+    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ItemExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`"}, {"sha": "3d38c0c8ed9e57f396076d84786fdc54bdc13e43", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -524,15 +524,10 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n-            hir::ItemExternCrate(ref optional_path) => {\n+            hir::ItemExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n-                if let Some(p) = *optional_path {\n-                    let val = p.as_str();\n-                    if val.contains(\"-\") {\n-                        self.print_string(&val, ast::StrStyle::Cooked)?;\n-                    } else {\n-                        self.print_name(p)?;\n-                    }\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name)?;\n                     self.s.space()?;\n                     self.s.word(\"as\")?;\n                     self.s.space()?;"}, {"sha": "e764cedd658b5df4070f031fcd0f5bc33c26c663", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -851,7 +851,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n }\n \n impl_stable_hash_for!(enum hir::Item_ {\n-    ItemExternCrate(name),\n+    ItemExternCrate(orig_name),\n     ItemUse(path, use_kind),\n     ItemStatic(ty, mutability, body_id),\n     ItemConst(ty, body_id),"}, {"sha": "0d91074e946bda028c813aebb2804082c91569fe", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -385,7 +385,7 @@ top_level_options!(\n         externs: Externs [UNTRACKED],\n         crate_name: Option<String> [TRACKED],\n         // An optional name to use as the crate for std during std injection,\n-        // written `extern crate std = \"name\"`. Default to \"std\". Used by\n+        // written `extern crate name as std`. Defaults to `std`. Used by\n         // out-of-tree drivers.\n         alt_std_name: Option<String> [TRACKED],\n         // Indicates how the compiler should treat unstable features"}, {"sha": "02e704b6841856779af8b5c5696d04caa96eaf0a", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -99,7 +99,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             f.cx.item_extern_crate(f.span, f.alloc),\n             f.cx.item_use_simple(\n                 f.span,\n-                respan(f.span.empty(), VisibilityKind::Inherited),\n+                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n                 super_path,\n             ),\n         ];"}, {"sha": "710fef8db40de1e244741e9b1aa9d20abbf27514", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -683,7 +683,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     });\n \n     krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.clone();\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n         syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name)\n     });\n "}, {"sha": "bffa8628ff3530f527ff72589df83e826bcc9e76", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     if !cx.access_levels.is_reachable(it.id) {\n                         let msg = \"function is marked #[no_mangle], but not exported\";\n                         let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_FNS, it.span, msg);\n-                        let insertion_span = it.span.with_hi(it.span.lo());\n+                        let insertion_span = it.span.shrink_to_lo();\n                         if it.vis == hir::Visibility::Inherited {\n                             err.span_suggestion(insertion_span,\n                                                 \"try making it public\",\n@@ -1107,7 +1107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                    !cx.access_levels.is_reachable(it.id) {\n                        let msg = \"static is marked #[no_mangle], but not exported\";\n                        let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg);\n-                       let insertion_span = it.span.with_hi(it.span.lo());\n+                       let insertion_span = it.span.shrink_to_lo();\n                        if it.vis == hir::Visibility::Inherited {\n                            err.span_suggestion(insertion_span,\n                                                \"try making it public\","}, {"sha": "86f79c553c3917fc9249e7cd49a8c69a7445f55a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -377,11 +377,12 @@ impl UnusedImportBraces {\n             // Trigger the lint if the nested item is a non-self single item\n             let node_ident;\n             match items[0].0.kind {\n-                ast::UseTreeKind::Simple(ident) => {\n-                    if ident.name == keywords::SelfValue.name() {\n+                ast::UseTreeKind::Simple(rename) => {\n+                    let orig_ident = items[0].0.prefix.segments.last().unwrap().identifier;\n+                    if orig_ident.name == keywords::SelfValue.name() {\n                         return;\n                     } else {\n-                        node_ident = ident;\n+                        node_ident = rename.unwrap_or(orig_ident);\n                     }\n                 }\n                 ast::UseTreeKind::Glob => {"}, {"sha": "a0546b369a8ebba094105cdc45f61cbe485ee9b7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -1055,12 +1055,14 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ExternCrate(rename) => {\n-                debug!(\"resolving extern crate stmt. ident: {} rename: {:?}\", item.ident, rename);\n-                let rename = match rename {\n-                    Some(rename) => {\n-                        validate_crate_name(Some(self.sess), &rename.as_str(), Some(item.span));\n-                        rename\n+            ast::ItemKind::ExternCrate(orig_name) => {\n+                debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n+                       item.ident, orig_name);\n+                let orig_name = match orig_name {\n+                    Some(orig_name) => {\n+                        validate_crate_name(Some(self.sess), &orig_name.as_str(),\n+                                            Some(item.span));\n+                        orig_name\n                     }\n                     None => item.ident.name,\n                 };\n@@ -1071,7 +1073,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n                 };\n \n                 let (cnum, ..) = self.resolve_crate(\n-                    &None, item.ident.name, rename, None, item.span, PathKind::Crate, dep_kind,\n+                    &None, item.ident.name, orig_name, None, item.span, PathKind::Crate, dep_kind,\n                 );\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();"}, {"sha": "2de27f3a1c3eac510b32a74ba637cfaf92528185", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -533,7 +533,7 @@ impl CrateStore for cstore::CStore {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),\n-            vis: codemap::respan(local_span.empty(), ast::VisibilityKind::Inherited),\n+            vis: codemap::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             tokens: None,\n         })\n     }"}, {"sha": "8494c043f90fcd28ef2e6ea3b3b20a0d0a1dceca", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -422,7 +422,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             builder.args_and_body(block, &arguments, arg_scope, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n-        let fn_end = span.with_lo(span.hi());\n+        let fn_end = span.shrink_to_hi();\n         let source_info = builder.source_info(fn_end);\n         let return_block = builder.return_block();\n         builder.cfg.terminate(block, source_info,"}, {"sha": "c192f349c2019723f6eb2bba0679db27a4c43220", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -119,7 +119,8 @@ impl<'a> Resolver<'a> {\n             .collect();\n \n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(mut ident) => {\n+            ast::UseTreeKind::Simple(rename) => {\n+                let mut ident = use_tree.ident();\n                 let mut source = module_path.pop().unwrap().node;\n                 let mut type_ns_only = false;\n \n@@ -142,7 +143,7 @@ impl<'a> Resolver<'a> {\n                         // Replace `use foo::self;` with `use foo;`\n                         let _ = module_path.pop();\n                         source = last_segment.node;\n-                        if ident.name == keywords::SelfValue.name() {\n+                        if rename.is_none() {\n                             ident = last_segment.node;\n                         }\n                     }\n@@ -162,7 +163,7 @@ impl<'a> Resolver<'a> {\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n                         source.name = crate_name;\n-                        if ident.name == keywords::DollarCrate.name() {\n+                        if rename.is_none() {\n                             ident.name = crate_name;\n                         }\n \n@@ -206,8 +207,8 @@ impl<'a> Resolver<'a> {\n \n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n-                    if let ast::UseTreeKind::Simple(ident) = use_tree.kind {\n-                        if ident.name == keywords::SelfValue.name() {\n+                    if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n+                        if use_tree.ident().name == keywords::SelfValue.name() {\n                             return Some(use_tree.span);\n                         }\n                     }\n@@ -244,9 +245,9 @@ impl<'a> Resolver<'a> {\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n-                // Just an empty prefix to start out\n+                // Imports are resolved as global by default, add starting root segment.\n                 let prefix = ast::Path {\n-                    segments: vec![],\n+                    segments: use_tree.prefix.make_root().into_iter().collect(),\n                     span: use_tree.span,\n                 };\n \n@@ -255,7 +256,7 @@ impl<'a> Resolver<'a> {\n                 );\n             }\n \n-            ItemKind::ExternCrate(as_name) => {\n+            ItemKind::ExternCrate(orig_name) => {\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n@@ -274,7 +275,7 @@ impl<'a> Resolver<'a> {\n                     id: item.id,\n                     parent,\n                     imported_module: Cell::new(Some(module)),\n-                    subclass: ImportDirectiveSubclass::ExternCrate(as_name),\n+                    subclass: ImportDirectiveSubclass::ExternCrate(orig_name),\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),"}, {"sha": "dc22c23271d63855639e095e76df63fc701f8a18", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -756,7 +756,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if item.span.ctxt().outer().expn_info().is_none() {\n-                        self.span = Some(item.span.with_hi(item.span.lo()));\n+                        self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n                     }\n@@ -768,12 +768,12 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                     if item.span.ctxt().outer().expn_info().is_none() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n-                            self.span = Some(item.span.with_hi(item.span.lo()));\n+                            self.span = Some(item.span.shrink_to_lo());\n                         } else {\n                             // find the first attribute on the item\n                             for attr in &item.attrs {\n                                 if self.span.map_or(true, |span| attr.span < span) {\n-                                    self.span = Some(attr.span.with_hi(attr.span.lo()));\n+                                    self.span = Some(attr.span.shrink_to_lo());\n                                 }\n                             }\n                         }\n@@ -2164,8 +2164,9 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::Use(ref use_tree) => {\n+                // Imports are resolved as global by default, add starting root segment.\n                 let path = Path {\n-                    segments: vec![],\n+                    segments: use_tree.prefix.make_root().into_iter().collect(),\n                     span: use_tree.span,\n                 };\n                 self.resolve_use_tree(item.id, use_tree, &path);\n@@ -2300,7 +2301,6 @@ impl<'a> Resolver<'a> {\n                 None,\n                 &path,\n                 trait_ref.path.span,\n-                trait_ref.path.segments.last().unwrap().span,\n                 PathSource::Trait(AliasPossibility::No)\n             ).base_def();\n             if def != Def::Err {\n@@ -2731,18 +2731,17 @@ impl<'a> Resolver<'a> {\n         let segments = &path.segments.iter()\n             .map(|seg| respan(seg.span, seg.identifier))\n             .collect::<Vec<_>>();\n-        let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[SpannedIdent],\n                                    span: Span,\n-                                   ident_span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n+        let ident_span = path.last().map_or(span, |ident| ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n@@ -3090,7 +3089,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, span, PathSource::TraitItem(ns));\n+                                                       span, PathSource::TraitItem(ns));\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -3941,8 +3940,12 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n-                let def = self.smart_resolve_path(id, None, path,\n-                                                  PathSource::Visibility).base_def();\n+                // Visibilities are resolved as global by default, add starting root segment.\n+                let segments = path.make_root().iter().chain(path.segments.iter())\n+                    .map(|seg| respan(seg.span, seg.identifier))\n+                    .collect::<Vec<_>>();\n+                let def = self.smart_resolve_path_fragment(id, None, &segments, path.span,\n+                                                           PathSource::Visibility).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {"}, {"sha": "4cbebdc3c1c39f9458fb732e4e0da80bf471d2f7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -667,11 +667,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                if !self_path.is_empty() &&\n-                    !token::Ident(self_path[0].node).is_path_segment_keyword() &&\n-                    !(self_path.len() > 1 &&\n-                      token::Ident(self_path[1].node).is_path_segment_keyword())\n-                {\n+                let is_special = |ident| token::Ident(ident).is_path_segment_keyword() &&\n+                                         ident.name != keywords::CrateRoot.name();\n+                if !self_path.is_empty() && !is_special(self_path[0].node) &&\n+                   !(self_path.len() > 1 && is_special(self_path[1].node)) {\n                     self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }"}, {"sha": "3d4d8571c6e4242283bea932777f3e3c30ae9b4a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -1209,7 +1209,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n-        let vis_span = trait_item.span.empty();\n+        let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.node {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n@@ -1342,7 +1342,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             .map(::id_from_def_id);\n \n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(ident) => {\n+            ast::UseTreeKind::Simple(..) => {\n+                let ident = use_tree.ident();\n                 let path = ast::Path {\n                     segments: prefix.segments\n                         .iter()"}, {"sha": "61afac97d6409b337a19522d934bc35519645f9e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -767,7 +767,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if item.span.ctxt().outer().expn_info().is_none() {\n-                        self.span = Some(item.span.with_hi(item.span.lo()));\n+                        self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n                     }\n@@ -779,12 +779,12 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                     if item.span.ctxt().outer().expn_info().is_none() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n-                            self.span = Some(item.span.with_hi(item.span.lo()));\n+                            self.span = Some(item.span.shrink_to_lo());\n                         } else {\n                             // find the first attribute on the item\n                             for attr in &item.attrs {\n                                 if self.span.map_or(true, |span| attr.span < span) {\n-                                    self.span = Some(attr.span.with_hi(attr.span.lo()));\n+                                    self.span = Some(attr.span.shrink_to_lo());\n                                 }\n                             }\n                         }"}, {"sha": "4a685cfddb7a42f5e760d8a4427d26b622064335", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -2520,7 +2520,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if sugg_unit {\n                 let sugg_span = sess.codemap().end_point(expr_sp);\n                 // remove closing `)` from the span\n-                let sugg_span = sugg_span.with_hi(sugg_span.lo());\n+                let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n                     sugg_span,\n                     \"expected the unit value `()`; create it with empty parentheses\","}, {"sha": "f45a5b030db2bf354b0095e5ccc58c7004826bcd", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -406,13 +406,13 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             // If we're inlining, skip private items.\n             _ if self.inlining && item.vis != hir::Public => {}\n             hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExternCrate(ref p) => {\n+            hir::ItemExternCrate(orig_name) => {\n                 let def_id = self.cx.tcx.hir.local_def_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n                     name,\n-                    path: p.map(|x|x.to_string()),\n+                    path: orig_name.map(|x|x.to_string()),\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     whence: item.span,"}, {"sha": "1f16b728cd23951cec66be533adae4fe0b6217e4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -108,17 +108,16 @@ impl Path {\n         }\n     }\n \n-    // Add starting \"crate root\" segment to all paths except those that\n-    // already have it or start with `self`, `super`, `Self` or `$crate`.\n-    pub fn default_to_global(mut self) -> Path {\n-        if !self.is_global() {\n-            let ident = self.segments[0].identifier;\n-            if !::parse::token::Ident(ident).is_path_segment_keyword() ||\n-               ident.name == keywords::Crate.name() {\n-                self.segments.insert(0, PathSegment::crate_root(self.span));\n+    // Make a \"crate root\" segment for this path unless it already has it\n+    // or starts with something like `self`/`super`/`$crate`/etc.\n+    pub fn make_root(&self) -> Option<PathSegment> {\n+        if let Some(ident) = self.segments.get(0).map(|seg| seg.identifier) {\n+            if ::parse::token::Ident(ident).is_path_segment_keyword() &&\n+               ident.name != keywords::Crate.name() {\n+                return None;\n             }\n         }\n-        self\n+        Some(PathSegment::crate_root(self.span.shrink_to_lo()))\n     }\n \n     pub fn is_global(&self) -> bool {\n@@ -1878,20 +1877,37 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n+/// Part of `use` item to the right of its prefix.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum UseTreeKind {\n-    Simple(Ident),\n-    Glob,\n+    /// `use prefix` or `use prefix as rename`\n+    Simple(Option<Ident>),\n+    /// `use prefix::{...}`\n     Nested(Vec<(UseTree, NodeId)>),\n+    /// `use prefix::*`\n+    Glob,\n }\n \n+/// A tree of paths sharing common prefixes.\n+/// Used in `use` items both at top-level and inside of braces in import groups.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct UseTree {\n-    pub kind: UseTreeKind,\n     pub prefix: Path,\n+    pub kind: UseTreeKind,\n     pub span: Span,\n }\n \n+impl UseTree {\n+    pub fn ident(&self) -> Ident {\n+        match self.kind {\n+            UseTreeKind::Simple(Some(rename)) => rename,\n+            UseTreeKind::Simple(None) =>\n+                self.prefix.segments.last().expect(\"empty prefix in a simple import\").identifier,\n+            _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n+        }\n+    }\n+}\n+\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n@@ -2055,7 +2071,7 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n-    /// An `extern crate` item, with optional original crate name.\n+    /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ExternCrate(Option<Name>),"}, {"sha": "2c91844da96d70ecec36f6b9aa113ec102ad37a5", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -220,7 +220,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 ty,\n                 expr,\n             ),\n-            vis: codemap::respan(span.empty(), ast::VisibilityKind::Public),\n+            vis: codemap::respan(span.shrink_to_lo(), ast::VisibilityKind::Public),\n             span,\n             tokens: None,\n         })"}, {"sha": "9b53553bf69d723b6d921078f60f4124180e06b3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -294,7 +294,7 @@ pub trait AstBuilder {\n                 vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item>;\n     fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n     fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> P<ast::Item>;\n+                        ident: Option<ast::Ident>, path: ast::Path) -> P<ast::Item>;\n     fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item>;\n     fn item_use_glob(&self, sp: Span,\n@@ -329,9 +329,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             None\n         };\n         segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n-        let path = ast::Path { span, segments };\n-\n-        if global { path.default_to_global() } else { path }\n+        let mut path = ast::Path { span, segments };\n+        if global {\n+            if let Some(seg) = path.make_root() {\n+                path.segments.insert(0, seg);\n+            }\n+        }\n+        path\n     }\n \n     /// Constructs a qualified path.\n@@ -983,7 +987,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n             node,\n-            vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n+            vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             span,\n             tokens: None,\n         })\n@@ -1029,7 +1033,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 span: ty.span,\n                 ty,\n                 ident: None,\n-                vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n+                vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n             }\n@@ -1159,16 +1163,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n-        let last = path.segments.last().unwrap().identifier;\n-        self.item_use_simple_(sp, vis, last, path)\n+        self.item_use_simple_(sp, vis, None, path)\n     }\n \n     fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> P<ast::Item> {\n+                        rename: Option<ast::Ident>, path: ast::Path) -> P<ast::Item> {\n         self.item_use(sp, vis, P(ast::UseTree {\n             span: sp,\n             prefix: path,\n-            kind: ast::UseTreeKind::Simple(ident),\n+            kind: ast::UseTreeKind::Simple(rename),\n         }))\n     }\n \n@@ -1178,7 +1181,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             (ast::UseTree {\n                 span: sp,\n                 prefix: self.path(sp, vec![*id]),\n-                kind: ast::UseTreeKind::Simple(*id),\n+                kind: ast::UseTreeKind::Simple(None),\n             }, ast::DUMMY_NODE_ID)\n         }).collect();\n "}, {"sha": "34dd7696168a6d431ba160010d3ff3b17d00f2d1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             node: ast::ItemKind::Mod(krate.module),\n             ident: keywords::Invalid.ident(),\n             id: ast::DUMMY_NODE_ID,\n-            vis: respan(krate.span.empty(), ast::VisibilityKind::Public),\n+            vis: respan(krate.span.shrink_to_lo(), ast::VisibilityKind::Public),\n             tokens: None,\n         })));\n "}, {"sha": "6844532e7b375ece36530f74a3d9c56dfb85e9ef", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -857,7 +857,7 @@ fn expand_wrapper(cx: &ExtCtxt,\n         let path = path.iter().map(|s| s.to_string()).collect();\n         let use_item = cx.item_use_glob(\n             sp,\n-            respan(sp.empty(), ast::VisibilityKind::Inherited),\n+            respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             ids_ext(path),\n         );\n         cx.stmt_item(sp, use_item)"}, {"sha": "a5af8564057f61cfbb1b71a077e649f593c6f3d4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -1438,7 +1438,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_use_tree(&mut self, use_tree: &'a ast::UseTree, id: NodeId, _nested: bool) {\n-        if let ast::UseTreeKind::Simple(ident) = use_tree.kind {\n+        if let ast::UseTreeKind::Simple(Some(ident)) = use_tree.kind {\n             if ident.name == \"_\" {\n                 gate_feature_post!(&self, underscore_imports, use_tree.span,\n                                    \"renaming imports with `_` is unstable\");"}, {"sha": "46e6027b094bc2d7a8e94713e1df71ef3081d59b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -323,7 +323,8 @@ pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree\n         span: fld.new_span(use_tree.span),\n         prefix: fld.fold_path(use_tree.prefix),\n         kind: match use_tree.kind {\n-            UseTreeKind::Simple(ident) => UseTreeKind::Simple(fld.fold_ident(ident)),\n+            UseTreeKind::Simple(rename) =>\n+                UseTreeKind::Simple(rename.map(|ident| fld.fold_ident(ident))),\n             UseTreeKind::Glob => UseTreeKind::Glob,\n             UseTreeKind::Nested(items) => UseTreeKind::Nested(items.move_map(|(tree, id)| {\n                 (fld.fold_use_tree(tree), fld.new_id(id))\n@@ -886,7 +887,7 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n \n pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n     match i {\n-        ItemKind::ExternCrate(string) => ItemKind::ExternCrate(string),\n+        ItemKind::ExternCrate(orig_name) => ItemKind::ExternCrate(orig_name),\n         ItemKind::Use(use_tree) => {\n             ItemKind::Use(use_tree.map(|tree| folder.fold_use_tree(tree)))\n         }\n@@ -1018,7 +1019,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         ident: keywords::Invalid.ident(),\n         attrs,\n         id: ast::DUMMY_NODE_ID,\n-        vis: respan(span.empty(), ast::VisibilityKind::Public),\n+        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Public),\n         span,\n         node: ast::ItemKind::Mod(module),\n         tokens: None,"}, {"sha": "0e20eb49d395ed213211ff0a02ce52be7ee3e748", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -214,7 +214,7 @@ impl<'a> StringReader<'a> {\n \n         // Make the range zero-length if the span is invalid.\n         if span.lo() > span.hi() || begin.fm.start_pos != end.fm.start_pos {\n-            span = span.with_hi(span.lo());\n+            span = span.shrink_to_lo();\n         }\n \n         let mut sr = StringReader::new_raw_internal(sess, begin.fm);"}, {"sha": "f7e5d40b52468821e79a28e324a01cdd866fdb1f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -713,7 +713,7 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Path(None, ast::Path {\n                             span: sp(0, 6),\n-                            segments: vec![ast::PathSegment::crate_root(sp(0, 2)),\n+                            segments: vec![ast::PathSegment::crate_root(sp(0, 0)),\n                                         str2seg(\"a\", 2, 3),\n                                         str2seg(\"b\", 5, 6)]\n                         }),"}, {"sha": "cb5010a638df4f67b899c06b824009c326d60415", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 36, "deletions": 80, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -1508,7 +1508,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::RArrow) {\n             Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true)?))\n         } else {\n-            Ok(FunctionRetTy::Default(self.span.with_hi(self.span.lo())))\n+            Ok(FunctionRetTy::Default(self.span.shrink_to_lo()))\n         }\n     }\n \n@@ -1986,7 +1986,7 @@ impl<'a> Parser<'a> {\n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo));\n+            segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -2021,7 +2021,7 @@ impl<'a> Parser<'a> {\n         loop {\n             segments.push(self.parse_path_segment(style, enable_warning)?);\n \n-            if self.is_import_coupler(false) || !self.eat(&token::ModSep) {\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n                 return Ok(());\n             }\n         }\n@@ -5863,7 +5863,7 @@ impl<'a> Parser<'a> {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n-                let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `path`\n+                let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n@@ -5876,7 +5876,7 @@ impl<'a> Parser<'a> {\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n-                let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `super`/`self`\n+                let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n@@ -6285,23 +6285,17 @@ impl<'a> Parser<'a> {\n                                lo: Span,\n                                visibility: Visibility,\n                                attrs: Vec<Attribute>)\n-                                -> PResult<'a, P<Item>> {\n-\n-        let crate_name = self.parse_ident()?;\n-        let (maybe_path, ident) = if let Some(ident) = self.parse_rename()? {\n-            (Some(crate_name.name), ident)\n+                               -> PResult<'a, P<Item>> {\n+        let orig_name = self.parse_ident()?;\n+        let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n+            (rename, Some(orig_name.name))\n         } else {\n-            (None, crate_name)\n+            (orig_name, None)\n         };\n         self.expect(&token::Semi)?;\n \n-        let prev_span = self.prev_span;\n-\n-        Ok(self.mk_item(lo.to(prev_span),\n-                        ident,\n-                        ItemKind::ExternCrate(maybe_path),\n-                        visibility,\n-                        attrs))\n+        let span = lo.to(self.prev_span);\n+        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n     }\n \n     /// Parse `extern` for foreign ABIs\n@@ -6480,12 +6474,11 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree(false)?));\n+            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n-            let prev_span = self.prev_span;\n-            let invalid = keywords::Invalid.ident();\n-            let item = self.mk_item(lo.to(prev_span), invalid, item_, visibility, attrs);\n+            let span = lo.to(self.prev_span);\n+            let item = self.mk_item(span, keywords::Invalid.ident(), item_, visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -6960,90 +6953,53 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// `{` or `::{` or `*` or `::*`\n-    /// `::{` or `::*` (also `{`  or `*` if unprefixed is true)\n-    fn is_import_coupler(&mut self, unprefixed: bool) -> bool {\n-        self.is_import_coupler_inner(&token::OpenDelim(token::Brace), unprefixed) ||\n-            self.is_import_coupler_inner(&token::BinOp(token::Star), unprefixed)\n-    }\n-\n-    fn is_import_coupler_inner(&mut self, token: &token::Token, unprefixed: bool) -> bool {\n-        if self.check(&token::ModSep) {\n-            self.look_ahead(1, |t| t == token)\n-        } else if unprefixed {\n-            self.check(token)\n-        } else {\n-            false\n-        }\n+    /// `::{` or `::*`\n+    fn is_import_coupler(&mut self) -> bool {\n+        self.check(&token::ModSep) &&\n+            self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n+                                   *t == token::BinOp(token::Star))\n     }\n \n     /// Parse UseTree\n     ///\n-    /// USE_TREE = `*` |\n-    ///            `{` USE_TREE_LIST `}` |\n+    /// USE_TREE = [`::`] `*` |\n+    ///            [`::`] `{` USE_TREE_LIST `}` |\n     ///            PATH `::` `*` |\n     ///            PATH `::` `{` USE_TREE_LIST `}` |\n     ///            PATH [`as` IDENT]\n-    fn parse_use_tree(&mut self, nested: bool) -> PResult<'a, UseTree> {\n+    fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n         let lo = self.span;\n \n-        let mut prefix = ast::Path {\n-            segments: vec![],\n-            span: lo.to(self.span),\n-        };\n-\n-        let kind = if self.is_import_coupler(true) {\n-            // `use *;` or `use ::*;` or `use {...};` `use ::{...};`\n-\n-            // Remove the first `::`\n+        let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n+        let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n+                      self.check(&token::BinOp(token::Star)) ||\n+                      self.is_import_coupler() {\n+            // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n             if self.eat(&token::ModSep) {\n-                prefix.segments.push(PathSegment::crate_root(self.prev_span));\n-            } else if !nested {\n-                prefix.segments.push(PathSegment::crate_root(self.span));\n+                prefix.segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n             }\n \n             if self.eat(&token::BinOp(token::Star)) {\n-                // `use *;`\n                 UseTreeKind::Glob\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n-                // `use {...};`\n-                UseTreeKind::Nested(self.parse_use_tree_list()?)\n             } else {\n-                return self.unexpected();\n+                UseTreeKind::Nested(self.parse_use_tree_list()?)\n             }\n         } else {\n-            // `use path::...;`\n-            let mut parsed = self.parse_path(PathStyle::Mod)?;\n-            if !nested {\n-                parsed = parsed.default_to_global();\n-            }\n-\n-            prefix.segments.append(&mut parsed.segments);\n-            prefix.span = prefix.span.to(parsed.span);\n+            // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n+            prefix = self.parse_path(PathStyle::Mod)?;\n \n             if self.eat(&token::ModSep) {\n                 if self.eat(&token::BinOp(token::Star)) {\n-                    // `use path::*;`\n                     UseTreeKind::Glob\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    // `use path::{...};`\n-                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 } else {\n-                    return self.unexpected();\n+                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 }\n             } else {\n-                // `use path::foo;` or `use path::foo as bar;`\n-                let rename = self.parse_rename()?.\n-                                  unwrap_or(prefix.segments.last().unwrap().identifier);\n-                UseTreeKind::Simple(rename)\n+                UseTreeKind::Simple(self.parse_rename()?)\n             }\n         };\n \n-        Ok(UseTree {\n-            span: lo.to(self.prev_span),\n-            kind,\n-            prefix,\n-        })\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n     }\n \n     /// Parse UseTreeKind::Nested(list)\n@@ -7053,7 +7009,7 @@ impl<'a> Parser<'a> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n                                  &token::CloseDelim(token::Brace),\n                                  SeqSep::trailing_allowed(token::Comma), |this| {\n-            Ok((this.parse_use_tree(true)?, ast::DUMMY_NODE_ID))\n+            Ok((this.parse_use_tree()?, ast::DUMMY_NODE_ID))\n         })\n     }\n "}, {"sha": "4ada9e20f2cc0db63af93a20cf04bdf6be3e9856", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -361,6 +361,7 @@ impl Token {\n                         id.name == keywords::SelfType.name() ||\n                         id.name == keywords::Extern.name() ||\n                         id.name == keywords::Crate.name() ||\n+                        id.name == keywords::CrateRoot.name() ||\n                         id.name == keywords::DollarCrate.name(),\n             None => false,\n         }"}, {"sha": "7adb2848f8d94fae5f43842e0b3693f293bb56db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -352,7 +352,7 @@ pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0, false))\n+    to_string(|s| s.print_path(p, false, 0))\n }\n \n pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n@@ -1050,7 +1050,7 @@ impl<'a> State<'a> {\n                                  &f.generic_params)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n-                self.print_path(path, false, 0, false)?;\n+                self.print_path(path, false, 0)?;\n             }\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?\n@@ -1173,15 +1173,10 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n-            ast::ItemKind::ExternCrate(ref optional_path) => {\n+            ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n-                if let Some(p) = *optional_path {\n-                    let val = p.as_str();\n-                    if val.contains('-') {\n-                        self.print_string(&val, ast::StrStyle::Cooked)?;\n-                    } else {\n-                        self.print_name(p)?;\n-                    }\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name)?;\n                     self.s.space()?;\n                     self.s.word(\"as\")?;\n                     self.s.space()?;\n@@ -1382,7 +1377,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n@@ -1407,7 +1402,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0, false)\n+        self.print_path(&t.path, false, 0)\n     }\n \n     fn print_formal_generic_params(\n@@ -1464,7 +1459,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\")\n             }\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = to_string(|s| s.print_path(path, false, 0, true));\n+                let path = to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(&format!(\"pub({})\", path))\n                 } else {\n@@ -1572,7 +1567,7 @@ impl<'a> State<'a> {\n                     ti.ident,\n                     ty,\n                     default.as_ref().map(|expr| &**expr),\n-                    &codemap::respan(ti.span.empty(), ast::VisibilityKind::Inherited),\n+                    &codemap::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 )?;\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n@@ -1583,7 +1578,7 @@ impl<'a> State<'a> {\n                     ti.ident,\n                     &ti.generics,\n                     sig,\n-                    &codemap::respan(ti.span.empty(), ast::VisibilityKind::Inherited),\n+                    &codemap::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 )?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n@@ -1598,7 +1593,7 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n@@ -1632,7 +1627,7 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n@@ -1818,7 +1813,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n-        self.print_path(&m.node.path, false, 0, false)?;\n+        self.print_path(&m.node.path, false, 0)?;\n         self.s.word(\"!\")?;\n         match delim {\n             token::Paren => self.popen()?,\n@@ -1919,7 +1914,7 @@ impl<'a> State<'a> {\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>,\n                          attrs: &[Attribute]) -> io::Result<()> {\n-        self.print_path(path, true, 0, false)?;\n+        self.print_path(path, true, 0)?;\n         self.s.word(\"{\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_cmnt(\n@@ -2240,7 +2235,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0, false)?\n+                self.print_path(path, true, 0)?\n             }\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n@@ -2400,17 +2395,12 @@ impl<'a> State<'a> {\n     fn print_path(&mut self,\n                   path: &ast::Path,\n                   colons_before_params: bool,\n-                  depth: usize,\n-                  defaults_to_global: bool)\n+                  depth: usize)\n                   -> io::Result<()>\n     {\n         self.maybe_print_comment(path.span.lo())?;\n \n-        let mut segments = path.segments[..path.segments.len()-depth].iter();\n-        if defaults_to_global && path.is_global() {\n-            segments.next();\n-        }\n-        for (i, segment) in segments.enumerate() {\n+        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n@@ -2449,7 +2439,7 @@ impl<'a> State<'a> {\n             self.s.space()?;\n             self.word_space(\"as\")?;\n             let depth = path.segments.len() - qself.position;\n-            self.print_path(path, false, depth, false)?;\n+            self.print_path(path, false, depth)?;\n         }\n         self.s.word(\">\")?;\n         self.s.word(\"::\")?;\n@@ -2552,7 +2542,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p))?;\n@@ -2570,13 +2560,13 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             PatKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n             }\n             PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?;\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(\n@@ -2953,18 +2943,17 @@ impl<'a> State<'a> {\n \n     pub fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n         match tree.kind {\n-            ast::UseTreeKind::Simple(ref ident) => {\n-                self.print_path(&tree.prefix, false, 0, true)?;\n-\n-                if tree.prefix.segments.last().unwrap().identifier.name != ident.name {\n+            ast::UseTreeKind::Simple(rename) => {\n+                self.print_path(&tree.prefix, false, 0)?;\n+                if let Some(rename) = rename {\n                     self.s.space()?;\n                     self.word_space(\"as\")?;\n-                    self.print_ident(*ident)?;\n+                    self.print_ident(rename)?;\n                 }\n             }\n             ast::UseTreeKind::Glob => {\n                 if !tree.prefix.segments.is_empty() {\n-                    self.print_path(&tree.prefix, false, 0, true)?;\n+                    self.print_path(&tree.prefix, false, 0)?;\n                     self.s.word(\"::\")?;\n                 }\n                 self.s.word(\"*\")?;\n@@ -2973,7 +2962,7 @@ impl<'a> State<'a> {\n                 if tree.prefix.segments.is_empty() {\n                     self.s.word(\"{\")?;\n                 } else {\n-                    self.print_path(&tree.prefix, false, 0, true)?;\n+                    self.print_path(&tree.prefix, false, 0)?;\n                     self.s.word(\"::{\")?;\n                 }\n                 self.commasep(Inconsistent, &items[..], |this, &(ref tree, _)| {"}, {"sha": "fdbc795b2d365500e81ac29da08ba6733008de8f", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -43,7 +43,7 @@ thread_local! {\n     static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n }\n \n-pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<String>) -> ast::Crate {\n+pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>) -> ast::Crate {\n     let name = if attr::contains_name(&krate.attrs, \"no_core\") {\n         return krate;\n     } else if attr::contains_name(&krate.attrs, \"no_std\") {\n@@ -54,14 +54,12 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let crate_name = Symbol::intern(&alt_std_name.unwrap_or_else(|| name.to_string()));\n-\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                         attr::mk_attr_id(),\n                                         attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n         vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-        node: ast::ItemKind::ExternCrate(Some(crate_name)),\n+        node: ast::ItemKind::ExternCrate(alt_std_name.map(Symbol::intern)),\n         ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n@@ -78,10 +76,10 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n             is_sugared_doc: false,\n             span,\n         }],\n-        vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n+        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                segments: [name, \"prelude\", \"v1\"].into_iter().map(|name| {\n                     ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n                 }).collect(),\n                 span,"}, {"sha": "9edfa767d31958df8c0ff07e7850c49708c072b0", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -78,7 +78,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n                           span_diagnostic: &errors::Handler,\n                           features: &Features) -> ast::Crate {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n-    // creates a `use some_name = __test::main;`. This needs to be\n+    // creates a `use __test::main as some_name;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n@@ -240,7 +240,8 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public), r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n+                                   Some(r), path)\n     })).collect();\n \n     let reexport_mod = ast::Mod {\n@@ -502,7 +503,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         (ast::ItemKind::Use(P(ast::UseTree {\n             span: DUMMY_SP,\n             prefix: path_node(vec![id_test]),\n-            kind: ast::UseTreeKind::Simple(id_test),\n+            kind: ast::UseTreeKind::Simple(None),\n         })),\n          ast::VisibilityKind::Public, keywords::Invalid.ident())\n     } else {\n@@ -590,13 +591,13 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         tokens: None,\n     })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.map(|s| {\n-        // building `use <ident> = __test::main`\n-        let reexport_ident = Ident::with_empty_ctxt(s);\n+        // building `use __test::main as <ident>;`\n+        let rename = Ident::with_empty_ctxt(s);\n \n         let use_path = ast::UseTree {\n             span: DUMMY_SP,\n             prefix: path_node(vec![mod_ident, Ident::from_str(\"main\")]),\n-            kind: ast::UseTreeKind::Simple(reexport_ident),\n+            kind: ast::UseTreeKind::Simple(Some(rename)),\n         };\n \n         expander.fold_item(P(ast::Item {"}, {"sha": "bbf1fe124f1ba3f4f4b29fe124873bc3dab25bc6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -213,9 +213,9 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemKind::ExternCrate(opt_name) => {\n-            if let Some(name) = opt_name {\n-                visitor.visit_name(item.span, name);\n+        ItemKind::ExternCrate(orig_name) => {\n+            if let Some(orig_name) = orig_name {\n+                visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemKind::Use(ref use_tree) => {\n@@ -354,10 +354,11 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n     visitor: &mut V, use_tree: &'a UseTree, id: NodeId,\n ) {\n     visitor.visit_path(&use_tree.prefix, id);\n-\n     match use_tree.kind {\n-        UseTreeKind::Simple(ident) => {\n-            visitor.visit_ident(use_tree.span, ident);\n+        UseTreeKind::Simple(rename) => {\n+            if let Some(rename) = rename {\n+                visitor.visit_ident(use_tree.span, rename);\n+            }\n         }\n         UseTreeKind::Glob => {},\n         UseTreeKind::Nested(ref use_trees) => {"}, {"sha": "49c372b751b506d4b694807aefddaf20810a2bda", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -530,7 +530,7 @@ impl<'a> TraitDef<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident,\n-                vis: respan(self.span.empty(), ast::VisibilityKind::Inherited),\n+                vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 generics: Generics::default(),\n@@ -977,7 +977,7 @@ impl<'a> MethodDef<'a> {\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n             span: trait_.span,\n-            vis: respan(trait_.span.empty(), ast::VisibilityKind::Inherited),\n+            vis: respan(trait_.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {"}, {"sha": "f01a0aacb0a734a5cc2337d55bd82779b796d409", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -60,7 +60,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n             asm,\n             ctxt: cx.backtrace(),\n         })),\n-        vis: respan(sp.empty(), ast::VisibilityKind::Inherited),\n+        vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         span: sp,\n         tokens: None,\n     })))"}, {"sha": "9b83d5510fb7d836dec3d37406c80dc7b21ef566", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -239,8 +239,15 @@ impl Span {\n \n     /// Returns a new span representing an empty span at the beginning of this span\n     #[inline]\n-    pub fn empty(self) -> Span {\n-        self.with_hi(self.lo())\n+    pub fn shrink_to_lo(self) -> Span {\n+        let span = self.data();\n+        span.with_hi(span.lo)\n+    }\n+    /// Returns a new span representing an empty span at the end of this span\n+    #[inline]\n+    pub fn shrink_to_hi(self) -> Span {\n+        let span = self.data();\n+        span.with_lo(span.hi)\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise."}, {"sha": "214a03c13f4e56bde68d486ad77b99e0427e2687", "filename": "src/test/compile-fail/lint-unnecessary-import-braces.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-import-braces.rs?ref=5e3ecdce4e42ccc34c49f32f81be71ae00f2cf11", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n #![deny(unused_import_braces)]\n-#![allow(dead_code)]\n-#![allow(unused_imports)]\n \n use test::{A}; //~ ERROR braces around A is unnecessary\n \n mod test {\n+    use test::{self}; // OK\n+    use test::{self as rename}; // OK\n     pub struct A;\n }\n "}]}