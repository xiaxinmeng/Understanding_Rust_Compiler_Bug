{"sha": "48947eafda511bf7acb43eff63b8ff61de1816d3", "node_id": "C_kwDOAAsO6NoAKDQ4OTQ3ZWFmZGE1MTFiZjdhY2I0M2VmZjYzYjhmZjYxZGUxODE2ZDM", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-11-19T04:06:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-19T04:06:34Z"}, "message": "Rollup merge of #90633 - tmiasko:candidate-struct, r=nagisa\n\nRefactor single variant `Candidate` enum into a struct\n\n`Candidate` enum has only a single `Ref` variant.  Refactor it into a\nstruct and reduce overall indentation of the code by two levels.\n\nNo functional changes.", "tree": {"sha": "5689a6bd7f0e1fbc7a213664b92be764747fcd05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5689a6bd7f0e1fbc7a213664b92be764747fcd05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48947eafda511bf7acb43eff63b8ff61de1816d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlyLKCRBK7hj4Ov3rIwAAmIQIABIcYi8C3iQnWgX5/R3PakQF\nf8k2KenR0VTEmIYwOj3gYw7EclXuJxbSGyrnQFva7ATpA+5gW932bn5Z9i9M1Yg8\ntY7AyI6nmGC+MzcV67Iy1Gmznw9G0l0QbJW4O3SepoQaaPPyyoGQspyXbAihPfL+\nzPzxp0jFL/L2RkOUmm5l/uNgUiRt18PWn801fGsPCPnL3JnuEjG+mNKOhnUl+MDK\nkf5Ut1LWTx6OqfoTib83oik9WlFZjuFPReR2ixc0R+EyTDupjwqCltSNEKOzr25W\nr5GmFVXpsTx+ShUV4ycB8lmt8Ec0WyKZJKwu6n6TQGuOT14Gk+pDcTfle2wo+A8=\n=sbZF\n-----END PGP SIGNATURE-----\n", "payload": "tree 5689a6bd7f0e1fbc7a213664b92be764747fcd05\nparent 81fd01684820b3937f6ae5e281b844ffbe5e1377\nparent 59edb9d38280eed96a3012f3ea2a46cb8c254218\nauthor Yuki Okushi <jtitor@2k36.org> 1637294794 +0900\ncommitter GitHub <noreply@github.com> 1637294794 +0900\n\nRollup merge of #90633 - tmiasko:candidate-struct, r=nagisa\n\nRefactor single variant `Candidate` enum into a struct\n\n`Candidate` enum has only a single `Ref` variant.  Refactor it into a\nstruct and reduce overall indentation of the code by two levels.\n\nNo functional changes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48947eafda511bf7acb43eff63b8ff61de1816d3", "html_url": "https://github.com/rust-lang/rust/commit/48947eafda511bf7acb43eff63b8ff61de1816d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48947eafda511bf7acb43eff63b8ff61de1816d3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81fd01684820b3937f6ae5e281b844ffbe5e1377", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fd01684820b3937f6ae5e281b844ffbe5e1377", "html_url": "https://github.com/rust-lang/rust/commit/81fd01684820b3937f6ae5e281b844ffbe5e1377"}, {"sha": "59edb9d38280eed96a3012f3ea2a46cb8c254218", "url": "https://api.github.com/repos/rust-lang/rust/commits/59edb9d38280eed96a3012f3ea2a46cb8c254218", "html_url": "https://github.com/rust-lang/rust/commit/59edb9d38280eed96a3012f3ea2a46cb8c254218"}], "stats": {"total": 183, "additions": 82, "deletions": 101}, "files": [{"sha": "a92b20f5cb520ae147c0ddfd3be48fc532738870", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 82, "deletions": 101, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/48947eafda511bf7acb43eff63b8ff61de1816d3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48947eafda511bf7acb43eff63b8ff61de1816d3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=48947eafda511bf7acb43eff63b8ff61de1816d3", "patch": "@@ -93,17 +93,8 @@ impl TempState {\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Candidate {\n-    /// Borrow of a constant temporary, candidate for lifetime extension.\n-    Ref(Location),\n-}\n-\n-impl Candidate {\n-    fn source_info(&self, body: &Body<'_>) -> SourceInfo {\n-        match self {\n-            Candidate::Ref(location) => *body.source_info(*location),\n-        }\n-    }\n+pub struct Candidate {\n+    location: Location,\n }\n \n struct Collector<'a, 'tcx> {\n@@ -167,7 +158,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n \n         match *rvalue {\n             Rvalue::Ref(..) => {\n-                self.candidates.push(Candidate::Ref(location));\n+                self.candidates.push(Candidate { location });\n             }\n             _ => {}\n         }\n@@ -209,36 +200,33 @@ struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n-        match candidate {\n-            Candidate::Ref(loc) => {\n-                let statement = &self.body[loc.block].statements[loc.statement_index];\n-                match &statement.kind {\n-                    StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        // We can only promote interior borrows of promotable temps (non-temps\n-                        // don't get promoted anyway).\n-                        self.validate_local(place.local)?;\n-\n-                        // The reference operation itself must be promotable.\n-                        // (Needs to come after `validate_local` to avoid ICEs.)\n-                        self.validate_ref(*kind, place)?;\n-\n-                        // We do not check all the projections (they do not get promoted anyway),\n-                        // but we do stay away from promoting anything involving a dereference.\n-                        if place.projection.contains(&ProjectionElem::Deref) {\n-                            return Err(Unpromotable);\n-                        }\n+        let loc = candidate.location;\n+        let statement = &self.body[loc.block].statements[loc.statement_index];\n+        match &statement.kind {\n+            StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n+                // We can only promote interior borrows of promotable temps (non-temps\n+                // don't get promoted anyway).\n+                self.validate_local(place.local)?;\n+\n+                // The reference operation itself must be promotable.\n+                // (Needs to come after `validate_local` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n \n-                        // We cannot promote things that need dropping, since the promoted value\n-                        // would not get dropped.\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n+                // We do not check all the projections (they do not get promoted anyway),\n+                // but we do stay away from promoting anything involving a dereference.\n+                if place.projection.contains(&ProjectionElem::Deref) {\n+                    return Err(Unpromotable);\n+                }\n \n-                        Ok(())\n-                    }\n-                    _ => bug!(),\n+                // We cannot promote things that need dropping, since the promoted value\n+                // would not get dropped.\n+                if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n+                    return Err(Unpromotable);\n                 }\n+\n+                Ok(())\n             }\n+            _ => bug!(),\n         }\n     }\n \n@@ -871,58 +859,55 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n-            match candidate {\n-                Candidate::Ref(loc) => {\n-                    let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-                    match statement.kind {\n-                        StatementKind::Assign(box (\n-                            _,\n-                            Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n-                        )) => {\n-                            // Use the underlying local for this (necessarily interior) borrow.\n-                            let ty = local_decls.local_decls()[place.local].ty;\n-                            let span = statement.source_info.span;\n-\n-                            let ref_ty = tcx.mk_ref(\n-                                tcx.lifetimes.re_erased,\n-                                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n-                            );\n-\n-                            *region = tcx.lifetimes.re_erased;\n-\n-                            let mut projection = vec![PlaceElem::Deref];\n-                            projection.extend(place.projection);\n-                            place.projection = tcx.intern_place_elems(&projection);\n-\n-                            // Create a temp to hold the promoted reference.\n-                            // This is because `*r` requires `r` to be a local,\n-                            // otherwise we would use the `promoted` directly.\n-                            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n-                            promoted_ref.source_info = statement.source_info;\n-                            let promoted_ref = local_decls.push(promoted_ref);\n-                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-\n-                            let promoted_ref_statement = Statement {\n-                                source_info: statement.source_info,\n-                                kind: StatementKind::Assign(Box::new((\n-                                    Place::from(promoted_ref),\n-                                    Rvalue::Use(promoted_operand(ref_ty, span)),\n-                                ))),\n-                            };\n-                            self.extra_statements.push((loc, promoted_ref_statement));\n-\n-                            Rvalue::Ref(\n-                                tcx.lifetimes.re_erased,\n-                                borrow_kind,\n-                                Place {\n-                                    local: mem::replace(&mut place.local, promoted_ref),\n-                                    projection: List::empty(),\n-                                },\n-                            )\n-                        }\n-                        _ => bug!(),\n-                    }\n+            let loc = candidate.location;\n+            let statement = &mut blocks[loc.block].statements[loc.statement_index];\n+            match statement.kind {\n+                StatementKind::Assign(box (\n+                    _,\n+                    Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n+                )) => {\n+                    // Use the underlying local for this (necessarily interior) borrow.\n+                    let ty = local_decls.local_decls()[place.local].ty;\n+                    let span = statement.source_info.span;\n+\n+                    let ref_ty = tcx.mk_ref(\n+                        tcx.lifetimes.re_erased,\n+                        ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+                    );\n+\n+                    *region = tcx.lifetimes.re_erased;\n+\n+                    let mut projection = vec![PlaceElem::Deref];\n+                    projection.extend(place.projection);\n+                    place.projection = tcx.intern_place_elems(&projection);\n+\n+                    // Create a temp to hold the promoted reference.\n+                    // This is because `*r` requires `r` to be a local,\n+                    // otherwise we would use the `promoted` directly.\n+                    let mut promoted_ref = LocalDecl::new(ref_ty, span);\n+                    promoted_ref.source_info = statement.source_info;\n+                    let promoted_ref = local_decls.push(promoted_ref);\n+                    assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+                    let promoted_ref_statement = Statement {\n+                        source_info: statement.source_info,\n+                        kind: StatementKind::Assign(Box::new((\n+                            Place::from(promoted_ref),\n+                            Rvalue::Use(promoted_operand(ref_ty, span)),\n+                        ))),\n+                    };\n+                    self.extra_statements.push((loc, promoted_ref_statement));\n+\n+                    Rvalue::Ref(\n+                        tcx.lifetimes.re_erased,\n+                        borrow_kind,\n+                        Place {\n+                            local: mem::replace(&mut place.local, promoted_ref),\n+                            projection: List::empty(),\n+                        },\n+                    )\n                 }\n+                _ => bug!(),\n             }\n         };\n \n@@ -964,25 +949,21 @@ pub fn promote_candidates<'tcx>(\n \n     let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n-        match candidate {\n-            Candidate::Ref(Location { block, statement_index }) => {\n-                if let StatementKind::Assign(box (place, _)) =\n-                    &body[block].statements[statement_index].kind\n-                {\n-                    if let Some(local) = place.as_local() {\n-                        if temps[local] == TempState::PromotedOut {\n-                            // Already promoted.\n-                            continue;\n-                        }\n-                    }\n+        let Location { block, statement_index } = candidate.location;\n+        if let StatementKind::Assign(box (place, _)) = &body[block].statements[statement_index].kind\n+        {\n+            if let Some(local) = place.as_local() {\n+                if temps[local] == TempState::PromotedOut {\n+                    // Already promoted.\n+                    continue;\n                 }\n             }\n         }\n \n         // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(LocalDecl::new(tcx.types.never, body.span)).collect();\n \n-        let mut scope = body.source_scopes[candidate.source_info(body).scope].clone();\n+        let mut scope = body.source_scopes[body.source_info(candidate.location).scope].clone();\n         scope.parent_scope = None;\n \n         let promoted = Body::new("}]}