{"sha": "0d8321b5e87c87aa4dbea729b4dd722740fac645", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkODMyMWI1ZTg3Yzg3YWE0ZGJlYTcyOWI0ZGQ3MjI3NDBmYWM2NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-01T12:16:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-01T12:16:14Z"}, "message": "Auto merge of #50198 - oli-obk:const_prop, r=eddyb\n\nRemove some unused code", "tree": {"sha": "28cc87590fa4b055719b30e19a7278dd71aca082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28cc87590fa4b055719b30e19a7278dd71aca082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d8321b5e87c87aa4dbea729b4dd722740fac645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8321b5e87c87aa4dbea729b4dd722740fac645", "html_url": "https://github.com/rust-lang/rust/commit/0d8321b5e87c87aa4dbea729b4dd722740fac645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d8321b5e87c87aa4dbea729b4dd722740fac645/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4a79472598e24a60301fb99f27dc688cc365d5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a79472598e24a60301fb99f27dc688cc365d5a", "html_url": "https://github.com/rust-lang/rust/commit/a4a79472598e24a60301fb99f27dc688cc365d5a"}, {"sha": "487f7bc016aeca615ada10fce5bcd7190702bda6", "url": "https://api.github.com/repos/rust-lang/rust/commits/487f7bc016aeca615ada10fce5bcd7190702bda6", "html_url": "https://github.com/rust-lang/rust/commit/487f7bc016aeca615ada10fce5bcd7190702bda6"}], "stats": {"total": 997, "additions": 270, "deletions": 727}, "files": [{"sha": "940ca1aace05339199808e97b1d9a7fde56bf604", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -1728,7 +1728,6 @@ dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -1872,15 +1871,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_const_math\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_apfloat 0.0.0\",\n- \"serialize 0.0.0\",\n- \"syntax 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_cratesio_shim\"\n version = \"0.0.0\"\n@@ -2026,7 +2016,6 @@ dependencies = [\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -2053,7 +2042,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n@@ -2154,7 +2142,6 @@ dependencies = [\n  \"rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n@@ -2205,7 +2192,6 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\","}, {"sha": "af108188ce0f476b5d40da5a697701b1be49b65c", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -19,7 +19,6 @@ log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n proc_macro = { path = \"../libproc_macro\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "5f3ff461c0c7ec5a28309a77c093c019c9e6bc5f", "filename": "src/librustc/ich/impls_const_math.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module contains `HashStable` implementations for various data types\n-//! from `rustc_const_math` in no particular order.\n-\n-impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n-    ty,\n-    bits\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n-    NotInRange,\n-    CmpBetweenUnequalTypes,\n-    UnequalTypes(op),\n-    Overflow(op),\n-    ShiftNegative,\n-    DivisionByZero,\n-    RemainderByZero,\n-    UnsignedNegation,\n-    ULitOutOfRange(int_ty),\n-    LitOutOfRange(int_ty)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::Op {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    Shr,\n-    Shl,\n-    Neg,\n-    BitAnd,\n-    BitOr,\n-    BitXor\n-});"}, {"sha": "33f43e53394f59905335e50ed4420360a052ea97", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -227,27 +227,6 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::AssertMessage<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                len.hash_stable(hcx, hasher);\n-                index.hash_stable(hcx, hasher);\n-            }\n-            mir::AssertMessage::Math(ref const_math_err) => {\n-                const_math_err.hash_stable(hcx, hasher);\n-            }\n-            mir::AssertMessage::GeneratorResumedAfterReturn => (),\n-            mir::AssertMessage::GeneratorResumedAfterPanic => (),\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>"}, {"sha": "a40d8e09277406397ec1415f75e77afb8fb7b002", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -505,9 +505,6 @@ for ::middle::const_val::ErrKind<'gcx> {\n                 len.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n             }\n-            Math(ref const_math_err) => {\n-                const_math_err.hash_stable(hcx, hasher);\n-            }\n             LayoutError(ref layout_error) => {\n                 layout_error.hash_stable(hcx, hasher);\n             }\n@@ -528,16 +525,26 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n+\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::mir::interpret::EvalError<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.kind.hash_stable(hcx, hasher)\n+    }\n+}\n+\n+impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::EvalErrorKind<'gcx, O> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use mir::interpret::EvalErrorKind::*;\n \n-        mem::discriminant(&self.kind).hash_stable(hcx, hasher);\n+        mem::discriminant(&self).hash_stable(hcx, hasher);\n \n-        match self.kind {\n+        match *self {\n             DanglingPointerDeref |\n             DoubleFree |\n             InvalidMemoryAccess |\n@@ -568,8 +575,12 @@ for ::mir::interpret::EvalError<'gcx> {\n             TypeckError |\n             DerefFunctionPointer |\n             ExecuteMemory |\n-            ReferencedConstant |\n-            OverflowingMath => {}\n+            OverflowNeg |\n+            RemainderByZero |\n+            DivisionByZero |\n+            GeneratorResumedAfterReturn |\n+            GeneratorResumedAfterPanic |\n+            ReferencedConstant => {}\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n             FunctionPointerTyMismatch(a, b) => {\n                 a.hash_stable(hcx, hasher);\n@@ -588,14 +599,9 @@ for ::mir::interpret::EvalError<'gcx> {\n             },\n             InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n             Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n-            ArrayIndexOutOfBounds(sp, a, b) => {\n-                sp.hash_stable(hcx, hasher);\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            Math(sp, ref err) => {\n-                sp.hash_stable(hcx, hasher);\n-                err.hash_stable(hcx, hasher)\n+            BoundsCheck { ref len, ref index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher)\n             },\n             Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n             InvalidChar(c) => c.hash_stable(hcx, hasher),\n@@ -668,6 +674,7 @@ for ::mir::interpret::EvalError<'gcx> {\n             Layout(lay) => lay.hash_stable(hcx, hasher),\n             HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n             PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n+            Overflow(op) => op.hash_stable(hcx, hasher),\n         }\n     }\n }"}, {"sha": "a0c6bbbb2393f83929c88980f2740ac515d6f4dc", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -18,7 +18,6 @@ mod fingerprint;\n mod caching_codemap_view;\n mod hcx;\n \n-mod impls_const_math;\n mod impls_cstore;\n mod impls_hir;\n mod impls_mir;"}, {"sha": "879d38c4894435613efa148027289b1f64281672", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -85,7 +85,6 @@ extern crate libc;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;\n-extern crate rustc_const_math;\n extern crate rustc_errors as errors;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "0ecab50dda22989faeb57d53f0bc642ff068e37d", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -11,7 +11,6 @@\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n-use rustc_const_math::*;\n use mir::interpret::{Value, PrimVal};\n use errors::DiagnosticBuilder;\n \n@@ -62,7 +61,6 @@ pub enum ErrKind<'tcx> {\n     UnimplementedConstVal(&'static str),\n     IndexOutOfBounds { len: u64, index: u64 },\n \n-    Math(ConstMathErr),\n     LayoutError(layout::LayoutError<'tcx>),\n \n     TypeckError,\n@@ -76,15 +74,6 @@ pub struct FrameInfo {\n     pub location: String,\n }\n \n-impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n-    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n-        match err {\n-            ConstMathErr::UnsignedNegation => ErrKind::TypeckError,\n-            _ => ErrKind::Math(err)\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub enum ConstEvalErrDescription<'a, 'tcx: 'a> {\n     Simple(Cow<'a, str>),\n@@ -122,7 +111,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n                         len, index)\n             }\n \n-            Math(ref err) => Simple(err.description().into_cow()),\n             LayoutError(ref err) => Simple(err.to_string().into_cow()),\n \n             TypeckError => simple!(\"type-checking failed\"),"}, {"sha": "1e1d50c3fc036d36d26369c18ed4d5ffdfc19db7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -1,4 +1,3 @@\n-use std::error::Error;\n use std::{fmt, env};\n \n use mir;\n@@ -8,18 +7,16 @@ use super::{\n     MemoryPointer, Lock, AccessKind\n };\n \n-use rustc_const_math::ConstMathErr;\n-use syntax::codemap::Span;\n use backtrace::Backtrace;\n \n #[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n-    pub kind: EvalErrorKind<'tcx>,\n+    pub kind: EvalErrorKind<'tcx, u64>,\n     pub backtrace: Option<Backtrace>,\n }\n \n-impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n-    fn from(kind: EvalErrorKind<'tcx>) -> Self {\n+impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n+    fn from(kind: EvalErrorKind<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"MIRI_BACKTRACE\") {\n             Ok(ref val) if !val.is_empty() => Some(Backtrace::new_unresolved()),\n             _ => None\n@@ -31,8 +28,10 @@ impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone)]\n-pub enum EvalErrorKind<'tcx> {\n+pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n     MachineError(String),\n@@ -60,10 +59,12 @@ pub enum EvalErrorKind<'tcx> {\n     Unimplemented(String),\n     DerefFunctionPointer,\n     ExecuteMemory,\n-    ArrayIndexOutOfBounds(Span, u64, u64),\n-    Math(Span, ConstMathErr),\n+    BoundsCheck { len: O, index: O },\n+    Overflow(mir::BinOp),\n+    OverflowNeg,\n+    DivisionByZero,\n+    RemainderByZero,\n     Intrinsic(String),\n-    OverflowingMath,\n     InvalidChar(u128),\n     StackFrameLimitReached,\n     OutOfTls,\n@@ -121,14 +122,16 @@ pub enum EvalErrorKind<'tcx> {\n     /// Cannot compute this constant because it depends on another one\n     /// which already produced an error\n     ReferencedConstant,\n+    GeneratorResumedAfterReturn,\n+    GeneratorResumedAfterPanic,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n-impl<'tcx> Error for EvalError<'tcx> {\n-    fn description(&self) -> &str {\n+impl<'tcx, O> EvalErrorKind<'tcx, O> {\n+    pub fn description(&self) -> &str {\n         use self::EvalErrorKind::*;\n-        match self.kind {\n+        match *self {\n             MachineError(ref inner) => inner,\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n@@ -175,14 +178,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to dereference a function pointer\",\n             ExecuteMemory =>\n                 \"tried to treat a memory pointer as a function pointer\",\n-            ArrayIndexOutOfBounds(..) =>\n+            BoundsCheck{..} =>\n                 \"array index out of bounds\",\n-            Math(..) =>\n-                \"mathematical operation failed\",\n             Intrinsic(..) =>\n                 \"intrinsic failed\",\n-            OverflowingMath =>\n-                \"attempted to do overflowing math\",\n             NoMirFor(..) =>\n                 \"mir not found\",\n             InvalidChar(..) =>\n@@ -232,22 +231,41 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"the evaluated program panicked\",\n             ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n-            EvalErrorKind::PathNotFound(_) =>\n+            PathNotFound(_) =>\n                 \"a path could not be resolved, maybe the crate is not loaded\",\n             UnimplementedTraitSelection =>\n                 \"there were unresolved type arguments during trait selection\",\n             TypeckError =>\n                 \"encountered constants with type errors, stopping evaluation\",\n             ReferencedConstant =>\n                 \"referenced constant has errors\",\n+            Overflow(mir::BinOp::Add) => \"attempt to add with overflow\",\n+            Overflow(mir::BinOp::Sub) => \"attempt to subtract with overflow\",\n+            Overflow(mir::BinOp::Mul) => \"attempt to multiply with overflow\",\n+            Overflow(mir::BinOp::Div) => \"attempt to divide with overflow\",\n+            Overflow(mir::BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n+            OverflowNeg => \"attempt to negate with overflow\",\n+            Overflow(mir::BinOp::Shr) => \"attempt to shift right with overflow\",\n+            Overflow(mir::BinOp::Shl) => \"attempt to shift left with overflow\",\n+            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n+            DivisionByZero => \"attempt to divide by zero\",\n+            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n+            GeneratorResumedAfterReturn => \"generator resumed after completion\",\n+            GeneratorResumedAfterPanic => \"generator resumed after panicking\",\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind)\n+    }\n+}\n+\n+impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::EvalErrorKind::*;\n-        match self.kind {\n+        match *self {\n             PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n                        if access { \"memory access\" } else { \"pointer computed\" },\n@@ -275,14 +293,12 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n-            ArrayIndexOutOfBounds(span, len, index) =>\n-                write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n+            BoundsCheck { ref len, ref index } =>\n+                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n-            Math(_, ref err) =>\n-                write!(f, \"{}\", err.description()),\n             Intrinsic(ref err) =>\n                 write!(f, \"{}\", err),\n             InvalidChar(c) =>"}, {"sha": "546c7a920d538fd6d12a653ea0c41ccf9f510088", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -8,7 +8,7 @@ macro_rules! err {\n mod error;\n mod value;\n \n-pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n+pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n \n@@ -23,21 +23,21 @@ use std::iter;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),\n     /// This should never be empty -- that would be a read lock held and nobody there to release it...\n     ReadLock(Vec<DynamicLifetime>),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct DynamicLifetime {\n     pub frame: usize,\n     pub region: Option<region::Scope>, // \"None\" indicates \"until the function ends\"\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -88,12 +88,12 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n     fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i as i128);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {"}, {"sha": "3bbec3915dd5b0ed9ffd1d79fa8a46c6912a31cf", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -15,7 +15,6 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n-use rustc_const_math::ConstMathErr;\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n@@ -26,7 +25,7 @@ use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n-use mir::interpret::{Value, PrimVal};\n+use mir::interpret::{Value, PrimVal, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -43,6 +42,10 @@ use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n+use rustc_apfloat::ieee::{Single, Double};\n+use rustc_apfloat::Float;\n+\n+pub use mir::interpret::AssertMessage;\n \n mod cache;\n pub mod tcx;\n@@ -1130,26 +1133,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 if !expected {\n                     write!(fmt, \"!\")?;\n                 }\n-                write!(fmt, \"{:?}, \", cond)?;\n-\n-                match *msg {\n-                    AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        write!(fmt, \"{:?}, {:?}, {:?}\",\n-                               \"index out of bounds: the len is {} but the index is {}\",\n-                               len, index)?;\n-                    }\n-                    AssertMessage::Math(ref err) => {\n-                        write!(fmt, \"{:?}\", err.description())?;\n-                    }\n-                    AssertMessage::GeneratorResumedAfterReturn => {\n-                        write!(fmt, \"{:?}\", \"generator resumed after completion\")?;\n-                    }\n-                    AssertMessage::GeneratorResumedAfterPanic => {\n-                        write!(fmt, \"{:?}\", \"generator resumed after panicking\")?;\n-                    }\n-                }\n-\n-                write!(fmt, \")\")\n+                write!(fmt, \"{:?}, \\\"{:?}\\\")\", cond, msg)\n             },\n             FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n@@ -1204,17 +1188,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AssertMessage<'tcx> {\n-    BoundsCheck {\n-        len: Operand<'tcx>,\n-        index: Operand<'tcx>\n-    },\n-    Math(ConstMathErr),\n-    GeneratorResumedAfterReturn,\n-    GeneratorResumedAfterPanic,\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n@@ -1915,12 +1888,13 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n \n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n-    use rustc_const_math::ConstFloat;\n     match (value, &ty.sty) {\n         (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n         (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(fty)) =>\n-            write!(f, \"{}\", ConstFloat { bits, ty: fty }),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+            write!(f, \"{}f32\", Single::from_bits(bits)),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+            write!(f, \"{}f64\", Double::from_bits(bits)),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n@@ -2279,8 +2253,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 }\n             },\n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let msg = if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n-                    AssertMessage::BoundsCheck {\n+                let msg = if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n+                    EvalErrorKind::BoundsCheck {\n                         len: len.fold_with(folder),\n                         index: index.fold_with(folder),\n                     }\n@@ -2329,7 +2303,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             },\n             Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n-                    if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                    if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n                     } else {\n                         false"}, {"sha": "59b6f3697541a0c8083079caf3d1f05391e25d45", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -511,17 +511,13 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)* AssertMessage<'tcx>,\n                                     location: Location) {\n-                match *msg {\n-                    AssertMessage::BoundsCheck {\n+                use mir::interpret::EvalErrorKind::*;\n+                if let BoundsCheck {\n                         ref $($mutability)* len,\n                         ref $($mutability)* index\n-                    } => {\n-                        self.visit_operand(len, location);\n-                        self.visit_operand(index, location);\n-                    }\n-                    AssertMessage::Math(_) => {},\n-                    AssertMessage::GeneratorResumedAfterReturn => {},\n-                    AssertMessage::GeneratorResumedAfterPanic => {},\n+                    } = *msg {\n+                    self.visit_operand(len, location);\n+                    self.visit_operand(index, location);\n                 }\n             }\n "}, {"sha": "53dde3e6903f9493027ea9ee5af7704c79b22fc9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -148,7 +148,7 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n     SizeOverflow(Ty<'tcx>)"}, {"sha": "d4ed6c60e0efa6baae51eef83e6132c3cdd4e8cc", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -473,9 +473,19 @@ impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n     type Lifted = interpret::EvalError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(interpret::EvalError {\n+            kind: tcx.lift(&self.kind)?,\n+            backtrace: self.backtrace.clone(),\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n+    type Lifted = interpret::EvalErrorKind<'tcx, <O as Lift<'tcx>>::Lifted>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         use ::mir::interpret::EvalErrorKind::*;\n-        let kind = match self.kind {\n+        Some(match *self {\n             MachineError(ref err) => MachineError(err.clone()),\n             FunctionPointerTyMismatch(a, b) => FunctionPointerTyMismatch(\n                 tcx.lift(&a)?,\n@@ -504,10 +514,11 @@ impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n             Unimplemented(ref s) => Unimplemented(s.clone()),\n             DerefFunctionPointer => DerefFunctionPointer,\n             ExecuteMemory => ExecuteMemory,\n-            ArrayIndexOutOfBounds(sp, a, b) => ArrayIndexOutOfBounds(sp, a, b),\n-            Math(sp, ref err) => Math(sp, err.clone()),\n+            BoundsCheck { ref len, ref index } => BoundsCheck {\n+                len: tcx.lift(len)?,\n+                index: tcx.lift(index)?,\n+            },\n             Intrinsic(ref s) => Intrinsic(s.clone()),\n-            OverflowingMath => OverflowingMath,\n             InvalidChar(c) => InvalidChar(c),\n             StackFrameLimitReached => StackFrameLimitReached,\n             OutOfTls => OutOfTls,\n@@ -568,10 +579,12 @@ impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n             UnimplementedTraitSelection => UnimplementedTraitSelection,\n             TypeckError => TypeckError,\n             ReferencedConstant => ReferencedConstant,\n-        };\n-        Some(interpret::EvalError {\n-            kind: kind,\n-            backtrace: self.backtrace.clone(),\n+            OverflowNeg => OverflowNeg,\n+            Overflow(op) => Overflow(op),\n+            DivisionByZero => DivisionByZero,\n+            RemainderByZero => RemainderByZero,\n+            GeneratorResumedAfterReturn => GeneratorResumedAfterReturn,\n+            GeneratorResumedAfterPanic => GeneratorResumedAfterPanic,\n         })\n     }\n }\n@@ -585,7 +598,6 @@ impl<'a, 'tcx> Lift<'tcx> for const_val::ErrKind<'a> {\n             NonConstPath => NonConstPath,\n             UnimplementedConstVal(s) => UnimplementedConstVal(s),\n             IndexOutOfBounds { len, index } => IndexOutOfBounds { len, index },\n-            Math(ref e) => Math(e.clone()),\n \n             LayoutError(ref e) => {\n                 return tcx.lift(e).map(LayoutError)"}, {"sha": "e662088e82fb09724338560c36cddb60e7641965", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -20,7 +20,7 @@ use std::ops::Neg;\n pub struct DoubleFloat<F>(F, F);\n pub type DoubleDouble = DoubleFloat<ieee::Double>;\n \n-// These are legacy semantics for the Fallback, inaccrurate implementation of\n+// These are legacy semantics for the Fallback, inaccurate implementation of\n // IBM double-double, if the accurate DoubleDouble doesn't handle the\n // operation. It's equivalent to having an IEEE number with consecutive 106\n // bits of mantissa and 11 bits of exponent."}, {"sha": "41310ede3e085a0928288779615792ea79dd8055", "filename": "src/librustc_const_math/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_const_math\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_const_math\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-rustc_apfloat = { path = \"../librustc_apfloat\" }\n-serialize = { path = \"../libserialize\" }\n-syntax = { path = \"../libsyntax\" }"}, {"sha": "bd0a332436e6427c945ed803ff270e88da5487be", "filename": "src/librustc_const_math/err.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ConstMathErr {\n-    NotInRange,\n-    CmpBetweenUnequalTypes,\n-    UnequalTypes(Op),\n-    Overflow(Op),\n-    ShiftNegative,\n-    DivisionByZero,\n-    RemainderByZero,\n-    UnsignedNegation,\n-    ULitOutOfRange(ast::UintTy),\n-    LitOutOfRange(ast::IntTy),\n-}\n-pub use self::ConstMathErr::*;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n-pub enum Op {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    Shr,\n-    Shl,\n-    Neg,\n-    BitAnd,\n-    BitOr,\n-    BitXor,\n-}\n-\n-impl ConstMathErr {\n-    pub fn description(&self) -> &'static str {\n-        use self::Op::*;\n-        match *self {\n-            NotInRange => \"inferred value out of range\",\n-            CmpBetweenUnequalTypes => \"compared two values of different types\",\n-            UnequalTypes(Add) => \"tried to add two values of different types\",\n-            UnequalTypes(Sub) => \"tried to subtract two values of different types\",\n-            UnequalTypes(Mul) => \"tried to multiply two values of different types\",\n-            UnequalTypes(Div) => \"tried to divide two values of different types\",\n-            UnequalTypes(Rem) => {\n-                \"tried to calculate the remainder of two values of different types\"\n-            },\n-            UnequalTypes(BitAnd) => \"tried to bitand two values of different types\",\n-            UnequalTypes(BitOr) => \"tried to bitor two values of different types\",\n-            UnequalTypes(BitXor) => \"tried to xor two values of different types\",\n-            UnequalTypes(_) => unreachable!(),\n-            Overflow(Add) => \"attempt to add with overflow\",\n-            Overflow(Sub) => \"attempt to subtract with overflow\",\n-            Overflow(Mul) => \"attempt to multiply with overflow\",\n-            Overflow(Div) => \"attempt to divide with overflow\",\n-            Overflow(Rem) => \"attempt to calculate the remainder with overflow\",\n-            Overflow(Neg) => \"attempt to negate with overflow\",\n-            Overflow(Shr) => \"attempt to shift right with overflow\",\n-            Overflow(Shl) => \"attempt to shift left with overflow\",\n-            Overflow(_) => unreachable!(),\n-            ShiftNegative => \"attempt to shift by a negative amount\",\n-            DivisionByZero => \"attempt to divide by zero\",\n-            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n-            UnsignedNegation => \"unary negation of unsigned integer\",\n-            ULitOutOfRange(ast::UintTy::U8) => \"literal out of range for u8\",\n-            ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n-            ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n-            ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n-            ULitOutOfRange(ast::UintTy::U128) => \"literal out of range for u128\",\n-            ULitOutOfRange(ast::UintTy::Usize) => \"literal out of range for usize\",\n-            LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n-            LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n-            LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n-            LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n-            LitOutOfRange(ast::IntTy::I128) => \"literal out of range for i128\",\n-            LitOutOfRange(ast::IntTy::Isize) => \"literal out of range for isize\",\n-        }\n-    }\n-}"}, {"sha": "9d820ea8cbed2990e91ab163aee9416840f8e8b1", "filename": "src/librustc_const_math/float.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1,213 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering;\n-use std::num::ParseFloatError;\n-\n-use syntax::ast;\n-\n-use rustc_apfloat::{Float, FloatConvert, Status};\n-use rustc_apfloat::ieee::{Single, Double};\n-\n-use super::err::*;\n-\n-// Note that equality for `ConstFloat` means that the it is the same\n-// constant, not that the rust values are equal. In particular, `NaN\n-// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-// are considering unequal).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ConstFloat {\n-    pub ty: ast::FloatTy,\n-\n-    // This is a bit inefficient but it makes conversions below more\n-    // ergonomic, and all of this will go away once `miri` is merged.\n-    pub bits: u128,\n-}\n-\n-impl ConstFloat {\n-    /// Description of the type, not the value\n-    pub fn description(&self) -> &'static str {\n-        self.ty.ty_to_string()\n-    }\n-\n-    /// Compares the values if they are of the same type\n-    pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n-        match (self.ty, rhs.ty) {\n-            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n-                let a = Double::from_bits(self.bits);\n-                let b = Double::from_bits(rhs.bits);\n-                // This is pretty bad but it is the existing behavior.\n-                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n-                let a = Single::from_bits(self.bits);\n-                let b = Single::from_bits(rhs.bits);\n-                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            _ => Err(CmpBetweenUnequalTypes),\n-        }\n-    }\n-\n-    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => {\n-                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Single gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Single::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-            ast::FloatTy::F64 => {\n-                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Double gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Double::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-        };\n-        Ok(ConstFloat { bits, ty })\n-    }\n-\n-    pub fn to_i128(self, width: usize) -> Option<i128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn to_u128(self, width: usize) -> Option<u128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn convert(self, to: ast::FloatTy) -> Self {\n-        let bits = match (self.ty, to) {\n-            (ast::FloatTy::F32, ast::FloatTy::F32) |\n-            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n-                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n-            }\n-            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n-                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n-            }\n-        };\n-        ConstFloat { bits, ty: to }\n-    }\n-}\n-\n-impl ::std::fmt::Display for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match self.ty {\n-            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n-            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n-        }\n-        write!(fmt, \"{}\", self.ty)\n-    }\n-}\n-\n-impl ::std::fmt::Debug for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        ::std::fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-macro_rules! derive_binop {\n-    ($op:ident, $func:ident) => {\n-        impl ::std::ops::$op for ConstFloat {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                let bits = match (self.ty, rhs.ty) {\n-                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n-                        let a = Single::from_bits(self.bits);\n-                        let b = Single::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n-                        let a = Double::from_bits(self.bits);\n-                        let b = Double::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    _ => return Err(UnequalTypes(Op::$op)),\n-                };\n-                Ok(ConstFloat { bits, ty: self.ty })\n-            }\n-        }\n-    }\n-}\n-\n-derive_binop!(Add, add);\n-derive_binop!(Sub, sub);\n-derive_binop!(Mul, mul);\n-derive_binop!(Div, div);\n-derive_binop!(Rem, rem);\n-\n-impl ::std::ops::Neg for ConstFloat {\n-    type Output = Self;\n-    fn neg(self) -> Self {\n-        let bits = match self.ty {\n-            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n-            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n-        };\n-        ConstFloat { bits, ty: self.ty }\n-    }\n-}\n-\n-/// This is `f32::MAX + (0.5 ULP)` as an integer. Numbers greater or equal to this\n-/// are rounded to infinity when converted to `f32`.\n-///\n-/// NB: Computed as maximum significand with an extra 1 bit added (for the half ULP)\n-/// shifted by the maximum exponent (accounting for normalization).\n-pub const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n-                                        << (Single::MAX_EXP - Single::PRECISION as i16);"}, {"sha": "499c330be1da8aca6a0d32483d9d011c2a7bf559", "filename": "src/librustc_const_math/lib.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a79472598e24a60301fb99f27dc688cc365d5a/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=a4a79472598e24a60301fb99f27dc688cc365d5a", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rusty Mathematics\n-//!\n-//! # Note\n-//!\n-//! This API is completely unstable and subject to change.\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n-extern crate rustc_apfloat;\n-\n-extern crate syntax;\n-\n-extern crate serialize as rustc_serialize; // used by deriving\n-\n-mod float;\n-mod err;\n-\n-pub use float::*;\n-pub use err::{ConstMathErr, Op};"}, {"sha": "62964745b6f9eb49ff8c8730a4375dd4dd1b255a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -16,7 +16,6 @@ log = \"0.4\"\n log_settings = \"0.1.1\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "7e1c20dff6a733bbcb44e86197713582d29b5596", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -18,7 +18,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{AssertMessage, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -586,18 +586,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 cleanup: _,\n             } => {\n                 self.consume_operand(ContextKind::Assert.new(loc), (cond, span), flow_state);\n-                match *msg {\n-                    AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                        self.consume_operand(\n-                            ContextKind::Assert.new(loc),\n-                            (index, span),\n-                            flow_state,\n-                        );\n-                    }\n-                    AssertMessage::Math(_ /*const_math_err*/) => {}\n-                    AssertMessage::GeneratorResumedAfterReturn => {}\n-                    AssertMessage::GeneratorResumedAfterPanic => {}\n+                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                if let BoundsCheck { ref len, ref index } = *msg {\n+                    self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n+                    self.consume_operand(\n+                        ContextKind::Assert.new(loc),\n+                        (index, span),\n+                        flow_state,\n+                    );\n                 }\n             }\n "}, {"sha": "a21b9196badb5856b5fba5c3e8575114662bdf09", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -22,6 +22,7 @@ use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::*;\n use rustc::traits::query::NoSolution;\n use rustc::traits::{self, Normalized, TraitEngine};\n@@ -928,7 +929,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                if let BoundsCheck { ref len, ref index } = *msg {\n                     if len.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }"}, {"sha": "19ec13324d6b4a8c287a51505f03e7ed82c158c9", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -14,6 +14,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n+use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -73,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                            Operand::Copy(Place::Local(idx)),\n                                                            Operand::Copy(len.clone())));\n \n-                let msg = AssertMessage::BoundsCheck {\n+                let msg = BoundsCheck {\n                     len: Operand::Move(len),\n                     index: Operand::Copy(Place::Local(idx))\n                 };"}, {"sha": "9e96fdf821417f7bdcf7ecad1be5bb5ca7baa92a", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -10,7 +10,6 @@\n \n //! See docs in build/expr/mod.rs\n \n-use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -21,7 +20,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n-use rustc::mir::interpret::{Value, PrimVal};\n+use rustc::mir::interpret::{Value, PrimVal, EvalErrorKind};\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -86,9 +85,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.to_copy(), minval));\n \n-                    let err = ConstMathErr::Overflow(Op::Neg);\n                     block = this.assert(block, Operand::Move(is_min), false,\n-                                        AssertMessage::Math(err), expr_span);\n+                                        EvalErrorKind::OverflowNeg, expr_span);\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n@@ -311,19 +309,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let err = ConstMathErr::Overflow(match op {\n-                BinOp::Add => Op::Add,\n-                BinOp::Sub => Op::Sub,\n-                BinOp::Mul => Op::Mul,\n-                BinOp::Shl => Op::Shl,\n-                BinOp::Shr => Op::Shr,\n-                _ => {\n-                    bug!(\"MIR build_binary_op: {:?} is not checkable\", op)\n-                }\n-            });\n+            let err = EvalErrorKind::Overflow(op);\n \n             block = self.assert(block, Operand::Move(of), false,\n-                                AssertMessage::Math(err), span);\n+                                err, span);\n \n             block.and(Rvalue::Use(Operand::Move(val)))\n         } else {\n@@ -332,11 +321,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n                 let (zero_err, overflow_err) = if op == BinOp::Div {\n-                    (ConstMathErr::DivisionByZero,\n-                     ConstMathErr::Overflow(Op::Div))\n+                    (EvalErrorKind::DivisionByZero,\n+                     EvalErrorKind::Overflow(op))\n                 } else {\n-                    (ConstMathErr::RemainderByZero,\n-                     ConstMathErr::Overflow(Op::Rem))\n+                    (EvalErrorKind::RemainderByZero,\n+                     EvalErrorKind::Overflow(op))\n                 };\n \n                 // Check for / 0\n@@ -346,7 +335,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.to_copy(), zero));\n \n                 block = self.assert(block, Operand::Move(is_zero), false,\n-                                    AssertMessage::Math(zero_err), span);\n+                                    zero_err, span);\n \n                 // We only need to check for the overflow in one case:\n                 // MIN / -1, and only for signed values.\n@@ -371,7 +360,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n                     block = self.assert(block, Operand::Move(of), false,\n-                                        AssertMessage::Math(overflow_err), span);\n+                                        overflow_err, span);\n                 }\n             }\n "}, {"sha": "5890ea5c9d0c653cc8d186986dbb1c4dd303ade1", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -30,9 +30,9 @@ use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n-use rustc_const_math::ConstFloat;\n use rustc_data_structures::sync::Lrc;\n use rustc::mir::interpret::{Value, PrimVal};\n+use hair::pattern::parse_float;\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -170,12 +170,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         neg: bool,\n     ) -> Literal<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n-        let tcx = self.tcx.global_tcx();\n \n-        let parse_float = |num: &str, fty| -> ConstFloat {\n-            ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n+        let parse_float = |num, fty| -> Value {\n+            parse_float(num, fty, neg).unwrap_or_else(|_| {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n+                self.tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n             })\n         };\n \n@@ -213,26 +212,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             },\n             LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(n, fty)\n             }\n             LitKind::FloatUnsuffixed(n) => {\n                 let fty = match ty.sty {\n                     ty::TyFloat(fty) => fty,\n                     _ => bug!()\n                 };\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(n, fty)\n             }\n             LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n             LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),"}, {"sha": "619b4596b42277c0649439b94ed9eef25f90be9e", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -28,13 +28,13 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstFloat;\n \n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n@@ -1053,24 +1053,22 @@ pub fn compare_const_vals<'a, 'tcx>(\n     b: &ConstVal,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    use rustc_const_math::ConstFloat;\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n     use rustc::mir::interpret::{Value, PrimVal};\n     match (a, b) {\n         (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n          &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            use ::rustc_apfloat::Float;\n             match ty.sty {\n-                ty::TyFloat(ty) => {\n-                    let l = ConstFloat {\n-                        bits: a,\n-                        ty,\n-                    };\n-                    let r = ConstFloat {\n-                        bits: b,\n-                        ty,\n-                    };\n-                    // FIXME(oli-obk): report cmp errors?\n-                    l.try_cmp(r).ok()\n+                ty::TyFloat(ast::FloatTy::F32) => {\n+                    let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n+                    l.partial_cmp(&r)\n+                },\n+                ty::TyFloat(ast::FloatTy::F64) => {\n+                    let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n+                    l.partial_cmp(&r)\n                 },\n                 ty::TyInt(_) => {\n                     let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n@@ -1148,34 +1146,51 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             Value::ByVal(PrimVal::Bytes(n))\n         },\n         LitKind::Float(n, fty) => {\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(n, fty, neg)?\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(n, fty, neg)?\n         }\n         LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n         LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n     };\n     Ok(ConstVal::Value(lit))\n }\n \n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ()> {\n-    ConstFloat::from_str(num, fty).map_err(|_| ())\n+pub fn parse_float(\n+    num: Symbol,\n+    fty: ast::FloatTy,\n+    neg: bool,\n+) -> Result<Value, ()> {\n+    let num = num.as_str();\n+    use rustc_apfloat::ieee::{Single, Double};\n+    use rustc_apfloat::Float;\n+    let bits = match fty {\n+        ast::FloatTy::F32 => {\n+            num.parse::<f32>().map_err(|_| ())?;\n+            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+        ast::FloatTy::F64 => {\n+            num.parse::<f64>().map_err(|_| ())?;\n+            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+    };\n+\n+    Ok(Value::ByVal(PrimVal::Bytes(bits)))\n }"}, {"sha": "002b5eb187db31ce36c2467687574938bb39b7d2", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -2,10 +2,9 @@ use rustc::ty::Ty;\n use rustc::ty::layout::LayoutOf;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use rustc_const_math::ConstFloat;\n+use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n-use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -50,8 +49,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(PrimVal::Bytes(v))\n             }\n \n-            TyFloat(fty) if signed => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n-            TyFloat(fty) => Ok(PrimVal::Bytes(ConstFloat::from_u128(v, fty).bits)),\n+            TyFloat(FloatTy::F32) if signed => Ok(PrimVal::Bytes(Single::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F64) if signed => Ok(PrimVal::Bytes(Double::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F32) => Ok(PrimVal::Bytes(Single::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F64) => Ok(PrimVal::Bytes(Double::from_u128(v).value.to_bits())),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),"}, {"sha": "e1b358a5eb7799ed19bd784d465480dbb4694a66", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     // it emits in debug mode) is performance, but it doesn't cost us any performance in miri.\n                     // If, however, the compiler ever starts transforming unchecked intrinsics into unchecked binops,\n                     // we have to go back to just ignoring the overflow here.\n-                    return err!(OverflowingMath);\n+                    return err!(Overflow(bin_op));\n                 }\n             }\n "}, {"sha": "ef6deab04775049ac2dc23fd1c3fd4ee8f32121d", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -1,9 +1,10 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n use rustc::ty::layout::LayoutOf;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n@@ -125,31 +126,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return err!(Unimplemented(msg));\n         }\n \n-        let float_op = |op, l, r, ty| {\n-            let l = ConstFloat {\n-                bits: l,\n-                ty,\n-            };\n-            let r = ConstFloat {\n-                bits: r,\n-                ty,\n-            };\n-            match op {\n-                Eq => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Equal),\n-                Ne => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Equal),\n-                Lt => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Less),\n-                Le => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Greater),\n-                Gt => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Greater),\n-                Ge => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Less),\n-                Add => PrimVal::Bytes((l + r).unwrap().bits),\n-                Sub => PrimVal::Bytes((l - r).unwrap().bits),\n-                Mul => PrimVal::Bytes((l * r).unwrap().bits),\n-                Div => PrimVal::Bytes((l / r).unwrap().bits),\n-                Rem => PrimVal::Bytes((l % r).unwrap().bits),\n-                _ => bug!(\"invalid float op: `{:?}`\", op),\n-            }\n-        };\n-\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n                 Lt => Some(i128::lt),\n@@ -164,7 +140,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 return Ok((PrimVal::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                Div if r == 0 => return err!(DivisionByZero),\n+                Rem if r == 0 => return err!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -199,7 +176,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n-            return Ok((float_op(bin_op, l, r, fty), false));\n+            macro_rules! float_math {\n+                ($ty:path) => {{\n+                    let l = <$ty>::from_bits(l);\n+                    let r = <$ty>::from_bits(r);\n+                    let val = match bin_op {\n+                        Eq => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Equal),\n+                        Ne => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Equal),\n+                        Lt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Less),\n+                        Le => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Greater),\n+                        Gt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Greater),\n+                        Ge => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Less),\n+                        Add => PrimVal::Bytes((l + r).value.to_bits()),\n+                        Sub => PrimVal::Bytes((l - r).value.to_bits()),\n+                        Mul => PrimVal::Bytes((l * r).value.to_bits()),\n+                        Div => PrimVal::Bytes((l / r).value.to_bits()),\n+                        Rem => PrimVal::Bytes((l % r).value.to_bits()),\n+                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                    };\n+                    return Ok((val, false));\n+                }};\n+            }\n+            match fty {\n+                FloatTy::F32 => float_math!(Single),\n+                FloatTy::F64 => float_math!(Double),\n+            }\n         }\n \n         // only ints left\n@@ -221,7 +222,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                    Div if r == 0 => return err!(DivisionByZero),\n+                    Rem if r == 0 => return err!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -269,7 +271,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n             (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n-            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowingMath),\n+            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowNeg),\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n "}, {"sha": "0e0d91f472472d2583db5ea058e7ccfbbd132a8c", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -148,23 +148,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n-                    use rustc::mir::AssertMessage::*;\n+                    use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let span = terminator.source_info.span;\n                             let len = self.eval_operand_to_primval(len)\n                                 .expect(\"can't eval len\")\n                                 .to_u64()?;\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n                                 .to_u64()?;\n-                            err!(ArrayIndexOutOfBounds(span, len, index))\n-                        }\n-                        Math(ref err) => {\n-                            err!(Math(terminator.source_info.span, err.clone()))\n+                            err!(BoundsCheck { len, index })\n                         }\n+                        Overflow(op) => Err(Overflow(op).into()),\n+                        OverflowNeg => Err(OverflowNeg.into()),\n+                        DivisionByZero => Err(DivisionByZero.into()),\n+                        RemainderByZero => Err(RemainderByZero.into()),\n                         GeneratorResumedAfterReturn |\n                         GeneratorResumedAfterPanic => unimplemented!(),\n+                        _ => bug!(),\n                     };\n                 }\n             }"}, {"sha": "95cf3b8ddc6ceace3095a749d965e07a3b36344e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -50,8 +50,6 @@ extern crate rustc_errors;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_target;\n-extern crate rustc_const_math;\n-extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n extern crate byteorder;"}, {"sha": "e1db216b6bbbcfad1b1d15a9a696d79cc3325674", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -328,7 +328,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         } else {\n                             if overflow {\n                                 use rustc::mir::interpret::EvalErrorKind;\n-                                let mut err = EvalErrorKind::OverflowingMath.into();\n+                                let mut err = EvalErrorKind::Overflow(op).into();\n                                 ecx.report(&mut err, false, Some(span));\n                                 return None;\n                             }\n@@ -478,12 +478,12 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         .hir\n                         .as_local_node_id(self.source.def_id)\n                         .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::AssertMessage::*;\n+                    use rustc::mir::interpret::EvalErrorKind::*;\n                     let msg = match msg {\n-                        // Need proper const propagator for these\n-                        GeneratorResumedAfterReturn |\n-                        GeneratorResumedAfterPanic => return,\n-                        Math(ref err) => err.description().to_owned(),\n+                        Overflow(_) |\n+                        OverflowNeg |\n+                        DivisionByZero |\n+                        RemainderByZero => msg.description().to_owned(),\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n@@ -504,6 +504,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                 index,\n                             )\n                         },\n+                        // Need proper const propagator for these\n+                        _ => return,\n                     };\n                     self.tcx.lint_node(\n                         ::rustc::lint::builtin::CONST_ERR,"}, {"sha": "36735586e81175f950deb1e646fcce86d02655c4", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -738,12 +738,17 @@ fn create_generator_resume_function<'a, 'tcx>(\n \n     let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n \n+    use rustc::mir::interpret::EvalErrorKind::{\n+        GeneratorResumedAfterPanic,\n+        GeneratorResumedAfterReturn,\n+    };\n+\n     // Jump to the entry point on the 0 state\n     cases.insert(0, (0, BasicBlock::new(0)));\n     // Panic when resumed on the returned (1) state\n-    cases.insert(1, (1, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterReturn)));\n+    cases.insert(1, (1, insert_panic_block(tcx, mir, GeneratorResumedAfterReturn)));\n     // Panic when resumed on the poisoned (2) state\n-    cases.insert(2, (2, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterPanic)));\n+    cases.insert(2, (2, insert_panic_block(tcx, mir, GeneratorResumedAfterPanic)));\n \n     insert_switch(tcx, mir, cases, &transform, TerminatorKind::Unreachable);\n "}, {"sha": "2babb93eedbcfb68732f7b1c821bb6a1bdf15a49", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -12,7 +12,6 @@ crate-type = [\"dylib\"]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_mir = { path = \"../librustc_mir\"}\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "b6b5edc094003c2215a26cf031804c650bf865d5", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -23,7 +23,6 @@\n #[macro_use]\n extern crate rustc;\n extern crate rustc_mir;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n \n #[macro_use]"}, {"sha": "45c6e89321d044934c0073ba092fbf951406e9ae", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::{Place, PlaceElem, PlaceProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n+use rustc::mir::interpret::EvalErrorKind;\n use rustc::mir::visit as mir_visit;\n use rustc::ty::{self, ClosureSubsts, TyCtxt};\n use rustc::util::nodemap::{FxHashMap};\n@@ -133,14 +134,18 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                             location: Location) {\n         self.record(\"AssertMessage\", msg);\n         self.record(match *msg {\n-            AssertMessage::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n-            AssertMessage::Math(..) => \"AssertMessage::Math\",\n-            AssertMessage::GeneratorResumedAfterReturn => {\n+            EvalErrorKind::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n+            EvalErrorKind::Overflow(..) => \"AssertMessage::Overflow\",\n+            EvalErrorKind::OverflowNeg => \"AssertMessage::OverflowNeg\",\n+            EvalErrorKind::DivisionByZero => \"AssertMessage::DivisionByZero\",\n+            EvalErrorKind::RemainderByZero => \"AssertMessage::RemainderByZero\",\n+            EvalErrorKind::GeneratorResumedAfterReturn => {\n                 \"AssertMessage::GeneratorResumedAfterReturn\"\n             }\n-            AssertMessage::GeneratorResumedAfterPanic => {\n+            EvalErrorKind::GeneratorResumedAfterPanic => {\n                 \"AssertMessage::GeneratorResumedAfterPanic\"\n             }\n+            _ => bug!(),\n         }, msg);\n         self.super_assert_message(msg, location);\n     }"}, {"sha": "a4dd02e97b233573d417e789950265498e4b4634", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -21,7 +21,6 @@ rustc-demangle = \"0.1.4\"\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "7a152d6ded4c56ecc957f4d6ce7c40d5a1a31c31", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -43,7 +43,6 @@ extern crate rustc_mir;\n extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_target;\n-extern crate rustc_const_math;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_demangle;\n extern crate rustc_incremental;"}, {"sha": "b666c2b211525713e762126a5a437160a7ca787b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -13,6 +13,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n+use rustc::mir::interpret::EvalErrorKind;\n use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n@@ -311,10 +312,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n                 if !bx.cx.check_overflow {\n-                    use rustc_const_math::ConstMathErr::Overflow;\n-                    use rustc_const_math::Op::Neg;\n-\n-                    if let mir::AssertMessage::Math(Overflow(Neg)) = *msg {\n+                    if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n                         const_cond = Some(expected);\n                     }\n                 }\n@@ -354,7 +352,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args) = match *msg {\n-                    mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                    EvalErrorKind::BoundsCheck { ref len, ref index } => {\n                         let len = self.trans_operand(&mut bx, len).immediate();\n                         let index = self.trans_operand(&mut bx, index).immediate();\n \n@@ -366,26 +364,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         (lang_items::PanicBoundsCheckFnLangItem,\n                          vec![file_line_col, index, len])\n                     }\n-                    mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = Symbol::intern(err.description()).as_str();\n-                        let msg_str = C_str_slice(bx.cx, msg_str);\n-                        let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n-                        let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                                msg_file_line_col,\n-                                                                align,\n-                                                                \"panic_loc\");\n-                        (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line_col])\n-                    }\n-                    mir::AssertMessage::GeneratorResumedAfterReturn |\n-                    mir::AssertMessage::GeneratorResumedAfterPanic => {\n-                        let str = if let mir::AssertMessage::GeneratorResumedAfterReturn = *msg {\n-                            \"generator resumed after completion\"\n-                        } else {\n-                            \"generator resumed after panicking\"\n-                        };\n+                    _ => {\n+                        let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bx.cx, msg_str);\n                         let msg_file_line_col = C_struct(bx.cx,"}, {"sha": "0cd823391b9b66ed4dd6872afb2f56d6ce51f0bc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n-use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n use std::{u128, i128};\n \n use base;\n@@ -805,6 +804,10 @@ fn cast_int_to_float(bx: &Builder,\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n+        use rustc_apfloat::ieee::Single;\n+        use rustc_apfloat::Float;\n+        const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n+                                            << (Single::MAX_EXP - Single::PRECISION as i16);\n         let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);"}, {"sha": "c426533779c9be18721ec458e7114feca16e048f", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -15,7 +15,6 @@ syntax = { path = \"../libsyntax\" }\n arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n rustc = { path = \"../librustc\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "350b53a406bc885268e54a37783b1c381fa79ce5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -92,7 +92,6 @@ extern crate syntax_pos;\n extern crate arena;\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_target;"}, {"sha": "059d41698953d2a4fcb85e36b1e45fd7e264ffa8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -31,7 +31,6 @@ extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n extern crate rustc_data_structures;\n-extern crate rustc_const_math;\n extern crate rustc_trans_utils;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "d16231c72b91a5040cf65ee083332eb9ccc592fe", "filename": "src/test/ui/const-eval/index_out_of_bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -2,7 +2,7 @@ error[E0080]: constant evaluation error\n   --> $DIR/index_out_of_bound.rs:11:19\n    |\n LL | static FOO: i32 = [][0];\n-   |                   ^^^^^ index out of bounds: the len is 0 but the index is 0 at $DIR/index_out_of_bound.rs:11:19: 11:24\n+   |                   ^^^^^ index out of bounds: the len is 0 but the index is 0\n \n error: aborting due to previous error\n "}, {"sha": "7761f192fdb70aa33edd4e4d1f6557bfb6625151", "filename": "src/test/ui/const-eval/promoted_errors.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpromoted_errors.stderr?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -2,21 +2,21 @@ warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:14:20\n    |\n LL |     println!(\"{}\", 0u32 - 1);\n-   |                    ^^^^^^^^ attempted to do overflowing math\n+   |                    ^^^^^^^^ attempt to subtract with overflow\n    |\n    = note: #[warn(const_err)] on by default\n \n warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:14:20\n    |\n LL |     println!(\"{}\", 0u32 - 1);\n-   |                    ^^^^^^^^ attempted to do overflowing math\n+   |                    ^^^^^^^^ attempt to subtract with overflow\n \n warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:17:14\n    |\n LL |     let _x = 0u32 - 1;\n-   |              ^^^^^^^^ attempted to do overflowing math\n+   |              ^^^^^^^^ attempt to subtract with overflow\n \n warning: attempt to divide by zero\n   --> $DIR/promoted_errors.rs:19:20\n@@ -28,7 +28,7 @@ warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:19:20\n    |\n LL |     println!(\"{}\", 1/(1-1));\n-   |                    ^^^^^^^ attempted to do overflowing math\n+   |                    ^^^^^^^ attempt to divide by zero\n \n warning: attempt to divide by zero\n   --> $DIR/promoted_errors.rs:22:14\n@@ -40,11 +40,11 @@ warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:22:14\n    |\n LL |     let _x = 1/(1-1);\n-   |              ^^^^^^^ attempted to do overflowing math\n+   |              ^^^^^^^ attempt to divide by zero\n \n warning: constant evaluation error\n   --> $DIR/promoted_errors.rs:25:20\n    |\n LL |     println!(\"{}\", 1/(false as u32));\n-   |                    ^^^^^^^^^^^^^^^^ attempted to do overflowing math\n+   |                    ^^^^^^^^^^^^^^^^ attempt to divide by zero\n "}, {"sha": "7f3e6eaad9b17963d825d532d470d2a0be4c85bb", "filename": "src/test/ui/error-codes/E0080.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -15,7 +15,6 @@ enum Enum {\n     //~| const_err\n     //~| const_err\n     //~| const_err\n-    //~| divide by zero\n }\n \n fn main() {"}, {"sha": "5e401bd6c79da92a3faa90ae0a3630422d832ffe", "filename": "src/test/ui/error-codes/E0080.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0d8321b5e87c87aa4dbea729b4dd722740fac645/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr?ref=0d8321b5e87c87aa4dbea729b4dd722740fac645", "patch": "@@ -24,7 +24,7 @@ warning: constant evaluation error\n   --> $DIR/E0080.rs:14:9\n    |\n LL |     Y = (1 / 0) //~ ERROR E0080\n-   |         ^^^^^^^ attempted to do overflowing math\n+   |         ^^^^^^^ attempt to divide by zero\n \n error[E0080]: constant evaluation error\n   --> $DIR/E0080.rs:14:9"}]}