{"sha": "b3317d68910900f135f9f38e43a7a699bc736b4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzE3ZDY4OTEwOTAwZjEzNWY5ZjM4ZTQzYTdhNjk5YmM3MzZiNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-31T05:47:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-31T05:47:35Z"}, "message": "Auto merge of #23884 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #23558, #23813, #23826, #23836, #23839, #23846, #23852, #23859, #23862, #23865, #23866, #23869, #23874\n- Failed merges:", "tree": {"sha": "fcc7af00740cd4540119a4f4bf345cd077ed269c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcc7af00740cd4540119a4f4bf345cd077ed269c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3317d68910900f135f9f38e43a7a699bc736b4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3317d68910900f135f9f38e43a7a699bc736b4a", "html_url": "https://github.com/rust-lang/rust/commit/b3317d68910900f135f9f38e43a7a699bc736b4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3317d68910900f135f9f38e43a7a699bc736b4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf3b0b74aadcc1fe87adbd2c74876a1f6c920b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf3b0b74aadcc1fe87adbd2c74876a1f6c920b3", "html_url": "https://github.com/rust-lang/rust/commit/6cf3b0b74aadcc1fe87adbd2c74876a1f6c920b3"}, {"sha": "db76327ef686d81c74e74ac25028681e61badb3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/db76327ef686d81c74e74ac25028681e61badb3c", "html_url": "https://github.com/rust-lang/rust/commit/db76327ef686d81c74e74ac25028681e61badb3c"}], "stats": {"total": 730, "additions": 511, "deletions": 219}, "files": [{"sha": "f594a6a19f1580ab9f5c489b7fcb969dc2ff4b7d", "filename": "mk/crates.mk", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -125,13 +125,18 @@ ONLY_RLIB_rustc_bitflags := 1\n # On channels where the only usable crate is std, only build documentation for\n # std. This keeps distributions small and doesn't clutter up the API docs with\n # confusing internal details from the crates behind the facade.\n+#\n+# (Disabled while cmr figures out how to change rustdoc to make reexports work\n+# slightly nicer. Otherwise, all cross-crate links to Vec will go to\n+# libcollections, breaking them, and [src] links for anything reexported will\n+# not work.)\n \n-ifeq ($(CFG_RELEASE_CHANNEL),stable)\n-DOC_CRATES := std\n-else\n-ifeq ($(CFG_RELEASE_CHANNEL),beta)\n-DOC_CRATES := std\n-else\n+#ifeq ($(CFG_RELEASE_CHANNEL),stable)\n+#DOC_CRATES := std\n+#else\n+#ifeq ($(CFG_RELEASE_CHANNEL),beta)\n+#DOC_CRATES := std\n+#else\n DOC_CRATES := $(filter-out rustc, \\\n \t   $(filter-out rustc_trans, \\\n \t   $(filter-out rustc_typeck, \\\n@@ -143,8 +148,8 @@ DOC_CRATES := $(filter-out rustc, \\\n \t   $(filter-out log, \\\n \t   $(filter-out getopts, \\\n \t   $(filter-out syntax, $(CRATES))))))))))))\n-endif\n-endif\n+#endif\n+#endif\n COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n                        rustc_typeck rustc_driver syntax rustc_privacy \\\n                        rustc_lint"}, {"sha": "0bc4414999d74e320e6968e410e3211a39237e01", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -1188,12 +1188,15 @@ the guarantee that these issues are never caused by safe code.\n \n * Data races\n * Dereferencing a null/dangling raw pointer\n-* Mutating an immutable value/reference without `UnsafeCell`\n * Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n   (uninitialized) memory\n * Breaking the [pointer aliasing\n   rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n   with raw pointers (a subset of the rules used by C)\n+* `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n+  contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n+  guarantees.\n+* Mutating an immutable value/reference without `UnsafeCell<U>`\n * Invoking undefined behavior via compiler intrinsics:\n   * Indexing outside of the bounds of an object with `std::ptr::offset`\n     (`offset` intrinsic), with\n@@ -1210,6 +1213,8 @@ the guarantee that these issues are never caused by safe code.\n   code. Rust's failure system is not compatible with exception handling in\n   other languages. Unwinding must be caught and handled at FFI boundaries.\n \n+[noalias]: http://llvm.org/docs/LangRef.html#noalias\n+\n ##### Behaviour not considered unsafe\n \n This is a list of behaviour not considered *unsafe* in Rust terms, but that may"}, {"sha": "18542e58bbfd2b878f06d982f8f801f3a6882922", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -181,17 +181,23 @@ impl Circle {\n }\n \n struct CircleBuilder {\n-    coordinate: f64,\n+    x: f64,\n+    y: f64,\n     radius: f64,\n }\n \n impl CircleBuilder {\n     fn new() -> CircleBuilder {\n-        CircleBuilder { coordinate: 0.0, radius: 0.0, }\n+        CircleBuilder { x: 0.0, y: 0.0, radius: 0.0, }\n+    }\n+\n+    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {\n+        self.x = coordinate;\n+        self\n     }\n \n-    fn coordinate(&mut self, coordinate: f64) -> &mut CircleBuilder {\n-        self.coordinate = coordinate;\n+    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {\n+        self.x = coordinate;\n         self\n     }\n \n@@ -201,18 +207,20 @@ impl CircleBuilder {\n     }\n \n     fn finalize(&self) -> Circle {\n-        Circle { x: self.coordinate, y: self.coordinate, radius: self.radius }\n+        Circle { x: self.x, y: self.y, radius: self.radius }\n     }\n }\n \n fn main() {\n     let c = CircleBuilder::new()\n-                .coordinate(10.0)\n-                .radius(5.0)\n+                .x(1.0)\n+                .y(2.0)\n+                .radius(2.0)\n                 .finalize();\n \n-\n     println!(\"area: {}\", c.area());\n+    println!(\"x: {}\", c.x);\n+    println!(\"y: {}\", c.y);\n }\n ```\n "}, {"sha": "f4b5495ba6390d88e50161e7bbb0e212d1324aae", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -472,10 +472,15 @@ thread-safe counterpart of `Rc<T>`.\n \n ## Lifetime Elision\n \n-Earlier, we mentioned *lifetime elision*, a feature of Rust which allows you to\n-not write lifetime annotations in certain circumstances. All references have a\n-lifetime, and so if you elide a lifetime (like `&T` instead of `&'a T`), Rust\n-will do three things to determine what those lifetimes should be.\n+Rust supports powerful local type inference in function bodies, but it\u2019s\n+forbidden in item signatures to allow reasoning about the types just based in\n+the item signature alone. However, for ergonomic reasons a very restricted\n+secondary inference algorithm called \u201clifetime elision\u201d applies in function\n+signatures. It infers only based on the signature components themselves and not\n+based on the body of the function, only infers lifetime paramters, and does\n+this with only three easily memorizable and unambiguous rules. This makes\n+lifetime elision a shorthand for writing an item signature, while not hiding\n+away the actual types involved as full local inference would if applied to it.\n \n When talking about lifetime elision, we use the term *input lifetime* and\n *output lifetime*. An *input lifetime* is a lifetime associated with a parameter"}, {"sha": "8b2c14526cbf0fd91a5611bbfd223fbae6c91125", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -231,7 +231,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod tests {\n+mod test {\n     use super::add_two;\n \n     #[test]\n@@ -241,7 +241,7 @@ mod tests {\n }\n ```\n \n-There's a few changes here. The first is the introduction of a `mod tests` with\n+There's a few changes here. The first is the introduction of a `mod test` with\n a `cfg` attribute. The module allows us to group all of our tests together, and\n to also define helper functions if needed, that don't become a part of the rest\n of our crate. The `cfg` attribute only compiles our test code if we're\n@@ -260,7 +260,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod tests {\n+mod test {\n     use super::*;\n \n     #[test]"}, {"sha": "c6c86e46b444306de395553422060d277aa36d6a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -301,7 +301,7 @@ mod imp {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n             let new_ptr = allocate(size, align);\n-            ptr::copy(new_ptr, ptr, cmp::min(size, old_size));\n+            ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n             deallocate(ptr, old_size, align);\n             new_ptr\n         }"}, {"sha": "847ee7c19ce94d7b7f8329938a9267c7418a4b36", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -1133,13 +1133,13 @@ impl<K, V> Node<K, V> {\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n         ptr::copy(\n-            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.keys().as_ptr().offset(index as isize),\n+            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n         ptr::copy(\n-            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.vals().as_ptr().offset(index as isize),\n+            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n \n@@ -1155,8 +1155,8 @@ impl<K, V> Node<K, V> {\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n         ptr::copy(\n-            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.edges().as_ptr().offset(index as isize),\n+            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n@@ -1188,13 +1188,13 @@ impl<K, V> Node<K, V> {\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy(\n-            self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.keys().as_ptr().offset(index as isize + 1),\n+            self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.len() - index - 1\n         );\n         ptr::copy(\n-            self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.vals().as_ptr().offset(index as isize + 1),\n+            self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.len() - index - 1\n         );\n \n@@ -1209,8 +1209,8 @@ impl<K, V> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy(\n-            self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n+            self.edges_mut().as_mut_ptr().offset(index as isize),\n             // index can be == len+1, so do the +1 first to avoid underflow.\n             (self.len() + 1) - index\n         );\n@@ -1237,19 +1237,19 @@ impl<K, V> Node<K, V> {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n             ptr::copy_nonoverlapping(\n-                right.keys_mut().as_mut_ptr(),\n                 self.keys().as_ptr().offset(right_offset as isize),\n+                right.keys_mut().as_mut_ptr(),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping(\n-                right.vals_mut().as_mut_ptr(),\n                 self.vals().as_ptr().offset(right_offset as isize),\n+                right.vals_mut().as_mut_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping(\n-                    right.edges_mut().as_mut_ptr(),\n                     self.edges().as_ptr().offset(right_offset as isize),\n+                    right.edges_mut().as_mut_ptr(),\n                     right.len() + 1\n                 );\n             }\n@@ -1278,19 +1278,19 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping(\n-                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n+                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping(\n-                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n+                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping(\n-                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n+                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.len() + 1\n                 );\n             }"}, {"sha": "0ca297765ff6d6fa82b5a5913a271c8324248197", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -1320,10 +1320,10 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy(buf_v.offset(j + 1),\n-                          &*buf_v.offset(j),\n+                ptr::copy(&*buf_v.offset(j),\n+                          buf_v.offset(j + 1),\n                           (i - j) as usize);\n-                ptr::copy_nonoverlapping(buf_v.offset(j), &tmp, 1);\n+                ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n                 mem::forget(tmp);\n             }\n         }\n@@ -1396,10 +1396,10 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy(buf_dat.offset(j + 1),\n-                          &*buf_dat.offset(j),\n+                ptr::copy(&*buf_dat.offset(j),\n+                          buf_dat.offset(j + 1),\n                           i - j as usize);\n-                ptr::copy_nonoverlapping(buf_dat.offset(j), read_ptr, 1);\n+                ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n             }\n         }\n     }\n@@ -1447,11 +1447,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(out, &*right, elems);\n+                        ptr::copy_nonoverlapping(&*right, out, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(out, &*left, elems);\n+                        ptr::copy_nonoverlapping(&*left, out, elems);\n                         break;\n                     }\n \n@@ -1465,7 +1465,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping(out, &*to_copy, 1);\n+                    ptr::copy_nonoverlapping(&*to_copy, out, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -1479,7 +1479,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping(v.as_mut_ptr(), &*buf_dat, len);\n+        ptr::copy_nonoverlapping(&*buf_dat, v.as_mut_ptr(), len);\n     }\n \n     // increment the pointer, returning the old pointer."}, {"sha": "dbf214a712b6528cecc3f57493aed7666ad5538d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -592,8 +592,8 @@ impl String {\n         let ch = self.char_at(idx);\n         let next = idx + ch.len_utf8();\n         unsafe {\n-            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n-                      self.vec.as_ptr().offset(next as isize),\n+            ptr::copy(self.vec.as_ptr().offset(next as isize),\n+                      self.vec.as_mut_ptr().offset(idx as isize),\n                       len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n@@ -622,11 +622,11 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n-                      self.vec.as_ptr().offset(idx as isize),\n+            ptr::copy(self.vec.as_ptr().offset(idx as isize),\n+                      self.vec.as_mut_ptr().offset((idx + amt) as isize),\n                       len - idx);\n-            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n-                      bits.as_ptr(),\n+            ptr::copy(bits.as_ptr(),\n+                      self.vec.as_mut_ptr().offset(idx as isize),\n                       amt);\n             self.vec.set_len(len + amt);\n         }\n@@ -1019,27 +1019,44 @@ impl AsRef<str> for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for String {\n+    #[inline]\n     fn from(s: &'a str) -> String {\n         s.to_string()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for Cow<'a, str> {\n+    #[inline]\n+    fn from(s: &'a str) -> Cow<'a, str> {\n+        Cow::Borrowed(s)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<String> for Cow<'a, str> {\n+    #[inline]\n+    fn from(s: String) -> Cow<'a, str> {\n+        Cow::Owned(s)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Into<Vec<u8>> for String {\n     fn into(self) -> Vec<u8> {\n         self.into_bytes()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n impl IntoCow<'static, str> for String {\n     #[inline]\n     fn into_cow(self) -> Cow<'static, str> {\n         Cow::Owned(self)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n impl<'a> IntoCow<'a, str> for &'a str {\n     #[inline]\n     fn into_cow(self) -> Cow<'a, str> {"}, {"sha": "3595288a6c94067d0126c23d74365932dc50913e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -260,16 +260,17 @@ impl<T> Vec<T> {\n \n     /// Creates a vector by copying the elements from a raw pointer.\n     ///\n-    /// This function will copy `elts` contiguous elements starting at `ptr` into a new allocation\n-    /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n-    /// without cloning, as if `ptr::read()` were called on them.\n+    /// This function will copy `elts` contiguous elements starting at `ptr`\n+    /// into a new allocation owned by the returned `Vec<T>`. The elements of\n+    /// the buffer are copied into the vector without cloning, as if\n+    /// `ptr::read()` were called on them.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n-        ptr::copy_nonoverlapping(dst.as_mut_ptr(), ptr, elts);\n+        ptr::copy_nonoverlapping(ptr, dst.as_mut_ptr(), elts);\n         dst\n     }\n \n@@ -288,8 +289,9 @@ impl<T> Vec<T> {\n         self.cap\n     }\n \n-    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -541,7 +543,7 @@ impl<T> Vec<T> {\n                 let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n-                ptr::copy(p.offset(1), &*p, len - index);\n+                ptr::copy(&*p, p.offset(1), len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n                 ptr::write(&mut *p, element);\n@@ -579,7 +581,7 @@ impl<T> Vec<T> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy(ptr, &*ptr.offset(1), len - index - 1);\n+                ptr::copy(&*ptr.offset(1), ptr, len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -721,8 +723,8 @@ impl<T> Vec<T> {\n         let len = self.len();\n         unsafe {\n             ptr::copy_nonoverlapping(\n-                self.get_unchecked_mut(len),\n                 other.as_ptr(),\n+                self.get_unchecked_mut(len),\n                 other.len());\n         }\n \n@@ -1042,8 +1044,8 @@ impl<T> Vec<T> {\n             other.set_len(other_len);\n \n             ptr::copy_nonoverlapping(\n-                other.as_mut_ptr(),\n                 self.as_ptr().offset(at as isize),\n+                other.as_mut_ptr(),\n                 other.len());\n         }\n         other"}, {"sha": "abe8e7cf3aa0fd9de1df96657391104ac3b381f2", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -142,8 +142,8 @@ impl<T> VecDeque<T> {\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy(\n-            self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n+            self.ptr.offset(dst as isize),\n             len);\n     }\n \n@@ -155,8 +155,8 @@ impl<T> VecDeque<T> {\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_nonoverlapping(\n-            self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n+            self.ptr.offset(dst as isize),\n             len);\n     }\n }\n@@ -1361,21 +1361,21 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping(*other.ptr,\n-                                         first_half.as_ptr().offset(at as isize),\n+                ptr::copy_nonoverlapping(first_half.as_ptr().offset(at as isize),\n+                                         *other.ptr,\n                                          amount_in_first);\n \n                 // just take all of the second half.\n-                ptr::copy_nonoverlapping(other.ptr.offset(amount_in_first as isize),\n-                                         second_half.as_ptr(),\n+                ptr::copy_nonoverlapping(second_half.as_ptr(),\n+                                         other.ptr.offset(amount_in_first as isize),\n                                          second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping(*other.ptr,\n-                                         second_half.as_ptr().offset(offset as isize),\n+                ptr::copy_nonoverlapping(second_half.as_ptr().offset(offset as isize),\n+                                         *other.ptr,\n                                          amount_in_second);\n             }\n         }"}, {"sha": "9430aa0066871326399b577f02d72884cf3eae68", "filename": "src/libcore/error.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -48,33 +48,30 @@\n //! For example,\n //!\n //! ```\n-//! # #![feature(os, old_io, old_path)]\n+//! #![feature(core)]\n //! use std::error::FromError;\n-//! use std::old_io::{File, IoError};\n-//! use std::os::{MemoryMap, MapError};\n-//! use std::old_path::Path;\n+//! use std::{io, str};\n+//! use std::fs::File;\n //!\n //! enum MyError {\n-//!     Io(IoError),\n-//!     Map(MapError)\n+//!     Io(io::Error),\n+//!     Utf8(str::Utf8Error),\n //! }\n //!\n-//! impl FromError<IoError> for MyError {\n-//!     fn from_error(err: IoError) -> MyError {\n-//!         MyError::Io(err)\n-//!     }\n+//! impl FromError<io::Error> for MyError {\n+//!     fn from_error(err: io::Error) -> MyError { MyError::Io(err) }\n //! }\n //!\n-//! impl FromError<MapError> for MyError {\n-//!     fn from_error(err: MapError) -> MyError {\n-//!         MyError::Map(err)\n-//!     }\n+//! impl FromError<str::Utf8Error> for MyError {\n+//!     fn from_error(err: str::Utf8Error) -> MyError { MyError::Utf8(err) }\n //! }\n //!\n //! #[allow(unused_variables)]\n //! fn open_and_map() -> Result<(), MyError> {\n-//!     let f = try!(File::open(&Path::new(\"foo.txt\")));\n-//!     let m = try!(MemoryMap::new(0, &[]));\n+//!     let b = b\"foo.txt\";\n+//!     let s = try!(str::from_utf8(b));\n+//!     let f = try!(File::open(s));\n+//!\n //!     // do something interesting here...\n //!     Ok(())\n //! }"}, {"sha": "6a5943265ca88fee04ccecb1ba986b6d7ab85ad0", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -316,8 +316,8 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::Write for Filler<'a> {\n                 fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(&mut self.buf[(*self.end)..],\n-                                              s.as_bytes());\n+                    slice::bytes::copy_memory(s.as_bytes(),\n+                                              &mut self.buf[(*self.end)..]);\n                     *self.end += s.len();\n                     Ok(())\n                 }"}, {"sha": "43cf64bf3ad9dfbe2af6ec10269dd70c06aa7d94", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -293,9 +293,9 @@ extern \"rust-intrinsic\" {\n     ///         let mut t: T = mem::uninitialized();\n     ///\n     ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping(&mut t, &*x, 1);\n-    ///         ptr::copy_nonoverlapping(x, &*y, 1);\n-    ///         ptr::copy_nonoverlapping(y, &t, 1);\n+    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n+    ///         ptr::copy_nonoverlapping(y, x, 1);\n+    ///         ptr::copy_nonoverlapping(&t, y, 1);\n     ///\n     ///         // y and t now point to the same thing, but we need to completely forget `tmp`\n     ///         // because it's no longer relevant.\n@@ -304,6 +304,12 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// dox\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(stage0)]\n     pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -329,12 +335,18 @@ extern \"rust-intrinsic\" {\n     /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n     ///     dst.set_len(elts);\n-    ///     ptr::copy(dst.as_mut_ptr(), ptr, elts);\n+    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n     ///     dst\n     /// }\n     /// ```\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// dox\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(stage0)]\n     pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`"}, {"sha": "98e8668239bb8ee67e9aed5fcd3cce856c291838", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -229,9 +229,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let mut t: T = uninitialized();\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping(&mut t, &*x, 1);\n-        ptr::copy_nonoverlapping(x, &*y, 1);\n-        ptr::copy_nonoverlapping(y, &t, 1);\n+        ptr::copy_nonoverlapping(&*x, &mut t, 1);\n+        ptr::copy_nonoverlapping(&*y, x, 1);\n+        ptr::copy_nonoverlapping(&t, y, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `t`\n         // because it's no longer relevant."}, {"sha": "c5102ede29fcf82f0ab37905e444f973d492ba98", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -333,7 +333,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Moves the value `v` out of the `Option<T>` if the content of the `Option<T>` is a `Some(v)`.\n+    /// Moves the value `v` out of the `Option<T>` if it is `Some(v)`.\n     ///\n     /// # Panics\n     ///"}, {"sha": "41a70ef708f30d85a5a49ff63c175cad0ccdb826", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -104,11 +104,28 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n pub use intrinsics::copy_nonoverlapping;\n \n+/// dox\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n+    intrinsics::copy_nonoverlapping(dst, src, count)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n pub use intrinsics::copy;\n \n+/// dox\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n+    intrinsics::copy(dst, src, count)\n+}\n+\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::write_bytes;\n \n@@ -167,12 +184,11 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n-    let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping(t, &*x, 1);\n-    copy(x, &*y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(y, &*t, 1);\n+    copy_nonoverlapping(x, &mut tmp, 1);\n+    copy(y, x, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping(&tmp, y, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n@@ -208,7 +224,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n-    copy_nonoverlapping(&mut tmp, src, 1);\n+    copy_nonoverlapping(src, &mut tmp, 1);\n     tmp\n }\n "}, {"sha": "223a0bdae36cd8c3cebe763a4192e2950732c4e6", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -1577,14 +1577,14 @@ pub mod bytes {\n     ///\n     /// Panics if the length of `dst` is less than the length of `src`.\n     #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n+    pub fn copy_memory(src: &[u8], dst: &mut [u8]) {\n         let len_src = src.len();\n         assert!(dst.len() >= len_src);\n         // `dst` is unaliasable, so we know statically it doesn't overlap\n         // with `src`.\n         unsafe {\n-            ptr::copy_nonoverlapping(dst.as_mut_ptr(),\n-                                     src.as_ptr(),\n+            ptr::copy_nonoverlapping(src.as_ptr(),\n+                                     dst.as_mut_ptr(),\n                                      len_src);\n         }\n     }"}, {"sha": "8f1017c50a39d318b76152ffd7913294cae344d2", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -35,18 +35,15 @@ fn test() {\n         let v0 = vec![32000u16, 32001u16, 32002u16];\n         let mut v1 = vec![0u16, 0u16, 0u16];\n \n-        copy(v1.as_mut_ptr().offset(1),\n-             v0.as_ptr().offset(1), 1);\n+        copy(v0.as_ptr().offset(1), v1.as_mut_ptr().offset(1), 1);\n         assert!((v1[0] == 0u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy(v1.as_mut_ptr(),\n-             v0.as_ptr().offset(2), 1);\n+        copy(v0.as_ptr().offset(2), v1.as_mut_ptr(), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy(v1.as_mut_ptr().offset(2),\n-             v0.as_ptr(), 1);\n+        copy(v0.as_ptr(), v1.as_mut_ptr().offset(2), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 32000u16));"}, {"sha": "80341fa1a7a2f886f904fc96cd9e9da46750e60b", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -449,21 +449,21 @@ pub mod reader {\n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2);\n         let mut b = [0; 2];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u16)).to_be() }\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4);\n         let mut b = [0; 4];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8);\n         let mut b = [0; 8];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u64)).to_be() }\n     }\n \n@@ -938,7 +938,7 @@ pub mod writer {\n                 {\n                     let last_size_pos = last_size_pos as usize;\n                     let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n-                    bytes::copy_memory(&mut buf, data);\n+                    bytes::copy_memory(data, &mut buf);\n                 }\n \n                 // overwrite the size and data and continue"}, {"sha": "1cff7c448a96277892835fe32a8c8c91ae17836a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -62,7 +62,7 @@ pub type Cmd<'a> = &'a crate_metadata;\n \n fn u32_from_be_bytes(bytes: &[u8]) -> u32 {\n     let mut b = [0; 4];\n-    bytes::copy_memory(&mut b, &bytes[..4]);\n+    bytes::copy_memory(&bytes[..4], &mut b);\n     unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n }\n "}, {"sha": "e98b438d370c70055c9cbda771733033b8464814", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -885,6 +885,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         }\n     }\n \n+    // When this returns true, it means that the expression *is* a\n+    // method-call (i.e. via the operator-overload).  This true result\n+    // also implies that walk_overloaded_operator already took care of\n+    // recursively processing the input arguments, and thus the caller\n+    // should not do so.\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,"}, {"sha": "3738e38f68704988e75dfc6c1231570f1e6c2fa2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 118, "deletions": 51, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -71,6 +71,8 @@ pub use self::Note::*;\n pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n+use self::Aliasability::*;\n+\n use middle::check_const;\n use middle::def;\n use middle::region;\n@@ -295,23 +297,29 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n \n impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n-        match m {\n+        let ret = match m {\n             MutImmutable => McImmutable,\n             MutMutable => McDeclared\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_mutbl\", m, ret);\n+        ret\n     }\n \n     pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n-        match borrow_kind {\n+        let ret = match borrow_kind {\n             ty::ImmBorrow => McImmutable,\n             ty::UniqueImmBorrow => McImmutable,\n             ty::MutBorrow => McDeclared,\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_borrow_kind\", borrow_kind, ret);\n+        ret\n     }\n \n-    pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n-                             ptr: PointerKind) -> MutabilityCategory {\n-        match ptr {\n+    fn from_pointer_kind(base_mutbl: MutabilityCategory,\n+                         ptr: PointerKind) -> MutabilityCategory {\n+        let ret = match ptr {\n             Unique => {\n                 base_mutbl.inherit()\n             }\n@@ -321,11 +329,14 @@ impl MutabilityCategory {\n             UnsafePtr(m) => {\n                 MutabilityCategory::from_mutbl(m)\n             }\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}, {:?}) => {:?}\",\n+               \"from_pointer_kind\", base_mutbl, ptr, ret);\n+        ret\n     }\n \n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n-        match tcx.map.get(id) {\n+        let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n                 ast::PatIdent(bind_mode, _, _) => {\n                     if bind_mode == ast::BindByValue(ast::MutMutable) {\n@@ -337,30 +348,39 @@ impl MutabilityCategory {\n                 _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n             },\n             _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n+               \"from_local\", id, ret);\n+        ret\n     }\n \n     pub fn inherit(&self) -> MutabilityCategory {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => McImmutable,\n             McDeclared => McInherited,\n             McInherited => McInherited,\n-        }\n+        };\n+        debug!(\"{:?}.inherit() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_mutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => false,\n             McInherited => true,\n             McDeclared => true,\n-        }\n+        };\n+        debug!(\"{:?}.is_mutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_immutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => true,\n             McDeclared | McInherited => false\n-        }\n+        };\n+        debug!(\"{:?}.is_immutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn to_user_str(&self) -> &'static str {\n@@ -733,7 +753,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n         };\n \n-        Ok(Rc::new(cmt_result))\n+        let ret = Rc::new(cmt_result);\n+        debug!(\"cat_upvar ret={}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     fn env_deref(&self,\n@@ -794,14 +816,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             McDeclared | McInherited => { }\n         }\n \n-        cmt_ {\n+        let ret = cmt_ {\n             id: id,\n             span: span,\n             cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n             mutbl: deref_mutbl,\n             ty: var_ty,\n             note: NoteClosureEnv(upvar_id)\n-        }\n+        };\n+\n+        debug!(\"env_deref ret {}\", ret.repr(self.tcx()));\n+\n+        ret\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -831,22 +857,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 }\n             }\n         };\n-        self.cat_rvalue(id, span, re, expr_ty)\n+        let ret = self.cat_rvalue(id, span, re, expr_ty);\n+        debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_rvalue ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_field<N:ast_node>(&self,\n@@ -855,14 +885,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                  f_name: ast::Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_tup_field<N:ast_node>(&self,\n@@ -871,14 +903,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                      f_idx: usize,\n                                      f_ty: Ty<'tcx>)\n                                      -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(PositionalField(f_idx))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_tup_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     fn cat_deref<N:ast_node>(&self,\n@@ -913,10 +947,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt,\n+            Some(mt) => {\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n                                               deref_context,\n-                                              /* implicit: */ false),\n+                                                /* implicit: */ false);\n+                debug!(\"cat_deref ret {}\", ret.repr(self.tcx()));\n+                ret\n+            }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -954,14 +992,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        Ok(Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty,\n             note: NoteNone\n-        }))\n+        });\n+        debug!(\"cat_deref_common ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1009,8 +1049,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty,\n-                           m, context, element_ty));\n+        let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n+                           m, context, element_ty);\n+        debug!(\"cat_index ret {}\", ret.repr(self.tcx()));\n+        return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,\n@@ -1039,14 +1081,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              context: InteriorOffsetKind)\n                              -> McResult<cmt<'tcx>>\n     {\n-        match try!(deref_kind(base_cmt.ty, Some(context))) {\n+        let ret = match try!(deref_kind(base_cmt.ty, Some(context))) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n                 // the deref is explicit in the resulting cmt\n-                Ok(Rc::new(cmt_ {\n+                Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n@@ -1056,13 +1098,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n-                }))\n+                })\n             }\n \n             deref_interior(_) => {\n-                Ok(base_cmt)\n+                base_cmt\n             }\n-        }\n+        };\n+        debug!(\"deref_vec ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     /// Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is the cmt for `P`, `slice_pat` is\n@@ -1112,14 +1156,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n                                         -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_imm_interior ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_downcast<N:ast_node>(&self,\n@@ -1128,14 +1174,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     downcast_ty: Ty<'tcx>,\n                                     variant_did: ast::DefId)\n                                     -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_downcast(base_cmt, variant_did),\n             ty: downcast_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_downcast ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n@@ -1341,17 +1389,25 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n }\n \n-#[derive(Copy)]\n+#[derive(Copy, Clone, Debug)]\n pub enum InteriorSafety {\n     InteriorUnsafe,\n     InteriorSafe\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Debug)]\n+pub enum Aliasability {\n+    FreelyAliasable(AliasableReason),\n+    NonAliasable,\n+    ImmutableUnique(Box<Aliasability>),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n pub enum AliasableReason {\n     AliasableBorrowed,\n     AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n     AliasableOther,\n+    UnaliasableImmutable, // Created as needed upon seeing ImmutableUnique\n     AliasableStatic(InteriorSafety),\n     AliasableStaticMut(InteriorSafety),\n }\n@@ -1380,9 +1436,9 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    /// Returns `Some(_)` if this lvalue represents a freely aliasable pointer type.\n+    /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n     pub fn freely_aliasable(&self, ctxt: &ty::ctxt<'tcx>)\n-                            -> Option<AliasableReason> {\n+                            -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n         // aliased and eventually recused.\n@@ -1393,17 +1449,27 @@ impl<'tcx> cmt_<'tcx> {\n             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n             cat_downcast(ref b, _) |\n-            cat_deref(ref b, _, Unique) |\n             cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n \n+            cat_deref(ref b, _, Unique) => {\n+                let sub = b.freely_aliasable(ctxt);\n+                if b.mutbl.is_mutable() {\n+                    // Aliasability depends on base cmt alone\n+                    sub\n+                } else {\n+                    // Do not allow mutation through an immutable box.\n+                    ImmutableUnique(Box::new(sub))\n+                }\n+            }\n+\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n-                None\n+                NonAliasable\n             }\n \n             cat_static_item(..) => {\n@@ -1414,17 +1480,18 @@ impl<'tcx> cmt_<'tcx> {\n                 };\n \n                 if self.mutbl.is_mutable() {\n-                    Some(AliasableStaticMut(int_safe))\n+                    FreelyAliasable(AliasableStaticMut(int_safe))\n                 } else {\n-                    Some(AliasableStatic(int_safe))\n+                    FreelyAliasable(AliasableStatic(int_safe))\n                 }\n             }\n \n             cat_deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n             cat_deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n                 match base.cat {\n-                    cat_upvar(Upvar{ id, .. }) => Some(AliasableClosure(id.closure_expr_id)),\n-                    _ => Some(AliasableBorrowed)\n+                    cat_upvar(Upvar{ id, .. }) =>\n+                        FreelyAliasable(AliasableClosure(id.closure_expr_id)),\n+                    _ => FreelyAliasable(AliasableBorrowed)\n                 }\n             }\n         }"}, {"sha": "f0e1427e6db60a80a258a62a7719c754663239de", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -139,15 +139,15 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        &mut self.buffer[self.buffer_idx..size],\n-                        &input[..buffer_remaining]);\n+                        &input[..buffer_remaining],\n+                        &mut self.buffer[self.buffer_idx..size]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    &mut self.buffer[self.buffer_idx..self.buffer_idx + input.len()],\n-                    input);\n+                    input,\n+                    &mut self.buffer[self.buffer_idx..self.buffer_idx + input.len()]);\n                 self.buffer_idx += input.len();\n                 return;\n             }\n@@ -165,8 +165,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            &mut self.buffer[..input_remaining],\n-            &input[i..]);\n+            &input[i..],\n+            &mut self.buffer[..input_remaining]);\n         self.buffer_idx += input_remaining;\n     }\n "}, {"sha": "ce7b492c51af158de887e36a92efb09feacb8a6e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -943,13 +943,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                       cmt: mc::cmt<'tcx>)\n                                                       -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n-                None => {\n+                mc::Aliasability::NonAliasable => {\n                     return true;\n                 }\n-                Some(mc::AliasableStaticMut(..)) => {\n+                mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)) => {\n                     return true;\n                 }\n-                Some(cause) => {\n+                mc::Aliasability::ImmutableUnique(_) => {\n+                    this.bccx.report_aliasability_violation(\n+                        span,\n+                        MutabilityViolation,\n+                        mc::AliasableReason::UnaliasableImmutable);\n+                    return false;\n+                }\n+                mc::Aliasability::FreelyAliasable(cause) => {\n                     this.bccx.report_aliasability_violation(\n                         span,\n                         MutabilityViolation,"}, {"sha": "733d486d2d22d3ae495b10f2ddc233b423a1de4a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -151,10 +151,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr(self.tcx()));\n+        let opt_lp = opt_loan_path(&assignee_cmt);\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n+               assignment_id, assignee_cmt.repr(self.tcx()), opt_lp);\n \n-        match opt_loan_path(&assignee_cmt) {\n+        match opt_lp {\n             Some(lp) => {\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n                                                 assignment_id, assignment_span,\n@@ -181,12 +182,16 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n-    match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n-        (None, _) => {\n+    let aliasability = cmt.freely_aliasable(bccx.tcx);\n+    debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n+           aliasability, req_kind);\n+\n+    match (aliasability, req_kind) {\n+        (mc::Aliasability::NonAliasable, _) => {\n             /* Uniquely accessible path -- OK for `&` and `&mut` */\n             Ok(())\n         }\n-        (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n             // Borrow of an immutable static item:\n             match safety {\n                 mc::InteriorUnsafe => {\n@@ -202,13 +207,20 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        (Some(mc::AliasableStaticMut(..)), _) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)), _) => {\n             // Even touching a static mut is considered unsafe. We assume the\n             // user knows what they're doing in these cases.\n             Ok(())\n         }\n-        (Some(alias_cause), ty::UniqueImmBorrow) |\n-        (Some(alias_cause), ty::MutBorrow) => {\n+        (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n+            bccx.report_aliasability_violation(\n+                        borrow_span,\n+                        BorrowViolation(loan_cause),\n+                        mc::AliasableReason::UnaliasableImmutable);\n+            Err(())\n+        }\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         BorrowViolation(loan_cause),\n@@ -376,7 +388,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n-\n+            debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n+                   cause, cmt.repr(bccx.tcx), req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {"}, {"sha": "268e469b7f91580b0e5a0773baea799e5e27f19e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -844,6 +844,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     &format!(\"{} in an aliasable location\",\n                              prefix));\n             }\n+            mc::AliasableReason::UnaliasableImmutable => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"{} in an immutable container\",\n+                             prefix));\n+            }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        &format!(\"{} in a captured outer \\"}, {"sha": "586a1eb085c1c4e841dcba8ef76680913c872d23", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -39,7 +39,7 @@ use util::ppaux::ty_to_string;\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n-use std::collections::BitSet;\n+use std::collections::{HashSet, BitSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -1437,6 +1437,9 @@ pub struct MissingDoc {\n     /// Stack of whether #[doc(hidden)] is set\n     /// at each level which has lint attributes.\n     doc_hidden_stack: Vec<bool>,\n+\n+    /// Private traits or trait items that leaked through. Don't check their methods.\n+    private_traits: HashSet<ast::NodeId>,\n }\n \n impl MissingDoc {\n@@ -1445,6 +1448,7 @@ impl MissingDoc {\n             struct_def_stack: vec!(),\n             in_variant: false,\n             doc_hidden_stack: vec!(false),\n+            private_traits: HashSet::new(),\n         }\n     }\n \n@@ -1531,18 +1535,46 @@ impl LintPass for MissingDoc {\n             ast::ItemMod(..) => \"a module\",\n             ast::ItemEnum(..) => \"an enum\",\n             ast::ItemStruct(..) => \"a struct\",\n-            ast::ItemTrait(..) => \"a trait\",\n+            ast::ItemTrait(_, _, _, ref items) => {\n+                // Issue #11592, traits are always considered exported, even when private.\n+                if it.vis == ast::Visibility::Inherited {\n+                    self.private_traits.insert(it.id);\n+                    for itm in items {\n+                        self.private_traits.insert(itm.id);\n+                    }\n+                    return\n+                }\n+                \"a trait\"\n+            },\n             ast::ItemTy(..) => \"a type alias\",\n+            ast::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n+                // If the trait is private, add the impl items to private_traits so they don't get\n+                // reported for missing docs.\n+                let real_trait = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                match cx.tcx.map.find(real_trait.node) {\n+                    Some(ast_map::NodeItem(item)) => if item.vis == ast::Visibility::Inherited {\n+                        for itm in impl_items {\n+                            self.private_traits.insert(itm.id);\n+                        }\n+                    },\n+                    _ => { }\n+                }\n+                return\n+            },\n             _ => return\n         };\n+\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        if self.private_traits.contains(&trait_item.id) { return }\n+\n         let desc = match trait_item.node {\n             ast::MethodTraitItem(..) => \"a trait method\",\n             ast::TypeTraitItem(..) => \"an associated type\"\n         };\n+\n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n                                       &trait_item.attrs,\n                                       trait_item.span, desc);"}, {"sha": "62a6ede4c2f936bdcdefaec91e8e21c5e12cca96", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -398,8 +398,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            false,\n                            false,\n                            *substs.types.get(FnSpace, 0),\n-                           llargs[0],\n                            llargs[1],\n+                           llargs[0],\n                            llargs[2],\n                            call_debug_location)\n         }\n@@ -408,8 +408,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            true,\n                            false,\n                            *substs.types.get(FnSpace, 0),\n-                           llargs[0],\n                            llargs[1],\n+                           llargs[0],\n                            llargs[2],\n                            call_debug_location)\n         }"}, {"sha": "8a61142c1731611c0cd896010d4883bb098fa18b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -5080,7 +5080,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                    mutbl: ast::MutImmutable\n                }))\n             }\n-            \"copy\" | \"copy_nonoverlapping\" |\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+              (1,\n+               vec!(\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               ty::mk_nil(tcx))\n+            }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!("}, {"sha": "babbe15b17df51ad1beeaa06f6540f6c2c951e74", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -243,8 +243,9 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n             if should_panic && out.status.success() {\n                 panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_panic && !out.status.success() {\n-                panic!(\"test executable failed:\\n{:?}\",\n-                      str::from_utf8(&out.stdout));\n+                panic!(\"test executable failed:\\n{}\\n{}\",\n+                       str::from_utf8(&out.stdout).unwrap_or(\"\"),\n+                       str::from_utf8(&out.stderr).unwrap_or(\"\"));\n             }\n         }\n     }"}, {"sha": "aa3195cbf018b2e43178fc19968d4da6db1641c1", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -480,8 +480,8 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.gap.raw.key, self.full.raw.key, 1);\n-            ptr::copy_nonoverlapping(self.gap.raw.val, self.full.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;"}, {"sha": "8eea06bf6b0c729f672d0bff9ebbc4843bf277b4", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -177,8 +177,8 @@ impl<W: Write> BufWriter<W> {\n         if written > 0 {\n             // NB: would be better expressed as .remove(0..n) if it existed\n             unsafe {\n-                ptr::copy(self.buf.as_mut_ptr(),\n-                          self.buf.as_ptr().offset(written as isize),\n+                ptr::copy(self.buf.as_ptr().offset(written as isize),\n+                          self.buf.as_mut_ptr(),\n                           len - written);\n             }\n         }"}, {"sha": "c8a41beecbc2248d78cf5178954eb0c1a4a1b41f", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -151,7 +151,7 @@ impl Write for Cursor<Vec<u8>> {\n         // there (left), and what will be appended on the end (right)\n         let space = self.inner.len() - pos as usize;\n         let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n-        slice::bytes::copy_memory(&mut self.inner[(pos as usize)..], left);\n+        slice::bytes::copy_memory(left, &mut self.inner[(pos as usize)..]);\n         self.inner.push_all(right);\n \n         // Bump us forward"}, {"sha": "52daba362131eda7392c0d0c71e49faa5350ff49", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -149,7 +149,7 @@ impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n         let (a, b) = self.split_at(amt);\n-        slice::bytes::copy_memory(buf, a);\n+        slice::bytes::copy_memory(a, buf);\n         *self = b;\n         Ok(amt)\n     }\n@@ -170,7 +170,7 @@ impl<'a> Write for &'a mut [u8] {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let amt = cmp::min(data.len(), self.len());\n         let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n-        slice::bytes::copy_memory(a, &data[..amt]);\n+        slice::bytes::copy_memory(&data[..amt], a);\n         *self = b;\n         Ok(amt)\n     }"}, {"sha": "645bc5db753d0a1067c5d3beb2c15301a0c3242d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -64,6 +64,10 @@ macro_rules! panic {\n ///\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n+///\n+/// Note that stdout is frequently line-buffered by default so it may be\n+/// necessary to use `io::stdout().flush()` to ensure the output is emitted\n+/// immediately.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]"}, {"sha": "ad6cac621733b815472affd508d80c5210ddf09f", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -118,7 +118,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, &available[..nread]);\n+            slice::bytes::copy_memory(&available[..nread], buf);\n             nread\n         };\n         self.pos += nread;\n@@ -225,7 +225,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n             self.inner.as_mut().unwrap().write_all(buf)\n         } else {\n             let dst = &mut self.buf[self.pos..];\n-            slice::bytes::copy_memory(dst, buf);\n+            slice::bytes::copy_memory(buf, dst);\n             self.pos += buf.len();\n             Ok(())\n         }"}, {"sha": "5ebf931e95c375f60f2358faae6b3112b756c3a8", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -91,7 +91,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = &mut buf[num_read..];\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, &src[..count]);\n+                    bytes::copy_memory(&src[..count], dst);\n                     count\n                 },\n                 None => 0,"}, {"sha": "0e5dd3aa4aac2862fca5478d305b3d7dc2304de1", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -171,7 +171,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n     unsafe {\n         let ptr = data.as_ptr().offset(start as isize);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(out.offset((8 - size) as isize), ptr, size);\n+        copy_nonoverlapping(ptr, out.offset((8 - size) as isize), size);\n         (*(out as *const u64)).to_be()\n     }\n }"}, {"sha": "64803191d4f14e7a51235d62c2de629665240385", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -168,7 +168,7 @@ impl Reader for MemReader {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n             let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n@@ -212,7 +212,7 @@ impl<'a> Reader for &'a [u8] {\n         {\n             let input = &self[..write_len];\n             let output = &mut buf[.. write_len];\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n \n         *self = &self[write_len..];\n@@ -287,13 +287,13 @@ impl<'a> Writer for BufWriter<'a> {\n         let src_len = src.len();\n \n         if dst_len >= src_len {\n-            slice::bytes::copy_memory(dst, src);\n+            slice::bytes::copy_memory(src, dst);\n \n             self.pos += src_len;\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, &src[..dst_len]);\n+            slice::bytes::copy_memory(&src[..dst_len], dst);\n \n             self.pos += dst_len;\n \n@@ -360,7 +360,7 @@ impl<'a> Reader for BufReader<'a> {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n             let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());"}, {"sha": "8f788988e557adfd7f8cfe481a397b9a4b03492a", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -344,8 +344,8 @@ impl Wtf8Buf {\n                 Some((surrogate_pos, _)) => {\n                     pos = surrogate_pos + 3;\n                     slice::bytes::copy_memory(\n+                        UTF8_REPLACEMENT_CHARACTER,\n                         &mut self.bytes[surrogate_pos .. pos],\n-                        UTF8_REPLACEMENT_CHARACTER\n                     );\n                 },\n                 None => return unsafe { String::from_utf8_unchecked(self.bytes) }"}, {"sha": "7c4cc0eaab7ce403267064511da85cb858aedba3", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -126,10 +126,9 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         let mut buf = repeat(0).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(&mut buf, alu);\n+        copy_memory(alu, &mut buf);\n         let buf_len = buf.len();\n-        copy_memory(&mut buf[alu_len..buf_len],\n-                    &alu[..LINE_LEN]);\n+        copy_memory(&alu[..LINE_LEN], &mut buf[alu_len..buf_len]);\n \n         let mut pos = 0;\n         let mut bytes;"}, {"sha": "cda90c08f23ad121df4e70b0565e7d83ebeae794", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -181,8 +181,8 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n     let mut i = LINE_LEN;\n     while i < len {\n         unsafe {\n-            copy(seq.as_mut_ptr().offset((i - off + 1) as isize),\n-                 seq.as_ptr().offset((i - off) as isize), off);\n+            copy(seq.as_ptr().offset((i - off) as isize),\n+                 seq.as_mut_ptr().offset((i - off + 1) as isize), off);\n             *seq.get_unchecked_mut(i - off) = b'\\n';\n         }\n         i += LINE_LEN + 1;"}, {"sha": "64033623fe2d13e86ca3349dd9d520de47346564", "filename": "src/test/compile-fail/borrowck-issue-14498.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -9,56 +9,116 @@\n // except according to those terms.\n \n // This tests that we can't modify Box<&mut T> contents while they\n-// are borrowed.\n+// are borrowed (#14498).\n+//\n+// Also includes tests of the errors reported when the Box in question\n+// is immutable (#14270).\n \n #![feature(box_syntax)]\n \n struct A { a: isize }\n struct B<'a> { a: Box<&'a mut isize> }\n \n+fn indirect_write_to_imm_box() {\n+    let mut x: isize = 1;\n+    let y: Box<_> = box &mut x;\n+    let p = &y;\n+    ***p = 2; //~ ERROR cannot assign to data in an immutable container\n+    drop(p);\n+}\n+\n fn borrow_in_var_from_var() {\n+    let mut x: isize = 1;\n+    let mut y: Box<_> = box &mut x;\n+    let p = &y;\n+    let q = &***p;\n+    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_var_from_var_via_imm_box() {\n     let mut x: isize = 1;\n     let y: Box<_> = box &mut x;\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_var_from_field() {\n+    let mut x = A { a: 1 };\n+    let mut y: Box<_> = box &mut x.a;\n+    let p = &y;\n+    let q = &***p;\n+    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_var_from_field_via_imm_box() {\n     let mut x = A { a: 1 };\n     let y: Box<_> = box &mut x.a;\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_field_from_var() {\n+    let mut x: isize = 1;\n+    let mut y = B { a: box &mut x };\n+    let p = &y.a;\n+    let q = &***p;\n+    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_field_from_var_via_imm_box() {\n     let mut x: isize = 1;\n     let y = B { a: box &mut x };\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_field_from_field() {\n+    let mut x = A { a: 1 };\n+    let mut y = B { a: box &mut x.a };\n+    let p = &y.a;\n+    let q = &***p;\n+    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_field_from_field_via_imm_box() {\n     let mut x = A { a: 1 };\n     let y = B { a: box &mut x.a };\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn main() {\n+    indirect_write_to_imm_box();\n     borrow_in_var_from_var();\n+    borrow_in_var_from_var_via_imm_box();\n     borrow_in_var_from_field();\n+    borrow_in_var_from_field_via_imm_box();\n     borrow_in_field_from_var();\n+    borrow_in_field_from_var_via_imm_box();\n     borrow_in_field_from_field();\n+    borrow_in_field_from_field_via_imm_box();\n }"}, {"sha": "432e7ff20254f6d68bedc5b45cb0700b7283de08", "filename": "src/test/run-pass/issue-11592.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Frun-pass%2Fissue-11592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Frun-pass%2Fissue-11592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11592.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Ensure the private trait Bar isn't complained about.\n+\n+#![deny(missing_docs)]\n+\n+mod foo {\n+    trait Bar { fn bar(&self) { } }\n+    impl Bar for i8 { fn bar(&self) { } }\n+}\n+\n+fn main() { }"}, {"sha": "7cc762c93482665fac08891ed2119e393f2f98b5", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3317d68910900f135f9f38e43a7a699bc736b4a/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=b3317d68910900f135f9f38e43a7a699bc736b4a", "patch": "@@ -26,7 +26,7 @@ trait MyWriter {\n \n impl<'a> MyWriter for &'a mut [u8] {\n     fn my_write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        slice::bytes::copy_memory(*self, buf);\n+        slice::bytes::copy_memory(buf, *self);\n \n         let write_len = buf.len();\n         unsafe {"}]}