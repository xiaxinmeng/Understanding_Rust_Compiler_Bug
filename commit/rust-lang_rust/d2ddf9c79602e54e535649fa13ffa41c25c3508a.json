{"sha": "d2ddf9c79602e54e535649fa13ffa41c25c3508a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZGRmOWM3OTYwMmU1NGU1MzU2NDlmYTEzZmZhNDFjMjVjMzUwOGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-21T15:22:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-21T15:22:35Z"}, "message": "Auto merge of #6754 - camsteffen:spanlesseq-res, r=flip1995\n\nTeach SpanlessEq binding IDs\n\nchangelog: Fix collapsible_match false positive\n\nFixes #6740\n\nThis PR changes the way `SpanlessEq` determines whether two local variables are the same. Instead of checking that the names match, it checks that the `HirId`s match. If local bindings are declared within the expressions that are being compared, `SpanlessEq` will remember bindings that correspond to each other in a `FxHashMap<HirId, HirId>`. This makes `SpanlessEq` more flexible while also fixing false positives.\n\nExample: `{ let x = 1; x + 2 }` is equal to `{ let y = 1; y + 2 }`.\n\nCC `@xFrednet` I think this will resolve some concerns in #6463", "tree": {"sha": "9d83c68627613ddf846055a612651c0fda394d06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d83c68627613ddf846055a612651c0fda394d06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ddf9c79602e54e535649fa13ffa41c25c3508a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ddf9c79602e54e535649fa13ffa41c25c3508a", "html_url": "https://github.com/rust-lang/rust/commit/d2ddf9c79602e54e535649fa13ffa41c25c3508a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ddf9c79602e54e535649fa13ffa41c25c3508a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67087a1b4ee06ce42fd8abe5825f9af96a41e83d", "url": "https://api.github.com/repos/rust-lang/rust/commits/67087a1b4ee06ce42fd8abe5825f9af96a41e83d", "html_url": "https://github.com/rust-lang/rust/commit/67087a1b4ee06ce42fd8abe5825f9af96a41e83d"}, {"sha": "9ad6e263c9eec118a37cdbd5e182afaaad42840a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad6e263c9eec118a37cdbd5e182afaaad42840a", "html_url": "https://github.com/rust-lang/rust/commit/9ad6e263c9eec118a37cdbd5e182afaaad42840a"}], "stats": {"total": 269, "additions": 154, "deletions": 115}, "files": [{"sha": "efc8b13942507dc408df040a4d281aae391d7268", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d2ddf9c79602e54e535649fa13ffa41c25c3508a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ddf9c79602e54e535649fa13ffa41c25c3508a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d2ddf9c79602e54e535649fa13ffa41c25c3508a", "patch": "@@ -3,19 +3,19 @@ use crate::utils::sugg::Sugg;\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     expr_block, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local_id,\n-    peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-    strip_pat_refs,\n+    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local,\n+    path_to_local_id, peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block,\n+    snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, strip_pat_refs,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource, Mutability, Node, Pat,\n     PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, Symbol};\n+use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -1873,13 +1873,6 @@ fn test_overlapping() {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n-        lhs.len() == rhs.len()\n-            && lhs\n-                .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n-    }\n-\n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx);\n@@ -1891,12 +1884,38 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n             let min_index = usize::min(lindex, rindex);\n             let max_index = usize::max(lindex, rindex);\n \n+            let mut local_map: FxHashMap<HirId, HirId> = FxHashMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n             // Arms with a guard are ignored, those can\u2019t always be merged together\n             // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n-                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n-                // all patterns should have the same bindings\n-                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(&lhs.body, &rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n         };\n \n         let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n@@ -1939,50 +1958,18 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n     }\n }\n \n-/// Returns the list of bindings in a pattern.\n-fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.kind {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Binding(.., ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.typeck_results().pat_ty(pat));\n-                }\n-                if let Some(ref as_pat) = *as_pat {\n-                    bindings_impl(cx, as_pat, map);\n-                }\n-            },\n-            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Struct(_, fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.pat, map);\n-                }\n-            },\n-            PatKind::Slice(lhs, ref mid, rhs) => {\n-                for pat in lhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-                if let Some(ref mid) = *mid {\n-                    bindings_impl(cx, mid, map);\n-                }\n-                for pat in rhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n-        }\n-    }\n-\n-    let mut result = FxHashMap::default();\n-    bindings_impl(cx, pat, &mut result);\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n     result\n }\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: FxHashSet<HirId>) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "c042990b759eaec0d73bf0d39c39d2d03aa5a6f2", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 91, "deletions": 47, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d2ddf9c79602e54e535649fa13ffa41c25c3508a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ddf9c79602e54e535649fa13ffa41c25c3508a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=d2ddf9c79602e54e535649fa13ffa41c25c3508a", "patch": "@@ -1,10 +1,12 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def::Res;\n use rustc_hir::{\n     BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat, FnRetTy,\n-    GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n+    GenericArg, GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n     PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n@@ -24,7 +26,7 @@ pub struct SpanlessEq<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     allow_side_effects: bool,\n-    expr_fallback: Option<Box<dyn Fn(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n+    expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n@@ -45,15 +47,54 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_fallback(self, expr_fallback: impl Fn(&Expr<'_>, &Expr<'_>) -> bool + 'a) -> Self {\n+    pub fn expr_fallback(self, expr_fallback: impl FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a) -> Self {\n         Self {\n             expr_fallback: Some(Box::new(expr_fallback)),\n             ..self\n         }\n     }\n \n-    /// Checks whether two statements are the same.\n-    pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n+    /// Use this method to wrap comparisons that may involve inter-expression context.\n+    /// See `self.locals`.\n+    fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n+        HirEqInterExpr {\n+            inner: self,\n+            locals: FxHashMap::default(),\n+        }\n+    }\n+\n+    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+        self.inter_expr().eq_block(left, right)\n+    }\n+\n+    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        self.inter_expr().eq_expr(left, right)\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n+        self.inter_expr().eq_path_segment(left, right)\n+    }\n+\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment<'_>], right: &[PathSegment<'_>]) -> bool {\n+        self.inter_expr().eq_path_segments(left, right)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+        self.inter_expr().eq_ty_kind(left, right)\n+    }\n+}\n+\n+struct HirEqInterExpr<'a, 'b, 'tcx> {\n+    inner: &'a mut SpanlessEq<'b, 'tcx>,\n+\n+    // When binding are declared, the binding ID in the left expression is mapped to the one on the\n+    // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n+    // these blocks are considered equal since `x` is mapped to `y`.\n+    locals: FxHashMap<HirId, HirId>,\n+}\n+\n+impl HirEqInterExpr<'_, '_, '_> {\n+    fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n                 self.eq_pat(&l.pat, &r.pat)\n@@ -68,21 +109,21 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two blocks are the same.\n-    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+    fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n+    fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n-        if let Some(typeck_results) = self.maybe_typeck_results {\n+        if let Some(typeck_results) = self.inner.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.cx, typeck_results, left),\n-                constant_simple(self.cx, typeck_results, right),\n+                constant_simple(self.inner.cx, typeck_results, left),\n+                constant_simple(self.inner.cx, typeck_results, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -98,10 +139,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -116,7 +157,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -139,19 +180,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 ls == rs\n                     && self.eq_expr(le, re)\n                     && over(la, ra, |l, r| {\n-                        self.eq_expr(&l.body, &r.body)\n+                        self.eq_pat(&l.pat, &r.pat)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && self.eq_pat(&l.pat, &r.pat)\n+                            && self.eq_expr(&l.body, &r.body)\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n+                let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n+                let rl = celcx.expr(&self.inner.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n@@ -168,7 +209,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n             _ => false,\n         };\n-        is_eq || self.expr_fallback.as_ref().map_or(false, |f| f(left, right))\n+        is_eq || self.inner.expr_fallback.as_mut().map_or(false, |f| f(left, right))\n     }\n \n     fn eq_exprs(&mut self, left: &[Expr<'_>], right: &[Expr<'_>]) -> bool {\n@@ -199,13 +240,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n-    pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n+    fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n         let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n         li.name == ri.name && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n-    pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n@@ -214,8 +255,12 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n-            (&PatKind::Binding(ref lb, .., ref li, ref lp), &PatKind::Binding(ref rb, .., ref ri, ref rp)) => {\n-                lb == rb && li.name == ri.name && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(lb, li, _, ref lp), &PatKind::Binding(rb, ri, _, ref rp)) => {\n+                let eq = lb == rb && both(lp, rp, |l, r| self.eq_pat(l, r));\n+                if eq {\n+                    self.locals.insert(li, ri);\n+                }\n+                eq\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -251,8 +296,11 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n-        left.is_global() == right.is_global()\n-            && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        match (left.res, right.res) {\n+            (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n+            (Res::Local(_), _) | (_, Res::Local(_)) => false,\n+            _ => over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r)),\n+        }\n     }\n \n     fn eq_path_parameters(&mut self, left: &GenericArgs<'_>, right: &GenericArgs<'_>) -> bool {\n@@ -279,28 +327,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.ident.name == right.ident.name && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n-    pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n+    fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         self.eq_ty_kind(&left.kind, &right.kind)\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+    fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let old_maybe_typeck_results = self.maybe_typeck_results;\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n-\n-                let eq_ty = self.eq_ty(lt, rt);\n-                self.maybe_typeck_results = old_maybe_typeck_results;\n-                eq_ty && ll == rl\n+                let cx = self.inner.cx;\n+                let eval_const =\n+                    |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n+                self.eq_ty(lt, rt) && eval_const(ll_id.body) == eval_const(rl_id.body)\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n@@ -667,10 +706,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n-    pub fn hash_path(&mut self, p: &Path<'_>) {\n-        p.is_global().hash(&mut self.s);\n-        for p in p.segments {\n-            self.hash_name(p.ident.name);\n+    pub fn hash_path(&mut self, path: &Path<'_>) {\n+        match path.res {\n+            // constant hash since equality is dependant on inter-expression context\n+            Res::Local(_) => 1_usize.hash(&mut self.s),\n+            _ => {\n+                for seg in path.segments {\n+                    self.hash_name(seg.ident.name);\n+                }\n+            },\n         }\n     }\n "}, {"sha": "55467cf4229de4b9e5607d003a93f010bfd9eefd", "filename": "tests/ui/collapsible_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=d2ddf9c79602e54e535649fa13ffa41c25c3508a", "patch": "@@ -232,6 +232,14 @@ fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u\n             };\n         }\n     }\n+    let _: &dyn std::any::Any = match &Some(Some(1)) {\n+        Some(e) => match e {\n+            Some(e) => e,\n+            e => e,\n+        },\n+        // else branch looks the same but the binding is different\n+        e => e,\n+    };\n }\n \n fn make<T>() -> T {"}, {"sha": "a2ff1b741ca25e5699ff8d9f2453325ed7e4b9f0", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=d2ddf9c79602e54e535649fa13ffa41c25c3508a", "patch": "@@ -12,7 +12,7 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     if true {\n         for _ in &[42] {\n             let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            if foo.is_some() {\n                 break;\n             } else {\n                 continue;\n@@ -21,8 +21,8 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     } else {\n         //~ ERROR same body as `if` block\n         for _ in &[42] {\n-            let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            let bar: &Option<_> = &Some::<u8>(42);\n+            if bar.is_some() {\n                 break;\n             } else {\n                 continue;"}, {"sha": "454322d8aacda727b2a8efead93c70cc554ed772", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2ddf9c79602e54e535649fa13ffa41c25c3508a/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=d2ddf9c79602e54e535649fa13ffa41c25c3508a", "patch": "@@ -5,7 +5,7 @@ LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n LL | |         for _ in &[42] {\n-LL | |             let foo: &Option<_> = &Some::<u8>(42);\n+LL | |             let bar: &Option<_> = &Some::<u8>(42);\n ...  |\n LL | |         }\n LL | |     }\n@@ -19,7 +19,7 @@ LL |       if true {\n    |  _____________^\n LL | |         for _ in &[42] {\n LL | |             let foo: &Option<_> = &Some::<u8>(42);\n-LL | |             if true {\n+LL | |             if foo.is_some() {\n ...  |\n LL | |         }\n LL | |     } else {"}]}