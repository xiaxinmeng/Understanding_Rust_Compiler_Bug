{"sha": "25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Y2NmM2MwZGFhYjNjYmQyZTQ5ZjEzYzg5ZjM1ZWQ5ZjM4MmRjNWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-17T23:14:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T01:26:43Z"}, "message": "rollup merge of #22331: steveklabnik/guidelines\n\nFixes #19315\n\nr? @aturon", "tree": {"sha": "04b04eaa4485a222884832ae35af9878c779ad94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04b04eaa4485a222884832ae35af9878c779ad94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "html_url": "https://github.com/rust-lang/rust/commit/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca2453a02548042fcb7082063149367a3343dd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca2453a02548042fcb7082063149367a3343dd7", "html_url": "https://github.com/rust-lang/rust/commit/eca2453a02548042fcb7082063149367a3343dd7"}, {"sha": "01c520818cef59f14d9bc7766eaec42a1f3bf105", "url": "https://api.github.com/repos/rust-lang/rust/commits/01c520818cef59f14d9bc7766eaec42a1f3bf105", "html_url": "https://github.com/rust-lang/rust/commit/01c520818cef59f14d9bc7766eaec42a1f3bf105"}], "stats": {"total": 2555, "additions": 2554, "deletions": 1}, "files": [{"sha": "743032f676d217d4201246b9cf8d5984ff8608d0", "filename": "mk/docs.mk", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -73,7 +73,7 @@ RUSTBOOK = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTBOOK_EXE)\n \n D := $(S)src/doc\n \n-DOC_TARGETS := trpl\n+DOC_TARGETS := trpl style\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -275,3 +275,9 @@ trpl: doc/book/index.html\n doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md) | doc/\n \t$(Q)rm -rf doc/book\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book\n+\n+style: doc/style/index.html\n+\n+doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n+\t$(Q)rm -rf doc/style\n+\t$(Q)$(RUSTBOOK) build $(S)src/doc/style doc/style"}, {"sha": "9b328b5d393c59f0183bd36cc4587f0e28907cf5", "filename": "src/doc/style/README.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,64 @@\n+% Style Guidelines\n+\n+This document collects the emerging principles, conventions, abstractions, and\n+best practices for writing Rust code.\n+\n+Since Rust is evolving at a rapid pace, these guidelines are\n+preliminary. The hope is that writing them down explicitly will help\n+drive discussion, consensus and adoption.\n+\n+Whenever feasible, guidelines provide specific examples from Rust's standard\n+libraries.\n+\n+### Guideline statuses\n+\n+Every guideline has a status:\n+\n+* **[FIXME]**: Marks places where there is more work to be done. In\n+  some cases, that just means going through the RFC process.\n+\n+* **[FIXME #NNNNN]**: Like **[FIXME]**, but links to the issue tracker.\n+\n+* **[RFC #NNNN]**: Marks accepted guidelines, linking to the rust-lang\n+  RFC establishing them.\n+\n+### Guideline stabilization\n+\n+One purpose of these guidelines is to reach decisions on a number of\n+cross-cutting API and stylistic choices. Discussion and development of\n+the guidelines will happen primarily on http://discuss.rust-lang.org/,\n+using the Guidelines category. Discussion can also occur on the\n+[guidelines issue tracker](https://github.com/rust-lang/rust-guidelines).\n+\n+Guidelines that are under development or discussion will be marked with the\n+status **[FIXME]**, with a link to the issue tracker when appropriate.\n+\n+Once a concrete guideline is ready to be proposed, it should be filed\n+as an [FIXME: needs RFC](https://github.com/rust-lang/rfcs). If the RFC is\n+accepted, the official guidelines will be updated to match, and will\n+include the tag **[RFC #NNNN]** linking to the RFC document.\n+\n+### What's in this document\n+\n+This document is broken into four parts:\n+\n+* **[Style](style/README.md)** provides a set of rules governing naming conventions,\n+  whitespace, and other stylistic issues.\n+\n+* **[Guidelines by Rust feature](features/README.md)** places the focus on each of\n+  Rust's features, starting from expressions and working the way out toward\n+  crates, dispensing guidelines relevant to each.\n+\n+* **Topical guidelines and patterns**. The rest of the document proceeds by\n+  cross-cutting topic, starting with\n+  [Ownership and resources](ownership/README.md).\n+\n+* **[APIs for a changing Rust](changing/README.md)**\n+  discusses the forward-compatibility hazards, especially those that interact\n+  with the pre-1.0 library stabilization process.\n+\n+> **[FIXME]** Add cross-references throughout this document to the tutorial,\n+> reference manual, and other guides.\n+\n+> **[FIXME]** What are some _non_-goals, _non_-principles, or _anti_-patterns that\n+> we should document?"}, {"sha": "41bc08f229e7c9f65f5120d82507ca216da21c8e", "filename": "src/doc/style/SUMMARY.md", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FSUMMARY.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,54 @@\n+# Summary\n+\n+* [Style](style/README.md)\n+    * [Whitespace](style/whitespace.md)\n+    * [Comments](style/comments.md)\n+    * [Braces, semicolons, commas](style/braces.md)\n+    * [Naming](style/naming/README.md)\n+        * [Ownership variants](style/naming/ownership.md)\n+        * [Containers/wrappers](style/naming/containers.md)\n+        * [Conversions](style/naming/conversions.md)\n+        * [Iterators](style/naming/iterators.md)\n+    * [Imports](style/imports.md)\n+    * [Organization](style/organization.md)\n+* [Guidelines by Rust feature](features/README.md)\n+    * [Let binding](features/let.md)\n+    * [Pattern matching](features/match.md)\n+    * [Loops](features/loops.md)\n+    * [Functions and methods](features/functions-and-methods/README.md)\n+        * [Input](features/functions-and-methods/input.md)\n+        * [Output](features/functions-and-methods/output.md)\n+        * [For convenience](features/functions-and-methods/convenience.md)\n+    * [Types](features/types/README.md)\n+        * [Conversions](features/types/conversions.md)\n+        * [The newtype pattern](features/types/newtype.md)\n+    * [Traits](features/traits/README.md)\n+        * [For generics](features/traits/generics.md)\n+        * [For objects](features/traits/objects.md)\n+        * [For overloading](features/traits/overloading.md)\n+        * [For extensions](features/traits/extensions.md)\n+        * [For reuse](features/traits/reuse.md)\n+        * [Common traits](features/traits/common.md)\n+    * [Modules](features/modules.md)\n+    * [Crates](features/crates.md)\n+* [Ownership and resources](ownership/README.md)\n+    * [Constructors](ownership/constructors.md)\n+    * [Builders](ownership/builders.md)\n+    * [Destructors](ownership/destructors.md)\n+    * [RAII](ownership/raii.md)\n+    * [Cells and smart pointers](ownership/cell-smart.md)\n+* [Errors](errors/README.md)\n+    * [Signaling](errors/signaling.md)\n+    * [Handling](errors/handling.md)\n+    * [Propagation](errors/propagation.md)\n+    * [Ergonomics](errors/ergonomics.md)\n+* [Safety and guarantees](safety/README.md)\n+    * [Using unsafe](safety/unsafe.md)\n+    * [Library guarantees](safety/lib-guarantees.md)\n+* [Testing](testing/README.md)\n+    * [Unit testing](testing/unit.md)\n+* [FFI, platform-specific code](platform.md)\n+* [APIs for a changing Rust](changing/README.md)\n+    * [Pre-1.0 changes](changing/pre-1-0.md)\n+    * [Post-1.0 changes](changing/post-1-0.md)\n+    * [Timing unclear](changing/unclear.md)"}, {"sha": "38e76f6970c810feee03999cac78a6d334e9afde", "filename": "src/doc/style/changing/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,5 @@\n+% API design for a changing Rust\n+\n+A number of planned Rust features will drastically affect the API design\n+story. This section collects some of the biggest features with concrete examples\n+of how the API will change."}, {"sha": "7ac1c837c071fda7eeae7e1194c978e76d0b93c0", "filename": "src/doc/style/changing/post-1-0.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,12 @@\n+% Post-1.0 changes\n+\n+### Higher-kinded types\n+\n+* A trait encompassing both `Iterable<T>` for some fixed `T` and\n+  `FromIterator<U>` for _all_ `U` (where HKT comes in).  The train\n+  could provide e.g. a default `map` method producing the same kind of\n+  the container, but with a new type parameter.\n+\n+* **Monadic-generic programming**? Can we add this without deprecating\n+  huge swaths of the API (including `Option::map`, `option::collect`,\n+  `result::collect`, `try!` etc."}, {"sha": "adadfe31a59d138b1c7dc0fd4b5f328826860d7b", "filename": "src/doc/style/changing/pre-1-0.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,17 @@\n+% Pre-1.0 changes\n+\n+### `std` facade\n+\n+We should revisit some APIs in `libstd` now that the facade effort is complete.\n+\n+For example, the treatment of environment variables in the new\n+`Command` API is waiting on access to hashtables before being\n+approved.\n+\n+### Trait reform\n+\n+Potential for standard conversion traits (`to`, `into`, `as`).\n+\n+Probably many other opportunities here.\n+\n+### Unboxed closures"}, {"sha": "e4b8a98e1a1622f1ac4e051facc9a3c649998050", "filename": "src/doc/style/changing/unclear.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,28 @@\n+% Changes with unclear timing\n+\n+### Associated items\n+\n+* Many traits that currently take type parameters should instead use associated\n+  types; this will _drastically_ simplify signatures in some cases.\n+\n+* Associated constants would be useful in a few places, e.g. traits for\n+  numerics, traits for paths.\n+\n+### Anonymous, unboxed return types (aka `impl Trait` types)\n+\n+* See https://github.com/rust-lang/rfcs/pull/105\n+\n+* Could affect API design in several places, e.g. the `Iterator` trait.\n+\n+### Default type parameters\n+\n+We are already using this in a few places (e.g. `HashMap`), but it's\n+feature-gated.\n+\n+### Compile-time function evaluation (CTFE)\n+\n+https://github.com/mozilla/rust/issues/11621\n+\n+### Improved constant folding\n+\n+https://github.com/rust-lang/rust/issues/7834"}, {"sha": "444da26ff8fed7191bc82d15eb88d5ed11156174", "filename": "src/doc/style/errors/README.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,3 @@\n+% Errors\n+\n+> **[FIXME]** Add some general text here."}, {"sha": "33f1e82b187e7ddb6ee68fa2465e131e16a0435e", "filename": "src/doc/style/errors/ergonomics.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,66 @@\n+% Ergonomic error handling\n+\n+Error propagation with raw `Result`s can require tedious matching and\n+repackaging. This tedium is largely alleviated by the `try!` macro,\n+and can be completely removed (in some cases) by the \"`Result`-`impl`\"\n+pattern.\n+\n+### The `try!` macro\n+\n+Prefer\n+\n+```rust\n+use std::io::{File, Open, Write, IoError};\n+\n+struct Info {\n+    name: String,\n+    age: int,\n+    rating: int\n+}\n+\n+fn write_info(info: &Info) -> Result<(), IoError> {\n+    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n+                                   Open, Write);\n+    // Early return on error\n+    try!(file.write_line(format!(\"name: {}\", info.name).as_slice()));\n+    try!(file.write_line(format!(\"age: {}\", info.age).as_slice()));\n+    try!(file.write_line(format!(\"rating: {}\", info.rating).as_slice()));\n+    return Ok(());\n+}\n+```\n+\n+over\n+\n+```rust\n+use std::io::{File, Open, Write, IoError};\n+\n+struct Info {\n+    name: String,\n+    age: int,\n+    rating: int\n+}\n+\n+fn write_info(info: &Info) -> Result<(), IoError> {\n+    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n+                                   Open, Write);\n+    // Early return on error\n+    match file.write_line(format!(\"name: {}\", info.name).as_slice()) {\n+        Ok(_) => (),\n+        Err(e) => return Err(e)\n+    }\n+    match file.write_line(format!(\"age: {}\", info.age).as_slice()) {\n+        Ok(_) => (),\n+        Err(e) => return Err(e)\n+    }\n+    return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n+}\n+```\n+\n+See\n+[the `result` module documentation](http://static.rust-lang.org/doc/master/std/result/index.html#the-try!-macro)\n+for more details.\n+\n+### The `Result`-`impl` pattern [FIXME]\n+\n+> **[FIXME]** Document the way that the `io` module uses trait impls\n+> on `IoResult` to painlessly propagate errors."}, {"sha": "cc5b5b475769c55cfcd4bd5044c5c18514c9b18a", "filename": "src/doc/style/errors/handling.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,7 @@\n+% Handling errors\n+\n+### Use task isolation to cope with failure. [FIXME]\n+\n+> **[FIXME]** Explain how to isolate tasks and detect task failure for recovery.\n+\n+### Consuming `Result` [FIXME]"}, {"sha": "0a347cd577b906136b2129909a7cde31e25f701e", "filename": "src/doc/style/errors/propagation.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,8 @@\n+% Propagation\n+\n+> **[FIXME]** We need guidelines on how to layer error information up a stack of\n+> abstractions.\n+\n+### Error interoperation [FIXME]\n+\n+> **[FIXME]** Document the `FromError` infrastructure."}, {"sha": "95db4f8afa03c515b7c3300956a8776849ec4892", "filename": "src/doc/style/errors/signaling.md", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,125 @@\n+% Signaling errors [RFC #236]\n+\n+> The guidelines below were approved by [RFC #236](https://github.com/rust-lang/rfcs/pull/236).\n+\n+Errors fall into one of three categories:\n+\n+* Catastrophic errors, e.g. out-of-memory.\n+* Contract violations, e.g. wrong input encoding, index out of bounds.\n+* Obstructions, e.g. file not found, parse error.\n+\n+The basic principle of the convention is that:\n+\n+* Catastrophic errors and programming errors (bugs) can and should only be\n+recovered at a *coarse grain*, i.e. a task boundary.\n+* Obstructions preventing an operation should be reported at a maximally *fine\n+grain* -- to the immediate invoker of the operation.\n+\n+## Catastrophic errors\n+\n+An error is _catastrophic_ if there is no meaningful way for the current task to\n+continue after the error occurs.\n+\n+Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n+\n+**Canonical examples**: out of memory, stack overflow.\n+\n+### For catastrophic errors, panic\n+\n+For errors like stack overflow, Rust currently aborts the process, but\n+could in principle panic, which (in the best case) would allow\n+reporting and recovery from a supervisory task.\n+\n+## Contract violations\n+\n+An API may define a contract that goes beyond the type checking enforced by the\n+compiler. For example, slices support an indexing operation, with the contract\n+that the supplied index must be in bounds.\n+\n+Contracts can be complex and involve more than a single function invocation. For\n+example, the `RefCell` type requires that `borrow_mut` not be called until all\n+existing borrows have been relinquished.\n+\n+### For contract violations, panic\n+\n+A contract violation is always a bug, and for bugs we follow the Erlang\n+philosophy of \"let it crash\": we assume that software *will* have bugs, and we\n+design coarse-grained task boundaries to report, and perhaps recover, from these\n+bugs.\n+\n+### Contract design\n+\n+One subtle aspect of these guidelines is that the contract for a function is\n+chosen by an API designer -- and so the designer also determines what counts as\n+a violation.\n+\n+This RFC does not attempt to give hard-and-fast rules for designing\n+contracts. However, here are some rough guidelines:\n+\n+* Prefer expressing contracts through static types whenever possible.\n+\n+* It *must* be possible to write code that uses the API without violating the\n+  contract.\n+\n+* Contracts are most justified when violations are *inarguably* bugs -- but this\n+  is surprisingly rare.\n+\n+* Consider whether the API client could benefit from the contract-checking\n+  logic.  The checks may be expensive. Or there may be useful programming\n+  patterns where the client does not want to check inputs before hand, but would\n+  rather attempt the operation and then find out whether the inputs were invalid.\n+\n+* When a contract violation is the *only* kind of error a function may encounter\n+  -- i.e., there are no obstructions to its success other than \"bad\" inputs --\n+  using `Result` or `Option` instead is especially warranted. Clients can then use\n+  `unwrap` to assert that they have passed valid input, or re-use the error\n+  checking done by the API for their own purposes.\n+\n+* When in doubt, use loose contracts and instead return a `Result` or `Option`.\n+\n+## Obstructions\n+\n+An operation is *obstructed* if it cannot be completed for some reason, even\n+though the operation's contract has been satisfied. Obstructed operations may\n+have (documented!) side effects -- they are not required to roll back after\n+encountering an obstruction.  However, they should leave the data structures in\n+a \"coherent\" state (satisfying their invariants, continuing to guarantee safety,\n+etc.).\n+\n+Obstructions may involve external conditions (e.g., I/O), or they may involve\n+aspects of the input that are not covered by the contract.\n+\n+**Canonical examples**: file not found, parse error.\n+\n+### For obstructions, use `Result`\n+\n+The\n+[`Result<T,E>` type](http://static.rust-lang.org/doc/master/std/result/index.html)\n+represents either a success (yielding `T`) or failure (yielding `E`). By\n+returning a `Result`, a function allows its clients to discover and react to\n+obstructions in a fine-grained way.\n+\n+#### What about `Option`?\n+\n+The `Option` type should not be used for \"obstructed\" operations; it\n+should only be used when a `None` return value could be considered a\n+\"successful\" execution of the operation.\n+\n+This is of course a somewhat subjective question, but a good litmus\n+test is: would a reasonable client ever ignore the result? The\n+`Result` type provides a lint that ensures the result is actually\n+inspected, while `Option` does not, and this difference of behavior\n+can help when deciding between the two types.\n+\n+Another litmus test: can the operation be understood as asking a\n+question (possibly with sideeffects)? Operations like `pop` on a\n+vector can be viewed as asking for the contents of the first element,\n+with the side effect of removing it if it exists -- with an `Option`\n+return value.\n+\n+## Do not provide both `Result` and `panic!` variants.\n+\n+An API should not provide both `Result`-producing and `panic`king versions of an\n+operation. It should provide just the `Result` version, allowing clients to use\n+`try!` or `unwrap` instead as needed. This is part of the general pattern of\n+cutting down on redundant variants by instead using method chaining."}, {"sha": "09657503d20d1cebf0c84eb194d2d315809590a4", "filename": "src/doc/style/features/README.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,9 @@\n+% Guidelines by language feature\n+\n+Rust provides a unique combination of language features, some new and some\n+old. This section gives guidance on when and how to use Rust's features, and\n+brings attention to some of the tradeoffs between different features.\n+\n+Notably missing from this section is an in-depth discussion of Rust's pointer\n+types (both built-in and in the library). The topic of pointers is discussed at\n+length in a [separate section on ownership](../ownership/README.md)."}, {"sha": "4748b05f17f74a189f5681bcd584657ac1cf6c83", "filename": "src/doc/style/features/crates.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,6 @@\n+% Crates\n+\n+> **[FIXME]** What general guidelines should we provide for crate design?\n+\n+> Possible topics: facades; per-crate preludes (to be imported as globs);\n+> \"lib.rs\""}, {"sha": "2dcfc382d0baf43c7a3657a31719114436dfb7e4", "filename": "src/doc/style/features/functions-and-methods/README.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,43 @@\n+% Functions and methods\n+\n+### Prefer methods to functions if there is a clear receiver. **[FIXME: needs RFC]**\n+\n+Prefer\n+\n+```rust\n+impl Foo {\n+    pub fn frob(&self, w: widget) { ... }\n+}\n+```\n+\n+over\n+\n+```rust\n+pub fn frob(foo: &Foo, w: widget) { ... }\n+```\n+\n+for any operation that is clearly associated with a particular\n+type.\n+\n+Methods have numerous advantages over functions:\n+* They do not need to be imported or qualified to be used: all you\n+  need is a value of the appropriate type.\n+* Their invocation performs autoborrowing (including mutable borrows).\n+* They make it easy to answer the question \"what can I do with a value\n+  of type `T`\" (especially when using rustdoc).\n+* They provide `self` notation, which is more concise and often more\n+  clearly conveys ownership distinctions.\n+\n+> **[FIXME]** Revisit these guidelines with\n+> [UFCS](https://github.com/nick29581/rfcs/blob/ufcs/0000-ufcs.md) and\n+> conventions developing around it.\n+\n+\n+\n+### Guidelines for inherent methods. **[FIXME]**\n+\n+> **[FIXME]** We need guidelines for when to provide inherent methods on a type,\n+> versus methods through a trait or functions.\n+\n+> **NOTE**: Rules for method resolution around inherent methods are in flux,\n+> which may impact the guidelines."}, {"sha": "69fd3772a761f8521bcf5153d2ec2b9aae2c28f5", "filename": "src/doc/style/features/functions-and-methods/convenience.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,43 @@\n+% Convenience methods\n+\n+### Provide small, coherent sets of convenience methods. **[FIXME: needs RFC]**\n+\n+_Convenience methods_ wrap up existing functionality in a more convenient\n+way. The work done by a convenience method varies widely:\n+\n+* _Re-providing functions as methods_. For example, the `std::path::Path` type\n+  provides methods like `stat` on `Path`s that simply invoke the corresponding\n+  function in `std::io::fs`.\n+* _Skipping through conversions_. For example, the `str` type provides a\n+  `.len()` convenience method which is also expressible as `.as_bytes().len()`.\n+  Sometimes the conversion is more complex: the `str` module also provides\n+  `from_chars`, which encapsulates a simple use of iterators.\n+* _Encapsulating common arguments_. For example, vectors of `&str`s\n+  provide a `connect` as well as a special case, `concat`, that is expressible\n+  using `connect` with a fixed separator of `\"\"`.\n+* _Providing more efficient special cases_. The `connect` and `concat` example\n+  also applies here: singling out `concat` as a special case allows for a more\n+  efficient implementation.\n+\n+  Note, however, that the `connect` method actually detects the special case\n+  internally and invokes `concat`. Usually, it is not necessary to add a public\n+  convenience method just for efficiency gains; there should also be a\n+  _conceptual_ reason to add it, e.g. because it is such a common special case.\n+\n+It is tempting to add convenience methods in a one-off, haphazard way as\n+common use patterns emerge. Avoid this temptation, and instead _design_ small,\n+coherent sets of convenience methods that are easy to remember:\n+\n+* _Small_: Avoid combinatorial explosions of convenience methods. For example,\n+  instead of adding `_str` variants of methods that provide a `str` output,\n+  instead ensure that the normal output type of methods is easily convertible to\n+  `str`.\n+* _Coherent_: Look for small groups of convenience methods that make sense to\n+  include together. For example, the `Path` API mentioned above includes a small\n+  selection of the most common filesystem operations that take a `Path`\n+  argument.  If one convenience method strongly suggests the existence of others,\n+  consider adding the whole group.\n+* _Memorable_: It is not worth saving a few characters of typing if you have to\n+  look up the name of a convenience method every time you use it. Add\n+  convenience methods with names that are obvious and easy to remember, and add\n+  them for the most common or painful use cases."}, {"sha": "b0912ea0203dc0f50f802d15d2d75f16053f0f5b", "filename": "src/doc/style/features/functions-and-methods/input.md", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,201 @@\n+% Input to functions and methods\n+\n+### Let the client decide when to copy and where to place data. [FIXME: needs RFC]\n+\n+#### Copying:\n+\n+Prefer\n+\n+```rust\n+fn foo(b: Bar) {\n+   // use b as owned, directly\n+}\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: &Bar) {\n+    let b = b.clone();\n+    // use b as owned after cloning\n+}\n+```\n+\n+If a function requires ownership of a value of unknown type `T`, but does not\n+otherwise need to make copies, the function should take ownership of the\n+argument (pass by value `T`) rather than using `.clone()`. That way, the caller\n+can decide whether to relinquish ownership or to `clone`.\n+\n+Similarly, the `Copy` trait bound should only be demanded it when absolutely\n+needed, not as a way of signaling that copies should be cheap to make.\n+\n+#### Placement:\n+\n+Prefer\n+\n+```rust\n+fn foo(b: Bar) -> Bar { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: Box<Bar>) -> Box<Bar> { ... }\n+```\n+\n+for concrete types `Bar` (as opposed to trait objects). This way, the caller can\n+decide whether to place data on the stack or heap. No overhead is imposed by\n+letting the caller determine the placement.\n+\n+### Minimize assumptions about parameters. [FIXME: needs RFC]\n+\n+The fewer assumptions a function makes about its inputs, the more widely usable\n+it becomes.\n+\n+#### Minimizing assumptions through generics:\n+\n+Prefer\n+\n+```rust\n+fn foo<T: Iterator<int>>(c: T) { ... }\n+```\n+\n+over any of\n+\n+```rust\n+fn foo(c: &[int]) { ... }\n+fn foo(c: &Vec<int>) { ... }\n+fn foo(c: &SomeOtherCollection<int>) { ... }\n+```\n+\n+if the function only needs to iterate over the data.\n+\n+More generally, consider using generics to pinpoint the assumptions a function\n+needs to make about its arguments.\n+\n+On the other hand, generics can make it more difficult to read and understand a\n+function's signature. Aim for \"natural\" parameter types that a neither overly\n+concrete nor overly abstract. See the discussion on\n+[traits](../../traits/README.md) for more guidance.\n+\n+\n+#### Minimizing ownership assumptions:\n+\n+Prefer either of\n+\n+```rust\n+fn foo(b: &Bar) { ... }\n+fn foo(b: &mut Bar) { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: Bar) { ... }\n+```\n+\n+That is, prefer borrowing arguments rather than transferring ownership, unless\n+ownership is actually needed.\n+\n+### Prefer compound return types to out-parameters. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+fn foo() -> (Bar, Bar)\n+```\n+\n+over\n+\n+```rust\n+fn foo(output: &mut Bar) -> Bar\n+```\n+\n+for returning multiple `Bar` values.\n+\n+Compound return types like tuples and structs are efficiently compiled\n+and do not require heap allocation. If a function needs to return\n+multiple values, it should do so via one of these types.\n+\n+The primary exception: sometimes a function is meant to modify data\n+that the caller already owns, for example to re-use a buffer:\n+\n+```rust\n+fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>\n+```\n+\n+(From the [Reader trait](http://static.rust-lang.org/doc/master/std/io/trait.Reader.html#tymethod.read).)\n+\n+### Consider validating arguments, statically or dynamically. [FIXME: needs RFC]\n+\n+_Note: this material is closely related to\n+  [library-level guarantees](../../safety/lib-guarantees.md)._\n+\n+Rust APIs do _not_ generally follow the\n+[robustness principle](http://en.wikipedia.org/wiki/Robustness_principle): \"be\n+conservative in what you send; be liberal in what you accept\".\n+\n+Instead, Rust code should _enforce_ the validity of input whenever practical.\n+\n+Enforcement can be achieved through the following mechanisms (listed\n+in order of preference).\n+\n+#### Static enforcement:\n+\n+Choose an argument type that rules out bad inputs.\n+\n+For example, prefer\n+\n+```rust\n+fn foo(a: ascii::Ascii) { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(a: u8) { ... }\n+```\n+\n+Note that\n+[`ascii::Ascii`](http://static.rust-lang.org/doc/master/std/ascii/struct.Ascii.html)\n+is a _wrapper_ around `u8` that guarantees the highest bit is zero; see\n+[newtype patterns]() for more details on creating typesafe wrappers.\n+\n+Static enforcement usually comes at little run-time cost: it pushes the\n+costs to the boundaries (e.g. when a `u8` is first converted into an\n+`Ascii`). It also catches bugs early, during compilation, rather than through\n+run-time failures.\n+\n+On the other hand, some properties are difficult or impossible to\n+express using types.\n+\n+#### Dynamic enforcement:\n+\n+Validate the input as it is processed (or ahead of time, if necessary).  Dynamic\n+checking is often easier to implement than static checking, but has several\n+downsides:\n+\n+1. Runtime overhead (unless checking can be done as part of processing the input).\n+2. Delayed detection of bugs.\n+3. Introduces failure cases, either via `fail!` or `Result`/`Option` types (see\n+   the [error handling guidelines](../../errors/README.md)), which must then be\n+   dealt with by client code.\n+\n+#### Dynamic enforcement with `debug_assert!`:\n+\n+Same as dynamic enforcement, but with the possibility of easily turning off\n+expensive checks for production builds.\n+\n+#### Dynamic enforcement with opt-out:\n+\n+Same as dynamic enforcement, but adds sibling functions that opt out of the\n+checking.\n+\n+The convention is to mark these opt-out functions with a suffix like\n+`_unchecked` or by placing them in a `raw` submodule.\n+\n+The unchecked functions can be used judiciously in cases where (1) performance\n+dictates avoiding checks and (2) the client is otherwise confident that the\n+inputs are valid.\n+\n+> **[FIXME]** Should opt-out functions be marked `unsafe`?"}, {"sha": "a83e2b76bcb7f457c71c8ef2247ae0713675490a", "filename": "src/doc/style/features/functions-and-methods/output.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,56 @@\n+% Output from functions and methods\n+\n+### Don't overpromise. [FIXME]\n+\n+> **[FIXME]** Add discussion of overly-specific return types,\n+> e.g. returning a compound iterator type rather than hiding it behind\n+> a use of newtype.\n+\n+### Let clients choose what to throw away. [FIXME: needs RFC]\n+\n+#### Return useful intermediate results:\n+\n+Many functions that answer a question also compute interesting related data.  If\n+this data is potentially of interest to the client, consider exposing it in the\n+API.\n+\n+Prefer\n+\n+```rust\n+struct SearchResult {\n+    found: bool,          // item in container?\n+    expected_index: uint  // what would the item's index be?\n+}\n+\n+fn binary_search(&self, k: Key) -> SearchResult\n+```\n+or\n+\n+```rust\n+fn binary_search(&self, k: Key) -> (bool, uint)\n+```\n+\n+over\n+\n+```rust\n+fn binary_search(&self, k: Key) -> bool\n+```\n+\n+#### Yield back ownership:\n+\n+Prefer\n+\n+```rust\n+fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>>\n+```\n+\n+over\n+\n+```rust\n+fn from_utf8_owned(vv: Vec<u8>) -> Option<String>\n+```\n+\n+The `from_utf8_owned` function gains ownership of a vector.  In the successful\n+case, the function consumes its input, returning an owned string without\n+allocating or copying. In the unsuccessful case, however, the function returns\n+back ownership of the original slice."}, {"sha": "87117a20d7a4957392497b1dbec79978748a5e55", "filename": "src/doc/style/features/let.md", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,103 @@\n+% Let binding\n+\n+### Always separately bind RAII guards. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+fn use_mutex(m: sync::mutex::Mutex<int>) {\n+    let guard = m.lock();\n+    do_work(guard);\n+    drop(guard); // unlock the lock\n+    // do other work\n+}\n+```\n+\n+over\n+\n+```rust\n+fn use_mutex(m: sync::mutex::Mutex<int>) {\n+    do_work(m.lock());\n+    // do other work\n+}\n+```\n+\n+As explained in the [RAII guide](../ownership/raii.md), RAII guards are values\n+that represent ownership of some resource and whose destructor releases the\n+resource. Because the lifetime of guards are significant, they should always be\n+explicitly `let`-bound to make the lifetime clear. Consider using an explicit\n+`drop` to release the resource early.\n+\n+### Prefer conditional expressions to deferred initialization. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+let foo = match bar {\n+    Baz  => 0,\n+    Quux => 1\n+};\n+```\n+\n+over\n+\n+```rust\n+let foo;\n+match bar {\n+    Baz  => {\n+        foo = 0;\n+    }\n+    Quux => {\n+        foo = 1;\n+    }\n+}\n+```\n+\n+unless the conditions for initialization are too complex to fit into a simple\n+conditional expression.\n+\n+### Use type annotations for clarification; prefer explicit generics when inference fails. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+s.iter().map(|x| x * 2)\n+        .collect::<Vec<_>>()\n+```\n+\n+over\n+\n+```rust\n+let v: Vec<_> = s.iter().map(|x| x * 2)\n+                        .collect();\n+```\n+\n+When the type of a value might be unclear to the _reader_ of the code, consider\n+explicitly annotating it in a `let`.\n+\n+On the other hand, when the type is unclear to the _compiler_, prefer to specify\n+the type by explicit generics instantiation, which is usually more clear.\n+\n+### Shadowing [FIXME]\n+\n+> **[FIXME]** Repeatedly shadowing a binding is somewhat common in Rust code. We\n+> need to articulate a guideline on when it is appropriate/useful and when not.\n+\n+### Prefer immutable bindings. [FIXME: needs RFC]\n+\n+Use `mut` bindings to signal the span during which a value is mutated:\n+\n+```rust\n+let mut v = Vec::new();\n+// push things onto v\n+let v = v;\n+// use v immutably henceforth\n+```\n+\n+### Prefer to bind all `struct` or tuple fields. [FIXME: needs RFC]\n+\n+When consuming a `struct` or tuple via a `let`, bind all of the fields rather\n+than using `..` to elide the ones you don't need. The benefit is that when\n+fields are added, the compiler will pinpoint all of the places where that type\n+of value was consumed, which will often need to be adjusted to take the new\n+field properly into account."}, {"sha": "b144825f98183d8a44bd6143d2b72d5a8c9e188d", "filename": "src/doc/style/features/loops.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,13 @@\n+% Loops\n+\n+### Prefer `for` to `while`. [FIXME: needs RFC]\n+\n+A `for` loop is preferable to a `while` loop, unless the loop counts in a\n+non-uniform way (making it difficult to express using `for`).\n+\n+### Guidelines for `loop`. [FIXME]\n+\n+> **[FIXME]** When is `loop` recommended? Some possibilities:\n+> * For optimistic retry algorithms\n+> * For servers\n+> * To avoid mutating local variables sometimes needed to fit `while`"}, {"sha": "131e0fad79a92d33b460e5c7a8d6315b32b866d8", "filename": "src/doc/style/features/match.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,26 @@\n+% Pattern matching\n+\n+### Dereference `match` targets when possible. [FIXME: needs RFC]\n+\n+Prefer\n+\n+~~~~\n+match *foo {\n+    X(...) => ...\n+    Y(...) => ...\n+}\n+~~~~\n+\n+over\n+\n+~~~~\n+match foo {\n+    box X(...) => ...\n+    box Y(...) => ...\n+}\n+~~~~\n+\n+<!-- ### Clearly indicate important scopes. **[FIXME: needs RFC]** -->\n+\n+<!-- If it is important that the destructor for a value be executed at a specific -->\n+<!-- time, clearly bind that value using a standalone `let` -->"}, {"sha": "04aae226f72b59414c635ccd763f26ac0a245edb", "filename": "src/doc/style/features/modules.md", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,133 @@\n+% Modules\n+\n+> **[FIXME]** What general guidelines should we provide for module design?\n+\n+> We should discuss visibility, nesting, `mod.rs`, and any interesting patterns\n+> around modules.\n+\n+### Headers [FIXME: needs RFC]\n+\n+Organize module headers as follows:\n+  1. [Imports](../style/imports.md).\n+  1. `mod` declarations.\n+  1. `pub mod` declarations.\n+\n+### Avoid `path` directives. [FIXME: needs RFC]\n+\n+Avoid using `#[path=\"...\"]` directives; make the file system and\n+module hierarchy match, instead.\n+\n+### Use the module hirearchy to organize APIs into coherent sections. [FIXME]\n+\n+> **[FIXME]** Flesh this out with examples; explain what a \"coherent\n+> section\" is with examples.\n+>\n+> The module hirearchy defines both the public and internal API of your module.\n+> Breaking related functionality into submodules makes it understandable to both\n+> users and contributors to the module.\n+\n+### Place modules in their own file. [FIXME: needs RFC]\n+\n+> **[FIXME]**\n+> - \"<100 lines\" is arbitrary, but it's a clearer recommendation\n+>   than \"~1 page\" or similar suggestions that vary by screen size, etc.\n+\n+For all except very short modules (<100 lines) and [tests](../testing/README.md),\n+place the module `foo` in a separate file, as in:\n+\n+```rust\n+pub mod foo;\n+\n+// in foo.rs or foo/mod.rs\n+pub fn bar() { println!(\"...\"); }\n+/* ... */\n+```\n+\n+rather than declaring it inline:\n+\n+```rust\n+pub mod foo {\n+    pub fn bar() { println!(\"...\"); }\n+    /* ... */\n+}\n+```\n+\n+#### Use subdirectories for modules with children. [FIXME: needs RFC]\n+\n+For modules that themselves have submodules, place the module in a separate\n+directory (e.g., `bar/mod.rs` for a module `bar`) rather than the same directory.\n+\n+Note the structure of\n+[`std::io`](http://doc.rust-lang.org/std/io/). Many of the submodules lack\n+children, like\n+[`io::fs`](http://doc.rust-lang.org/std/io/fs/)\n+and\n+[`io::stdio`](http://doc.rust-lang.org/std/io/stdio/).\n+On the other hand,\n+[`io::net`](http://doc.rust-lang.org/std/io/net/)\n+contains submodules, so it lives in a separate directory:\n+\n+```\n+io/mod.rs\n+   io/extensions.rs\n+   io/fs.rs\n+   io/net/mod.rs\n+          io/net/addrinfo.rs\n+          io/net/ip.rs\n+          io/net/tcp.rs\n+          io/net/udp.rs\n+          io/net/unix.rs\n+   io/pipe.rs\n+   ...\n+```\n+\n+While it is possible to define all of `io` within a single directory,\n+mirroring the module hirearchy in the directory structure makes\n+submodules of `io::net` easier to find.\n+\n+### Consider top-level definitions or reexports. [FIXME: needs RFC]\n+\n+For modules with submodules,\n+define or [reexport](http://doc.rust-lang.org/std/io/#reexports) commonly used\n+definitions at the top level:\n+\n+* Functionality relevant to the module itself or to many of its\n+  children should be defined in `mod.rs`.\n+* Functionality specific to a submodule should live in that\n+  submodule. Reexport at the top level for the most important or\n+  common definitions.\n+\n+For example,\n+[`IoError`](http://doc.rust-lang.org/std/io/struct.IoError.html)\n+is defined in `io/mod.rs`, since it pertains to the entirety of `io`,\n+while\n+[`TcpStream`](http://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html)\n+is defined in `io/net/tcp.rs` and reexported in the `io` module.\n+\n+### Use internal module hirearchies for organization. [FIXME: needs RFC]\n+\n+> **[FIXME]**\n+> - Referencing internal modules from the standard library is subject to\n+>   becoming outdated.\n+\n+Internal module hirearchies (i.e., private submodules) may be used to\n+hide implementation details that are not part of the module's API.\n+\n+For example, in [`std::io`](http://doc.rust-lang.org/std/io/), `mod mem`\n+provides implementations for\n+[`BufReader`](http://doc.rust-lang.org/std/io/struct.BufReader.html)\n+and\n+[`BufWriter`](http://doc.rust-lang.org/std/io/struct.BufWriter.html),\n+but these are re-exported in `io/mod.rs` at the top level of the module:\n+\n+```rust\n+// libstd/io/mod.rs\n+\n+pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n+/* ... */\n+mod mem;\n+```\n+\n+This hides the detail that there even exists a `mod mem` in `io`, and\n+helps keep code organized while offering freedom to change the\n+implementation."}, {"sha": "1893db24466fa861a075035a917092a81b021094", "filename": "src/doc/style/features/traits/README.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,22 @@\n+% Traits\n+\n+Traits are probably Rust's most complex feature, supporting a wide range of use\n+cases and design tradeoffs. Patterns of trait usage are still emerging.\n+\n+### Know whether a trait will be used as an object. [FIXME: needs RFC]\n+\n+Trait objects have some [significant limitations](objects.md): methods\n+invoked through a trait object cannot use generics, and cannot use\n+`Self` except in receiver position.\n+\n+When designing a trait, decide early on whether the trait will be used\n+as an [object](objects.md) or as a [bound on generics](generics.md);\n+the tradeoffs are discussed in each of the linked sections.\n+\n+If a trait is meant to be used as an object, its methods should take\n+and return trait objects rather than use generics.\n+\n+\n+### Default methods [FIXME]\n+\n+> **[FIXME]** Guidelines for default methods."}, {"sha": "48c37eabcaaa13ab200aa90da74a281e2758501b", "filename": "src/doc/style/features/traits/common.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,71 @@\n+% Common traits\n+\n+### Eagerly implement common traits. [FIXME: needs RFC]\n+\n+Rust's trait system does not allow _orphans_: roughly, every `impl` must live\n+either in the crate that defines the trait or the implementing\n+type. Consequently, crates that define new types should eagerly implement all\n+applicable, common traits.\n+\n+To see why, consider the following situation:\n+\n+* Crate `std` defines trait `Show`.\n+* Crate `url` defines type `Url`, without implementing `Show`.\n+* Crate `webapp` imports from both `std` and `url`,\n+\n+There is no way for `webapp` to add `Show` to `url`, since it defines neither.\n+(Note: the newtype pattern can provide an efficient, but inconvenient\n+workaround; see [newtype for views](../types/newtype.md))\n+\n+The most important common traits to implement from `std` are:\n+\n+```rust\n+Clone, Show, Hash, Eq\n+```\n+\n+#### When safe, derive or otherwise implement `Send` and `Share`. [FIXME]\n+\n+> **[FIXME]**. This guideline is in flux while the \"opt-in\" nature of\n+> built-in traits is being decided. See https://github.com/rust-lang/rfcs/pull/127\n+\n+### Prefer to derive, rather than implement. [FIXME: needs RFC]\n+\n+Deriving saves implementation effort, makes correctness trivial, and\n+automatically adapts to upstream changes.\n+\n+### Do not overload operators in surprising ways. [FIXME: needs RFC]\n+\n+Operators with built in syntax (`*`, `|`, and so on) can be provided for a type\n+by implementing the traits in `core::ops`. These operators come with strong\n+expectations: implement `Mul` only for an operation that bears some resemblance\n+to multiplication (and shares the expected properties, e.g. associativity), and\n+so on for the other traits.\n+\n+### The `Drop` trait\n+\n+The `Drop` trait is treated specially by the compiler as a way of\n+associating destructors with types. See\n+[the section on destructors](../../ownership/destructors.md) for\n+guidance.\n+\n+### The `Deref`/`DerefMut` traits\n+\n+#### Use `Deref`/`DerefMut` only for smart pointers. [FIXME: needs RFC]\n+\n+The `Deref` traits are used implicitly by the compiler in many circumstances,\n+and interact with method resolution. The relevant rules are designed\n+specifically to accommodate smart pointers, and so the traits should be used\n+only for that purpose.\n+\n+#### Do not fail within a `Deref`/`DerefMut` implementation. [FIXME: needs RFC]\n+\n+Because the `Deref` traits are invoked implicitly by the compiler in sometimes\n+subtle ways, failure during dereferencing can be extremely confusing. If a\n+dereference might not succeed, target the `Deref` trait as a `Result` or\n+`Option` type instead.\n+\n+#### Avoid inherent methods when implementing `Deref`/`DerefMut` [FIXME: needs RFC]\n+\n+The rules around method resolution and `Deref` are in flux, but inherent methods\n+on a type implementing `Deref` are likely to shadow any methods of the referent\n+with the same name."}, {"sha": "fc3a03c01f5a184e5afdb75d62ec6e32f3cd1fa0", "filename": "src/doc/style/features/traits/extensions.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,7 @@\n+% Using traits to add extension methods\n+\n+> **[FIXME]** Elaborate.\n+\n+### Consider using default methods rather than extension traits **[FIXME]**\n+\n+> **[FIXME]** Elaborate."}, {"sha": "ab4f9cb1579611fdfc951e06856e8c637c557a6f", "filename": "src/doc/style/features/traits/generics.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,68 @@\n+% Using traits for bounds on generics\n+\n+The most widespread use of traits is for writing generic functions or types. For\n+example, the following signature describes a function for consuming any iterator\n+yielding items of type `A` to produce a collection of `A`:\n+\n+```rust\n+fn from_iter<T: Iterator<A>>(iterator: T) -> SomeCollection<A>\n+```\n+\n+Here, the `Iterator` trait is specifies an interface that a type `T` must\n+explicitly implement to be used by this generic function.\n+\n+**Pros**:\n+\n+* _Reusability_. Generic functions can be applied to an open-ended collection of\n+  types, while giving a clear contract for the functionality those types must\n+  provide.\n+* _Static dispatch and optimization_. Each use of a generic function is\n+  specialized (\"monomorphized\") to the particular types implementing the trait\n+  bounds, which means that (1) invocations of trait methods are static, direct\n+  calls to the implementation and (2) the compiler can inline and otherwise\n+  optimize these calls.\n+* _Inline layout_. If a `struct` and `enum` type is generic over some type\n+  parameter `T`, values of type `T` will be laid out _inline_ in the\n+  `struct`/`enum`, without any indirection.\n+* _Inference_. Since the type parameters to generic functions can usually be\n+  inferred, generic functions can help cut down on verbosity in code where\n+  explicit conversions or other method calls would usually be necessary. See the\n+  [overloading/implicits use case](#use-case:-limited-overloading-and/or-implicit-conversions)\n+  below.\n+* _Precise types_. Because generic give a _name_ to the specific type\n+  implementing a trait, it is possible to be precise about places where that\n+  exact type is required or produced. For example, a function\n+\n+  ```rust\n+  fn binary<T: Trait>(x: T, y: T) -> T\n+  ```\n+\n+  is guaranteed to consume and produce elements of exactly the same type `T`; it\n+  cannot be invoked with parameters of different types that both implement\n+  `Trait`.\n+\n+**Cons**:\n+\n+* _Code size_. Specializing generic functions means that the function body is\n+  duplicated. The increase in code size must be weighed against the performance\n+  benefits of static dispatch.\n+* _Homogeneous types_. This is the other side of the \"precise types\" coin: if\n+  `T` is a type parameter, it stands for a _single_ actual type. So for example\n+  a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n+  vector representation is specialized to lay these out in line). Sometimes\n+  heterogeneous collections are useful; see\n+  [trait objects](#use-case:-trait-objects) below.\n+* _Signature verbosity_. Heavy use of generics can bloat function signatures.\n+  **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n+\n+### Favor widespread traits. **[FIXME: needs RFC]**\n+\n+Generic types are a form of abstraction, which entails a mental indirection: if\n+a function takes an argument of type `T` bounded by `Trait`, clients must first\n+think about the concrete types that implement `Trait` to understand how and when\n+the function is callable.\n+\n+To keep the cost of abstraction low, favor widely-known traits. Whenever\n+possible, implement and use traits provided as part of the standard library.  Do\n+not introduce new traits for generics lightly; wait until there are a wide range\n+of types that can implement the type."}, {"sha": "38494a9b9bc3c02a0b7f529849c1584990e5bb23", "filename": "src/doc/style/features/traits/objects.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,49 @@\n+% Using trait objects\n+\n+> **[FIXME]** What are uses of trait objects other than heterogeneous collections?\n+\n+Trait objects are useful primarily when _heterogeneous_ collections of objects\n+need to be treated uniformly; it is the closest that Rust comes to\n+object-oriented programming.\n+\n+```rust\n+struct Frame  { ... }\n+struct Button { ... }\n+struct Label  { ... }\n+\n+trait Widget  { ... }\n+\n+impl Widget for Frame  { ... }\n+impl Widget for Button { ... }\n+impl Widget for Label  { ... }\n+\n+impl Frame {\n+    fn new(contents: &[Box<Widget>]) -> Frame {\n+        ...\n+    }\n+}\n+\n+fn make_gui() -> Box<Widget> {\n+    let b: Box<Widget> = box Button::new(...);\n+    let l: Box<Widget> = box Label::new(...);\n+\n+    box Frame::new([b, l]) as Box<Widget>\n+}\n+```\n+\n+By using trait objects, we can set up a GUI framework with a `Frame` widget that\n+contains a heterogeneous collection of children widgets.\n+\n+**Pros**:\n+\n+* _Heterogeneity_. When you need it, you really need it.\n+* _Code size_. Unlike generics, trait objects do not generate specialized\n+  (monomorphized) versions of code, which can greatly reduce code size.\n+\n+**Cons**:\n+\n+* _No generic methods_. Trait objects cannot currently provide generic methods.\n+* _Dynamic dispatch and fat pointers_. Trait objects inherently involve\n+  indirection and vtable dispatch, which can carry a performance penalty.\n+* _No Self_. Except for the method receiver argument, methods on trait objects\n+  cannot use the `Self` type."}, {"sha": "d7482c96190723e943812db84cb4e1a4774a2fac", "filename": "src/doc/style/features/traits/overloading.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,7 @@\n+% Using traits for overloading\n+\n+> **[FIXME]** Elaborate.\n+\n+> **[FIXME]** We need to decide on guidelines for this use case. There are a few\n+> patterns emerging in current Rust code, but it's not clear how widespread they\n+> should be."}, {"sha": "6735023ae680098dd9223ddb6583221961c83c28", "filename": "src/doc/style/features/traits/reuse.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,30 @@\n+% Using traits to share implementations\n+\n+> **[FIXME]** Elaborate.\n+\n+> **[FIXME]** We probably want to discourage this, at least when used in a way\n+> that is publicly exposed.\n+\n+Traits that provide default implmentations for function can provide code reuse\n+across types. For example, a `print` method can be defined across multiple\n+types as follows:\n+\n+``` Rust\n+trait Printable {\n+    // Default method implementation\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for int {}\n+\n+impl Printable for String {\n+    fn print(&self) { println!(\"{}\", *self) }\n+}\n+\n+impl Printable for bool {}\n+\n+impl Printable for f32 {}\n+```\n+\n+This allows the implementation of `print` to be shared across types, yet\n+overridden where needed, as seen in the `impl` for `String`."}, {"sha": "c675eb581c6ae328945c815116f2fe989baf570f", "filename": "src/doc/style/features/types/README.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,68 @@\n+% Data types\n+\n+### Use custom types to imbue meaning; do not abuse `bool`, `Option` or other core types. **[FIXME: needs RFC]**\n+\n+Prefer\n+\n+```rust\n+let w = Widget::new(Small, Round)\n+```\n+\n+over\n+\n+```rust\n+let w = Widget::new(true, false)\n+```\n+\n+Core types like `bool`, `u8` and `Option` have many possible interpretations.\n+\n+Use custom types (whether `enum`s, `struct`, or tuples) to convey\n+interpretation and invariants. In the above example,\n+it is not immediately clear what `true` and `false` are conveying without\n+looking up the argument names, but `Small` and `Round` are more suggestive.\n+\n+Using custom types makes it easier to expand the\n+options later on, for example by adding an `ExtraLarge` variant.\n+\n+See [the newtype pattern](newtype.md) for a no-cost way to wrap\n+existing types with a distinguished name.\n+\n+### Prefer private fields, except for passive data. **[FIXME: needs RFC]**\n+\n+Making a field public is a strong commitment: it pins down a representation\n+choice, _and_ prevents the type from providing any validation or maintaining any\n+invariants on the contents of the field, since clients can mutate it arbitrarily.\n+\n+Public fields are most appropriate for `struct` types in the C spirit: compound,\n+passive data structures. Otherwise, consider providing getter/setter methods\n+and hiding fields instead.\n+\n+> **[FIXME]** Cross-reference validation for function arguments.\n+\n+### Use custom `enum`s for alternatives, `bitflags` for C-style flags. **[FIXME: needs RFC]**\n+\n+Rust supports `enum` types with \"custom discriminants\":\n+\n+~~~~\n+enum Color {\n+  Red = 0xff0000,\n+  Green = 0x00ff00,\n+  Blue = 0x0000ff\n+}\n+~~~~\n+\n+Custom discriminants are useful when an `enum` type needs to be serialized to an\n+integer value compatibly with some other system/language. They support\n+\"typesafe\" APIs: by taking a `Color`, rather than an integer, a function is\n+guaranteed to get well-formed inputs, even if it later views those inputs as\n+integers.\n+\n+An `enum` allows an API to request exactly one choice from among many. Sometimes\n+an API's input is instead the presence or absence of a set of flags. In C code,\n+this is often done by having each flag correspond to a particular bit, allowing\n+a single integer to represent, say, 32 or 64 flags. Rust's `std::bitflags`\n+module provides a typesafe way for doing so.\n+\n+### Phantom types. [FIXME]\n+\n+> **[FIXME]** Add some material on phantom types (https://blog.mozilla.org/research/2014/06/23/static-checking-of-units-in-servo/)"}, {"sha": "f0f230f57e557cf2c08d8058ecd1cb5ec41a4652", "filename": "src/doc/style/features/types/conversions.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,22 @@\n+% Conversions between types\n+\n+### Associate conversions with the most specific type involved. **[FIXME: needs RFC]**\n+\n+When in doubt, prefer `to_`/`as_`/`into_` to `from_`, because they are\n+more ergonomic to use (and can be chained with other methods).\n+\n+For many conversions between two types, one of the types is clearly more\n+\"specific\": it provides some additional invariant or interpretation that is not\n+present in the other type. For example, `str` is more specific than `&[u8]`,\n+since it is a utf-8 encoded sequence of bytes.\n+\n+Conversions should live with the more specific of the involved types. Thus,\n+`str` provides both the `as_bytes` method and the `from_utf8` constructor for\n+converting to and from `&[u8]` values. Besides being intuitive, this convention\n+avoids polluting concrete types like `&[u8]` with endless conversion methods.\n+\n+### Explicitly mark lossy conversions, or do not label them as conversions. **[FIXME: needs RFC]**\n+\n+If a function's name implies that it is a conversion (prefix `from_`, `as_`,\n+`to_` or `into_`), but the function loses information, add a suffix `_lossy` or\n+otherwise indicate the lossyness. Consider avoiding the conversion name prefix."}, {"sha": "60c17fc2a52e2985277387b609bbfb74409a919e", "filename": "src/doc/style/features/types/newtype.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,69 @@\n+% The newtype pattern\n+\n+A \"newtype\" is a tuple or `struct` with a single field. The terminology is borrowed from Haskell.\n+\n+Newtypes are a zero-cost abstraction: they introduce a new, distinct name for an\n+existing type, with no runtime overhead when converting between the two types.\n+\n+### Use newtypes to provide static distinctions. [FIXME: needs RFC]\n+\n+Newtypes can statically distinguish between different interpretations of an\n+underlying type.\n+\n+For example, a `f64` value might be used to represent a quantity in miles or in\n+kilometers. Using newtypes, we can keep track of the intended interpretation:\n+\n+```rust\n+struct Miles(pub f64);\n+struct Kilometers(pub f64);\n+\n+impl Miles {\n+    fn as_kilometers(&self) -> Kilometers { ... }\n+}\n+impl Kilometers {\n+    fn as_miles(&self) -> Miles { ... }\n+}\n+```\n+\n+Once we have separated these two types, we can statically ensure that we do not\n+confuse them. For example, the function\n+\n+```rust\n+fn are_we_there_yet(distance_travelled: Miles) -> bool { ... }\n+```\n+\n+cannot accidentally be called with a `Kilometers` value. The compiler will\n+remind us to perform the conversion, thus averting certain\n+[catastrophic bugs](http://en.wikipedia.org/wiki/Mars_Climate_Orbiter).\n+\n+### Use newtypes with private fields for hiding. [FIXME: needs RFC]\n+\n+A newtype can be used to hide representation details while making precise\n+promises to the client.\n+\n+For example, consider a function `my_transform` that returns a compound iterator\n+type `Enumerate<Skip<vec::MoveItems<T>>>`. We wish to hide this type from the\n+client, so that the client's view of the return type is roughly `Iterator<(uint,\n+T)>`. We can do so using the newtype pattern:\n+\n+```rust\n+struct MyTransformResult<T>(Enumerate<Skip<vec::MoveItems<T>>>);\n+impl<T> Iterator<(uint, T)> for MyTransformResult<T> { ... }\n+\n+fn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> MyTransformResult<T> {\n+    ...\n+}\n+```\n+\n+Aside from simplifying the signature, this use of newtypes allows us to make a\n+expose and promise less to the client. The client does not know _how_ the result\n+iterator is constructed or represented, which means the representation can\n+change in the future without breaking client code.\n+\n+> **[FIXME]** Interaction with auto-deref.\n+\n+### Use newtypes to provide cost-free _views_ of another type. **[FIXME]**\n+\n+> **[FIXME]** Describe the pattern of using newtypes to provide a new set of\n+> inherent or trait methods, providing a different perspective on the underlying\n+> type."}, {"sha": "11bdb03a3a81851cc6e77b56a62b779ef5172b79", "filename": "src/doc/style/ownership/README.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,3 @@\n+% Ownership and resource management\n+\n+> **[FIXME]** Add general remarks about ownership/resources here."}, {"sha": "94eda59b95b6510f8f6774959d39daa26e456207", "filename": "src/doc/style/ownership/builders.md", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,176 @@\n+% The builder pattern\n+\n+Some data structures are complicated to construct, due to their construction needing:\n+\n+* a large number of inputs\n+* compound data (e.g. slices)\n+* optional configuration data\n+* choice between several flavors\n+\n+which can easily lead to a large number of distinct constructors with\n+many arguments each.\n+\n+If `T` is such a data structure, consider introducing a `T` _builder_:\n+\n+1. Introduce a separate data type `TBuilder` for incrementally configuring a `T`\n+   value. When possible, choose a better name: e.g. `Command` is the builder for\n+   `Process`.\n+2. The builder constructor should take as parameters only the data _required_ to\n+   to make a `T`.\n+3. The builder should offer a suite of convenient methods for configuration,\n+   including setting up compound inputs (like slices) incrementally.\n+   These methods should return `self` to allow chaining.\n+4. The builder should provide one or more \"_terminal_\" methods for actually building a `T`.\n+\n+The builder pattern is especially appropriate when building a `T` involves side\n+effects, such as spawning a task or launching a process.\n+\n+In Rust, there are two variants of the builder pattern, differing in the\n+treatment of ownership, as described below.\n+\n+### Non-consuming builders (preferred):\n+\n+In some cases, constructing the final `T` does not require the builder itself to\n+be consumed. The follow variant on\n+[`std::io::process::Command`](http://static.rust-lang.org/doc/master/std/io/process/struct.Command.html)\n+is one example:\n+\n+```rust\n+// NOTE: the actual Command API does not use owned Strings;\n+// this is a simplified version.\n+\n+pub struct Command {\n+    program: String,\n+    args: Vec<String>,\n+    cwd: Option<String>,\n+    // etc\n+}\n+\n+impl Command {\n+    pub fn new(program: String) -> Command {\n+        Command {\n+            program: program,\n+            args: Vec::new(),\n+            cwd: None,\n+        }\n+    }\n+\n+    /// Add an argument to pass to the program.\n+    pub fn arg<'a>(&'a mut self, arg: String) -> &'a mut Command {\n+        self.args.push(arg);\n+        self\n+    }\n+\n+    /// Add multiple arguments to pass to the program.\n+    pub fn args<'a>(&'a mut self, args: &[String])\n+                    -> &'a mut Command {\n+        self.args.push_all(args);\n+        self\n+    }\n+\n+    /// Set the working directory for the child process.\n+    pub fn cwd<'a>(&'a mut self, dir: String) -> &'a mut Command {\n+        self.cwd = Some(dir);\n+        self\n+    }\n+\n+    /// Executes the command as a child process, which is returned.\n+    pub fn spawn(&self) -> IoResult<Process> {\n+        ...\n+    }\n+}\n+```\n+\n+Note that the `spawn` method, which actually uses the builder configuration to\n+spawn a process, takes the builder by immutable reference. This is possible\n+because spawning the process does not require ownership of the configuration\n+data.\n+\n+Because the terminal `spawn` method only needs a reference, the configuration\n+methods take and return a mutable borrow of `self`.\n+\n+#### The benefit\n+\n+By using borrows throughout, `Command` can be used conveniently for both\n+one-liner and more complex constructions:\n+\n+```rust\n+// One-liners\n+Command::new(\"/bin/cat\").arg(\"file.txt\").spawn();\n+\n+// Complex configuration\n+let mut cmd = Command::new(\"/bin/ls\");\n+cmd.arg(\".\");\n+\n+if size_sorted {\n+    cmd.arg(\"-S\");\n+}\n+\n+cmd.spawn();\n+```\n+\n+### Consuming builders:\n+\n+Sometimes builders must transfer ownership when constructing the final type\n+`T`, meaning that the terminal methods must take `self` rather than `&self`:\n+\n+```rust\n+// A simplified excerpt from std::task::TaskBuilder\n+\n+impl TaskBuilder {\n+    /// Name the task-to-be. Currently the name is used for identification\n+    /// only in failure messages.\n+    pub fn named(mut self, name: String) -> TaskBuilder {\n+        self.name = Some(name);\n+        self\n+    }\n+\n+    /// Redirect task-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n+        self.stdout = Some(stdout);\n+        //   ^~~~~~ this is owned and cannot be cloned/re-used\n+        self\n+    }\n+\n+    /// Creates and executes a new child task.\n+    pub fn spawn(self, f: proc():Send) {\n+        // consume self\n+        ...\n+    }\n+}\n+```\n+\n+Here, the `stdout` configuration involves passing ownership of a `Writer`,\n+which must be transferred to the task upon construction (in `spawn`).\n+\n+When the terminal methods of the builder require ownership, there is a basic tradeoff:\n+\n+* If the other builder methods take/return a mutable borrow, the complex\n+  configuration case will work well, but one-liner configuration becomes\n+  _impossible_.\n+\n+* If the other builder methods take/return an owned `self`, one-liners\n+  continue to work well but complex configuration is less convenient.\n+\n+Under the rubric of making easy things easy and hard things possible, _all_\n+builder methods for a consuming builder should take and returned an owned\n+`self`. Then client code works as follows:\n+\n+```rust\n+// One-liners\n+TaskBuilder::new().named(\"my_task\").spawn(proc() { ... });\n+\n+// Complex configuration\n+let mut task = TaskBuilder::new();\n+task = task.named(\"my_task_2\"); // must re-assign to retain ownership\n+\n+if reroute {\n+    task = task.stdout(mywriter);\n+}\n+\n+task.spawn(proc() { ... });\n+```\n+\n+One-liners work as before, because ownership is threaded through each of the\n+builder methods until being consumed by `spawn`. Complex configuration,\n+however, is more verbose: it requires re-assigning the builder at each step."}, {"sha": "cd027cc4aaffc96728ae64289533043b8f8471ed", "filename": "src/doc/style/ownership/cell-smart.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,4 @@\n+% Cells and smart pointers\n+\n+> **[FIXME]** Add guidelines about when to use Cell, RefCell, Rc and\n+> Arc (and how to use them together)."}, {"sha": "b4a1147315679f09dbcbaa30306977a8f474d6b1", "filename": "src/doc/style/ownership/constructors.md", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,62 @@\n+% Constructors\n+\n+### Define constructors as static, inherent methods. [FIXME: needs RFC]\n+\n+In Rust, \"constructors\" are just a convention:\n+\n+```rust\n+impl<T> Vec<T> {\n+    pub fn new() -> Vec<T> { ... }\n+}\n+```\n+\n+Constructors are static (no `self`) inherent methods for the type that they\n+construct. Combined with the practice of\n+[fully importing type names](../style/imports.md), this convention leads to\n+informative but concise construction:\n+\n+```rust\n+use vec::Vec;\n+\n+// construct a new vector\n+let mut v = Vec::new();\n+```\n+\n+This convention also applied to conversion constructors (prefix `from` rather\n+than `new`).\n+\n+### Provide constructors for passive `struct`s with defaults. [FIXME: needs RFC]\n+\n+Given the `struct`\n+\n+```rust\n+pub struct Config {\n+    pub color: Color,\n+    pub size:  Size,\n+    pub shape: Shape,\n+}\n+```\n+\n+provide a constructor if there are sensible defaults:\n+\n+```rust\n+impl Config {\n+    pub fn new() -> Config {\n+        Config {\n+            color: Brown,\n+            size: Medium,\n+            shape: Square,\n+        }\n+    }\n+}\n+```\n+\n+which then allows clients to concisely override using `struct` update syntax:\n+\n+```rust\n+Config { color: Red, .. Config::new() };\n+```\n+\n+See the [guideline for field privacy](../features/types/README.md) for\n+discussion on when to create such \"passive\" `struct`s with public\n+fields."}, {"sha": "8f58aa6c6d2f1e862018032c0096c1754e78f491", "filename": "src/doc/style/ownership/destructors.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,22 @@\n+% Destructors\n+\n+Unlike constructors, destructors in Rust have a special status: they are added\n+by implementing `Drop` for a type, and they are automatically invoked as values\n+go out of scope.\n+\n+> **[FIXME]** This section needs to be expanded.\n+\n+### Destructors should not fail. [FIXME: needs RFC]\n+\n+Destructors are executed on task failure, and in that context a failing\n+destructor causes the program to abort.\n+\n+Instead of failing in a destructor, provide a separate method for checking for\n+clean teardown, e.g. a `close` method, that returns a `Result` to signal\n+problems.\n+\n+### Destructors should not block. [FIXME: needs RFC]\n+\n+Similarly, destructors should not invoke blocking operations, which can make\n+debugging much more difficult. Again, consider providing a separate method for\n+preparing for an infallible, nonblocking teardown."}, {"sha": "244e8096a1a2f26a230512c1f1d91ab4abfd5547", "filename": "src/doc/style/ownership/raii.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,12 @@\n+% RAII\n+\n+Resource Acquisition is Initialization\n+\n+> **[FIXME]** Explain the RAII pattern and give best practices.\n+\n+### Whenever possible, tie resource access to guard scopes [FIXME]\n+\n+> **[FIXME]** Example: Mutex guards guarantee that access to the\n+> protected resource only happens when the guard is in scope.\n+\n+`must_use`"}, {"sha": "d29d060b6946195deb8238a438d77f05a8c65412", "filename": "src/doc/style/platform.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fplatform.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fplatform.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fplatform.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,7 @@\n+% FFI and platform-specific code **[FIXME]**\n+\n+> **[FIXME]** Not sure where this should live.\n+\n+When writing cross-platform code, group platform-specific code into a\n+module called `platform`. Avoid `#[cfg]` directives outside this\n+`platform` module."}, {"sha": "1ac6e704d23ebcca784d34df02987c859f8c2144", "filename": "src/doc/style/safety/README.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,19 @@\n+% Safety and guarantees\n+\n+> **[FIXME]** Is there a better phrase than \"strong guarantees\" that encompasses\n+> both e.g. memory safety and e.g. data structure invariants?\n+\n+A _guarantee_ is a property that holds no matter what client code does, unless\n+the client explicitly opts out:\n+\n+* Rust guarantees memory safety and data-race freedom, with `unsafe`\n+  blocks as an opt-out mechanism.\n+\n+* APIs in Rust often provide their own guarantees. For example, `std::str`\n+guarantees that its underlying buffer is valid utf-8. The `std::path::Path` type\n+guarantees no interior nulls. Both strings and paths provide `unsafe` mechanisms\n+for opting out of these guarantees (and thereby avoiding runtime checks).\n+\n+Thinking about guarantees is an essential part of writing good Rust code.  The\n+rest of this subsection outlines some cross-cutting principles around\n+guarantees."}, {"sha": "aa87223383a10d0f38fe4af7ece9ec96425f64f1", "filename": "src/doc/style/safety/lib-guarantees.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,81 @@\n+% Library-level guarantees\n+\n+Most libraries rely on internal invariants, e.g. about their data, resource\n+ownership, or protocol states. In Rust, broken invariants cannot produce\n+segfaults, but they can still lead to wrong answers.\n+\n+### Provide library-level guarantees whenever practical. **[FIXME: needs RFC]**\n+\n+Library-level invariants should be turned into guarantees whenever\n+practical. They should hold no matter what the client does, modulo\n+explicit opt-outs. Depending on the kind of invariant, this can be\n+achieved through a combination of static and dynamic enforcement, as\n+described below.\n+\n+#### Static enforcement:\n+\n+Guaranteeing invariants almost always requires _hiding_,\n+i.e. preventing the client from directly accessing or modifying\n+internal data.\n+\n+For example, the representation of the `str` type is hidden,\n+which means that any value of type `str` must have been produced\n+through an API under the control of the `str` module, and these\n+APIs in turn ensure valid utf-8 encoding.\n+\n+Rust's type system makes it possible to provide guarantees even while\n+revealing more of the representation than usual. For example, the\n+`as_bytes()` method on `&str` gives a _read-only_ view into the\n+underlying buffer, which cannot be used to violate the utf-8 property.\n+\n+#### Dynamic enforcement:\n+\n+Malformed inputs from the client are hazards to library-level\n+guarantees, so library APIs should validate their input.\n+\n+For example, `std::str::from_utf8_owned` attempts to convert a `u8`\n+slice into an owned string, but dynamically checks that the slice is\n+valid utf-8 and returns `Err` if not.\n+\n+See\n+[the discussion on input validation](../features/functions-and-methods/input.md)\n+for more detail.\n+\n+\n+### Prefer static enforcement of guarantees. **[FIXME: needs RFC]**\n+\n+Static enforcement provides two strong benefits over dynamic enforcement:\n+\n+* Bugs are caught at compile time.\n+* There is no runtime cost.\n+\n+Sometimes purely static enforcement is impossible or impractical. In these\n+cases, a library should check as much as possible statically, but defer to\n+dynamic checks where needed.\n+\n+For example, the `std::string` module exports a `String` type with the guarantee\n+that all instances are valid utf-8:\n+\n+* Any _consumer_ of a `String` is statically guaranteed utf-8 contents. For example,\n+  the `append` method can push a `&str` onto the end of a `String` without\n+  checking anything dynamically, since the existing `String` and `&str` are\n+  statically guaranteed to be in utf-8.\n+\n+* Some _producers_ of a `String` must perform dynamic checks. For example, the\n+  `from_utf8` function attempts to convert a `Vec<u8>` into a `String`, but\n+  dynamically checks that the contents are utf-8.\n+\n+### Provide opt-outs with caution; make them explicit. **[FIXME: needs RFC]**\n+\n+Providing library-level guarantees sometimes entails inconvenience (for static\n+checks) or overhead (for dynamic checks). So it is sometimes desirable to allow\n+clients to sidestep this checking, while promising to use the API in a way that\n+still provides the guarantee. Such escape hatches should only be be introduced\n+when there is a demonstrated need for them.\n+\n+It should be trivial for clients to audit their use of the library for\n+escape hatches.\n+\n+See\n+[the discussion on input validation](../features/functions-and-methods/input.md)\n+for conventions on marking opt-out functions."}, {"sha": "a8a50af044c2916e1fc6e9de79bd75bf3f05266b", "filename": "src/doc/style/safety/unsafe.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,22 @@\n+% Using `unsafe`\n+\n+### Unconditionally guarantee safety, or mark API as `unsafe`. **[FIXME: needs RFC]**\n+\n+Memory safety, type safety, and data race freedom are basic assumptions for all\n+Rust code.\n+\n+APIs that use `unsafe` blocks internally thus have two choices:\n+\n+* They can guarantee safety _unconditionally_ (i.e., regardless of client\n+  behavior or inputs) and be exported as safe code. Any safety violation is then\n+  the library's fault, not the client's fault.\n+\n+* They can export potentially unsafe functions with the `unsafe` qualifier. In\n+  this case, the documentation should make very clear the conditions under which\n+  safety is guaranteed.\n+\n+The result is that a client program can never violate safety merely by having a\n+bug; it must have explicitly opted out by using an `unsafe` block.\n+\n+Of the two options for using `unsafe`, creating such safe abstractions (the\n+first option above) is strongly preferred."}, {"sha": "87449710543c01f0ec0f7e57bf47448abef704e1", "filename": "src/doc/style/style/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,5 @@\n+% Style\n+\n+This section gives a set of strict rules for styling Rust code.\n+\n+> **[FIXME]** General remarks about the style guidelines"}, {"sha": "0f61bac9fd229133729efd7359518747238c0c6b", "filename": "src/doc/style/style/braces.md", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,77 @@\n+% Braces, semicolons, and commas [FIXME: needs RFC]\n+\n+### Opening braces always go on the same line.\n+\n+``` rust\n+fn foo() {\n+    ...\n+}\n+\n+fn frobnicate(a: Bar, b: Bar,\n+              c: Bar, d: Bar)\n+              -> Bar {\n+    ...\n+}\n+\n+trait Bar {\n+    fn baz(&self);\n+}\n+\n+impl Bar for Baz {\n+    fn baz(&self) {\n+        ...\n+    }\n+}\n+\n+frob(|x| {\n+    x.transpose()\n+})\n+```\n+\n+### `match` arms get braces, except for single-line expressions.\n+\n+``` rust\n+match foo {\n+    bar => baz,\n+    quux => {\n+        do_something();\n+        do_something_else()\n+    }\n+}\n+```\n+\n+### `return` statements get semicolons.\n+\n+``` rust\n+fn foo() {\n+    do_something();\n+\n+    if condition() {\n+        return;\n+    }\n+\n+    do_something_else();\n+}\n+```\n+\n+### Trailing commas\n+\n+> **[FIXME]** We should have a guideline for when to include trailing\n+> commas in `struct`s, `match`es, function calls, etc.\n+>\n+> One possible rule: a trailing comma should be included whenever the\n+> closing delimiter appears on a separate line:\n+\n+```rust\n+Foo { bar: 0, baz: 1 }\n+\n+Foo {\n+    bar: 0,\n+    baz: 1,\n+}\n+\n+match a_thing {\n+    None => 0,\n+    Some(x) => 1,\n+}\n+```"}, {"sha": "347750ce6020df1da5afcb74b583c6bf3aa4799c", "filename": "src/doc/style/style/comments.md", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,87 @@\n+% Comments [FIXME: needs RFC]\n+\n+### Avoid block comments.\n+\n+Use line comments:\n+\n+``` rust\n+// Wait for the main task to return, and set the process error code\n+// appropriately.\n+```\n+\n+Instead of:\n+\n+``` rust\n+/*\n+ * Wait for the main task to return, and set the process error code\n+ * appropriately.\n+ */\n+```\n+\n+## Doc comments\n+\n+Doc comments are prefixed by three slashes (`///`) and indicate\n+documentation that you would like to be included in Rustdoc's output.\n+They support\n+[Markdown syntax](https://en.wikipedia.org/wiki/Markdown)\n+and are the main way of documenting your public APIs.\n+\n+The supported markdown syntax includes all of the extensions listed in the\n+[GitHub Flavored Markdown]\n+(https://help.github.com/articles/github-flavored-markdown) documentation,\n+plus superscripts.\n+\n+### Summary line\n+\n+The first line in any doc comment should be a single-line short sentence\n+providing a summary of the code. This line is used as a short summary\n+description throughout Rustdoc's output, so it's a good idea to keep it\n+short.\n+\n+### Sentence structure\n+\n+All doc comments, including the summary line, should begin with a\n+capital letter and end with a period, question mark, or exclamation\n+point. Prefer full sentences to fragments.\n+\n+The summary line should be written in\n+[third person singular present indicative form]\n+(http://en.wikipedia.org/wiki/English_verbs#Third_person_singular_present).\n+Basically, this means write \"Returns\" instead of \"Return\".\n+\n+For example:\n+\n+``` rust\n+/// Sets up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This function will block until the entire pool of M:N schedulers has\n+/// exited. This function also requires a local task to be available.\n+///\n+/// # Arguments\n+///\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///                     by `os::args`.\n+/// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n+///            Once this procedure exits, the scheduling pool will begin to shut\n+///            down. The entire pool (and this function) will only return once\n+///            all child tasks have finished executing.\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on\n+/// error.\n+```\n+\n+### Code snippets\n+\n+> **[FIXME]**\n+\n+### Avoid inner doc comments.\n+\n+Use inner doc comments _only_ to document crates and file-level modules:\n+\n+``` rust\n+//! The core library.\n+//!\n+//! The core library is a something something...\n+```"}, {"sha": "f73517c2b9c3b6ce1d9853103d12eda07311d0fd", "filename": "src/doc/style/style/features.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,13 @@\n+## `return` [FIXME: needs RFC]\n+\n+Terminate `return` statements with semicolons:\n+\n+``` rust\n+fn foo(bar: int) -> Option<int> {\n+    if some_condition() {\n+        return None;\n+    }\n+\n+    ...\n+}\n+```"}, {"sha": "207a3fd7f8d165d81d58740d97f5368ea4f0a7f4", "filename": "src/doc/style/style/imports.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,50 @@\n+% Imports [FIXME: needs RFC]\n+\n+The imports of a crate/module should consist of the following\n+sections, in order, with a blank space between each:\n+\n+* `extern crate` directives\n+* external `use` imports\n+* local `use` imports\n+* `pub use` imports\n+\n+For example:\n+\n+```rust\n+// Crates.\n+extern crate getopts;\n+extern crate mylib;\n+\n+// Standard library imports.\n+use getopts::{optopt, getopts};\n+use std::os;\n+\n+// Import from a library that we wrote.\n+use mylib::webserver;\n+\n+// Will be reexported when we import this module.\n+pub use self::types::Webdata;\n+```\n+\n+### Avoid `use *`, except in tests.\n+\n+Glob imports have several downsides:\n+* They make it harder to tell where names are bound.\n+* They are forwards-incompatible, since new upstream exports can clash\n+  with existing names.\n+\n+When writing a [`test` submodule](../testing/README.md), importing `super::*` is appropriate\n+as a convenience.\n+\n+### Prefer fully importing types/traits while module-qualifying functions.\n+\n+For example:\n+\n+```rust\n+use option::Option;\n+use mem;\n+\n+let i: int = mem::transmute(Option(0));\n+```\n+\n+> **[FIXME]** Add rationale."}, {"sha": "9d78721ad3644965a11e0fb1b6dd7115a20ae841", "filename": "src/doc/style/style/naming/README.md", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,115 @@\n+% Naming conventions\n+\n+### General conventions [RFC #430]\n+\n+> The guidelines below were approved by [RFC #430](https://github.com/rust-lang/rfcs/pull/430).\n+\n+In general, Rust tends to use `CamelCase` for \"type-level\" constructs\n+(types and traits) and `snake_case` for \"value-level\" constructs. More\n+precisely:\n+\n+| Item | Convention |\n+| ---- | ---------- |\n+| Crates | `snake_case` (but prefer single word) |\n+| Modules | `snake_case` |\n+| Types | `CamelCase` |\n+| Traits | `CamelCase` |\n+| Enum variants | `CamelCase` |\n+| Functions | `snake_case` |\n+| Methods | `snake_case` |\n+| General constructors | `new` or `with_more_details` |\n+| Conversion constructors | `from_some_other_type` |\n+| Local variables | `snake_case` |\n+| Static variables | `SCREAMING_SNAKE_CASE` |\n+| Constant variables | `SCREAMING_SNAKE_CASE` |\n+| Type parameters | concise `CamelCase`, usually single uppercase letter: `T` |\n+| Lifetimes | short, lowercase: `'a` |\n+\n+<p>\n+In `CamelCase`, acronyms count as one word: use `Uuid` rather than\n+`UUID`.  In `snake_case`, acronyms are lower-cased: `is_xid_start`.\n+\n+In `snake_case` or `SCREAMING_SNAKE_CASE`, a \"word\" should never\n+consist of a single letter unless it is the last \"word\". So, we have\n+`btree_map` rather than `b_tree_map`, but `PI_2` rather than `PI2`.\n+\n+### Referring to types in function/method names [RFC 344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+Function names often involve type names, the most common example being conversions\n+like `as_slice`. If the type has a purely textual name (ignoring parameters), it\n+is straightforward to convert between type conventions and function conventions:\n+\n+Type name | Text in methods\n+--------- | ---------------\n+`String`  | `string`\n+`Vec<T>`  | `vec`\n+`YourType`| `your_type`\n+\n+Types that involve notation follow the convention below. There is some\n+overlap on these rules; apply the most specific applicable rule:\n+\n+Type name | Text in methods\n+--------- | ---------------\n+`&str`    | `str`\n+`&[T]`    | `slice`\n+`&mut [T]`| `mut_slice`\n+`&[u8]`   | `bytes`\n+`&T`      | `ref`\n+`&mut T`  | `mut`\n+`*const T`| `ptr`\n+`*mut T`  | `mut_ptr`\n+\n+### Avoid redundant prefixes [RFC 356]\n+\n+> The guidelines below were approved by [RFC #356](https://github.com/rust-lang/rfcs/pull/356).\n+\n+Names of items within a module should not be prefixed with that module's name:\n+\n+Prefer\n+\n+``` rust\n+mod foo {\n+    pub struct Error { ... }\n+}\n+```\n+\n+over\n+\n+``` rust\n+mod foo {\n+    pub struct FooError { ... }\n+}\n+```\n+\n+This convention avoids stuttering (like `io::IoError`). Library clients can\n+rename on import to avoid clashes.\n+\n+### Getter/setter methods [RFC 344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+Some data structures do not wish to provide direct access to their fields, but\n+instead offer \"getter\" and \"setter\" methods for manipulating the field state\n+(often providing checking or other functionality).\n+\n+The convention for a field `foo: T` is:\n+\n+* A method `foo(&self) -> &T` for getting the current value of the field.\n+* A method `set_foo(&self, val: T)` for setting the field. (The `val` argument\n+  here may take `&T` or some other type, depending on the context.)\n+\n+Note that this convention is about getters/setters on ordinary data types, *not*\n+on [builder objects](../ownership/builders.html).\n+\n+### Escape hatches [FIXME]\n+\n+> **[FIXME]** Should we standardize a convention for functions that may break API\n+> guarantees? e.g. `ToCStr::to_c_str_unchecked`\n+\n+### Predicates\n+\n+* Simple boolean predicates should be prefixed with `is_` or another\n+  short question word, e.g., `is_empty`.\n+* Common exceptions: `lt`, `gt`, and other established predicate names."}, {"sha": "04204f0f88aec18efc15a5c24e753628a38501c3", "filename": "src/doc/style/style/naming/containers.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,69 @@\n+% Common container/wrapper methods [FIXME: needs RFC]\n+\n+Containers, wrappers, and cells all provide ways to access the data\n+they enclose.  Accessor methods often have variants to access the data\n+by value, by reference, and by mutable reference.\n+\n+In general, the `get` family of methods is used to access contained\n+data without any risk of task failure; they return `Option` as\n+appropriate. This name is chosen rather than names like `find` or\n+`lookup` because it is appropriate for a wider range of container types.\n+\n+#### Containers\n+\n+For a container with keys/indexes of type `K` and elements of type `V`:\n+\n+```rust\n+// Look up element without failing\n+fn get(&self, key: K) -> Option<&V>\n+fn get_mut(&mut self, key: K) -> Option<&mut V>\n+\n+// Convenience for .get(key).map(|elt| elt.clone())\n+fn get_clone(&self, key: K) -> Option<V>\n+\n+// Lookup element, failing if it is not found:\n+impl Index<K, V> for Container { ... }\n+impl IndexMut<K, V> for Container { ... }\n+```\n+\n+#### Wrappers/Cells\n+\n+Prefer specific conversion functions like `as_bytes` or `into_vec` whenever\n+possible. Otherwise, use:\n+\n+```rust\n+// Extract contents without failing\n+fn get(&self) -> &V\n+fn get_mut(&mut self) -> &mut V\n+fn unwrap(self) -> V\n+```\n+\n+#### Wrappers/Cells around `Copy` data\n+\n+```rust\n+// Extract contents without failing\n+fn get(&self) -> V\n+```\n+\n+#### `Option`-like types\n+\n+Finally, we have the cases of types like `Option` and `Result`, which\n+play a special role for failure.\n+\n+For `Option<V>`:\n+\n+```rust\n+// Extract contents or fail if not available\n+fn assert(self) -> V\n+fn expect(self, &str) -> V\n+```\n+\n+For `Result<V, E>`:\n+\n+```rust\n+// Extract the contents of Ok variant; fail if Err\n+fn assert(self) -> V\n+\n+// Extract the contents of Err variant; fail if Ok\n+fn assert_err(self) -> E\n+```"}, {"sha": "0287919c78aae22b7dfc069b04d895d892b8807a", "filename": "src/doc/style/style/naming/conversions.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,32 @@\n+% Conversions [Rust issue #7087]\n+\n+> The guidelines below were approved by [rust issue #7087](https://github.com/rust-lang/rust/issues/7087).\n+\n+> **[FIXME]** Should we provide standard traits for conversions? Doing\n+> so nicely will require\n+> [trait reform](https://github.com/rust-lang/rfcs/pull/48) to land.\n+\n+Conversions should be provided as methods, with names prefixed as follows:\n+\n+| Prefix | Cost | Consumes convertee |\n+| ------ | ---- | ------------------ |\n+| `as_` | Free | No |\n+| `to_` | Expensive | No |\n+| `into_` | Variable | Yes |\n+\n+<p>\n+For example:\n+\n+* `as_bytes()` gives a `&[u8]` view into a `&str`, which is a no-op.\n+* `to_owned()` copies a `&str` to a new `String`.\n+* `into_bytes()` consumes a `String` and yields the underlying\n+  `Vec<u8>`, which is a no-op.\n+\n+Conversions prefixed `as_` and `into_` typically _decrease abstraction_, either\n+exposing a view into the underlying representation (`as`) or deconstructing data\n+into its underlying representation (`into`). Conversions prefixed `to_`, on the\n+other hand, typically stay at the same level of abstraction but do some work to\n+change one representation into another.\n+\n+> **[FIXME]** The distinctions between conversion methods does not work\n+> so well for `from_` conversion constructors. Is that a problem?"}, {"sha": "38138b5e39d3a0781efb0e333adc62646ee4672a", "filename": "src/doc/style/style/naming/iterators.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,32 @@\n+% Iterators\n+\n+#### Method names [RFC #199]\n+\n+> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n+\n+For a container with elements of type `U`, iterator methods should be named:\n+\n+```rust\n+fn iter(&self) -> T           // where T implements Iterator<&U>\n+fn iter_mut(&mut self) -> T   // where T implements Iterator<&mut U>\n+fn into_iter(self) -> T       // where T implements Iterator<U>\n+```\n+\n+The default iterator variant yields shared references `&U`.\n+\n+#### Type names [RFC #344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+The name of an iterator type should be the same as the method that\n+produces the iterator.\n+\n+For example:\n+\n+* `iter` should yield an `Iter`\n+* `iter_mut` should yield an `IterMut`\n+* `into_iter` should yield an `IntoIter`\n+* `keys` should yield `Keys`\n+\n+These type names make the most sense when prefixed with their owning module,\n+e.g. `vec::IntoIter`."}, {"sha": "32cd8a1595afb0a245ae6062c7218fe65fe29940", "filename": "src/doc/style/style/naming/ownership.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,34 @@\n+% Ownership variants [RFC #199]\n+\n+> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n+\n+Functions often come in multiple variants: immutably borrowed, mutably\n+borrowed, and owned.\n+\n+The right default depends on the function in question. Variants should\n+be marked through suffixes.\n+\n+#### Immutably borrowed by default\n+\n+If `foo` uses/produces an immutable borrow by default, use:\n+\n+* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n+* The `_move` suffix (e.g. `foo_move`) for the owned variant.\n+\n+#### Owned by default\n+\n+If `foo` uses/produces owned data by default, use:\n+\n+* The `_ref` suffix (e.g. `foo_ref`) for the immutably borrowed variant.\n+* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n+\n+#### Exceptions\n+\n+In the case of iterators, the moving variant can also be understood as\n+an `into` conversion, `into_iter`, and `for x in v.into_iter()` reads\n+arguably better than `for x in v.iter_move()`, so the convention is\n+`into_iter`.\n+\n+For mutably borrowed variants, if the `mut` qualifier is part of a\n+type name (e.g. `as_mut_slice`), it should appear as it would appear\n+in the type."}, {"sha": "d3c2178cc993fc6f66a41f25a18bae6883f67883", "filename": "src/doc/style/style/optional.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,3 @@\n+*\n+\n+*"}, {"sha": "85065406d761c7ec76deffe71400f2c2c2d2a448", "filename": "src/doc/style/style/organization.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,14 @@\n+% Organization [FIXME: needs RFC]\n+\n+> **[FIXME]** What else?\n+\n+### Reexport the most important types at the crate level.\n+\n+Crates `pub use` the most common types for convenience, so that clients do not\n+have to remember or write the crate's module hierarchy to use these types.\n+\n+### Define types and operations together.\n+\n+Type definitions and the functions/methods that operate on them should be\n+defined together in a single module, with the type appearing above the\n+functions/methods."}, {"sha": "b21b280dff0d7feb6651af866de507234b6d5a97", "filename": "src/doc/style/style/whitespace.md", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,133 @@\n+% Whitespace [FIXME: needs RFC]\n+\n+* Lines must not exceed 99 characters.\n+* Use 4 spaces for indentation, _not_ tabs.\n+* No trailing whitespace at the end of lines or files.\n+\n+### Spaces\n+\n+* Use spaces around binary operators, including the equals sign in attributes:\n+\n+``` rust\n+#[deprecated = \"Use `bar` instead.\"]\n+fn foo(a: uint, b: uint) -> uint {\n+    a + b\n+}\n+```\n+\n+* Use a space after colons and commas:\n+\n+``` rust\n+fn foo(a: Bar);\n+\n+MyStruct { foo: 3, bar: 4 }\n+\n+foo(bar, baz);\n+```\n+\n+* Use a space after the opening and before the closing brace for\n+  single line blocks or `struct` expressions:\n+\n+``` rust\n+spawn(proc() { do_something(); })\n+\n+Point { x: 0.1, y: 0.3 }\n+```\n+\n+### Line wrapping\n+\n+* For multiline function signatures, each new line should align with the\n+  first parameter. Multiple parameters per line are permitted:\n+\n+``` rust\n+fn frobnicate(a: Bar, b: Bar,\n+              c: Bar, d: Bar)\n+              -> Bar {\n+    ...\n+}\n+\n+fn foo<T: This,\n+       U: That>(\n+       a: Bar,\n+       b: Bar)\n+       -> Baz {\n+    ...\n+}\n+```\n+\n+* Multiline function invocations generally follow the same rule as for\n+  signatures. However, if the final argument begins a new block, the\n+  contents of the block may begin on a new line, indented one level:\n+\n+``` rust\n+fn foo_bar(a: Bar, b: Bar,\n+           c: |Bar|) -> Bar {\n+    ...\n+}\n+\n+// Same line is fine:\n+foo_bar(x, y, |z| { z.transpose(y) });\n+\n+// Indented body on new line is also fine:\n+foo_bar(x, y, |z| {\n+    z.quux();\n+    z.rotate(x)\n+})\n+```\n+\n+> **[FIXME]** Do we also want to allow the following?\n+>\n+> ```rust\n+> frobnicate(\n+>     arg1,\n+>     arg2,\n+>     arg3)\n+> ```\n+>\n+> This style could ease the conflict between line length and functions\n+> with many parameters (or long method chains).\n+\n+### Matches\n+\n+> * **[Deprecated]** If you have multiple patterns in a single `match`\n+>   arm, write each pattern on a separate line:\n+>\n+>     ``` rust\n+>     match foo {\n+>         bar(_)\n+>         | baz => quux,\n+>         x\n+>         | y\n+>         | z => {\n+>             quuux\n+>         }\n+>     }\n+>     ```\n+\n+### Alignment\n+\n+Idiomatic code should not use extra whitespace in the middle of a line\n+to provide alignment.\n+\n+\n+``` rust\n+// Good\n+struct Foo {\n+    short: f64,\n+    really_long: f64,\n+}\n+\n+// Bad\n+struct Bar {\n+    short:       f64,\n+    really_long: f64,\n+}\n+\n+// Good\n+let a = 0;\n+let radius = 7;\n+\n+// Bad\n+let b        = 0;\n+let diameter = 7;\n+```"}, {"sha": "a21f69414d326b15cb1a617ebba77a1b23807dc4", "filename": "src/doc/style/testing/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,5 @@\n+% Testing\n+\n+> **[FIXME]** Add some general remarks about when and how to unit\n+> test, versus other kinds of testing. What are our expectations for\n+> Rust's core libraries?"}, {"sha": "813660d8fdfb945e90196b3c5518d27688e71ce3", "filename": "src/doc/style/testing/unit.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,30 @@\n+% Unit testing\n+\n+Unit tests should live in a `test` submodule at the bottom of the module they\n+test. Mark the `test` submodule with `#[cfg(test)]` so it is only compiled when\n+testing.\n+\n+The `test` module should contain:\n+\n+* Imports needed only for testing.\n+* Functions marked with `#[test]` striving for full coverage of the parent module's\n+  definitions.\n+* Auxiliary functions needed for writing the tests.\n+\n+For example:\n+\n+``` rust\n+// Excerpt from std::str\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_eq() {\n+        assert!((eq(&\"\".to_owned(), &\"\".to_owned())));\n+        assert!((eq(&\"foo\".to_owned(), &\"foo\".to_owned())));\n+        assert!((!eq(&\"foo\".to_owned(), &\"bar\".to_owned())));\n+    }\n+}\n+```\n+\n+> **[FIXME]** add details about useful macros for testing, e.g. `assert!`"}, {"sha": "28ef2a1832d8bf175682a7709ba6409ae1ec0ea7", "filename": "src/doc/style/todo.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftodo.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c/src%2Fdoc%2Fstyle%2Ftodo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftodo.md?ref=25ccf3c0daab3cbd2e49f13c89f35ed9f382dc5c", "patch": "@@ -0,0 +1,5 @@\n+* [Containers and iteration]()\n+* [The visitor pattern]()\n+* [Concurrency]()\n+* [Documentation]()\n+* [Macros]()"}]}