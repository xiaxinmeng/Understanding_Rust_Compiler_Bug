{"sha": "374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NGE4MGE4NmRlNGRhYmFlNDk3NWZhZTA0ZmI2N2NjNmU2ZGMwYmI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-07T15:29:22Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:57Z"}, "message": "expand: It's always possible to create a dummy AST fragment\n\nRemove a bunch of `Option`s that assumed that dummy fragment creation could fail.\n\nThe test output changed due to not performing the expansion in `fn expand_invoc` in case of the recursion limit hit.", "tree": {"sha": "8b508ec646b7e2bd8e3bc502ce1a96d6fbb20b35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b508ec646b7e2bd8e3bc502ce1a96d6fbb20b35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "html_url": "https://github.com/rust-lang/rust/commit/374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/374a80a86de4dabae4975fae04fb67cc6e6dc0bb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac900ac87828d6a4813f0c4a870bcdb439d1175", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac900ac87828d6a4813f0c4a870bcdb439d1175", "html_url": "https://github.com/rust-lang/rust/commit/eac900ac87828d6a4813f0c4a870bcdb439d1175"}], "stats": {"total": 85, "additions": 39, "deletions": 46}, "files": [{"sha": "85a31b8b7e853f45b3a4dc420fd528aed01b46d9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/374a80a86de4dabae4975fae04fb67cc6e6dc0bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374a80a86de4dabae4975fae04fb67cc6e6dc0bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "patch": "@@ -158,8 +158,8 @@ ast_fragments! {\n }\n \n impl AstFragmentKind {\n-    fn dummy(self, span: Span) -> Option<AstFragment> {\n-        self.make_from(DummyResult::any(span))\n+    fn dummy(self, span: Span) -> AstFragment {\n+        self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I)\n@@ -327,10 +327,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let (invoc_fragment_kind, invoc_span) = (invoc.fragment_kind, invoc.span());\n-                let fragment = self.expand_invoc(invoc, &ext).unwrap_or_else(|| {\n-                    invoc_fragment_kind.dummy(invoc_span).unwrap()\n-                });\n+                let fragment = self.expand_invoc(invoc, &ext);\n                 self.collect_invocations(fragment, &[])\n             } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n                 if !item.derive_allowed() {\n@@ -477,7 +474,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> AstFragment {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern() {\n             if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n@@ -487,12 +484,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         }\n \n-        let result = match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n-            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext)?,\n-        };\n-\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             let info = self.cx.current_expansion.mark.expn_info().unwrap();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n@@ -507,15 +498,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             FatalError.raise();\n         }\n \n-        Some(result)\n+        match invoc.kind {\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n+        }\n     }\n \n     fn expand_attr_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<AstFragment> {\n+                         -> AstFragment {\n         let (attr, mut item) = match invoc.kind {\n-            InvocationKind::Attr { attr, item, .. } => (attr?, item),\n+            InvocationKind::Attr { attr: Some(attr), item, .. } => (attr, item),\n             _ => unreachable!(),\n         };\n \n@@ -526,13 +521,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     attr::mark_used(&attr);\n                 }\n                 item.visit_attrs(|attrs| attrs.push(attr));\n-                Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n+                invoc.fragment_kind.expect_from_annotatables(iter::once(item))\n             }\n             SyntaxExtensionKind::LegacyAttr(expander) => {\n-                let meta = attr.parse_meta(self.cx.parse_sess)\n-                               .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = expander.expand(self.cx, attr.span, &meta, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(item))\n+                match attr.parse_meta(self.cx.parse_sess) {\n+                    Ok(meta) => {\n+                        let item = expander.expand(self.cx, attr.span, &meta, item);\n+                        invoc.fragment_kind.expect_from_annotatables(item)\n+                    }\n+                    Err(mut err) => {\n+                        err.emit();\n+                        invoc.fragment_kind.dummy(attr.span)\n+                    }\n+                }\n             }\n             SyntaxExtensionKind::Attr(expander) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n@@ -598,14 +599,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn gate_proc_macro_expansion(&self, span: Span, fragment: &Option<AstFragment>) {\n+    fn gate_proc_macro_expansion(&self, span: Span, fragment: &AstFragment) {\n         if self.cx.ecfg.proc_macro_hygiene() {\n             return\n         }\n-        let fragment = match fragment {\n-            Some(fragment) => fragment,\n-            None => return,\n-        };\n \n         fragment.visit_with(&mut DisallowMacros {\n             span,\n@@ -641,15 +638,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_bang_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<AstFragment> {\n+                         -> AstFragment {\n         let kind = invoc.fragment_kind;\n         let (mac, span) = match invoc.kind {\n             InvocationKind::Bang { mac, span } => (mac, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n-        let opt_expanded = match &ext.kind {\n+        match &ext.kind {\n             SyntaxExtensionKind::Bang(expander) => {\n                 self.gate_proc_macro_expansion_kind(span, kind);\n                 let tok_result = expander.expand(self.cx, span, mac.node.stream());\n@@ -659,19 +656,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             SyntaxExtensionKind::LegacyBang(expander) => {\n                 let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                kind.make_from(tok_result)\n+                if let Some(result) = kind.make_from(tok_result) {\n+                    result\n+                } else {\n+                    let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n+                                    name = path.segments[0].ident.name, kind = kind.name());\n+                    self.cx.span_err(path.span, &msg);\n+                    self.cx.trace_macros_diag();\n+                    kind.dummy(span)\n+                }\n             }\n             _ => unreachable!()\n-        };\n-\n-        if opt_expanded.is_some() {\n-            opt_expanded\n-        } else {\n-            let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                              name = path.segments[0].ident.name, kind = kind.name());\n-            self.cx.span_err(path.span, &msg);\n-            self.cx.trace_macros_diag();\n-            kind.dummy(span)\n         }\n     }\n \n@@ -703,7 +698,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_derive_invoc(&mut self,\n                            invoc: Invocation,\n                            ext: &SyntaxExtension)\n-                           -> Option<AstFragment> {\n+                           -> AstFragment {\n         let (path, item) = match invoc.kind {\n             InvocationKind::Derive { path, item, item_with_markers } => match ext.kind {\n                 SyntaxExtensionKind::LegacyDerive(..) => (path, item_with_markers),\n@@ -712,7 +707,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n         if !item.derive_allowed() {\n-            return None;\n+            return invoc.fragment_kind.dummy(path.span);\n         }\n \n         match &ext.kind {\n@@ -721,7 +716,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n                 let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n+                invoc.fragment_kind.expect_from_annotatables(items)\n             }\n             _ => unreachable!()\n         }\n@@ -732,12 +727,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                           kind: AstFragmentKind,\n                           path: &Path,\n                           span: Span)\n-                          -> Option<AstFragment> {\n+                          -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         match parser.parse_ast_fragment(kind, false) {\n             Ok(fragment) => {\n                 parser.ensure_complete_parse(path, kind.name(), span);\n-                Some(fragment)\n+                fragment\n             }\n             Err(mut err) => {\n                 err.set_span(span);"}, {"sha": "fc05012377b2a33121d58da57683f772b1d399d9", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/374a80a86de4dabae4975fae04fb67cc6e6dc0bb/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/374a80a86de4dabae4975fae04fb67cc6e6dc0bb/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "patch": "@@ -45,8 +45,6 @@ LL |     my_recursive_macro!();\n    = note: to `my_recursive_macro ! (  ) ;`\n    = note: expanding `my_recursive_macro! {  }`\n    = note: to `my_recursive_macro ! (  ) ;`\n-   = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n \n error: aborting due to 2 previous errors\n "}]}