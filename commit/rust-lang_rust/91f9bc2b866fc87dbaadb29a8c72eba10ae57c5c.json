{"sha": "91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZjliYzJiODY2ZmM4N2RiYWFkYjI5YThjNzJlYmExMGFlNTdjNWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-07T13:42:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-07T13:42:56Z"}, "message": "Refactor xtasks", "tree": {"sha": "685e2dc2f1e02aadbcd94de5076692a56a09a475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/685e2dc2f1e02aadbcd94de5076692a56a09a475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "html_url": "https://github.com/rust-lang/rust/commit/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b02576d5623478526328b4716b1fd9c5c2efd637", "url": "https://api.github.com/repos/rust-lang/rust/commits/b02576d5623478526328b4716b1fd9c5c2efd637", "html_url": "https://github.com/rust-lang/rust/commit/b02576d5623478526328b4716b1fd9c5c2efd637"}], "stats": {"total": 571, "additions": 290, "deletions": 281}, "files": [{"sha": "9c78ba37fa9a5cf500c2ee02e936cc30e858921b", "filename": "xtask/src/help.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b02576d5623478526328b4716b1fd9c5c2efd637/xtask%2Fsrc%2Fhelp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b02576d5623478526328b4716b1fd9c5c2efd637/xtask%2Fsrc%2Fhelp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fhelp.rs?ref=b02576d5623478526328b4716b1fd9c5c2efd637", "patch": "@@ -1,33 +0,0 @@\n-//! FIXME: write short doc here\n-\n-pub const GLOBAL_HELP: &str = \"tasks\n-\n-USAGE:\n-    ra_tools <SUBCOMMAND>\n-\n-FLAGS:\n-    -h, --help       Prints help information\n-\n-SUBCOMMANDS:\n-    format\n-    install-pre-commit-hook\n-    fuzz-tests\n-    codegen\n-    install\n-    lint\";\n-\n-pub const INSTALL_HELP: &str = \"ra_tools-install\n-\n-USAGE:\n-    ra_tools.exe install [FLAGS]\n-\n-FLAGS:\n-        --client-code\n-    -h, --help           Prints help information\n-        --jemalloc\n-        --server\";\n-\n-pub const INSTALL_RA_CONFLICT: &str =\n-    \"error: The argument `--server` cannot be used with `--client-code`\n-\n-For more information try --help\";"}, {"sha": "ab6ed92f73b3ac9b50ba0726190aeca88e500178", "filename": "xtask/src/install.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Finstall.rs?ref=91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "patch": "@@ -0,0 +1,178 @@\n+//! Installs rust-analyzer langauge server and/or editor plugin.\n+\n+use std::{env, path::PathBuf, str};\n+\n+use anyhow::{Context, Result};\n+\n+use crate::{run, run_with_output, Cmd};\n+\n+// Latest stable, feel free to send a PR if this lags behind.\n+const REQUIRED_RUST_VERSION: u32 = 40;\n+\n+pub struct InstallCmd {\n+    pub client: Option<ClientOpt>,\n+    pub server: Option<ServerOpt>,\n+}\n+\n+pub enum ClientOpt {\n+    VsCode,\n+}\n+\n+pub struct ServerOpt {\n+    pub jemalloc: bool,\n+}\n+\n+impl InstallCmd {\n+    pub fn run(self) -> Result<()> {\n+        if cfg!(target_os = \"macos\") {\n+            fix_path_for_mac().context(\"Fix path for mac\")?\n+        }\n+        if let Some(server) = self.server {\n+            install_server(server).context(\"install server\")?;\n+        }\n+        if let Some(client) = self.client {\n+            install_client(client).context(\"install client\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn fix_path_for_mac() -> Result<()> {\n+    let mut vscode_path: Vec<PathBuf> = {\n+        const COMMON_APP_PATH: &str =\n+            r\"/Applications/Visual Studio Code.app/Contents/Resources/app/bin\";\n+        const ROOT_DIR: &str = \"\";\n+        let home_dir = match env::var(\"HOME\") {\n+            Ok(home) => home,\n+            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n+        };\n+\n+        [ROOT_DIR, &home_dir]\n+            .iter()\n+            .map(|dir| String::from(*dir) + COMMON_APP_PATH)\n+            .map(PathBuf::from)\n+            .filter(|path| path.exists())\n+            .collect()\n+    };\n+\n+    if !vscode_path.is_empty() {\n+        let vars = match env::var_os(\"PATH\") {\n+            Some(path) => path,\n+            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n+        };\n+\n+        let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n+        paths.append(&mut vscode_path);\n+        let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n+        env::set_var(\"PATH\", &new_paths);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n+    let npm_version = Cmd {\n+        unix: r\"npm --version\",\n+        windows: r\"cmd.exe /c npm --version\",\n+        work_dir: \"./editors/code\",\n+    }\n+    .run();\n+\n+    if npm_version.is_err() {\n+        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n+    }\n+\n+    Cmd { unix: r\"npm install\", windows: r\"cmd.exe /c npm install\", work_dir: \"./editors/code\" }\n+        .run()?;\n+    Cmd {\n+        unix: r\"npm run package --scripts-prepend-node-path\",\n+        windows: r\"cmd.exe /c npm run package\",\n+        work_dir: \"./editors/code\",\n+    }\n+    .run()?;\n+\n+    let code_binary = [\"code\", \"code-insiders\", \"codium\"].iter().find(|bin| {\n+        Cmd {\n+            unix: &format!(\"{} --version\", bin),\n+            windows: &format!(\"cmd.exe /c {}.cmd --version\", bin),\n+            work_dir: \"./editors/code\",\n+        }\n+        .run()\n+        .is_ok()\n+    });\n+\n+    let code_binary = match code_binary {\n+        Some(it) => it,\n+        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n+    };\n+\n+    Cmd {\n+        unix: &format!(r\"{} --install-extension ./ra-lsp-0.0.1.vsix --force\", code_binary),\n+        windows: &format!(\n+            r\"cmd.exe /c {}.cmd --install-extension ./ra-lsp-0.0.1.vsix --force\",\n+            code_binary\n+        ),\n+        work_dir: \"./editors/code\",\n+    }\n+    .run()?;\n+\n+    let output = Cmd {\n+        unix: &format!(r\"{} --list-extensions\", code_binary),\n+        windows: &format!(r\"cmd.exe /c {}.cmd --list-extensions\", code_binary),\n+        work_dir: \".\",\n+    }\n+    .run_with_output()?;\n+\n+    if !str::from_utf8(&output.stdout)?.contains(\"ra-lsp\") {\n+        anyhow::bail!(\n+            \"Could not install the Visual Studio Code extension. \\\n+             Please make sure you have at least NodeJS 10.x together with the latest version of VS Code installed and try again.\"\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+fn install_server(opts: ServerOpt) -> Result<()> {\n+    let mut old_rust = false;\n+    if let Ok(output) = run_with_output(\"cargo --version\", \".\") {\n+        if let Ok(stdout) = String::from_utf8(output.stdout) {\n+            println!(\"{}\", stdout);\n+            if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n+                old_rust = true;\n+            }\n+        }\n+    }\n+\n+    if old_rust {\n+        eprintln!(\n+            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n+            REQUIRED_RUST_VERSION,\n+        )\n+    }\n+\n+    let res = if opts.jemalloc {\n+        run(\"cargo install --path crates/ra_lsp_server --locked --force --features jemalloc\", \".\")\n+    } else {\n+        run(\"cargo install --path crates/ra_lsp_server --locked --force\", \".\")\n+    };\n+\n+    if res.is_err() && old_rust {\n+        eprintln!(\n+            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n+            REQUIRED_RUST_VERSION,\n+        )\n+    }\n+\n+    res\n+}\n+\n+fn check_version(version_output: &str, min_minor_version: u32) -> bool {\n+    // Parse second the number out of\n+    //      cargo 1.39.0-beta (1c6ec66d5 2019-09-30)\n+    let minor: Option<u32> = version_output.split('.').nth(1).and_then(|it| it.parse().ok());\n+    match minor {\n+        None => true,\n+        Some(minor) => minor >= min_minor_version,\n+    }\n+}"}, {"sha": "fb853e71a884a4da56b18b106203c1cf311ca2c6", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "patch": "@@ -1,13 +1,14 @@\n //! FIXME: write short doc here\n \n pub mod codegen;\n+pub mod install;\n+pub mod pre_commit;\n mod ast_src;\n \n use anyhow::Context;\n pub use anyhow::Result;\n use std::{\n-    env, fs,\n-    io::{Error as IoError, ErrorKind},\n+    env,\n     path::{Path, PathBuf},\n     process::{Command, Output, Stdio},\n };\n@@ -79,23 +80,11 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     Ok(())\n }\n \n-pub fn install_rustfmt() -> Result<()> {\n+fn install_rustfmt() -> Result<()> {\n     run(&format!(\"rustup toolchain install {}\", TOOLCHAIN), \".\")?;\n     run(&format!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN), \".\")\n }\n \n-pub fn install_pre_commit_hook() -> Result<()> {\n-    let result_path =\n-        PathBuf::from(format!(\"./.git/hooks/pre-commit{}\", std::env::consts::EXE_SUFFIX));\n-    if !result_path.exists() {\n-        let me = std::env::current_exe()?;\n-        fs::copy(me, result_path)?;\n-    } else {\n-        Err(IoError::new(ErrorKind::AlreadyExists, \"Git hook already created\"))?;\n-    }\n-    Ok(())\n-}\n-\n pub fn run_clippy() -> Result<()> {\n     match Command::new(\"rustup\")\n         .args(&[\"run\", TOOLCHAIN, \"--\", \"cargo\", \"clippy\", \"--version\"])\n@@ -144,28 +133,6 @@ pub fn run_fuzzer() -> Result<()> {\n     run(\"rustup run nightly -- cargo fuzz run parser\", \"./crates/ra_syntax\")\n }\n \n-pub fn reformat_staged_files() -> Result<()> {\n-    run_rustfmt(Mode::Overwrite)?;\n-    let root = project_root();\n-    let output = Command::new(\"git\")\n-        .arg(\"diff\")\n-        .arg(\"--diff-filter=MAR\")\n-        .arg(\"--name-only\")\n-        .arg(\"--cached\")\n-        .current_dir(&root)\n-        .output()?;\n-    if !output.status.success() {\n-        anyhow::bail!(\n-            \"`git diff --diff-filter=MAR --name-only --cached` exited with {}\",\n-            output.status\n-        );\n-    }\n-    for line in String::from_utf8(output.stdout)?.lines() {\n-        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n-    }\n-    Ok(())\n-}\n-\n fn do_run<F>(cmdline: &str, dir: &str, mut f: F) -> Result<Output>\n where\n     F: FnMut(&mut Command),"}, {"sha": "9309b2fbd57fbd247af17cbfc4fa1cf9e537ca03", "filename": "xtask/src/main.rs", "status": "modified", "additions": 72, "deletions": 211, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "patch": "@@ -7,244 +7,105 @@\n //!\n //! This binary is integrated into the `cargo` command line by using an alias in\n //! `.cargo/config`.\n-mod help;\n \n-use std::{env, fmt::Write, path::PathBuf, str};\n+use std::env;\n \n-use anyhow::Context;\n use pico_args::Arguments;\n use xtask::{\n     codegen::{self, Mode},\n-    install_pre_commit_hook, reformat_staged_files, run, run_clippy, run_fuzzer, run_rustfmt,\n-    run_with_output, Cmd, Result,\n+    install::{ClientOpt, InstallCmd, ServerOpt},\n+    pre_commit, run_clippy, run_fuzzer, run_rustfmt, Result,\n };\n \n-// Latest stable, feel free to send a PR if this lags behind.\n-const REQUIRED_RUST_VERSION: u32 = 40;\n-\n-struct InstallOpt {\n-    client: Option<ClientOpt>,\n-    server: Option<ServerOpt>,\n-}\n-\n-enum ClientOpt {\n-    VsCode,\n-}\n-\n-struct ServerOpt {\n-    jemalloc: bool,\n-}\n-\n fn main() -> Result<()> {\n     if env::args().next().map(|it| it.contains(\"pre-commit\")) == Some(true) {\n-        return reformat_staged_files();\n+        return pre_commit::run_hook();\n     }\n \n-    let subcommand = match std::env::args_os().nth(1) {\n-        None => {\n-            eprintln!(\"{}\", help::GLOBAL_HELP);\n-            return Ok(());\n-        }\n-        Some(s) => s,\n-    };\n-    let mut matches = Arguments::from_vec(std::env::args_os().skip(2).collect());\n-    let subcommand = &*subcommand.to_string_lossy();\n-    match subcommand {\n+    let subcommand = std::env::args().nth(1).unwrap_or_default();\n+    let mut args = Arguments::from_vec(std::env::args_os().skip(2).collect());\n+\n+    match subcommand.as_str() {\n         \"install\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                eprintln!(\"{}\", help::INSTALL_HELP);\n+            if args.contains([\"-h\", \"--help\"]) {\n+                eprintln!(\n+                    \"\\\n+cargo xtask install\n+Install rust-analyzer server or editor plugin.\n+\n+USAGE:\n+    cargo xtask install [FLAGS]\n+\n+FLAGS:\n+        --client-code    Install only VS Code plugin\n+        --server         Install only the language server\n+        --jemalloc       Use jemalloc for server\n+    -h, --help           Prints help information\n+        \"\n+                );\n                 return Ok(());\n             }\n-            let server = matches.contains(\"--server\");\n-            let client_code = matches.contains(\"--client-code\");\n+            let server = args.contains(\"--server\");\n+            let client_code = args.contains(\"--client-code\");\n             if server && client_code {\n-                eprintln!(\"{}\", help::INSTALL_RA_CONFLICT);\n+                eprintln!(\n+                    \"error: The argument `--server` cannot be used with `--client-code`\\n\\n\\\n+                     For more information try --help\"\n+                );\n                 return Ok(());\n             }\n-            let jemalloc = matches.contains(\"--jemalloc\");\n-            matches.finish().or_else(handle_extra_flags)?;\n-            let opts = InstallOpt {\n+\n+            let jemalloc = args.contains(\"--jemalloc\");\n+\n+            args.finish()?;\n+\n+            InstallCmd {\n                 client: if server { None } else { Some(ClientOpt::VsCode) },\n                 server: if client_code { None } else { Some(ServerOpt { jemalloc }) },\n-            };\n-            install(opts)?\n+            }\n+            .run()\n         }\n         \"codegen\" => {\n+            args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n+            Ok(())\n         }\n-        \"format\" => run_rustfmt(Mode::Overwrite)?,\n-        \"install-pre-commit-hook\" => install_pre_commit_hook()?,\n-        \"lint\" => run_clippy()?,\n-        \"fuzz-tests\" => run_fuzzer()?,\n-        _ => eprintln!(\"{}\", help::GLOBAL_HELP),\n-    }\n-    Ok(())\n-}\n-\n-fn handle_extra_flags(e: pico_args::Error) -> Result<()> {\n-    if let pico_args::Error::UnusedArgsLeft(flags) = e {\n-        let mut invalid_flags = String::new();\n-        for flag in flags {\n-            write!(&mut invalid_flags, \"{}, \", flag)?;\n+        \"format\" => {\n+            args.finish()?;\n+            run_rustfmt(Mode::Overwrite)\n         }\n-        let (invalid_flags, _) = invalid_flags.split_at(invalid_flags.len() - 2);\n-        anyhow::bail!(\"Invalid flags: {}\", invalid_flags)\n-    } else {\n-        anyhow::bail!(e.to_string())\n-    }\n-}\n-\n-fn install(opts: InstallOpt) -> Result<()> {\n-    if cfg!(target_os = \"macos\") {\n-        fix_path_for_mac().context(\"Fix path for mac\")?\n-    }\n-    if let Some(server) = opts.server {\n-        install_server(server).context(\"install server\")?;\n-    }\n-    if let Some(client) = opts.client {\n-        install_client(client).context(\"install client\")?;\n-    }\n-    Ok(())\n-}\n-\n-fn fix_path_for_mac() -> Result<()> {\n-    let mut vscode_path: Vec<PathBuf> = {\n-        const COMMON_APP_PATH: &str =\n-            r\"/Applications/Visual Studio Code.app/Contents/Resources/app/bin\";\n-        const ROOT_DIR: &str = \"\";\n-        let home_dir = match env::var(\"HOME\") {\n-            Ok(home) => home,\n-            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n-        };\n-\n-        [ROOT_DIR, &home_dir]\n-            .iter()\n-            .map(|dir| String::from(*dir) + COMMON_APP_PATH)\n-            .map(PathBuf::from)\n-            .filter(|path| path.exists())\n-            .collect()\n-    };\n-\n-    if !vscode_path.is_empty() {\n-        let vars = match env::var_os(\"PATH\") {\n-            Some(path) => path,\n-            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n-        };\n-\n-        let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n-        paths.append(&mut vscode_path);\n-        let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n-        env::set_var(\"PATH\", &new_paths);\n-    }\n-\n-    Ok(())\n-}\n-\n-fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n-    let npm_version = Cmd {\n-        unix: r\"npm --version\",\n-        windows: r\"cmd.exe /c npm --version\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run();\n-\n-    if npm_version.is_err() {\n-        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n-    }\n-\n-    Cmd { unix: r\"npm install\", windows: r\"cmd.exe /c npm install\", work_dir: \"./editors/code\" }\n-        .run()?;\n-    Cmd {\n-        unix: r\"npm run package --scripts-prepend-node-path\",\n-        windows: r\"cmd.exe /c npm run package\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n-\n-    let code_binary = [\"code\", \"code-insiders\", \"codium\"].iter().find(|bin| {\n-        Cmd {\n-            unix: &format!(\"{} --version\", bin),\n-            windows: &format!(\"cmd.exe /c {}.cmd --version\", bin),\n-            work_dir: \"./editors/code\",\n+        \"install-pre-commit-hook\" => {\n+            args.finish()?;\n+            pre_commit::install_hook()\n         }\n-        .run()\n-        .is_ok()\n-    });\n-\n-    let code_binary = match code_binary {\n-        Some(it) => it,\n-        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n-    };\n-\n-    Cmd {\n-        unix: &format!(r\"{} --install-extension ./ra-lsp-0.0.1.vsix --force\", code_binary),\n-        windows: &format!(\n-            r\"cmd.exe /c {}.cmd --install-extension ./ra-lsp-0.0.1.vsix --force\",\n-            code_binary\n-        ),\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n-\n-    let output = Cmd {\n-        unix: &format!(r\"{} --list-extensions\", code_binary),\n-        windows: &format!(r\"cmd.exe /c {}.cmd --list-extensions\", code_binary),\n-        work_dir: \".\",\n-    }\n-    .run_with_output()?;\n-\n-    if !str::from_utf8(&output.stdout)?.contains(\"ra-lsp\") {\n-        anyhow::bail!(\n-            \"Could not install the Visual Studio Code extension. \\\n-             Please make sure you have at least NodeJS 10.x together with the latest version of VS Code installed and try again.\"\n-        );\n-    }\n-\n-    Ok(())\n-}\n-\n-fn install_server(opts: ServerOpt) -> Result<()> {\n-    let mut old_rust = false;\n-    if let Ok(output) = run_with_output(\"cargo --version\", \".\") {\n-        if let Ok(stdout) = String::from_utf8(output.stdout) {\n-            println!(\"{}\", stdout);\n-            if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n-                old_rust = true;\n-            }\n+        \"lint\" => {\n+            args.finish()?;\n+            run_clippy()\n+        }\n+        \"fuzz-tests\" => {\n+            args.finish()?;\n+            run_fuzzer()\n+        }\n+        _ => {\n+            eprintln!(\n+                \"\\\n+cargo xtask\n+Run custom build command.\n+\n+USAGE:\n+    cargo xtask <SUBCOMMAND>\n+\n+SUBCOMMANDS:\n+    format\n+    install-pre-commit-hook\n+    fuzz-tests\n+    codegen\n+    install\n+    lint\"\n+            );\n+            Ok(())\n         }\n-    }\n-\n-    if old_rust {\n-        eprintln!(\n-            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION,\n-        )\n-    }\n-\n-    let res = if opts.jemalloc {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force --features jemalloc\", \".\")\n-    } else {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force\", \".\")\n-    };\n-\n-    if res.is_err() && old_rust {\n-        eprintln!(\n-            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION,\n-        )\n-    }\n-\n-    res\n-}\n-\n-fn check_version(version_output: &str, min_minor_version: u32) -> bool {\n-    // Parse second the number out of\n-    //      cargo 1.39.0-beta (1c6ec66d5 2019-09-30)\n-    let minor: Option<u32> = version_output.split('.').nth(1).and_then(|it| it.parse().ok());\n-    match minor {\n-        None => true,\n-        Some(minor) => minor >= min_minor_version,\n     }\n }"}, {"sha": "7984ba9632b61385119066eea9f9d6f811503389", "filename": "xtask/src/pre_commit.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Fpre_commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c/xtask%2Fsrc%2Fpre_commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpre_commit.rs?ref=91f9bc2b866fc87dbaadb29a8c72eba10ae57c5c", "patch": "@@ -0,0 +1,36 @@\n+//! pre-commit hook for code formatting.\n+\n+use std::{fs, path::PathBuf};\n+\n+use anyhow::{bail, Result};\n+\n+use crate::{project_root, run, run_rustfmt, run_with_output, Mode};\n+\n+// FIXME: if there are changed `.ts` files, also reformat TypeScript (by\n+// shelling out to `npm fmt`).\n+pub fn run_hook() -> Result<()> {\n+    run_rustfmt(Mode::Overwrite)?;\n+\n+    let diff = run_with_output(\"git diff --diff-filter=MAR --name-only --cached\", \".\")?;\n+\n+    let root = project_root();\n+    for line in String::from_utf8(diff.stdout)?.lines() {\n+        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n+    }\n+\n+    Ok(())\n+}\n+\n+pub fn install_hook() -> Result<()> {\n+    let hook_path: PathBuf =\n+        format!(\"./.git/hooks/pre-commit{}\", std::env::consts::EXE_SUFFIX).into();\n+\n+    if hook_path.exists() {\n+        bail!(\"Git hook already created\");\n+    }\n+\n+    let me = std::env::current_exe()?;\n+    fs::copy(me, hook_path)?;\n+\n+    Ok(())\n+}"}]}