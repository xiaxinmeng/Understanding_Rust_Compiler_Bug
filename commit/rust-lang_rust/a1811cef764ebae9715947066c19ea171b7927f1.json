{"sha": "a1811cef764ebae9715947066c19ea171b7927f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExODExY2VmNzY0ZWJhZTk3MTU5NDcwNjZjMTllYTE3MWI3OTI3ZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-08T12:59:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:23Z"}, "message": "break canonicalizer into submodules to make it easier to comprehend", "tree": {"sha": "49c68b1d6370a2203ab9e43ff70486df2269540a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49c68b1d6370a2203ab9e43ff70486df2269540a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1811cef764ebae9715947066c19ea171b7927f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1811cef764ebae9715947066c19ea171b7927f1", "html_url": "https://github.com/rust-lang/rust/commit/a1811cef764ebae9715947066c19ea171b7927f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1811cef764ebae9715947066c19ea171b7927f1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9f8d5c69b3d90f84867001769a5feef538dbdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9f8d5c69b3d90f84867001769a5feef538dbdb", "html_url": "https://github.com/rust-lang/rust/commit/5e9f8d5c69b3d90f84867001769a5feef538dbdb"}], "stats": {"total": 1283, "additions": 689, "deletions": 594}, "files": [{"sha": "677063fcf881eaa288a0bad63f5ff7d2ad8329ed", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a1811cef764ebae9715947066c19ea171b7927f1", "patch": "@@ -0,0 +1,347 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains the \"canonicalizer\" itself.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::{\n+    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, CanonicalVarValues,\n+    Canonicalize,\n+};\n+use infer::InferCtxt;\n+use std::sync::atomic::Ordering;\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::Kind;\n+use ty::{self, CanonicalVar, Slice, Ty, TyCtxt, TypeFlags};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Canonicalizes a query value `V`. When we canonicalize a query,\n+    /// we not only canonicalize unbound inference variables, but we\n+    /// *also* replace all free regions whatsoever. So for example a\n+    /// query like `T: Trait<'static>` would be canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query\n+    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        self.tcx\n+            .sess\n+            .perf_stats\n+            .queries_canonicalized\n+            .fetch_add(1, Ordering::Relaxed);\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(true),\n+        )\n+    }\n+\n+    /// Canonicalizes a query *response* `V`. When we canonicalize a\n+    /// query response, we only canonicalize unbound inference\n+    /// variables, and we leave other free regions alone. So,\n+    /// continuing with the example from `canonicalize_query`, if\n+    /// there was an input query `T: Trait<'static>`, it would have\n+    /// been canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n+    /// exists only one possible impl of `Trait`, and it looks like\n+    ///\n+    ///     impl<T> Trait<'static> for T { .. }\n+    ///\n+    /// then we would prepare a query result R that (among other\n+    /// things) includes a mapping to `'?0 := 'static`. When\n+    /// canonicalizing this query result R, we would leave this\n+    /// reference to `'static` alone.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n+    pub fn canonicalize_response<V>(\n+        &self,\n+        value: &V,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(false),\n+        )\n+    }\n+}\n+\n+/// If this flag is true, then all free regions will be replaced with\n+/// a canonical var. This is used to make queries as generic as\n+/// possible. For example, the query `F: Foo<'static>` would be\n+/// canonicalized to `F: Foo<'0>`.\n+struct CanonicalizeAllFreeRegions(pub bool);\n+\n+struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n+    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    needs_canonical_flags: TypeFlags,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReVar(vid) => {\n+                let r = self\n+                    .infcx\n+                    .unwrap()\n+                    .borrow_region_constraints()\n+                    .opportunistic_resolve_var(self.tcx, vid);\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Region,\n+                };\n+                debug!(\n+                    \"canonical: region var found with vid {:?}, \\\n+                     opportunistically resolved to {:?}\",\n+                    vid, r\n+                );\n+                let cvar = self.canonical_var(info, r.into());\n+                self.tcx().mk_region(ty::ReCanonical(cvar))\n+            }\n+\n+            ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReScope(_)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased => {\n+                if self.canonicalize_all_free_regions.0 {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, r.into());\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n+                bug!(\"canonical region encountered during canonicalization\")\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+\n+            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+\n+            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"encountered a fresh type during canonicalization\")\n+            }\n+\n+            ty::TyInfer(ty::CanonicalTy(_)) => {\n+                bug!(\"encountered a canonical type during canonicalization\")\n+            }\n+\n+            ty::TyClosure(..)\n+            | ty::TyGenerator(..)\n+            | ty::TyGeneratorWitness(..)\n+            | ty::TyBool\n+            | ty::TyChar\n+            | ty::TyInt(..)\n+            | ty::TyUint(..)\n+            | ty::TyFloat(..)\n+            | ty::TyAdt(..)\n+            | ty::TyStr\n+            | ty::TyError\n+            | ty::TyArray(..)\n+            | ty::TySlice(..)\n+            | ty::TyRawPtr(..)\n+            | ty::TyRef(..)\n+            | ty::TyFnDef(..)\n+            | ty::TyFnPtr(_)\n+            | ty::TyDynamic(..)\n+            | ty::TyNever\n+            | ty::TyTuple(..)\n+            | ty::TyProjection(..)\n+            | ty::TyForeign(..)\n+            | ty::TyParam(..)\n+            | ty::TyAnon(..) => {\n+                if t.flags.intersects(self.needs_canonical_flags) {\n+                    t.super_fold_with(self)\n+                } else {\n+                    t\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+    /// The main `canonicalize` method, shared impl of\n+    /// `canonicalize_query` and `canonicalize_response`.\n+    fn canonicalize<V>(\n+        value: &V,\n+        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        debug_assert!(\n+            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            \"canonicalizing a canonical value: {:?}\",\n+            value,\n+        );\n+\n+        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n+            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n+        } else {\n+            TypeFlags::KEEP_IN_LOCAL_TCX\n+        };\n+\n+        let gcx = tcx.global_tcx();\n+\n+        // Fast path: nothing that needs to be canonicalized.\n+        if !value.has_type_flags(needs_canonical_flags) {\n+            let out_value = gcx.lift(value).unwrap();\n+            let canon_value = V::intern(\n+                gcx,\n+                Canonical {\n+                    variables: Slice::empty(),\n+                    value: out_value,\n+                },\n+            );\n+            let values = CanonicalVarValues {\n+                var_values: IndexVec::default(),\n+            };\n+            return (canon_value, values);\n+        }\n+\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            tcx,\n+            canonicalize_all_free_regions,\n+            needs_canonical_flags,\n+            variables: IndexVec::default(),\n+            indices: FxHashMap::default(),\n+            var_values: IndexVec::default(),\n+        };\n+        let out_value = value.fold_with(&mut canonicalizer);\n+\n+        // Once we have canonicalized `out_value`, it should not\n+        // contain anything that ties it to this inference context\n+        // anymore, so it should live in the global arena.\n+        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n+            bug!(\n+                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n+                out_value,\n+                value\n+            )\n+        });\n+\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+\n+        let canonical_value = V::intern(\n+            gcx,\n+            Canonical {\n+                variables: canonical_variables,\n+                value: out_value,\n+            },\n+        );\n+        let canonical_var_values = CanonicalVarValues {\n+            var_values: canonicalizer.var_values,\n+        };\n+        (canonical_value, canonical_var_values)\n+    }\n+\n+    /// Creates a canonical variable replacing `kind` from the input,\n+    /// or returns an existing variable if `kind` has already been\n+    /// seen. `kind` is expected to be an unbound variable (or\n+    /// potentially a free region).\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n+        let Canonicalizer {\n+            indices,\n+            variables,\n+            var_values,\n+            ..\n+        } = self;\n+\n+        indices\n+            .entry(kind)\n+            .or_insert_with(|| {\n+                let cvar1 = variables.push(info);\n+                let cvar2 = var_values.push(kind);\n+                assert_eq!(cvar1, cvar2);\n+                cvar1\n+            })\n+            .clone()\n+    }\n+\n+    /// Given a type variable `ty_var` of the given kind, first check\n+    /// if `ty_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `ty_var`.\n+    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n+        let bound_to = infcx.shallow_resolve(ty_var);\n+        if bound_to != ty_var {\n+            self.fold_ty(bound_to)\n+        } else {\n+            let info = CanonicalVarInfo {\n+                kind: CanonicalVarKind::Ty(ty_kind),\n+            };\n+            let cvar = self.canonical_var(info, ty_var.into());\n+            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n+        }\n+    }\n+}"}, {"sha": "037fc637ec91e167e61e31b1363826a7a04c7b1e", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 14, "deletions": 594, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=a1811cef764ebae9715947066c19ea171b7927f1", "patch": "@@ -31,20 +31,22 @@\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n-use rustc_data_structures::indexed_vec::Idx;\n+use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use serialize::UseSpecializedDecodable;\n use std::fmt::Debug;\n use std::ops::Index;\n-use std::sync::atomic::Ordering;\n use syntax::codemap::Span;\n-use traits::{Obligation, ObligationCause, PredicateObligation};\n-use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n-use ty::subst::{Kind, UnpackedKind};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::{self, CanonicalVar, Lift, Region, Slice, TyCtxt};\n+use ty::subst::Kind;\n+use ty::fold::TypeFoldable;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashMap;\n+\n+mod canonicalizer;\n+\n+mod query_result;\n+\n+mod substitute;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewriten to \"canonical vars\". These are\n@@ -66,11 +68,8 @@ impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> { }\n ///\n /// When you canonicalize a value `V`, you get back one of these\n /// vectors with the original values that were replaced by canonical\n-/// variables.\n-///\n-/// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n-/// to get back a `CanonicalVarValues` containing fresh inference\n-/// variables.\n+/// variables. You will need to supply it later to instantiate the\n+/// canonicalized query response.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n@@ -223,7 +222,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// canonical, creates fresh inference variables with the same\n     /// characteristics. You can then use `substitute` to instantiate\n     /// the canonical variable with these inference variables.\n-    pub fn fresh_inference_vars_for_canonical_vars(\n+    fn fresh_inference_vars_for_canonical_vars(\n         &self,\n         span: Span,\n         variables: &Slice<CanonicalVarInfo>,\n@@ -238,7 +237,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Given the \"info\" about a canonical variable, creates a fresh\n     /// inference variable with the same characteristics.\n-    pub fn fresh_inference_var_for_canonical_var(\n+    fn fresh_inference_var_for_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo,\n@@ -264,585 +263,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Given the (canonicalized) result to a canonical query,\n-    /// instantiates the result so it can be used, plugging in the\n-    /// values from the canonical query. (Note that the result may\n-    /// have been ambiguous; you should check the certainty level of\n-    /// the query before applying this function.)\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#processing-the-canonicalized-query-result\n-    pub fn instantiate_query_result<R>(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n-    ) -> InferResult<'tcx, R>\n-    where\n-        R: Debug + TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n-            original_values, query_result,\n-        );\n-\n-        // Every canonical query result includes values for each of\n-        // the inputs to the query. Therefore, we begin by unifying\n-        // these values with the original inputs that were\n-        // canonicalized.\n-        let result_values = &query_result.value.var_values;\n-        assert_eq!(original_values.len(), result_values.len());\n-\n-        // Quickly try to find initial values for the canonical\n-        // variables in the result in terms of the query. We do this\n-        // by iterating down the values that the query gave to each of\n-        // the canonical inputs. If we find that one of those values\n-        // is directly equal to one of the canonical variables in the\n-        // result, then we can type the corresponding value from the\n-        // input. See the example above.\n-        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n-            IndexVec::from_elem_n(None, query_result.variables.len());\n-\n-        // In terms of our example above, we are iterating over pairs like:\n-        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n-        for (original_value, result_value) in original_values.iter().zip(result_values) {\n-            match result_value.unpack() {\n-                UnpackedKind::Type(result_value) => {\n-                    // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n-                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n-                        opt_values[index] = Some(original_value);\n-                    }\n-                }\n-                UnpackedKind::Lifetime(result_value) => {\n-                    // e.g., here `result_value` might be `'?1` in the example above...\n-                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n-                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n-                        opt_values[index] = Some(original_value);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Create a result substitution: if we found a value for a\n-        // given variable in the loop above, use that. Otherwise, use\n-        // a fresh inference variable.\n-        let result_subst = &CanonicalVarValues {\n-            var_values: query_result\n-                .variables\n-                .iter()\n-                .enumerate()\n-                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n-                    Some(k) => k,\n-                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n-                })\n-                .collect(),\n-        };\n-\n-        // Unify the original values for the canonical variables in\n-        // the input with the value found in the query\n-        // post-substitution. Often, but not always, this is a no-op,\n-        // because we already found the mapping in the first step.\n-        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n-            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n-        };\n-        let mut obligations =\n-            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n-                .into_obligations();\n-\n-        obligations.extend(self.query_region_constraints_into_obligations(\n-            cause,\n-            param_env,\n-            &query_result.value.region_constraints,\n-            result_subst,\n-        ));\n-\n-        let user_result: R =\n-            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n-\n-        Ok(InferOk {\n-            value: user_result,\n-            obligations,\n-        })\n-    }\n-\n-    /// Converts the region constraints resulting from a query into an\n-    /// iterator of obligations.\n-    fn query_region_constraints_into_obligations<'a>(\n-        &'a self,\n-        cause: &'a ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n-        result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n-        Box::new(unsubstituted_region_constraints.iter().map(move |constraint| {\n-            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n-            let k1 = substitute_value(self.tcx, result_subst, k1);\n-            let r2 = substitute_value(self.tcx, result_subst, r2);\n-            match k1.unpack() {\n-                UnpackedKind::Lifetime(r1) =>\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        ty::Predicate::RegionOutlives(\n-                            ty::Binder::dummy(ty::OutlivesPredicate(r1, r2))),\n-                    ),\n-\n-                UnpackedKind::Type(t1) =>\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        ty::Predicate::TypeOutlives(\n-                            ty::Binder::dummy(ty::OutlivesPredicate(t1, r2))),\n-                    ),\n-            }\n-        })) as Box<dyn Iterator<Item = _>>\n-    }\n-\n-    /// Given two sets of values for the same set of canonical variables, unify them.\n-    /// The second set is produced lazilly by supplying indices from the first set.\n-    fn unify_canonical_vars(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        variables1: &CanonicalVarValues<'tcx>,\n-        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        self.commit_if_ok(|_| {\n-            let mut obligations = vec![];\n-            for (index, value1) in variables1.var_values.iter_enumerated() {\n-                let value2 = variables2(index);\n-\n-                match (value1.unpack(), value2.unpack()) {\n-                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n-                    }\n-                    (\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                    ) => {\n-                        // no action needed\n-                    }\n-                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n-                    }\n-                    _ => {\n-                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n-                    }\n-                }\n-            }\n-            Ok(InferOk {\n-                value: (),\n-                obligations,\n-            })\n-        })\n-    }\n-\n-    /// Canonicalizes a query value `V`. When we canonicalize a query,\n-    /// we not only canonicalize unbound inference variables, but we\n-    /// *also* replace all free regions whatsoever. So for example a\n-    /// query like `T: Trait<'static>` would be canonicalized to\n-    ///\n-    /// ```text\n-    /// T: Trait<'?0>\n-    /// ```\n-    ///\n-    /// with a mapping M that maps `'?0` to `'static`.\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query\n-    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n-\n-        Canonicalizer::canonicalize(\n-            value,\n-            Some(self),\n-            self.tcx,\n-            CanonicalizeAllFreeRegions(true),\n-        )\n-    }\n-\n-    /// Canonicalizes a query *response* `V`. When we canonicalize a\n-    /// query response, we only canonicalize unbound inference\n-    /// variables, and we leave other free regions alone. So,\n-    /// continuing with the example from `canonicalize_query`, if\n-    /// there was an input query `T: Trait<'static>`, it would have\n-    /// been canonicalized to\n-    ///\n-    /// ```text\n-    /// T: Trait<'?0>\n-    /// ```\n-    ///\n-    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n-    /// exists only one possible impl of `Trait`, and it looks like\n-    ///\n-    ///     impl<T> Trait<'static> for T { .. }\n-    ///\n-    /// then we would prepare a query result R that (among other\n-    /// things) includes a mapping to `'?0 := 'static`. When\n-    /// canonicalizing this query result R, we would leave this\n-    /// reference to `'static` alone.\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(\n-        &self,\n-        value: &V,\n-    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        Canonicalizer::canonicalize(\n-            value,\n-            Some(self),\n-            self.tcx,\n-            CanonicalizeAllFreeRegions(false),\n-        )\n-    }\n-}\n-\n-/// If this flag is true, then all free regions will be replaced with\n-/// a canonical var. This is used to make queries as generic as\n-/// possible. For example, the query `F: Foo<'static>` would be\n-/// canonicalized to `F: Foo<'0>`.\n-struct CanonicalizeAllFreeRegions(bool);\n-\n-struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n-    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n-    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n-    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n-    needs_canonical_flags: TypeFlags,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReLateBound(..) => {\n-                // leave bound regions alone\n-                r\n-            }\n-\n-            ty::ReVar(vid) => {\n-                let r = self.infcx\n-                    .unwrap()\n-                    .borrow_region_constraints()\n-                    .opportunistic_resolve_var(self.tcx, vid);\n-                let info = CanonicalVarInfo {\n-                    kind: CanonicalVarKind::Region,\n-                };\n-                debug!(\n-                    \"canonical: region var found with vid {:?}, \\\n-                     opportunistically resolved to {:?}\",\n-                    vid, r\n-                );\n-                let cvar = self.canonical_var(info, r.into());\n-                self.tcx().mk_region(ty::ReCanonical(cvar))\n-            }\n-\n-            ty::ReStatic\n-            | ty::ReEarlyBound(..)\n-            | ty::ReFree(_)\n-            | ty::ReScope(_)\n-            | ty::ReSkolemized(..)\n-            | ty::ReEmpty\n-            | ty::ReErased => {\n-                if self.canonicalize_all_free_regions.0 {\n-                    let info = CanonicalVarInfo {\n-                        kind: CanonicalVarKind::Region,\n-                    };\n-                    let cvar = self.canonical_var(info, r.into());\n-                    self.tcx().mk_region(ty::ReCanonical(cvar))\n-                } else {\n-                    r\n-                }\n-            }\n-\n-            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n-                bug!(\"canonical region encountered during canonicalization\")\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n-\n-            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n-\n-            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n-\n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n-                bug!(\"encountered a fresh type during canonicalization\")\n-            }\n-\n-            ty::TyInfer(ty::CanonicalTy(_)) => {\n-                bug!(\"encountered a canonical type during canonicalization\")\n-            }\n-\n-            ty::TyClosure(..)\n-            | ty::TyGenerator(..)\n-            | ty::TyGeneratorWitness(..)\n-            | ty::TyBool\n-            | ty::TyChar\n-            | ty::TyInt(..)\n-            | ty::TyUint(..)\n-            | ty::TyFloat(..)\n-            | ty::TyAdt(..)\n-            | ty::TyStr\n-            | ty::TyError\n-            | ty::TyArray(..)\n-            | ty::TySlice(..)\n-            | ty::TyRawPtr(..)\n-            | ty::TyRef(..)\n-            | ty::TyFnDef(..)\n-            | ty::TyFnPtr(_)\n-            | ty::TyDynamic(..)\n-            | ty::TyNever\n-            | ty::TyTuple(..)\n-            | ty::TyProjection(..)\n-            | ty::TyForeign(..)\n-            | ty::TyParam(..)\n-            | ty::TyAnon(..) => {\n-                if t.flags.intersects(self.needs_canonical_flags) {\n-                    t.super_fold_with(self)\n-                } else {\n-                    t\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n-    /// The main `canonicalize` method, shared impl of\n-    /// `canonicalize_query` and `canonicalize_response`.\n-    fn canonicalize<V>(\n-        value: &V,\n-        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n-    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        debug_assert!(\n-            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n-            \"canonicalizing a canonical value: {:?}\",\n-            value,\n-        );\n-\n-        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n-            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n-        } else {\n-            TypeFlags::KEEP_IN_LOCAL_TCX\n-        };\n-\n-        let gcx = tcx.global_tcx();\n-\n-        // Fast path: nothing that needs to be canonicalized.\n-        if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap();\n-            let canon_value = V::intern(\n-                gcx,\n-                Canonical {\n-                    variables: Slice::empty(),\n-                    value: out_value,\n-                },\n-            );\n-            let values = CanonicalVarValues {\n-                var_values: IndexVec::default(),\n-            };\n-            return (canon_value, values);\n-        }\n-\n-        let mut canonicalizer = Canonicalizer {\n-            infcx,\n-            tcx,\n-            canonicalize_all_free_regions,\n-            needs_canonical_flags,\n-            variables: IndexVec::default(),\n-            indices: FxHashMap::default(),\n-            var_values: IndexVec::default(),\n-        };\n-        let out_value = value.fold_with(&mut canonicalizer);\n-\n-        // Once we have canonicalized `out_value`, it should not\n-        // contain anything that ties it to this inference context\n-        // anymore, so it should live in the global arena.\n-        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n-            bug!(\n-                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n-                out_value,\n-                value\n-            )\n-        });\n-\n-        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n-\n-        let canonical_value = V::intern(\n-            gcx,\n-            Canonical {\n-                variables: canonical_variables,\n-                value: out_value,\n-            },\n-        );\n-        let canonical_var_values = CanonicalVarValues {\n-            var_values: canonicalizer.var_values,\n-        };\n-        (canonical_value, canonical_var_values)\n-    }\n-\n-    /// Creates a canonical variable replacing `kind` from the input,\n-    /// or returns an existing variable if `kind` has already been\n-    /// seen. `kind` is expected to be an unbound variable (or\n-    /// potentially a free region).\n-    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n-        let Canonicalizer {\n-            indices,\n-            variables,\n-            var_values,\n-            ..\n-        } = self;\n-\n-        indices\n-            .entry(kind)\n-            .or_insert_with(|| {\n-                let cvar1 = variables.push(info);\n-                let cvar2 = var_values.push(kind);\n-                assert_eq!(cvar1, cvar2);\n-                cvar1\n-            })\n-            .clone()\n-    }\n-\n-    /// Given a type variable `ty_var` of the given kind, first check\n-    /// if `ty_var` is bound to anything; if so, canonicalize\n-    /// *that*. Otherwise, create a new canonical variable for\n-    /// `ty_var`.\n-    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n-        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n-        let bound_to = infcx.shallow_resolve(ty_var);\n-        if bound_to != ty_var {\n-            self.fold_ty(bound_to)\n-        } else {\n-            let info = CanonicalVarInfo {\n-                kind: CanonicalVarKind::Ty(ty_kind),\n-            };\n-            let cvar = self.canonical_var(info, ty_var.into());\n-            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n-        }\n-    }\n-}\n-\n-impl<'tcx, V> Canonical<'tcx, V> {\n-    /// Instantiate the wrapped value, replacing each canonical value\n-    /// with the value given in `var_values`.\n-    fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n-    where\n-        V: TypeFoldable<'tcx>,\n-    {\n-        self.substitute_projected(tcx, var_values, |value| value)\n-    }\n-\n-    /// Invoke `projection_fn` with `self.value` to get a value V that\n-    /// is expressed in terms of the same canonical variables bound in\n-    /// `self`. Apply the substitution `var_values` to this value V,\n-    /// replacing each of the canonical variables.\n-    fn substitute_projected<T>(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        var_values: &CanonicalVarValues<'tcx>,\n-        projection_fn: impl FnOnce(&V) -> &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        assert_eq!(self.variables.len(), var_values.var_values.len());\n-        let value = projection_fn(&self.value);\n-        substitute_value(tcx, var_values, value)\n-    }\n-}\n-\n-/// Substitute the values from `var_values` into `value`. `var_values`\n-/// must be values for the set of cnaonical variables that appear in\n-/// `value`.\n-fn substitute_value<'a, 'tcx, T>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    var_values: &CanonicalVarValues<'tcx>,\n-    value: &'a T,\n-) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    if var_values.var_values.is_empty() {\n-        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n-        value.clone()\n-    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n-        value.clone()\n-    } else {\n-        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n-    }\n-}\n-\n-struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    var_values: &'cx CanonicalVarValues<'tcx>,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n-                match self.var_values.var_values[c].unpack() {\n-                    UnpackedKind::Type(ty) => ty,\n-                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n-                }\n-            }\n-            _ => {\n-                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n-                    t\n-                } else {\n-                    t.super_fold_with(self)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match r {\n-            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n-                UnpackedKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n-            },\n-            _ => r.super_fold_with(self),\n-        }\n-    }\n }\n \n CloneTypeFoldableAndLiftImpls! {"}, {"sha": "b1eed05c2a2fd88db9caaaeb5814726051d64694", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=a1811cef764ebae9715947066c19ea171b7927f1", "patch": "@@ -0,0 +1,215 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains the code to instantiate a \"query result\", and\n+//! in particular to extract out the resulting region obligations and\n+//! encode them therein.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::{Canonical, CanonicalVarValues, QueryRegionConstraint, QueryResult};\n+use infer::canonical::substitute::substitute_value;\n+use infer::{InferCtxt, InferOk, InferResult};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::fmt::Debug;\n+use traits::{Obligation, ObligationCause, PredicateObligation};\n+use ty::fold::TypeFoldable;\n+use ty::subst::{Kind, UnpackedKind};\n+use ty::{self, CanonicalVar};\n+\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Given the (canonicalized) result to a canonical query,\n+    /// instantiates the result so it can be used, plugging in the\n+    /// values from the canonical query. (Note that the result may\n+    /// have been ambiguous; you should check the certainty level of\n+    /// the query before applying this function.)\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#processing-the-canonicalized-query-result\n+    pub fn instantiate_query_result<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        // Every canonical query result includes values for each of\n+        // the inputs to the query. Therefore, we begin by unifying\n+        // these values with the original inputs that were\n+        // canonicalized.\n+        let result_values = &query_result.value.var_values;\n+        assert_eq!(original_values.len(), result_values.len());\n+\n+        // Quickly try to find initial values for the canonical\n+        // variables in the result in terms of the query. We do this\n+        // by iterating down the values that the query gave to each of\n+        // the canonical inputs. If we find that one of those values\n+        // is directly equal to one of the canonical variables in the\n+        // result, then we can type the corresponding value from the\n+        // input. See the example above.\n+        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n+            IndexVec::from_elem_n(None, query_result.variables.len());\n+\n+        // In terms of our example above, we are iterating over pairs like:\n+        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n+        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+            match result_value.unpack() {\n+                UnpackedKind::Type(result_value) => {\n+                    // e.g., here `result_value` might be `?0` in the example above...\n+                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+                UnpackedKind::Lifetime(result_value) => {\n+                    // e.g., here `result_value` might be `'?1` in the example above...\n+                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n+                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Create a result substitution: if we found a value for a\n+        // given variable in the loop above, use that. Otherwise, use\n+        // a fresh inference variable.\n+        let result_subst = &CanonicalVarValues {\n+            var_values: query_result\n+                .variables\n+                .iter()\n+                .enumerate()\n+                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n+                    Some(k) => k,\n+                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n+                })\n+                .collect(),\n+        };\n+\n+        // Unify the original values for the canonical variables in\n+        // the input with the value found in the query\n+        // post-substitution. Often, but not always, this is a no-op,\n+        // because we already found the mapping in the first step.\n+        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n+        };\n+        let mut obligations = self\n+            .unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n+            .into_obligations();\n+\n+        obligations.extend(self.query_region_constraints_into_obligations(\n+            cause,\n+            param_env,\n+            &query_result.value.region_constraints,\n+            result_subst,\n+        ));\n+\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// Converts the region constraints resulting from a query into an\n+    /// iterator of obligations.\n+    fn query_region_constraints_into_obligations<'a>(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n+        result_subst: &'a CanonicalVarValues<'tcx>,\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        Box::new(\n+            unsubstituted_region_constraints\n+                .iter()\n+                .map(move |constraint| {\n+                    let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+                    let k1 = substitute_value(self.tcx, result_subst, k1);\n+                    let r2 = substitute_value(self.tcx, result_subst, r2);\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => Obligation::new(\n+                            cause.clone(),\n+                            param_env,\n+                            ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                ty::OutlivesPredicate(r1, r2),\n+                            )),\n+                        ),\n+\n+                        UnpackedKind::Type(t1) => Obligation::new(\n+                            cause.clone(),\n+                            param_env,\n+                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+                                t1, r2,\n+                            ))),\n+                        ),\n+                    }\n+                }),\n+        ) as Box<dyn Iterator<Item = _>>\n+    }\n+\n+    /// Given two sets of values for the same set of canonical variables, unify them.\n+    /// The second set is produced lazilly by supplying indices from the first set.\n+    fn unify_canonical_vars(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        variables1: &CanonicalVarValues<'tcx>,\n+        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        self.commit_if_ok(|_| {\n+            let mut obligations = vec![];\n+            for (index, value1) in variables1.var_values.iter_enumerated() {\n+                let value2 = variables2(index);\n+\n+                match (value1.unpack(), value2.unpack()) {\n+                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                    }\n+                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    _ => {\n+                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n+                    }\n+                }\n+            }\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        })\n+    }\n+}"}, {"sha": "5bc1ae689a5d2d0cc097ffb41643283edbdcfcea", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=a1811cef764ebae9715947066c19ea171b7927f1", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains code to substitute new values into a\n+//! `Canonical<'tcx, T>`.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::{Canonical, CanonicalVarValues};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::UnpackedKind;\n+use ty::{self, Ty, TyCtxt, TypeFlags};\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Instantiate the wrapped value, replacing each canonical value\n+    /// with the value given in `var_values`.\n+    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    /// Allows one to apply a substitute to some subset of\n+    /// `self.value`. Invoke `projection_fn` with `self.value` to get\n+    /// a value V that is expressed in terms of the same canonical\n+    /// variables bound in `self` (usually this extracts from subset\n+    /// of `self`). Apply the substitution `var_values` to this value\n+    /// V, replacing each of the canonical variables.\n+    pub fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        let value = projection_fn(&self.value);\n+        substitute_value(tcx, var_values, value)\n+    }\n+}\n+\n+/// Substitute the values from `var_values` into `value`. `var_values`\n+/// must be values for the set of canonical variables that appear in\n+/// `value`.\n+pub(super) fn substitute_value<'a, 'tcx, T>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    var_values: &CanonicalVarValues<'tcx>,\n+    value: &'a T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    if var_values.var_values.is_empty() {\n+        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n+        value.clone()\n+    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+        value.clone()\n+    } else {\n+        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+    }\n+}\n+\n+struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    var_values: &'cx CanonicalVarValues<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+                match self.var_values.var_values[c].unpack() {\n+                    UnpackedKind::Type(ty) => ty,\n+                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n+                }\n+            }\n+            _ => {\n+                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n+            },\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}]}