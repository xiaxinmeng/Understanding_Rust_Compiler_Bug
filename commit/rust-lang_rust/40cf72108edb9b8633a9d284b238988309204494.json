{"sha": "40cf72108edb9b8633a9d284b238988309204494", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwY2Y3MjEwOGVkYjliODYzM2E5ZDI4NGIyMzg5ODgzMDkyMDQ0OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-23T14:20:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-23T14:20:22Z"}, "message": "Auto merge of #79186 - JulianKnodt:str_from, r=Mark-Simulacrum\n\nChange slice::to_vec to not use extend_from_slice\n\nI saw this [Zulip thread](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/String.3A.3Afrom%28.26str%29.20wonky.20codegen/near/216164455), and didn't see any update from it, so I thought I'd try to fix it. This converts `to_vec` to no longer use `extend_from_slice`, but relies on knowing that the allocated capacity is the same size as the input.\n\n[Godbolt new v1](https://rust.godbolt.org/z/1bcWKG)\n[Godbolt new v2 w/ drop guard](https://rust.godbolt.org/z/5jn76K)\n[Godbolt old version](https://rust.godbolt.org/z/e4ePav)\n\nAfter some amount of iteration, there are now two specializations for `to_vec`, one for `Copy` types that use memcpy, and one for clone types which is the original from this PR.\n\nThis is then used inside of `impl<T: Clone> FromIterator<Iter::Slice<T>> for Vec<T>` which is essentially equivalent to `&[T] -> Vec<T>`, instead of previous specialization of the `extend` function. This is because extend has to reason more about existing capacity by calling `reserve` on an existing vec, and thus produces worse asm.\n\nDownsides: This allocates the exact capacity, so I think if many items are added to this `Vec` after, it might need to allocate whereas extending may not. I also noticed the number of faults went up in the benchmarks, but not sure where from exactly.", "tree": {"sha": "8ea73ecde9df96d08ea95a412a3f62eb087548e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ea73ecde9df96d08ea95a412a3f62eb087548e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40cf72108edb9b8633a9d284b238988309204494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40cf72108edb9b8633a9d284b238988309204494", "html_url": "https://github.com/rust-lang/rust/commit/40cf72108edb9b8633a9d284b238988309204494", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40cf72108edb9b8633a9d284b238988309204494/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "068320b39e3e4839d832b3aa71fa910ba170673b", "url": "https://api.github.com/repos/rust-lang/rust/commits/068320b39e3e4839d832b3aa71fa910ba170673b", "html_url": "https://github.com/rust-lang/rust/commit/068320b39e3e4839d832b3aa71fa910ba170673b"}, {"sha": "a9915581d7cb73e7c8fb8193f48dbef36a7d09ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9915581d7cb73e7c8fb8193f48dbef36a7d09ac", "html_url": "https://github.com/rust-lang/rust/commit/a9915581d7cb73e7c8fb8193f48dbef36a7d09ac"}], "stats": {"total": 102, "additions": 85, "deletions": 17}, "files": [{"sha": "949a3bb1d708c2067f51e5f1764d0e696b1fc9ce", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/40cf72108edb9b8633a9d284b238988309204494/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cf72108edb9b8633a9d284b238988309204494/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=40cf72108edb9b8633a9d284b238988309204494", "patch": "@@ -155,13 +155,65 @@ mod hack {\n     }\n \n     #[inline]\n-    pub fn to_vec<T, A: AllocRef>(s: &[T], alloc: A) -> Vec<T, A>\n-    where\n-        T: Clone,\n-    {\n-        let mut vec = Vec::with_capacity_in(s.len(), alloc);\n-        vec.extend_from_slice(s);\n-        vec\n+    pub fn to_vec<T: ConvertVec, A: AllocRef>(s: &[T], alloc: A) -> Vec<T, A> {\n+        T::to_vec(s, alloc)\n+    }\n+\n+    pub trait ConvertVec {\n+        fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A>\n+        where\n+            Self: Sized;\n+    }\n+\n+    impl<T: Clone> ConvertVec for T {\n+        #[inline]\n+        default fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A> {\n+            struct DropGuard<'a, T, A: AllocRef> {\n+                vec: &'a mut Vec<T, A>,\n+                num_init: usize,\n+            }\n+            impl<'a, T, A: AllocRef> Drop for DropGuard<'a, T, A> {\n+                #[inline]\n+                fn drop(&mut self) {\n+                    // SAFETY:\n+                    // items were marked initialized in the loop below\n+                    unsafe {\n+                        self.vec.set_len(self.num_init);\n+                    }\n+                }\n+            }\n+            let mut vec = Vec::with_capacity_in(s.len(), alloc);\n+            let mut guard = DropGuard { vec: &mut vec, num_init: 0 };\n+            let slots = guard.vec.spare_capacity_mut();\n+            // .take(slots.len()) is necessary for LLVM to remove bounds checks\n+            // and has better codegen than zip.\n+            for (i, b) in s.iter().enumerate().take(slots.len()) {\n+                guard.num_init = i;\n+                slots[i].write(b.clone());\n+            }\n+            core::mem::forget(guard);\n+            // SAFETY:\n+            // the vec was allocated and initialized above to at least this length.\n+            unsafe {\n+                vec.set_len(s.len());\n+            }\n+            vec\n+        }\n+    }\n+\n+    impl<T: Copy> ConvertVec for T {\n+        #[inline]\n+        fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A> {\n+            let mut v = Vec::with_capacity_in(s.len(), alloc);\n+            // SAFETY:\n+            // allocated above with the capacity of `s`, and initialize to `s.len()` in\n+            // ptr::copy_to_non_overlapping below.\n+            unsafe {\n+                s.as_ptr().copy_to_nonoverlapping(v.as_mut_ptr(), s.len());\n+                v.set_len(s.len());\n+            }\n+            v\n+        }\n     }\n }\n "}, {"sha": "5168792092823fd5111efd2cded686cf38e6b119", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/40cf72108edb9b8633a9d284b238988309204494/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cf72108edb9b8633a9d284b238988309204494/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=40cf72108edb9b8633a9d284b238988309204494", "patch": "@@ -2508,17 +2508,23 @@ where\n     }\n }\n \n-impl<'a, T: 'a> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T>\n-where\n-    T: Copy,\n-{\n-    // reuses the extend specialization for T: Copy\n+// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n+// must take more steps to reason about the final capacity + length\n+// and thus do more work. `to_vec()` directly allocates the correct amount\n+// and fills it exactly.\n+impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n+    #[cfg(not(test))]\n     fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        let mut vec = Vec::new();\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vec.spec_extend(iterator);\n-        vec\n+        iterator.as_slice().to_vec()\n+    }\n+\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Instead use the\n+    // `slice::to_vec`  function which is only available with cfg(test)\n+    // NB see the slice::hack module in slice.rs for more information\n+    #[cfg(test)]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        crate::slice::to_vec(iterator.as_slice(), Global)\n     }\n }\n "}, {"sha": "60dc4efcb625151b6e508e24e18380f3ba5fdf91", "filename": "src/test/codegen/to_vec.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40cf72108edb9b8633a9d284b238988309204494/src%2Ftest%2Fcodegen%2Fto_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cf72108edb9b8633a9d284b238988309204494/src%2Ftest%2Fcodegen%2Fto_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fto_vec.rs?ref=40cf72108edb9b8633a9d284b238988309204494", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @copy_to_vec\n+#[no_mangle]\n+fn copy_to_vec(s: &[u64]) -> Vec<u64> {\n+  s.to_vec()\n+  // CHECK: call void @llvm.memcpy\n+}"}]}