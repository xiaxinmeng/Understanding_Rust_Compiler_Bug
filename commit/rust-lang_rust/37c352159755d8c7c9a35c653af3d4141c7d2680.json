{"sha": "37c352159755d8c7c9a35c653af3d4141c7d2680", "node_id": "C_kwDOAAsO6NoAKDM3YzM1MjE1OTc1NWQ4YzdjOWEzNWM2NTNhZjNkNDE0MWM3ZDI2ODA", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-11-23T15:24:03Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-11-23T15:24:03Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "efc723e7731d3e307205be0506afb7d1828f900c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efc723e7731d3e307205be0506afb7d1828f900c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37c352159755d8c7c9a35c653af3d4141c7d2680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37c352159755d8c7c9a35c653af3d4141c7d2680", "html_url": "https://github.com/rust-lang/rust/commit/37c352159755d8c7c9a35c653af3d4141c7d2680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37c352159755d8c7c9a35c653af3d4141c7d2680/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0d0d757e2f1b61ec809420b006545a9f8974c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0d0d757e2f1b61ec809420b006545a9f8974c0", "html_url": "https://github.com/rust-lang/rust/commit/4e0d0d757e2f1b61ec809420b006545a9f8974c0"}, {"sha": "26562973b3482a635416b2b663a13016d4d90e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/26562973b3482a635416b2b663a13016d4d90e20", "html_url": "https://github.com/rust-lang/rust/commit/26562973b3482a635416b2b663a13016d4d90e20"}], "stats": {"total": 2984, "additions": 2089, "deletions": 895}, "files": [{"sha": "41c5d36671de00e56f6d890b0139b1d8f4e5be1a", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -221,6 +221,16 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"command-group\"\n+version = \"1.0.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f7a8a86f409b4a59df3a3e4bee2de0b83f1755fdd2a25e3a9684c396fc4bed2c\"\n+dependencies = [\n+ \"nix\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"countme\"\n version = \"3.0.1\"\n@@ -300,7 +310,7 @@ dependencies = [\n  \"hashbrown\",\n  \"lock_api\",\n  \"once_cell\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -359,14 +369,14 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.17\"\n+version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e94a7bbaa59354bc20dd75b67f23e2797b4490e9d6928203fb105c79e448c86c\"\n+checksum = \"4b9663d381d07ae25dc88dbdf27df458faa83a9b25336bcac83d5e452b5fc9d3\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -390,6 +400,7 @@ name = \"flycheck\"\n version = \"0.0.0\"\n dependencies = [\n  \"cargo_metadata\",\n+ \"command-group\",\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"paths\",\n@@ -963,11 +974,24 @@ dependencies = [\n \n [[package]]\n name = \"miow\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n+checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n dependencies = [\n- \"windows-sys 0.28.0\",\n+ \"windows-sys 0.42.0\",\n+]\n+\n+[[package]]\n+name = \"nix\"\n+version = \"0.22.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e4916f159ed8e5de0082076562152a76b7a1f64a01fd9d1e0fea002c37624faf\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"memoffset\",\n ]\n \n [[package]]\n@@ -1037,7 +1061,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -1056,15 +1080,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -1979,19 +2003,6 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows-sys\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n-dependencies = [\n- \"windows_aarch64_msvc 0.28.0\",\n- \"windows_i686_gnu 0.28.0\",\n- \"windows_i686_msvc 0.28.0\",\n- \"windows_x86_64_gnu 0.28.0\",\n- \"windows_x86_64_msvc 0.28.0\",\n-]\n-\n [[package]]\n name = \"windows-sys\"\n version = \"0.36.1\"\n@@ -2006,10 +2017,25 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"windows_aarch64_msvc\"\n-version = \"0.28.0\"\n+name = \"windows-sys\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc 0.42.0\",\n+ \"windows_i686_gnu 0.42.0\",\n+ \"windows_i686_msvc 0.42.0\",\n+ \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc 0.42.0\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n@@ -2018,10 +2044,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n \n [[package]]\n-name = \"windows_i686_gnu\"\n-version = \"0.28.0\"\n+name = \"windows_aarch64_msvc\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n@@ -2030,10 +2056,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n \n [[package]]\n-name = \"windows_i686_msvc\"\n-version = \"0.28.0\"\n+name = \"windows_i686_gnu\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n@@ -2042,10 +2068,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n \n [[package]]\n-name = \"windows_x86_64_gnu\"\n-version = \"0.28.0\"\n+name = \"windows_i686_msvc\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n@@ -2054,17 +2080,29 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n \n [[package]]\n-name = \"windows_x86_64_msvc\"\n-version = \"0.28.0\"\n+name = \"windows_x86_64_gnu\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n \n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+\n [[package]]\n name = \"write-json\"\n version = \"0.1.2\""}, {"sha": "a484ecec68250944dff51124551cc19d54af5991", "filename": "src/tools/rust-analyzer/crates/base-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "2857420c285a7874c1f465d757967f709e1aebc2", "filename": "src/tools/rust-analyzer/crates/cfg/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "514d567fcce756eb461adacefa07a117c5dc349b", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false\n@@ -17,6 +17,7 @@ rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.86\"\n jod-thread = \"0.1.2\"\n+command-group = \"1.0.8\"\n \n toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "8f93dad06e3f5d384b95b89907faee227e1db0eb", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -10,11 +10,12 @@ use std::{\n     time::Duration,\n };\n \n+use command_group::{CommandGroup, GroupChild};\n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use rustc_hash::FxHashMap;\n use serde::Deserialize;\n-use stdx::{process::streaming_output, JodChild};\n+use stdx::process::streaming_output;\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -39,7 +40,7 @@ pub enum InvocationLocation {\n pub enum FlycheckConfig {\n     CargoCommand {\n         command: String,\n-        target_triple: Option<String>,\n+        target_triples: Vec<String>,\n         all_targets: bool,\n         no_default_features: bool,\n         all_features: bool,\n@@ -285,7 +286,7 @@ impl FlycheckActor {\n         let (mut cmd, args) = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n-                target_triple,\n+                target_triples,\n                 no_default_features,\n                 all_targets,\n                 all_features,\n@@ -299,7 +300,7 @@ impl FlycheckActor {\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n                     .arg(self.root.join(\"Cargo.toml\").as_os_str());\n \n-                if let Some(target) = target_triple {\n+                for target in target_triples {\n                     cmd.args(&[\"--target\", target.as_str()]);\n                 }\n                 if *all_targets {\n@@ -359,10 +360,12 @@ impl FlycheckActor {\n     }\n }\n \n+struct JodChild(GroupChild);\n+\n /// A handle to a cargo process used for fly-checking.\n struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n-    /// a read syscall dropping and therefor terminating the process is our best option.\n+    /// a read syscall dropping and therefore terminating the process is our best option.\n     child: JodChild,\n     thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n@@ -371,10 +374,10 @@ struct CargoHandle {\n impl CargoHandle {\n     fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n         command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-        let mut child = JodChild::spawn(command)?;\n+        let mut child = command.group_spawn().map(JodChild)?;\n \n-        let stdout = child.stdout.take().unwrap();\n-        let stderr = child.stderr.take().unwrap();\n+        let stdout = child.0.inner().stdout.take().unwrap();\n+        let stderr = child.0.inner().stderr.take().unwrap();\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n@@ -386,13 +389,13 @@ impl CargoHandle {\n     }\n \n     fn cancel(mut self) {\n-        let _ = self.child.kill();\n-        let _ = self.child.wait();\n+        let _ = self.child.0.kill();\n+        let _ = self.child.0.wait();\n     }\n \n     fn join(mut self) -> io::Result<()> {\n-        let _ = self.child.kill();\n-        let exit_status = self.child.wait()?;\n+        let _ = self.child.0.kill();\n+        let exit_status = self.child.0.wait()?;\n         let (read_at_least_one_message, error) = self.thread.join()?;\n         if read_at_least_one_message || exit_status.success() {\n             Ok(())"}, {"sha": "22f98ea7cd450e83a44ad9512e1fb9303fadbca0", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "9c76969086485b2aecafdd7a36f436c4802d8136", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -236,11 +236,19 @@ impl TraitData {\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let mut collector =\n-            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n-        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n-        let (items, attribute_calls, diagnostics) = collector.finish();\n-\n+        let (items, attribute_calls, diagnostics) = match &tr_def.items {\n+            Some(items) => {\n+                let mut collector = AssocItemCollector::new(\n+                    db,\n+                    module_id,\n+                    tree_id.file_id(),\n+                    ItemContainerId::TraitId(tr),\n+                );\n+                collector.collect(&item_tree, tree_id.tree_id(), items);\n+                collector.finish()\n+            }\n+            None => Default::default(),\n+        };\n         (\n             Arc::new(TraitData {\n                 name,"}, {"sha": "0aa531eff71f6f5e02e12f003c947e25c1dddf5e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -666,7 +666,8 @@ pub struct Trait {\n     pub generic_params: Interned<GenericParams>,\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n-    pub items: Box<[AssocItem]>,\n+    /// This is [`None`] if this Trait is a trait alias.\n+    pub items: Option<Box<[AssocItem]>>,\n     pub ast_id: FileAstId<ast::Trait>,\n }\n "}, {"sha": "b25274bccc9a4aa6dbe507dc946376af735ab181", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -451,15 +451,7 @@ impl<'a> Ctx<'a> {\n                 .collect()\n         });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n-        let res = Trait {\n-            name,\n-            visibility,\n-            generic_params,\n-            is_auto,\n-            is_unsafe,\n-            items: items.unwrap_or_default(),\n-            ast_id,\n-        };\n+        let res = Trait { name, visibility, generic_params, is_auto, is_unsafe, items, ast_id };\n         Some(id(self.data().traits.alloc(res)))\n     }\n "}, {"sha": "48c40df22ff5f2ff319405cbb352739af61aafb1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -375,12 +375,21 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"trait {}\", name);\n                 self.print_generic_params(generic_params);\n-                self.print_where_clause_and_opening_brace(generic_params);\n-                self.indented(|this| {\n-                    for item in &**items {\n-                        this.print_mod_item((*item).into());\n+                match items {\n+                    Some(items) => {\n+                        self.print_where_clause_and_opening_brace(generic_params);\n+                        self.indented(|this| {\n+                            for item in &**items {\n+                                this.print_mod_item((*item).into());\n+                            }\n+                        });\n                     }\n-                });\n+                    None => {\n+                        w!(self, \" = \");\n+                        // FIXME: Print the aliased traits\n+                        self.print_where_clause_and_opening_brace(generic_params);\n+                    }\n+                }\n                 wln!(self, \"}}\");\n             }\n             ModItem::Impl(it) => {"}, {"sha": "fc90c6e9f370f107cacd59606055ecba9a6d94ea", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -94,11 +94,11 @@ macro_rules! m {\n     ($($s:stmt)*) => (stringify!($($s |)*);)\n }\n stringify!(;\n-|;\n-|92|;\n-|let x = 92|;\n+| ;\n+|92| ;\n+|let x = 92| ;\n |loop {}\n-|;\n+| ;\n |);\n \"#]],\n     );\n@@ -118,7 +118,7 @@ m!(.. .. ..);\n macro_rules! m {\n     ($($p:pat)*) => (stringify!($($p |)*);)\n }\n-stringify!(.. .. ..|);\n+stringify!(.. .. .. |);\n \"#]],\n     );\n }"}, {"sha": "118c14ed843fecf9e3e5ad2a59f2f3ae3e1757bc", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -82,14 +82,14 @@ fn attribute_macro_syntax_completion_2() {\n #[proc_macros::identity_when_valid]\n fn foo() { bar.; blub }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[proc_macros::identity_when_valid]\n fn foo() { bar.; blub }\n \n fn foo() {\n-    bar.;\n+    bar. ;\n     blub\n-}\"##]],\n+}\"#]],\n     );\n }\n "}, {"sha": "b0dd01f9dbea288784cceef395338852ef4ed859", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -212,6 +212,7 @@ impl Import {\n \n #[derive(Debug, Eq, PartialEq)]\n struct ImportDirective {\n+    /// The module this import directive is in.\n     module_id: LocalModuleId,\n     import: Import,\n     status: PartialResolvedImport,\n@@ -963,8 +964,10 @@ impl DefCollector<'_> {\n \n     fn update(\n         &mut self,\n+        // The module for which `resolutions` have been resolve\n         module_id: LocalModuleId,\n         resolutions: &[(Option<Name>, PerNs)],\n+        // Visibility this import will have\n         vis: Visibility,\n         import_type: ImportType,\n     ) {\n@@ -974,6 +977,7 @@ impl DefCollector<'_> {\n \n     fn update_recursive(\n         &mut self,\n+        // The module for which `resolutions` have been resolve\n         module_id: LocalModuleId,\n         resolutions: &[(Option<Name>, PerNs)],\n         // All resolutions are imported with this visibility; the visibilities in"}, {"sha": "20d39ec6cb92e2c86b2a1c48d43de2ca627f73e1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -73,7 +73,10 @@ impl DefMap {\n     pub(crate) fn resolve_visibility(\n         &self,\n         db: &dyn DefDatabase,\n+        // module to import to\n         original_module: LocalModuleId,\n+        // pub(path)\n+        //     ^^^^ this\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n         let mut vis = match visibility {\n@@ -115,6 +118,7 @@ impl DefMap {\n         &self,\n         db: &dyn DefDatabase,\n         mode: ResolveMode,\n+        // module to import to\n         mut original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n@@ -361,6 +365,9 @@ impl DefMap {\n                     );\n                 }\n             };\n+\n+            curr_per_ns = curr_per_ns\n+                .filter_visibility(|vis| vis.is_visible_from_def_map(db, self, original_module));\n         }\n \n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None, Some(self.krate))"}, {"sha": "0d90047c28f6f7e3e30991914642effaedb23387", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -58,9 +58,9 @@ extern {\n \"#,\n         expect![[r#\"\n             crate\n-            E: t\n+            E: _\n             S: t v\n-            V: t v\n+            V: _\n             foo: t\n \n             crate::foo\n@@ -307,7 +307,7 @@ pub struct FromLib;\n             Bar: t v\n \n             crate::foo\n-            Bar: t v\n+            Bar: _\n             FromLib: t v\n         \"#]],\n     );"}, {"sha": "88a3c76393f08fed9b12adf425a5f37f9d7e3d7d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/globs.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -119,7 +119,7 @@ use foo::*;\n use foo::bar::*;\n \n //- /foo/mod.rs\n-mod bar;\n+pub mod bar;\n fn Foo() {};\n pub struct Foo {};\n \n@@ -132,6 +132,7 @@ pub(crate) struct PubCrateStruct;\n             crate\n             Foo: t\n             PubCrateStruct: t v\n+            bar: t\n             foo: t\n \n             crate::foo\n@@ -336,3 +337,33 @@ mod d {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn glob_name_collision_check_visibility() {\n+    check(\n+        r#\"\n+mod event {\n+    mod serenity {\n+        pub fn Event() {}\n+    }\n+    use serenity::*;\n+\n+    pub struct Event {}\n+}\n+\n+use event::Event;\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            Event: t\n+            event: t\n+\n+            crate::event\n+            Event: t v\n+            serenity: t\n+\n+            crate::event::serenity\n+            Event: v\n+        \"#]],\n+    );\n+}"}, {"sha": "c575bf7cac2550d252c88bf785b6179c86b43551", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -580,7 +580,7 @@ fn module_resolution_decl_inside_inline_module_in_crate_root() {\n //- /main.rs\n mod foo {\n     #[path = \"baz.rs\"]\n-    mod bar;\n+    pub mod bar;\n }\n use self::foo::bar::Baz;\n "}, {"sha": "77eb1fd450433468adc517c258322a6559d4c55c", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a4abe75626e6dcacf24df7e822857e404eecc919", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,6 +4,7 @@ use std::mem;\n \n use mbe::{SyntheticToken, SyntheticTokenId, TokenMap};\n use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::{\n     ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n@@ -292,25 +293,34 @@ pub(crate) fn reverse_fixups(\n     token_map: &TokenMap,\n     undo_info: &SyntaxFixupUndoInfo,\n ) {\n-    tt.token_trees.retain(|tt| match tt {\n-        tt::TokenTree::Leaf(leaf) => {\n-            token_map.synthetic_token_id(leaf.id()).is_none()\n-                || token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID)\n-        }\n-        tt::TokenTree::Subtree(st) => st.delimiter.map_or(true, |d| {\n-            token_map.synthetic_token_id(d.id).is_none()\n-                || token_map.synthetic_token_id(d.id) != Some(EMPTY_ID)\n-        }),\n-    });\n-    tt.token_trees.iter_mut().for_each(|tt| match tt {\n-        tt::TokenTree::Subtree(tt) => reverse_fixups(tt, token_map, undo_info),\n-        tt::TokenTree::Leaf(leaf) => {\n-            if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n-                let original = &undo_info.original[id.0 as usize];\n-                *tt = tt::TokenTree::Subtree(original.clone());\n+    let tts = std::mem::take(&mut tt.token_trees);\n+    tt.token_trees = tts\n+        .into_iter()\n+        .filter(|tt| match tt {\n+            tt::TokenTree::Leaf(leaf) => token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID),\n+            tt::TokenTree::Subtree(st) => {\n+                st.delimiter.map_or(true, |d| token_map.synthetic_token_id(d.id) != Some(EMPTY_ID))\n             }\n-        }\n-    });\n+        })\n+        .flat_map(|tt| match tt {\n+            tt::TokenTree::Subtree(mut tt) => {\n+                reverse_fixups(&mut tt, token_map, undo_info);\n+                SmallVec::from_const([tt.into()])\n+            }\n+            tt::TokenTree::Leaf(leaf) => {\n+                if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n+                    let original = undo_info.original[id.0 as usize].clone();\n+                    if original.delimiter.is_none() {\n+                        original.token_trees.into()\n+                    } else {\n+                        SmallVec::from_const([original.into()])\n+                    }\n+                } else {\n+                    SmallVec::from_const([leaf.into()])\n+                }\n+            }\n+        })\n+        .collect();\n }\n \n #[cfg(test)]\n@@ -319,6 +329,31 @@ mod tests {\n \n     use super::reverse_fixups;\n \n+    // The following three functions are only meant to check partial structural equivalence of\n+    // `TokenTree`s, see the last assertion in `check()`.\n+    fn check_leaf_eq(a: &tt::Leaf, b: &tt::Leaf) -> bool {\n+        match (a, b) {\n+            (tt::Leaf::Literal(a), tt::Leaf::Literal(b)) => a.text == b.text,\n+            (tt::Leaf::Punct(a), tt::Leaf::Punct(b)) => a.char == b.char,\n+            (tt::Leaf::Ident(a), tt::Leaf::Ident(b)) => a.text == b.text,\n+            _ => false,\n+        }\n+    }\n+\n+    fn check_subtree_eq(a: &tt::Subtree, b: &tt::Subtree) -> bool {\n+        a.delimiter.map(|it| it.kind) == b.delimiter.map(|it| it.kind)\n+            && a.token_trees.len() == b.token_trees.len()\n+            && a.token_trees.iter().zip(&b.token_trees).all(|(a, b)| check_tt_eq(a, b))\n+    }\n+\n+    fn check_tt_eq(a: &tt::TokenTree, b: &tt::TokenTree) -> bool {\n+        match (a, b) {\n+            (tt::TokenTree::Leaf(a), tt::TokenTree::Leaf(b)) => check_leaf_eq(a, b),\n+            (tt::TokenTree::Subtree(a), tt::TokenTree::Subtree(b)) => check_subtree_eq(a, b),\n+            _ => false,\n+        }\n+    }\n+\n     #[track_caller]\n     fn check(ra_fixture: &str, mut expect: Expect) {\n         let parsed = syntax::SourceFile::parse(ra_fixture);\n@@ -331,27 +366,28 @@ mod tests {\n             fixups.append,\n         );\n \n-        let mut actual = tt.to_string();\n-        actual.push('\\n');\n+        let actual = format!(\"{}\\n\", tt);\n \n         expect.indent(false);\n         expect.assert_eq(&actual);\n \n         // the fixed-up tree should be syntactically valid\n         let (parse, _) = mbe::token_tree_to_syntax_node(&tt, ::mbe::TopEntryPoint::MacroItems);\n-        assert_eq!(\n-            parse.errors(),\n-            &[],\n+        assert!(\n+            parse.errors().is_empty(),\n             \"parse has syntax errors. parse tree:\\n{:#?}\",\n             parse.syntax_node()\n         );\n \n         reverse_fixups(&mut tt, &tmap, &fixups.undo_info);\n \n         // the fixed-up + reversed version should be equivalent to the original input\n-        // (but token IDs don't matter)\n+        // modulo token IDs and `Punct`s' spacing.\n         let (original_as_tt, _) = mbe::syntax_node_to_token_tree(&parsed.syntax_node());\n-        assert_eq!(tt.to_string(), original_as_tt.to_string());\n+        assert!(\n+            check_subtree_eq(&tt, &original_as_tt),\n+            \"different token tree: {tt:?}, {original_as_tt:?}\"\n+        );\n     }\n \n     #[test]\n@@ -468,7 +504,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup}\n+fn foo () {a . __ra_fixup}\n \"#]],\n         )\n     }\n@@ -482,7 +518,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup ;}\n+fn foo () {a . __ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -497,7 +533,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .__ra_fixup ; bar () ;}\n+fn foo () {a . __ra_fixup ; bar () ;}\n \"#]],\n         )\n     }\n@@ -525,7 +561,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {let x = a .__ra_fixup ;}\n+fn foo () {let x = a . __ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -541,7 +577,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a .b ; bar () ;}\n+fn foo () {a . b ; bar () ;}\n \"#]],\n         )\n     }"}, {"sha": "7352b003a491cde5ca4b09ce94ecfa1c99f9f172", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -814,7 +814,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n \n     pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n-        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n             return Some(self.map(Clone::clone));\n         } else if !self.file_id.is_attr_macro(db) {\n@@ -926,7 +926,7 @@ impl<N: AstNode> InFile<N> {\n \n     pub fn original_ast_node(self, db: &dyn db::AstDatabase) -> Option<InFile<N>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n-        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n             return Some(self);\n         } else if !self.file_id.is_attr_macro(db) {"}, {"sha": "a1d6835bfaed36eb2a5e4655174ee2d926a74486", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "39514fc44e6c8091849b73b3d9c06549ba585b7b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -53,7 +53,7 @@ pub use builder::{ParamKind, TyBuilder};\n pub use chalk_ext::*;\n pub use infer::{\n     could_coerce, could_unify, Adjust, Adjustment, AutoBorrow, BindingMode, InferenceDiagnostic,\n-    InferenceResult,\n+    InferenceResult, OverloadedDeref, PointerCast,\n };\n pub use interner::Interner;\n pub use lower::{\n@@ -523,35 +523,36 @@ where\n }\n \n pub fn callable_sig_from_fnonce(\n-    self_ty: &Canonical<Ty>,\n+    self_ty: &Ty,\n     env: Arc<TraitEnvironment>,\n     db: &dyn HirDatabase,\n ) -> Option<CallableSig> {\n     let krate = env.krate;\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n-    let mut kinds = self_ty.binders.interned().to_vec();\n     let b = TyBuilder::trait_ref(db, fn_once_trait);\n     if b.remaining() != 2 {\n         return None;\n     }\n-    let fn_once = b\n-        .push(self_ty.value.clone())\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n-        .build();\n-    kinds.extend(fn_once.substitution.iter(Interner).skip(1).map(|x| {\n-        let vk = match x.data(Interner) {\n-            chalk_ir::GenericArgData::Ty(_) => {\n-                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n-            }\n-            chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-            chalk_ir::GenericArgData::Const(c) => {\n-                chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n-            }\n-        };\n-        chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n-    }));\n+    let fn_once = b.push(self_ty.clone()).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n+    let kinds = fn_once\n+        .substitution\n+        .iter(Interner)\n+        .skip(1)\n+        .map(|x| {\n+            let vk = match x.data(Interner) {\n+                chalk_ir::GenericArgData::Ty(_) => {\n+                    chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n+                }\n+                chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n+                chalk_ir::GenericArgData::Const(c) => {\n+                    chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n+                }\n+            };\n+            chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n+        })\n+        .collect::<Vec<_>>();\n \n     // FIXME: chalk refuses to solve `<Self as FnOnce<^0.0>>::Output == ^0.1`, so we first solve\n     // `<Self as FnOnce<^0.0>>` and then replace `^0.0` with the concrete argument tuple.\n@@ -563,21 +564,16 @@ pub fn callable_sig_from_fnonce(\n         Some(Solution::Unique(vars)) => vars.value.subst,\n         _ => return None,\n     };\n-    let args = subst.at(Interner, self_ty.binders.interned().len()).ty(Interner)?;\n+    let args = subst.at(Interner, 0).ty(Interner)?;\n     let params = match args.kind(Interner) {\n         chalk_ir::TyKind::Tuple(_, subst) => {\n             subst.iter(Interner).filter_map(|arg| arg.ty(Interner).cloned()).collect::<Vec<_>>()\n         }\n         _ => return None,\n     };\n-    if params.iter().any(|ty| ty.is_unknown()) {\n-        return None;\n-    }\n \n-    let fn_once = TyBuilder::trait_ref(db, fn_once_trait)\n-        .push(self_ty.value.clone())\n-        .push(args.clone())\n-        .build();\n+    let fn_once =\n+        TyBuilder::trait_ref(db, fn_once_trait).push(self_ty.clone()).push(args.clone()).build();\n     let projection =\n         TyBuilder::assoc_type_projection(db, output_assoc_type, Some(fn_once.substitution.clone()))\n             .build();"}, {"sha": "8bcfa2728f071844a8e57c0ec81ca3f6f2dcbf46", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -541,7 +541,7 @@ pub struct ReceiverAdjustments {\n \n impl ReceiverAdjustments {\n     pub(crate) fn apply(&self, table: &mut InferenceTable<'_>, ty: Ty) -> (Ty, Vec<Adjustment>) {\n-        let mut ty = ty;\n+        let mut ty = table.resolve_ty_shallow(&ty);\n         let mut adjust = Vec::new();\n         for _ in 0..self.autoderefs {\n             match autoderef::autoderef_step(table, ty.clone()) {"}, {"sha": "5d76d185ffc0441cb3b961bd57c251f612972b33", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -164,16 +164,16 @@ fn infer_associated_method_with_modules() {\n     check_infer(\n         r#\"\n         mod a {\n-            struct A;\n+            pub struct A;\n             impl A { pub fn thing() -> A { A {} }}\n         }\n \n         mod b {\n-            struct B;\n+            pub struct B;\n             impl B { pub fn thing() -> u32 { 99 }}\n \n-            mod c {\n-                struct C;\n+            pub mod c {\n+                pub struct C;\n                 impl C { pub fn thing() -> C { C {} }}\n             }\n         }\n@@ -186,22 +186,22 @@ fn infer_associated_method_with_modules() {\n         }\n         \"#,\n         expect![[r#\"\n-            55..63 '{ A {} }': A\n-            57..61 'A {}': A\n-            125..131 '{ 99 }': u32\n-            127..129 '99': u32\n-            201..209 '{ C {} }': C\n-            203..207 'C {}': C\n-            240..324 '{     ...g(); }': ()\n-            250..251 'x': A\n-            254..265 'a::A::thing': fn thing() -> A\n-            254..267 'a::A::thing()': A\n-            277..278 'y': u32\n-            281..292 'b::B::thing': fn thing() -> u32\n-            281..294 'b::B::thing()': u32\n-            304..305 'z': C\n-            308..319 'c::C::thing': fn thing() -> C\n-            308..321 'c::C::thing()': C\n+            59..67 '{ A {} }': A\n+            61..65 'A {}': A\n+            133..139 '{ 99 }': u32\n+            135..137 '99': u32\n+            217..225 '{ C {} }': C\n+            219..223 'C {}': C\n+            256..340 '{     ...g(); }': ()\n+            266..267 'x': A\n+            270..281 'a::A::thing': fn thing() -> A\n+            270..283 'a::A::thing()': A\n+            293..294 'y': u32\n+            297..308 'b::B::thing': fn thing() -> u32\n+            297..310 'b::B::thing()': u32\n+            320..321 'z': C\n+            324..335 'c::C::thing': fn thing() -> C\n+            324..337 'c::C::thing()': C\n         \"#]],\n     );\n }"}, {"sha": "4e46397459d5d6b26a16e4729d799bcaa244f4c1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1707,3 +1707,19 @@ impl<T, const N: usize> Trait for [T; N] {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn unsize_array_with_inference_variable() {\n+    check_types(\n+        r#\"\n+//- minicore: try, slice\n+use core::ops::ControlFlow;\n+fn foo() -> ControlFlow<(), [usize; 1]> { loop {} }\n+fn bar() -> ControlFlow<(), ()> {\n+    let a = foo()?.len();\n+      //^ usize\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+    );\n+}"}, {"sha": "d7431443b83d519bb1330a7bd5e5ef4a1650142a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -214,7 +214,7 @@ fn infer_paths() {\n fn a() -> u32 { 1 }\n \n mod b {\n-    fn c() -> u32 { 1 }\n+    pub fn c() -> u32 { 1 }\n }\n \n fn test() {\n@@ -225,13 +225,13 @@ fn test() {\n         expect![[r#\"\n             14..19 '{ 1 }': u32\n             16..17 '1': u32\n-            47..52 '{ 1 }': u32\n-            49..50 '1': u32\n-            66..90 '{     ...c(); }': ()\n-            72..73 'a': fn a() -> u32\n-            72..75 'a()': u32\n-            81..85 'b::c': fn c() -> u32\n-            81..87 'b::c()': u32\n+            51..56 '{ 1 }': u32\n+            53..54 '1': u32\n+            70..94 '{     ...c(); }': ()\n+            76..77 'a': fn a() -> u32\n+            76..79 'a()': u32\n+            85..89 'b::c': fn c() -> u32\n+            85..91 'b::c()': u32\n         \"#]],\n     );\n }\n@@ -1856,7 +1856,7 @@ fn not_shadowing_module_by_primitive() {\n     check_types(\n         r#\"\n //- /str.rs\n-fn foo() -> u32 {0}\n+pub fn foo() -> u32 {0}\n \n //- /main.rs\n mod str;"}, {"sha": "3d7194b6f4468ff0fe20910642af7f61bd52b73f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1706,7 +1706,7 @@ fn where_clause_trait_in_scope_for_method_resolution() {\n     check_types(\n         r#\"\n mod foo {\n-    trait Trait {\n+    pub trait Trait {\n         fn foo(&self) -> u32 { 0 }\n     }\n }\n@@ -1723,7 +1723,7 @@ fn super_trait_method_resolution() {\n     check_infer(\n         r#\"\n mod foo {\n-    trait SuperTrait {\n+    pub trait SuperTrait {\n         fn foo(&self) -> u32 {}\n     }\n }\n@@ -1735,15 +1735,15 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n     y.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &Self\n-            62..64 '{}': u32\n-            181..182 'x': T\n-            187..188 'y': U\n-            193..222 '{     ...o(); }': ()\n-            199..200 'x': T\n-            199..206 'x.foo()': u32\n-            212..213 'y': U\n-            212..219 'y.foo()': u32\n+            53..57 'self': &Self\n+            66..68 '{}': u32\n+            185..186 'x': T\n+            191..192 'y': U\n+            197..226 '{     ...o(); }': ()\n+            203..204 'x': T\n+            203..210 'x.foo()': u32\n+            216..217 'y': U\n+            216..223 'y.foo()': u32\n         \"#]],\n     );\n }\n@@ -1754,7 +1754,7 @@ fn super_trait_impl_trait_method_resolution() {\n         r#\"\n //- minicore: sized\n mod foo {\n-    trait SuperTrait {\n+    pub trait SuperTrait {\n         fn foo(&self) -> u32 {}\n     }\n }\n@@ -1764,12 +1764,12 @@ fn test(x: &impl Trait1) {\n     x.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &Self\n-            62..64 '{}': u32\n-            115..116 'x': &impl Trait1\n-            132..148 '{     ...o(); }': ()\n-            138..139 'x': &impl Trait1\n-            138..145 'x.foo()': u32\n+            53..57 'self': &Self\n+            66..68 '{}': u32\n+            119..120 'x': &impl Trait1\n+            136..152 '{     ...o(); }': ()\n+            142..143 'x': &impl Trait1\n+            142..149 'x.foo()': u32\n         \"#]],\n     );\n }"}, {"sha": "f780e3f53c855aa733d2b690883d16386727d037", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cbbcaebb428554a107ffcec8babdac21f3efac15", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -117,7 +117,7 @@ pub use {\n         name::{known, Name},\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n-    hir_ty::display::HirDisplay,\n+    hir_ty::{display::HirDisplay, PointerCast, Safety},\n };\n \n // These are negative re-exports: pub using these names is forbidden, they\n@@ -2997,8 +2997,7 @@ impl Type {\n             TyKind::Function(_) => Callee::FnPtr,\n             TyKind::FnDef(..) => Callee::Def(self.ty.callable_def(db)?),\n             _ => {\n-                let ty = hir_ty::replace_errors_with_variables(&self.ty);\n-                let sig = hir_ty::callable_sig_from_fnonce(&ty, self.env.clone(), db)?;\n+                let sig = hir_ty::callable_sig_from_fnonce(&self.ty, self.env.clone(), db)?;\n                 return Some(Callable {\n                     ty: self.clone(),\n                     sig,\n@@ -3651,6 +3650,28 @@ impl From<ItemInNs> for ScopeDef {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Adjust {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+    /// Dereference once, producing a place.\n+    Deref(Option<OverloadedDeref>),\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow),\n+    Pointer(PointerCast),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AutoBorrow {\n+    /// Converts from T to &T.\n+    Ref(Mutability),\n+    /// Converts from T to *T.\n+    RawPtr(Mutability),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OverloadedDeref(pub Mutability);\n+\n pub trait HasVisibility {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {"}, {"sha": "2e1f88ba09043e7b9d76bfbb2b1d1ec266302c13", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -29,9 +29,10 @@ use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    Access, BindingMode, BuiltinAttr, Callable, ConstParam, Crate, DeriveHelper, Field, Function,\n-    HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local, Macro, Module, ModuleDef,\n-    Name, Path, ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Access, Adjust, AutoBorrow, BindingMode, BuiltinAttr, Callable, ConstParam, Crate,\n+    DeriveHelper, Field, Function, HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local,\n+    Macro, Module, ModuleDef, Name, OverloadedDeref, Path, ScopeDef, ToolModule, Trait, Type,\n+    TypeAlias, TypeParam, VariantDef,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -333,9 +334,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_trait(trait_)\n     }\n \n-    // FIXME: Figure out a nice interface to inspect adjustments\n-    pub fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n-        self.imp.is_implicit_reborrow(expr)\n+    pub fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+        self.imp.expr_adjustments(expr)\n     }\n \n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n@@ -1067,8 +1067,29 @@ impl<'db> SemanticsImpl<'db> {\n         }\n     }\n \n-    fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n-        self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n+    fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+        let mutability = |m| match m {\n+            hir_ty::Mutability::Not => Mutability::Shared,\n+            hir_ty::Mutability::Mut => Mutability::Mut,\n+        };\n+        self.analyze(expr.syntax())?.expr_adjustments(self.db, expr).map(|it| {\n+            it.iter()\n+                .map(|adjust| match adjust.kind {\n+                    hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n+                    hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n+                        Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                    }\n+                    hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n+                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n+                        Adjust::Borrow(AutoBorrow::RawPtr(mutability(m)))\n+                    }\n+                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::Ref(m)) => {\n+                        Adjust::Borrow(AutoBorrow::Ref(mutability(m)))\n+                    }\n+                    hir_ty::Adjust::Pointer(pc) => Adjust::Pointer(pc),\n+                })\n+                .collect()\n+        })\n     }\n \n     fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {"}, {"sha": "91ea1c24d14f83895c13c30a861bbe354f78919a", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -38,8 +38,7 @@ use hir_ty::{\n         UnsafeExpr,\n     },\n     method_resolution::{self, lang_names_for_bin_op},\n-    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n-    TyLoweringContext,\n+    Adjustment, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind, TyLoweringContext,\n };\n use itertools::Itertools;\n use smallvec::SmallVec;\n@@ -156,21 +155,14 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn is_implicit_reborrow(\n+    pub(crate) fn expr_adjustments(\n         &self,\n         db: &dyn HirDatabase,\n         expr: &ast::Expr,\n-    ) -> Option<Mutability> {\n+    ) -> Option<&[Adjustment]> {\n         let expr_id = self.expr_id(db, expr)?;\n         let infer = self.infer.as_ref()?;\n-        let adjustments = infer.expr_adjustments.get(&expr_id)?;\n-        adjustments.windows(2).find_map(|slice| match slice {\n-            &[Adjustment {kind: Adjust::Deref(None), ..}, Adjustment {kind: Adjust::Borrow(AutoBorrow::Ref(m)), ..}] => Some(match m {\n-                hir_ty::Mutability::Mut => Mutability::Mut,\n-                hir_ty::Mutability::Not => Mutability::Shared,\n-            }),\n-            _ => None,\n-        })\n+        infer.expr_adjustments.get(&expr_id).map(|v| &**v)\n     }\n \n     pub(crate) fn type_of_expr("}, {"sha": "e781c0a016d5ad3467a4ab7a3d1ec9a0abf761e7", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "2b3793659cf7d4f9998549cc4c952698b2d6746c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -196,6 +196,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self);\n     fn bar(&self);\n@@ -213,6 +214,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self);\n     fn bar(&self);\n@@ -226,7 +228,7 @@ impl Foo for S {\n \n     $0type Output;\n \n-    const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn foo(&self) {\n         todo!()\n@@ -379,14 +381,14 @@ impl Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar;\n-    trait Foo { fn foo(&self, bar: Bar); }\n+    pub trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar;\n-    trait Foo { fn foo(&self, bar: Bar); }\n+    pub trait Foo { fn foo(&self, bar: Bar); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -439,14 +441,14 @@ impl bar::Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -464,14 +466,14 @@ impl foo::Foo for S {\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+    pub trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n impl foo::Foo<u32> for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n-    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+    pub trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n }\n struct S;\n impl foo::Foo<u32> for S {\n@@ -489,15 +491,15 @@ impl foo::Foo<u32> for S {\n             add_missing_impl_members,\n             r#\"\n mod foo {\n-    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n struct S;\n impl foo::Foo<Param> for S { $0 }\"#,\n             r#\"\n mod foo {\n-    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub trait Foo<T> { fn foo(&self, bar: T); }\n     pub struct Param;\n }\n struct Param;\n@@ -518,15 +520,15 @@ impl foo::Foo<Param> for S {\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n-    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n     impl Bar<T> { type Assoc = u32; }\n-    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+    pub trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -545,15 +547,15 @@ impl foo::Foo for S {\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n-    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub struct Bar<T>;\n     pub struct Baz;\n-    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+    pub trait Foo { fn foo(&self, bar: Bar<Baz>); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -571,14 +573,14 @@ impl foo::Foo for S {\n             r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n-    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+    pub trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n impl foo::Foo for S { $0 }\"#,\n             r#\"\n mod foo {\n     pub trait Fn<Args> { type Output; }\n-    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+    pub trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n }\n struct S;\n impl foo::Foo for S {\n@@ -658,6 +660,7 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn valid(some: u32) -> bool { false }\n     fn foo(some: u32) -> bool;\n@@ -669,13 +672,16 @@ trait Foo {\n     type Output;\n \n     const CONST: usize = 42;\n+    const CONST_2: i32;\n \n     fn valid(some: u32) -> bool { false }\n     fn foo(some: u32) -> bool;\n }\n struct S;\n impl Foo for S {\n-    $0fn valid(some: u32) -> bool { false }\n+    $0const CONST: usize = 42;\n+\n+    fn valid(some: u32) -> bool { false }\n }\"#,\n         )\n     }"}, {"sha": "c1e2f19ab18b2502989555158aaff00a9e63554d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 266, "deletions": 4, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -109,8 +109,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             let params =\n                 body.extracted_function_params(ctx, &container_info, locals_used.iter().copied());\n \n-            let extracted_from_trait_impl = body.extracted_from_trait_impl();\n-\n             let name = make_function_name(&semantics_scope);\n \n             let fun = Function {\n@@ -129,8 +127,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n+            let has_impl_wrapper =\n+                insert_after.ancestors().any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);\n+\n             let fn_def = match fun.self_param_adt(ctx) {\n-                Some(adt) if extracted_from_trait_impl => {\n+                Some(adt) if anchor == Anchor::Method && !has_impl_wrapper => {\n                     let fn_def = format_function(ctx, module, &fun, old_indent, new_indent + 1);\n                     generate_impl_text(&adt, &fn_def).replace(\"{\\n\\n\", \"{\")\n                 }\n@@ -272,7 +273,7 @@ enum FunType {\n }\n \n /// Where to put extracted function definition\n-#[derive(Debug)]\n+#[derive(Debug, Eq, PartialEq, Clone, Copy)]\n enum Anchor {\n     /// Extract free function and put right after current top-level function\n     Freestanding,\n@@ -1245,6 +1246,14 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::IMPL => {\n+                if body.extracted_from_trait_impl() && matches!(anchor, Anchor::Method) {\n+                    let impl_node = find_non_trait_impl(&next_ancestor);\n+                    if let target_node @ Some(_) = impl_node.as_ref().and_then(last_impl_member) {\n+                        return target_node;\n+                    }\n+                }\n+            }\n             SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n@@ -1265,6 +1274,29 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n+fn find_non_trait_impl(trait_impl: &SyntaxNode) -> Option<ast::Impl> {\n+    let as_impl = ast::Impl::cast(trait_impl.clone())?;\n+    let impl_type = Some(impl_type_name(&as_impl)?);\n+\n+    let sibblings = trait_impl.parent()?.children();\n+    sibblings\n+        .filter_map(ast::Impl::cast)\n+        .find(|s| impl_type_name(s) == impl_type && !is_trait_impl(s))\n+}\n+\n+fn last_impl_member(impl_node: &ast::Impl) -> Option<SyntaxNode> {\n+    let last_child = impl_node.assoc_item_list()?.assoc_items().last()?;\n+    Some(last_child.syntax().clone())\n+}\n+\n+fn is_trait_impl(node: &ast::Impl) -> bool {\n+    node.trait_().is_some()\n+}\n+\n+fn impl_type_name(impl_node: &ast::Impl) -> Option<String> {\n+    Some(impl_node.self_ty()?.to_string())\n+}\n+\n fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n@@ -5051,6 +5083,236 @@ impl Struct {\n         );\n     }\n \n+    #[test]\n+    fn extract_method_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_function_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = $03 * 3$0;\n+        self.0 + three_squared\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = fun_name();\n+        self.0 + three_squared\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    3 * 3\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn closure_arguments() {\n         check_assist("}, {"sha": "d9e00435ecf5d73e14c0fefbc4e3f62cd7af1eb1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n+use hir::{db::HirDatabase, HasSource, HasVisibility, ModuleDef, PathResolution, ScopeDef};\n use ide_db::base_db::FileId;\n use syntax::{\n     ast::{self, HasVisibility as _},\n@@ -18,7 +18,7 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n //     fn frobnicate() {}\n // }\n // fn main() {\n-//     m::frobnicate$0() {}\n+//     m::frobnicate$0();\n // }\n // ```\n // ->\n@@ -27,7 +27,7 @@ use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n //     $0pub(crate) fn frobnicate() {}\n // }\n // fn main() {\n-//     m::frobnicate() {}\n+//     m::frobnicate();\n // }\n // ```\n pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n@@ -37,11 +37,15 @@ pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n \n fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n-    let path_res = ctx.sema.resolve_path(&path)?;\n-    let def = match path_res {\n-        PathResolution::Def(def) => def,\n-        _ => return None,\n-    };\n+    let qualifier = path.qualifier()?;\n+    let name_ref = path.segment()?.name_ref()?;\n+    let qualifier_res = ctx.sema.resolve_path(&qualifier)?;\n+    let PathResolution::Def(ModuleDef::Module(module)) = qualifier_res else { return None; };\n+    let (_, def) = module\n+        .scope(ctx.db(), None)\n+        .into_iter()\n+        .find(|(name, _)| name.to_smol_str() == name_ref.text().as_str())?;\n+    let ScopeDef::ModuleDef(def) = def else { return None; };\n \n     let current_module = ctx.sema.scope(path.syntax())?.module();\n     let target_module = def.module(ctx.db())?;"}, {"sha": "0bcb5728311b73db3f6c757a34864c6ee3ac2cc8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -261,12 +261,12 @@ fn main() {\n }\n \n //- /foo.rs\n-enum Foo {\n+pub enum Foo {\n     Bar,\n }\n \",\n             r\"\n-enum Foo {\n+pub enum Foo {\n     Bar,\n     Baz,\n }\n@@ -310,7 +310,7 @@ fn main() {\n             generate_enum_variant,\n             r\"\n mod m {\n-    enum Foo {\n+    pub enum Foo {\n         Bar,\n     }\n }\n@@ -320,7 +320,7 @@ fn main() {\n \",\n             r\"\n mod m {\n-    enum Foo {\n+    pub enum Foo {\n         Bar,\n         Baz,\n     }\n@@ -516,10 +516,10 @@ mod foo;\n use foo::Foo::Bar$0;\n \n //- /foo.rs\n-enum Foo {}\n+pub enum Foo {}\n \",\n             r\"\n-enum Foo {\n+pub enum Foo {\n     Bar,\n }\n \","}, {"sha": "57f198748cb76ef9a285b538a2b09a6071f8db67", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1324,7 +1324,7 @@ fn foo() {\n             generate_function,\n             r\"\n mod bar {\n-    mod baz {}\n+    pub mod baz {}\n }\n \n fn foo() {\n@@ -1333,7 +1333,7 @@ fn foo() {\n \",\n             r\"\n mod bar {\n-    mod baz {\n+    pub mod baz {\n         pub(crate) fn my_fn() {\n             ${0:todo!()}\n         }"}, {"sha": "11db6ae7f7b811825d59fd8b08c6e872c179195a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n                         NodeOrToken::Node(n) => {\n                             format_to!(current_arg, \"{n}\");\n                         },\n-                        NodeOrToken::Token(t) if t.kind() == COMMA=> {\n+                        NodeOrToken::Token(t) if t.kind() == COMMA => {\n                             existing_args.push(current_arg.trim().into());\n                             current_arg.clear();\n                         },\n@@ -238,14 +238,14 @@ fn main() {\n             &add_macro_decl(\n                 r#\"\n fn main() {\n-    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+    print!(\"{:b} {x + 1:b} {Struct(1, 2)}$0\", 1);\n }\n \"#,\n             ),\n             &add_macro_decl(\n                 r#\"\n fn main() {\n-    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+    print!(\"{:b} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n \"#,\n             ),"}, {"sha": "99ae60e07bcfa7283e274fbdcd5d91743052c4c2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use syntax::{\n     ast::{self, AstNode, AstToken},\n-    match_ast, NodeOrToken, SyntaxElement, TextSize, T,\n+    match_ast, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -22,7 +22,36 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n // ```\n pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n+    let macro_calls = if ctx.has_empty_selection() {\n+        vec![ctx.find_node_at_offset::<ast::MacroCall>()?]\n+    } else {\n+        ctx.covering_element()\n+            .as_node()?\n+            .descendants()\n+            .filter(|node| ctx.selection_trimmed().contains_range(node.text_range()))\n+            .filter_map(ast::MacroCall::cast)\n+            .collect()\n+    };\n+\n+    let replacements =\n+        macro_calls.into_iter().filter_map(compute_dbg_replacement).collect::<Vec<_>>();\n+    if replacements.is_empty() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"remove_dbg\", AssistKind::Refactor),\n+        \"Remove dbg!()\",\n+        ctx.selection_trimmed(),\n+        |builder| {\n+            for (range, text) in replacements {\n+                builder.replace(range, text);\n+            }\n+        },\n+    )\n+}\n+\n+fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, String)> {\n     let tt = macro_call.token_tree()?;\n     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);\n     if macro_call.path()?.segment()?.name_ref()?.text() != \"dbg\"\n@@ -41,7 +70,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n \n     let macro_expr = ast::MacroExpr::cast(macro_call.syntax().parent()?)?;\n     let parent = macro_expr.syntax().parent()?;\n-    let (range, text) = match &*input_expressions {\n+    Some(match &*input_expressions {\n         // dbg!()\n         [] => {\n             match_ast! {\n@@ -107,10 +136,6 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n         }\n         // dbg!(expr0, expr1, ...)\n         exprs => (macro_call.syntax().text_range(), format!(\"({})\", exprs.iter().format(\", \"))),\n-    };\n-\n-    acc.add(AssistId(\"remove_dbg\", AssistKind::Refactor), \"Remove dbg!()\", range, |builder| {\n-        builder.replace(range, text);\n     })\n }\n \n@@ -238,4 +263,28 @@ fn foo() {\n         check(r#\"$0dbg!(0, 1)\"#, r#\"(0, 1)\"#);\n         check(r#\"$0dbg!(0, (1, 2))\"#, r#\"(0, (1, 2))\"#);\n     }\n+\n+    #[test]\n+    fn test_range() {\n+        check(\n+            r#\"\n+fn f() {\n+    dbg!(0) + $0dbg!(1);\n+    dbg!(())$0\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    dbg!(0) + 1;\n+    ()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_range_partial() {\n+        check_assist_not_applicable(remove_dbg, r#\"$0dbg$0!(0)\"#);\n+        check_assist_not_applicable(remove_dbg, r#\"$0dbg!(0$0)\"#);\n+    }\n }"}, {"sha": "6fa15b28e4efcfac2b42fba2fc938b9c920b69c8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1019,8 +1019,6 @@ struct Foo {\n impl foo::Bar for Foo {\n     $0type Qux;\n \n-    const Baz: usize = 42;\n-\n     const Fez: usize;\n \n     fn foo() {"}, {"sha": "c09317572acf2b8fb935fd8e8f7ff6d72f4fe0ee", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -741,15 +741,15 @@ mod m {\n     fn frobnicate() {}\n }\n fn main() {\n-    m::frobnicate$0() {}\n+    m::frobnicate$0();\n }\n \"#####,\n         r#####\"\n mod m {\n     $0pub(crate) fn frobnicate() {}\n }\n fn main() {\n-    m::frobnicate() {}\n+    m::frobnicate();\n }\n \"#####,\n     )"}, {"sha": "68c31b4f8e92285586f14ebe4f3caf119170790b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -119,6 +119,10 @@ pub fn filter_assoc_items(\n                 (default_methods, def.body()),\n                 (DefaultMethods::Only, Some(_)) | (DefaultMethods::No, None)\n             ),\n+            ast::AssocItem::Const(def) => matches!(\n+                (default_methods, def.body()),\n+                (DefaultMethods::Only, Some(_)) | (DefaultMethods::No, None)\n+            ),\n             _ => default_methods == DefaultMethods::No,\n         })\n         .collect::<Vec<_>>()"}, {"sha": "11310e2f1291e63b3e40681720b608aacee7ae38", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "7384a3f2d80b4141cec4fdc2f0bb7799bc20e738", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 139, "deletions": 20, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -157,7 +157,7 @@ fn complete_trait_impl(\n                     add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n                 }\n                 (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n-                    add_type_alias_impl(acc, ctx, replacement_range, type_alias)\n+                    add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n                 }\n                 (hir::AssocItem::Const(const_), All | Const) => {\n                     add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n@@ -236,9 +236,7 @@ fn get_transformed_assoc_item(\n     );\n \n     transform.apply(assoc_item.syntax());\n-    if let ast::AssocItem::Fn(func) = &assoc_item {\n-        func.remove_attrs_and_docs();\n-    }\n+    assoc_item.remove_attrs_and_docs();\n     Some(assoc_item)\n }\n \n@@ -247,24 +245,50 @@ fn add_type_alias_impl(\n     ctx: &CompletionContext<'_>,\n     replacement_range: TextRange,\n     type_alias: hir::TypeAlias,\n+    impl_def: hir::Impl,\n ) {\n-    let alias_name = type_alias.name(ctx.db);\n-    let (alias_name, escaped_name) =\n-        (alias_name.unescaped().to_smol_str(), alias_name.to_smol_str());\n+    let alias_name = type_alias.name(ctx.db).unescaped().to_smol_str();\n \n     let label = format!(\"type {} =\", alias_name);\n-    let replacement = format!(\"type {} = \", escaped_name);\n \n     let mut item = CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label);\n     item.lookup_by(format!(\"type {}\", alias_name))\n         .set_documentation(type_alias.docs(ctx.db))\n         .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n-    match ctx.config.snippet_cap {\n-        Some(cap) => item\n-            .snippet_edit(cap, TextEdit::replace(replacement_range, format!(\"{}$0;\", replacement))),\n-        None => item.text_edit(TextEdit::replace(replacement_range, replacement)),\n-    };\n-    item.add_to(acc);\n+\n+    if let Some(source) = ctx.sema.source(type_alias) {\n+        let assoc_item = ast::AssocItem::TypeAlias(source.value);\n+        if let Some(transformed_item) = get_transformed_assoc_item(ctx, assoc_item, impl_def) {\n+            let transformed_ty = match transformed_item {\n+                ast::AssocItem::TypeAlias(ty) => ty,\n+                _ => unreachable!(),\n+            };\n+\n+            let start = transformed_ty.syntax().text_range().start();\n+            let Some(end) = transformed_ty\n+                .eq_token()\n+                .map(|tok| tok.text_range().start())\n+                .or(transformed_ty.semicolon_token().map(|tok| tok.text_range().start())) else { return };\n+\n+            let len = end - start;\n+            let mut decl = transformed_ty.syntax().text().slice(..len).to_string();\n+            if !decl.ends_with(' ') {\n+                decl.push(' ');\n+            }\n+            decl.push_str(\"= \");\n+\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"{}$0;\", decl);\n+                    item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n+                }\n+                None => {\n+                    item.text_edit(TextEdit::replace(replacement_range, decl));\n+                }\n+            };\n+            item.add_to(acc);\n+        }\n+    }\n }\n \n fn add_const_impl(\n@@ -309,7 +333,6 @@ fn add_const_impl(\n }\n \n fn make_const_compl_syntax(const_: &ast::Const, needs_whitespace: bool) -> String {\n-    const_.remove_attrs_and_docs();\n     let const_ = if needs_whitespace {\n         insert_whitespace_into_node::insert_ws_into(const_.syntax().clone())\n     } else {\n@@ -333,8 +356,6 @@ fn make_const_compl_syntax(const_: &ast::Const, needs_whitespace: bool) -> Strin\n }\n \n fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n-    node.remove_attrs_and_docs();\n-\n     let node = if needs_whitespace {\n         insert_whitespace_into_node::insert_ws_into(node.syntax().clone())\n     } else {\n@@ -350,9 +371,7 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n         .map_or(end, |f| f.text_range().start());\n \n     let len = end - start;\n-    let range = TextRange::new(0.into(), len);\n-\n-    let syntax = node.text().slice(range).to_string();\n+    let syntax = node.text().slice(..len).to_string();\n \n     syntax.trim_end().to_owned()\n }\n@@ -1160,6 +1179,106 @@ impl Foo for Test {\n     $0\n }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn includes_gat_generics() {\n+        check_edit(\n+            \"type Ty\",\n+            r#\"\n+trait Tr<'b> {\n+    type Ty<'a: 'b, T: Copy, const C: usize>;\n+}\n+\n+impl<'b> Tr<'b> for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr<'b> {\n+    type Ty<'a: 'b, T: Copy, const C: usize>;\n+}\n+\n+impl<'b> Tr<'b> for () {\n+    type Ty<'a: 'b, T: Copy, const C: usize> = $0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strips_comments() {\n+        check_edit(\n+            \"fn func\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    fn func();\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    fn func();\n+}\n+impl Tr for () {\n+    fn func() {\n+    $0\n+}\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"const C\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    const C: usize;\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    const C: usize;\n+}\n+impl Tr for () {\n+    const C: usize = $0;\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"type Item\",\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    type Item;\n+}\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    /// docs\n+    #[attr]\n+    type Item;\n+}\n+impl Tr for () {\n+    type Item = $0;\n+}\n \"#,\n         );\n     }"}, {"sha": "c142a7305f9e94ac6e68ae2d02be21d36ffb5c3a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -681,9 +681,13 @@ fn classify_name_ref(\n                     ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n                     ast::Item::Fn(it) => it.body().is_none(),\n                     ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n-                    ast::Item::Module(it) => it.item_list().is_none(),\n+                    ast::Item::Module(it) => {\n+                        it.item_list().is_none() && it.semicolon_token().is_none()\n+                    }\n                     ast::Item::Static(it) => it.body().is_none(),\n-                    ast::Item::Struct(it) => it.field_list().is_none(),\n+                    ast::Item::Struct(it) => {\n+                        it.field_list().is_none() && it.semicolon_token().is_none()\n+                    }\n                     ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n                     ast::Item::TypeAlias(it) => it.ty().is_none(),\n                     ast::Item::Union(it) => it.record_field_list().is_none(),"}, {"sha": "8ed6cb3cf867ef851c417b4c3316189327b90c88", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -245,3 +245,35 @@ impl Test for () {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn after_unit_struct() {\n+    check(\n+        r#\"struct S; f$0\"#,\n+        expect![[r#\"\n+            ma makro!(\u2026)           macro_rules! makro\n+            md module\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw fn\n+            kw impl\n+            kw mod\n+            kw pub\n+            kw pub(crate)\n+            kw pub(super)\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            sn macro_rules\n+            sn tfn (Test function)\n+            sn tmod (Test module)\n+        \"#]],\n+    );\n+}"}, {"sha": "f48cce58c6e7386a68cbe7f341aa6027992bc8f5", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "1b8f56187a02bf78f214fc0dacb7087ba16fc45d", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -58,8 +58,11 @@ impl LineIndex {\n         let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n-        let mut newlines = vec![0.into()];\n-        let mut curr_row @ mut curr_col = 0.into();\n+        let mut newlines = Vec::with_capacity(16);\n+        newlines.push(TextSize::from(0));\n+\n+        let mut curr_row = 0.into();\n+        let mut curr_col = 0.into();\n         let mut line = 0;\n         for c in text.chars() {\n             let c_len = TextSize::of(c);"}, {"sha": "313346ee131539b9210714159d0164b5b464e8c2", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -104,6 +104,11 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n                 extracted_expressions.push(Arg::Placeholder);\n                 state = State::NotArg;\n             }\n+            (State::MaybeArg, ':') => {\n+                output.push(chr);\n+                extracted_expressions.push(Arg::Placeholder);\n+                state = State::FormatOpts;\n+            }\n             (State::MaybeArg, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n                     current_expr.push('\\\\');\n@@ -118,44 +123,41 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n                     state = State::Expr;\n                 }\n             }\n-            (State::Ident | State::Expr, '}') => {\n-                if inexpr_open_count == 0 {\n-                    output.push(chr);\n-\n-                    if matches!(state, State::Expr) {\n-                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n-                    } else {\n-                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n-                    }\n-\n-                    current_expr = String::new();\n-                    state = State::NotArg;\n-                } else {\n-                    // We're closing one brace met before inside of the expression.\n-                    current_expr.push(chr);\n-                    inexpr_open_count -= 1;\n-                }\n-            }\n             (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n                 // path separator\n                 state = State::Expr;\n                 current_expr.push_str(\"::\");\n                 chars.next();\n             }\n-            (State::Ident | State::Expr, ':') => {\n+            (State::Ident | State::Expr, ':' | '}') => {\n                 if inexpr_open_count == 0 {\n-                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                    output.push(chr);\n+                    let trimmed = current_expr.trim();\n \n-                    if matches!(state, State::Expr) {\n-                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    // if the expression consists of a single number, like \"0\" or \"12\", it can refer to\n+                    // format args in the order they are specified.\n+                    // see: https://doc.rust-lang.org/std/fmt/#positional-parameters\n+                    if trimmed.chars().fold(true, |only_num, c| c.is_ascii_digit() && only_num) {\n+                        output.push_str(trimmed);\n+                    } else if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(trimmed.into()));\n                     } else {\n-                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                        extracted_expressions.push(Arg::Ident(trimmed.into()));\n                     }\n \n-                    current_expr = String::new();\n-                    state = State::FormatOpts;\n-                } else {\n+                    output.push(chr);\n+                    current_expr.clear();\n+                    state = if chr == ':' {\n+                        State::FormatOpts\n+                    } else if chr == '}' {\n+                        State::NotArg\n+                    } else {\n+                        unreachable!()\n+                    };\n+                } else if chr == '}' {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                } else if chr == ':' {\n                     // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n                     current_expr.push(chr);\n                 }\n@@ -219,6 +221,10 @@ mod tests {\n             (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n             (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n             (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{:1$}\", expect![[r\"{:1\\$}; $1\"]]),\n+            (\"{:>padding$}\", expect![[r\"{:>padding\\$}; $1\"]]),\n+            (\"{}, {}, {0}\", expect![[r\"{}, {}, {0}; $1, $2\"]]),\n+            (\"{}, {}, {0:b}\", expect![[r\"{}, {}, {0:b}; $1, $2\"]]),\n             (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n             (\"{malformed\", expect![[\"-\"]]),\n             (\"malformed}\", expect![[\"-\"]]),"}, {"sha": "7e9a1125d751c9525010ca062d57b450489ba9d5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "870c78d1f1eb729277df8d71da89ecab3e675f48", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -5,10 +5,7 @@ use crate::{Diagnostic, DiagnosticsContext};\n // This diagnostic is shown for macro expansion errors.\n pub(crate) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = d\n-        .precise_location\n-        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.node.clone()).range);\n-\n+    let display_range = ctx.resolve_precise_location(&d.node, d.precise_location);\n     Diagnostic::new(\"macro-error\", d.message.clone(), display_range).experimental()\n }\n "}, {"sha": "d8f2a9de9818fca43f638f6e8e8031abc9887d78", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -268,12 +268,12 @@ fn main() {\n     foo::Foo { bar: 3, $0baz: false};\n }\n //- /foo.rs\n-struct Foo {\n+pub struct Foo {\n     bar: i32\n }\n \"#,\n             r#\"\n-struct Foo {\n+pub struct Foo {\n     bar: i32,\n     pub(crate) baz: bool\n }"}, {"sha": "87531f4acfb753b0feb68c58caf76b3518bc6c5d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -9,10 +9,7 @@ pub(crate) fn unresolved_macro_call(\n     d: &hir::UnresolvedMacroCall,\n ) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = d\n-        .precise_location\n-        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.macro_call.clone()).range);\n-\n+    let display_range = ctx.resolve_precise_location(&d.macro_call, d.precise_location);\n     let bang = if d.is_bang { \"!\" } else { \"\" };\n     Diagnostic::new(\n         \"unresolved-macro-call\","}, {"sha": "23818d883f73181d7c684523d21637cda93b1085", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,5 +1,4 @@\n use hir::db::DefDatabase;\n-use syntax::NodeOrToken;\n \n use crate::{Diagnostic, DiagnosticsContext, Severity};\n \n@@ -19,16 +18,7 @@ pub(crate) fn unresolved_proc_macro(\n     proc_attr_macros_enabled: bool,\n ) -> Diagnostic {\n     // Use more accurate position if available.\n-    let display_range = (|| {\n-        let precise_location = d.precise_location?;\n-        let root = ctx.sema.parse_or_expand(d.node.file_id)?;\n-        match root.covering_element(precise_location) {\n-            NodeOrToken::Node(it) => Some(ctx.sema.original_range(&it)),\n-            NodeOrToken::Token(it) => d.node.with_value(it).original_file_range_opt(ctx.sema.db),\n-        }\n-    })()\n-    .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.node.clone()))\n-    .range;\n+    let display_range = ctx.resolve_precise_location(&d.node, d.precise_location);\n \n     let config_enabled = match d.kind {\n         hir::MacroKind::Attr => proc_macros_enabled && proc_attr_macros_enabled,"}, {"sha": "289ed0458c67dbc4aea2f677dc9e5a88037e91eb", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/useless_braces.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -71,9 +71,9 @@ use a;\n use a::{c, d::e};\n \n mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n+    pub mod c {}\n+    pub mod d {\n+        pub mod e {}\n     }\n }\n \"#,\n@@ -87,9 +87,9 @@ use a::{\n };\n \n mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n+    pub mod c {}\n+    pub mod d {\n+        pub mod e {}\n     }\n }\n \"#,\n@@ -116,11 +116,11 @@ use b;\n         );\n         check_fix(\n             r#\"\n-mod a { mod c {} }\n+mod a { pub mod c {} }\n use a::{c$0};\n \"#,\n             r#\"\n-mod a { mod c {} }\n+mod a { pub mod c {} }\n use a::c;\n \"#,\n         );\n@@ -136,11 +136,11 @@ use a;\n         );\n         check_fix(\n             r#\"\n-mod a { mod c {} mod d { mod e {} } }\n+mod a { pub mod c {} pub mod d { pub mod e {} } }\n use a::{c, d::{e$0}};\n \"#,\n             r#\"\n-mod a { mod c {} mod d { mod e {} } }\n+mod a { pub mod c {} pub mod d { pub mod e {} } }\n use a::{c, d::e};\n \"#,\n         );"}, {"sha": "d81e36a1f86321428d55f3f99fbb229e7dc0d0a2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -182,6 +182,28 @@ struct DiagnosticsContext<'a> {\n     resolve: &'a AssistResolveStrategy,\n }\n \n+impl<'a> DiagnosticsContext<'a> {\n+    fn resolve_precise_location(\n+        &self,\n+        node: &InFile<SyntaxNodePtr>,\n+        precise_location: Option<TextRange>,\n+    ) -> TextRange {\n+        let sema = &self.sema;\n+        (|| {\n+            let precise_location = precise_location?;\n+            let root = sema.parse_or_expand(node.file_id)?;\n+            match root.covering_element(precise_location) {\n+                syntax::NodeOrToken::Node(it) => Some(sema.original_range(&it)),\n+                syntax::NodeOrToken::Token(it) => {\n+                    node.with_value(it).original_file_range_opt(sema.db)\n+                }\n+            }\n+        })()\n+        .unwrap_or_else(|| sema.diagnostics_display_range(node.clone()))\n+        .range\n+    }\n+}\n+\n pub fn diagnostics(\n     db: &RootDatabase,\n     config: &DiagnosticsConfig,"}, {"sha": "7be62a8d9ffe905035c530ab3d86ae305e7d4021", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -5,7 +5,7 @@ description = \"Structural search and replace of Rust code\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "73f202630f15b86396d19ae0638ebd140f5ebb5d", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "43f7a529bc2979168dcef1d96a2daf67aafe1b28", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -289,10 +289,10 @@ mod b;\n enum E { X(Foo$0) }\n \n //- /a.rs\n-struct Foo;\n-     //^^^\n+pub struct Foo;\n+         //^^^\n //- /b.rs\n-struct Foo;\n+pub struct Foo;\n \"#,\n         );\n     }"}, {"sha": "838fb18c3d590e273819af63ec7eae6ae5c2ff6b", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -119,7 +119,14 @@ pub(crate) fn hover(\n         });\n     }\n \n-    let in_attr = matches!(original_token.parent().and_then(ast::TokenTree::cast), Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind())));\n+    let in_attr = original_token\n+        .parent_ancestors()\n+        .filter_map(ast::Item::cast)\n+        .any(|item| sema.is_attr_macro_call(&item))\n+        && !matches!(\n+            original_token.parent().and_then(ast::TokenTree::cast),\n+            Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind()))\n+        );\n     // prefer descending the same token kind in attribute expansions, in normal macros text\n     // equivalency is more important\n     let descended = if in_attr {"}, {"sha": "37384c4e7e07501dffe853c1e31d02309618af41", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 172, "deletions": 71, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,7 +1,10 @@\n use std::fmt;\n \n use either::Either;\n-use hir::{known, Callable, HasVisibility, HirDisplay, Mutability, Semantics, TypeInfo};\n+use hir::{\n+    known, Adjust, AutoBorrow, Callable, HasVisibility, HirDisplay, Mutability, OverloadedDeref,\n+    PointerCast, Safety, Semantics, TypeInfo,\n+};\n use ide_db::{\n     base_db::FileRange, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty, FxHashMap,\n     RootDatabase,\n@@ -22,7 +25,7 @@ pub struct InlayHintsConfig {\n     pub type_hints: bool,\n     pub parameter_hints: bool,\n     pub chaining_hints: bool,\n-    pub reborrow_hints: ReborrowHints,\n+    pub adjustment_hints: AdjustmentHints,\n     pub closure_return_type_hints: ClosureReturnTypeHints,\n     pub binding_mode_hints: bool,\n     pub lifetime_elision_hints: LifetimeElisionHints,\n@@ -48,9 +51,9 @@ pub enum LifetimeElisionHints {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum ReborrowHints {\n+pub enum AdjustmentHints {\n     Always,\n-    MutableOnly,\n+    ReborrowOnly,\n     Never,\n }\n \n@@ -61,7 +64,8 @@ pub enum InlayKind {\n     ClosingBraceHint,\n     ClosureReturnTypeHint,\n     GenericParamListHint,\n-    ImplicitReborrowHint,\n+    AdjustmentHint,\n+    AdjustmentHintClosingParenthesis,\n     LifetimeHint,\n     ParameterHint,\n     TypeHint,\n@@ -115,6 +119,12 @@ impl From<String> for InlayHintLabel {\n     }\n }\n \n+impl From<&str> for InlayHintLabel {\n+    fn from(s: &str) -> Self {\n+        Self { parts: vec![InlayHintLabelPart { text: s.into(), linked_location: None }] }\n+    }\n+}\n+\n impl fmt::Display for InlayHintLabel {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.parts.iter().map(|part| &part.text).format(\"\"))\n@@ -180,7 +190,7 @@ impl fmt::Debug for InlayHintLabelPart {\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,\n-    range_limit: Option<FileRange>,\n+    range_limit: Option<TextRange>,\n     config: &InlayHintsConfig,\n ) -> Vec<InlayHint> {\n     let _p = profile::span(\"inlay_hints\");\n@@ -195,7 +205,7 @@ pub(crate) fn inlay_hints(\n \n         let hints = |node| hints(&mut acc, &famous_defs, config, file_id, node);\n         match range_limit {\n-            Some(FileRange { range, .. }) => match file.covering_element(range) {\n+            Some(range) => match file.covering_element(range) {\n                 NodeOrToken::Token(_) => return acc,\n                 NodeOrToken::Node(n) => n\n                     .descendants()\n@@ -221,6 +231,7 @@ fn hints(\n         match node {\n             ast::Expr(expr) => {\n                 chaining_hints(hints, sema, &famous_defs, config, file_id, &expr);\n+                adjustment_hints(hints, sema, config, &expr);\n                 match expr {\n                     ast::Expr::CallExpr(it) => param_name_hints(hints, sema, config, ast::Expr::from(it)),\n                     ast::Expr::MethodCallExpr(it) => {\n@@ -229,7 +240,7 @@ fn hints(\n                     ast::Expr::ClosureExpr(it) => closure_ret_hints(hints, sema, &famous_defs, config, file_id, it),\n                     // We could show reborrows for all expressions, but usually that is just noise to the user\n                     // and the main point here is to show why \"moving\" a mutable reference doesn't necessarily move it\n-                    ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n+                    // ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n                     _ => None,\n                 }\n             },\n@@ -617,30 +628,95 @@ fn closure_ret_hints(\n     Some(())\n }\n \n-fn reborrow_hints(\n+fn adjustment_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<'_, RootDatabase>,\n     config: &InlayHintsConfig,\n     expr: &ast::Expr,\n ) -> Option<()> {\n-    if config.reborrow_hints == ReborrowHints::Never {\n+    if config.adjustment_hints == AdjustmentHints::Never {\n+        return None;\n+    }\n+\n+    if let ast::Expr::ParenExpr(_) = expr {\n+        // These inherit from the inner expression which would result in duplicate hints\n         return None;\n     }\n \n+    let parent = expr.syntax().parent().and_then(ast::Expr::cast);\n     let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n     let desc_expr = descended.as_ref().unwrap_or(expr);\n-    let mutability = sema.is_implicit_reborrow(desc_expr)?;\n-    let label = match mutability {\n-        hir::Mutability::Shared if config.reborrow_hints != ReborrowHints::MutableOnly => \"&*\",\n-        hir::Mutability::Mut => \"&mut *\",\n-        _ => return None,\n+    let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n+    let needs_parens = match parent {\n+        Some(parent) => {\n+            match parent {\n+                ast::Expr::AwaitExpr(_)\n+                | ast::Expr::CallExpr(_)\n+                | ast::Expr::CastExpr(_)\n+                | ast::Expr::FieldExpr(_)\n+                | ast::Expr::MethodCallExpr(_)\n+                | ast::Expr::TryExpr(_) => true,\n+                // FIXME: shorthands need special casing, though not sure if adjustments are even valid there\n+                ast::Expr::RecordExpr(_) => false,\n+                ast::Expr::IndexExpr(index) => index.base().as_ref() == Some(expr),\n+                _ => false,\n+            }\n+        }\n+        None => false,\n     };\n-    acc.push(InlayHint {\n-        range: expr.syntax().text_range(),\n-        kind: InlayKind::ImplicitReborrowHint,\n-        label: label.to_string().into(),\n-        tooltip: Some(InlayTooltip::String(\"Compiler inserted reborrow\".into())),\n-    });\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHint,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    for adjustment in adjustments.into_iter().rev() {\n+        // FIXME: Add some nicer tooltips to each of these\n+        let text = match adjustment {\n+            Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n+                \"<never-to-any>\"\n+            }\n+            Adjust::Deref(None) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n+            // some of these could be represented via `as` casts, but that's not too nice and\n+            // handling everything as a prefix expr makes the `(` and `)` insertion easier\n+            Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n+                match cast {\n+                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n+                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                    PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n+                        \"<closure-to-unsafe-fn-pointer>\"\n+                    }\n+                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n+                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n+                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n+                    PointerCast::Unsize => \"<unsize>\",\n+                }\n+            }\n+            _ => continue,\n+        };\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHint,\n+            label: text.into(),\n+            tooltip: None,\n+        });\n+    }\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHintClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n     Some(())\n }\n \n@@ -1213,12 +1289,11 @@ fn get_callable(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::base_db::FileRange;\n     use itertools::Itertools;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n-    use crate::inlay_hints::ReborrowHints;\n+    use crate::inlay_hints::AdjustmentHints;\n     use crate::{fixture, inlay_hints::InlayHintsConfig, LifetimeElisionHints};\n \n     use super::ClosureReturnTypeHints;\n@@ -1230,7 +1305,7 @@ mod tests {\n         chaining_hints: false,\n         lifetime_elision_hints: LifetimeElisionHints::Never,\n         closure_return_type_hints: ClosureReturnTypeHints::Never,\n-        reborrow_hints: ReborrowHints::Always,\n+        adjustment_hints: AdjustmentHints::Never,\n         binding_mode_hints: false,\n         hide_named_constructor_hints: false,\n         hide_closure_initialization_hints: false,\n@@ -1242,7 +1317,6 @@ mod tests {\n         type_hints: true,\n         parameter_hints: true,\n         chaining_hints: true,\n-        reborrow_hints: ReborrowHints::Always,\n         closure_return_type_hints: ClosureReturnTypeHints::WithBlock,\n         binding_mode_hints: true,\n         lifetime_elision_hints: LifetimeElisionHints::Always,\n@@ -1838,10 +1912,7 @@ fn main() {\n             .inlay_hints(\n                 &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n                 file_id,\n-                Some(FileRange {\n-                    file_id,\n-                    range: TextRange::new(TextSize::from(500), TextSize::from(600)),\n-                }),\n+                Some(TextRange::new(TextSize::from(500), TextSize::from(600))),\n             )\n             .unwrap();\n         let actual =\n@@ -2845,48 +2916,6 @@ impl () {\n         );\n     }\n \n-    #[test]\n-    fn hints_implicit_reborrow() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                reborrow_hints: ReborrowHints::Always,\n-                parameter_hints: true,\n-                ..DISABLED_CONFIG\n-            },\n-            r#\"\n-fn __() {\n-    let unique = &mut ();\n-    let r_mov = unique;\n-    let foo: &mut _ = unique;\n-                    //^^^^^^ &mut *\n-    ref_mut_id(unique);\n-             //^^^^^^ mut_ref\n-             //^^^^^^ &mut *\n-    let shared = ref_id(unique);\n-                      //^^^^^^ shared_ref\n-                      //^^^^^^ &*\n-    let mov = shared;\n-    let r_mov: &_ = shared;\n-    ref_id(shared);\n-         //^^^^^^ shared_ref\n-\n-    identity(unique);\n-    identity(shared);\n-}\n-fn identity<T>(t: T) -> T {\n-    t\n-}\n-fn ref_mut_id(mut_ref: &mut ()) -> &mut () {\n-    mut_ref\n-  //^^^^^^^ &mut *\n-}\n-fn ref_id(shared_ref: &()) -> &() {\n-    shared_ref\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn hints_binding_modes() {\n         check_with_config(\n@@ -2994,4 +3023,76 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn adjustment_hints() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: coerce_unsized\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^<never-to-any>\n+    let _: &u32        = &mut 0;\n+                       //^^^^^^&\n+                       //^^^^^^*\n+    let _: &mut u32    = &mut 0;\n+                       //^^^^^^&mut $\n+                       //^^^^^^*\n+    let _: *const u32  = &mut 0;\n+                       //^^^^^^&raw const $\n+                       //^^^^^^*\n+    let _: *mut u32    = &mut 0;\n+                       //^^^^^^&raw mut $\n+                       //^^^^^^*\n+    let _: fn()        = main;\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main;\n+                       //^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main as fn();\n+                       //^^^^^^^^^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+    let _: fn()        = || {};\n+                       //^^^^^<closure-to-fn-pointer>\n+    let _: unsafe fn() = || {};\n+                       //^^^^^<closure-to-unsafe-fn-pointer>\n+    let _: *const u32  = &mut 0u32 as *mut u32;\n+                       //^^^^^^^^^^^^^^^^^^^^^<mut-ptr-to-const-ptr>\n+    let _: &mut [_]    = &mut [0; 0];\n+                       //^^^^^^^^^^^<unsize>\n+                       //^^^^^^^^^^^&mut $\n+                       //^^^^^^^^^^^*\n+\n+    Struct.consume();\n+    Struct.by_ref();\n+  //^^^^^^(\n+  //^^^^^^&\n+  //^^^^^^)\n+    Struct.by_ref_mut();\n+  //^^^^^^(\n+  //^^^^^^&mut $\n+  //^^^^^^)\n+\n+    (&Struct).consume();\n+   //^^^^^^^*\n+    (&Struct).by_ref();\n+\n+    (&mut Struct).consume();\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref();\n+   //^^^^^^^^^^^&\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref_mut();\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Struct;\n+impl Struct {\n+    fn consume(self) {}\n+    fn by_ref(&self) {}\n+    fn by_ref_mut(&mut self) {}\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "7402e86f36fa411c5e6f713a0a1fc8e76030e11c", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -81,8 +81,8 @@ pub use crate::{\n     highlight_related::{HighlightRelatedConfig, HighlightedRange},\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{\n-        ClosureReturnTypeHints, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n-        InlayTooltip, LifetimeElisionHints, ReborrowHints,\n+        AdjustmentHints, ClosureReturnTypeHints, InlayHint, InlayHintLabel, InlayHintsConfig,\n+        InlayKind, InlayTooltip, LifetimeElisionHints,\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n@@ -367,7 +367,7 @@ impl Analysis {\n         &self,\n         config: &InlayHintsConfig,\n         file_id: FileId,\n-        range: Option<FileRange>,\n+        range: Option<TextRange>,\n     ) -> Cancellable<Vec<InlayHint>> {\n         self.with_db(|db| inlay_hints::inlay_hints(db, file_id, range, config))\n     }"}, {"sha": "fcbf6d8e58c4b07fd66cda4e0b3f8f49f696bfda", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,17 +1,17 @@\n //! This module generates [moniker](https://microsoft.github.io/language-server-protocol/specifications/lsif/0.6.0/specification/#exportsImports)\n //! for LSIF and LSP.\n \n-use hir::{db::DefDatabase, AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n+use hir::{AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n use ide_db::{\n-    base_db::{CrateOrigin, FileId, FileLoader, FilePosition, LangCrateOrigin},\n+    base_db::{CrateOrigin, FilePosition, LangCrateOrigin},\n     defs::{Definition, IdentClass},\n     helpers::pick_best_token,\n     RootDatabase,\n };\n use itertools::Itertools;\n use syntax::{AstNode, SyntaxKind::*, T};\n \n-use crate::{doc_links::token_as_doc_comment, RangeInfo};\n+use crate::{doc_links::token_as_doc_comment, parent_module::crates_for, RangeInfo};\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum MonikerDescriptorKind {\n@@ -77,25 +77,13 @@ pub struct PackageInformation {\n     pub version: Option<String>,\n }\n \n-pub(crate) fn crate_for_file(db: &RootDatabase, file_id: FileId) -> Option<Crate> {\n-    for &krate in db.relevant_crates(file_id).iter() {\n-        let crate_def_map = db.crate_def_map(krate);\n-        for (_, data) in crate_def_map.modules() {\n-            if data.origin.file_id() == Some(file_id) {\n-                return Some(krate.into());\n-            }\n-        }\n-    }\n-    None\n-}\n-\n pub(crate) fn moniker(\n     db: &RootDatabase,\n     FilePosition { file_id, offset }: FilePosition,\n ) -> Option<RangeInfo<Vec<MonikerResult>>> {\n     let sema = &Semantics::new(db);\n     let file = sema.parse(file_id).syntax().clone();\n-    let current_crate = crate_for_file(db, file_id)?;\n+    let current_crate: hir::Crate = crates_for(db, file_id).pop()?.into();\n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT\n         | INT_NUMBER"}, {"sha": "0f758cfa2d344dec2fa3dd2546aa1acae9fb9edf", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -16,6 +16,7 @@ use ide_db::{\n     search::{ReferenceCategory, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use stdx::hash::NoHashHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n@@ -86,6 +87,7 @@ pub(crate) fn find_all_refs(\n                         file_id,\n                         refs.into_iter()\n                             .map(|file_ref| (file_ref.range, file_ref.category))\n+                            .unique()\n                             .collect(),\n                     )\n                 })"}, {"sha": "e7412d27faf446452a33962d6e70ca5220cc1122", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1345,5 +1345,36 @@ fn f<F: FnOnce(u8, u16) -> i32>(f: F) {\n                  ^^  ---\n             \"#]],\n         );\n+        check(\n+            r#\"\n+fn f<T, F: FnOnce(&T, u16) -> &T>(f: F) {\n+    f($0)\n+}\n+\"#,\n+            expect![[r#\"\n+                (&T, u16) -> &T\n+                 ^^  ---\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn regression_13579() {\n+        check(\n+            r#\"\n+fn f() {\n+    take(2)($0);\n+}\n+\n+fn take<C, Error>(\n+    count: C\n+) -> impl Fn() -> C  {\n+    move || count\n+}\n+\"#,\n+            expect![[r#\"\n+                () -> i32\n+            \"#]],\n+        );\n     }\n }"}, {"sha": "2380cf7381c1ceb5223fcaeba8a22e837e92717e", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -13,7 +13,8 @@ use syntax::{AstNode, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n use crate::{\n     hover::hover_for_definition,\n-    moniker::{crate_for_file, def_to_moniker, MonikerResult},\n+    moniker::{def_to_moniker, MonikerResult},\n+    parent_module::crates_for,\n     Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n     TryToNav,\n };\n@@ -99,7 +100,7 @@ fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n \n impl StaticIndex<'_> {\n     fn add_file(&mut self, file_id: FileId) {\n-        let current_crate = crate_for_file(self.db, file_id);\n+        let current_crate = crates_for(self.db, file_id).pop().map(Into::into);\n         let folds = self.analysis.folding_ranges(file_id).unwrap();\n         let inlay_hints = self\n             .analysis\n@@ -111,7 +112,7 @@ impl StaticIndex<'_> {\n                     chaining_hints: true,\n                     closure_return_type_hints: crate::ClosureReturnTypeHints::WithBlock,\n                     lifetime_elision_hints: crate::LifetimeElisionHints::Never,\n-                    reborrow_hints: crate::ReborrowHints::Never,\n+                    adjustment_hints: crate::AdjustmentHints::Never,\n                     hide_named_constructor_hints: false,\n                     hide_closure_initialization_hints: false,\n                     param_names_for_lifetime_elision_hints: false,"}, {"sha": "3536f73da73e3be2c144913491e8835a9e593080", "filename": "src/tools/rust-analyzer/crates/limit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [features]\n tracking = []"}, {"sha": "bce2fc9a70e8271a1471a0d03e88d5baf6f98fd8", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cf53c16726bf7fe092c11fe7cf87748f39d2f9b8", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -12,6 +12,9 @@ use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::{to_parser_input::to_parser_input, tt_iter::TtIter, TokenMap};\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Convert the syntax node to a `TokenTree` (what macro\n /// will consume).\n pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> (tt::Subtree, TokenMap) {\n@@ -35,7 +38,7 @@ pub fn syntax_node_to_token_tree_with_modifications(\n     append: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n ) -> (tt::Subtree, TokenMap, u32) {\n     let global_offset = node.text_range().start();\n-    let mut c = Convertor::new(node, global_offset, existing_token_map, next_id, replace, append);\n+    let mut c = Converter::new(node, global_offset, existing_token_map, next_id, replace, append);\n     let subtree = convert_tokens(&mut c);\n     c.id_alloc.map.shrink_to_fit();\n     always!(c.replace.is_empty(), \"replace: {:?}\", c.replace);\n@@ -100,7 +103,7 @@ pub fn parse_to_token_tree(text: &str) -> Option<(tt::Subtree, TokenMap)> {\n         return None;\n     }\n \n-    let mut conv = RawConvertor {\n+    let mut conv = RawConverter {\n         lexed,\n         pos: 0,\n         id_alloc: TokenIdAlloc {\n@@ -148,7 +151,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     res\n }\n \n-fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n+fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n     struct StackEntry {\n         subtree: tt::Subtree,\n         idx: usize,\n@@ -228,7 +231,7 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n             }\n \n             let spacing = match conv.peek().map(|next| next.kind(conv)) {\n-                Some(kind) if !kind.is_trivia() => tt::Spacing::Joint,\n+                Some(kind) if is_single_token_op(kind) => tt::Spacing::Joint,\n                 _ => tt::Spacing::Alone,\n             };\n             let char = match token.to_char(conv) {\n@@ -307,6 +310,35 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n     }\n }\n \n+fn is_single_token_op(kind: SyntaxKind) -> bool {\n+    matches!(\n+        kind,\n+        EQ | L_ANGLE\n+            | R_ANGLE\n+            | BANG\n+            | AMP\n+            | PIPE\n+            | TILDE\n+            | AT\n+            | DOT\n+            | COMMA\n+            | SEMICOLON\n+            | COLON\n+            | POUND\n+            | DOLLAR\n+            | QUESTION\n+            | PLUS\n+            | MINUS\n+            | STAR\n+            | SLASH\n+            | PERCENT\n+            | CARET\n+            // LIFETIME_IDENT will be split into a sequence of `'` (a single quote) and an\n+            // identifier.\n+            | LIFETIME_IDENT\n+    )\n+}\n+\n /// Returns the textual content of a doc comment block as a quoted string\n /// That is, strips leading `///` (or `/**`, etc)\n /// and strips the ending `*/`\n@@ -425,8 +457,8 @@ impl TokenIdAlloc {\n     }\n }\n \n-/// A raw token (straight from lexer) convertor\n-struct RawConvertor<'a> {\n+/// A raw token (straight from lexer) converter\n+struct RawConverter<'a> {\n     lexed: parser::LexedStr<'a>,\n     pos: usize,\n     id_alloc: TokenIdAlloc,\n@@ -442,7 +474,7 @@ trait SrcToken<Ctx>: std::fmt::Debug {\n     fn synthetic_id(&self, ctx: &Ctx) -> Option<SyntheticTokenId>;\n }\n \n-trait TokenConvertor: Sized {\n+trait TokenConverter: Sized {\n     type Token: SrcToken<Self>;\n \n     fn convert_doc_comment(&self, token: &Self::Token) -> Option<Vec<tt::TokenTree>>;\n@@ -454,25 +486,25 @@ trait TokenConvertor: Sized {\n     fn id_alloc(&mut self) -> &mut TokenIdAlloc;\n }\n \n-impl<'a> SrcToken<RawConvertor<'a>> for usize {\n-    fn kind(&self, ctx: &RawConvertor<'a>) -> SyntaxKind {\n+impl<'a> SrcToken<RawConverter<'a>> for usize {\n+    fn kind(&self, ctx: &RawConverter<'a>) -> SyntaxKind {\n         ctx.lexed.kind(*self)\n     }\n \n-    fn to_char(&self, ctx: &RawConvertor<'a>) -> Option<char> {\n+    fn to_char(&self, ctx: &RawConverter<'a>) -> Option<char> {\n         ctx.lexed.text(*self).chars().next()\n     }\n \n-    fn to_text(&self, ctx: &RawConvertor<'_>) -> SmolStr {\n+    fn to_text(&self, ctx: &RawConverter<'_>) -> SmolStr {\n         ctx.lexed.text(*self).into()\n     }\n \n-    fn synthetic_id(&self, _ctx: &RawConvertor<'a>) -> Option<SyntheticTokenId> {\n+    fn synthetic_id(&self, _ctx: &RawConverter<'a>) -> Option<SyntheticTokenId> {\n         None\n     }\n }\n \n-impl<'a> TokenConvertor for RawConvertor<'a> {\n+impl<'a> TokenConverter for RawConverter<'a> {\n     type Token = usize;\n \n     fn convert_doc_comment(&self, &token: &usize) -> Option<Vec<tt::TokenTree>> {\n@@ -504,7 +536,7 @@ impl<'a> TokenConvertor for RawConvertor<'a> {\n     }\n }\n \n-struct Convertor {\n+struct Converter {\n     id_alloc: TokenIdAlloc,\n     current: Option<SyntaxToken>,\n     current_synthetic: Vec<SyntheticToken>,\n@@ -515,19 +547,19 @@ struct Convertor {\n     punct_offset: Option<(SyntaxToken, TextSize)>,\n }\n \n-impl Convertor {\n+impl Converter {\n     fn new(\n         node: &SyntaxNode,\n         global_offset: TextSize,\n         existing_token_map: TokenMap,\n         next_id: u32,\n         mut replace: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n         mut append: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n-    ) -> Convertor {\n+    ) -> Converter {\n         let range = node.text_range();\n         let mut preorder = node.preorder_with_tokens();\n         let (first, synthetic) = Self::next_token(&mut preorder, &mut replace, &mut append);\n-        Convertor {\n+        Converter {\n             id_alloc: { TokenIdAlloc { map: existing_token_map, global_offset, next_id } },\n             current: first,\n             current_synthetic: synthetic,\n@@ -590,39 +622,39 @@ impl SynToken {\n     }\n }\n \n-impl SrcToken<Convertor> for SynToken {\n-    fn kind(&self, _ctx: &Convertor) -> SyntaxKind {\n+impl SrcToken<Converter> for SynToken {\n+    fn kind(&self, ctx: &Converter) -> SyntaxKind {\n         match self {\n             SynToken::Ordinary(token) => token.kind(),\n-            SynToken::Punch(token, _) => token.kind(),\n+            SynToken::Punch(..) => SyntaxKind::from_char(self.to_char(ctx).unwrap()).unwrap(),\n             SynToken::Synthetic(token) => token.kind,\n         }\n     }\n-    fn to_char(&self, _ctx: &Convertor) -> Option<char> {\n+    fn to_char(&self, _ctx: &Converter) -> Option<char> {\n         match self {\n             SynToken::Ordinary(_) => None,\n             SynToken::Punch(it, i) => it.text().chars().nth((*i).into()),\n             SynToken::Synthetic(token) if token.text.len() == 1 => token.text.chars().next(),\n             SynToken::Synthetic(_) => None,\n         }\n     }\n-    fn to_text(&self, _ctx: &Convertor) -> SmolStr {\n+    fn to_text(&self, _ctx: &Converter) -> SmolStr {\n         match self {\n             SynToken::Ordinary(token) => token.text().into(),\n             SynToken::Punch(token, _) => token.text().into(),\n             SynToken::Synthetic(token) => token.text.clone(),\n         }\n     }\n \n-    fn synthetic_id(&self, _ctx: &Convertor) -> Option<SyntheticTokenId> {\n+    fn synthetic_id(&self, _ctx: &Converter) -> Option<SyntheticTokenId> {\n         match self {\n             SynToken::Synthetic(token) => Some(token.id),\n             _ => None,\n         }\n     }\n }\n \n-impl TokenConvertor for Convertor {\n+impl TokenConverter for Converter {\n     type Token = SynToken;\n     fn convert_doc_comment(&self, token: &Self::Token) -> Option<Vec<tt::TokenTree>> {\n         convert_doc_comment(token.token()?)\n@@ -651,7 +683,7 @@ impl TokenConvertor for Convertor {\n         }\n \n         let curr = self.current.clone()?;\n-        if !&self.range.contains_range(curr.text_range()) {\n+        if !self.range.contains_range(curr.text_range()) {\n             return None;\n         }\n         let (new_current, new_synth) =\n@@ -809,12 +841,15 @@ impl<'a> TtTreeSink<'a> {\n         let next = last.bump();\n         if let (\n             Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(curr), _)),\n-            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(_), _)),\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(next), _)),\n         ) = (last.token_tree(), next.token_tree())\n         {\n             // Note: We always assume the semi-colon would be the last token in\n             // other parts of RA such that we don't add whitespace here.\n-            if curr.spacing == tt::Spacing::Alone && curr.char != ';' {\n+            //\n+            // When `next` is a `Punct` of `'`, that's a part of a lifetime identifier so we don't\n+            // need to add whitespace either.\n+            if curr.spacing == tt::Spacing::Alone && curr.char != ';' && next.char != '\\'' {\n                 self.inner.token(WHITESPACE, \" \");\n                 self.text_pos += TextSize::of(' ');\n             }"}, {"sha": "4e04d2bc1c77bcbd972d7d349cb7ed2fe6c32129", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge/tests.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -0,0 +1,93 @@\n+use std::collections::HashMap;\n+\n+use syntax::{ast, AstNode};\n+use test_utils::extract_annotations;\n+use tt::{\n+    buffer::{TokenBuffer, TokenTreeRef},\n+    Leaf, Punct, Spacing,\n+};\n+\n+use super::syntax_node_to_token_tree;\n+\n+fn check_punct_spacing(fixture: &str) {\n+    let source_file = ast::SourceFile::parse(fixture).ok().unwrap();\n+    let (subtree, token_map) = syntax_node_to_token_tree(source_file.syntax());\n+    let mut annotations: HashMap<_, _> = extract_annotations(fixture)\n+        .into_iter()\n+        .map(|(range, annotation)| {\n+            let token = token_map.token_by_range(range).expect(\"no token found\");\n+            let spacing = match annotation.as_str() {\n+                \"Alone\" => Spacing::Alone,\n+                \"Joint\" => Spacing::Joint,\n+                a => panic!(\"unknown annotation: {}\", a),\n+            };\n+            (token, spacing)\n+        })\n+        .collect();\n+\n+    let buf = TokenBuffer::from_subtree(&subtree);\n+    let mut cursor = buf.begin();\n+    while !cursor.eof() {\n+        while let Some(token_tree) = cursor.token_tree() {\n+            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, id, .. }), _) = token_tree {\n+                if let Some(expected) = annotations.remove(&id) {\n+                    assert_eq!(expected, *spacing);\n+                }\n+            }\n+            cursor = cursor.bump_subtree();\n+        }\n+        cursor = cursor.bump();\n+    }\n+\n+    assert!(annotations.is_empty(), \"unchecked annotations: {:?}\", annotations);\n+}\n+\n+#[test]\n+fn punct_spacing() {\n+    check_punct_spacing(\n+        r#\"\n+fn main() {\n+    0+0;\n+   //^ Alone\n+    0+(0);\n+   //^ Alone\n+    0<=0;\n+   //^ Joint\n+   // ^ Alone\n+    0<=(0);\n+   // ^ Alone\n+    a=0;\n+   //^ Alone\n+    a=(0);\n+   //^ Alone\n+    a+=0;\n+   //^ Joint\n+   // ^ Alone\n+    a+=(0);\n+   // ^ Alone\n+    a&&b;\n+   //^ Joint\n+   // ^ Alone\n+    a&&(b);\n+   // ^ Alone\n+    foo::bar;\n+   //  ^ Joint\n+   //   ^ Alone\n+    use foo::{bar,baz,};\n+   //       ^ Alone\n+   //            ^ Alone\n+   //                ^ Alone\n+    struct Struct<'a> {};\n+   //            ^ Joint\n+   //             ^ Joint\n+    Struct::<0>;\n+   //       ^ Alone\n+    Struct::<{0}>;\n+   //       ^ Alone\n+    ;;\n+  //^ Joint\n+  // ^ Alone\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "d1420de8937a02d66fd97d4cb4660ca4b4b3cffb", "filename": "src/tools/rust-analyzer/crates/parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "d23a63d2a973d426d1cd8b9af30d1edfbc06d1f5", "filename": "src/tools/rust-analyzer/crates/paths/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f261f3def45d68060b90786c5e6c52e3d7db4898", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "7991e125ab83c2f81544efb5408aea76a853f24c", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv-cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [dependencies]\n proc-macro-srv = { version = \"0.0.0\", path = \"../proc-macro-srv\" }"}, {"sha": "a136abc12b756e89b231846984a5cd69814b2a24", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "0ce099ae0bab3b5a39b29a431b1bbd836315e679", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -117,7 +117,7 @@ impl Abi {\n                 let inner = unsafe { Abi_1_63::from_lib(lib, symbol_name) }?;\n                 Ok(Abi::Abi1_63(inner))\n             }\n-            _ => Err(LoadProcMacroDylibError::UnsupportedABI),\n+            _ => Err(LoadProcMacroDylibError::UnsupportedABI(info.version_string.clone())),\n         }\n     }\n "}, {"sha": "0722cd89d7297b5c4b502b86a66e1299c9ad641b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -80,14 +80,14 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n pub enum LoadProcMacroDylibError {\n     Io(io::Error),\n     LibLoading(libloading::Error),\n-    UnsupportedABI,\n+    UnsupportedABI(String),\n }\n \n impl fmt::Display for LoadProcMacroDylibError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Self::Io(e) => e.fmt(f),\n-            Self::UnsupportedABI => write!(f, \"unsupported ABI version\"),\n+            Self::UnsupportedABI(v) => write!(f, \"unsupported ABI `{v}`\"),\n             Self::LibLoading(e) => e.fmt(f),\n         }\n     }"}, {"sha": "b4f5ebd157f33d04c1a94a21b76cef917c4ba667", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -113,12 +113,12 @@ impl ProcMacroSrv {\n \n     fn expander(&mut self, path: &Path) -> Result<&dylib::Expander, String> {\n         let time = fs::metadata(path).and_then(|it| it.modified()).map_err(|err| {\n-            format!(\"Failed to get file metadata for {}: {:?}\", path.display(), err)\n+            format!(\"Failed to get file metadata for {}: {}\", path.display(), err)\n         })?;\n \n         Ok(match self.expanders.entry((path.to_path_buf(), time)) {\n             Entry::Vacant(v) => v.insert(dylib::Expander::new(path).map_err(|err| {\n-                format!(\"Cannot create expander for {}: {:?}\", path.display(), err)\n+                format!(\"Cannot create expander for {}: {}\", path.display(), err)\n             })?),\n             Entry::Occupied(e) => e.into_mut(),\n         })"}, {"sha": "cc0fc91fe989e3230720237584cb6ad48fbe9821", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -19,7 +19,7 @@ fn test_derive_error() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [joint] 4294967295\n+              PUNCH   ! [alone] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[derive(DeriveError)] struct S ;\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],\n@@ -109,7 +109,7 @@ fn test_fn_like_macro_clone_literals() {\n               PUNCH   , [alone] 4294967295\n               LITERAL 2_u32 4294967295\n               PUNCH   , [alone] 4294967295\n-              PUNCH   - [joint] 4294967295\n+              PUNCH   - [alone] 4294967295\n               LITERAL 4i64 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 3.14f32 4294967295\n@@ -130,7 +130,7 @@ fn test_attr_macro() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [joint] 4294967295\n+              PUNCH   ! [alone] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[attr_error(some arguments)] mod m {}\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],"}, {"sha": "d2a79f91074a187005a0d451b5244405dc9b16ec", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -3,7 +3,7 @@ name = \"proc-macro-test\"\n version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n publish = false\n \n [lib]"}, {"sha": "1bd14070e90da80ef7560d06984f7eed5e4a968b", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/imp/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -3,7 +3,7 @@ name = \"proc-macro-test-impl\"\n version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n publish = false\n \n [lib]"}, {"sha": "01d1735bf784391c16c82432c359a4acf56dcbab", "filename": "src/tools/rust-analyzer/crates/profile/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "39902a53214d0dfcbf4a33d64e009af530bef0a3", "filename": "src/tools/rust-analyzer/crates/project-model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "ae2b41f27d58efe226a66e667683cca74788cb47", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -69,7 +69,7 @@ impl WorkspaceBuildScripts {\n                 cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n                 // --all-targets includes tests, benches and examples in addition to the\n-                // default lib and bins. This is an independent concept from the --targets\n+                // default lib and bins. This is an independent concept from the --target\n                 // flag below.\n                 cmd.arg(\"--all-targets\");\n "}, {"sha": "02ec7a4f6f992b60a60d0a593afce746150680f5", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -270,11 +270,7 @@ impl CargoWorkspace {\n         config: &CargoConfig,\n         progress: &dyn Fn(String),\n     ) -> Result<cargo_metadata::Metadata> {\n-        let target = config\n-            .target\n-            .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml, &config.extra_env))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml, &config.extra_env));\n+        let targets = find_list_of_build_targets(config, cargo_toml);\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n@@ -294,8 +290,12 @@ impl CargoWorkspace {\n         }\n         meta.current_dir(current_dir.as_os_str());\n \n-        if let Some(target) = target {\n-            meta.other_options(vec![String::from(\"--filter-platform\"), target]);\n+        if !targets.is_empty() {\n+            let other_options: Vec<_> = targets\n+                .into_iter()\n+                .flat_map(|target| [\"--filter-platform\".to_string(), target])\n+                .collect();\n+            meta.other_options(other_options);\n         }\n \n         // FIXME: Fetching metadata is a slow process, as it might require\n@@ -469,6 +469,19 @@ impl CargoWorkspace {\n     }\n }\n \n+fn find_list_of_build_targets(config: &CargoConfig, cargo_toml: &ManifestPath) -> Vec<String> {\n+    if let Some(target) = &config.target {\n+        return [target.into()].to_vec();\n+    }\n+\n+    let build_targets = cargo_config_build_target(cargo_toml, &config.extra_env);\n+    if !build_targets.is_empty() {\n+        return build_targets;\n+    }\n+\n+    rustc_discover_host_triple(cargo_toml, &config.extra_env).into_iter().collect()\n+}\n+\n fn rustc_discover_host_triple(\n     cargo_toml: &ManifestPath,\n     extra_env: &FxHashMap<String, String>,\n@@ -499,20 +512,29 @@ fn rustc_discover_host_triple(\n fn cargo_config_build_target(\n     cargo_toml: &ManifestPath,\n     extra_env: &FxHashMap<String, String>,\n-) -> Option<String> {\n+) -> Vec<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n     cargo_config.envs(extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])\n         .env(\"RUSTC_BOOTSTRAP\", \"1\");\n     // if successful we receive `build.target = \"target-triple\"`\n+    // or `build.target = [\"<target 1>\", ..]`\n     tracing::debug!(\"Discovering cargo config target by {:?}\", cargo_config);\n-    match utf8_stdout(cargo_config) {\n-        Ok(stdout) => stdout\n-            .strip_prefix(\"build.target = \\\"\")\n-            .and_then(|stdout| stdout.strip_suffix('\"'))\n-            .map(ToOwned::to_owned),\n-        Err(_) => None,\n+    utf8_stdout(cargo_config).map(parse_output_cargo_config_build_target).unwrap_or_default()\n+}\n+\n+fn parse_output_cargo_config_build_target(stdout: String) -> Vec<String> {\n+    let trimmed = stdout.trim_start_matches(\"build.target = \").trim_matches('\"');\n+\n+    if !trimmed.starts_with('[') {\n+        return [trimmed.to_string()].to_vec();\n+    }\n+\n+    let res = serde_json::from_str(trimmed);\n+    if let Err(e) = &res {\n+        tracing::warn!(\"Failed to parse `build.target` as an array of target: {}`\", e);\n     }\n+    res.unwrap_or_default()\n }"}, {"sha": "f6c09a27c9d7ea1a03727550603237348454feab", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -128,14 +128,18 @@ impl Sysroot {\n         }\n \n         if let Some(alloc) = sysroot.by_name(\"alloc\") {\n-            if let Some(core) = sysroot.by_name(\"core\") {\n-                sysroot.crates[alloc].deps.push(core);\n+            for dep in ALLOC_DEPS.trim().lines() {\n+                if let Some(dep) = sysroot.by_name(dep) {\n+                    sysroot.crates[alloc].deps.push(dep)\n+                }\n             }\n         }\n \n         if let Some(proc_macro) = sysroot.by_name(\"proc_macro\") {\n-            if let Some(std) = sysroot.by_name(\"std\") {\n-                sysroot.crates[proc_macro].deps.push(std);\n+            for dep in PROC_MACRO_DEPS.trim().lines() {\n+                if let Some(dep) = sysroot.by_name(dep) {\n+                    sysroot.crates[proc_macro].deps.push(dep)\n+                }\n             }\n         }\n \n@@ -239,24 +243,27 @@ fn get_rust_src(sysroot_path: &AbsPath) -> Option<AbsPathBuf> {\n \n const SYSROOT_CRATES: &str = \"\n alloc\n+backtrace\n core\n panic_abort\n panic_unwind\n proc_macro\n profiler_builtins\n std\n stdarch/crates/std_detect\n-term\n test\n unwind\";\n \n+const ALLOC_DEPS: &str = \"core\";\n+\n const STD_DEPS: &str = \"\n alloc\n-core\n-panic_abort\n panic_unwind\n+panic_abort\n+core\n profiler_builtins\n+unwind\n std_detect\n-term\n-test\n-unwind\";\n+test\";\n+\n+const PROC_MACRO_DEPS: &str = \"std\";"}, {"sha": "a1cb438bddc4c6cd6a00450378d44b384705aea9", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 14, "deletions": 57, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1566,10 +1566,10 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    1,\n+                                    3,\n                                 ),\n                                 name: CrateName(\n-                                    \"core\",\n+                                    \"panic_unwind\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1584,10 +1584,10 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    3,\n+                                    1,\n                                 ),\n                                 name: CrateName(\n-                                    \"panic_unwind\",\n+                                    \"core\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1602,40 +1602,31 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    7,\n+                                    9,\n                                 ),\n                                 name: CrateName(\n-                                    \"std_detect\",\n+                                    \"unwind\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    8,\n+                                    7,\n                                 ),\n                                 name: CrateName(\n-                                    \"term\",\n+                                    \"std_detect\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    9,\n+                                    8,\n                                 ),\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n                                 prelude: true,\n                             },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    10,\n-                                ),\n-                                name: CrateName(\n-                                    \"unwind\",\n-                                ),\n-                                prelude: true,\n-                            },\n                         ],\n                         proc_macro: Err(\n                             \"no proc macro loaded for sysroot crate\",\n@@ -1687,40 +1678,6 @@ fn rust_project_hello_world_project_model() {\n                         ),\n                         edition: Edition2018,\n                         version: None,\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"term\",\n-                                ),\n-                                canonical_name: \"term\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        env: Env {\n-                            entries: {},\n-                        },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Other,\n-                        ),\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        9,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            10,\n-                        ),\n-                        edition: Edition2018,\n-                        version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n@@ -1748,10 +1705,10 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        10,\n+                        9,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            11,\n+                            10,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n@@ -1782,10 +1739,10 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        11,\n+                        10,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            12,\n+                            11,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n@@ -1836,7 +1793,7 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    9,\n+                                    8,\n                                 ),\n                                 name: CrateName(\n                                     \"test\","}, {"sha": "3d199ed24afe79342c97ef43951cb7bc709c7486", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -377,6 +377,21 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn find_sysroot_proc_macro_srv(&self) -> Option<AbsPathBuf> {\n+        match self {\n+            ProjectWorkspace::Cargo { sysroot: Some(sysroot), .. }\n+            | ProjectWorkspace::Json { sysroot: Some(sysroot), .. } => {\n+                let standalone_server_name =\n+                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+                [\"libexec\", \"lib\"]\n+                    .into_iter()\n+                    .map(|segment| sysroot.root().join(segment).join(&standalone_server_name))\n+                    .find(|server_path| std::fs::metadata(&server_path).is_ok())\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n@@ -509,14 +524,14 @@ impl ProjectWorkspace {\n                 build_scripts,\n                 toolchain: _,\n             } => cargo_to_crate_graph(\n-                rustc_cfg.clone(),\n-                cfg_overrides,\n                 load_proc_macro,\n                 load,\n+                rustc,\n                 cargo,\n-                build_scripts,\n                 sysroot.as_ref(),\n-                rustc,\n+                rustc_cfg.clone(),\n+                cfg_overrides,\n+                build_scripts,\n             ),\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => {\n                 detached_files_to_crate_graph(rustc_cfg.clone(), load, files, sysroot)\n@@ -602,7 +617,7 @@ fn project_json_to_crate_graph(\n     for (from, krate) in project.crates() {\n         if let Some(&from) = crates.get(&from) {\n             if let Some((public_deps, libproc_macro)) = &sysroot_deps {\n-                public_deps.add(from, &mut crate_graph);\n+                public_deps.add_to_crate_graph(&mut crate_graph, from);\n                 if krate.is_proc_macro {\n                     if let Some(proc_macro) = libproc_macro {\n                         add_dep(\n@@ -626,14 +641,14 @@ fn project_json_to_crate_graph(\n }\n \n fn cargo_to_crate_graph(\n-    rustc_cfg: Vec<CfgFlag>,\n-    override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    rustc: &Option<CargoWorkspace>,\n     cargo: &CargoWorkspace,\n-    build_scripts: &WorkspaceBuildScripts,\n     sysroot: Option<&Sysroot>,\n-    rustc: &Option<CargoWorkspace>,\n+    rustc_cfg: Vec<CfgFlag>,\n+    override_cfg: &CfgOverrides,\n+    build_scripts: &WorkspaceBuildScripts,\n ) -> CrateGraph {\n     let _p = profile::span(\"cargo_to_crate_graph\");\n     let mut crate_graph = CrateGraph::default();\n@@ -642,13 +657,15 @@ fn cargo_to_crate_graph(\n         None => (SysrootPublicDeps::default(), None),\n     };\n \n-    let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(rustc_cfg);\n+    let cfg_options = {\n+        let mut cfg_options = CfgOptions::default();\n+        cfg_options.extend(rustc_cfg);\n+        cfg_options.insert_atom(\"debug_assertions\".into());\n+        cfg_options\n+    };\n \n     let mut pkg_to_lib_crate = FxHashMap::default();\n \n-    cfg_options.insert_atom(\"debug_assertions\".into());\n-\n     let mut pkg_crates = FxHashMap::default();\n     // Does any crate signal to rust-analyzer that they need the rustc_private crates?\n     let mut has_private = false;\n@@ -723,7 +740,7 @@ fn cargo_to_crate_graph(\n         // Set deps to the core, std and to the lib target of the current package\n         for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n             // Add sysroot deps first so that a lib target named `core` etc. can overwrite them.\n-            public_deps.add(from, &mut crate_graph);\n+            public_deps.add_to_crate_graph(&mut crate_graph, from);\n \n             if let Some((to, name)) = lib_tgt.clone() {\n                 if to != from && kind != TargetKind::BuildScript {\n@@ -767,15 +784,16 @@ fn cargo_to_crate_graph(\n         if let Some(rustc_workspace) = rustc {\n             handle_rustc_crates(\n                 &mut crate_graph,\n-                rustc_workspace,\n+                &mut pkg_to_lib_crate,\n                 load,\n-                &cfg_options,\n-                override_cfg,\n                 load_proc_macro,\n-                &mut pkg_to_lib_crate,\n-                &public_deps,\n+                rustc_workspace,\n                 cargo,\n+                &public_deps,\n+                libproc_macro,\n                 &pkg_crates,\n+                &cfg_options,\n+                override_cfg,\n                 build_scripts,\n             );\n         }\n@@ -825,28 +843,29 @@ fn detached_files_to_crate_graph(\n             },\n         );\n \n-        public_deps.add(detached_file_crate, &mut crate_graph);\n+        public_deps.add_to_crate_graph(&mut crate_graph, detached_file_crate);\n     }\n     crate_graph\n }\n \n fn handle_rustc_crates(\n     crate_graph: &mut CrateGraph,\n-    rustc_workspace: &CargoWorkspace,\n+    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    cfg_options: &CfgOptions,\n-    override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n-    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n-    public_deps: &SysrootPublicDeps,\n+    rustc_workspace: &CargoWorkspace,\n     cargo: &CargoWorkspace,\n+    public_deps: &SysrootPublicDeps,\n+    libproc_macro: Option<CrateId>,\n     pkg_crates: &FxHashMap<Package, Vec<(CrateId, TargetKind)>>,\n+    cfg_options: &CfgOptions,\n+    override_cfg: &CfgOverrides,\n     build_scripts: &WorkspaceBuildScripts,\n ) {\n     let mut rustc_pkg_crates = FxHashMap::default();\n     // The root package of the rustc-dev component is rustc_driver, so we match that\n     let root_pkg =\n-        rustc_workspace.packages().find(|package| rustc_workspace[*package].name == \"rustc_driver\");\n+        rustc_workspace.packages().find(|&package| rustc_workspace[package].name == \"rustc_driver\");\n     // The rustc workspace might be incomplete (such as if rustc-dev is not\n     // installed for the current toolchain) and `rustc_source` is set to discover.\n     if let Some(root_pkg) = root_pkg {\n@@ -901,7 +920,16 @@ fn handle_rustc_crates(\n                     );\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n                     // Add dependencies on core / std / alloc for this crate\n-                    public_deps.add(crate_id, crate_graph);\n+                    public_deps.add_to_crate_graph(crate_graph, crate_id);\n+                    if let Some(proc_macro) = libproc_macro {\n+                        add_dep_with_prelude(\n+                            crate_graph,\n+                            crate_id,\n+                            CrateName::new(\"proc_macro\").unwrap(),\n+                            proc_macro,\n+                            rustc_workspace[tgt].is_proc_macro,\n+                        );\n+                    }\n                     rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                 }\n             }\n@@ -1009,7 +1037,7 @@ struct SysrootPublicDeps {\n \n impl SysrootPublicDeps {\n     /// Makes `from` depend on the public sysroot crates.\n-    fn add(&self, from: CrateId, crate_graph: &mut CrateGraph) {\n+    fn add_to_crate_graph(&self, crate_graph: &mut CrateGraph, from: CrateId) {\n         for (name, krate, prelude) in &self.deps {\n             add_dep_with_prelude(crate_graph, from, name.clone(), *krate, *prelude);\n         }"}, {"sha": "56f14fe1874901ab32b88abcceb59e5329d03772", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -8,7 +8,7 @@ documentation = \"https://rust-analyzer.github.io/manual.html\"\n license = \"MIT OR Apache-2.0\"\n autobins = false\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "cf51cf15a0e1d209855150a7dcd710c9bbd78442", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -3,11 +3,11 @@\n use std::mem;\n \n use cfg::{CfgAtom, CfgExpr};\n-use ide::{FileId, RunnableKind, TestId};\n+use ide::{Cancellable, FileId, RunnableKind, TestId};\n use project_model::{self, CargoFeatures, ManifestPath, TargetKind};\n use vfs::AbsPathBuf;\n \n-use crate::{global_state::GlobalStateSnapshot, Result};\n+use crate::global_state::GlobalStateSnapshot;\n \n /// Abstract representation of Cargo target.\n ///\n@@ -29,7 +29,7 @@ impl CargoTargetSpec {\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n         cfg: &Option<CfgExpr>,\n-    ) -> Result<(Vec<String>, Vec<String>)> {\n+    ) -> (Vec<String>, Vec<String>) {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n \n@@ -111,13 +111,13 @@ impl CargoTargetSpec {\n                 }\n             }\n         }\n-        Ok((args, extra_args))\n+        (args, extra_args)\n     }\n \n     pub(crate) fn for_file(\n         global_state_snapshot: &GlobalStateSnapshot,\n         file_id: FileId,\n-    ) -> Result<Option<CargoTargetSpec>> {\n+    ) -> Cancellable<Option<CargoTargetSpec>> {\n         let crate_id = match &*global_state_snapshot.analysis.crates_for(file_id)? {\n             &[crate_id, ..] => crate_id,\n             _ => return Ok(None),"}, {"sha": "762d7d3a18e8b51ef7c03ce80a73ff9d289db4f9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -60,24 +60,12 @@ pub fn load_workspace(\n     };\n \n     let proc_macro_client = if load_config.with_proc_macro {\n-        let mut path = AbsPathBuf::assert(std::env::current_exe()?);\n-        let mut args = vec![\"proc-macro\"];\n-\n-        if let ProjectWorkspace::Cargo { sysroot, .. } | ProjectWorkspace::Json { sysroot, .. } =\n-            &ws\n-        {\n-            if let Some(sysroot) = sysroot.as_ref() {\n-                let standalone_server_name =\n-                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n-                let server_path = sysroot.root().join(\"libexec\").join(&standalone_server_name);\n-                if std::fs::metadata(&server_path).is_ok() {\n-                    path = server_path;\n-                    args = vec![];\n-                }\n-            }\n-        }\n+        let (server_path, args): (_, &[_]) = match ws.find_sysroot_proc_macro_srv() {\n+            Some(server_path) => (server_path, &[]),\n+            None => (AbsPathBuf::assert(std::env::current_exe()?), &[\"proc-macro\"]),\n+        };\n \n-        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|e| e.to_string())\n+        ProcMacroServer::spawn(server_path, args).map_err(|e| e.to_string())\n     } else {\n         Err(\"proc macro server disabled\".to_owned())\n     };"}, {"sha": "9edd045ab0716510309e3248ea8c15ce40d55f7f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -47,30 +47,27 @@ impl flags::Scip {\n \n         let si = StaticIndex::compute(&analysis);\n \n-        let mut index = scip_types::Index {\n-            metadata: Some(scip_types::Metadata {\n-                version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n-                tool_info: Some(scip_types::ToolInfo {\n-                    name: \"rust-analyzer\".to_owned(),\n-                    version: \"0.1\".to_owned(),\n-                    arguments: vec![],\n-                    ..Default::default()\n-                })\n-                .into(),\n-                project_root: format!(\n-                    \"file://{}\",\n-                    path.normalize()\n-                        .as_os_str()\n-                        .to_str()\n-                        .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n-                        .to_string()\n-                ),\n-                text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n-                ..Default::default()\n+        let metadata = scip_types::Metadata {\n+            version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n+            tool_info: Some(scip_types::ToolInfo {\n+                name: \"rust-analyzer\".to_owned(),\n+                version: \"0.1\".to_owned(),\n+                arguments: vec![],\n+                special_fields: Default::default(),\n             })\n             .into(),\n-            ..Default::default()\n+            project_root: format!(\n+                \"file://{}\",\n+                path.normalize()\n+                    .as_os_str()\n+                    .to_str()\n+                    .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n+                    .to_string()\n+            ),\n+            text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n+            special_fields: Default::default(),\n         };\n+        let mut documents = Vec::new();\n \n         let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n         let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n@@ -95,53 +92,77 @@ impl flags::Scip {\n                 endings: LineEndings::Unix,\n             };\n \n-            let mut doc = scip_types::Document {\n-                relative_path,\n-                language: \"rust\".to_string(),\n-                ..Default::default()\n-            };\n+            let mut occurrences = Vec::new();\n+            let mut symbols = Vec::new();\n \n-            tokens.into_iter().for_each(|(range, id)| {\n+            tokens.into_iter().for_each(|(text_range, id)| {\n                 let token = si.tokens.get(id).unwrap();\n \n-                let mut occurrence = scip_types::Occurrence::default();\n-                occurrence.range = text_range_to_scip_range(&line_index, range);\n-                occurrence.symbol = tokens_to_symbol\n+                let range = text_range_to_scip_range(&line_index, text_range);\n+                let symbol = tokens_to_symbol\n                     .entry(id)\n                     .or_insert_with(|| {\n                         let symbol = token_to_symbol(&token).unwrap_or_else(&mut new_local_symbol);\n                         scip::symbol::format_symbol(symbol)\n                     })\n                     .clone();\n \n+                let mut symbol_roles = Default::default();\n+\n                 if let Some(def) = token.definition {\n-                    if def.range == range {\n-                        occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n+                    if def.range == text_range {\n+                        symbol_roles |= scip_types::SymbolRole::Definition as i32;\n                     }\n \n                     if symbols_emitted.insert(id) {\n-                        let mut symbol_info = scip_types::SymbolInformation::default();\n-                        symbol_info.symbol = occurrence.symbol.clone();\n-                        if let Some(hover) = &token.hover {\n-                            if !hover.markup.as_str().is_empty() {\n-                                symbol_info.documentation = vec![hover.markup.as_str().to_string()];\n-                            }\n-                        }\n-\n-                        doc.symbols.push(symbol_info)\n+                        let documentation = token\n+                            .hover\n+                            .as_ref()\n+                            .map(|hover| hover.markup.as_str())\n+                            .filter(|it| !it.is_empty())\n+                            .map(|it| vec![it.to_owned()]);\n+                        let symbol_info = scip_types::SymbolInformation {\n+                            symbol: symbol.clone(),\n+                            documentation: documentation.unwrap_or_default(),\n+                            relationships: Vec::new(),\n+                            special_fields: Default::default(),\n+                        };\n+\n+                        symbols.push(symbol_info)\n                     }\n                 }\n \n-                doc.occurrences.push(occurrence);\n+                occurrences.push(scip_types::Occurrence {\n+                    range,\n+                    symbol,\n+                    symbol_roles,\n+                    override_documentation: Vec::new(),\n+                    syntax_kind: Default::default(),\n+                    diagnostics: Vec::new(),\n+                    special_fields: Default::default(),\n+                });\n             });\n \n-            if doc.occurrences.is_empty() {\n+            if occurrences.is_empty() {\n                 continue;\n             }\n \n-            index.documents.push(doc);\n+            documents.push(scip_types::Document {\n+                relative_path,\n+                language: \"rust\".to_string(),\n+                occurrences,\n+                symbols,\n+                special_fields: Default::default(),\n+            });\n         }\n \n+        let index = scip_types::Index {\n+            metadata: Some(metadata).into(),\n+            documents,\n+            external_symbols: Vec::new(),\n+            special_fields: Default::default(),\n+        };\n+\n         scip::write_message_to_file(\"index.scip\", index)\n             .map_err(|err| anyhow::anyhow!(\"Failed to write scip to file: {}\", err))?;\n \n@@ -181,7 +202,7 @@ fn new_descriptor_str(\n         name: name.to_string(),\n         disambiguator: \"\".to_string(),\n         suffix: suffix.into(),\n-        ..Default::default()\n+        special_fields: Default::default(),\n     }\n }\n \n@@ -232,11 +253,11 @@ fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n             manager: \"cargo\".to_string(),\n             name: package_name,\n             version: version.unwrap_or_else(|| \".\".to_string()),\n-            ..Default::default()\n+            special_fields: Default::default(),\n         })\n         .into(),\n         descriptors,\n-        ..Default::default()\n+        special_fields: Default::default(),\n     })\n }\n "}, {"sha": "6b2f22faa7178b262fe08b2e5f57323f4f210e4a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -118,9 +118,11 @@ config_data! {\n         /// This option does not take effect until rust-analyzer is restarted.\n         cargo_sysroot: Option<String>    = \"\\\"discover\\\"\",\n         /// Compilation target override (target triple).\n+        // FIXME(@poliorcetics): move to multiple targets here too, but this will need more work\n+        // than `checkOnSave_target`\n         cargo_target: Option<String>     = \"null\",\n         /// Unsets `#[cfg(test)]` for the specified crates.\n-        cargo_unsetTest: Vec<String>   = \"[\\\"core\\\"]\",\n+        cargo_unsetTest: Vec<String>     = \"[\\\"core\\\"]\",\n \n         /// Check all targets and tests (`--all-targets`).\n         checkOnSave_allTargets: bool                     = \"true\",\n@@ -157,7 +159,7 @@ config_data! {\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n         /// Override the command rust-analyzer uses instead of `cargo check` for\n         /// diagnostics on save. The command is required to output json and\n-        /// should therefor include `--message-format=json` or a similar option.\n+        /// should therefore include `--message-format=json` or a similar option.\n         ///\n         /// If you're changing this because you're using some tool wrapping\n         /// Cargo, you might also want to change\n@@ -174,9 +176,13 @@ config_data! {\n         /// ```\n         /// .\n         checkOnSave_overrideCommand: Option<Vec<String>> = \"null\",\n-        /// Check for a specific target. Defaults to\n-        /// `#rust-analyzer.cargo.target#`.\n-        checkOnSave_target: Option<String>               = \"null\",\n+        /// Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\n+        ///\n+        /// Can be a single target, e.g. `\"x86_64-unknown-linux-gnu\"` or a list of targets, e.g.\n+        /// `[\"aarch64-apple-darwin\", \"x86_64-apple-darwin\"]`.\n+        ///\n+        /// Aliased as `\"checkOnSave.targets\"`.\n+        checkOnSave_target | checkOnSave_targets: CheckOnSaveTargets           = \"[]\",\n \n         /// Toggles the additional completions that automatically add imports when completed.\n         /// Note that your client must specify the `additionalTextEdits` LSP client capability to truly have this feature enabled.\n@@ -261,6 +267,7 @@ config_data! {\n         files_excludeDirs: Vec<PathBuf> = \"[]\",\n         /// Controls file watching implementation.\n         files_watcher: FilesWatcherDef = \"\\\"client\\\"\",\n+\n         /// Enables highlighting of related references while the cursor is on `break`, `loop`, `while`, or `for` keywords.\n         highlightRelated_breakPoints_enable: bool = \"true\",\n         /// Enables highlighting of all exit points while the cursor is on any `return`, `?`, `fn`, or return type arrow (`->`).\n@@ -320,6 +327,8 @@ config_data! {\n         inlayHints_closingBraceHints_minLines: usize               = \"25\",\n         /// Whether to show inlay type hints for return types of closures.\n         inlayHints_closureReturnTypeHints_enable: ClosureReturnTypeHintsDef  = \"\\\"never\\\"\",\n+        /// Whether to show inlay hints for type adjustments.\n+        inlayHints_expressionAdjustmentHints_enable: AdjustmentHintsDef = \"\\\"never\\\"\",\n         /// Whether to show inlay type hints for elided lifetimes in function signatures.\n         inlayHints_lifetimeElisionHints_enable: LifetimeElisionDef = \"\\\"never\\\"\",\n         /// Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n@@ -329,7 +338,8 @@ config_data! {\n         /// Whether to show function parameter name inlay hints at the call\n         /// site.\n         inlayHints_parameterHints_enable: bool                     = \"true\",\n-        /// Whether to show inlay type hints for compiler inserted reborrows.\n+        /// Whether to show inlay hints for compiler inserted reborrows.\n+        /// This setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\n         inlayHints_reborrowHints_enable: ReborrowHintsDef          = \"\\\"never\\\"\",\n         /// Whether to render leading colons for type hints, and trailing colons for parameter hints.\n         inlayHints_renderColons: bool                              = \"true\",\n@@ -1143,11 +1153,10 @@ impl Config {\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n                 command: self.data.checkOnSave_command.clone(),\n-                target_triple: self\n-                    .data\n-                    .checkOnSave_target\n-                    .clone()\n-                    .or_else(|| self.data.cargo_target.clone()),\n+                target_triples: match &self.data.checkOnSave_target.0[..] {\n+                    [] => self.data.cargo_target.clone().into_iter().collect(),\n+                    targets => targets.into(),\n+                },\n                 all_targets: self.data.checkOnSave_allTargets,\n                 no_default_features: self\n                     .data\n@@ -1200,10 +1209,15 @@ impl Config {\n             hide_closure_initialization_hints: self\n                 .data\n                 .inlayHints_typeHints_hideClosureInitialization,\n-            reborrow_hints: match self.data.inlayHints_reborrowHints_enable {\n-                ReborrowHintsDef::Always => ide::ReborrowHints::Always,\n-                ReborrowHintsDef::Never => ide::ReborrowHints::Never,\n-                ReborrowHintsDef::Mutable => ide::ReborrowHints::MutableOnly,\n+            adjustment_hints: match self.data.inlayHints_expressionAdjustmentHints_enable {\n+                AdjustmentHintsDef::Always => ide::AdjustmentHints::Always,\n+                AdjustmentHintsDef::Never => match self.data.inlayHints_reborrowHints_enable {\n+                    ReborrowHintsDef::Always | ReborrowHintsDef::Mutable => {\n+                        ide::AdjustmentHints::ReborrowOnly\n+                    }\n+                    ReborrowHintsDef::Never => ide::AdjustmentHints::Never,\n+                },\n+                AdjustmentHintsDef::Reborrow => ide::AdjustmentHints::ReborrowOnly,\n             },\n             binding_mode_hints: self.data.inlayHints_bindingModeHints_enable,\n             param_names_for_lifetime_elision_hints: self\n@@ -1538,6 +1552,7 @@ mod de_unit_v {\n     named_unit_variant!(all);\n     named_unit_variant!(skip_trivial);\n     named_unit_variant!(mutable);\n+    named_unit_variant!(reborrow);\n     named_unit_variant!(with_block);\n }\n \n@@ -1647,6 +1662,9 @@ enum InvocationStrategy {\n     PerWorkspace,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+struct CheckOnSaveTargets(#[serde(deserialize_with = \"single_or_array\")] Vec<String>);\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum InvocationLocation {\n@@ -1687,6 +1705,17 @@ enum ReborrowHintsDef {\n     Mutable,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(untagged)]\n+enum AdjustmentHintsDef {\n+    #[serde(deserialize_with = \"true_or_always\")]\n+    Always,\n+    #[serde(deserialize_with = \"false_or_never\")]\n+    Never,\n+    #[serde(deserialize_with = \"de_unit_v::reborrow\")]\n+    Reborrow,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum FilesWatcherDef {\n@@ -1996,6 +2025,19 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Only show mutable reborrow hints.\"\n             ]\n         },\n+        \"AdjustmentHintsDef\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\n+                \"always\",\n+                \"never\",\n+                \"reborrow\"\n+            ],\n+            \"enumDescriptions\": [\n+                \"Always show all adjustment hints.\",\n+                \"Never show adjustment hints.\",\n+                \"Only show auto borrow and dereference adjustment hints.\"\n+            ]\n+        },\n         \"CargoFeaturesDef\" => set! {\n             \"anyOf\": [\n                 {\n@@ -2084,6 +2126,17 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"The command will be executed in the project root.\"\n             ],\n         },\n+        \"CheckOnSaveTargets\" => set! {\n+            \"anyOf\": [\n+                {\n+                    \"type\": \"string\",\n+                },\n+                {\n+                    \"type\": \"array\",\n+                    \"items\": { \"type\": \"string\" }\n+                },\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "beb23c54c9f0fc7361bd7199073499798dc41ec3", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -359,14 +359,15 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         .iter()\n         .flat_map(|primary_span| {\n             let primary_location = primary_location(config, workspace_root, primary_span, snap);\n-\n-            let mut message = message.clone();\n-            if needs_primary_span_label {\n-                if let Some(primary_span_label) = &primary_span.label {\n-                    format_to!(message, \"\\n{}\", primary_span_label);\n+            let message = {\n+                let mut message = message.clone();\n+                if needs_primary_span_label {\n+                    if let Some(primary_span_label) = &primary_span.label {\n+                        format_to!(message, \"\\n{}\", primary_span_label);\n+                    }\n                 }\n-            }\n-\n+                message\n+            };\n             // Each primary diagnostic span may result in multiple LSP diagnostics.\n             let mut diagnostics = Vec::new();\n \n@@ -417,7 +418,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n                     message: message.clone(),\n                     related_information: Some(information_for_additional_diagnostic),\n                     tags: if tags.is_empty() { None } else { Some(tags.clone()) },\n-                    data: None,\n+                    data: Some(serde_json::json!({ \"rendered\": rd.rendered })),\n                 };\n                 diagnostics.push(MappedRustDiagnostic {\n                     url: secondary_location.uri,\n@@ -449,7 +450,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n                         }\n                     },\n                     tags: if tags.is_empty() { None } else { Some(tags.clone()) },\n-                    data: None,\n+                    data: Some(serde_json::json!({ \"rendered\": rd.rendered })),\n                 },\n                 fix: None,\n             });\n@@ -534,7 +535,8 @@ mod tests {\n             Config::new(workspace_root.to_path_buf(), ClientCapabilities::default()),\n         );\n         let snap = state.snapshot();\n-        let actual = map_rust_diagnostic_to_lsp(&config, &diagnostic, workspace_root, &snap);\n+        let mut actual = map_rust_diagnostic_to_lsp(&config, &diagnostic, workspace_root, &snap);\n+        actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);\n         expect.assert_debug_eq(&actual)\n     }\n "}, {"sha": "dd433b0f4d31cffad29b39955fb5365597355b4d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -42,8 +42,10 @@ pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> R\n pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Result<TextRange> {\n     let start = offset(line_index, range.start)?;\n     let end = offset(line_index, range.end)?;\n-    let text_range = TextRange::new(start, end);\n-    Ok(text_range)\n+    match end < start {\n+        true => Err(format_err!(\"Invalid Range\").into()),\n+        false => Ok(TextRange::new(start, end)),\n+    }\n }\n \n pub(crate) fn file_id(snap: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {"}, {"sha": "4e8bc8d6462ce58362d04a5a625eccb3ac565d59", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -100,7 +100,7 @@ pub(crate) struct GlobalState {\n     /// the user just adds comments or whitespace to Cargo.toml, we do not want\n     /// to invalidate any salsa caches.\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n-    pub(crate) fetch_workspaces_queue: OpQueue<Vec<anyhow::Result<ProjectWorkspace>>>,\n+    pub(crate) fetch_workspaces_queue: OpQueue<Option<Vec<anyhow::Result<ProjectWorkspace>>>>,\n     pub(crate) fetch_build_data_queue:\n         OpQueue<(Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)>,\n "}, {"sha": "d190a9f4e2ca99c0322a141c9700dcf19de8d12f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -9,9 +9,9 @@ use std::{\n \n use anyhow::Context;\n use ide::{\n-    AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n-    HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,\n-    SingleResolve, SourceChange, TextEdit,\n+    AnnotationConfig, AssistKind, AssistResolveStrategy, Cancellable, FileId, FilePosition,\n+    FileRange, HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable,\n+    RunnableKind, SingleResolve, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use lsp_server::ErrorCode;\n@@ -556,7 +556,7 @@ pub(crate) fn handle_will_rename_files(\n     if source_change.source_file_edits.is_empty() {\n         Ok(None)\n     } else {\n-        to_proto::workspace_edit(&snap, source_change).map(Some)\n+        Ok(Some(to_proto::workspace_edit(&snap, source_change)?))\n     }\n }\n \n@@ -1313,7 +1313,7 @@ pub(crate) fn handle_ssr(\n         position,\n         selections,\n     )??;\n-    to_proto::workspace_edit(&snap, source_change)\n+    to_proto::workspace_edit(&snap, source_change).map_err(Into::into)\n }\n \n pub(crate) fn publish_diagnostics(\n@@ -1354,13 +1354,12 @@ pub(crate) fn handle_inlay_hints(\n ) -> Result<Option<Vec<InlayHint>>> {\n     let _p = profile::span(\"handle_inlay_hints\");\n     let document_uri = &params.text_document.uri;\n-    let file_id = from_proto::file_id(&snap, document_uri)?;\n-    let line_index = snap.file_line_index(file_id)?;\n-    let range = from_proto::file_range(\n+    let FileRange { file_id, range } = from_proto::file_range(\n         &snap,\n         TextDocumentIdentifier::new(document_uri.to_owned()),\n         params.range,\n     )?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let inlay_hints_config = snap.config.inlay_hints();\n     Ok(Some(\n         snap.analysis\n@@ -1369,7 +1368,7 @@ pub(crate) fn handle_inlay_hints(\n             .map(|it| {\n                 to_proto::inlay_hint(&snap, &line_index, inlay_hints_config.render_colons, it)\n             })\n-            .collect::<Result<Vec<_>>>()?,\n+            .collect::<Cancellable<Vec<_>>>()?,\n     ))\n }\n \n@@ -1426,7 +1425,7 @@ pub(crate) fn handle_call_hierarchy_prepare(\n         .into_iter()\n         .filter(|it| it.kind == Some(SymbolKind::Function))\n         .map(|it| to_proto::call_hierarchy_item(&snap, it))\n-        .collect::<Result<Vec<_>>>()?;\n+        .collect::<Cancellable<Vec<_>>>()?;\n \n     Ok(Some(res))\n }"}, {"sha": "2945dba12f255527265fb4668707adabda75d04d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -27,10 +27,6 @@ pub(crate) enum LineEndings {\n impl LineEndings {\n     /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n     pub(crate) fn normalize(src: String) -> (String, LineEndings) {\n-        if !src.as_bytes().contains(&b'\\r') {\n-            return (src, LineEndings::Unix);\n-        }\n-\n         // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n         // While we *can* call `as_mut_vec` and do surgery on the live string\n         // directly, let's rather steal the contents of `src`. This makes the code\n@@ -39,10 +35,19 @@ impl LineEndings {\n         let mut buf = src.into_bytes();\n         let mut gap_len = 0;\n         let mut tail = buf.as_mut_slice();\n+        let mut crlf_seen = false;\n+\n+        let find_crlf = |src: &[u8]| src.windows(2).position(|it| it == b\"\\r\\n\");\n+\n         loop {\n             let idx = match find_crlf(&tail[gap_len..]) {\n-                None => tail.len(),\n-                Some(idx) => idx + gap_len,\n+                None if crlf_seen => tail.len(),\n+                // SAFETY: buf is unchanged and therefore still contains utf8 data\n+                None => return (unsafe { String::from_utf8_unchecked(buf) }, LineEndings::Unix),\n+                Some(idx) => {\n+                    crlf_seen = true;\n+                    idx + gap_len\n+                }\n             };\n             tail.copy_within(gap_len..idx, 0);\n             tail = &mut tail[idx - gap_len..];\n@@ -54,15 +59,48 @@ impl LineEndings {\n \n         // Account for removed `\\r`.\n         // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n-        let new_len = buf.len() - gap_len;\n         let src = unsafe {\n+            let new_len = buf.len() - gap_len;\n             buf.set_len(new_len);\n             String::from_utf8_unchecked(buf)\n         };\n-        return (src, LineEndings::Dos);\n+        (src, LineEndings::Dos)\n+    }\n+}\n \n-        fn find_crlf(src: &[u8]) -> Option<usize> {\n-            src.windows(2).position(|it| it == b\"\\r\\n\")\n-        }\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn unix() {\n+        let src = \"a\\nb\\nc\\n\\n\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n+    }\n+\n+    #[test]\n+    fn dos() {\n+        let src = \"\\r\\na\\r\\n\\r\\nb\\r\\nc\\r\\n\\r\\n\\r\\n\\r\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"\\na\\n\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn mixed() {\n+        let src = \"a\\r\\nb\\r\\nc\\r\\n\\n\\r\\n\\n\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Dos);\n+        assert_eq!(res, \"a\\nb\\nc\\n\\n\\n\\n\");\n+    }\n+\n+    #[test]\n+    fn none() {\n+        let src = \"abc\";\n+        let (res, endings) = LineEndings::normalize(src.into());\n+        assert_eq!(endings, LineEndings::Unix);\n+        assert_eq!(res, src);\n     }\n }"}, {"sha": "0971dc36f3a5c84ef1f1ab34ae0da88c4ce70edc", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::{ops::Range, sync::Arc};\n+use std::{mem, ops::Range, sync::Arc};\n \n use lsp_server::Notification;\n \n@@ -133,11 +133,37 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n-    old_text: &mut String,\n-    content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n-) {\n+    file_contents: impl FnOnce() -> String,\n+    mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n+) -> String {\n+    // Skip to the last full document change, as it invalidates all previous changes anyways.\n+    let mut start = content_changes\n+        .iter()\n+        .rev()\n+        .position(|change| change.range.is_none())\n+        .map(|idx| content_changes.len() - idx - 1)\n+        .unwrap_or(0);\n+\n+    let mut text: String = match content_changes.get_mut(start) {\n+        // peek at the first content change as an optimization\n+        Some(lsp_types::TextDocumentContentChangeEvent { range: None, text, .. }) => {\n+            let text = mem::take(text);\n+            start += 1;\n+\n+            // The only change is a full document update\n+            if start == content_changes.len() {\n+                return text;\n+            }\n+            text\n+        }\n+        Some(_) => file_contents(),\n+        // we received no content changes\n+        None => return file_contents(),\n+    };\n+\n     let mut line_index = LineIndex {\n-        index: Arc::new(ide::LineIndex::new(old_text)),\n+        // the index will be overwritten in the bottom loop's first iteration\n+        index: Arc::new(ide::LineIndex::new(&text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n         encoding: PositionEncoding::Utf16,\n@@ -148,38 +174,20 @@ pub(crate) fn apply_document_changes(\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n     // remember the last valid line in the index and only rebuild it if needed.\n     // The VFS will normalize the end of lines to `\\n`.\n-    enum IndexValid {\n-        All,\n-        UpToLineExclusive(u32),\n-    }\n-\n-    impl IndexValid {\n-        fn covers(&self, line: u32) -> bool {\n-            match *self {\n-                IndexValid::UpToLineExclusive(to) => to > line,\n-                _ => true,\n-            }\n-        }\n-    }\n-\n-    let mut index_valid = IndexValid::All;\n+    let mut index_valid = !0u32;\n     for change in content_changes {\n-        match change.range {\n-            Some(range) => {\n-                if !index_valid.covers(range.end.line) {\n-                    line_index.index = Arc::new(ide::LineIndex::new(old_text));\n-                }\n-                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                if let Ok(range) = from_proto::text_range(&line_index, range) {\n-                    old_text.replace_range(Range::<usize>::from(range), &change.text);\n-                }\n+        // The None case can't happen as we have handled it above already\n+        if let Some(range) = change.range {\n+            if index_valid <= range.end.line {\n+                *Arc::make_mut(&mut line_index.index) = ide::LineIndex::new(&text);\n             }\n-            None => {\n-                *old_text = change.text;\n-                index_valid = IndexValid::UpToLineExclusive(0);\n+            index_valid = range.start.line;\n+            if let Ok(range) = from_proto::text_range(&line_index, range) {\n+                text.replace_range(Range::<usize>::from(range), &change.text);\n             }\n         }\n     }\n+    text\n }\n \n /// Checks that the edits inside the completion and the additional edits do not overlap.\n@@ -242,51 +250,50 @@ mod tests {\n             };\n         }\n \n-        let mut text = String::new();\n-        apply_document_changes(&mut text, vec![]);\n+        let text = apply_document_changes(|| String::new(), vec![]);\n         assert_eq!(text, \"\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n                 range_length: None,\n                 text: String::from(\"the\"),\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n-        text = String::from(\"\u2764\ufe0f\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = String::from(\"\u2764\ufe0f\");\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "274588ce0e0764f9953c09402edfca046fc02ada", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -451,7 +451,7 @@ impl GlobalState {\n                     ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n                     ProjectWorkspaceProgress::Report(msg) => (Progress::Report, Some(msg)),\n                     ProjectWorkspaceProgress::End(workspaces) => {\n-                        self.fetch_workspaces_queue.op_completed(workspaces);\n+                        self.fetch_workspaces_queue.op_completed(Some(workspaces));\n \n                         let old = Arc::clone(&self.workspaces);\n                         self.switch_workspaces(\"fetched workspace\".to_string());\n@@ -759,8 +759,10 @@ impl GlobalState {\n \n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n-                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                    apply_document_changes(&mut text, params.content_changes);\n+                    let text = apply_document_changes(\n+                        || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n+                        params.content_changes,\n+                    );\n \n                     vfs.set_file_contents(path, Some(text.into_bytes()));\n                 }"}, {"sha": "45a1dab9772faa8a3809436949262c97b8585243", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/mem_docs.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -7,7 +7,7 @@ use vfs::VfsPath;\n \n /// Holds the set of in-memory documents.\n ///\n-/// For these document, there true contents is maintained by the client. It\n+/// For these document, their true contents is maintained by the client. It\n /// might be different from what's on disk.\n #[derive(Default, Clone)]\n pub(crate) struct MemDocs {\n@@ -19,31 +19,37 @@ impl MemDocs {\n     pub(crate) fn contains(&self, path: &VfsPath) -> bool {\n         self.mem_docs.contains_key(path)\n     }\n+\n     pub(crate) fn insert(&mut self, path: VfsPath, data: DocumentData) -> Result<(), ()> {\n         self.added_or_removed = true;\n         match self.mem_docs.insert(path, data) {\n             Some(_) => Err(()),\n             None => Ok(()),\n         }\n     }\n+\n     pub(crate) fn remove(&mut self, path: &VfsPath) -> Result<(), ()> {\n         self.added_or_removed = true;\n         match self.mem_docs.remove(path) {\n             Some(_) => Ok(()),\n             None => Err(()),\n         }\n     }\n+\n     pub(crate) fn get(&self, path: &VfsPath) -> Option<&DocumentData> {\n         self.mem_docs.get(path)\n     }\n+\n     pub(crate) fn get_mut(&mut self, path: &VfsPath) -> Option<&mut DocumentData> {\n         // NB: don't set `self.added_or_removed` here, as that purposefully only\n         // tracks changes to the key set.\n         self.mem_docs.get_mut(path)\n     }\n+\n     pub(crate) fn iter(&self) -> impl Iterator<Item = &VfsPath> {\n         self.mem_docs.keys()\n     }\n+\n     pub(crate) fn take_changes(&mut self) -> bool {\n         mem::replace(&mut self.added_or_removed, false)\n     }"}, {"sha": "fcfe4be0b8cec9aa5578286e8e34e483e6341bb8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -106,6 +106,14 @@ impl GlobalState {\n             status.health = lsp_ext::Health::Error;\n             status.message = Some(error)\n         }\n+\n+        if self.config.linked_projects().is_empty()\n+            && self.config.detached_files().is_empty()\n+            && self.config.notifications().cargo_toml_not_found\n+        {\n+            status.health = lsp_ext::Health::Warning;\n+            status.message = Some(\"Workspace reload required\".to_string())\n+        }\n         status\n     }\n \n@@ -198,12 +206,9 @@ impl GlobalState {\n             self.show_and_log_error(\"failed to run build scripts\".to_string(), Some(error));\n         }\n \n-        let workspaces = self\n-            .fetch_workspaces_queue\n-            .last_op_result()\n-            .iter()\n-            .filter_map(|res| res.as_ref().ok().cloned())\n-            .collect::<Vec<_>>();\n+        let Some(workspaces) = self.fetch_workspaces_queue.last_op_result() else { return; };\n+        let workspaces =\n+            workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect::<Vec<_>>();\n \n         fn eq_ignore_build_data<'a>(\n             left: &'a ProjectWorkspace,\n@@ -300,50 +305,24 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n-        let standalone_server_name =\n-            format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n-\n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let (path, args) = if path_manually_set {\n+                        let (path, args): (_, &[_]) = if path_manually_set {\n                             tracing::debug!(\n                                 \"Pro-macro server path explicitly set: {}\",\n                                 path.display()\n                             );\n-                            (path.clone(), vec![])\n+                            (path.clone(), &[])\n                         } else {\n-                            let mut sysroot_server = None;\n-                            if let ProjectWorkspace::Cargo { sysroot, .. }\n-                            | ProjectWorkspace::Json { sysroot, .. } = ws\n-                            {\n-                                if let Some(sysroot) = sysroot.as_ref() {\n-                                    let server_path = sysroot\n-                                        .root()\n-                                        .join(\"libexec\")\n-                                        .join(&standalone_server_name);\n-                                    if std::fs::metadata(&server_path).is_ok() {\n-                                        tracing::debug!(\n-                                            \"Sysroot proc-macro server exists at {}\",\n-                                            server_path.display()\n-                                        );\n-                                        sysroot_server = Some(server_path);\n-                                    } else {\n-                                        tracing::debug!(\n-                                            \"Sysroot proc-macro server does not exist at {}\",\n-                                            server_path.display()\n-                                        );\n-                                    }\n-                                }\n+                            match ws.find_sysroot_proc_macro_srv() {\n+                                Some(server_path) => (server_path, &[]),\n+                                None => (path.clone(), &[\"proc-macro\"]),\n                             }\n-                            sysroot_server.map_or_else(\n-                                || (path.clone(), vec![\"proc-macro\".to_owned()]),\n-                                |path| (path, vec![]),\n-                            )\n                         };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n@@ -427,9 +406,14 @@ impl GlobalState {\n     fn fetch_workspace_error(&self) -> Result<(), String> {\n         let mut buf = String::new();\n \n-        for ws in self.fetch_workspaces_queue.last_op_result() {\n-            if let Err(err) = ws {\n-                stdx::format_to!(buf, \"rust-analyzer failed to load workspace: {:#}\\n\", err);\n+        let Some(last_op_result) = self.fetch_workspaces_queue.last_op_result() else { return Ok(()) };\n+        if last_op_result.is_empty() {\n+            stdx::format_to!(buf, \"rust-analyzer failed to discover workspace\");\n+        } else {\n+            for ws in last_op_result {\n+                if let Err(err) = ws {\n+                    stdx::format_to!(buf, \"rust-analyzer failed to load workspace: {:#}\\n\", err);\n+                }\n             }\n         }\n "}, {"sha": "81cc1952ba5ca4b9d210f85b2225ed1abde4e189", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     line_index::{LineEndings, LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n-    semantic_tokens, Result,\n+    semantic_tokens,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n@@ -429,7 +429,7 @@ pub(crate) fn inlay_hint(\n     line_index: &LineIndex,\n     render_colons: bool,\n     mut inlay_hint: InlayHint,\n-) -> Result<lsp_types::InlayHint> {\n+) -> Cancellable<lsp_types::InlayHint> {\n     match inlay_hint.kind {\n         InlayKind::ParameterHint if render_colons => inlay_hint.label.append_str(\":\"),\n         InlayKind::TypeHint if render_colons => inlay_hint.label.prepend_str(\": \"),\n@@ -440,32 +440,35 @@ pub(crate) fn inlay_hint(\n     Ok(lsp_types::InlayHint {\n         position: match inlay_hint.kind {\n             // before annotated thing\n-            InlayKind::ParameterHint\n-            | InlayKind::ImplicitReborrowHint\n-            | InlayKind::BindingModeHint => position(line_index, inlay_hint.range.start()),\n+            InlayKind::ParameterHint | InlayKind::AdjustmentHint | InlayKind::BindingModeHint => {\n+                position(line_index, inlay_hint.range.start())\n+            }\n             // after annotated thing\n             InlayKind::ClosureReturnTypeHint\n             | InlayKind::TypeHint\n             | InlayKind::ChainingHint\n             | InlayKind::GenericParamListHint\n+            | InlayKind::AdjustmentHintClosingParenthesis\n             | InlayKind::LifetimeHint\n             | InlayKind::ClosingBraceHint => position(line_index, inlay_hint.range.end()),\n         },\n         padding_left: Some(match inlay_hint.kind {\n             InlayKind::TypeHint => !render_colons,\n             InlayKind::ChainingHint | InlayKind::ClosingBraceHint => true,\n-            InlayKind::BindingModeHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::BindingModeHint\n             | InlayKind::ClosureReturnTypeHint\n             | InlayKind::GenericParamListHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::LifetimeHint\n             | InlayKind::ParameterHint => false,\n         }),\n         padding_right: Some(match inlay_hint.kind {\n-            InlayKind::ChainingHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::ChainingHint\n             | InlayKind::ClosureReturnTypeHint\n             | InlayKind::GenericParamListHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::TypeHint\n             | InlayKind::ClosingBraceHint => false,\n             InlayKind::BindingModeHint => inlay_hint.label.as_simple_str() != Some(\"&\"),\n@@ -476,10 +479,11 @@ pub(crate) fn inlay_hint(\n             InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n                 Some(lsp_types::InlayHintKind::TYPE)\n             }\n-            InlayKind::BindingModeHint\n+            InlayKind::AdjustmentHintClosingParenthesis\n+            | InlayKind::BindingModeHint\n             | InlayKind::GenericParamListHint\n             | InlayKind::LifetimeHint\n-            | InlayKind::ImplicitReborrowHint\n+            | InlayKind::AdjustmentHint\n             | InlayKind::ClosingBraceHint => None,\n         },\n         text_edits: None,\n@@ -518,7 +522,7 @@ pub(crate) fn inlay_hint(\n fn inlay_hint_label(\n     snap: &GlobalStateSnapshot,\n     label: InlayHintLabel,\n-) -> Result<lsp_types::InlayHintLabel> {\n+) -> Cancellable<lsp_types::InlayHintLabel> {\n     Ok(match label.as_simple_str() {\n         Some(s) => lsp_types::InlayHintLabel::String(s.into()),\n         None => lsp_types::InlayHintLabel::LabelParts(\n@@ -536,7 +540,7 @@ fn inlay_hint_label(\n                         command: None,\n                     })\n                 })\n-                .collect::<Result<Vec<_>>>()?,\n+                .collect::<Cancellable<Vec<_>>>()?,\n         ),\n     })\n }\n@@ -794,7 +798,7 @@ pub(crate) fn optional_versioned_text_document_identifier(\n pub(crate) fn location(\n     snap: &GlobalStateSnapshot,\n     frange: FileRange,\n-) -> Result<lsp_types::Location> {\n+) -> Cancellable<lsp_types::Location> {\n     let url = url(snap, frange.file_id);\n     let line_index = snap.file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n@@ -806,7 +810,7 @@ pub(crate) fn location(\n pub(crate) fn location_from_nav(\n     snap: &GlobalStateSnapshot,\n     nav: NavigationTarget,\n-) -> Result<lsp_types::Location> {\n+) -> Cancellable<lsp_types::Location> {\n     let url = url(snap, nav.file_id);\n     let line_index = snap.file_line_index(nav.file_id)?;\n     let range = range(&line_index, nav.full_range);\n@@ -818,7 +822,7 @@ pub(crate) fn location_link(\n     snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     target: NavigationTarget,\n-) -> Result<lsp_types::LocationLink> {\n+) -> Cancellable<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n             let line_index = snap.file_line_index(src.file_id)?;\n@@ -840,7 +844,7 @@ pub(crate) fn location_link(\n fn location_info(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n-) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n+) -> Cancellable<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n     let line_index = snap.file_line_index(target.file_id)?;\n \n     let target_uri = url(snap, target.file_id);\n@@ -854,20 +858,20 @@ pub(crate) fn goto_definition_response(\n     snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n-) -> Result<lsp_types::GotoDefinitionResponse> {\n+) -> Cancellable<lsp_types::GotoDefinitionResponse> {\n     if snap.config.location_link() {\n         let links = targets\n             .into_iter()\n             .map(|nav| location_link(snap, src, nav))\n-            .collect::<Result<Vec<_>>>()?;\n+            .collect::<Cancellable<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(snap, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n             })\n-            .collect::<Result<Vec<_>>>()?;\n+            .collect::<Cancellable<Vec<_>>>()?;\n         Ok(locations.into())\n     }\n }\n@@ -881,7 +885,7 @@ pub(crate) fn snippet_text_document_edit(\n     is_snippet: bool,\n     file_id: FileId,\n     edit: TextEdit,\n-) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n+) -> Cancellable<lsp_ext::SnippetTextDocumentEdit> {\n     let text_document = optional_versioned_text_document_identifier(snap, file_id);\n     let line_index = snap.file_line_index(file_id)?;\n     let mut edits: Vec<_> =\n@@ -958,7 +962,7 @@ pub(crate) fn snippet_text_document_ops(\n pub(crate) fn snippet_workspace_edit(\n     snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n-) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n+) -> Cancellable<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n \n     for op in source_change.file_system_edits {\n@@ -995,7 +999,7 @@ pub(crate) fn snippet_workspace_edit(\n pub(crate) fn workspace_edit(\n     snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n-) -> Result<lsp_types::WorkspaceEdit> {\n+) -> Cancellable<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n     snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n@@ -1048,7 +1052,7 @@ impl From<lsp_ext::SnippetTextEdit>\n pub(crate) fn call_hierarchy_item(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n-) -> Result<lsp_types::CallHierarchyItem> {\n+) -> Cancellable<lsp_types::CallHierarchyItem> {\n     let name = target.name.to_string();\n     let detail = target.description.clone();\n     let kind = target.kind.map(symbol_kind).unwrap_or(lsp_types::SymbolKind::FUNCTION);\n@@ -1080,7 +1084,7 @@ pub(crate) fn code_action(\n     snap: &GlobalStateSnapshot,\n     assist: Assist,\n     resolve_data: Option<(usize, lsp_types::CodeActionParams)>,\n-) -> Result<lsp_ext::CodeAction> {\n+) -> Cancellable<lsp_ext::CodeAction> {\n     let mut res = lsp_ext::CodeAction {\n         title: assist.label.to_string(),\n         group: assist.group.filter(|_| snap.config.code_action_group()).map(|gr| gr.0),\n@@ -1113,13 +1117,13 @@ pub(crate) fn code_action(\n pub(crate) fn runnable(\n     snap: &GlobalStateSnapshot,\n     runnable: Runnable,\n-) -> Result<lsp_ext::Runnable> {\n+) -> Cancellable<lsp_ext::Runnable> {\n     let config = snap.config.runnables();\n     let spec = CargoTargetSpec::for_file(snap, runnable.nav.file_id)?;\n     let workspace_root = spec.as_ref().map(|it| it.workspace_root.clone());\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n-        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg)?;\n+        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg);\n     let label = runnable.label(target);\n     let location = location_link(snap, None, runnable.nav)?;\n \n@@ -1142,7 +1146,7 @@ pub(crate) fn code_lens(\n     acc: &mut Vec<lsp_types::CodeLens>,\n     snap: &GlobalStateSnapshot,\n     annotation: Annotation,\n-) -> Result<()> {\n+) -> Cancellable<()> {\n     let client_commands_config = snap.config.client_commands();\n     match annotation.kind {\n         AnnotationKind::Runnable(run) => {"}, {"sha": "593dc4e55b21bb769bcfe70cfb949e7c8d609040", "filename": "src/tools/rust-analyzer/crates/sourcegen/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f7b7d09640ff71fc7e4f8630cb122ce69e3c19ce", "filename": "src/tools/rust-analyzer/crates/stdx/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false\n@@ -16,7 +16,7 @@ always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here\n \n [target.'cfg(windows)'.dependencies]\n-miow = \"0.4.0\"\n+miow = \"0.5.0\"\n winapi = { version = \"0.3.9\", features = [\"winerror\"] }\n \n [features]"}, {"sha": "00743cca5593494622640b85663cff15289e13d2", "filename": "src/tools/rust-analyzer/crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -5,7 +5,7 @@ description = \"Comment and whitespace preserving parser for the Rust language\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "f295c40065dbd2497f9f7c77e7f14d19fd6ae040", "filename": "src/tools/rust-analyzer/crates/syntax/fuzz/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ name = \"syntax-fuzz\"\n version = \"0.0.1\"\n publish = false\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [package.metadata]\n cargo-fuzz = true"}, {"sha": "0a0cb0290d6cb5b0a55bc683a8fb8292f64fae63", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -239,8 +239,11 @@ Static =\n Trait =\n   Attr* Visibility?\n   'unsafe'? 'auto'?\n-  'trait' Name GenericParamList? (':' TypeBoundList?)? WhereClause?\n-  AssocItemList\n+  'trait' Name GenericParamList?\n+  (\n+    (':' TypeBoundList?)? WhereClause? AssocItemList\n+    | '=' TypeBoundList? WhereClause? ';'\n+  )\n \n AssocItemList =\n   '{' Attr* AssocItem* '}'"}, {"sha": "2ea715f47fb23753089a3be6e96ac55425697d52", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -407,6 +407,8 @@ impl Trait {\n     pub fn auto_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![auto]) }\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "8990f7a7d4e8ec4b85d5906667216f5835e8cb80", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -209,17 +209,19 @@ impl ast::String {\n         let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n \n         let mut buf = String::new();\n-        let mut text_iter = text.chars();\n+        let mut prev_end = 0;\n         let mut has_error = false;\n         unescape_literal(text, Mode::Str, &mut |char_range, unescaped_char| match (\n             unescaped_char,\n             buf.capacity() == 0,\n         ) {\n             (Ok(c), false) => buf.push(c),\n-            (Ok(c), true) if char_range.len() == 1 && Some(c) == text_iter.next() => (),\n+            (Ok(_), true) if char_range.len() == 1 && char_range.start == prev_end => {\n+                prev_end = char_range.end\n+            }\n             (Ok(c), true) => {\n                 buf.reserve_exact(text.len());\n-                buf.push_str(&text[..char_range.start]);\n+                buf.push_str(&text[..prev_end]);\n                 buf.push(c);\n             }\n             (Err(_), _) => has_error = true,\n@@ -252,17 +254,19 @@ impl ast::ByteString {\n         let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n \n         let mut buf: Vec<u8> = Vec::new();\n-        let mut text_iter = text.chars();\n+        let mut prev_end = 0;\n         let mut has_error = false;\n         unescape_literal(text, Mode::ByteStr, &mut |char_range, unescaped_char| match (\n             unescaped_char,\n             buf.capacity() == 0,\n         ) {\n             (Ok(c), false) => buf.push(c as u8),\n-            (Ok(c), true) if char_range.len() == 1 && Some(c) == text_iter.next() => (),\n+            (Ok(_), true) if char_range.len() == 1 && char_range.start == prev_end => {\n+                prev_end = char_range.end\n+            }\n             (Ok(c), true) => {\n                 buf.reserve_exact(text.len());\n-                buf.extend_from_slice(text[..char_range.start].as_bytes());\n+                buf.extend_from_slice(text[..prev_end].as_bytes());\n                 buf.push(c as u8);\n             }\n             (Err(_), _) => has_error = true,\n@@ -445,6 +449,36 @@ mod tests {\n         check_string_value(r\"\\foobar\", None);\n         check_string_value(r\"\\nfoobar\", \"\\nfoobar\");\n         check_string_value(r\"C:\\\\Windows\\\\System32\\\\\", \"C:\\\\Windows\\\\System32\\\\\");\n+        check_string_value(r\"\\x61bcde\", \"abcde\");\n+        check_string_value(\n+            r\"a\\\n+bcde\", \"abcde\",\n+        );\n+    }\n+\n+    fn check_byte_string_value<'a, const N: usize>(\n+        lit: &str,\n+        expected: impl Into<Option<&'a [u8; N]>>,\n+    ) {\n+        assert_eq!(\n+            ast::ByteString { syntax: make::tokens::literal(&format!(\"b\\\"{}\\\"\", lit)) }\n+                .value()\n+                .as_deref(),\n+            expected.into().map(|value| &value[..])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_byte_string_escape() {\n+        check_byte_string_value(r\"foobar\", b\"foobar\");\n+        check_byte_string_value(r\"\\foobar\", None::<&[u8; 0]>);\n+        check_byte_string_value(r\"\\nfoobar\", b\"\\nfoobar\");\n+        check_byte_string_value(r\"C:\\\\Windows\\\\System32\\\\\", b\"C:\\\\Windows\\\\System32\\\\\");\n+        check_byte_string_value(r\"\\x61bcde\", b\"abcde\");\n+        check_byte_string_value(\n+            r\"a\\\n+bcde\", b\"abcde\",\n+        );\n     }\n \n     #[test]"}, {"sha": "712ef5f63b651e9e3db63378dff73210a7622a12", "filename": "src/tools/rust-analyzer/crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -86,7 +86,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                 .traits\n                 .iter()\n                 .filter(|trait_name| {\n-                    // Loops have two expressions so this might collide, therefor manual impl it\n+                    // Loops have two expressions so this might collide, therefore manual impl it\n                     node.name != \"ForExpr\" && node.name != \"WhileExpr\"\n                         || trait_name.as_str() != \"HasLoopBody\"\n                 })"}, {"sha": "1047373b1c75ea104608913537f099e5971d6343", "filename": "src/tools/rust-analyzer/crates/test-utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "8df7e1af611635d2486736e25ac8234e2cbf181a", "filename": "src/tools/rust-analyzer/crates/text-edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a6a3ae742aeb3f0c7ebc07783a9a64b72b25ff98", "filename": "src/tools/rust-analyzer/crates/toolchain/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "4f2103f3a97fc4174393249ea1d0bf0f1f0577a3", "filename": "src/tools/rust-analyzer/crates/tt/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "061f3c157a88c528025717fd4d411302a81b72ad", "filename": "src/tools/rust-analyzer/crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "e55bf6f293c436e23c9d6e8f5d02597740313cf6", "filename": "src/tools/rust-analyzer/crates/vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n description = \"TBD\"\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [lib]\n doctest = false"}, {"sha": "a07cf036e0604de89140018332f6deb362cc3035", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -481,7 +481,7 @@ It is not cheap enough to enable in prod, and this is a bug which should be fixe\n rust-analyzer strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.\n The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.\n There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.\n-Enabling them by default is a matter of discoverability, as many users end up don't know about some features even though they are presented in the manual.\n+Enabling them by default is a matter of discoverability, as many users don't know about some features even though they are presented in the manual.\n Mind the code--architecture gap: at the moment, we are using fewer feature flags than we really should.\n \n ### Serialization\n@@ -492,8 +492,8 @@ If a type is serializable, then it is a part of some IPC boundary.\n You often don't control the other side of this boundary, so changing serializable types is hard.\n \n For this reason, the types in `ide`, `base_db` and below are not serializable by design.\n-If such types need to cross an IPC boundary, then the client of rust-analyzer needs to provide custom, client-specific serialization format.\n+If such types need to cross an IPC boundary, then the client of rust-analyzer needs to provide a custom, client-specific serialization format.\n This isolates backwards compatibility and migration concerns to a specific client.\n \n-For example, `rust-project.json` is it's own format -- it doesn't include `CrateGraph` as is.\n+For example, `rust-project.json` is its own format -- it doesn't include `CrateGraph` as is.\n Instead, it creates a `CrateGraph` by calling appropriate constructing functions."}, {"sha": "57f950034cbb7c0eb99c4cefee5e346d23a7694b", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -173,7 +173,7 @@ Whether to pass `--no-default-features` to Cargo. Defaults to\n --\n Override the command rust-analyzer uses instead of `cargo check` for\n diagnostics on save. The command is required to output json and\n-should therefor include `--message-format=json` or a similar option.\n+should therefore include `--message-format=json` or a similar option.\n \n If you're changing this because you're using some tool wrapping\n Cargo, you might also want to change\n@@ -190,11 +190,15 @@ cargo check --workspace --message-format=json --all-targets\n ```\n .\n --\n-[[rust-analyzer.checkOnSave.target]]rust-analyzer.checkOnSave.target (default: `null`)::\n+[[rust-analyzer.checkOnSave.target]]rust-analyzer.checkOnSave.target (default: `[]`)::\n +\n --\n-Check for a specific target. Defaults to\n-`#rust-analyzer.cargo.target#`.\n+Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\n+\n+Can be a single target, e.g. `\"x86_64-unknown-linux-gnu\"` or a list of targets, e.g.\n+`[\"aarch64-apple-darwin\", \"x86_64-apple-darwin\"]`.\n+\n+Aliased as `\"checkOnSave.targets\"`.\n --\n [[rust-analyzer.completion.autoimport.enable]]rust-analyzer.completion.autoimport.enable (default: `true`)::\n +\n@@ -450,6 +454,11 @@ to always show them).\n --\n Whether to show inlay type hints for return types of closures.\n --\n+[[rust-analyzer.inlayHints.expressionAdjustmentHints.enable]]rust-analyzer.inlayHints.expressionAdjustmentHints.enable (default: `\"never\"`)::\n++\n+--\n+Whether to show inlay hints for type adjustments.\n+--\n [[rust-analyzer.inlayHints.lifetimeElisionHints.enable]]rust-analyzer.inlayHints.lifetimeElisionHints.enable (default: `\"never\"`)::\n +\n --\n@@ -474,7 +483,8 @@ site.\n [[rust-analyzer.inlayHints.reborrowHints.enable]]rust-analyzer.inlayHints.reborrowHints.enable (default: `\"never\"`)::\n +\n --\n-Whether to show inlay type hints for compiler inserted reborrows.\n+Whether to show inlay hints for compiler inserted reborrows.\n+This setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\n --\n [[rust-analyzer.inlayHints.renderColons]]rust-analyzer.inlayHints.renderColons (default: `true`)::\n +"}, {"sha": "1a4c70575b033af617a301a7db203a99f9da0252", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -367,7 +367,7 @@ if executable('rust-analyzer')\n endif\n ----\n \n-There is no dedicated UI for the server configuration, so you would need to send any options as a value of the `initialization_options` field, as described in the <<_configuration,Configuration>> section.\n+There is no dedicated UI for the server configuration, so you would need to send any options as a value of the `initialization_options` field, as described in the <<configuration,Configuration>> section.\n Here is an example of how to enable the proc-macro support:\n \n [source,vim]"}, {"sha": "c4d4e428ea07d9d60cd855e2097ad6b178333ce4", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -396,6 +396,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.diagnostics.previewRustcOutput\": {\n+                    \"markdownDescription\": \"Whether to show the main part of the rendered rustc output of a diagnostic message.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.emitMustUse\": {\n                     \"markdownDescription\": \"Whether to insert #[must_use] when generating `as_` methods\\nfor enum variants.\",\n@@ -623,7 +628,7 @@\n                     ]\n                 },\n                 \"rust-analyzer.checkOnSave.overrideCommand\": {\n-                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefor include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nIf there are multiple linked projects, this command is invoked for\\neach of them, with the working directory being the project root\\n(i.e., the folder containing the `Cargo.toml`).\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n+                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefore include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nIf there are multiple linked projects, this command is invoked for\\neach of them, with the working directory being the project root\\n(i.e., the folder containing the `Cargo.toml`).\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,\n                     \"type\": [\n                         \"null\",\n@@ -634,11 +639,18 @@\n                     }\n                 },\n                 \"rust-analyzer.checkOnSave.target\": {\n-                    \"markdownDescription\": \"Check for a specific target. Defaults to\\n`#rust-analyzer.cargo.target#`.\",\n-                    \"default\": null,\n-                    \"type\": [\n-                        \"null\",\n-                        \"string\"\n+                    \"markdownDescription\": \"Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.\\n\\nCan be a single target, e.g. `\\\"x86_64-unknown-linux-gnu\\\"` or a list of targets, e.g.\\n`[\\\"aarch64-apple-darwin\\\", \\\"x86_64-apple-darwin\\\"]`.\\n\\nAliased as `\\\"checkOnSave.targets\\\"`.\",\n+                    \"default\": [],\n+                    \"anyOf\": [\n+                        {\n+                            \"type\": \"string\"\n+                        },\n+                        {\n+                            \"type\": \"array\",\n+                            \"items\": {\n+                                \"type\": \"string\"\n+                            }\n+                        }\n                     ]\n                 },\n                 \"rust-analyzer.completion.autoimport.enable\": {\n@@ -935,6 +947,21 @@\n                         \"Only show type hints for return types of closures with blocks.\"\n                     ]\n                 },\n+                \"rust-analyzer.inlayHints.expressionAdjustmentHints.enable\": {\n+                    \"markdownDescription\": \"Whether to show inlay hints for type adjustments.\",\n+                    \"default\": \"never\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"always\",\n+                        \"never\",\n+                        \"reborrow\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Always show all adjustment hints.\",\n+                        \"Never show adjustment hints.\",\n+                        \"Only show auto borrow and dereference adjustment hints.\"\n+                    ]\n+                },\n                 \"rust-analyzer.inlayHints.lifetimeElisionHints.enable\": {\n                     \"markdownDescription\": \"Whether to show inlay type hints for elided lifetimes in function signatures.\",\n                     \"default\": \"never\",\n@@ -970,7 +997,7 @@\n                     \"type\": \"boolean\"\n                 },\n                 \"rust-analyzer.inlayHints.reborrowHints.enable\": {\n-                    \"markdownDescription\": \"Whether to show inlay type hints for compiler inserted reborrows.\",\n+                    \"markdownDescription\": \"Whether to show inlay hints for compiler inserted reborrows.\\nThis setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.\",\n                     \"default\": \"never\",\n                     \"type\": \"string\",\n                     \"enum\": [\n@@ -1276,6 +1303,11 @@\n                 \"$generated-end\": {}\n             }\n         },\n+        \"configurationDefaults\": {\n+            \"explorer.fileNesting.patterns\": {\n+                \"Cargo.toml\": \"Cargo.lock\"\n+            }\n+        },\n         \"problemPatterns\": [\n             {\n                 \"name\": \"rustc\","}, {"sha": "23e039722ee334ac1634d2c5a0093e2ce1a4ea26", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ import * as ra from \"../src/lsp_ext\";\n import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import { WorkspaceEdit } from \"vscode\";\n-import { substituteVSCodeVariables } from \"./config\";\n+import { Config, substituteVSCodeVariables } from \"./config\";\n import { randomUUID } from \"crypto\";\n \n export interface Env {\n@@ -66,7 +66,8 @@ export async function createClient(\n     traceOutputChannel: vscode.OutputChannel,\n     outputChannel: vscode.OutputChannel,\n     initializationOptions: vscode.WorkspaceConfiguration,\n-    serverOptions: lc.ServerOptions\n+    serverOptions: lc.ServerOptions,\n+    config: Config\n ): Promise<lc.LanguageClient> {\n     const clientOptions: lc.LanguageClientOptions = {\n         documentSelector: [{ scheme: \"file\", language: \"rust\" }],\n@@ -99,6 +100,43 @@ export async function createClient(\n                     }\n                 },\n             },\n+            async handleDiagnostics(\n+                uri: vscode.Uri,\n+                diagnostics: vscode.Diagnostic[],\n+                next: lc.HandleDiagnosticsSignature\n+            ) {\n+                const preview = config.previewRustcOutput;\n+                diagnostics.forEach((diag, idx) => {\n+                    // Abuse the fact that VSCode leaks the LSP diagnostics data field through the\n+                    // Diagnostic class, if they ever break this we are out of luck and have to go\n+                    // back to the worst diagnostics experience ever:)\n+\n+                    // We encode the rendered output of a rustc diagnostic in the rendered field of\n+                    // the data payload of the lsp diagnostic. If that field exists, overwrite the\n+                    // diagnostic code such that clicking it opens the diagnostic in a readonly\n+                    // text editor for easy inspection\n+                    const rendered = (diag as unknown as { data?: { rendered?: string } }).data\n+                        ?.rendered;\n+                    if (rendered) {\n+                        if (preview) {\n+                            const index = rendered.match(/^(note|help):/m)?.index || 0;\n+                            diag.message = rendered\n+                                .substring(0, index)\n+                                .replace(/^ -->[^\\n]+\\n/m, \"\");\n+                        }\n+                        diag.code = {\n+                            target: vscode.Uri.from({\n+                                scheme: \"rust-analyzer-diagnostics-view\",\n+                                path: \"/diagnostic message\",\n+                                fragment: uri.toString(),\n+                                query: idx.toString(),\n+                            }),\n+                            value: \"Click for full compiler diagnostic\",\n+                        };\n+                    }\n+                });\n+                return next(uri, diagnostics);\n+            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,"}, {"sha": "d8dbd1df16dfbceecee1e7249dec38046ccbe41d", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -238,6 +238,9 @@ export class Config {\n             gotoTypeDef: this.get<boolean>(\"hover.actions.gotoTypeDef.enable\"),\n         };\n     }\n+    get previewRustcOutput() {\n+        return this.get<boolean>(\"diagnostics.previewRustcOutput\");\n+    }\n }\n \n const VarRegex = new RegExp(/\\$\\{(.+?)\\}/g);"}, {"sha": "d6cee5c8fc6100926f7675edb81033759e43dfef", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -179,7 +179,8 @@ export class Ctx {\n                 this.traceOutputChannel,\n                 this.outputChannel,\n                 initializationOptions,\n-                serverOptions\n+                serverOptions,\n+                this.config\n             );\n             this.pushClientCleanup(\n                 this._client.onNotification(ra.serverStatus, (params) =>"}, {"sha": "25f1e83d109cbba173e01bdb336454bb616268a9", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -48,6 +48,30 @@ async function activateServer(ctx: Ctx): Promise<RustAnalyzerExtensionApi> {\n         ctx.pushExtCleanup(activateTaskProvider(ctx.config));\n     }\n \n+    ctx.pushExtCleanup(\n+        vscode.workspace.registerTextDocumentContentProvider(\n+            \"rust-analyzer-diagnostics-view\",\n+            new (class implements vscode.TextDocumentContentProvider {\n+                async provideTextDocumentContent(uri: vscode.Uri): Promise<string> {\n+                    const diags = ctx.client?.diagnostics?.get(\n+                        vscode.Uri.parse(uri.fragment, true)\n+                    );\n+                    if (!diags) {\n+                        return \"Unable to find original rustc diagnostic\";\n+                    }\n+\n+                    const diag = diags[parseInt(uri.query)];\n+                    if (!diag) {\n+                        return \"Unable to find original rustc diagnostic\";\n+                    }\n+                    const rendered = (diag as unknown as { data?: { rendered?: string } }).data\n+                        ?.rendered;\n+                    return rendered ?? \"Unable to find original rustc diagnostic\";\n+                }\n+            })()\n+        )\n+    );\n+\n     vscode.workspace.onDidChangeWorkspaceFolders(\n         async (_) => ctx.onWorkspaceFolderChanges(),\n         null,"}, {"sha": "95e27beab5dc12506d23463e4f3f04222c39e295", "filename": "src/tools/rust-analyzer/xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37c352159755d8c7c9a35c653af3d4141c7d2680/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml?ref=37c352159755d8c7c9a35c653af3d4141c7d2680", "patch": "@@ -4,7 +4,7 @@ version = \"0.1.0\"\n publish = false\n license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n-rust-version = \"1.57\"\n+rust-version = \"1.65\"\n \n [dependencies]\n anyhow = \"1.0.62\""}]}