{"sha": "b2aa00ba8b3539985c77f84b01e5781dd1455177", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYWEwMGJhOGIzNTM5OTg1Yzc3Zjg0YjAxZTU3ODFkZDE0NTUxNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-01T11:11:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-01T11:11:58Z"}, "message": "auto merge of #10676 : eddyb/rust/ast-box-in-enums, r=cmr\n\n**Note**: I only tested on top of my #10670 PR, size reductions come from both change sets.\r\n\r\nWith this, [more enums are shrinked](https://gist.github.com/eddyb/08fef0dfc6ff54e890bc), the most significant one being `ast_node`, from 104 bytes (master) to 96 (#10670) and now to 32 bytes.\r\n\r\nMy own testcase requires **200MB** less when compiling (not including the other **200MB** gained in #10670), and rustc-stage2 is down by about **130MB**.\r\n\r\nI believe there is more to gain by fiddling with the enums' layouts.", "tree": {"sha": "7db7b6c693714e3254715698b055e6d47787507b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7db7b6c693714e3254715698b055e6d47787507b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2aa00ba8b3539985c77f84b01e5781dd1455177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2aa00ba8b3539985c77f84b01e5781dd1455177", "html_url": "https://github.com/rust-lang/rust/commit/b2aa00ba8b3539985c77f84b01e5781dd1455177", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2aa00ba8b3539985c77f84b01e5781dd1455177/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c470184c20167f9f41613d5f4a1d75840e0f5c3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c470184c20167f9f41613d5f4a1d75840e0f5c3a", "html_url": "https://github.com/rust-lang/rust/commit/c470184c20167f9f41613d5f4a1d75840e0f5c3a"}, {"sha": "a9c4b18b18bd3f5fd4a4c20489f37c52d106fc81", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c4b18b18bd3f5fd4a4c20489f37c52d106fc81", "html_url": "https://github.com/rust-lang/rust/commit/a9c4b18b18bd3f5fd4a4c20489f37c52d106fc81"}], "stats": {"total": 1263, "additions": 623, "deletions": 640}, "files": [{"sha": "e9dfed46f73cbdba3510c36a23a8a1a82b216c69", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -27,7 +27,7 @@ impl<'self> fold::ast_fold for Context<'self> {\n     fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+    fn fold_block(&self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         fold_block(self, block)\n     }\n     fn fold_foreign_mod(&self, foreign_module: &ast::foreign_mod)\n@@ -97,10 +97,10 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n \n fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, ref b, ref c, ref methods) => {\n+        ast::item_impl(ref a, ref b, c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .map(|x| *x).collect();\n-            ast::item_impl((*a).clone(), (*b).clone(), (*c).clone(), methods)\n+            ast::item_impl((*a).clone(), (*b).clone(), c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter()\n@@ -129,22 +129,22 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n     }\n }\n \n-fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n+fn fold_block(cx: &Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     let resulting_stmts = b.stmts.iter()\n             .filter(|&a| retain_stmt(cx, *a))\n             .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n             .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n-    ast::Block {\n+    ast::P(ast::Block {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n         expr: b.expr.map(|x| cx.fold_expr(x)),\n         id: b.id,\n         rules: b.rules,\n         span: b.span,\n-    }\n+    })\n }\n \n fn item_in_cfg(cx: &Context, item: @ast::item) -> bool {"}, {"sha": "b517d890c59f7c25610527be13787bd9d4ccf6fa", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -352,7 +352,7 @@ fn encode_struct_fields(ecx: &EncodeContext,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: NodeId,\n-                            variants: &[variant],\n+                            variants: &[P<variant>],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n@@ -1081,7 +1081,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         def_id.node);\n         }\n       }\n-      item_impl(_, ref opt_trait, ref ty, ref ast_methods) => {\n+      item_impl(_, ref opt_trait, ty, ref ast_methods) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let imp = tcx.impls.get(&def_id);"}, {"sha": "e8a7e73b58c911d8252298c78189020f08bc0a63", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -301,7 +301,7 @@ struct NestedItemsDropper {\n }\n \n impl fold::ast_fold for NestedItemsDropper {\n-    fn fold_block(&self, blk: &ast::Block) -> ast::Block {\n+    fn fold_block(&self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n                 ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n@@ -316,16 +316,16 @@ impl fold::ast_fold for NestedItemsDropper {\n                 ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n             }\n         }).collect();\n-        let blk_sans_items = ast::Block {\n+        let blk_sans_items = ast::P(ast::Block {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!\n             stmts: stmts_sans_items,\n             expr: blk.expr,\n             id: blk.id,\n             rules: blk.rules,\n             span: blk.span,\n-        };\n-        fold::noop_fold_block(&blk_sans_items, self)\n+        });\n+        fold::noop_fold_block(blk_sans_items, self)\n     }\n }\n "}, {"sha": "4e1fca1e1250f1b7ba55a86d0abb65b57a87cafc", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -48,14 +48,14 @@ impl<'self> Visitor<()> for CheckLoanCtxt<'self> {\n     fn visit_local(&mut self, l:@ast::Local, _:()) {\n         check_loans_in_local(self, l);\n     }\n-    fn visit_block(&mut self, b:&ast::Block, _:()) {\n+    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) {\n         check_loans_in_block(self, b);\n     }\n     fn visit_pat(&mut self, p:&ast::Pat, _:()) {\n         check_loans_in_pat(self, p);\n     }\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, _:()) {\n+                b:ast::P<ast::Block>, s:Span, n:ast::NodeId, _:()) {\n         check_loans_in_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -64,7 +64,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n-                   body: &ast::Block) {\n+                   body: ast::P<ast::Block>) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n@@ -724,7 +724,7 @@ impl<'self> CheckLoanCtxt<'self> {\n fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                          fk: &visit::fn_kind,\n                          decl: &ast::fn_decl,\n-                         body: &ast::Block,\n+                         body: ast::P<ast::Block>,\n                          sp: Span,\n                          id: ast::NodeId) {\n     match *fk {\n@@ -855,7 +855,7 @@ fn check_loans_in_pat<'a>(this: &mut CheckLoanCtxt<'a>,\n }\n \n fn check_loans_in_block<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            blk: &ast::Block)\n+                            blk: ast::P<ast::Block>)\n {\n     visit::walk_block(this, blk, ());\n     this.check_for_conflicting_loans(blk.id);"}, {"sha": "787cba86bb4c4ea17af9450b19c8e3ad1d0e6ec1", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -32,7 +32,7 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::{Visitor, fn_kind};\n-use syntax::ast::{Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n+use syntax::ast::{P, Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n \n mod lifetime;\n mod restrictions;\n@@ -77,10 +77,10 @@ impl<'self> visit::Visitor<()> for GatherLoanCtxt<'self> {\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n         gather_loans_in_expr(self, ex);\n     }\n-    fn visit_block(&mut self, b:&Block, _:()) {\n+    fn visit_block(&mut self, b:P<Block>, _:()) {\n         gather_loans_in_block(self, b);\n     }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block,\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>,\n                 s:Span, n:NodeId, _:()) {\n         gather_loans_in_fn(self, fk, fd, b, s, n);\n     }\n@@ -102,7 +102,7 @@ impl<'self> visit::Visitor<()> for GatherLoanCtxt<'self> {\n \n pub fn gather_loans(bccx: &BorrowckCtxt,\n                     decl: &ast::fn_decl,\n-                    body: &ast::Block)\n+                    body: ast::P<ast::Block>)\n                     -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n@@ -131,7 +131,7 @@ fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       fk: &fn_kind,\n                       decl: &ast::fn_decl,\n-                      body: &ast::Block,\n+                      body: ast::P<ast::Block>,\n                       sp: Span,\n                       id: ast::NodeId) {\n     match fk {\n@@ -150,7 +150,7 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n }\n \n fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n-                         blk: &ast::Block) {\n+                         blk: ast::P<ast::Block>) {\n     this.id_range.add(blk.id);\n     visit::walk_block(this, blk, ());\n }\n@@ -286,7 +286,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::ExprWhile(cond, ref body) => {\n+      ast::ExprWhile(cond, body) => {\n           // during the condition, can only root for the condition\n           this.push_repeating_id(cond.id);\n           this.visit_expr(cond, ());\n@@ -299,7 +299,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::ExprLoop(ref body, _) => {\n+      ast::ExprLoop(body, _) => {\n           this.push_repeating_id(body.id);\n           visit::walk_expr(this, ex, ());\n           this.pop_repeating_id(body.id);"}, {"sha": "b8e7a13f2088a1518327f719c757273c115de3aa", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -29,7 +29,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{fn_decl,Block,NodeId};\n+use syntax::ast::{P,fn_decl,Block,NodeId};\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -62,7 +62,7 @@ pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n impl Visitor<()> for BorrowckCtxt {\n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, _:()) {\n+                b:P<Block>, s:Span, n:NodeId, _:()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -123,7 +123,7 @@ pub fn check_crate(\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: &visit::fn_kind,\n                decl: &ast::fn_decl,\n-               body: &ast::Block,\n+               body: ast::P<ast::Block>,\n                sp: Span,\n                id: ast::NodeId) {\n     match fk {"}, {"sha": "4a12ac4ccff4b3aa366a3b80cd552e93f328040d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -161,12 +161,12 @@ impl CFGBuilder {\n \n     fn expr(&mut self, expr: @ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprBlock(blk) => {\n                 let blk_exit = self.block(blk, pred);\n                 self.add_node(expr.id, [blk_exit])\n             }\n \n-            ast::ExprIf(cond, ref then, None) => {\n+            ast::ExprIf(cond, then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -186,7 +186,7 @@ impl CFGBuilder {\n                 self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n             }\n \n-            ast::ExprIf(cond, ref then, Some(otherwise)) => {\n+            ast::ExprIf(cond, then, Some(otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -207,7 +207,7 @@ impl CFGBuilder {\n                 self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n             }\n \n-            ast::ExprWhile(cond, ref body) => {\n+            ast::ExprWhile(cond, body) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -241,7 +241,7 @@ impl CFGBuilder {\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(ref body, _) => {\n+            ast::ExprLoop(body, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -300,7 +300,7 @@ impl CFGBuilder {\n                 for arm in arms.iter() {\n                     guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n                     let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n-                    let body_exit = self.block(&arm.body, pats_exit);    // 4\n+                    let body_exit = self.block(arm.body, pats_exit);    // 4\n                     self.add_contained_edge(body_exit, expr_exit);       // 5\n                 }\n                 expr_exit"}, {"sha": "a08884857a6062206b7bc8e8050d6967348d5853", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -35,14 +35,14 @@ impl Visitor<Context> for CheckLoopVisitor {\n \n     fn visit_expr(&mut self, e: @ast::Expr, cx:Context) {\n         match e.node {\n-            ast::ExprWhile(e, ref b) => {\n+            ast::ExprWhile(e, b) => {\n                 self.visit_expr(e, cx);\n                 self.visit_block(b, Loop);\n             }\n-            ast::ExprLoop(ref b, _) => {\n+            ast::ExprLoop(b, _) => {\n                 self.visit_block(b, Loop);\n             }\n-            ast::ExprFnBlock(_, ref b) | ast::ExprProc(_, ref b) => {\n+            ast::ExprFnBlock(_, b) | ast::ExprProc(_, b) => {\n                 self.visit_block(b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),"}, {"sha": "7e236a875143470248916849a60f61a62cf6ac84", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -45,7 +45,7 @@ impl Visitor<()> for CheckMatchVisitor {\n     fn visit_local(&mut self, l:@Local, e:()) {\n         check_local(self, self.cx, l, e);\n     }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:()) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:()) {\n         check_fn(self, self.cx, fk, fd, b, s, n, e);\n     }\n }\n@@ -827,7 +827,7 @@ fn check_fn(v: &mut CheckMatchVisitor,\n                 cx: &MatchCheckCtxt,\n                 kind: &visit::fn_kind,\n                 decl: &fn_decl,\n-                body: &Block,\n+                body: P<Block>,\n                 sp: Span,\n                 id: NodeId,\n                 s: ()) {"}, {"sha": "248ff1fdd163202b04ded2dbc5fc094b91b52943", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -90,7 +90,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n                        -> Option<@Expr> {\n-    fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@Expr> {\n+    fn variant_expr(variants: &[ast::P<ast::variant>], id: ast::NodeId) -> Option<@Expr> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;"}, {"sha": "6ef3b70dba8bb7257010426bf967120a4f6f9c1b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -429,8 +429,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.merge_with_entry_set(expr.id, in_out);\n \n         match expr.node {\n-            ast::ExprFnBlock(ref decl, ref body) |\n-            ast::ExprProc(ref decl, ref body) => {\n+            ast::ExprFnBlock(ref decl, body) |\n+            ast::ExprProc(ref decl, body) => {\n                 if self.dfcx.oper.walk_closures() {\n                     // In the absence of once fns, we must assume that\n                     // every function body will execute more than\n@@ -519,7 +519,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 }\n             }\n \n-            ast::ExprIf(cond, ref then, els) => {\n+            ast::ExprIf(cond, then, els) => {\n                 //\n                 //     (cond)\n                 //       |\n@@ -542,7 +542,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 join_bits(&self.dfcx.oper, then_bits, in_out);\n             }\n \n-            ast::ExprWhile(cond, ref blk) => {\n+            ast::ExprWhile(cond, blk) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -570,7 +570,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(ref blk, _) => {\n+            ast::ExprLoop(blk, _) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -623,7 +623,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                     // them into `in_out`, which reflects all bodies to date\n                     let mut body = reslice(guards).to_owned();\n                     self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n-                    self.walk_block(&arm.body, body, loop_scopes);\n+                    self.walk_block(arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n                 }\n             }\n@@ -730,7 +730,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 }\n             }\n \n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprBlock(blk) => {\n                 self.walk_block(blk, in_out, loop_scopes);\n             }\n "}, {"sha": "aff37264f24e2ca1dbdd314f58b5bf0131b87ed2", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -81,7 +81,7 @@ impl EffectCheckVisitor {\n \n impl Visitor<()> for EffectCheckVisitor {\n     fn visit_fn(&mut self, fn_kind: &visit::fn_kind, fn_decl: &ast::fn_decl,\n-                block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n+                block: ast::P<ast::Block>, span: Span, node_id: ast::NodeId, _:()) {\n \n         let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n             visit::fk_item_fn(_, _, purity, _) =>\n@@ -103,7 +103,7 @@ impl Visitor<()> for EffectCheckVisitor {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &ast::Block, _:()) {\n+    fn visit_block(&mut self, block: ast::P<ast::Block>, _:()) {\n         let old_unsafe_context = self.unsafe_context;\n         let is_unsafe = match block.rules {\n             ast::UnsafeBlock(..) => true, ast::DefaultBlock => false"}, {"sha": "10b72b06048d3dc5cd3db171fb1707be0e2b672d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -88,7 +88,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n+fn collect_freevars(def_map: resolve::DefMap, blk: ast::P<ast::Block>)\n     -> freevar_info {\n     let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n@@ -110,7 +110,7 @@ struct AnnotateFreevarsVisitor {\n \n impl Visitor<()> for AnnotateFreevarsVisitor {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                blk:&ast::Block, s:Span, nid:ast::NodeId, _:()) {\n+                blk:ast::P<ast::Block>, s:Span, nid:ast::NodeId, _:()) {\n         let vars = collect_freevars(self.def_map, blk);\n         self.freevars.insert(nid, vars);\n         visit::walk_fn(self, fk, fd, blk, s, nid, ());"}, {"sha": "c1b2b304c518a28ed7cee774b43a74cfccdc9f05", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -62,7 +62,7 @@ impl Visitor<()> for Context {\n         check_expr(self, ex);\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, _:()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n \n@@ -154,7 +154,7 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n fn check_item(cx: &mut Context, item: @item) {\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n+            item_impl(_, Some(ref trait_ref), self_type, _) => {\n                 check_impl_of_trait(cx, item, trait_ref, self_type);\n             }\n             _ => {}\n@@ -240,7 +240,7 @@ fn check_fn(\n     cx: &mut Context,\n     fk: &visit::fn_kind,\n     decl: &fn_decl,\n-    body: &Block,\n+    body: P<Block>,\n     sp: Span,\n     fn_id: NodeId) {\n "}, {"sha": "ad753227c20035102b56a45e7db13519418d2070", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -733,19 +733,19 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n         for input in decl.inputs.iter() {\n-            check_ty(cx, &input.ty);\n+            check_ty(cx, input.ty);\n         }\n-        check_ty(cx, &decl.output)\n+        check_ty(cx, decl.output)\n     }\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n-                ast::foreign_item_fn(ref decl, _) => {\n+                ast::foreign_item_fn(decl, _) => {\n                     check_foreign_fn(cx, decl);\n                 }\n-                ast::foreign_item_static(ref t, _) => { check_ty(cx, t); }\n+                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n             }\n         }\n       }\n@@ -1267,7 +1267,7 @@ impl<'self> Visitor<()> for Context<'self> {\n     }\n \n     fn visit_fn(&mut self, fk: &visit::fn_kind, decl: &ast::fn_decl,\n-                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n+                body: ast::P<ast::Block>, span: Span, id: ast::NodeId, _: ()) {\n         let recurse = |this: &mut Context| {\n             visit::walk_fn(this, fk, decl, body, span, id, ());\n         };"}, {"sha": "d800b52df0f43e08034e0bb0ea9dfbc126082667", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -155,7 +155,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n struct LivenessVisitor;\n \n impl Visitor<@mut IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:@mut IrMaps) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:@mut IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n@@ -347,7 +347,7 @@ impl IrMaps {\n }\n \n impl Visitor<()> for Liveness {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, _:()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_local(&mut self, l:@Local, _:()) {\n@@ -364,7 +364,7 @@ impl Visitor<()> for Liveness {\n fn visit_fn(v: &mut LivenessVisitor,\n             fk: &visit::fn_kind,\n             decl: &fn_decl,\n-            body: &Block,\n+            body: P<Block>,\n             sp: Span,\n             id: NodeId,\n             this: @mut IrMaps) {\n@@ -1024,7 +1024,7 @@ impl Liveness {\n               self.propagate_through_expr(e, succ)\n           }\n \n-          ExprFnBlock(_, ref blk) | ExprProc(_, ref blk) => {\n+          ExprFnBlock(_, blk) | ExprProc(_, blk) => {\n               debug!(\"{} is an ExprFnBlock or ExprProc\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1047,7 +1047,7 @@ impl Liveness {\n               })\n           }\n \n-          ExprIf(cond, ref then, els) => {\n+          ExprIf(cond, then, els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1069,15 +1069,15 @@ impl Liveness {\n             self.propagate_through_expr(cond, ln)\n           }\n \n-          ExprWhile(cond, ref blk) => {\n+          ExprWhile(cond, blk) => {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n           ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ExprLoop(ref blk, _) => {\n+          ExprLoop(blk, _) => {\n             self.propagate_through_loop(expr, None, blk, succ)\n           }\n \n@@ -1101,7 +1101,7 @@ impl Liveness {\n             let mut first_merge = true;\n             for arm in arms.iter() {\n                 let body_succ =\n-                    self.propagate_through_block(&arm.body, succ);\n+                    self.propagate_through_block(arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n@@ -1247,7 +1247,7 @@ impl Liveness {\n             succ\n           }\n \n-          ExprBlock(ref blk) => {\n+          ExprBlock(blk) => {\n             self.propagate_through_block(blk, succ)\n           }\n "}, {"sha": "8cdca441d8a93bcb198035780d7dfaeaa7622db7", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -193,7 +193,7 @@ enum UseMode {\n \n impl visit::Visitor<()> for VisitContext {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, _:()) {\n+                b:P<Block>, s:Span, n:NodeId, _:()) {\n         compute_modes_for_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n@@ -247,7 +247,7 @@ fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n fn compute_modes_for_fn(cx: &mut VisitContext,\n                         fk: &visit::fn_kind,\n                         decl: &fn_decl,\n-                        body: &Block,\n+                        body: P<Block>,\n                         span: Span,\n                         id: NodeId) {\n     for a in decl.inputs.iter() {\n@@ -450,7 +450,7 @@ impl VisitContext {\n                 self.consume_exprs(*exprs);\n             }\n \n-            ExprIf(cond_expr, ref then_blk, opt_else_expr) => {\n+            ExprIf(cond_expr, then_blk, opt_else_expr) => {\n                 self.consume_expr(cond_expr);\n                 self.consume_block(then_blk);\n                 for else_expr in opt_else_expr.iter() {\n@@ -489,11 +489,11 @@ impl VisitContext {\n             ExprAgain(..) |\n             ExprLit(..) => {}\n \n-            ExprLoop(ref blk, _) => {\n+            ExprLoop(blk, _) => {\n                 self.consume_block(blk);\n             }\n \n-            ExprWhile(cond_expr, ref blk) => {\n+            ExprWhile(cond_expr, blk) => {\n                 self.consume_expr(cond_expr);\n                 self.consume_block(blk);\n             }\n@@ -515,7 +515,7 @@ impl VisitContext {\n                 }\n             }\n \n-            ExprBlock(ref blk) => {\n+            ExprBlock(blk) => {\n                 self.consume_block(blk);\n             }\n \n@@ -553,8 +553,8 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode);\n             }\n \n-            ExprFnBlock(ref decl, ref body) |\n-            ExprProc(ref decl, ref body) => {\n+            ExprFnBlock(ref decl, body) |\n+            ExprProc(ref decl, body) => {\n                 for a in decl.inputs.iter() {\n                     self.use_pat(a.pat);\n                 }\n@@ -604,7 +604,7 @@ impl VisitContext {\n             self.consume_expr(*guard);\n         }\n \n-        self.consume_block(&arm.body);\n+        self.consume_block(arm.body);\n     }\n \n     pub fn use_pat(&mut self, pat: @Pat) {"}, {"sha": "2556397caf907467f0ae1662f3cf8d978f84b43e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -96,7 +96,7 @@ impl Visitor<()> for ParentVisitor {\n     }\n \n     fn visit_fn(&mut self, a: &visit::fn_kind, b: &ast::fn_decl,\n-                c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n+                c: ast::P<ast::Block>, d: Span, id: ast::NodeId, _: ()) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n@@ -801,7 +801,7 @@ impl Visitor<()> for SanePrivacyVisitor {\n     }\n \n     fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n-                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n+                b: ast::P<ast::Block>, s: Span, n: ast::NodeId, _: ()) {\n         // This catches both functions and methods\n         let orig_in_fn = util::replace(&mut self.in_fn, true);\n         visit::walk_fn(self, fk, fd, b, s, n, ());"}, {"sha": "a6cd431c60375a526bb5565136911c159308e9e3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -304,7 +304,7 @@ impl ReachableContext {\n         match *node {\n             ast_map::node_item(item, _) => {\n                 match item.node {\n-                    ast::item_fn(_, _, _, _, ref search_block) => {\n+                    ast::item_fn(_, _, _, _, search_block) => {\n                         if item_might_be_inlined(item) {\n                             visit::walk_block(visitor, search_block, ())\n                         }\n@@ -331,13 +331,13 @@ impl ReachableContext {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::provided(ref method) => {\n-                        visit::walk_block(visitor, &method.body, ())\n+                        visit::walk_block(visitor, method.body, ())\n                     }\n                 }\n             }\n             ast_map::node_method(method, did, _) => {\n                 if method_might_be_inlined(self.tcx, method, did) {\n-                    visit::walk_block(visitor, &method.body, ())\n+                    visit::walk_block(visitor, method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "2a372a9e7173020da7d4d1fbe055cc2e74676521", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -29,7 +29,7 @@ use std::hashmap::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n+use syntax::ast::{P,Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n \n /**\n The region maps encode information about region relationships.\n@@ -322,7 +322,7 @@ fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor,\n-                 blk: &ast::Block,\n+                 blk: ast::P<ast::Block>,\n                  cx: Context) {\n     // Record the parent of this block.\n     parent_to_expr(visitor, cx, blk.id, blk.span);\n@@ -424,7 +424,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor,\n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n-              body: &ast::Block,\n+              body: ast::P<ast::Block>,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n@@ -466,15 +466,15 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n impl Visitor<Context> for RegionResolutionVisitor {\n \n-    fn visit_block(&mut self, b:&Block, cx:Context) {\n+    fn visit_block(&mut self, b:P<Block>, cx:Context) {\n         resolve_block(self, b, cx);\n     }\n \n     fn visit_item(&mut self, i:@item, cx:Context) {\n         resolve_item(self, i, cx);\n     }\n \n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, cx:Context) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, cx:Context) {\n         resolve_fn(self, fk, fd, b, s, n, cx);\n     }\n     fn visit_arm(&mut self, a:&Arm, cx:Context) {"}, {"sha": "74e7a2d921936a9db56ff0797f505ac296172f5d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -159,7 +159,7 @@ impl Visitor<()> for Resolver {\n     fn visit_arm(&mut self, arm:&Arm, _:()) {\n         self.resolve_arm(arm);\n     }\n-    fn visit_block(&mut self, block:&Block, _:()) {\n+    fn visit_block(&mut self, block:P<Block>, _:()) {\n         self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr:@Expr, _:()) {\n@@ -921,7 +921,7 @@ impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n         self.resolver.build_reduced_graph_for_view_item(view_item, context);\n     }\n \n-    fn visit_block(&mut self, block:&Block, context:ReducedGraphParent) {\n+    fn visit_block(&mut self, block:P<Block>, context:ReducedGraphParent) {\n         let np = self.resolver.build_reduced_graph_for_block(block, context);\n         visit::walk_block(self, block, np);\n     }\n@@ -1203,7 +1203,7 @@ impl Resolver {\n                 name_bindings.define_type\n                     (DefTy(local_def(item.id)), sp, is_public);\n \n-                for variant in (*enum_definition).variants.iter() {\n+                for &variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n                         variant,\n                         local_def(item.id),\n@@ -1240,7 +1240,7 @@ impl Resolver {\n                 new_parent\n             }\n \n-            item_impl(_, None, ref ty, ref methods) => {\n+            item_impl(_, None, ty, ref methods) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1250,11 +1250,8 @@ impl Resolver {\n                 // the same module that declared the type.\n \n                 // Create the module and add all methods.\n-                match ty {\n-                    &Ty {\n-                        node: ty_path(ref path, _, _),\n-                        ..\n-                    } if path.segments.len() == 1 => {\n+                match ty.node {\n+                    ty_path(ref path, _, _) if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let new_parent = match parent.children.find(&name.name) {\n@@ -3569,7 +3566,7 @@ impl Resolver {\n \n             item_impl(ref generics,\n                       ref implemented_traits,\n-                      ref self_type,\n+                      self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n@@ -3621,10 +3618,10 @@ impl Resolver {\n                                     &ty_m.generics.ty_params);\n \n                                 for argument in ty_m.decl.inputs.iter() {\n-                                    this.resolve_type(&argument.ty);\n+                                    this.resolve_type(argument.ty);\n                                 }\n \n-                                this.resolve_type(&ty_m.decl.output);\n+                                this.resolve_type(ty_m.decl.output);\n                             });\n                           }\n                           provided(m) => {\n@@ -3676,7 +3673,7 @@ impl Resolver {\n                 });\n             }\n \n-            item_fn(ref fn_decl, _, _, ref generics, ref block) => {\n+            item_fn(fn_decl, _, _, ref generics, block) => {\n                 self.resolve_function(OpaqueFunctionRibKind,\n                                       Some(fn_decl),\n                                       HasTypeParameters\n@@ -3760,9 +3757,9 @@ impl Resolver {\n \n     fn resolve_function(&mut self,\n                             rib_kind: RibKind,\n-                            optional_declaration: Option<&fn_decl>,\n+                            optional_declaration: Option<P<fn_decl>>,\n                             type_parameters: TypeParameters,\n-                            block: &Block,\n+                            block: P<Block>,\n                             self_binding: SelfBinding) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib::new(rib_kind);\n@@ -3811,12 +3808,12 @@ impl Resolver {\n                                              binding_mode,\n                                              None);\n \n-                        this.resolve_type(&argument.ty);\n+                        this.resolve_type(argument.ty);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    this.resolve_type(&declaration.output);\n+                    this.resolve_type(declaration.output);\n                 }\n             }\n \n@@ -3909,7 +3906,7 @@ impl Resolver {\n \n             // Resolve fields.\n             for field in fields.iter() {\n-                this.resolve_type(&field.node.ty);\n+                this.resolve_type(field.node.ty);\n             }\n         });\n     }\n@@ -3933,9 +3930,9 @@ impl Resolver {\n         };\n \n         self.resolve_function(rib_kind,\n-                              Some(&method.decl),\n+                              Some(method.decl),\n                               type_parameters,\n-                              &method.body,\n+                              method.body,\n                               self_binding);\n     }\n \n@@ -3995,7 +3992,7 @@ impl Resolver {\n                     self.resolve_function(MethodRibKind(\n                                           id,\n                                           Provided(method.id)),\n-                                          Some(@method.decl),\n+                                          Some(method.decl),\n                                           HasTypeParameters\n                                             (borrowed_type_parameters,\n                                              method.id,\n@@ -4027,7 +4024,7 @@ impl Resolver {\n \n     fn resolve_local(&mut self, local: @Local) {\n         // Resolve the type.\n-        self.resolve_type(&local.ty);\n+        self.resolve_type(local.ty);\n \n         // Resolve the initializer, if necessary.\n         match local.init {\n@@ -4112,12 +4109,12 @@ impl Resolver {\n         self.check_consistent_bindings(arm);\n \n         visit::walk_expr_opt(self, arm.guard, ());\n-        self.resolve_block(&arm.body);\n+        self.resolve_block(arm.body);\n \n         self.value_ribs.pop();\n     }\n \n-    fn resolve_block(&mut self, block: &Block) {\n+    fn resolve_block(&mut self, block: P<Block>) {\n         debug!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n@@ -4374,7 +4371,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.segments\n+                    for &ty in path.segments\n                                   .iter()\n                                   .flat_map(|seg| seg.types.iter()) {\n                         self.resolve_type(ty);\n@@ -4409,7 +4406,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.segments\n+                    for &ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty);\n@@ -4446,7 +4443,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.segments\n+                    for &ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty);\n@@ -4550,7 +4547,7 @@ impl Resolver {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+        for &ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n             self.resolve_type(ty);\n         }\n \n@@ -5034,8 +5031,8 @@ impl Resolver {\n                 visit::walk_expr(self, expr, ());\n             }\n \n-            ExprFnBlock(ref fn_decl, ref block) |\n-            ExprProc(ref fn_decl, ref block) => {\n+            ExprFnBlock(fn_decl, block) |\n+            ExprProc(fn_decl, block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl),\n                                       NoTypeParameters,"}, {"sha": "1ff4d3953562afee2a4cd2f38e4f988e2e15659b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -84,7 +84,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n     fn visit_fn(&mut self,\n                 fk: &visit::fn_kind,\n                 fd: &ast::fn_decl,\n-                b: &ast::Block,\n+                b: ast::P<ast::Block>,\n                 s: Span,\n                 n: ast::NodeId,\n                 scope: &'self ScopeChain<'self>) {\n@@ -132,7 +132,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n     }\n \n     fn visit_block(&mut self,\n-                   b: &ast::Block,\n+                   b: ast::P<ast::Block>,\n                    scope: &'self ScopeChain<'self>) {\n         let scope1 = BlockScope(b.id, scope);\n         debug!(\"pushing block scope {}\", b.id);"}, {"sha": "f4479b98e61bde3cb834025c0d9ef1a0bd784b0e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -1935,7 +1935,7 @@ fn trans_match_inner(scope_cx: @mut Block,\n         // insert bindings into the lllocals map and add cleanups\n         bcx = insert_lllocals(bcx, arm_data.bindings_map, true);\n \n-        bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n+        bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n         arm_cxs.push(bcx);\n     }"}, {"sha": "1dba8169da831a72897f2398541347451b13edae", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -2054,17 +2054,17 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n \n trait IdAndTy {\n     fn id(&self) -> ast::NodeId;\n-    fn ty<'a>(&'a self) -> &'a ast::Ty;\n+    fn ty(&self) -> ast::P<ast::Ty>;\n }\n \n impl IdAndTy for ast::variant_arg {\n     fn id(&self) -> ast::NodeId { self.id }\n-    fn ty<'a>(&'a self) -> &'a ast::Ty { &self.ty }\n+    fn ty(&self) -> ast::P<ast::Ty> { self.ty }\n }\n \n impl IdAndTy for @ast::struct_field {\n     fn id(&self) -> ast::NodeId { self.node.id }\n-    fn ty<'a>(&'a self) -> &'a ast::Ty { &self.node.ty }\n+    fn ty(&self) -> ast::P<ast::Ty> { self.node.ty }\n }\n \n pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n@@ -2078,7 +2078,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     // Translate variant arguments to function arguments.\n     let fn_args = args.map(|varg| {\n         ast::arg {\n-            ty: (*varg.ty()).clone(),\n+            ty: varg.ty(),\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n                 codemap::dummy_sp(),\n@@ -2149,7 +2149,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n-    for variant in enum_definition.variants.iter() {\n+    for &variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n@@ -2187,7 +2187,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n         _ => fail!(\"trans_item\"),\n     };\n     match item.node {\n-      ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n+      ast::item_fn(decl, purity, _abis, ref generics, body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi("}, {"sha": "d0aeafeef07f2f1dafa708a950cce8d7e17ec50d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -590,12 +590,6 @@ impl Visitor<()> for CalleeTranslationVisitor {\n \n }\n \n-pub fn body_contains_ret(body: &ast::Block) -> bool {\n-    let mut v = CalleeTranslationVisitor{ flag: false };\n-    visit::walk_block(&mut v, body, ());\n-    v.flag\n-}\n-\n pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,"}, {"sha": "240ab9d21300356aacdb0cc289a6070ef924202f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -47,7 +47,7 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n \n pub fn trans_if(bcx: @mut Block,\n             cond: &ast::Expr,\n-            thn: &ast::Block,\n+            thn: ast::P<ast::Block>,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n          -> @mut Block {\n@@ -142,9 +142,9 @@ pub fn trans_if(bcx: @mut Block,\n         let else_bcx_out = match elexpr.node {\n             ast::ExprIf(_, _, _) => {\n                 let elseif_blk = ast_util::block_from_expr(elexpr);\n-                trans_block(else_bcx_in, &elseif_blk, dest)\n+                trans_block(else_bcx_in, elseif_blk, dest)\n             }\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprBlock(blk) => {\n                 trans_block(else_bcx_in, blk, dest)\n             }\n             // would be nice to have a constraint on ifs"}, {"sha": "04b906a559c3841d9144e1e5bcf59b2ca614ddd0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -554,7 +554,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                ast::item_fn(fn_decl, _, _, ref generics, top_level_block) => {\n                     (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n@@ -565,10 +565,10 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         ast_map::node_method(\n             @ast::method {\n-                decl: ref fn_decl,\n+                decl: fn_decl,\n                 ident: ident,\n                 generics: ref generics,\n-                body: ref top_level_block,\n+                body: top_level_block,\n                 span: span,\n                 ..\n             },\n@@ -578,8 +578,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::ExprFnBlock(ref fn_decl, ref top_level_block) |\n-                ast::ExprProc(ref fn_decl, ref top_level_block) => {\n+                ast::ExprFnBlock(fn_decl, top_level_block) |\n+                ast::ExprProc(fn_decl, top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name);\n                     (name, fn_decl,\n@@ -598,10 +598,10 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_trait_method(\n             @ast::provided(\n                 @ast::method {\n-                    decl: ref fn_decl,\n+                    decl: fn_decl,\n                     ident: ident,\n                     generics: ref generics,\n-                    body: ref top_level_block,\n+                    body: top_level_block,\n                     span: span,\n                     ..\n                 }),\n@@ -2554,7 +2554,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 walk_expr(cx, sub_exp2, scope_stack, scope_map);\n             }\n \n-            ast::ExprIf(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            ast::ExprIf(@ref cond_exp, then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n@@ -2571,7 +2571,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::ExprWhile(@ref cond_exp, ref loop_body) => {\n+            ast::ExprWhile(@ref cond_exp, loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n@@ -2593,8 +2593,8 @@ fn populate_scope_map(cx: &mut CrateContext,\n                                             Found unexpanded macro.\");\n             }\n \n-            ast::ExprLoop(ref block, _) |\n-            ast::ExprBlock(ref block)   => {\n+            ast::ExprLoop(block, _) |\n+            ast::ExprBlock(block)   => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n@@ -2604,14 +2604,14 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 })\n             }\n \n-            ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, .. }, ref block) |\n-            ast::ExprProc(ast::fn_decl { inputs: ref inputs, .. }, ref block) => {\n+            ast::ExprFnBlock(decl, block) |\n+            ast::ExprProc(decl, block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::arg { pat: pattern, .. } in inputs.iter() {\n+                    for &ast::arg { pat: pattern, .. } in decl.inputs.iter() {\n                         walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n@@ -2674,7 +2674,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                             walk_expr(cx, guard_exp, scope_stack, scope_map)\n                         }\n \n-                        walk_block(cx, &arm_ref.body, scope_stack, scope_map);\n+                        walk_block(cx, arm_ref.body, scope_stack, scope_map);\n                     })\n                 }\n             }"}, {"sha": "09218b53424934f36e8131c6f4665b982bb8d84f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -637,10 +637,10 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n         ast::ExprRet(ex) => {\n             return controlflow::trans_ret(bcx, ex);\n         }\n-        ast::ExprWhile(cond, ref body) => {\n+        ast::ExprWhile(cond, body) => {\n             return controlflow::trans_while(bcx, cond, body);\n         }\n-        ast::ExprLoop(ref body, opt_label) => {\n+        ast::ExprLoop(body, opt_label) => {\n             // FIXME #6993: map can go away when ast.rs is changed\n             return controlflow::trans_loop(bcx, body, opt_label.map(|x| x.name));\n         }\n@@ -686,13 +686,13 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n         }\n-        ast::ExprIf(cond, ref thn, els) => {\n+        ast::ExprIf(cond, thn, els) => {\n             return controlflow::trans_if(bcx, cond, thn, els, dest);\n         }\n         ast::ExprMatch(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n-        ast::ExprBlock(ref blk) => {\n+        ast::ExprBlock(blk) => {\n             return base::with_scope(bcx,\n                                     blk.info(),\n                                     \"block-expr body\",\n@@ -719,8 +719,8 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        ast::ExprFnBlock(ref decl, ref body) |\n-        ast::ExprProc(ref decl, ref body) => {\n+        ast::ExprFnBlock(decl, body) |\n+        ast::ExprProc(decl, body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             debug!(\"translating block function {} with type {}\","}, {"sha": "a3f6b7db326aaab9e411621cdd499c33d7de65d7", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -151,8 +151,8 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n               };\n               trans_fn(ccx,\n                        path,\n-                       &mth.decl,\n-                       &mth.body,\n+                       mth.decl,\n+                       mth.body,\n                        llfn,\n                        self_kind,\n                        None,"}, {"sha": "dff9f55e04ccc440e797575f121996dbd1cd86c4", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -129,8 +129,8 @@ pub fn trans_method(ccx: @mut CrateContext,\n     // generate the actual code\n     trans_fn(ccx,\n              path,\n-             &method.decl,\n-             &method.body,\n+             method.decl,\n+             method.body,\n              llfn,\n              self_arg,\n              param_substs,"}, {"sha": "3350a52e2bc2d5be317f3aee38959fbad8f67f93", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -207,7 +207,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n \n     let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n-                node: ast::item_fn(ref decl, _, _, _, ref body),\n+                node: ast::item_fn(decl, _, _, _, body),\n                 ..\n             }, _) => {\n         let d = mk_lldecl();\n@@ -232,7 +232,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                                      ref_id);\n           d\n       }\n-      ast_map::node_variant(ref v, enum_item, _) => {\n+      ast_map::node_variant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n         let d = mk_lldecl();"}, {"sha": "a557332c8de60a765c48df6c927cc0cf4285d153", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -3868,7 +3868,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n                     ..\n                 }, _) => {\n             let mut last_discriminant: Option<Disr> = None;\n-            @enum_definition.variants.iter().map(|variant| {\n+            @enum_definition.variants.iter().map(|&variant| {\n \n                 let mut discriminant = match last_discriminant {\n                     Some(val) => val + 1,"}, {"sha": "26b9a1b25d58823b696f541c2a079fb4296bd4a1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -208,7 +208,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     let tps = path.segments\n                   .iter()\n                   .flat_map(|s| s.types.iter())\n-                  .map(|a_t| ast_ty_to_ty(this, rscope, a_t))\n+                  .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n                   .collect();\n \n     substs {\n@@ -413,15 +413,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(ref fields) => {\n-        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, t));\n+        let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n           if bf.decl.variadic && !bf.abis.is_c() {\n             tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n           }\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n-                                            bf.abis, &bf.decl))\n+                                            bf.abis, bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n         if f.sigil == ast::ManagedSigil {\n@@ -444,7 +444,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                       f.onceness,\n                                       bounds,\n                                       &f.region,\n-                                      &f.decl,\n+                                      f.decl,\n                                       None,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n@@ -583,7 +583,7 @@ pub fn ty_of_arg<AC:AstConv,\n     match a.ty.node {\n         ast::ty_infer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, &a.ty),\n+        _ => ast_ty_to_ty(this, rscope, a.ty),\n     }\n }\n \n@@ -643,7 +643,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n \n     let output_ty = match decl.output.node {\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, &decl.output)\n+        _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n \n     return (opt_transformed_self_ty,\n@@ -743,7 +743,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, &decl.output)\n+        _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "2e2d2232421930131ac696bd5992b2240f258f2a", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -72,7 +72,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n           },\n           None => ()\n         }\n-        check_block(fcx, &arm.body);\n+        check_block(fcx, arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n         saw_err = saw_err || ty::type_is_error(bty);\n         if guard_err {"}, {"sha": "5340ea2f802cc7821c4a3cd56589149a6bccc2f0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -317,7 +317,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n-                     body: &ast::Block,\n+                     body: ast::P<ast::Block>,\n                      id: ast::NodeId,\n                      self_info: Option<SelfInfo>,\n                      fty: ty::t,\n@@ -365,7 +365,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n     fn visit_local(&mut self, local:@ast::Local, _:()) {\n             let o_ty = match local.ty.node {\n               ast::ty_infer => None,\n-              _ => Some(self.fcx.to_ty(&local.ty))\n+              _ => Some(self.fcx.to_ty(local.ty))\n             };\n             self.assign(local.id, o_ty);\n             debug!(\"Local variable {} is assigned type {}\",\n@@ -392,7 +392,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n     }\n \n-    fn visit_block(&mut self, b:&ast::Block, _:()) {\n+    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n@@ -401,7 +401,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n         // Don't descend into fns and items\n     fn visit_fn(&mut self, _:&visit::fn_kind, _:&ast::fn_decl,\n-                _:&ast::Block, _:Span, _:ast::NodeId, _:()) { }\n+                _:ast::P<ast::Block>, _:Span, _:ast::NodeId, _:()) { }\n     fn visit_item(&mut self, _:@ast::item, _:()) { }\n \n }\n@@ -412,7 +412,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 id: ast::NodeId,\n-                body: &ast::Block,\n+                body: ast::P<ast::Block>,\n                 fn_kind: FnKind,\n                 inherited: @Inherited) -> @mut FnCtxt\n {\n@@ -498,7 +498,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     fn gather_locals(fcx: @mut FnCtxt,\n                      decl: &ast::fn_decl,\n-                     body: &ast::Block,\n+                     body: ast::P<ast::Block>,\n                      arg_tys: &[ty::t],\n                      opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n@@ -580,7 +580,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             enum_definition.variants,\n                             it.id);\n       }\n-      ast::item_fn(ref decl, _, _, _, ref body) => {\n+      ast::item_fn(decl, _, _, _, body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n         // FIXME(#5121) -- won't work for lifetimes that appear in type bounds\n@@ -713,8 +713,8 @@ fn check_method_body(ccx: @mut CrateCtxt,\n \n     check_bare_fn(\n         ccx,\n-        &method.decl,\n-        &method.body,\n+        method.decl,\n+        method.body,\n         method.id,\n         opt_self_info,\n         fty,\n@@ -1909,7 +1909,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          rcvr: @ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n-                         tps: &[ast::Ty],\n+                         tps: &[ast::P<ast::Ty>],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n \n@@ -1918,7 +1918,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n \n-        let tps = tps.map(|ast_ty| fcx.to_ty(ast_ty));\n+        let tps = tps.map(|&ast_ty| fcx.to_ty(ast_ty));\n         match method::lookup(fcx,\n                              expr,\n                              rcvr,\n@@ -2215,7 +2215,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                      expr: @ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n-                     body: &ast::Block,\n+                     body: ast::P<ast::Block>,\n                      fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n@@ -2309,7 +2309,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    expr: @ast::Expr,\n                    base: @ast::Expr,\n                    field: ast::Name,\n-                   tys: &[ast::Ty]) {\n+                   tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -2339,7 +2339,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps : ~[ty::t] = tys.iter().map(|ty| fcx.to_ty(ty)).collect();\n+        let tps : ~[ty::t] = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2872,11 +2872,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprIf(cond, ref then_blk, opt_else_expr) => {\n+      ast::ExprIf(cond, then_blk, opt_else_expr) => {\n         check_then_else(fcx, cond, then_blk, opt_else_expr,\n                         id, expr.span, expected);\n       }\n-      ast::ExprWhile(cond, ref body) => {\n+      ast::ExprWhile(cond, body) => {\n         check_expr_has_type(fcx, cond, ty::mk_bool());\n         check_block_no_value(fcx, body);\n         let cond_ty = fcx.expr_ty(cond);\n@@ -2893,7 +2893,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::ExprForLoop(..) =>\n           fail!(\"non-desugared expr_for_loop\"),\n-      ast::ExprLoop(ref body, _) => {\n+      ast::ExprLoop(body, _) => {\n         check_block_no_value(fcx, (body));\n         if !may_break(tcx, expr.id, body) {\n             fcx.write_bot(id);\n@@ -2905,7 +2905,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::ExprMatch(discrim, ref arms) => {\n         _match::check_match(fcx, expr, discrim, *arms);\n       }\n-      ast::ExprFnBlock(ref decl, ref body) => {\n+      ast::ExprFnBlock(decl, body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       Some(ast::BorrowedSigil),\n@@ -2914,7 +2914,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       Vanilla,\n                       expected);\n       }\n-      ast::ExprProc(ref decl, ref body) => {\n+      ast::ExprProc(decl, body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       Some(ast::OwnedSigil),\n@@ -2951,7 +2951,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         };\n         match b.node {\n-          ast::ExprFnBlock(ref decl, ref body) => {\n+          ast::ExprFnBlock(decl, body) => {\n             check_expr_fn(fcx, b, None,\n                           decl, body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n@@ -2961,7 +2961,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n-      ast::ExprBlock(ref b) => {\n+      ast::ExprBlock(b) => {\n         check_block_with_expected(fcx, b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n@@ -2996,7 +2996,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprCast(e, ref t) => {\n+      ast::ExprCast(e, t) => {\n         check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n@@ -3494,7 +3494,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n \n pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: Span,\n-                           vs: &[ast::variant],\n+                           vs: &[ast::P<ast::variant>],\n                            id: ast::NodeId) {\n \n     fn disr_in_range(ccx: @mut CrateCtxt,\n@@ -3525,7 +3525,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     }\n \n     fn do_check(ccx: @mut CrateCtxt,\n-                vs: &[ast::variant],\n+                vs: &[ast::P<ast::variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n                 -> ~[@ty::VariantInfo] {\n@@ -3535,7 +3535,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n         let mut disr_vals: ~[ty::Disr] = ~[];\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs.iter() {\n+        for &v in vs.iter() {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -3766,7 +3766,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         // at the appropriate position.\n         let mut result = ~[];\n         let mut pushed = false;\n-        for (i, ast_type) in pth.segments\n+        for (i, &ast_type) in pth.segments\n                                 .iter()\n                                 .flat_map(|segment| segment.types.iter())\n                                 .enumerate() {\n@@ -3871,7 +3871,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n+pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {"}, {"sha": "10120a69c31966d648bdea70a0817339f0e538d6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -152,7 +152,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::Block) {\n+pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::P<ast::Block>) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;\n@@ -182,14 +182,14 @@ impl Visitor<()> for Rcx {\n \n     fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(self, l); }\n \n-    fn visit_block(&mut self, b:&ast::Block, _:()) { visit_block(self, b); }\n+    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) { visit_block(self, b); }\n }\n \n fn visit_item(_rcx: &mut Rcx, _item: @ast::item) {\n     // Ignore items\n }\n \n-fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n+fn visit_block(rcx: &mut Rcx, b: ast::P<ast::Block>) {\n     rcx.fcx.tcx().region_maps.record_cleanup_scope(b.id);\n     visit::walk_block(rcx, b, ());\n }\n@@ -431,13 +431,13 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n             check_expr_fn_block(rcx, expr);\n         }\n \n-        ast::ExprLoop(ref body, _) => {\n+        ast::ExprLoop(body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             visit::walk_expr(rcx, expr, ());\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::ExprWhile(cond, ref body) => {\n+        ast::ExprWhile(cond, body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n             rcx.visit_expr(cond, ());\n "}, {"sha": "6e588faeaf76b3886f7d0349805c2ff393ee3861", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -788,7 +788,7 @@ impl visit::Visitor<()> for @mut FnCtxt {\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::Block) {\n+pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::P<ast::Block>) {\n     let mut fcx = fcx;\n     visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "93463f507c708a519f0e72cb890ea4eb4d55692e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -269,7 +269,7 @@ fn visit_expr(e: @ast::Expr, wbcx: &mut WbCtxt) {\n     visit::walk_expr(wbcx, e, ());\n }\n \n-fn visit_block(b: &ast::Block, wbcx: &mut WbCtxt) {\n+fn visit_block(b: ast::P<ast::Block>, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n@@ -322,7 +322,7 @@ impl Visitor<()> for WbCtxt {\n     fn visit_item(&mut self, i:@ast::item, _:()) { visit_item(i, self); }\n     fn visit_stmt(&mut self, s:@ast::Stmt, _:()) { visit_stmt(s, self); }\n     fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(ex, self); }\n-    fn visit_block(&mut self, b:&ast::Block, _:()) { visit_block(b, self); }\n+    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) { visit_block(b, self); }\n     fn visit_pat(&mut self, p:&ast::Pat, _:()) { visit_pat(p, self); }\n     fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(l, self); }\n }\n@@ -336,7 +336,7 @@ pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::Expr) -> bool {\n \n pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n-                               blk: &ast::Block,\n+                               blk: ast::P<ast::Block>,\n                                self_info: Option<SelfInfo>) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;"}, {"sha": "a0264848b47266aeac446f31aa8c9218e8cc164a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -190,7 +190,7 @@ impl visit::Visitor<()> for PrivilegedScopeVisitor {\n                         // Then visit the module items.\n                         visit::walk_mod(self, module_, ());\n                     }\n-                    item_impl(_, None, ref ast_ty, _) => {\n+                    item_impl(_, None, ast_ty, _) => {\n                         if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n                             // This is an error.\n                             let session = self.cc.crate_context.tcx.sess;"}, {"sha": "bb0e1d42ac638cda6184e2df45e07c9beabfa10b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -134,7 +134,7 @@ impl AstConv for CrateCtxt {\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n-                              variants: &[ast::variant],\n+                              variants: &[ast::P<ast::variant>],\n                               generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n@@ -146,7 +146,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         let result_ty = match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n+                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n                 ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n \n@@ -197,14 +197,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                         ty_method_of_trait_method(\n                             ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n-                            &m.generics, &m.purity, &m.decl)\n+                            &m.generics, &m.purity, m.decl)\n                     }\n \n                     &ast::provided(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n-                            &m.generics, &m.purity, &m.decl)\n+                            &m.generics, &m.purity, m.decl)\n                     }\n                 };\n \n@@ -414,7 +414,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n                      v: &ast::struct_field) {\n-    let tt = ccx.to_ty(&ExplicitRscope, &v.node.ty);\n+    let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -475,7 +475,7 @@ fn convert_methods(ccx: &CrateCtxt,\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(ccx, m.id, m.purity,\n                                   untransformed_rcvr_ty,\n-                                  m.explicit_self, &m.decl);\n+                                  m.explicit_self, m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -528,7 +528,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                  enum_definition.variants,\n                                  generics);\n       }\n-      ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n+      ast::item_impl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, generics, 0);\n         let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -755,13 +755,13 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n         _ => {}\n     }\n     match it.node {\n-        ast::item_static(ref t, _, _) => {\n+        ast::item_static(t, _, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, t);\n             let tpt = no_params(typ);\n             tcx.tcache.insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n+        ast::item_fn(decl, purity, abi, ref generics, _) => {\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n@@ -782,7 +782,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             ccx.tcx.tcache.insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_ty(ref t, ref generics) => {\n+        ast::item_ty(t, ref generics) => {\n             match tcx.tcache.find(&local_def(it.id)) {\n                 Some(&tpt) => return tpt,\n                 None => { }\n@@ -838,14 +838,14 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           abis: AbiSet) -> ty::ty_param_bounds_and_ty\n {\n     match it.node {\n-        ast::foreign_item_fn(ref fn_decl, ref generics) => {\n+        ast::foreign_item_fn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n                                   fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_static(ref t, _) => {\n+        ast::foreign_item_static(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -935,7 +935,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let ty_generics = ty_generics(ccx, ast_generics, 0);\n     let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n-    let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n+    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "84dff19e452ddbe09bfdaeb6c508e5c5e7f9394d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -449,7 +449,7 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n                 // here, mainly so as to mask the differences between\n                 // struct-like enums and so forth.\n-                for ast_variant in enum_definition.variants.iter() {\n+                for &ast_variant in enum_definition.variants.iter() {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n                                                           ast_variant,"}, {"sha": "643e0440860e09a358fc4cac22a08174956342ac", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -79,7 +79,7 @@ impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n+pub fn loop_query(b: ast::P<ast::Block>, p: |&ast::Expr_| -> bool) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -102,7 +102,7 @@ impl<'self> Visitor<()> for BlockQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: |@ast::Expr| -> bool) -> bool {\n+pub fn block_query(b: ast::P<ast::Block>, p: |@ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "93d1db447e77b8031a62bdf952133c65e0eb2396", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -115,7 +115,7 @@ pub struct Function {\n }\n \n pub struct Typedef {\n-    ty: ast::Ty,\n+    ty: ast::P<ast::Ty>,\n     gen: ast::Generics,\n     name: Ident,\n     id: ast::NodeId,\n@@ -125,7 +125,7 @@ pub struct Typedef {\n }\n \n pub struct Static {\n-    type_: ast::Ty,\n+    type_: ast::P<ast::Ty>,\n     mutability: ast::Mutability,\n     expr: @ast::Expr,\n     name: Ident,\n@@ -149,7 +149,7 @@ pub struct Trait {\n pub struct Impl {\n     generics: ast::Generics,\n     trait_: Option<ast::trait_ref>,\n-    for_: ast::Ty,\n+    for_: ast::P<ast::Ty>,\n     methods: ~[@ast::method],\n     attrs: ~[ast::Attribute],\n     where: Span,"}, {"sha": "1a4a9a0aee8c378ceafffacb4d7286157c410c9e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -121,11 +121,11 @@ impl RustdocVisitor {\n                 },\n                 ast::item_enum(ref ed, ref gen) => om.enums.push(visit_enum_def(item, ed, gen)),\n                 ast::item_struct(sd, ref gen) => om.structs.push(visit_struct_def(item, sd, gen)),\n-                ast::item_fn(ref fd, ref pur, ref abi, ref gen, _) =>\n+                ast::item_fn(fd, ref pur, ref abi, ref gen, _) =>\n                     om.fns.push(visit_fn(item, fd, pur, abi, gen)),\n-                ast::item_ty(ref ty, ref gen) => {\n+                ast::item_ty(ty, ref gen) => {\n                     let t = Typedef {\n-                        ty: ty.clone(),\n+                        ty: ty,\n                         gen: gen.clone(),\n                         name: item.ident,\n                         id: item.id,\n@@ -135,9 +135,9 @@ impl RustdocVisitor {\n                     };\n                     om.typedefs.push(t);\n                 },\n-                ast::item_static(ref ty, ref mut_, ref exp) => {\n+                ast::item_static(ty, ref mut_, ref exp) => {\n                     let s = Static {\n-                        type_: ty.clone(),\n+                        type_: ty,\n                         mutability: mut_.clone(),\n                         expr: exp.clone(),\n                         id: item.id,\n@@ -161,11 +161,11 @@ impl RustdocVisitor {\n                     };\n                     om.traits.push(t);\n                 },\n-                ast::item_impl(ref gen, ref tr, ref ty, ref meths) => {\n+                ast::item_impl(ref gen, ref tr, ty, ref meths) => {\n                     let i = Impl {\n                         generics: gen.clone(),\n                         trait_: tr.clone(),\n-                        for_: ty.clone(),\n+                        for_: ty,\n                         methods: meths.clone(),\n                         attrs: item.attrs.clone(),\n                         id: item.id,"}, {"sha": "aebb5303cd437ede2a081c906812a91dd74f99ab", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -20,6 +20,13 @@ use std::option::Option;\n use std::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+/// A pointer abstraction. FIXME(eddyb) #10676 use Rc<T> in the future.\n+pub type P<T> = @T;\n+\n+/// Construct a P<T> from a T value.\n+pub fn P<T: 'static>(value: T) -> P<T> {\n+    @value\n+}\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n // by just \"Name\".\n@@ -160,7 +167,7 @@ pub struct PathSegment {\n     /// The lifetime parameters for this path segment.\n     lifetimes: OptVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    types: OptVec<Ty>,\n+    types: OptVec<P<Ty>>,\n }\n \n pub type CrateNum = u32;\n@@ -460,7 +467,7 @@ pub enum Stmt_ {\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Local {\n-    ty: Ty,\n+    ty: P<Ty>,\n     pat: @Pat,\n     init: Option<@Expr>,\n     id: NodeId,\n@@ -481,7 +488,7 @@ pub enum Decl_ {\n pub struct Arm {\n     pats: ~[@Pat],\n     guard: Option<@Expr>,\n-    body: Block,\n+    body: P<Block>,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -537,28 +544,28 @@ pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     ExprVec(~[@Expr], Mutability),\n     ExprCall(@Expr, ~[@Expr], CallSugar),\n-    ExprMethodCall(NodeId, @Expr, Ident, ~[Ty], ~[@Expr], CallSugar),\n+    ExprMethodCall(NodeId, @Expr, Ident, ~[P<Ty>], ~[@Expr], CallSugar),\n     ExprTup(~[@Expr]),\n     ExprBinary(NodeId, BinOp, @Expr, @Expr),\n     ExprUnary(NodeId, UnOp, @Expr),\n     ExprLit(@lit),\n-    ExprCast(@Expr, Ty),\n-    ExprIf(@Expr, Block, Option<@Expr>),\n-    ExprWhile(@Expr, Block),\n+    ExprCast(@Expr, P<Ty>),\n+    ExprIf(@Expr, P<Block>, Option<@Expr>),\n+    ExprWhile(@Expr, P<Block>),\n     // FIXME #6993: change to Option<Name>\n-    ExprForLoop(@Pat, @Expr, Block, Option<Ident>),\n+    ExprForLoop(@Pat, @Expr, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n-    ExprLoop(Block, Option<Ident>),\n+    ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(@Expr, ~[Arm]),\n-    ExprFnBlock(fn_decl, Block),\n-    ExprProc(fn_decl, Block),\n+    ExprFnBlock(P<fn_decl>, P<Block>),\n+    ExprProc(P<fn_decl>, P<Block>),\n     ExprDoBody(@Expr),\n-    ExprBlock(Block),\n+    ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n     ExprAssignOp(NodeId, BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, ~[Ty]),\n+    ExprField(@Expr, Ident, ~[P<Ty>]),\n     ExprIndex(NodeId, @Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,\n@@ -727,7 +734,7 @@ pub enum lit_ {\n // type structure in middle/ty.rs as well.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct mt {\n-    ty: ~Ty,\n+    ty: P<Ty>,\n     mutbl: Mutability,\n }\n \n@@ -743,7 +750,7 @@ pub struct TypeMethod {\n     ident: Ident,\n     attrs: ~[Attribute],\n     purity: purity,\n-    decl: fn_decl,\n+    decl: P<fn_decl>,\n     generics: Generics,\n     explicit_self: explicit_self,\n     id: NodeId,\n@@ -842,7 +849,7 @@ pub struct TyClosure {\n     lifetimes: OptVec<Lifetime>,\n     purity: purity,\n     onceness: Onceness,\n-    decl: fn_decl,\n+    decl: P<fn_decl>,\n     // Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\n     // implement issue #7264. None means \"fn()\", which means infer a default\n     // bound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\n@@ -855,7 +862,7 @@ pub struct TyBareFn {\n     purity: purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n-    decl: fn_decl\n+    decl: P<fn_decl>\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -870,7 +877,7 @@ pub enum ty_ {\n     ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n-    ty_tup(~[Ty]),\n+    ty_tup(~[P<Ty>]),\n     ty_path(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     ty_typeof(@Expr),\n     // ty_infer means the type should be inferred instead of it having been\n@@ -899,15 +906,15 @@ pub struct inline_asm {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct arg {\n-    ty: Ty,\n+    ty: P<Ty>,\n     pat: @Pat,\n     id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n-    output: Ty,\n+    output: P<Ty>,\n     cf: ret_style,\n     variadic: bool\n }\n@@ -954,8 +961,8 @@ pub struct method {\n     generics: Generics,\n     explicit_self: explicit_self,\n     purity: purity,\n-    decl: fn_decl,\n-    body: Block,\n+    decl: P<fn_decl>,\n+    body: P<Block>,\n     id: NodeId,\n     span: Span,\n     self_id: NodeId,\n@@ -977,7 +984,7 @@ pub struct foreign_mod {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_arg {\n-    ty: Ty,\n+    ty: P<Ty>,\n     id: NodeId,\n }\n \n@@ -989,7 +996,7 @@ pub enum variant_kind {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct enum_def {\n-    variants: ~[variant],\n+    variants: ~[P<variant>],\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -1102,7 +1109,7 @@ impl visibility {\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: NodeId,\n-    ty: Ty,\n+    ty: P<Ty>,\n     attrs: ~[Attribute],\n }\n \n@@ -1138,17 +1145,17 @@ pub struct item {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum item_ {\n-    item_static(Ty, Mutability, @Expr),\n-    item_fn(fn_decl, purity, AbiSet, Generics, Block),\n+    item_static(P<Ty>, Mutability, @Expr),\n+    item_fn(P<fn_decl>, purity, AbiSet, Generics, P<Block>),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(Ty, Generics),\n+    item_ty(P<Ty>, Generics),\n     item_enum(enum_def, Generics),\n     item_struct(@struct_def, Generics),\n     item_trait(Generics, ~[trait_ref], ~[trait_method]),\n     item_impl(Generics,\n               Option<trait_ref>, // (optional) trait this impl implements\n-              Ty, // self\n+              P<Ty>, // self\n               ~[@method]),\n     // a macro invocation (which includes macro definition)\n     item_mac(mac),\n@@ -1166,8 +1173,8 @@ pub struct foreign_item {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n-    foreign_item_fn(fn_decl, Generics),\n-    foreign_item_static(Ty, /* is_mutbl */ bool),\n+    foreign_item_fn(P<fn_decl>, Generics),\n+    foreign_item_static(P<Ty>, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "961d8170fd35d6b7683e6c7585ec7acf913df97b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -115,12 +115,12 @@ pub enum ast_node {\n     /// node_variant represents a variant of an enum, e.g., for\n     /// `enum A { B, C, D }`, there would be a node_item for `A`, and a\n     /// node_variant item for each of `B`, `C`, and `D`.\n-    node_variant(variant, @item, @path),\n+    node_variant(P<variant>, @item, @path),\n     node_expr(@Expr),\n     node_stmt(@Stmt),\n     node_arg(@Pat),\n     node_local(Ident),\n-    node_block(Block),\n+    node_block(P<Block>),\n \n     /// node_struct_ctor represents a tuple struct.\n     node_struct_ctor(@struct_def, @item, @path),\n@@ -214,7 +214,7 @@ impl Ctx {\n     fn map_fn(&mut self,\n               fk: &visit::fn_kind,\n               decl: &fn_decl,\n-              body: &Block,\n+              body: P<Block>,\n               sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n@@ -236,9 +236,8 @@ impl Ctx {\n         visit::walk_stmt(self, stmt, ());\n     }\n \n-    fn map_block(&mut self, b: &Block) {\n-        // clone is FIXME #2543\n-        self.map.insert(b.id, node_block((*b).clone()));\n+    fn map_block(&mut self, b: P<Block>) {\n+        self.map.insert(b.id, node_block(b));\n         visit::walk_block(self, b, ());\n     }\n \n@@ -262,7 +261,7 @@ impl Visitor<()> for Ctx {\n         let item_path = @self.path.clone();\n         self.map.insert(i.id, node_item(i, item_path));\n         match i.node {\n-            item_impl(_, ref maybe_trait, ref ty, ref ms) => {\n+            item_impl(_, ref maybe_trait, ty, ref ms) => {\n                 // Right now the ident on impls is __extensions__ which isn't\n                 // very pretty when debugging, so attempt to select a better\n                 // name to use.\n@@ -277,13 +276,10 @@ impl Visitor<()> for Ctx {\n                 self.path.push(elt);\n             }\n             item_enum(ref enum_definition, _) => {\n-                for v in (*enum_definition).variants.iter() {\n+                for &v in enum_definition.variants.iter() {\n                     let elt = path_name(i.ident);\n-                    // FIXME #2543: bad clone\n                     self.map.insert(v.node.id,\n-                                    node_variant((*v).clone(),\n-                                                 i,\n-                                                 self.extend(elt)));\n+                                    node_variant(v, i, self.extend(elt)));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -361,14 +357,14 @@ impl Visitor<()> for Ctx {\n     fn visit_fn(&mut self,\n                 function_kind: &fn_kind,\n                 function_declaration: &fn_decl,\n-                block: &Block,\n+                block: P<Block>,\n                 span: Span,\n                 node_id: NodeId,\n                 _: ()) {\n         self.map_fn(function_kind, function_declaration, block, span, node_id)\n     }\n \n-    fn visit_block(&mut self, block: &Block, _: ()) {\n+    fn visit_block(&mut self, block: P<Block>, _: ()) {\n         self.map_block(block)\n     }\n \n@@ -477,7 +473,7 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n       Some(&node_local(ident)) => {\n         format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n       }\n-      Some(&node_block(ref block)) => {\n+      Some(&node_block(block)) => {\n         format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n       }\n       Some(&node_struct_ctor(_, _, path)) => {"}, {"sha": "094ad7afea66e9d617673309445e95bccbdf39b2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -11,7 +11,7 @@\n use ast::*;\n use ast;\n use ast_util;\n-use codemap::{Span, dummy_sp};\n+use codemap::Span;\n use opt_vec;\n use parse::token;\n use visit::Visitor;\n@@ -21,7 +21,6 @@ use std::hashmap::HashMap;\n use std::u32;\n use std::local_data;\n use std::num;\n-use std::option;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n@@ -197,25 +196,15 @@ pub fn is_call_expr(e: @Expr) -> bool {\n     match e.node { ExprCall(..) => true, _ => false }\n }\n \n-pub fn block_from_expr(e: @Expr) -> Block {\n-    let mut blk = default_block(~[], option::Some::<@Expr>(e), e.id);\n-    blk.span = e.span;\n-    return blk;\n-}\n-\n-pub fn default_block(\n-    stmts1: ~[@Stmt],\n-    expr1: Option<@Expr>,\n-    id1: NodeId\n-) -> Block {\n-    ast::Block {\n+pub fn block_from_expr(e: @Expr) -> P<Block> {\n+    P(Block {\n         view_items: ~[],\n-        stmts: stmts1,\n-        expr: expr1,\n-        id: id1,\n+        stmts: ~[],\n+        expr: Some(e),\n+        id: e.id,\n         rules: DefaultBlock,\n-        span: dummy_sp(),\n-    }\n+        span: e.span\n+    })\n }\n \n pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n@@ -272,7 +261,7 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> TypeMethod {\n                 ident: m.ident,\n                 attrs: m.attrs.clone(),\n                 purity: m.purity,\n-                decl: m.decl.clone(),\n+                decl: m.decl,\n                 generics: m.generics.clone(),\n                 explicit_self: m.explicit_self,\n                 id: m.id,\n@@ -487,7 +476,7 @@ impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n         visit::walk_local(self, local, env)\n     }\n \n-    fn visit_block(&mut self, block: &Block, env: ()) {\n+    fn visit_block(&mut self, block: P<Block>, env: ()) {\n         self.operation.visit_id(block.id);\n         visit::walk_block(self, block, env)\n     }\n@@ -531,7 +520,7 @@ impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n     fn visit_fn(&mut self,\n                 function_kind: &visit::fn_kind,\n                 function_declaration: &fn_decl,\n-                block: &Block,\n+                block: P<Block>,\n                 span: Span,\n                 node_id: NodeId,\n                 env: ()) {"}, {"sha": "8a8de3906c4c28ae2ad6a6c6398c8fe8708ba88b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 83, "deletions": 81, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::AbiSet;\n-use ast::Ident;\n+use ast::{P, Ident};\n use ast;\n use ast_util;\n use codemap::{Span, respan, dummy_sp};\n@@ -39,30 +39,30 @@ pub trait AstBuilder {\n                 global: bool,\n                 idents: ~[ast::Ident],\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[ast::Ty])\n+                types: ~[P<ast::Ty>])\n         -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::Mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::mt;\n \n-    fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty;\n-    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n-    fn ty_ident(&self, span: Span, idents: ast::Ident) -> ast::Ty;\n+    fn ty(&self, span: Span, ty: ast::ty_) -> P<ast::Ty>;\n+    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> P<ast::Ty>;\n+    fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n-               ty: ast::Ty,\n+               ty: P<ast::Ty>,\n                lifetime: Option<ast::Lifetime>,\n-               mutbl: ast::Mutability) -> ast::Ty;\n-    fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty;\n-    fn ty_box(&self, span: Span, ty: ast::Ty, mutbl: ast::Mutability) -> ast::Ty;\n+               mutbl: ast::Mutability) -> P<ast::Ty>;\n+    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n+    fn ty_box(&self, span: Span, ty: P<ast::Ty>, mutbl: ast::Mutability) -> P<ast::Ty>;\n \n-    fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n-    fn ty_infer(&self, sp: Span) -> ast::Ty;\n-    fn ty_nil(&self) -> ast::Ty;\n+    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n+    fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n+    fn ty_nil(&self) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::TypeField;\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n+    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n@@ -78,17 +78,17 @@ pub trait AstBuilder {\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n-                      typ: ast::Ty,\n+                      typ: P<ast::Ty>,\n                       ex: @ast::Expr)\n                       -> @ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> ast::Block;\n-    fn block_expr(&self, expr: @ast::Expr) -> ast::Block;\n+    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> P<ast::Block>;\n+    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n                  view_items: ~[ast::view_item],\n                  stmts: ~[@ast::Stmt],\n-                 expr: Option<@ast::Expr>) -> ast::Block;\n+                 expr: Option<@ast::Expr>) -> P<ast::Block>;\n \n     // expressions\n     fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr;\n@@ -112,8 +112,8 @@ pub trait AstBuilder {\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr, ident: ast::Ident,\n                         args: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_block(&self, b: ast::Block) -> @ast::Expr;\n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr;\n+    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr;\n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr;\n \n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n@@ -159,11 +159,12 @@ pub trait AstBuilder {\n     fn expr_if(&self, span: Span,\n                cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n \n-    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::Expr;\n+    fn lambda_fn_decl(&self, span: Span,\n+                      fn_decl: P<ast::fn_decl>, blk: P<ast::Block>) -> @ast::Expr;\n \n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::Expr;\n-    fn lambda0(&self, span: Span, blk: ast::Block) -> @ast::Expr;\n-    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr;\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr;\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr;\n \n     fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::Expr) -> @ast::Expr;\n     fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n@@ -177,25 +178,25 @@ pub trait AstBuilder {\n     fn item(&self, span: Span,\n             name: Ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::arg;\n+    fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::arg;\n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: P<ast::Ty>) -> P<ast::fn_decl>;\n \n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     inputs: ~[ast::arg],\n-                    output: ast::Ty,\n+                    output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: ast::Block) -> @ast::item;\n+                    body: P<ast::Block>) -> @ast::item;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: ~[ast::arg],\n-               output: ast::Ty,\n-               body: ast::Block) -> @ast::item;\n+               output: P<ast::Ty>,\n+               body: P<ast::Block>) -> @ast::item;\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n@@ -217,9 +218,9 @@ pub trait AstBuilder {\n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    ty: ast::Ty,\n+                    ty: P<ast::Ty>,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: Span, name: Ident, ty: ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::item;\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n@@ -250,7 +251,7 @@ impl AstBuilder for @ExtCtxt {\n                 global: bool,\n                 mut idents: ~[ast::Ident],\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[ast::Ty])\n+                types: ~[P<ast::Ty>])\n                 -> ast::Path {\n         let last_identifier = idents.pop();\n         let mut segments: ~[ast::PathSegment] = idents.move_iter()\n@@ -273,52 +274,52 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::Mutability) -> ast::mt {\n+    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::mt {\n         ast::mt {\n-            ty: ~ty,\n+            ty: ty,\n             mutbl: mutbl\n         }\n     }\n \n-    fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty {\n-        ast::Ty {\n+    fn ty(&self, span: Span, ty: ast::ty_) -> P<ast::Ty> {\n+        P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span: span,\n             node: ty\n-        }\n+        })\n     }\n \n     fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n-              -> ast::Ty {\n+              -> P<ast::Ty> {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, ast::DUMMY_NODE_ID))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: Span, ident: ast::Ident)\n-        -> ast::Ty {\n+        -> P<ast::Ty> {\n         self.ty_path(self.path_ident(span, ident), None)\n     }\n \n     fn ty_rptr(&self,\n                span: Span,\n-               ty: ast::Ty,\n+               ty: P<ast::Ty>,\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::Mutability)\n-        -> ast::Ty {\n+        -> P<ast::Ty> {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty {\n+    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::MutImmutable)))\n     }\n     fn ty_box(&self, span: Span,\n-                 ty: ast::Ty, mutbl: ast::Mutability) -> ast::Ty {\n+                 ty: P<ast::Ty>, mutbl: ast::Mutability) -> P<ast::Ty> {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_option(&self, ty: ast::Ty) -> ast::Ty {\n+    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty_path(\n             self.path_all(dummy_sp(),\n                           true,\n@@ -331,24 +332,24 @@ impl AstBuilder for @ExtCtxt {\n                           ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::TypeField {\n+    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n         ast::TypeField {\n             ident: name,\n-            mt: ast::mt { ty: ~ty, mutbl: ast::MutImmutable },\n+            mt: ast::mt { ty: ty, mutbl: ast::MutImmutable },\n             span: span,\n         }\n     }\n \n-    fn ty_infer(&self, span: Span) -> ast::Ty {\n+    fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n         self.ty(span, ast::ty_infer)\n     }\n \n-    fn ty_nil(&self) -> ast::Ty {\n-        ast::Ty {\n+    fn ty_nil(&self) -> P<ast::Ty> {\n+        P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ty_nil,\n             span: dummy_sp(),\n-        }\n+        })\n     }\n \n     fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n@@ -358,12 +359,12 @@ impl AstBuilder for @ExtCtxt {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n                 self.path_global(dummy_sp(), ~[p.ident]), None)))\n@@ -419,7 +420,7 @@ impl AstBuilder for @ExtCtxt {\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n-                      typ: ast::Ty,\n+                      typ: P<ast::Ty>,\n                       ex: @ast::Expr)\n                       -> @ast::Stmt {\n         let pat = if mutbl {\n@@ -438,26 +439,26 @@ impl AstBuilder for @ExtCtxt {\n         @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> ast::Block {\n+    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> P<ast::Block> {\n         self.block_all(span, ~[], stmts, expr)\n     }\n \n-    fn block_expr(&self, expr: @ast::Expr) -> ast::Block {\n+    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block> {\n         self.block_all(expr.span, ~[], ~[], Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n                  view_items: ~[ast::view_item],\n                  stmts: ~[@ast::Stmt],\n-                 expr: Option<@ast::Expr>) -> ast::Block {\n-           ast::Block {\n+                 expr: Option<@ast::Expr>) -> P<ast::Block> {\n+            P(ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n                expr: expr,\n                id: ast::DUMMY_NODE_ID,\n                rules: ast::DefaultBlock,\n                span: span,\n-           }\n+            })\n     }\n \n     fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr {\n@@ -525,7 +526,7 @@ impl AstBuilder for @ExtCtxt {\n         self.expr(span,\n                   ast::ExprMethodCall(ast::DUMMY_NODE_ID, expr, ident, ~[], args, ast::NoSugar))\n     }\n-    fn expr_block(&self, b: ast::Block) -> @ast::Expr {\n+    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n@@ -575,7 +576,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr {\n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr {\n         self.expr(sp, ast::ExprCast(expr, ty))\n     }\n \n@@ -673,23 +674,24 @@ impl AstBuilder for @ExtCtxt {\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n-    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::Expr {\n+    fn lambda_fn_decl(&self, span: Span,\n+                      fn_decl: P<ast::fn_decl>, blk: P<ast::Block>) -> @ast::Expr {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::Expr {\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::Expr {\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n+    fn lambda0(&self, _span: Span, blk: P<ast::Block>) -> @ast::Expr {\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n         quote_expr!(*self, || $blk_e )\n     }\n \n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr {\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n+    fn lambda1(&self, _span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n         quote_expr!(*self, |$ident| $blk_e )\n     }\n \n@@ -713,7 +715,7 @@ impl AstBuilder for @ExtCtxt {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: Span, ident: ast::Ident, ty: ast::Ty) -> ast::arg {\n+    fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             ty: ty,\n@@ -723,13 +725,13 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl {\n-        ast::fn_decl {\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: P<ast::Ty>) -> P<ast::fn_decl> {\n+        P(ast::fn_decl {\n             inputs: inputs,\n             output: output,\n             cf: ast::return_val,\n             variadic: false\n-        }\n+        })\n     }\n \n     fn item(&self, span: Span,\n@@ -748,9 +750,9 @@ impl AstBuilder for @ExtCtxt {\n                     span: Span,\n                     name: Ident,\n                     inputs: ~[ast::arg],\n-                    output: ast::Ty,\n+                    output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: ast::Block) -> @ast::item {\n+                    body: P<ast::Block>) -> @ast::item {\n         self.item(span,\n                   name,\n                   ~[],\n@@ -765,8 +767,8 @@ impl AstBuilder for @ExtCtxt {\n                span: Span,\n                name: Ident,\n                inputs: ~[ast::arg],\n-               output: ast::Ty,\n-               body: ast::Block\n+               output: P<ast::Ty>,\n+               body: P<ast::Block>\n               ) -> @ast::item {\n         self.item_fn_poly(\n             span,\n@@ -777,7 +779,7 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[ast::Ty]) -> ast::variant {\n+    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::variant {\n         let args = tys.move_iter().map(|ty| {\n             ast::variant_arg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n@@ -844,12 +846,12 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: Span, name: Ident, ty: ast::Ty,\n+    fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n "}, {"sha": "627e799f2d36e80b12d4336f094fa8475d7884ec", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -175,7 +175,7 @@ StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n */\n \n use ast;\n-use ast::{enum_def, Expr, Ident, Generics, struct_def};\n+use ast::{P, enum_def, Expr, Ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -279,7 +279,7 @@ pub enum SubstructureFields<'self> {\n     [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'self [(uint, ast::variant, ~[(Span, Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'self [(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'self ast::struct_def, StaticFields),\n@@ -304,7 +304,7 @@ representing each variant: (variant index, ast::variant instance,\n pub type EnumNonMatchFunc<'self> =\n     'self |@ExtCtxt,\n            Span,\n-           &[(uint, ast::variant, ~[(Span, Option<Ident>, @Expr)])],\n+           &[(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])],\n            &[@Expr]|\n            -> @Expr;\n \n@@ -484,7 +484,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn get_ret_ty(&self, cx: @ExtCtxt, trait_span: Span,\n-                  generics: &Generics, type_ident: Ident) -> ast::Ty {\n+                  generics: &Generics, type_ident: Ident) -> P<ast::Ty> {\n         self.ret_ty.to_ty(cx, trait_span, type_ident, generics)\n     }\n \n@@ -494,7 +494,7 @@ impl<'self> MethodDef<'self> {\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, trait_span: Span,\n                                type_ident: Ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -542,7 +542,7 @@ impl<'self> MethodDef<'self> {\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n-                     arg_types: ~[(Ident, ast::Ty)],\n+                     arg_types: ~[(Ident, P<ast::Ty>)],\n                      body: @Expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n@@ -745,7 +745,7 @@ impl<'self> MethodDef<'self> {\n                         self_args: &[@Expr],\n                         nonself_args: &[@Expr],\n                         matching: Option<uint>,\n-                        matches_so_far: &mut ~[(uint, ast::variant,\n+                        matches_so_far: &mut ~[(uint, P<ast::variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n         if match_count == self_args.len() {\n@@ -772,7 +772,7 @@ impl<'self> MethodDef<'self> {\n                     // `ref` inside let matches is buggy. Causes havoc wih rusc.\n                     // let (variant_index, ref self_vec) = matches_so_far[0];\n                     let (variant, self_vec) = match matches_so_far[0] {\n-                        (_, ref v, ref s) => (v, s)\n+                        (_, v, ref s) => (v, s)\n                     };\n \n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n@@ -828,15 +828,13 @@ impl<'self> MethodDef<'self> {\n                 };\n \n                 // matching-variant match\n-                let variant = &enum_def.variants[index];\n+                let variant = enum_def.variants[index];\n                 let (pattern, idents) = create_enum_variant_pattern(cx,\n                                                                     variant,\n                                                                     current_match_str,\n                                                                     ast::MutImmutable);\n \n-                matches_so_far.push((index,\n-                                     /*bad*/ (*variant).clone(),\n-                                     idents));\n+                matches_so_far.push((index, variant, idents));\n                 let arm_expr = self.build_enum_match(cx, trait_span,\n                                                      enum_def,\n                                                      type_ident,\n@@ -859,15 +857,13 @@ impl<'self> MethodDef<'self> {\n                 }\n             } else {\n                 // create an arm matching on each variant\n-                for (index, variant) in enum_def.variants.iter().enumerate() {\n+                for (index, &variant) in enum_def.variants.iter().enumerate() {\n                     let (pattern, idents) = create_enum_variant_pattern(cx,\n                                                                         variant,\n                                                                         current_match_str,\n                                                                         ast::MutImmutable);\n \n-                    matches_so_far.push((index,\n-                                         /*bad*/ (*variant).clone(),\n-                                         idents));\n+                    matches_so_far.push((index, variant, idents));\n                     let new_matching =\n                         match matching {\n                             _ if match_count == 0 => Some(index),"}, {"sha": "87381d25dc7003b89dfcaf0801f7f13746907833", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -14,7 +14,7 @@ explicit `Self` type to use when specifying impls to be derived.\n */\n \n use ast;\n-use ast::{Expr,Generics,Ident};\n+use ast::{P,Expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n@@ -62,7 +62,7 @@ impl<'self> Path<'self> {\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n-                 -> ast::Ty {\n+                 -> P<ast::Ty> {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n@@ -130,7 +130,7 @@ impl<'self> Ty<'self> {\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n-                 -> ast::Ty {\n+                 -> P<ast::Ty> {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);"}, {"sha": "acf0326aefd100202e910d84a3a4142076abf443", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclLocal, Expr_, ExprMac, SyntaxContext};\n+use ast::{P, Block, Crate, DeclLocal, Expr_, ExprMac, SyntaxContext};\n use ast::{Local, Ident, mac_invoc_tt};\n use ast::{item_mac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n@@ -131,11 +131,11 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         // Desugar expr_for_loop\n         // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n         // FIXME #6993 : change type of opt_ident to Option<Name>\n-        ast::ExprForLoop(src_pat, src_expr, ref src_loop_block, opt_ident) => {\n+        ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n             let src_expr = fld.fold_expr(src_expr).clone();\n-            let src_loop_block = fld.fold_block(src_loop_block).clone();\n+            let src_loop_block = fld.fold_block(src_loop_block);\n \n             let span = e.span;\n \n@@ -148,21 +148,6 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 }\n             }\n \n-            fn mk_block(_: @ExtCtxt,\n-                        stmts: &[@ast::Stmt],\n-                        expr: Option<@ast::Expr>,\n-                        span: Span)\n-                        -> ast::Block {\n-                ast::Block {\n-                    view_items: ~[],\n-                    stmts: stmts.to_owned(),\n-                    expr: expr,\n-                    id: ast::DUMMY_NODE_ID,\n-                    rules: ast::DefaultBlock,\n-                    span: span,\n-                }\n-            }\n-\n             fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n                 ast::Path {\n                     span: span,\n@@ -556,8 +541,6 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n                 id: id,\n                 span: span\n             } = *local;\n-            // types can't be copied automatically because of the owned ptr in ty_tup...\n-            let ty = local.ty.clone();\n             // expand the pat (it might contain exprs... #:(o)>\n             let expanded_pat = fld.fold_pat(pat);\n             // find the pat_idents in the pattern:\n@@ -582,7 +565,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             let new_init_opt = init.map(|e| fld.fold_expr(e));\n             let rewritten_local =\n                 @Local {\n-                    ty: ty,\n+                    ty: local.ty,\n                     pat: rewritten_pat,\n                     init: new_init_opt,\n                     id: id,\n@@ -664,15 +647,15 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     _: @ExtCtxt,\n                     blk: &Block,\n                     fld: &MacroExpander)\n-                    -> Block {\n+                    -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(extsbox,false,\n                      expand_block_elts(*extsbox, blk, fld))\n }\n \n // expand the elements of a block.\n pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n-                         -> Block {\n+                         -> P<Block> {\n     let block_info = get_block_info(exts);\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n@@ -683,14 +666,14 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n             .flat_map(|x| fld.fold_stmt(x).move_iter())\n             .collect();\n     let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n-    Block{\n+    P(Block {\n         view_items: new_view_items,\n         stmts: new_stmts,\n         expr: new_expr,\n         id: fld.new_id(b.id),\n         rules: b.rules,\n         span: b.span,\n-    }\n+    })\n }\n \n // get the (innermost) BlockInfo from an exts stack\n@@ -1024,7 +1007,7 @@ impl ast_fold for MacroExpander {\n                     self)\n     }\n \n-    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+    fn fold_block(&self, block: P<Block>) -> P<Block> {\n         expand_block(self.extsbox,\n                      self.cx,\n                      block,"}, {"sha": "f6fb521ff7cd8ee285e00e611ae92504d158c15c", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast;\n+use ast::P;\n use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n@@ -587,7 +588,7 @@ impl Context {\n                 ~[]\n             ), None);\n         let ty = ast::ty_fixed_length_vec(\n-            self.ecx.ty_mt(piece_ty.clone(), ast::MutImmutable),\n+            self.ecx.ty_mt(piece_ty, ast::MutImmutable),\n             self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n         );\n         let ty = self.ecx.ty(self.fmtsp, ty);\n@@ -639,14 +640,14 @@ impl Context {\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n-        let result = self.ecx.expr_block(ast::Block {\n+        let result = self.ecx.expr_block(P(ast::Block {\n            view_items: ~[],\n            stmts: ~[],\n            expr: Some(result),\n            id: ast::DUMMY_NODE_ID,\n            rules: ast::UnsafeBlock(ast::CompilerGenerated),\n            span: self.fmtsp,\n-        });\n+        }));\n         let resname = self.ecx.ident_of(\"__args\");\n         lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n         let res = self.ecx.expr_ident(self.fmtsp, resname);"}, {"sha": "a450bfeccfe4c25b942088a2e92079689d7c54f9", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -432,11 +432,11 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n         Some(i) => token::nt_item(i),\n         None => p.fatal(\"expected an item keyword\")\n       },\n-      \"block\" => token::nt_block(~p.parse_block()),\n+      \"block\" => token::nt_block(p.parse_block()),\n       \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n       \"pat\" => token::nt_pat(p.parse_pat()),\n       \"expr\" => token::nt_expr(p.parse_expr()),\n-      \"ty\" => token::nt_ty(~p.parse_ty(false /* no need to disambiguate*/)),\n+      \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n       \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(~sn,b) }"}, {"sha": "945d22a0f5ade985ee7359ae28ef90f546c0f2bf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -95,16 +95,16 @@ pub trait ast_fold {\n                 match ni.node {\n                     foreign_item_fn(ref fdec, ref generics) => {\n                         foreign_item_fn(\n-                            ast::fn_decl {\n+                            P(fn_decl {\n                                 inputs: fdec.inputs.map(|a| fold_arg_(a,\n                                                                       self)),\n-                                output: self.fold_ty(&fdec.output),\n+                                output: self.fold_ty(fdec.output),\n                                 cf: fdec.cf,\n                                 variadic: fdec.variadic\n-                            },\n+                            }),\n                             fold_generics(generics, self))\n                     }\n-                    foreign_item_static(ref t, m) => {\n+                    foreign_item_static(t, m) => {\n                         foreign_item_static(self.fold_ty(t), m)\n                     }\n                 },\n@@ -125,7 +125,7 @@ pub trait ast_fold {\n             node: ast::struct_field_ {\n                 kind: sf.node.kind,\n                 id: self.new_id(sf.node.id),\n-                ty: self.fold_ty(&sf.node.ty),\n+                ty: self.fold_ty(sf.node.ty),\n                 attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n             },\n             span: self.new_span(sf.span)\n@@ -147,16 +147,16 @@ pub trait ast_fold {\n             generics: fold_generics(&m.generics, self),\n             explicit_self: self.fold_explicit_self(&m.explicit_self),\n             purity: m.purity,\n-            decl: fold_fn_decl(&m.decl, self),\n-            body: self.fold_block(&m.body),\n+            decl: fold_fn_decl(m.decl, self),\n+            body: self.fold_block(m.body),\n             id: self.new_id(m.id),\n             span: self.new_span(m.span),\n             self_id: self.new_id(m.self_id),\n             vis: m.vis,\n         }\n     }\n \n-    fn fold_block(&self, b: &Block) -> Block {\n+    fn fold_block(&self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n@@ -168,7 +168,7 @@ pub trait ast_fold {\n         Arm {\n             pats: a.pats.map(|x| self.fold_pat(*x)),\n             guard: a.guard.map(|x| self.fold_expr(x)),\n-            body: self.fold_block(&a.body),\n+            body: self.fold_block(a.body),\n         }\n     }\n \n@@ -237,7 +237,7 @@ pub trait ast_fold {\n         noop_fold_expr(e, self)\n     }\n \n-    fn fold_ty(&self, t: &Ty) -> Ty {\n+    fn fold_ty(&self, t: P<Ty>) -> P<Ty> {\n         let node = match t.node {\n             ty_nil | ty_bot | ty_infer => t.node.clone(),\n             ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n@@ -254,7 +254,7 @@ pub trait ast_fold {\n                     region: fold_opt_lifetime(&f.region, self),\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: fold_fn_decl(&f.decl, self),\n+                    decl: fold_fn_decl(f.decl, self),\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                 })\n             }\n@@ -263,10 +263,10 @@ pub trait ast_fold {\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                     purity: f.purity,\n                     abis: f.abis,\n-                    decl: fold_fn_decl(&f.decl, self)\n+                    decl: fold_fn_decl(f.decl, self)\n                 })\n             }\n-            ty_tup(ref tys) => ty_tup(tys.map(|ty| self.fold_ty(ty))),\n+            ty_tup(ref tys) => ty_tup(tys.map(|&ty| self.fold_ty(ty))),\n             ty_path(ref path, ref bounds, id) => {\n                 ty_path(self.fold_path(path),\n                         fold_opt_bounds(bounds, self),\n@@ -277,11 +277,11 @@ pub trait ast_fold {\n             }\n             ty_typeof(expr) => ty_typeof(self.fold_expr(expr)),\n         };\n-        Ty {\n+        P(Ty {\n             id: self.new_id(t.id),\n             span: self.new_span(t.span),\n             node: node,\n-        }\n+        })\n     }\n \n     fn fold_mod(&self, m: &_mod) -> _mod {\n@@ -302,7 +302,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_variant(&self, v: &variant) -> variant {\n+    fn fold_variant(&self, v: &variant) -> P<variant> {\n         let kind;\n         match v.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n@@ -333,10 +333,10 @@ pub trait ast_fold {\n             disr_expr: de,\n             vis: v.node.vis,\n         };\n-        Spanned {\n+        P(Spanned {\n             node: node,\n             span: self.new_span(v.span),\n-        }\n+        })\n     }\n \n     fn fold_ident(&self, i: Ident) -> Ident {\n@@ -350,14 +350,14 @@ pub trait ast_fold {\n             segments: p.segments.map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n                 lifetimes: segment.lifetimes.map(|l| fold_lifetime(l, self)),\n-                types: segment.types.map(|typ| self.fold_ty(typ)),\n+                types: segment.types.map(|&typ| self.fold_ty(typ)),\n             })\n         }\n     }\n \n     fn fold_local(&self, l: @Local) -> @Local {\n         @Local {\n-            ty: self.fold_ty(&l.ty),\n+            ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n             init: l.init.map(|e| self.fold_expr(e)),\n             id: self.new_id(l.id),\n@@ -444,7 +444,7 @@ fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n     ast::arg {\n-        ty: fld.fold_ty(&a.ty),\n+        ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),\n     }\n@@ -480,13 +480,13 @@ fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n }\n \n pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n-                                -> ast::fn_decl {\n-    ast::fn_decl {\n+                                -> P<fn_decl> {\n+    P(fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n-        output: fld.fold_ty(&decl.output),\n+        output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n         variadic: decl.variadic\n-    }\n+    })\n }\n \n fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &T)\n@@ -567,7 +567,7 @@ fn fold_struct_field<T:ast_fold>(f: @struct_field, fld: &T) -> @struct_field {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(&f.node.ty),\n+            ty: fld.fold_ty(f.node.ty),\n             attrs: f.node.attrs.map(|a| fold_attribute_(*a, fld)),\n         },\n         span: fld.new_span(f.span),\n@@ -584,7 +584,7 @@ fn fold_field_<T:ast_fold>(field: Field, folder: &T) -> Field {\n \n fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n     mt {\n-        ty: ~folder.fold_ty(mt.ty),\n+        ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n@@ -609,30 +609,30 @@ fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n                                  -> variant_arg {\n     ast::variant_arg {\n-        ty: folder.fold_ty(&va.ty),\n+        ty: folder.fold_ty(va.ty),\n         id: folder.new_id(va.id)\n     }\n }\n \n-pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n+pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n-    ast::Block {\n+    P(Block {\n         view_items: view_items,\n         stmts: stmts,\n         expr: b.expr.map(|x| folder.fold_expr(x)),\n         id: folder.new_id(b.id),\n         rules: b.rules,\n         span: folder.new_span(b.span),\n-    }\n+    })\n }\n \n pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n     match *i {\n-        item_static(ref t, m, e) => {\n+        item_static(t, m, e) => {\n             item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        item_fn(ref decl, purity, abi, ref generics, ref body) => {\n+        item_fn(decl, purity, abi, ref generics, body) => {\n             item_fn(\n                 fold_fn_decl(decl, folder),\n                 purity,\n@@ -645,14 +645,14 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(folder.fold_foreign_mod(nm))\n         }\n-        item_ty(ref t, ref generics) => {\n+        item_ty(t, ref generics) => {\n             item_ty(folder.fold_ty(t),\n                     fold_generics(generics, folder))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n                 ast::enum_def {\n-                    variants: enum_definition.variants.map(|x| {\n+                    variants: enum_definition.variants.map(|&x| {\n                         folder.fold_variant(x)\n                     }),\n                 },\n@@ -662,7 +662,7 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n             let struct_def = fold_struct_def(*struct_def, folder);\n             item_struct(struct_def, fold_generics(generics, folder))\n         }\n-        item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n+        item_impl(ref generics, ref ifce, ty, ref methods) => {\n             item_impl(fold_generics(generics, folder),\n                       ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n                       folder.fold_ty(ty),\n@@ -690,7 +690,7 @@ pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n         purity: m.purity,\n-        decl: fold_fn_decl(&m.decl, fld),\n+        decl: fold_fn_decl(m.decl, fld),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         id: fld.new_id(m.id),\n@@ -757,7 +757,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n                 folder.new_id(callee_id),\n                 folder.fold_expr(f),\n                 folder.fold_ident(i),\n-                tps.map(|x| folder.fold_ty(x)),\n+                tps.map(|&x| folder.fold_ty(x)),\n                 folder.map_exprs(|x| folder.fold_expr(x), *args),\n                 blk\n             )\n@@ -773,42 +773,42 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n         }\n         ExprDoBody(f) => ExprDoBody(folder.fold_expr(f)),\n         ExprLit(_) => e.node.clone(),\n-        ExprCast(expr, ref ty) => {\n+        ExprCast(expr, ty) => {\n             ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n         }\n         ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-        ExprIf(cond, ref tr, fl) => {\n+        ExprIf(cond, tr, fl) => {\n             ExprIf(folder.fold_expr(cond),\n                    folder.fold_block(tr),\n                    fl.map(|x| folder.fold_expr(x)))\n         }\n-        ExprWhile(cond, ref body) => {\n+        ExprWhile(cond, body) => {\n             ExprWhile(folder.fold_expr(cond), folder.fold_block(body))\n         }\n-        ExprForLoop(pat, iter, ref body, ref maybe_ident) => {\n+        ExprForLoop(pat, iter, body, ref maybe_ident) => {\n             ExprForLoop(folder.fold_pat(pat),\n                         folder.fold_expr(iter),\n                         folder.fold_block(body),\n                         maybe_ident.map(|i| folder.fold_ident(i)))\n         }\n-        ExprLoop(ref body, opt_ident) => {\n+        ExprLoop(body, opt_ident) => {\n             ExprLoop(folder.fold_block(body),\n                      opt_ident.map(|x| folder.fold_ident(x)))\n         }\n         ExprMatch(expr, ref arms) => {\n             ExprMatch(folder.fold_expr(expr),\n                       arms.map(|x| folder.fold_arm(x)))\n         }\n-        ExprFnBlock(ref decl, ref body) => {\n+        ExprFnBlock(decl, body) => {\n             ExprFnBlock(\n                 fold_fn_decl(decl, folder),\n                 folder.fold_block(body)\n             )\n         }\n-        ExprProc(ref decl, ref body) => {\n+        ExprProc(decl, body) => {\n             ExprProc(fold_fn_decl(decl, folder), folder.fold_block(body))\n         }\n-        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk)),\n+        ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n         ExprAssign(el, er) => {\n             ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n@@ -821,7 +821,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n         ExprField(el, id, ref tys) => {\n             ExprField(folder.fold_expr(el),\n                       folder.fold_ident(id),\n-                      tys.map(|x| folder.fold_ty(x)))\n+                      tys.map(|&x| folder.fold_ty(x)))\n         }\n         ExprIndex(callee_id, el, er) => {\n             ExprIndex(folder.new_id(callee_id),"}, {"sha": "1204cbc2eeae7c578f1474e982b30d73faf4947c", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -39,9 +39,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n \n pub fn expr_is_simple_block(e: @ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprBlock(\n-            ast::Block { rules: ast::DefaultBlock, .. }\n-        ) => true,\n+        ast::ExprBlock(block) => block.rules == ast::DefaultBlock,\n       _ => false\n     }\n }"}, {"sha": "83825cca631fed632262eee98e8d7539548c6887", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -655,10 +655,10 @@ mod test {\n                       @ast::item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n                             id: ast::DUMMY_NODE_ID,\n-                            node: ast::item_fn(ast::fn_decl{\n+                            node: ast::item_fn(ast::P(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n-                                    ty: ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                node: ast::ty_path(ast::Path{\n+                                    ty: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                       node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: ~[\n@@ -671,7 +671,7 @@ mod test {\n                                         ],\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n-                                    },\n+                                    }),\n                                     pat: @ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n@@ -694,19 +694,19 @@ mod test {\n                                     },\n                                     id: ast::DUMMY_NODE_ID\n                                 }],\n-                                output: ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                 node: ast::ty_nil,\n-                                                 span:sp(15,15)}, // not sure\n+                                output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                       node: ast::ty_nil,\n+                                                       span:sp(15,15)}), // not sure\n                                 cf: ast::return_val,\n                                 variadic: false\n-                            },\n+                            }),\n                                     ast::impure_fn,\n                                     abi::AbiSet::Rust(),\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: opt_vec::Empty,\n                                         ty_params: opt_vec::Empty,\n                                     },\n-                                    ast::Block {\n+                                    ast::P(ast::Block {\n                                         view_items: ~[],\n                                         stmts: ~[@Spanned{\n                                             node: ast::StmtSemi(@ast::Expr{\n@@ -734,7 +734,7 @@ mod test {\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n-                                    }),\n+                                    })),\n                             vis: ast::inherited,\n                             span: sp(0,21)}));\n     }"}, {"sha": "5807098c91e8cba5ca820b8776714dc9b7b904b0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 78, "deletions": 62, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -41,7 +41,7 @@ use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int, lit_char};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n use ast::{MutImmutable, MutMutable, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, BiMul, Mutability};\n-use ast::{named_field, UnNeg, noreturn, UnNot, Pat, PatBox, PatEnum};\n+use ast::{named_field, UnNeg, noreturn, UnNot, P, Pat, PatBox, PatEnum};\n use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatUniq, PatWild, PatWildMulti, private};\n use ast::{BiRem, required};\n@@ -190,6 +190,22 @@ macro_rules! maybe_whole (\n             }\n         }\n     );\n+    (no_clone $p:expr, $constructor:ident) => (\n+        {\n+            let __found__ = match *($p).token {\n+                INTERPOLATED(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            match __found__ {\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return x\n+                }\n+                _ => {}\n+            }\n+        }\n+    );\n     (deref $p:expr, $constructor:ident) => (\n         {\n             let __found__ = match *($p).token {\n@@ -247,8 +263,8 @@ macro_rules! maybe_whole (\n                 _ => None\n             };\n             match __found__ {\n-                Some(INTERPOLATED(token::$constructor(ref x))) => {\n-                    return (~[], (**x).clone())\n+                Some(INTERPOLATED(token::$constructor(x))) => {\n+                    return (~[], x)\n                 }\n                 _ => {}\n             }\n@@ -960,12 +976,12 @@ impl Parser {\n                 let bounds = self.parse_optional_ty_param_bounds();\n \n                 let (return_style, output) = self.parse_ret_ty();\n-                let decl = ast::fn_decl {\n+                let decl = P(ast::fn_decl {\n                     inputs: inputs,\n                     output: output,\n                     cf: return_style,\n                     variadic: false\n-                };\n+                });\n \n                 (BorrowedSigil, decl, lifetimes, bounds)\n             }\n@@ -999,7 +1015,7 @@ impl Parser {\n     }\n \n     // parse a function type (following the 'fn')\n-    pub fn parse_ty_fn_decl(&self, allow_variadic: bool) -> (fn_decl, OptVec<ast::Lifetime>) {\n+    pub fn parse_ty_fn_decl(&self, allow_variadic: bool) -> (P<fn_decl>, OptVec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -1020,12 +1036,12 @@ impl Parser {\n \n         let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        let decl = ast::fn_decl {\n+        let decl = P(ast::fn_decl {\n             inputs: inputs,\n             output: ret_ty,\n             cf: ret_style,\n             variadic: variadic\n-        };\n+        });\n         (decl, lifetimes)\n     }\n \n@@ -1114,7 +1130,7 @@ impl Parser {\n     // parse a possibly mutable type\n     pub fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n-        let t = ~self.parse_ty(false);\n+        let t = self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n@@ -1125,7 +1141,7 @@ impl Parser {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = ~self.parse_ty(false);\n+        let ty = self.parse_ty(false);\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n@@ -1135,17 +1151,17 @@ impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&self) -> (ret_style, Ty) {\n+    pub fn parse_ret_ty(&self) -> (ret_style, P<Ty>) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n                 (\n                     noreturn,\n-                    Ty {\n+                    P(Ty {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ty_bot,\n                         span: mk_sp(lo, self.last_span.hi)\n-                    }\n+                    })\n                 )\n             } else {\n                 (return_val, self.parse_ty(false))\n@@ -1154,20 +1170,20 @@ impl Parser {\n             let pos = self.span.lo;\n             (\n                 return_val,\n-                Ty {\n+                P(Ty {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ty_nil,\n                     span: mk_sp(pos, pos),\n-                }\n+                })\n             )\n         }\n     }\n \n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    pub fn parse_ty(&self, _: bool) -> Ty {\n-        maybe_whole!(deref self, nt_ty);\n+    pub fn parse_ty(&self, _: bool) -> P<Ty> {\n+        maybe_whole!(no_clone self, nt_ty);\n \n         let lo = self.span.lo;\n \n@@ -1216,7 +1232,7 @@ impl Parser {\n         } else if *self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n-            let mt = mt { ty: ~self.parse_ty(false), mutbl: MutImmutable };\n+            let mt = mt { ty: self.parse_ty(false), mutbl: MutImmutable };\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1270,7 +1286,7 @@ impl Parser {\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}\n+        P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp})\n     }\n \n     // parse the type following a @ or a ~\n@@ -1300,7 +1316,7 @@ impl Parser {\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         if sigil == OwnedSigil {\n-            ctor(mt { ty: ~self.parse_ty(false), mutbl: MutImmutable })\n+            ctor(mt { ty: self.parse_ty(false), mutbl: MutImmutable })\n         } else {\n             ctor(self.parse_mt())\n         }\n@@ -1375,11 +1391,11 @@ impl Parser {\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n-            Ty {\n+            P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ty_infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n-            }\n+            })\n         };\n         ast::arg {\n             ty: t,\n@@ -1691,7 +1707,7 @@ impl Parser {\n     pub fn mk_method_call(&self,\n                       rcvr: @Expr,\n                       ident: Ident,\n-                      tps: ~[Ty],\n+                      tps: ~[P<Ty>],\n                       args: ~[@Expr],\n                       sugar: CallSugar) -> ast::Expr_ {\n         ExprMethodCall(ast::DUMMY_NODE_ID, rcvr, ident, tps, args, sugar)\n@@ -1701,7 +1717,7 @@ impl Parser {\n         ExprIndex(ast::DUMMY_NODE_ID, expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @Expr, ident: Ident, tys: ~[Ty]) -> ast::Expr_ {\n+    pub fn mk_field(&self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n@@ -1784,14 +1800,14 @@ impl Parser {\n         } else if self.eat_keyword(keywords::Proc) {\n             let decl = self.parse_proc_decl();\n             let body = self.parse_expr();\n-            let fakeblock = ast::Block {\n+            let fakeblock = P(ast::Block {\n                 view_items: ~[],\n                 stmts: ~[],\n                 expr: Some(body),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n                 span: body.span,\n-            };\n+            });\n \n             return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n         } else if self.eat_keyword(keywords::Self) {\n@@ -2442,16 +2458,16 @@ impl Parser {\n                   }\n                   _ => {\n                     // No argument list - `do foo {`\n-                      ast::fn_decl {\n+                      P(ast::fn_decl {\n                           inputs: ~[],\n-                          output: Ty {\n+                          output: P(Ty {\n                               id: ast::DUMMY_NODE_ID,\n                               node: ty_infer,\n                               span: *self.span\n-                          },\n+                          }),\n                           cf: return_val,\n                           variadic: false\n-                      }\n+                      })\n                   }\n                 }\n             },\n@@ -2471,20 +2487,20 @@ impl Parser {\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&self,\n-                              parse_decl: || -> fn_decl,\n+                              parse_decl: || -> P<fn_decl>,\n                               parse_body: || -> @Expr)\n                               -> @Expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n         let body = parse_body();\n-        let fakeblock = ast::Block {\n+        let fakeblock = P(ast::Block {\n             view_items: ~[],\n             stmts: ~[],\n             expr: Some(body),\n             id: ast::DUMMY_NODE_ID,\n             rules: DefaultBlock,\n             span: body.span,\n-        };\n+        });\n \n         return self.mk_expr(lo, body.span.hi,\n                             ExprFnBlock(decl, fakeblock));\n@@ -2659,14 +2675,14 @@ impl Parser {\n                 self.eat(&token::COMMA);\n             }\n \n-            let blk = ast::Block {\n+            let blk = P(ast::Block {\n                 view_items: ~[],\n                 stmts: ~[],\n                 expr: Some(expr),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n                 span: expr.span,\n-            };\n+            });\n \n             arms.push(ast::Arm { pats: pats, guard: guard, body: blk });\n         }\n@@ -3132,11 +3148,11 @@ impl Parser {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n-        let mut ty = Ty {\n+        let mut ty = P(Ty {\n             id: ast::DUMMY_NODE_ID,\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n-        };\n+        });\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n         let init = self.parse_initializer();\n         @ast::Local {\n@@ -3280,8 +3296,8 @@ impl Parser {\n     }\n \n     // parse a block. No inner attrs are allowed.\n-    pub fn parse_block(&self) -> Block {\n-        maybe_whole!(deref self, nt_block);\n+    pub fn parse_block(&self) -> P<Block> {\n+        maybe_whole!(no_clone self, nt_block);\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n@@ -3294,7 +3310,7 @@ impl Parser {\n \n     // parse a block. Inner attrs are allowed.\n     fn parse_inner_attrs_and_block(&self)\n-        -> (~[Attribute], Block) {\n+        -> (~[Attribute], P<Block>) {\n \n         maybe_whole!(pair_empty self, nt_block);\n \n@@ -3312,13 +3328,13 @@ impl Parser {\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n-    fn parse_block_tail(&self, lo: BytePos, s: BlockCheckMode) -> Block {\n+    fn parse_block_tail(&self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: ~[Attribute]) -> Block {\n+                         first_item_attrs: ~[Attribute]) -> P<Block> {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n@@ -3429,14 +3445,14 @@ impl Parser {\n \n         let hi = self.span.hi;\n         self.bump();\n-        ast::Block {\n+        P(ast::Block {\n             view_items: view_items,\n             stmts: stmts,\n             expr: expr,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: mk_sp(lo, hi),\n-        }\n+        })\n     }\n \n     fn parse_optional_purity(&self) -> ast::purity {\n@@ -3516,15 +3532,15 @@ impl Parser {\n     }\n \n     // parse a generic use site\n-    fn parse_generic_values(&self) -> (OptVec<ast::Lifetime>, ~[Ty]) {\n+    fn parse_generic_values(&self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n         if !self.eat(&token::LT) {\n             (opt_vec::Empty, ~[])\n         } else {\n             self.parse_generic_values_after_lt()\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&self) -> (OptVec<ast::Lifetime>, ~[Ty]) {\n+    fn parse_generic_values_after_lt(&self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n@@ -3579,17 +3595,17 @@ impl Parser {\n     }\n \n     // parse the argument list and result type of a function declaration\n-    pub fn parse_fn_decl(&self, allow_variadic: bool) -> fn_decl {\n+    pub fn parse_fn_decl(&self, allow_variadic: bool) -> P<fn_decl> {\n \n         let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n-        ast::fn_decl {\n+        P(ast::fn_decl {\n             inputs: args,\n             output: ret_ty,\n             cf: ret_style,\n             variadic: variadic\n-        }\n+        })\n     }\n \n     fn is_self_ident(&self) -> bool {\n@@ -3614,7 +3630,7 @@ impl Parser {\n     // parse the argument list and result type of a function\n     // that may have a self type.\n     fn parse_fn_decl_with_self(&self, parse_arg_fn: |&Parser| -> arg)\n-                               -> (explicit_self, fn_decl) {\n+                               -> (explicit_self, P<fn_decl>) {\n         fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n                                         ast::explicit_self_,\n                                      p: &Parser)\n@@ -3775,18 +3791,18 @@ impl Parser {\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n-        let fn_decl = ast::fn_decl {\n+        let fn_decl = P(ast::fn_decl {\n             inputs: fn_inputs,\n             output: ret_ty,\n             cf: ret_style,\n             variadic: false\n-        };\n+        });\n \n         (spanned(lo, hi, explicit_self), fn_decl)\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&self) -> fn_decl {\n+    fn parse_fn_block_decl(&self) -> P<fn_decl> {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n                 ~[]\n@@ -3802,19 +3818,19 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            Ty { id: ast::DUMMY_NODE_ID, node: ty_infer, span: *self.span }\n+            P(Ty { id: ast::DUMMY_NODE_ID, node: ty_infer, span: *self.span })\n         };\n \n-        ast::fn_decl {\n+        P(ast::fn_decl {\n             inputs: inputs_captures,\n             output: output,\n             cf: return_val,\n             variadic: false\n-        }\n+        })\n     }\n \n     // Parses the `(arg, arg) -> return_type` header on a procedure.\n-    fn parse_proc_decl(&self) -> fn_decl {\n+    fn parse_proc_decl(&self) -> P<fn_decl> {\n         let inputs =\n             self.parse_unspanned_seq(&token::LPAREN,\n                                      &token::RPAREN,\n@@ -3824,19 +3840,19 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            Ty {\n+            P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ty_infer,\n                 span: *self.span,\n-            }\n+            })\n         };\n \n-        ast::fn_decl {\n+        P(ast::fn_decl {\n             inputs: inputs,\n             output: output,\n             cf: return_val,\n             variadic: false\n-        }\n+        })\n     }\n \n     // parse the name and optional generic types of a function header.\n@@ -4517,7 +4533,7 @@ impl Parser {\n                 disr_expr: disr_expr,\n                 vis: vis,\n             };\n-            variants.push(spanned(vlo, self.last_span.hi, vr));\n+            variants.push(P(spanned(vlo, self.last_span.hi, vr)));\n \n             if !self.eat(&token::COMMA) { break; }\n         }"}, {"sha": "04f03b4b58c76182d8269dbb7ae2c11ee537444c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{Name, Mrk};\n+use ast::{P, Name, Mrk};\n use ast_util;\n use parse::token;\n use util::interner::StrInterner;\n@@ -101,11 +101,11 @@ pub enum Token {\n /// For interpolation during macro expansion.\n pub enum nonterminal {\n     nt_item(@ast::item),\n-    nt_block(~ast::Block),\n+    nt_block(P<ast::Block>),\n     nt_stmt(@ast::Stmt),\n     nt_pat( @ast::Pat),\n     nt_expr(@ast::Expr),\n-    nt_ty(  ~ast::Ty),\n+    nt_ty(  P<ast::Ty>),\n     nt_ident(~ast::Ident, bool),\n     nt_attr(@ast::Attribute),   // #[foo]\n     nt_path(~ast::Path),"}, {"sha": "9eb61728e59b222941a801beac21174a021276ea", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::AbiSet;\n-use ast::{RegionTyParamBound, TraitTyParamBound, required, provided};\n+use ast::{P, RegionTyParamBound, TraitTyParamBound, required, provided};\n use ast;\n use ast_util;\n use opt_vec::OptVec;\n@@ -418,7 +418,7 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, print_type);\n+        commasep(s, inconsistent, *elts, print_type_ref);\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -430,7 +430,7 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n             ty_params: opt_vec::Empty\n           };\n           print_ty_fn(s, Some(f.abis), None, &None,\n-                      f.purity, ast::Many, &f.decl, None, &None,\n+                      f.purity, ast::Many, f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n@@ -439,7 +439,7 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n             ty_params: opt_vec::Empty\n           };\n           print_ty_fn(s, None, Some(f.sigil), &f.region,\n-                      f.purity, f.onceness, &f.decl, None, &f.bounds,\n+                      f.purity, f.onceness, f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n       ast::ty_path(ref path, ref bounds, _) => print_bounded_path(s, path, bounds),\n@@ -467,19 +467,23 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n     end(s);\n }\n \n+pub fn print_type_ref(s: @ps, ty: &P<ast::Ty>) {\n+    print_type(s, *ty);\n+}\n+\n pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n-      ast::foreign_item_fn(ref decl, ref generics) => {\n+      ast::foreign_item_fn(decl, ref generics) => {\n         print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics, None,\n                  item.vis);\n         end(s); // end head-ibox\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n-      ast::foreign_item_static(ref t, m) => {\n+      ast::foreign_item_static(t, m) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n         if m {\n             word_space(s, \"mut\");\n@@ -501,7 +505,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n     let ann_node = node_item(s, item);\n     s.ann.pre(ann_node);\n     match item.node {\n-      ast::item_static(ref ty, m, expr) => {\n+      ast::item_static(ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n         if m == ast::MutMutable {\n             word_space(s, \"mut\");\n@@ -518,7 +522,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(ref decl, purity, abi, ref typarams, ref body) => {\n+      ast::item_fn(decl, purity, abi, ref typarams, body) => {\n         print_fn(\n             s,\n             decl,\n@@ -547,7 +551,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ref ty, ref params) => {\n+      ast::item_ty(ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, \"type\"));\n@@ -576,7 +580,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n+      ast::item_impl(ref generics, ref opt_trait, ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n@@ -655,10 +659,10 @@ pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n }\n \n pub fn print_variants(s: @ps,\n-                      variants: &[ast::variant],\n+                      variants: &[P<ast::variant>],\n                       span: codemap::Span) {\n     bopen(s);\n-    for v in variants.iter() {\n+    for &v in variants.iter() {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n@@ -709,7 +713,7 @@ pub fn print_struct(s: @ps,\n                     ast::named_field(..) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n-                        print_type(s, &field.node.ty);\n+                        print_type(s, field.node.ty);\n                     }\n                 }\n             });\n@@ -733,7 +737,7 @@ pub fn print_struct(s: @ps,\n                     print_visibility(s, visibility);\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n-                    print_type(s, &field.node.ty);\n+                    print_type(s, field.node.ty);\n                     word(s.s, \",\");\n                 }\n             }\n@@ -792,7 +796,7 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             if !args.is_empty() {\n                 popen(s);\n                 fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n-                    print_type(s, &arg.ty);\n+                    print_type(s, arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n@@ -824,7 +828,7 @@ pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n                 &None,\n                 m.purity,\n                 ast::Many,\n-                &m.decl,\n+                m.decl,\n                 Some(m.ident),\n                 &None,\n                 Some(&m.generics),\n@@ -843,11 +847,11 @@ pub fn print_method(s: @ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, &meth.decl, Some(meth.purity), AbiSet::Rust(),\n+    print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n              meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n     word(s.s, \" \");\n-    print_block_with_attrs(s, &meth.body, meth.attrs);\n+    print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n@@ -996,7 +1000,7 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n           Some(_else) => {\n             match _else.node {\n               // \"another else-if\"\n-              ast::ExprIf(i, ref t, e) => {\n+              ast::ExprIf(i, t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, \" else if \");\n@@ -1006,7 +1010,7 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n                 do_else(s, e);\n               }\n               // \"final else\"\n-              ast::ExprBlock(ref b) => {\n+              ast::ExprBlock(b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, \" else \");\n@@ -1195,7 +1199,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         print_ident(s, ident);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type_ref);\n             word(s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n@@ -1221,22 +1225,22 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         print_expr(s, expr);\n       }\n       ast::ExprLit(lit) => print_literal(s, lit),\n-      ast::ExprCast(expr, ref ty) => {\n+      ast::ExprCast(expr, ty) => {\n         print_expr(s, expr);\n         space(s.s);\n         word_space(s, \"as\");\n         print_type(s, ty);\n       }\n-      ast::ExprIf(test, ref blk, elseopt) => {\n+      ast::ExprIf(test, blk, elseopt) => {\n         print_if(s, test, blk, elseopt, false);\n       }\n-      ast::ExprWhile(test, ref blk) => {\n+      ast::ExprWhile(test, blk) => {\n         head(s, \"while\");\n         print_expr(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::ExprForLoop(pat, iter, ref blk, opt_ident) => {\n+      ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n@@ -1250,7 +1254,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::ExprLoop(ref blk, opt_ident) => {\n+      ast::ExprLoop(blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n@@ -1300,7 +1304,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                 match arm.body.expr {\n                     Some(expr) => {\n                         match expr.node {\n-                            ast::ExprBlock(ref blk) => {\n+                            ast::ExprBlock(blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n                                     s, blk, indent_unit);\n@@ -1320,12 +1324,12 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                print_block_unclosed_indent(s, &arm.body, indent_unit);\n+                print_block_unclosed_indent(s, arm.body, indent_unit);\n             }\n         }\n         bclose_(s, expr.span, indent_unit);\n       }\n-      ast::ExprFnBlock(ref decl, ref body) => {\n+      ast::ExprFnBlock(decl, body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n@@ -1338,7 +1342,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.expr.unwrap().node {\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprBlock(blk) => {\n                 print_block_unclosed(s, blk);\n             }\n             _ => {\n@@ -1352,7 +1356,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         // empty box to satisfy the close.\n         ibox(s, 0);\n       }\n-      ast::ExprProc(ref decl, ref body) => {\n+      ast::ExprProc(decl, body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n@@ -1365,7 +1369,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.expr.unwrap().node {\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprBlock(blk) => {\n                 print_block_unclosed(s, blk);\n             }\n             _ => {\n@@ -1382,7 +1386,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n       ast::ExprDoBody(body) => {\n         print_expr(s, body);\n       }\n-      ast::ExprBlock(ref blk) => {\n+      ast::ExprBlock(blk) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block after {\n@@ -1408,7 +1412,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         print_ident(s, id);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type_ref);\n             word(s.s, \">\");\n         }\n       }\n@@ -1493,7 +1497,7 @@ pub fn print_local_decl(s: @ps, loc: &ast::Local) {\n     print_pat(s, loc.pat);\n     match loc.ty.node {\n       ast::ty_infer => (),\n-      _ => { word_space(s, \":\"); print_type(s, &loc.ty); }\n+      _ => { word_space(s, \":\"); print_type(s, loc.ty); }\n     }\n }\n \n@@ -1589,8 +1593,8 @@ fn print_path_(s: @ps,\n                 }\n                 commasep(s,\n                          inconsistent,\n-                         segment.types.map_to_vec(|t| (*t).clone()),\n-                         print_type);\n+                         segment.types.map_to_vec(|&t| t),\n+                         print_type_ref);\n             }\n \n             word(s.s, \">\")\n@@ -1796,7 +1800,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, &decl.output);\n+            print_type(s, decl.output);\n         }\n     }\n }\n@@ -1811,7 +1815,7 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, &decl.output);\n+            print_type(s, decl.output);\n         }\n     }\n \n@@ -1829,7 +1833,7 @@ pub fn print_proc_args(s: @ps, decl: &ast::fn_decl) {\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, &decl.output);\n+            print_type(s, decl.output);\n         }\n     }\n \n@@ -2007,7 +2011,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n                 space(s.s);\n             }\n         }\n-        print_type(s, &input.ty);\n+        print_type(s, input.ty);\n       }\n     }\n     end(s);\n@@ -2094,7 +2098,7 @@ pub fn print_ty_fn(s: @ps,\n             ibox(s, indent_unit);\n             word_space(s, \"->\");\n             if decl.cf == ast::noreturn { word_nbsp(s, \"!\"); }\n-            else { print_type(s, &decl.output); }\n+            else { print_type(s, decl.output); }\n             end(s);\n         }\n     }\n@@ -2419,9 +2423,9 @@ mod test {\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n-            output: ast::Ty {id: 0,\n-                              node: ast::ty_nil,\n-                              span: codemap::dummy_sp()},\n+            output: ast::P(ast::Ty {id: 0,\n+                                    node: ast::ty_nil,\n+                                    span: codemap::dummy_sp()}),\n             cf: ast::return_val,\n             variadic: false\n         };"}, {"sha": "e5a06c46d06bac842718b1c4eb461d061dcc344b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2aa00ba8b3539985c77f84b01e5781dd1455177/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b2aa00ba8b3539985c77f84b01e5781dd1455177", "patch": "@@ -75,7 +75,7 @@ pub trait Visitor<E:Clone> {\n     fn visit_foreign_item(&mut self, i:@foreign_item, e:E) { walk_foreign_item(self, i, e) }\n     fn visit_item(&mut self, i:@item, e:E) { walk_item(self, i, e) }\n     fn visit_local(&mut self, l:@Local, e:E) { walk_local(self, l, e) }\n-    fn visit_block(&mut self, b:&Block, e:E) { walk_block(self, b, e) }\n+    fn visit_block(&mut self, b:P<Block>, e:E) { walk_block(self, b, e) }\n     fn visit_stmt(&mut self, s:@Stmt, e:E) { walk_stmt(self, s, e) }\n     fn visit_arm(&mut self, a:&Arm, e:E) { walk_arm(self, a, e) }\n     fn visit_pat(&mut self, p:&Pat, e:E) { walk_pat(self, p, e) }\n@@ -84,7 +84,7 @@ pub trait Visitor<E:Clone> {\n     fn visit_expr_post(&mut self, _ex:@Expr, _e:E) { }\n     fn visit_ty(&mut self, _t:&Ty, _e:E) { }\n     fn visit_generics(&mut self, g:&Generics, e:E) { walk_generics(self, g, e) }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:E) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:E) {\n         walk_fn(self, fk, fd, b, s, n , e)\n     }\n     fn visit_ty_method(&mut self, t:&TypeMethod, e:E) { walk_ty_method(self, t, e) }\n@@ -164,7 +164,7 @@ pub fn walk_view_item<E:Clone, V:Visitor<E>>(visitor: &mut V, vi: &view_item, en\n \n pub fn walk_local<E:Clone, V:Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n     visitor.visit_pat(local.pat, env.clone());\n-    visitor.visit_ty(&local.ty, env.clone());\n+    visitor.visit_ty(local.ty, env.clone());\n     match local.init {\n         None => {}\n         Some(initializer) => visitor.visit_expr(initializer, env),\n@@ -192,11 +192,11 @@ fn walk_trait_ref<E:Clone, V:Visitor<E>>(visitor: &mut V,\n pub fn walk_item<E:Clone, V:Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n     visitor.visit_ident(item.span, item.ident, env.clone());\n     match item.node {\n-        item_static(ref typ, _, expr) => {\n+        item_static(typ, _, expr) => {\n             visitor.visit_ty(typ, env.clone());\n             visitor.visit_expr(expr, env);\n         }\n-        item_fn(ref declaration, purity, abi, ref generics, ref body) => {\n+        item_fn(declaration, purity, abi, ref generics, body) => {\n             visitor.visit_fn(&fk_item_fn(item.ident, generics, purity, abi),\n                              declaration,\n                              body,\n@@ -215,7 +215,7 @@ pub fn walk_item<E:Clone, V:Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n                 visitor.visit_foreign_item(*foreign_item, env.clone())\n             }\n         }\n-        item_ty(ref typ, ref type_parameters) => {\n+        item_ty(typ, ref type_parameters) => {\n             visitor.visit_ty(typ, env.clone());\n             visitor.visit_generics(type_parameters, env)\n         }\n@@ -225,7 +225,7 @@ pub fn walk_item<E:Clone, V:Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n         }\n         item_impl(ref type_parameters,\n                   ref trait_references,\n-                  ref typ,\n+                  typ,\n                   ref methods) => {\n             visitor.visit_generics(type_parameters, env.clone());\n             for trait_reference in trait_references.iter() {\n@@ -261,7 +261,7 @@ pub fn walk_enum_def<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                                enum_definition: &ast::enum_def,\n                                generics: &Generics,\n                                env: E) {\n-    for variant in enum_definition.variants.iter() {\n+    for &variant in enum_definition.variants.iter() {\n         visitor.visit_variant(variant, generics, env.clone());\n     }\n }\n@@ -275,7 +275,7 @@ pub fn walk_variant<E:Clone, V:Visitor<E>>(visitor:&mut V,\n     match variant.node.kind {\n         tuple_variant_kind(ref variant_arguments) => {\n             for variant_argument in variant_arguments.iter() {\n-                visitor.visit_ty(&variant_argument.ty, env.clone())\n+                visitor.visit_ty(variant_argument.ty, env.clone())\n             }\n         }\n         struct_variant_kind(struct_definition) => {\n@@ -303,15 +303,15 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n             visitor.visit_ty(mutable_type.ty, env)\n         }\n         ty_tup(ref tuple_element_types) => {\n-            for tuple_element_type in tuple_element_types.iter() {\n+            for &tuple_element_type in tuple_element_types.iter() {\n                 visitor.visit_ty(tuple_element_type, env.clone())\n             }\n         }\n         ty_closure(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&argument.ty, env.clone())\n+                visitor.visit_ty(argument.ty, env.clone())\n             }\n-            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(function_declaration.decl.output, env.clone());\n             for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n@@ -324,9 +324,9 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         ty_bare_fn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&argument.ty, env.clone())\n+                visitor.visit_ty(argument.ty, env.clone())\n             }\n-            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(function_declaration.decl.output, env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n@@ -359,7 +359,7 @@ pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier, env.clone());\n \n-        for typ in segment.types.iter() {\n+        for &typ in segment.types.iter() {\n             visitor.visit_ty(typ, env.clone());\n         }\n         for lifetime in segment.lifetimes.iter() {\n@@ -427,11 +427,11 @@ pub fn walk_foreign_item<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(foreign_item.span, foreign_item.ident, env.clone());\n \n     match foreign_item.node {\n-        foreign_item_fn(ref function_declaration, ref generics) => {\n+        foreign_item_fn(function_declaration, ref generics) => {\n             walk_fn_decl(visitor, function_declaration, env.clone());\n             visitor.visit_generics(generics, env)\n         }\n-        foreign_item_static(ref typ, _) => visitor.visit_ty(typ, env),\n+        foreign_item_static(typ, _) => visitor.visit_ty(typ, env),\n     }\n }\n \n@@ -462,9 +462,9 @@ pub fn walk_fn_decl<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                               env: E) {\n     for argument in function_declaration.inputs.iter() {\n         visitor.visit_pat(argument.pat, env.clone());\n-        visitor.visit_ty(&argument.ty, env.clone())\n+        visitor.visit_ty(argument.ty, env.clone())\n     }\n-    visitor.visit_ty(&function_declaration.output, env)\n+    visitor.visit_ty(function_declaration.output, env)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -476,8 +476,8 @@ pub fn walk_method_helper<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                                     env: E) {\n     visitor.visit_ident(method.span, method.ident, env.clone());\n     visitor.visit_fn(&fk_method(method.ident, &method.generics, method),\n-                     &method.decl,\n-                     &method.body,\n+                     method.decl,\n+                     method.body,\n                      method.span,\n                      method.id,\n                      env)\n@@ -486,7 +486,7 @@ pub fn walk_method_helper<E:Clone, V:Visitor<E>>(visitor: &mut V,\n pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                          function_kind: &fn_kind,\n                          function_declaration: &fn_decl,\n-                         function_body: &Block,\n+                         function_body: P<Block>,\n                          _span: Span,\n                          _: NodeId,\n                          env: E) {\n@@ -514,10 +514,10 @@ pub fn walk_ty_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(method_type.span, method_type.ident, env.clone());\n     visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n-        visitor.visit_ty(&argument_type.ty, env.clone())\n+        visitor.visit_ty(argument_type.ty, env.clone())\n     }\n     visitor.visit_generics(&method_type.generics, env.clone());\n-    visitor.visit_ty(&method_type.decl.output, env);\n+    visitor.visit_ty(method_type.decl.output, env);\n }\n \n pub fn walk_trait_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n@@ -552,10 +552,10 @@ pub fn walk_struct_field<E:Clone, V:Visitor<E>>(visitor: &mut V,\n         _ => {}\n     }\n \n-    visitor.visit_ty(&struct_field.node.ty, env)\n+    visitor.visit_ty(struct_field.node.ty, env)\n }\n \n-pub fn walk_block<E:Clone, V:Visitor<E>>(visitor: &mut V, block: &Block, env: E) {\n+pub fn walk_block<E:Clone, V:Visitor<E>>(visitor: &mut V, block: P<Block>, env: E) {\n     for view_item in block.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n@@ -635,7 +635,7 @@ pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env:\n         }\n         ExprMethodCall(_, callee, _, ref types, ref arguments, _) => {\n             walk_exprs(visitor, *arguments, env.clone());\n-            for typ in types.iter() {\n+            for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n             visitor.visit_expr(callee, env.clone())\n@@ -650,48 +650,48 @@ pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env:\n             visitor.visit_expr(subexpression, env.clone())\n         }\n         ExprLit(_) => {}\n-        ExprCast(subexpression, ref typ) => {\n+        ExprCast(subexpression, typ) => {\n             visitor.visit_expr(subexpression, env.clone());\n             visitor.visit_ty(typ, env.clone())\n         }\n-        ExprIf(head_expression, ref if_block, optional_else) => {\n+        ExprIf(head_expression, if_block, optional_else) => {\n             visitor.visit_expr(head_expression, env.clone());\n             visitor.visit_block(if_block, env.clone());\n             walk_expr_opt(visitor, optional_else, env.clone())\n         }\n-        ExprWhile(subexpression, ref block) => {\n+        ExprWhile(subexpression, block) => {\n             visitor.visit_expr(subexpression, env.clone());\n             visitor.visit_block(block, env.clone())\n         }\n-        ExprForLoop(pattern, subexpression, ref block, _) => {\n+        ExprForLoop(pattern, subexpression, block, _) => {\n             visitor.visit_pat(pattern, env.clone());\n             visitor.visit_expr(subexpression, env.clone());\n             visitor.visit_block(block, env.clone())\n         }\n-        ExprLoop(ref block, _) => visitor.visit_block(block, env.clone()),\n+        ExprLoop(block, _) => visitor.visit_block(block, env.clone()),\n         ExprMatch(subexpression, ref arms) => {\n             visitor.visit_expr(subexpression, env.clone());\n             for arm in arms.iter() {\n                 visitor.visit_arm(arm, env.clone())\n             }\n         }\n-        ExprFnBlock(ref function_declaration, ref body) => {\n+        ExprFnBlock(function_declaration, body) => {\n             visitor.visit_fn(&fk_fn_block,\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprProc(ref function_declaration, ref body) => {\n+        ExprProc(function_declaration, body) => {\n             visitor.visit_fn(&fk_fn_block,\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprBlock(ref block) => visitor.visit_block(block, env.clone()),\n+        ExprBlock(block) => visitor.visit_block(block, env.clone()),\n         ExprAssign(left_hand_expression, right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression, env.clone());\n             visitor.visit_expr(left_hand_expression, env.clone())\n@@ -702,7 +702,7 @@ pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env:\n         }\n         ExprField(subexpression, _, ref types) => {\n             visitor.visit_expr(subexpression, env.clone());\n-            for typ in types.iter() {\n+            for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n         }\n@@ -738,5 +738,5 @@ pub fn walk_arm<E:Clone, V:Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n         visitor.visit_pat(*pattern, env.clone())\n     }\n     walk_expr_opt(visitor, arm.guard, env.clone());\n-    visitor.visit_block(&arm.body, env)\n+    visitor.visit_block(arm.body, env)\n }"}]}