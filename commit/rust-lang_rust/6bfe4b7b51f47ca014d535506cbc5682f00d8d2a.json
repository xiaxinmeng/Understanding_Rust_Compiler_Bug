{"sha": "6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZmU0YjdiNTFmNDdjYTAxNGQ1MzU1MDZjYmM1NjgyZjAwZDhkMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T05:44:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T05:44:01Z"}, "message": "Auto merge of #59336 - gnzlbg:hint_black_box, r=alexcrichton\n\nMoves test::black_box to core::hint and fix black_box on wasm32 and asm.js\n\nThis changes removes a cyclic dependency between the \"test\" and \"libtest\"\ncrates, where \"libtest\" depends on \"test\" for \"black_box\", but \"test\" depends on\n\"libtest\" for everything else.\n\nI've chosen the \"hint\" module because there seems to be enough consensus in the\ndiscussion of RFC2360 that this module is where such an intrinsic would belong,\nbut this PR does not implement that RFC! If that RFC ever gets merged, the API, docs,\netc. of this API will need to change. This PR just move the implementation of the\nalready existing API.\n\nFor backwards compatibility reasons I've chosen to also keep the \"test\" feature\ngate for these instead of adding a new feature gate. If we change the feature\ngate, we'll potentially all benchmarks, and while that's something that we could\ndo, it seems unnecessary to do that now - if RFC2360 gets merged, we'll need to\ndo that anyways. Backwards compatibility is also why we continue to re-export\n\"black_box\" from the \"test\" crate.\n\nThis PR also fixes black_box on the wasm32 target, which now supports inline assembly, and uses volatile loads on the asm.js target.\n\nr? @Amanieu (cc @rust-lang/libs)", "tree": {"sha": "28385771e29b4c966bd93f984b147ec2959d7e0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28385771e29b4c966bd93f984b147ec2959d7e0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "html_url": "https://github.com/rust-lang/rust/commit/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d20e0002725d2b3efff23c97450806b3517ba804", "url": "https://api.github.com/repos/rust-lang/rust/commits/d20e0002725d2b3efff23c97450806b3517ba804", "html_url": "https://github.com/rust-lang/rust/commit/d20e0002725d2b3efff23c97450806b3517ba804"}, {"sha": "0c127e849487323a9f6be09d25c0da0aeb57314d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c127e849487323a9f6be09d25c0da0aeb57314d", "html_url": "https://github.com/rust-lang/rust/commit/0c127e849487323a9f6be09d25c0da0aeb57314d"}], "stats": {"total": 139, "additions": 122, "deletions": 17}, "files": [{"sha": "d1ccc148654ca4659b3cc7119186ba78da001e02", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "patch": "@@ -91,3 +91,39 @@ pub fn spin_loop() {\n         }\n     }\n }\n+\n+/// A function that is opaque to the optimizer, to allow benchmarks to\n+/// pretend to use outputs to assist in avoiding dead-code\n+/// elimination.\n+///\n+/// This function is a no-op, and does not even read from `dummy`.\n+#[inline]\n+#[unstable(feature = \"test\", issue = \"27812\")]\n+pub fn black_box<T>(dummy: T) -> T {\n+    cfg_if! {\n+        if #[cfg(any(\n+            target_arch = \"asmjs\",\n+            all(\n+                target_arch = \"wasm32\",\n+                target_os = \"emscripten\"\n+            )\n+        ))] {\n+            #[inline]\n+            unsafe fn black_box_impl<T>(d: T) -> T {\n+                // these targets do not support inline assembly\n+                let ret = crate::ptr::read_volatile(&d);\n+                crate::mem::forget(d);\n+                ret\n+            }\n+        } else {\n+            #[inline]\n+            unsafe fn black_box_impl<T>(d: T) -> T {\n+                // we need to \"use\" the argument in some way LLVM can't\n+                // introspect.\n+                asm!(\"\" : : \"r\"(&d));\n+                d\n+            }\n+        }\n+    }\n+    unsafe { black_box_impl(dummy) }\n+}"}, {"sha": "ee6b7d3db48a6f999440d47ef39af4a1434bbfc4", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "patch": "@@ -119,3 +119,84 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n+\n+/// A macro for defining `#[cfg]` if-else statements.\n+///\n+/// The macro provided by this crate, `cfg_if`, is similar to the `if/elif` C\n+/// preprocessor macro by allowing definition of a cascade of `#[cfg]` cases,\n+/// emitting the implementation which matches first.\n+///\n+/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #[macro_use]\n+/// extern crate cfg_if;\n+///\n+/// cfg_if! {\n+///     if #[cfg(unix)] {\n+///         fn foo() { /* unix specific functionality */ }\n+///     } else if #[cfg(target_pointer_width = \"32\")] {\n+///         fn foo() { /* non-unix, 32-bit functionality */ }\n+///     } else {\n+///         fn foo() { /* fallback implementation */ }\n+///     }\n+/// }\n+///\n+/// # fn main() {}\n+/// ```\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }\n+        $(\n+            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            ( ($($i_met),*) ($($i_it)*) ),\n+            $( ( ($($e_met),*) ($($e_it)*) ), )*\n+            ( () () ),\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the negated cfgs in a list at the beginning and after the\n+    // semicolon is all the remaining items\n+    (@__items ($($not:meta,)*) ; ) => {};\n+    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+        // Emit all items within one block, applying an approprate #[cfg]. The\n+        // #[cfg] will require all `$m` matchers specified and must also negate\n+        // all previous matchers.\n+        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$m` matchers to the list of `$not` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }\n+    };\n+\n+    // Internal macro to Apply a cfg attribute to a list of items\n+    (@__apply $m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    };\n+}"}, {"sha": "5c91c0ec43b19f812483c65e90aef7108e24f0c0", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "patch": "@@ -27,23 +27,7 @@ pub use libtest::{\n     TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk, stats::Summary\n };\n \n-/// A function that is opaque to the optimizer, to allow benchmarks to\n-/// pretend to use outputs to assist in avoiding dead-code\n-/// elimination.\n-///\n-/// This function is a no-op, and does not even read from `dummy`.\n-#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n-pub fn black_box<T>(dummy: T) -> T {\n-    // we need to \"use\" the argument in some way LLVM can't\n-    // introspect.\n-    unsafe { asm!(\"\" : : \"r\"(&dummy)) }\n-    dummy\n-}\n-#[cfg(any(target_arch = \"asmjs\", target_arch = \"wasm32\"))]\n-#[inline(never)]\n-pub fn black_box<T>(dummy: T) -> T {\n-    dummy\n-}\n+pub use std::hint::black_box;\n \n #[cfg(test)]\n mod tests {"}, {"sha": "b725fbe3d7425736a4ad73f6b70a5e1e0d2dcee6", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "patch": "@@ -42,6 +42,10 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libpanic_abort\",\n     \"src/libpanic_unwind\",\n     \"src/libunwind\",\n+    // black_box implementation is LLVM-version specific and it uses\n+    // target_os to tell targets with different LLVM-versions appart\n+    // (e.g. `wasm32-unknown-emscripten` vs `wasm32-unknown-unknown`):\n+    \"src/libcore/hint.rs\",\n     \"src/libstd/sys/\", // Platform-specific code for std lives here.\n                        // This has the trailing slash so that sys_common is not excepted.\n     \"src/libstd/os\", // Platform-specific public interfaces"}]}