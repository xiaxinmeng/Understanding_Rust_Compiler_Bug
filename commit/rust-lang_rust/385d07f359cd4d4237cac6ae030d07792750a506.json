{"sha": "385d07f359cd4d4237cac6ae030d07792750a506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NWQwN2YzNTljZDRkNDIzN2NhYzZhZTAzMGQwNzc5Mjc1MGE1MDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T18:44:09Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T18:44:09Z"}, "message": "parser: move into generics.rs", "tree": {"sha": "d5b2186abd4778d978997b7b9f5b241a9074ad57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5b2186abd4778d978997b7b9f5b241a9074ad57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/385d07f359cd4d4237cac6ae030d07792750a506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/385d07f359cd4d4237cac6ae030d07792750a506", "html_url": "https://github.com/rust-lang/rust/commit/385d07f359cd4d4237cac6ae030d07792750a506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/385d07f359cd4d4237cac6ae030d07792750a506/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "html_url": "https://github.com/rust-lang/rust/commit/d6d93b3d829116dbcd0c27d746a5ffd46f703ede"}], "stats": {"total": 550, "additions": 278, "deletions": 272}, "files": [{"sha": "afa475a4c8bf0ca08fdbdb3d3023a29f1784d7d7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 270, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=385d07f359cd4d4237cac6ae030d07792750a506", "patch": "@@ -8,10 +8,10 @@ mod ty;\n mod path;\n pub use path::PathStyle;\n mod stmt;\n+mod generics;\n \n use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n-use crate::ast::{FnDecl, Ident, IsAsync, Lifetime, MacDelimiter, Mutability};\n-use crate::ast::{GenericParam, GenericParamKind, WhereClause, TyKind,  GenericBounds};\n+use crate::ast::{FnDecl, Ident, IsAsync, Lifetime, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n@@ -1205,249 +1205,6 @@ impl<'a> Parser<'a> {\n \n     }\n \n-    /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n-    ///\n-    /// ```\n-    /// BOUND = LT_BOUND (e.g., `'a`)\n-    /// ```\n-    fn parse_lt_param_bounds(&mut self) -> GenericBounds {\n-        let mut lifetimes = Vec::new();\n-        while self.check_lifetime() {\n-            lifetimes.push(ast::GenericBound::Outlives(self.expect_lifetime()));\n-\n-            if !self.eat_plus() {\n-                break\n-            }\n-        }\n-        lifetimes\n-    }\n-\n-    /// Matches `typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?`.\n-    fn parse_ty_param(&mut self,\n-                      preceding_attrs: Vec<Attribute>)\n-                      -> PResult<'a, GenericParam> {\n-        let ident = self.parse_ident()?;\n-\n-        // Parse optional colon and param bounds.\n-        let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(Some(self.prev_span))?\n-        } else {\n-            Vec::new()\n-        };\n-\n-        let default = if self.eat(&token::Eq) {\n-            Some(self.parse_ty()?)\n-        } else {\n-            None\n-        };\n-\n-        Ok(GenericParam {\n-            ident,\n-            id: ast::DUMMY_NODE_ID,\n-            attrs: preceding_attrs.into(),\n-            bounds,\n-            kind: GenericParamKind::Type {\n-                default,\n-            }\n-        })\n-    }\n-\n-    fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n-        self.expect_keyword(kw::Const)?;\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-\n-        Ok(GenericParam {\n-            ident,\n-            id: ast::DUMMY_NODE_ID,\n-            attrs: preceding_attrs.into(),\n-            bounds: Vec::new(),\n-            kind: GenericParamKind::Const {\n-                ty,\n-            }\n-        })\n-    }\n-\n-    /// Parses a (possibly empty) list of lifetime and type parameters, possibly including\n-    /// a trailing comma and erroneous trailing attributes.\n-    crate fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n-        let mut params = Vec::new();\n-        loop {\n-            let attrs = self.parse_outer_attributes()?;\n-            if self.check_lifetime() {\n-                let lifetime = self.expect_lifetime();\n-                // Parse lifetime parameter.\n-                let bounds = if self.eat(&token::Colon) {\n-                    self.parse_lt_param_bounds()\n-                } else {\n-                    Vec::new()\n-                };\n-                params.push(ast::GenericParam {\n-                    ident: lifetime.ident,\n-                    id: lifetime.id,\n-                    attrs: attrs.into(),\n-                    bounds,\n-                    kind: ast::GenericParamKind::Lifetime,\n-                });\n-            } else if self.check_keyword(kw::Const) {\n-                // Parse const parameter.\n-                params.push(self.parse_const_param(attrs)?);\n-            } else if self.check_ident() {\n-                // Parse type parameter.\n-                params.push(self.parse_ty_param(attrs)?);\n-            } else {\n-                // Check for trailing attributes and stop parsing.\n-                if !attrs.is_empty() {\n-                    if !params.is_empty() {\n-                        self.struct_span_err(\n-                            attrs[0].span,\n-                            &format!(\"trailing attribute after generic parameter\"),\n-                        )\n-                        .span_label(attrs[0].span, \"attributes must go before parameters\")\n-                        .emit();\n-                    } else {\n-                        self.struct_span_err(\n-                            attrs[0].span,\n-                            &format!(\"attribute without generic parameters\"),\n-                        )\n-                        .span_label(\n-                            attrs[0].span,\n-                            \"attributes are only permitted when preceding parameters\",\n-                        )\n-                        .emit();\n-                    }\n-                }\n-                break\n-            }\n-\n-            if !self.eat(&token::Comma) {\n-                break\n-            }\n-        }\n-        Ok(params)\n-    }\n-\n-    /// Parses a set of optional generic type parameter declarations. Where\n-    /// clauses are not parsed here, and must be added later via\n-    /// `parse_where_clause()`.\n-    ///\n-    /// matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n-    ///                  | ( < lifetimes , typaramseq ( , )? > )\n-    /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n-    fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n-        let span_lo = self.token.span;\n-        let (params, span) = if self.eat_lt() {\n-            let params = self.parse_generic_params()?;\n-            self.expect_gt()?;\n-            (params, span_lo.to(self.prev_span))\n-        } else {\n-            (vec![], self.prev_span.between(self.token.span))\n-        };\n-        Ok(ast::Generics {\n-            params,\n-            where_clause: WhereClause {\n-                predicates: Vec::new(),\n-                span: DUMMY_SP,\n-            },\n-            span,\n-        })\n-    }\n-\n-    /// Parses an optional where-clause and places it in `generics`.\n-    ///\n-    /// ```ignore (only-for-syntax-highlight)\n-    /// where T : Trait<U, V> + 'b, 'a : 'b\n-    /// ```\n-    fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n-        let mut where_clause = WhereClause {\n-            predicates: Vec::new(),\n-            span: self.prev_span.to(self.prev_span),\n-        };\n-\n-        if !self.eat_keyword(kw::Where) {\n-            return Ok(where_clause);\n-        }\n-        let lo = self.prev_span;\n-\n-        // We are considering adding generics to the `where` keyword as an alternative higher-rank\n-        // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n-        // change we parse those generics now, but report an error.\n-        if self.choose_generics_over_qpath() {\n-            let generics = self.parse_generics()?;\n-            self.struct_span_err(\n-                generics.span,\n-                \"generic parameters on `where` clauses are reserved for future use\",\n-            )\n-                .span_label(generics.span, \"currently unsupported\")\n-                .emit();\n-        }\n-\n-        loop {\n-            let lo = self.token.span;\n-            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n-                let lifetime = self.expect_lifetime();\n-                // Bounds starting with a colon are mandatory, but possibly empty.\n-                self.expect(&token::Colon)?;\n-                let bounds = self.parse_lt_param_bounds();\n-                where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n-                    ast::WhereRegionPredicate {\n-                        span: lo.to(self.prev_span),\n-                        lifetime,\n-                        bounds,\n-                    }\n-                ));\n-            } else if self.check_type() {\n-                // Parse optional `for<'a, 'b>`.\n-                // This `for` is parsed greedily and applies to the whole predicate,\n-                // the bounded type can have its own `for` applying only to it.\n-                // Examples:\n-                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n-                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n-                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-                // Parse type with mandatory colon and (possibly empty) bounds,\n-                // or with mandatory equality sign and the second type.\n-                let ty = self.parse_ty()?;\n-                if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                        ast::WhereBoundPredicate {\n-                            span: lo.to(self.prev_span),\n-                            bound_generic_params: lifetime_defs,\n-                            bounded_ty: ty,\n-                            bounds,\n-                        }\n-                    ));\n-                // FIXME: Decide what should be used here, `=` or `==`.\n-                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n-                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n-                    let rhs_ty = self.parse_ty()?;\n-                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n-                        ast::WhereEqPredicate {\n-                            span: lo.to(self.prev_span),\n-                            lhs_ty: ty,\n-                            rhs_ty,\n-                            id: ast::DUMMY_NODE_ID,\n-                        }\n-                    ));\n-                } else {\n-                    return self.unexpected();\n-                }\n-            } else {\n-                break\n-            }\n-\n-            if !self.eat(&token::Comma) {\n-                break\n-            }\n-        }\n-\n-        where_clause.span = lo.to(self.prev_span);\n-        Ok(where_clause)\n-    }\n-\n     fn parse_fn_args(&mut self, named_args: bool, allow_c_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n         let sp = self.token.span;\n@@ -1671,31 +1428,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn choose_generics_over_qpath(&self) -> bool {\n-        // There's an ambiguity between generic parameters and qualified paths in impls.\n-        // If we see `<` it may start both, so we have to inspect some following tokens.\n-        // The following combinations can only start generics,\n-        // but not qualified paths (with one exception):\n-        //     `<` `>` - empty generic parameters\n-        //     `<` `#` - generic parameters with attributes\n-        //     `<` (LIFETIME|IDENT) `>` - single generic parameter\n-        //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n-        //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n-        //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n-        //     `<` const                - generic const parameter\n-        // The only truly ambiguous case is\n-        //     `<` IDENT `>` `::` IDENT ...\n-        // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n-        // because this is what almost always expected in practice, qualified paths in impls\n-        // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n-        self.token == token::Lt &&\n-            (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n-             self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n-                self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n-                                       t == &token::Colon || t == &token::Eq) ||\n-            self.is_keyword_ahead(1, &[kw::Const]))\n-    }\n-\n     fn is_crate_vis(&self) -> bool {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }"}, {"sha": "54f24f8ef2b21716c9643076603883676ff8636d", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=385d07f359cd4d4237cac6ae030d07792750a506", "patch": "@@ -0,0 +1,276 @@\n+use super::{Parser, PResult};\n+\n+use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n+use crate::parse::token;\n+use crate::source_map::DUMMY_SP;\n+use crate::symbol::kw;\n+\n+impl<'a> Parser<'a> {\n+    /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n+    ///\n+    /// ```\n+    /// BOUND = LT_BOUND (e.g., `'a`)\n+    /// ```\n+    fn parse_lt_param_bounds(&mut self) -> GenericBounds {\n+        let mut lifetimes = Vec::new();\n+        while self.check_lifetime() {\n+            lifetimes.push(ast::GenericBound::Outlives(self.expect_lifetime()));\n+\n+            if !self.eat_plus() {\n+                break\n+            }\n+        }\n+        lifetimes\n+    }\n+\n+    /// Matches `typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?`.\n+    fn parse_ty_param(&mut self,\n+                      preceding_attrs: Vec<Attribute>)\n+                      -> PResult<'a, GenericParam> {\n+        let ident = self.parse_ident()?;\n+\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(Some(self.prev_span))?\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+\n+        Ok(GenericParam {\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n+            bounds,\n+            kind: GenericParamKind::Type {\n+                default,\n+            }\n+        })\n+    }\n+\n+    fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+        self.expect_keyword(kw::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+\n+        Ok(GenericParam {\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n+            bounds: Vec::new(),\n+            kind: GenericParamKind::Const {\n+                ty,\n+            }\n+        })\n+    }\n+\n+    /// Parses a (possibly empty) list of lifetime and type parameters, possibly including\n+    /// a trailing comma and erroneous trailing attributes.\n+    crate fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n+        let mut params = Vec::new();\n+        loop {\n+            let attrs = self.parse_outer_attributes()?;\n+            if self.check_lifetime() {\n+                let lifetime = self.expect_lifetime();\n+                // Parse lifetime parameter.\n+                let bounds = if self.eat(&token::Colon) {\n+                    self.parse_lt_param_bounds()\n+                } else {\n+                    Vec::new()\n+                };\n+                params.push(ast::GenericParam {\n+                    ident: lifetime.ident,\n+                    id: lifetime.id,\n+                    attrs: attrs.into(),\n+                    bounds,\n+                    kind: ast::GenericParamKind::Lifetime,\n+                });\n+            } else if self.check_keyword(kw::Const) {\n+                // Parse const parameter.\n+                params.push(self.parse_const_param(attrs)?);\n+            } else if self.check_ident() {\n+                // Parse type parameter.\n+                params.push(self.parse_ty_param(attrs)?);\n+            } else {\n+                // Check for trailing attributes and stop parsing.\n+                if !attrs.is_empty() {\n+                    if !params.is_empty() {\n+                        self.struct_span_err(\n+                            attrs[0].span,\n+                            &format!(\"trailing attribute after generic parameter\"),\n+                        )\n+                        .span_label(attrs[0].span, \"attributes must go before parameters\")\n+                        .emit();\n+                    } else {\n+                        self.struct_span_err(\n+                            attrs[0].span,\n+                            &format!(\"attribute without generic parameters\"),\n+                        )\n+                        .span_label(\n+                            attrs[0].span,\n+                            \"attributes are only permitted when preceding parameters\",\n+                        )\n+                        .emit();\n+                    }\n+                }\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+        Ok(params)\n+    }\n+\n+    /// Parses a set of optional generic type parameter declarations. Where\n+    /// clauses are not parsed here, and must be added later via\n+    /// `parse_where_clause()`.\n+    ///\n+    /// matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n+    ///                  | ( < lifetimes , typaramseq ( , )? > )\n+    /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n+    pub(super) fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n+        let span_lo = self.token.span;\n+        let (params, span) = if self.eat_lt() {\n+            let params = self.parse_generic_params()?;\n+            self.expect_gt()?;\n+            (params, span_lo.to(self.prev_span))\n+        } else {\n+            (vec![], self.prev_span.between(self.token.span))\n+        };\n+        Ok(ast::Generics {\n+            params,\n+            where_clause: WhereClause {\n+                predicates: Vec::new(),\n+                span: DUMMY_SP,\n+            },\n+            span,\n+        })\n+    }\n+\n+    /// Parses an optional where-clause and places it in `generics`.\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// where T : Trait<U, V> + 'b, 'a : 'b\n+    /// ```\n+    pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n+        let mut where_clause = WhereClause {\n+            predicates: Vec::new(),\n+            span: self.prev_span.to(self.prev_span),\n+        };\n+\n+        if !self.eat_keyword(kw::Where) {\n+            return Ok(where_clause);\n+        }\n+        let lo = self.prev_span;\n+\n+        // We are considering adding generics to the `where` keyword as an alternative higher-rank\n+        // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n+        // change we parse those generics now, but report an error.\n+        if self.choose_generics_over_qpath() {\n+            let generics = self.parse_generics()?;\n+            self.struct_span_err(\n+                generics.span,\n+                \"generic parameters on `where` clauses are reserved for future use\",\n+            )\n+                .span_label(generics.span, \"currently unsupported\")\n+                .emit();\n+        }\n+\n+        loop {\n+            let lo = self.token.span;\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n+                let lifetime = self.expect_lifetime();\n+                // Bounds starting with a colon are mandatory, but possibly empty.\n+                self.expect(&token::Colon)?;\n+                let bounds = self.parse_lt_param_bounds();\n+                where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    ast::WhereRegionPredicate {\n+                        span: lo.to(self.prev_span),\n+                        lifetime,\n+                        bounds,\n+                    }\n+                ));\n+            } else if self.check_type() {\n+                // Parse optional `for<'a, 'b>`.\n+                // This `for` is parsed greedily and applies to the whole predicate,\n+                // the bounded type can have its own `for` applying only to it.\n+                // Examples:\n+                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n+                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+                // Parse type with mandatory colon and (possibly empty) bounds,\n+                // or with mandatory equality sign and the second type.\n+                let ty = self.parse_ty()?;\n+                if self.eat(&token::Colon) {\n+                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        ast::WhereBoundPredicate {\n+                            span: lo.to(self.prev_span),\n+                            bound_generic_params: lifetime_defs,\n+                            bounded_ty: ty,\n+                            bounds,\n+                        }\n+                    ));\n+                // FIXME: Decide what should be used here, `=` or `==`.\n+                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n+                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+                    let rhs_ty = self.parse_ty()?;\n+                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n+                        ast::WhereEqPredicate {\n+                            span: lo.to(self.prev_span),\n+                            lhs_ty: ty,\n+                            rhs_ty,\n+                            id: ast::DUMMY_NODE_ID,\n+                        }\n+                    ));\n+                } else {\n+                    return self.unexpected();\n+                }\n+            } else {\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+\n+        where_clause.span = lo.to(self.prev_span);\n+        Ok(where_clause)\n+    }\n+\n+    pub(super) fn choose_generics_over_qpath(&self) -> bool {\n+        // There's an ambiguity between generic parameters and qualified paths in impls.\n+        // If we see `<` it may start both, so we have to inspect some following tokens.\n+        // The following combinations can only start generics,\n+        // but not qualified paths (with one exception):\n+        //     `<` `>` - empty generic parameters\n+        //     `<` `#` - generic parameters with attributes\n+        //     `<` (LIFETIME|IDENT) `>` - single generic parameter\n+        //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n+        //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n+        //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n+        //     `<` const                - generic const parameter\n+        // The only truly ambiguous case is\n+        //     `<` IDENT `>` `::` IDENT ...\n+        // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n+        // because this is what almost always expected in practice, qualified paths in impls\n+        // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n+        self.token == token::Lt &&\n+            (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n+             self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n+                self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n+                                       t == &token::Colon || t == &token::Eq) ||\n+            self.is_keyword_ahead(1, &[kw::Const]))\n+    }\n+}"}, {"sha": "e01ce9a48c0dd887041541c6ce6e34a07a71dc9c", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d07f359cd4d4237cac6ae030d07792750a506/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=385d07f359cd4d4237cac6ae030d07792750a506", "patch": "@@ -430,8 +430,6 @@ impl<'a> Parser<'a> {\n         return Ok(bounds);\n     }\n \n-    // TODO remove super below.\n-\n     pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n         if self.eat_keyword(kw::For) {\n             self.expect_lt()?;"}]}