{"sha": "6c0f502fe6bb54b285d66850ca8171e0c98091b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMGY1MDJmZTZiYjU0YjI4NWQ2Njg1MGNhODE3MWUwYzk4MDkxYjA=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-22T04:40:14Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-07-04T21:36:07Z"}, "message": "Implement Clone, Eq and Hash for the heap and stack\n\nI use a pattern binding in each custom impl, so that adding fields to\n`Memory` or `Frame` will cause a compiler error instead of causing e.g.\n`PartialEq` to become invalid. This may be too cute.\n\nThis adds several requirements to `Machine::MemoryData`. These can be\nremoved if we don't want this associated type to be part of the equality\nof `Memory`.", "tree": {"sha": "df3bb64d941742ead834b5f05954f2ee8a7e2885", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df3bb64d941742ead834b5f05954f2ee8a7e2885"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c0f502fe6bb54b285d66850ca8171e0c98091b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0f502fe6bb54b285d66850ca8171e0c98091b0", "html_url": "https://github.com/rust-lang/rust/commit/6c0f502fe6bb54b285d66850ca8171e0c98091b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c0f502fe6bb54b285d66850ca8171e0c98091b0/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db025c14eccb435ffb6bc5d4f834b4551589447b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db025c14eccb435ffb6bc5d4f834b4551589447b", "html_url": "https://github.com/rust-lang/rust/commit/db025c14eccb435ffb6bc5d4f834b4551589447b"}], "stats": {"total": 178, "additions": 170, "deletions": 8}, "files": [{"sha": "50987af409f4063638b8b319f63ec0e537eab9d8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6c0f502fe6bb54b285d66850ca8171e0c98091b0", "patch": "@@ -1,5 +1,6 @@\n use std::fmt::Write;\n-use std::mem;\n+use std::hash::{Hash, Hasher};\n+use std::{mem, ptr};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n@@ -44,15 +45,52 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub(crate) terminators_remaining: usize,\n }\n \n-struct EvalState<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+pub(crate) struct EvalState<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The virtual memory system.\n     memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n+impl<'a, 'mir, 'tcx, M> Clone for EvalState<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn clone(&self) -> Self {\n+        EvalState {\n+            memory: self.memory.clone(),\n+            stack: self.stack.clone(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Eq for EvalState<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{}\n+\n+impl<'a, 'mir, 'tcx, M> PartialEq for EvalState<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.memory == other.memory\n+            && self.stack == other.stack\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Hash for EvalState<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.memory.hash(state);\n+        self.stack.hash(state);\n+    }\n+}\n /// A stack frame.\n+#[derive(Clone)]\n pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n@@ -94,6 +132,52 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n+impl<'mir, 'tcx: 'mir> Eq for Frame<'mir, 'tcx> {}\n+\n+impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        let Frame {\n+            mir,\n+            instance: _,\n+            span: _,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        ptr::eq(mir, &other.mir)\n+            && *return_to_block == other.return_to_block // TODO: Are these two necessary?\n+            && *return_place == other.return_place\n+            && *locals == other.locals\n+            && *block == other.block\n+            && *stmt == other.stmt\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Frame {\n+            mir,\n+            instance: _,\n+            span: _,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        (mir as *const _ as usize).hash(state);\n+        return_to_block.hash(state);\n+        return_place.hash(state);\n+        locals.hash(state);\n+        block.hash(state);\n+        stmt.hash(state);\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure it"}, {"sha": "f6491d7f1a46903507b236ed17166a976bb3464f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=6c0f502fe6bb54b285d66850ca8171e0c98091b0", "patch": "@@ -2,6 +2,8 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n+use std::hash::Hash;\n+\n use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n@@ -15,7 +17,7 @@ use syntax::ast::Mutability;\n /// and some use case dependent behaviour can instead be applied\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData;\n+    type MemoryData: Clone + Eq + Hash;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;"}, {"sha": "98ab361c239ee7b5d9273b86fbac6feb8c9b5019", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=6c0f502fe6bb54b285d66850ca8171e0c98091b0", "patch": "@@ -1,4 +1,5 @@\n use std::collections::VecDeque;\n+use std::hash::{Hash, Hasher};\n use std::ptr;\n \n use rustc::hir::def_id::DefId;\n@@ -9,7 +10,7 @@ use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n@@ -19,7 +20,7 @@ use super::{EvalContext, Machine};\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Debug, PartialEq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n@@ -47,6 +48,81 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n+impl<'a, 'mir, 'tcx, M> Clone for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn clone(&self) -> Self {\n+        Memory {\n+            data: self.data.clone(),\n+            alloc_kind: self.alloc_kind.clone(),\n+            alloc_map: self.alloc_map.clone(),\n+            cur_frame: self.cur_frame.clone(),\n+            tcx: self.tcx.clone(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{}\n+\n+impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        let Memory {\n+            data,\n+            alloc_kind,\n+            alloc_map,\n+            cur_frame,\n+            tcx,\n+        } = self;\n+\n+        *data == other.data\n+            && *alloc_kind == other.alloc_kind\n+            && *alloc_map == other.alloc_map\n+            && *cur_frame == other.cur_frame\n+            && ptr::eq(tcx, &other.tcx)\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Memory {\n+            data,\n+            alloc_kind: _,\n+            alloc_map: _,\n+            cur_frame,\n+            tcx,\n+        } = self;\n+\n+        data.hash(state);\n+        cur_frame.hash(state);\n+        (tcx as *const _ as usize).hash(state);\n+\n+        // We ignore some fields which don't change between evaluation steps.\n+\n+        // Since HashMaps which contain the same items may have different\n+        // iteration orders, we use a commutative operation (in this case\n+        // addition, but XOR would also work), to combine the hash of each\n+        // `Allocation`.\n+        self.allocations()\n+            .map(|allocs| {\n+                let mut h = FxHasher::default();\n+                allocs.hash(&mut h);\n+                h.finish()\n+            })\n+            .fold(0u64, |hash, x| hash.wrapping_add(x))\n+            .hash(state);\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n@@ -866,7 +942,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         for i in 0..size.bytes() {\n             let defined = undef_mask.get(src.offset + Size::from_bytes(i));\n-            \n+\n             for j in 0..repeat {\n                 dest_allocation.undef_mask.set(\n                     dest.offset + Size::from_bytes(i + (size.bytes() * j)),"}, {"sha": "bde2e5945f5d47c0ba1fccee74d63b7bc62bd6f4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0f502fe6bb54b285d66850ca8171e0c98091b0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=6c0f502fe6bb54b285d66850ca8171e0c98091b0", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr {\n@@ -24,7 +24,7 @@ pub enum Place {\n     Local { frame: usize, local: mir::Local },\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum PlaceExtra {\n     None,\n     Length(u64),"}]}