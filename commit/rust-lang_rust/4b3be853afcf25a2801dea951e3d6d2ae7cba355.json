{"sha": "4b3be853afcf25a2801dea951e3d6d2ae7cba355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiM2JlODUzYWZjZjI1YTI4MDFkZWE5NTFlM2Q2ZDJhZTdjYmEzNTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T23:14:55Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T23:14:55Z"}, "message": "Copyedit tasks tutorial", "tree": {"sha": "6eaa2011edec166629e0d6026d287d11b7f3d1e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eaa2011edec166629e0d6026d287d11b7f3d1e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b3be853afcf25a2801dea951e3d6d2ae7cba355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3be853afcf25a2801dea951e3d6d2ae7cba355", "html_url": "https://github.com/rust-lang/rust/commit/4b3be853afcf25a2801dea951e3d6d2ae7cba355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b3be853afcf25a2801dea951e3d6d2ae7cba355/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28cf16a30409463cbac3b7bb660be90dcecab06a", "url": "https://api.github.com/repos/rust-lang/rust/commits/28cf16a30409463cbac3b7bb660be90dcecab06a", "html_url": "https://github.com/rust-lang/rust/commit/28cf16a30409463cbac3b7bb660be90dcecab06a"}], "stats": {"total": 243, "additions": 124, "deletions": 119}, "files": [{"sha": "8a0cda3e820735d0f37dd7535bb383bde513381c", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 124, "deletions": 119, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/4b3be853afcf25a2801dea951e3d6d2ae7cba355/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b3be853afcf25a2801dea951e3d6d2ae7cba355/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=4b3be853afcf25a2801dea951e3d6d2ae7cba355", "patch": "@@ -2,38 +2,37 @@\n \n # Introduction\n \n-The Rust language is designed from the ground up to support pervasive\n+The designers of Rust designed the language from the ground up to support pervasive\n and safe concurrency through lightweight, memory-isolated tasks and\n message passing.\n \n-Rust tasks are not the same as traditional threads - they are what are\n-often referred to as _green threads_, cooperatively scheduled by the\n-Rust runtime onto a small number of operating system threads.  Being\n-significantly cheaper to create than traditional threads, Rust can\n-create hundreds of thousands of concurrent tasks on a typical 32-bit\n-system.\n-\n-Tasks provide failure isolation and recovery. When an exception occurs\n-in rust code (either by calling `fail` explicitly or by otherwise performing\n-an invalid operation) the entire task is destroyed - there is no way\n-to `catch` an exception as in other languages. Instead tasks may monitor\n-each other to detect when failure has occurred.\n-\n-Rust tasks have dynamically sized stacks. When a task is first created\n-it starts off with a small amount of stack (currently in the low\n-thousands of bytes, depending on platform) and more stack is acquired as\n-needed. A Rust task will never run off the end of the stack as is\n-possible in many other languages, but they do have a stack budget, and\n-if a Rust task exceeds its stack budget then it will fail safely.\n-\n-Tasks make use of Rust's type system to provide strong memory safety\n-guarantees, disallowing shared mutable state. Communication between\n-tasks is facilitated by the transfer of _owned_ data through the\n-global _exchange heap_.\n-\n-This tutorial will explain the basics of tasks and communication in Rust,\n-explore some typical patterns in concurrent Rust code, and finally\n-discuss some of the more exotic synchronization types in the standard\n+Rust tasks are not the same as traditional threads: rather, they are more like\n+_green threads_. The Rust runtime system schedules tasks cooperatively onto a\n+small number of operating system threads. Because tasks are significantly\n+cheaper to create than traditional threads, Rust can create hundreds of\n+thousands of concurrent tasks on a typical 32-bit system.\n+\n+Tasks provide failure isolation and recovery. When an exception occurs in Rust\n+code (as a result of an explicit call to `fail`, an assertion failure, or\n+another invalid operation), the runtime system destroys the entire\n+task. Unlike in languages such as Java and C++, there is no way to `catch` an\n+exception. Instead, tasks may monitor each other for failure.\n+\n+Rust tasks have dynamically sized stacks. A task begins its life with a small\n+amount of stack space (currently in the low thousands of bytes, depending on\n+platform), and acquires more stack as needed. Unlike in languages such as C, a\n+Rust task cannot run off the end of the stack. However, tasks do have a stack\n+budget. If a Rust task exceeds its stack budget, then it will fail safely:\n+with a checked exception.\n+\n+Tasks use Rust's type system to provide strong memory safety guarantees. In\n+particular, the type system guarantees that tasks cannot share mutable state\n+with each other. Tasks communicate with each other by transferring _owned_\n+data through the global _exchange heap_.\n+\n+This tutorial explains the basics of tasks and communication in Rust,\n+explores some typical patterns in concurrent Rust code, and finally\n+discusses some of the more unusual synchronization types in the standard\n library.\n \n > ***Warning:*** This tutorial is incomplete\n@@ -45,23 +44,23 @@ and efficient tasks, all of the task functionality itself is implemented\n in the core and standard libraries, which are still under development\n and do not always present a consistent interface.\n \n-In particular, there are currently two independent modules that provide\n-a message passing interface to Rust code: `core::comm` and `core::pipes`.\n-`core::comm` is an older, less efficient system that is being phased out\n-in favor of `pipes`. At some point the existing `core::comm` API will\n-be removed and the user-facing portions of `core::pipes` will be moved\n-to `core::comm`. In this tutorial we will discuss `pipes` and ignore\n-the `comm` API.\n+In particular, there are currently two independent modules that provide a\n+message passing interface to Rust code: `core::comm` and `core::pipes`.\n+`core::comm` is an older, less efficient system that is being phased out in\n+favor of `pipes`. At some point, we will remove the existing `core::comm` API\n+and move the user-facing portions of `core::pipes` to `core::comm`. In this\n+tutorial, we discuss `pipes` and ignore the `comm` API.\n \n For your reference, these are the standard modules involved in Rust\n-concurrency at the moment.\n+concurrency at this writing.\n \n * [`core::task`] - All code relating to tasks and task scheduling\n * [`core::comm`] - The deprecated message passing API\n * [`core::pipes`] - The new message passing infrastructure and API\n * [`std::comm`] - Higher level messaging types based on `core::pipes`\n * [`std::sync`] - More exotic synchronization tools, including locks\n-* [`std::arc`] - The ARC type, for safely sharing immutable data\n+* [`std::arc`] - The ARC (atomic reference counted) type, for safely sharing\n+  immutable data\n * [`std::par`] - Some basic tools for implementing parallel algorithms\n \n [`core::task`]: core/task.html\n@@ -74,11 +73,11 @@ concurrency at the moment.\n \n # Basics\n \n-The programming interface for creating and managing tasks is contained\n-in the `task` module of the `core` library, making it available to all\n-Rust code by default. At it's simplest, creating a task is a matter of\n-calling the `spawn` function, passing a closure to run in the new\n-task.\n+The programming interface for creating and managing tasks lives\n+in the `task` module of the `core` library, and is thus available to all\n+Rust code by default. At its simplest, creating a task is a matter of\n+calling the `spawn` function with a closure argument. `spawn` executes the\n+closure in the new task.\n \n ~~~~\n # use io::println;\n@@ -97,17 +96,17 @@ do spawn {\n }\n ~~~~\n \n-In Rust, there is nothing special about creating tasks - the language\n-itself doesn't know what a 'task' is. Instead, Rust provides in the\n-type system all the tools necessary to implement safe concurrency,\n-_owned types_ in particular, and leaves the dirty work up to the\n-core library.\n+In Rust, there is nothing special about creating tasks: a task is not a\n+concept that appears in the language semantics. Instead, Rust's type system\n+provides all the tools necessary to implement safe concurrency: particularly,\n+_owned types_. The language leaves the implementation details to the core\n+library.\n \n The `spawn` function has a very simple type signature: `fn spawn(f:\n ~fn())`. Because it accepts only owned closures, and owned closures\n-contained only owned data, `spawn` can safely move the entire closure\n+contain only owned data, `spawn` can safely move the entire closure\n and all its associated state into an entirely different task for\n-execution. Like any closure, the function passed to spawn may capture\n+execution. Like any closure, the function passed to `spawn` may capture\n an environment that it carries across tasks.\n \n ~~~\n@@ -123,8 +122,8 @@ do spawn {\n }\n ~~~\n \n-By default tasks will be multiplexed across the available cores, running\n-in parallel, thus on a multicore machine, running the following code\n+By default, the scheduler multiplexes tasks across the available cores, running\n+in parallel. Thus, on a multicore machine, running the following code\n should interleave the output in vaguely random order.\n \n ~~~\n@@ -145,17 +144,16 @@ communicate with it. Recall that Rust does not have shared mutable\n state, so one task may not manipulate variables owned by another task.\n Instead we use *pipes*.\n \n-Pipes are simply a pair of endpoints, with one for sending messages\n-and another for receiving messages. Pipes are low-level communication\n-building-blocks and so come in a variety of forms, appropriate for\n-different use cases, but there are just a few varieties that are most\n-commonly used, which we will cover presently.\n+A pipe is simply a pair of endpoints: one for sending messages and another for\n+receiving messages. Pipes are low-level communication building-blocks and so\n+come in a variety of forms, each one appropriate for a different use case. In\n+what follows, we cover the most commonly used varieties.\n \n The simplest way to create a pipe is to use the `pipes::stream`\n-function to create a `(Chan, Port)` pair. In Rust parlance a 'channel'\n-is a sending endpoint of a pipe, and a 'port' is the receiving\n-endpoint. Consider the following example of performing two calculations\n-concurrently.\n+function to create a `(Chan, Port)` pair. In Rust parlance, a *channel*\n+is a sending endpoint of a pipe, and a *port* is the receiving\n+endpoint. Consider the following example of calculating two results\n+concurrently:\n \n ~~~~\n use task::spawn;\n@@ -174,17 +172,17 @@ let result = port.recv();\n # fn some_other_expensive_computation() {}\n ~~~~\n \n-Let's examine this example in detail. The `let` statement first creates a\n-stream for sending and receiving integers (recall that `let` can be\n-used for destructuring patterns, in this case separating a tuple into\n-its component parts).\n+Let's examine this example in detail. First, the `let` statement creates a\n+stream for sending and receiving integers (the left-hand side of the `let`,\n+`(chan, port)`, is an example of a *destructuring let*: the pattern separates\n+a tuple into its component parts).\n \n ~~~~\n # use pipes::{stream, Chan, Port};\n let (chan, port): (Chan<int>, Port<int>) = stream();\n ~~~~\n \n-The channel will be used by the child task to send data to the parent task,\n+The child task will use the channel to send data to the parent task,\n which will wait to receive the data on the port. The next statement\n spawns the child task.\n \n@@ -200,14 +198,14 @@ do spawn {\n }\n ~~~~\n \n-Notice that `chan` was transferred to the child task implicitly by\n-capturing it in the task closure. Both `Chan` and `Port` are sendable\n-types and may be captured into tasks or otherwise transferred between\n-them. In the example, the child task performs an expensive computation\n-then sends the result over the captured channel.\n+Notice that the creation of the task closure transfers `chan` to the child\n+task implicitly: the closure captures `chan` in its environment. Both `Chan`\n+and `Port` are sendable types and may be captured into tasks or otherwise\n+transferred between them. In the example, the child task runs an expensive\n+computation, then sends the result over the captured channel.\n \n-Finally, the parent continues by performing some other expensive\n-computation and then waiting for the child's result to arrive on the\n+Finally, the parent continues with some other expensive\n+computation, then waits for the child's result to arrive on the\n port:\n \n ~~~~\n@@ -219,12 +217,11 @@ some_other_expensive_computation();\n let result = port.recv();\n ~~~~\n \n-The `Port` and `Chan` pair created by `stream` enable efficient\n-communication between a single sender and a single receiver, but\n-multiple senders cannot use a single `Chan`, nor can multiple\n-receivers use a single `Port`.  What if our example needed to perform\n-multiple computations across a number of tasks? The following cannot\n-be written:\n+The `Port` and `Chan` pair created by `stream` enables efficient communication\n+between a single sender and a single receiver, but multiple senders cannot use\n+a single `Chan`, and multiple receivers cannot use a single `Port`.  What if our\n+example needed to computer multiple results across a number of tasks? The\n+following program is ill-typed:\n \n ~~~ {.xfail-test}\n # use task::{spawn};\n@@ -265,18 +262,18 @@ let result = port.recv() + port.recv() + port.recv();\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n-Here we transfer ownership of the channel into a new `SharedChan`\n-value.  Like `Chan`, `SharedChan` is a non-copyable, owned type\n-(sometimes also referred to as an 'affine' or 'linear' type). Unlike\n-`Chan` though, `SharedChan` may be duplicated with the `clone()`\n-method.  A cloned `SharedChan` produces a new handle to the same\n-channel, allowing multiple tasks to send data to a single port.\n-Between `spawn`, `stream` and `SharedChan` we have enough tools\n-to implement many useful concurrency patterns.\n+Here we transfer ownership of the channel into a new `SharedChan` value.  Like\n+`Chan`, `SharedChan` is a non-copyable, owned type (sometimes also referred to\n+as an *affine* or *linear* type). Unlike with `Chan`, though, the programmer\n+may duplicate a `SharedChan`, with the `clone()` method.  A cloned\n+`SharedChan` produces a new handle to the same channel, allowing multiple\n+tasks to send data to a single port.  Between `spawn`, `stream` and\n+`SharedChan`, we have enough tools to implement many useful concurrency\n+patterns.\n \n Note that the above `SharedChan` example is somewhat contrived since\n you could also simply use three `stream` pairs, but it serves to\n-illustrate the point. For reference, written with multiple streams it\n+illustrate the point. For reference, written with multiple streams, it\n might look like the example below.\n \n ~~~\n@@ -299,15 +296,17 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n \n # Handling task failure\n \n-Rust has a built-in mechanism for raising exceptions, written `fail`\n-(or `fail ~\"reason\"`, or sometimes `assert expr`), and it causes the\n-task to unwind its stack, running destructors and freeing memory along\n-the way, and then exit itself. Unlike C++, exceptions in Rust are\n-unrecoverable within a single task - once a task fails there is no way\n-to \"catch\" the exception.\n+Rust has a built-in mechanism for raising exceptions. The `fail` construct\n+(which can also be written with an error string as an argument: `fail\n+~reason`) and the `assert` construct (which effectively calls `fail` if a\n+boolean expression is false) are both ways to raise exceptions. When a task\n+raises an exception the task unwinds its stack---running destructors and\n+freeing memory along the way---and then exits. Unlike exceptions in C++,\n+exceptions in Rust are unrecoverable within a single task: once a task fails,\n+there is no way to \"catch\" the exception.\n \n-All tasks are, by default, _linked_ to each other, meaning their fate\n-is intertwined, and if one fails so do all of them.\n+All tasks are, by default, _linked_ to each other. That means that the fates\n+of all tasks are intertwined: if one fails, so do all the others.\n \n ~~~\n # use task::spawn;\n@@ -321,11 +320,15 @@ do_some_work();\n # };\n ~~~\n \n-While it isn't possible for a task to recover from failure,\n-tasks may be notified when _other_ tasks fail. The simplest way\n-of handling task failure is with the `try` function, which is\n-similar to spawn, but immediately blocks waiting for the child\n-task to finish.\n+While it isn't possible for a task to recover from failure, tasks may notify\n+each other of failure. The simplest way of handling task failure is with the\n+`try` function, which is similar to `spawn`, but immediately blocks waiting\n+for the child task to finish. `try` returns a value of type `Result<int,\n+()>`. `Result` is an `enum` type with two variants: `Ok` and `Err`. In this\n+case, because the type arguments to `Result` are `int` and `()`, callers can\n+pattern-match on a result to check whether it's an `Ok` result with an `int`\n+field (representing a successful result) or an `Err` result (representing\n+termination with an error).\n \n ~~~\n # fn some_condition() -> bool { false }\n@@ -349,8 +352,8 @@ an `Error` result.\n [`Result`]: core/result.html\n \n > ***Note:*** A failed task does not currently produce a useful error\n-> value (all error results from `try` are equal to `Err(())`). In the\n-> future it may be possible for tasks to intercept the value passed to\n+> value (`try` always returns `Err(())`). In the\n+> future, it may be possible for tasks to intercept the value passed to\n > `fail`.\n \n TODO: Need discussion of `future_result` in order to make failure\n@@ -362,11 +365,11 @@ it trips, indicates an unrecoverable logic error); in other cases you\n might want to contain the failure at a certain boundary (perhaps a\n small piece of input from the outside world, which you happen to be\n processing in parallel, is malformed and its processing task can't\n-proceed). Hence the need for different _linked failure modes_.\n+proceed). Hence, you will need different _linked failure modes_.\n \n ## Failure modes\n \n-By default, task failure is _bidirectionally linked_, which means if\n+By default, task failure is _bidirectionally linked_, which means that if\n either task dies, it kills the other one.\n \n ~~~\n@@ -382,8 +385,8 @@ sleep_forever();  // Will get woken up by force, then fail\n # };\n ~~~\n \n-If you want parent tasks to kill their children, but not for a child\n-task's failure to kill the parent, you can call\n+If you want parent tasks to be able to kill their children, but do not want a\n+parent to die automatically if one of its child task dies, you can call\n `task::spawn_supervised` for _unidirectionally linked_ failure. The\n function `task::try`, which we saw previously, uses `spawn_supervised`\n internally, with additional logic to wait for the child task to finish\n@@ -411,7 +414,7 @@ do try {  // Unidirectionally linked\n \n Supervised failure is useful in any situation where one task manages\n multiple fallible child tasks, and the parent task can recover\n-if any child files. On the other hand, if the _parent_ (supervisor) fails\n+if any child fails. On the other hand, if the _parent_ (supervisor) fails,\n then there is nothing the children can do to recover, so they should\n also fail.\n \n@@ -456,11 +459,11 @@ fail;\n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n function `std::comm::DuplexStream()` supports this pattern.  We'll\n-look briefly at how it is used.\n+look briefly at how to use it.\n \n To see how `spawn_conversation()` works, we will create a child task\n-that receives `uint` messages, converts them to a string, and sends\n-the string in response.  The child terminates when `0` is received.\n+that repeatedly receives a `uint` message, converts it to a string, and sends\n+the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~~\n@@ -470,8 +473,8 @@ fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(uint::to_str(value, 10u));\n-        if value == 0u { break; }\n+        channel.send(uint::to_str(value, 10));\n+        if value == 0 { break; }\n     }\n }\n ~~~~\n@@ -481,7 +484,7 @@ receiving. The `stringifier` function takes a `DuplexStream` that can\n send strings (the first type parameter) and receive `uint` messages\n (the second type parameter). The body itself simply loops, reading\n from the channel and then sending its response back.  The actual\n-response itself is simply the strified version of the received value,\n+response itself is simply the stringified version of the received value,\n `uint::to_str(value)`.\n \n Here is the code for the parent task:\n@@ -506,18 +509,20 @@ do spawn || {\n     stringifier(&to_child);\n };\n \n-from_child.send(22u);\n+from_child.send(22);\n assert from_child.recv() == ~\"22\";\n \n-from_child.send(23u);\n-from_child.send(0u);\n+from_child.send(23);\n+from_child.send(0);\n \n assert from_child.recv() == ~\"23\";\n assert from_child.recv() == ~\"0\";\n \n # }\n ~~~~\n \n-The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n-and child can send and receive data to and from the other.\n+The parent task first calls `DuplexStream` to create a pair of bidirectional\n+endpoints. It then uses `task::spawn` to create the child task, which captures\n+one end of the communication channel.  As a result, both parent and child can\n+send and receive data to and from the other.\n "}]}