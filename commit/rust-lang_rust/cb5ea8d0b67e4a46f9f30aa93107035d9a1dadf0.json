{"sha": "cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "node_id": "C_kwDOAAsO6NoAKGNiNWVhOGQwYjY3ZTRhNDZmOWYzMGFhOTMxMDcwMzVkOWExZGFkZjA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-08T17:17:37Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-13T17:47:50Z"}, "message": "Emit an error instead of reconstructing token stream.", "tree": {"sha": "87557d065eb35fb481d22976c60606ce6d1b98e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87557d065eb35fb481d22976c60606ce6d1b98e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "html_url": "https://github.com/rust-lang/rust/commit/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8823634db8c4ee65b4a3d47ccb1d81891e33d0de", "url": "https://api.github.com/repos/rust-lang/rust/commits/8823634db8c4ee65b4a3d47ccb1d81891e33d0de", "html_url": "https://github.com/rust-lang/rust/commit/8823634db8c4ee65b4a3d47ccb1d81891e33d0de"}], "stats": {"total": 117, "additions": 58, "deletions": 59}, "files": [{"sha": "009f3c783d4c8d946cdd73f1fc011bce86a93611", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::visit::Visitor;\n use rustc_ast::NodeId;\n use rustc_ast::{mut_visit, visit};\n use rustc_ast::{Attribute, HasAttrs, HasTokens};\n+use rustc_errors::PResult;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n use rustc_expand::configure;\n@@ -144,33 +145,34 @@ impl CfgEval<'_, '_> {\n         // the location of `#[cfg]` and `#[cfg_attr]` in the token stream. The tokenization\n         // process is lossless, so this process is invisible to proc-macros.\n \n-        let parse_annotatable_with: fn(&mut Parser<'_>) -> _ = match annotatable {\n-            Annotatable::Item(_) => {\n-                |parser| Annotatable::Item(parser.parse_item(ForceCollect::Yes).unwrap().unwrap())\n-            }\n-            Annotatable::TraitItem(_) => |parser| {\n-                Annotatable::TraitItem(\n-                    parser.parse_trait_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ImplItem(_) => |parser| {\n-                Annotatable::ImplItem(\n-                    parser.parse_impl_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::ForeignItem(_) => |parser| {\n-                Annotatable::ForeignItem(\n-                    parser.parse_foreign_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n-                )\n-            },\n-            Annotatable::Stmt(_) => |parser| {\n-                Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes).unwrap().unwrap()))\n-            },\n-            Annotatable::Expr(_) => {\n-                |parser| Annotatable::Expr(parser.parse_expr_force_collect().unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n+        let parse_annotatable_with: for<'a> fn(&mut Parser<'a>) -> PResult<'a, _> =\n+            match annotatable {\n+                Annotatable::Item(_) => {\n+                    |parser| Ok(Annotatable::Item(parser.parse_item(ForceCollect::Yes)?.unwrap()))\n+                }\n+                Annotatable::TraitItem(_) => |parser| {\n+                    Ok(Annotatable::TraitItem(\n+                        parser.parse_trait_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ImplItem(_) => |parser| {\n+                    Ok(Annotatable::ImplItem(\n+                        parser.parse_impl_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::ForeignItem(_) => |parser| {\n+                    Ok(Annotatable::ForeignItem(\n+                        parser.parse_foreign_item(ForceCollect::Yes)?.unwrap().unwrap(),\n+                    ))\n+                },\n+                Annotatable::Stmt(_) => |parser| {\n+                    Ok(Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes)?.unwrap())))\n+                },\n+                Annotatable::Expr(_) => {\n+                    |parser| Ok(Annotatable::Expr(parser.parse_expr_force_collect()?))\n+                }\n+                _ => unreachable!(),\n+            };\n \n         // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n         // to `None`-delimited groups containing the corresponding tokens. This\n@@ -193,7 +195,13 @@ impl CfgEval<'_, '_> {\n         let mut parser =\n             rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n         parser.capture_cfg = true;\n-        annotatable = parse_annotatable_with(&mut parser);\n+        match parse_annotatable_with(&mut parser) {\n+            Ok(a) => annotatable = a,\n+            Err(mut err) => {\n+                err.emit();\n+                return Some(annotatable);\n+            }\n+        }\n \n         // Now that we have our re-parsed `AttrTokenStream`, recursively configuring\n         // our attribute target will correctly the tokens as well."}, {"sha": "86c386b94c8349a08b2ba100f47e6f1e5bbff92b", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "patch": "@@ -442,38 +442,22 @@ fn make_token_stream(\n         }\n         token_and_spacing = iter.next();\n     }\n-    while let Some(FrameData { open_delim_sp, mut inner }) = stack.pop() {\n-        // A former macro expansion could give us malformed tokens.\n-        // In that case, manually close all open delimitors so downstream users\n-        // don't ICE on them.\n-        if let Some((delim, open_sp)) = open_delim_sp {\n-            let dspan = DelimSpan::from_pair(open_sp, rustc_span::DUMMY_SP);\n-            let stream = AttrTokenStream::new(inner);\n-            let delimited = AttrTokenTree::Delimited(dspan, delim, stream);\n-            stack\n-                .last_mut()\n-                .unwrap_or_else(|| panic!(\"Bottom token frame is missing for recovered token\"))\n+    let mut final_buf = stack.pop().expect(\"Missing final buf!\");\n+    if break_last_token {\n+        let last_token = final_buf.inner.pop().unwrap();\n+        if let AttrTokenTree::Token(last_token, spacing) = last_token {\n+            let unglued_first = last_token.kind.break_two_token_op().unwrap().0;\n+\n+            // An 'unglued' token is always two ASCII characters\n+            let mut first_span = last_token.span.shrink_to_lo();\n+            first_span = first_span.with_hi(first_span.lo() + rustc_span::BytePos(1));\n+\n+            final_buf\n                 .inner\n-                .push(delimited);\n+                .push(AttrTokenTree::Token(Token::new(unglued_first, first_span), spacing));\n         } else {\n-            if break_last_token {\n-                let last_token = inner.pop().unwrap();\n-                if let AttrTokenTree::Token(last_token, spacing) = last_token {\n-                    let unglued_first = last_token.kind.break_two_token_op().unwrap().0;\n-\n-                    // An 'unglued' token is always two ASCII characters\n-                    let mut first_span = last_token.span.shrink_to_lo();\n-                    first_span = first_span.with_hi(first_span.lo() + rustc_span::BytePos(1));\n-\n-                    inner\n-                        .push(AttrTokenTree::Token(Token::new(unglued_first, first_span), spacing));\n-                } else {\n-                    panic!(\"Unexpected last token {:?}\", last_token)\n-                }\n-            }\n-            assert!(stack.is_empty(), \"Stack should be empty: stack={:?}\", stack);\n-            return AttrTokenStream::new(inner);\n+            panic!(\"Unexpected last token {:?}\", last_token)\n         }\n     }\n-    panic!(\"Missing final buf!\")\n+    AttrTokenStream::new(final_buf.inner)\n }"}, {"sha": "ae6de3c5046cde67c20f266a3fbfbf52acc1ff2c", "filename": "src/test/ui/macros/syntax-error-recovery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.rs?ref=cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "patch": "@@ -13,5 +13,6 @@ macro_rules! values {\n //~| ERROR macro expansion ignores token `(String)` and any following\n \n values!(STRING(1) as (String) => cfg(test),);\n+//~^ ERROR expected one of `!` or `::`, found `<eof>`\n \n fn main() {}"}, {"sha": "c153b3b910bbe8dd932341003200db2ca141c731", "filename": "src/test/ui/macros/syntax-error-recovery.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr?ref=cb5ea8d0b67e4a46f9f30aa93107035d9a1dadf0", "patch": "@@ -20,5 +20,11 @@ LL | values!(STRING(1) as (String) => cfg(test),);\n    |\n    = note: the usage of `values!` is likely invalid in item context\n \n-error: aborting due to 2 previous errors\n+error: expected one of `!` or `::`, found `<eof>`\n+  --> $DIR/syntax-error-recovery.rs:15:9\n+   |\n+LL | values!(STRING(1) as (String) => cfg(test),);\n+   |         ^^^^^^ expected one of `!` or `::`\n+\n+error: aborting due to 3 previous errors\n "}]}