{"sha": "c76e2d1e59d466c725a02de7fe43df61fd7eb56f", "node_id": "C_kwDOAAsO6NoAKGM3NmUyZDFlNTlkNDY2YzcyNWEwMmRlN2ZlNDNkZjYxZmQ3ZWI1NmY", "commit": {"author": {"name": "dswij", "email": "dswijj@gmail.com", "date": "2021-12-22T15:18:24Z"}, "committer": {"name": "Dharma Saputra Wijaya", "email": "dswijj@gmail.com", "date": "2021-12-25T13:55:15Z"}, "message": "Add str_util helpers to split camelcase strings", "tree": {"sha": "f59a6db1aacc6a3fd69ae5f0f6da6754a2c9698e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f59a6db1aacc6a3fd69ae5f0f6da6754a2c9698e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76e2d1e59d466c725a02de7fe43df61fd7eb56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76e2d1e59d466c725a02de7fe43df61fd7eb56f", "html_url": "https://github.com/rust-lang/rust/commit/c76e2d1e59d466c725a02de7fe43df61fd7eb56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76e2d1e59d466c725a02de7fe43df61fd7eb56f/comments", "author": {"login": "dswij", "id": 44697459, "node_id": "MDQ6VXNlcjQ0Njk3NDU5", "avatar_url": "https://avatars.githubusercontent.com/u/44697459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dswij", "html_url": "https://github.com/dswij", "followers_url": "https://api.github.com/users/dswij/followers", "following_url": "https://api.github.com/users/dswij/following{/other_user}", "gists_url": "https://api.github.com/users/dswij/gists{/gist_id}", "starred_url": "https://api.github.com/users/dswij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dswij/subscriptions", "organizations_url": "https://api.github.com/users/dswij/orgs", "repos_url": "https://api.github.com/users/dswij/repos", "events_url": "https://api.github.com/users/dswij/events{/privacy}", "received_events_url": "https://api.github.com/users/dswij/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dswij", "id": 44697459, "node_id": "MDQ6VXNlcjQ0Njk3NDU5", "avatar_url": "https://avatars.githubusercontent.com/u/44697459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dswij", "html_url": "https://github.com/dswij", "followers_url": "https://api.github.com/users/dswij/followers", "following_url": "https://api.github.com/users/dswij/following{/other_user}", "gists_url": "https://api.github.com/users/dswij/gists{/gist_id}", "starred_url": "https://api.github.com/users/dswij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dswij/subscriptions", "organizations_url": "https://api.github.com/users/dswij/orgs", "repos_url": "https://api.github.com/users/dswij/repos", "events_url": "https://api.github.com/users/dswij/events{/privacy}", "received_events_url": "https://api.github.com/users/dswij/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d58fdfbf3c995d241677f0dff76d30b5157d0d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d58fdfbf3c995d241677f0dff76d30b5157d0d0f", "html_url": "https://github.com/rust-lang/rust/commit/d58fdfbf3c995d241677f0dff76d30b5157d0d0f"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "daa816d211e401772e658d628b5b87c49ad0178a", "filename": "clippy_utils/src/str_utils.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c76e2d1e59d466c725a02de7fe43df61fd7eb56f/clippy_utils%2Fsrc%2Fstr_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76e2d1e59d466c725a02de7fe43df61fd7eb56f/clippy_utils%2Fsrc%2Fstr_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fstr_utils.rs?ref=c76e2d1e59d466c725a02de7fe43df61fd7eb56f", "patch": "@@ -68,6 +68,16 @@ pub fn camel_case_until(s: &str) -> StrIndex {\n /// ```\n #[must_use]\n pub fn camel_case_start(s: &str) -> StrIndex {\n+    camel_case_start_from_idx(s, 0)\n+}\n+\n+/// Returns `StrIndex` of the last camel-case component of `s[idx..]`.\n+///\n+/// ```\n+/// assert_eq!(camel_case_start(\"AbcDef\", 0), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_start(\"AbcDef\", 1), StrIndex::new(3, 3));\n+/// ```\n+pub fn camel_case_start_from_idx(s: &str, start_idx: usize) -> StrIndex {\n     let char_count = s.chars().count();\n     let range = 0..char_count;\n     let mut iter = range.rev().zip(s.char_indices().rev());\n@@ -78,9 +88,13 @@ pub fn camel_case_start(s: &str) -> StrIndex {\n     } else {\n         return StrIndex::new(char_count, s.len());\n     }\n+\n     let mut down = true;\n     let mut last_index = StrIndex::new(char_count, s.len());\n     for (char_index, (byte_index, c)) in iter {\n+        if byte_index < start_idx {\n+            continue;\n+        }\n         if down {\n             if c.is_uppercase() {\n                 down = false;\n@@ -98,9 +112,51 @@ pub fn camel_case_start(s: &str) -> StrIndex {\n             return last_index;\n         }\n     }\n+\n     last_index\n }\n \n+/// Get the indexes of camel case components of a string `s`\n+///\n+/// ```\n+/// assert_eq!(camel_case_indexes(\"AbcDef\"), vec![StrIndex::new(0, 0), StrIndex::new(3, 3)])\n+/// ```\n+pub fn camel_case_indexes(s: &str) -> Vec<StrIndex> {\n+    let mut result = Vec::new();\n+    let mut str_idx = camel_case_start(s);\n+\n+    while str_idx.byte_index < s.len() {\n+        let next_idx = str_idx.byte_index + 1;\n+        result.push(str_idx);\n+        str_idx = camel_case_start_from_idx(s, next_idx);\n+    }\n+    result.push(str_idx);\n+\n+    result\n+}\n+\n+/// Split camel case string into a vector of its components\n+///\n+/// ```\n+/// assert_eq!(camel_case_split(\"AbcDef\"), vec![\"Abc\", \"Def\"]);\n+/// ```\n+pub fn camel_case_split(s: &str) -> Vec<&str> {\n+    let offsets = camel_case_indexes(s);\n+    let mut idxs_iter = offsets.iter().map(|str_idx| str_idx.byte_index).peekable();\n+    let idxs: Vec<usize> = if let Some(&idx) = idxs_iter.peek() {\n+        if idx == 0 {\n+            idxs_iter.collect()\n+        } else {\n+            Vec::<usize>::from([0]).into_iter().chain(idxs_iter).collect()\n+        }\n+    } else {\n+        return vec![s];\n+    };\n+    let split_points: Vec<(&usize, &usize)> = idxs[..idxs.len() - 1].iter().zip(&idxs[1..]).collect();\n+\n+    split_points.iter().map(|(&start, &stop)| &s[start..stop]).collect()\n+}\n+\n /// Dealing with sting comparison can be complicated, this struct ensures that both the\n /// character and byte count are provided for correct indexing.\n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -231,4 +287,29 @@ mod test {\n     fn until_caps() {\n         assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n     }\n+\n+    #[test]\n+    fn camel_case_indexes_full() {\n+        assert_eq!(\n+            camel_case_indexes(\"AbcDef\"),\n+            vec![StrIndex::new(0, 0), StrIndex::new(3, 3)]\n+        );\n+        assert_eq!(\n+            camel_case_indexes(\"abcDef\"),\n+            vec![StrIndex::new(0, 0), StrIndex::new(3, 3)]\n+        );\n+        assert_eq!(camel_case_indexes(\"Abc\\u{f6}\\u{f6}DD\"), vec![StrIndex::new(5, 7)]);\n+    }\n+\n+    #[test]\n+    fn camel_case_split_full() {\n+        assert_eq!(camel_case_split(\"A\"), vec![\"A\"]);\n+        assert_eq!(camel_case_split(\"AbcDef\"), vec![\"Abc\", \"Def\"]);\n+        assert_eq!(camel_case_split(\"Abc\"), vec![\"Abc\"]);\n+        assert_eq!(camel_case_split(\"abcDef\"), vec![\"abc\", \"Def\"]);\n+        assert_eq!(\n+            camel_case_split(\"\\u{f6}\\u{f6}AabABcd\"),\n+            vec![\"\\u{f6}\\u{f6}\", \"Aab\", \"A\", \"Bcd\"]\n+        );\n+    }\n }"}]}