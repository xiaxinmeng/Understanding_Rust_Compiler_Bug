{"sha": "803a4f45fa5b581155e638143afb97195cfa9f2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwM2E0ZjQ1ZmE1YjU4MTE1NWU2MzgxNDNhZmI5NzE5NWNmYTlmMmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T20:21:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:59Z"}, "message": "libcore: Remove mutable fields from the task builder API", "tree": {"sha": "4e51e0e0327225a58a4a5326aa5dd974a1a2290a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e51e0e0327225a58a4a5326aa5dd974a1a2290a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/803a4f45fa5b581155e638143afb97195cfa9f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/803a4f45fa5b581155e638143afb97195cfa9f2e", "html_url": "https://github.com/rust-lang/rust/commit/803a4f45fa5b581155e638143afb97195cfa9f2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/803a4f45fa5b581155e638143afb97195cfa9f2e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "url": "https://api.github.com/repos/rust-lang/rust/commits/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "html_url": "https://github.com/rust-lang/rust/commit/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e"}], "stats": {"total": 218, "additions": 87, "deletions": 131}, "files": [{"sha": "248898001750fbfa583a0bd7cecdba958ceca42c", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 60, "deletions": 118, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -156,7 +156,7 @@ pub struct SchedOpts {\n pub struct TaskOpts {\n     linked: bool,\n     supervised: bool,\n-    mut notify_chan: Option<Chan<TaskResult>>,\n+    notify_chan: Option<Chan<TaskResult>>,\n     sched: SchedOpts\n }\n \n@@ -176,9 +176,9 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    mut gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n     can_not_copy: Option<util::NonCopyable>,\n-    mut consumed: bool,\n+    consumed: bool,\n }\n \n /**\n@@ -191,13 +191,13 @@ pub fn task() -> TaskBuilder {\n         opts: default_task_opts(),\n         gen_body: None,\n         can_not_copy: None,\n-        mut consumed: false,\n+        consumed: false,\n     }\n }\n \n #[doc(hidden)] // FIXME #3538\n priv impl TaskBuilder {\n-    fn consume(&self) -> TaskBuilder {\n+    fn consume(&mut self) -> TaskBuilder {\n         if self.consumed {\n             fail!(~\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n@@ -219,57 +219,23 @@ priv impl TaskBuilder {\n }\n \n pub impl TaskBuilder {\n-    /**\n-     * Decouple the child task's failure from the parent's. If either fails,\n-     * the other will not be killed.\n-     */\n-    fn unlinked(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: false,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+    /// Decouple the child task's failure from the parent's. If either fails,\n+    /// the other will not be killed.\n+    fn unlinked(&mut self) {\n+        self.opts.linked = false;\n     }\n-    /**\n-     * Unidirectionally link the child task's failure with the parent's. The\n-     * child's failure will not kill the parent, but the parent's will kill\n-     * the child.\n-     */\n-    fn supervised(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: false,\n-                supervised: true,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+\n+    /// Unidirectionally link the child task's failure with the parent's. The\n+    /// child's failure will not kill the parent, but the parent's will kill\n+    /// the child.\n+    fn supervised(&mut self) {\n+        self.opts.supervised = true;\n     }\n-    /**\n-     * Link the child task's and parent task's failures. If either fails, the\n-     * other will be killed.\n-     */\n-    fn linked(&self) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: true,\n-                supervised: false,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+\n+    /// Link the child task's and parent task's failures. If either fails, the\n+    /// other will be killed.\n+    fn linked(&mut self) {\n+        self.opts.linked = true;\n     }\n \n     /**\n@@ -289,7 +255,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(&self, blk: &fn(v: Port<TaskResult>)) -> TaskBuilder {\n+    fn future_result(&mut self, blk: &fn(v: Port<TaskResult>)) {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -305,30 +271,12 @@ pub impl TaskBuilder {\n         blk(notify_pipe_po);\n \n         // Reconfigure self to use a notify channel.\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: Some(notify_pipe_ch),\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+        self.opts.notify_chan = Some(notify_pipe_ch);\n     }\n+\n     /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(&self, mode: SchedMode) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: SchedOpts { mode: mode, foreign_stack_size: None}\n-            },\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+    fn sched_mode(&mut self, mode: SchedMode) {\n+        self.opts.sched.mode = mode;\n     }\n \n     /**\n@@ -343,7 +291,7 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(&self, wrapper: ~fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n+    fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n         let prev_gen_body = replace(&mut self.gen_body, None);\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n@@ -360,18 +308,7 @@ pub impl TaskBuilder {\n             };\n             f\n         };\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: self.opts.sched\n-            },\n-            gen_body: Some(next_gen_body),\n-            can_not_copy: None,\n-            .. self.consume()\n-        }\n+        self.gen_body = Some(next_gen_body);\n     }\n \n     /**\n@@ -386,7 +323,7 @@ pub impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(&self, f: ~fn()) {\n+    fn spawn(&mut self, f: ~fn()) {\n         let gen_body = replace(&mut self.gen_body, None);\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n@@ -406,8 +343,9 @@ pub impl TaskBuilder {\n         };\n         spawn::spawn_raw(opts, f);\n     }\n+\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A:Owned>(&self, arg: A, f: ~fn(v: A)) {\n+    fn spawn_with<A:Owned>(&mut self, arg: A, f: ~fn(v: A)) {\n         let arg = Cell(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -427,16 +365,16 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T:Owned>(&self, f: ~fn() -> T) -> Result<T,()> {\n+    fn try<T:Owned>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n \n-        let fr_task_builder = self.future_result(|+r| {\n-            result = Some(r);\n-        });\n-        do fr_task_builder.spawn || {\n+        self.future_result(|+r| { result = Some(r); });\n+\n+        do self.spawn {\n             ch.send(f());\n         }\n+\n         match result.unwrap().recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n@@ -468,26 +406,23 @@ pub fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n+/// Creates and executes a new child task\n+///\n+/// Sets up a new task with its own call stack and schedules it to run\n+/// the provided unique closure.\n+///\n+/// This function is equivalent to `task().spawn(f)`.\n pub fn spawn(f: ~fn()) {\n-    /*!\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure.\n-     *\n-     * This function is equivalent to `task().spawn(f)`.\n-     */\n-\n-    task().spawn(f)\n+    let mut task = task();\n+    task.spawn(f)\n }\n \n+/// Creates a child task unlinked from the current one. If either this\n+/// task or the child task fails, the other will not be killed.\n pub fn spawn_unlinked(f: ~fn()) {\n-    /*!\n-     * Creates a child task unlinked from the current one. If either this\n-     * task or the child task fails, the other will not be killed.\n-     */\n-\n-    task().unlinked().spawn(f)\n+    let mut task = task();\n+    task.unlinked();\n+    task.spawn(f)\n }\n \n pub fn spawn_supervised(f: ~fn()) {\n@@ -497,7 +432,9 @@ pub fn spawn_supervised(f: ~fn()) {\n      * the child will be killed.\n      */\n \n-    task().supervised().spawn(f)\n+    let mut task = task();\n+    task.supervised();\n+    task.spawn(f)\n }\n \n pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n@@ -511,7 +448,8 @@ pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n      * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n-    task().spawn_with(arg, f)\n+    let mut task = task();\n+    task.spawn_with(arg, f)\n }\n \n pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n@@ -527,7 +465,9 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n      * greater than zero.\n      */\n \n-    task().sched_mode(mode).spawn(f)\n+    let mut task = task();\n+    task.sched_mode(mode);\n+    task.spawn(f)\n }\n \n pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n@@ -538,7 +478,9 @@ pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    task().supervised().try(f)\n+    let mut task = task();\n+    task.supervised();\n+    task.try(f)\n }\n \n \n@@ -822,7 +764,7 @@ fn test_run_basic() {\n \n #[cfg(test)]\n struct Wrapper {\n-    mut f: Option<Chan<()>>\n+    f: Option<Chan<()>>\n }\n \n #[test]"}, {"sha": "19c417dfdfc950f66fd31c893287e57ee3e90791", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -580,7 +580,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     sched.schedule_new_task(task);\n }\n \n-fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n+fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);"}, {"sha": "39c930d415f1c38300bb0eb6fd6748fa746954d7", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -70,7 +70,9 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     while !exit_fns_vec.is_empty() {\n         match exit_fns_vec.pop() {\n             ~f => {\n-                task::task().supervised().spawn(f);\n+                let mut task = task::task();\n+                task.supervised();\n+                task.spawn(f);\n             }\n         }\n     }"}, {"sha": "381083e6031b4db51a16d67410c88328bd61ad2a", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -72,7 +72,9 @@ fn create_global_service() -> ~WeakTaskService {\n     let chan = SharedChan::new(chan);\n     let chan_clone = chan.clone();\n \n-    do task().unlinked().spawn {\n+    let mut task = task();\n+    task.unlinked();\n+    do task.spawn {\n         debug!(\"running global weak task service\");\n         let port = Cell(port.take());\n         do (|| {"}, {"sha": "0c52e1ff80e21145de2d73bb0625d851702e7548", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -70,7 +70,9 @@ pub impl<T> TaskPool<T> {\n                     task::spawn(task_body);\n                 }\n                 Some(sched_mode) => {\n-                    task::task().sched_mode(sched_mode).spawn(task_body);\n+                    let mut task = task::task();\n+                    task.sched_mode(sched_mode);\n+                    task.spawn(task_body);\n                 }\n             }\n "}, {"sha": "b3523b8ad801908e2dcf22c4f403ae8e0a7d3d6a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -556,9 +556,12 @@ pub fn run_test(force_ignore: bool,\n         let testfn_cell = ::core::cell::Cell(testfn);\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n-            task::task().unlinked().future_result(|+r| {\n-                result_future = Some(r);\n-            }).spawn(testfn_cell.take());\n+\n+            let mut task = task::task();\n+            task.unlinked();\n+            task.future_result(|+r| { result_future = Some(r) });\n+            task.spawn(testfn_cell.take());\n+\n             let task_result = result_future.unwrap().recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);"}, {"sha": "e1b7eb61505255da7f1ea4f10b1e78bd3b459684", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -62,7 +62,9 @@ fn get_monitor_task_gl() -> IoTask {\n                 }\n             };\n             if installed {\n-                do task().unlinked().spawn() {\n+                let mut task = task();\n+                task.unlinked();\n+                do task.spawn {\n                     unsafe {\n                         debug!(\"global monitor task starting\");\n                         // As a weak task the runtime will notify us\n@@ -88,7 +90,9 @@ fn get_monitor_task_gl() -> IoTask {\n }\n \n fn spawn_loop() -> IoTask {\n-    let builder = do task().add_wrapper |task_body| {\n+    let mut builder = task();\n+\n+    do builder.add_wrapper |task_body| {\n         let result: ~fn() = || {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n@@ -107,7 +111,8 @@ fn spawn_loop() -> IoTask {\n         };\n         result\n     };\n-    let builder = builder.unlinked();\n+\n+    builder.unlinked();\n     spawn_iotask(builder)\n }\n "}, {"sha": "83e95a6e1993ab17a4e7c9e082cd16cd4565e599", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a4f45fa5b581155e638143afb97195cfa9f2e/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=803a4f45fa5b581155e638143afb97195cfa9f2e", "patch": "@@ -36,11 +36,11 @@ impl Clone for IoTask {\n     }\n }\n \n-pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n-\n+pub fn spawn_iotask(mut task: task::TaskBuilder) -> IoTask {\n     let (iotask_port, iotask_chan) = stream();\n \n-    do task.sched_mode(task::SingleThreaded).spawn {\n+    task.sched_mode(task::SingleThreaded);\n+    do task.spawn {\n         debug!(\"entering libuv task\");\n         run_loop(&iotask_chan);\n         debug!(\"libuv task exiting\");"}]}