{"sha": "49c82f31a85f04a709810de4ccfb8ba765c1377b", "node_id": "C_kwDOAAsO6NoAKDQ5YzgyZjMxYTg1ZjA0YTcwOTgxMGRlNGNjZmI4YmE3NjVjMTM3N2I", "commit": {"author": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2022-05-20T23:51:09Z"}, "committer": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2022-05-21T00:04:54Z"}, "message": "Remove `crate` visibility usage in compiler", "tree": {"sha": "dbcbf74a4c0cef46af19b4b24f04dd2e79e3ea23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbcbf74a4c0cef46af19b4b24f04dd2e79e3ea23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c82f31a85f04a709810de4ccfb8ba765c1377b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQTgxeqBxcDGar1sVhy4DhnkZitapAUCYogspgAKCRC4DhnkZita\npFGjAP4hzqjjxKmPiIfwmDKyXp5KLQccbrF/h10FWYOWKuGoDwEA7oKR4jYcih7k\nKLxvLj1Lgmja8Rwh2lOT5bRvqnlWNwM=\n=M6PD\n-----END PGP SIGNATURE-----", "payload": "tree dbcbf74a4c0cef46af19b4b24f04dd2e79e3ea23\nparent 536020c5f97883aa9f2a90897a5adb520486d2e1\nauthor Jacob Pratt <jacob@jhpratt.dev> 1653090669 -0400\ncommitter Jacob Pratt <jacob@jhpratt.dev> 1653091494 -0400\n\nRemove `crate` visibility usage in compiler\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c82f31a85f04a709810de4ccfb8ba765c1377b", "html_url": "https://github.com/rust-lang/rust/commit/49c82f31a85f04a709810de4ccfb8ba765c1377b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c82f31a85f04a709810de4ccfb8ba765c1377b/comments", "author": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "536020c5f97883aa9f2a90897a5adb520486d2e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/536020c5f97883aa9f2a90897a5adb520486d2e1", "html_url": "https://github.com/rust-lang/rust/commit/536020c5f97883aa9f2a90897a5adb520486d2e1"}], "stats": {"total": 1665, "additions": 865, "deletions": 800}, "files": [{"sha": "988918b0505e0dcb2599e79cefc28b9e363760c4", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -340,7 +340,7 @@ pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n-crate fn mk_attr_id() -> AttrId {\n+pub(crate) fn mk_attr_id() -> AttrId {\n     use std::sync::atomic::AtomicU32;\n     use std::sync::atomic::Ordering;\n "}, {"sha": "2015d635e561b83c76cb22c78a4c62733d5f8a9a", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -12,7 +12,6 @@\n #![feature(box_patterns)]\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(label_break_value)]\n #![feature(let_chains)]"}, {"sha": "1522d12cbf92e819a437ea98008e55f77ac00bbf", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -134,7 +134,7 @@ impl LitKind {\n         }\n     }\n \n-    crate fn may_have_suffix(self) -> bool {\n+    pub(crate) fn may_have_suffix(self) -> bool {\n         matches!(self, Integer | Float | Err)\n     }\n }"}, {"sha": "6c055645ef3e9dcc86166a95a44664e4dcc4149f", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -17,7 +17,11 @@ use std::collections::hash_map::Entry;\n use std::fmt::Write;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_inline_asm(&mut self, sp: Span, asm: &InlineAsm) -> &'hir hir::InlineAsm<'hir> {\n+    pub(crate) fn lower_inline_asm(\n+        &mut self,\n+        sp: Span,\n+        asm: &InlineAsm,\n+    ) -> &'hir hir::InlineAsm<'hir> {\n         // Rustdoc needs to support asm! from foreign architectures: don't try\n         // lowering the register constraints in this case.\n         let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };"}, {"sha": "a01ab32c282f6c5702a05dd75b04b45c1b55ff7c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -848,7 +848,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    crate fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n+    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n "}, {"sha": "3dd6b4e52db3dfa4930303d9a2cc11150bb0ec41", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -30,7 +30,6 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-#![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "e27bc7a0f472f937743d2dbc21a7c20506929586", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -12,11 +12,11 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, pattern: &Pat) -> &'hir hir::Pat<'hir> {\n+    pub(crate) fn lower_pat(&mut self, pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         self.arena.alloc(self.lower_pat_mut(pattern))\n     }\n \n-    crate fn lower_pat_mut(&mut self, mut pattern: &Pat) -> hir::Pat<'hir> {\n+    pub(crate) fn lower_pat_mut(&mut self, mut pattern: &Pat) -> hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n             // loop here to avoid recursion\n             let node = loop {\n@@ -290,7 +290,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    crate fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+    pub(crate) fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n         self.diagnostic()\n             .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n             .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))"}, {"sha": "7fc8aac5116f91f1c03909cfd49f57d34c37ef50", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,7 +15,7 @@ use smallvec::smallvec;\n use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_qpath(\n+    pub(crate) fn lower_qpath(\n         &mut self,\n         id: NodeId,\n         qself: &Option<QSelf>,\n@@ -142,7 +142,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         );\n     }\n \n-    crate fn lower_path_extra(\n+    pub(crate) fn lower_path_extra(\n         &mut self,\n         res: Res,\n         p: &Path,\n@@ -163,7 +163,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    crate fn lower_path(\n+    pub(crate) fn lower_path(\n         &mut self,\n         id: NodeId,\n         p: &Path,\n@@ -174,7 +174,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.lower_path_extra(res, p, param_mode)\n     }\n \n-    crate fn lower_path_segment(\n+    pub(crate) fn lower_path_segment(\n         &mut self,\n         path_span: Span,\n         segment: &PathSegment,\n@@ -381,7 +381,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// An associated type binding `Output = $ty`.\n-    crate fn output_ty_binding(\n+    pub(crate) fn output_ty_binding(\n         &mut self,\n         span: Span,\n         ty: &'hir hir::Ty<'hir>,"}, {"sha": "79178830bf949d3f1b5f714eb063401b39136902", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,5 +1,4 @@\n #![feature(associated_type_bounds)]\n-#![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(with_negative_coherence)]\n #![recursion_limit = \"256\"]"}, {"sha": "7357ddf2134e48581a580afbc192b3f2542b3d90", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -95,7 +95,7 @@ pub struct State<'a> {\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n-crate const INDENT_UNIT: isize = 4;\n+pub(crate) const INDENT_UNIT: isize = 4;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n@@ -955,8 +955,13 @@ impl<'a> State<'a> {\n         State { s: pp::Printer::new(), comments: None, ann: &NoAnn }\n     }\n \n-    crate fn commasep_cmnt<T, F, G>(&mut self, b: Breaks, elts: &[T], mut op: F, mut get_span: G)\n-    where\n+    pub(crate) fn commasep_cmnt<T, F, G>(\n+        &mut self,\n+        b: Breaks,\n+        elts: &[T],\n+        mut op: F,\n+        mut get_span: G,\n+    ) where\n         F: FnMut(&mut State<'_>, &T),\n         G: FnMut(&T) -> rustc_span::Span,\n     {\n@@ -976,7 +981,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<ast::Expr>]) {\n+    pub(crate) fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<ast::Expr>]) {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n@@ -1109,7 +1114,7 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    crate fn print_stmt(&mut self, st: &ast::Stmt) {\n+    pub(crate) fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             ast::StmtKind::Local(ref loc) => {\n@@ -1164,19 +1169,19 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    crate fn print_block(&mut self, blk: &ast::Block) {\n+    pub(crate) fn print_block(&mut self, blk: &ast::Block) {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    crate fn print_block_unclosed_indent(&mut self, blk: &ast::Block) {\n+    pub(crate) fn print_block_unclosed_indent(&mut self, blk: &ast::Block) {\n         self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n-    crate fn print_block_with_attrs(&mut self, blk: &ast::Block, attrs: &[ast::Attribute]) {\n+    pub(crate) fn print_block_with_attrs(&mut self, blk: &ast::Block, attrs: &[ast::Attribute]) {\n         self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n-    crate fn print_block_maybe_unclosed(\n+    pub(crate) fn print_block_maybe_unclosed(\n         &mut self,\n         blk: &ast::Block,\n         attrs: &[ast::Attribute],\n@@ -1210,7 +1215,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Print a `let pat = expr` expression.\n-    crate fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n+    pub(crate) fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n         self.word(\"let \");\n         self.print_pat(pat);\n         self.space();\n@@ -1219,7 +1224,7 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n-    crate fn print_mac(&mut self, m: &ast::MacCall) {\n+    pub(crate) fn print_mac(&mut self, m: &ast::MacCall) {\n         self.print_mac_common(\n             Some(MacHeader::Path(&m.path)),\n             true,\n@@ -1360,15 +1365,15 @@ impl<'a> State<'a> {\n         self.pclose();\n     }\n \n-    crate fn print_local_decl(&mut self, loc: &ast::Local) {\n+    pub(crate) fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\");\n             self.print_type(ty);\n         }\n     }\n \n-    crate fn print_name(&mut self, name: Symbol) {\n+    pub(crate) fn print_name(&mut self, name: Symbol) {\n         self.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n@@ -1392,7 +1397,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_pat(&mut self, pat: &ast::Pat) {\n+    pub(crate) fn print_pat(&mut self, pat: &ast::Pat) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n@@ -1551,7 +1556,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n+    pub(crate) fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n         }\n@@ -1584,11 +1589,11 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_lifetime(&mut self, lifetime: ast::Lifetime) {\n+    pub(crate) fn print_lifetime(&mut self, lifetime: ast::Lifetime) {\n         self.print_name(lifetime.ident.name)\n     }\n \n-    crate fn print_lifetime_bounds(\n+    pub(crate) fn print_lifetime_bounds(\n         &mut self,\n         lifetime: ast::Lifetime,\n         bounds: &ast::GenericBounds,\n@@ -1608,7 +1613,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n+    pub(crate) fn print_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n         if generic_params.is_empty() {\n             return;\n         }\n@@ -1662,12 +1667,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n+    pub(crate) fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n \n-    crate fn print_param(&mut self, input: &ast::Param, is_closure: bool) {\n+    pub(crate) fn print_param(&mut self, input: &ast::Param, is_closure: bool) {\n         self.ibox(INDENT_UNIT);\n \n         self.print_outer_attributes_inline(&input.attrs);\n@@ -1695,7 +1700,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_fn_ret_ty(&mut self, fn_ret_ty: &ast::FnRetTy) {\n+    pub(crate) fn print_fn_ret_ty(&mut self, fn_ret_ty: &ast::FnRetTy) {\n         if let ast::FnRetTy::Ty(ty) = fn_ret_ty {\n             self.space_if_not_bol();\n             self.ibox(INDENT_UNIT);\n@@ -1706,7 +1711,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_ty_fn(\n+    pub(crate) fn print_ty_fn(\n         &mut self,\n         ext: ast::Extern,\n         unsafety: ast::Unsafe,\n@@ -1730,7 +1735,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_fn_header_info(&mut self, header: ast::FnHeader) {\n+    pub(crate) fn print_fn_header_info(&mut self, header: ast::FnHeader) {\n         self.print_constness(header.constness);\n         self.print_asyncness(header.asyncness);\n         self.print_unsafety(header.unsafety);\n@@ -1750,21 +1755,21 @@ impl<'a> State<'a> {\n         self.word(\"fn\")\n     }\n \n-    crate fn print_unsafety(&mut self, s: ast::Unsafe) {\n+    pub(crate) fn print_unsafety(&mut self, s: ast::Unsafe) {\n         match s {\n             ast::Unsafe::No => {}\n             ast::Unsafe::Yes(_) => self.word_nbsp(\"unsafe\"),\n         }\n     }\n \n-    crate fn print_constness(&mut self, s: ast::Const) {\n+    pub(crate) fn print_constness(&mut self, s: ast::Const) {\n         match s {\n             ast::Const::No => {}\n             ast::Const::Yes(_) => self.word_nbsp(\"const\"),\n         }\n     }\n \n-    crate fn print_is_auto(&mut self, s: ast::IsAuto) {\n+    pub(crate) fn print_is_auto(&mut self, s: ast::IsAuto) {\n         match s {\n             ast::IsAuto::Yes => self.word_nbsp(\"auto\"),\n             ast::IsAuto::No => {}"}, {"sha": "0de5e2099fd0b1ff5f6595e50df4ad479df879ab", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -19,7 +19,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+    pub(crate) fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n@@ -128,7 +128,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Pretty-prints an item.\n-    crate fn print_item(&mut self, item: &ast::Item) {\n+    pub(crate) fn print_item(&mut self, item: &ast::Item) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n@@ -400,7 +400,7 @@ impl<'a> State<'a> {\n         self.bclose(span, empty)\n     }\n \n-    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n+    pub(crate) fn print_visibility(&mut self, vis: &ast::Visibility) {\n         match vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             ast::VisibilityKind::Crate(sugar) => match sugar {\n@@ -484,7 +484,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_variant(&mut self, v: &ast::Variant) {\n+    pub(crate) fn print_variant(&mut self, v: &ast::Variant) {\n         self.head(\"\");\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n@@ -496,7 +496,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+    pub(crate) fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n@@ -562,7 +562,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_fn(\n+    pub(crate) fn print_fn(\n         &mut self,\n         decl: &ast::FnDecl,\n         header: ast::FnHeader,\n@@ -579,7 +579,7 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+    pub(crate) fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n         let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n         self.word(open);\n         self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n@@ -591,7 +591,7 @@ impl<'a> State<'a> {\n         self.print_where_clause_parts(where_clause.has_where_token, &where_clause.predicates);\n     }\n \n-    crate fn print_where_clause_parts(\n+    pub(crate) fn print_where_clause_parts(\n         &mut self,\n         has_where_token: bool,\n         predicates: &[ast::WherePredicate],"}, {"sha": "c7d0e3361331c51ea488331be0f107b094b5aa1d", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -29,7 +29,7 @@ pub struct BorrowSet<'tcx> {\n     /// Map from local to all the borrows on that local.\n     pub local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n-    crate locals_state_at_exit: LocalsStateAtExit,\n+    pub(crate) locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n@@ -148,23 +148,23 @@ impl<'tcx> BorrowSet<'tcx> {\n         }\n     }\n \n-    crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n+    pub(crate) fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n         self.activation_map.get(&location).map_or(&[], |activations| &activations[..])\n     }\n \n-    crate fn len(&self) -> usize {\n+    pub(crate) fn len(&self) -> usize {\n         self.location_map.len()\n     }\n \n-    crate fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n+    pub(crate) fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n         BorrowIndex::from_usize(0)..BorrowIndex::from_usize(self.len())\n     }\n \n-    crate fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n+    pub(crate) fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n         self.indices().zip(self.location_map.values())\n     }\n \n-    crate fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n+    pub(crate) fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n         self.location_map.get_index_of(location).map(BorrowIndex::from)\n     }\n }"}, {"sha": "a1233d62cb02ea2ecb832d05bd30975ccb2e4629", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -3,15 +3,15 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n-    crate fn cannot_move_when_borrowed(\n+    pub(crate) fn cannot_move_when_borrowed(\n         &self,\n         span: Span,\n         desc: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n     }\n \n-    crate fn cannot_use_when_mutably_borrowed(\n+    pub(crate) fn cannot_use_when_mutably_borrowed(\n         &self,\n         span: Span,\n         desc: &str,\n@@ -31,7 +31,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_act_on_uninitialized_variable(\n+    pub(crate) fn cannot_act_on_uninitialized_variable(\n         &self,\n         span: Span,\n         verb: &str,\n@@ -47,7 +47,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_mutably_borrow_multiply(\n+    pub(crate) fn cannot_mutably_borrow_multiply(\n         &self,\n         new_loan_span: Span,\n         desc: &str,\n@@ -97,7 +97,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_uniquely_borrow_by_two_closures(\n+    pub(crate) fn cannot_uniquely_borrow_by_two_closures(\n         &self,\n         new_loan_span: Span,\n         desc: &str,\n@@ -126,7 +126,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_uniquely_borrow_by_one_closure(\n+    pub(crate) fn cannot_uniquely_borrow_by_one_closure(\n         &self,\n         new_loan_span: Span,\n         container_name: &str,\n@@ -157,7 +157,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reborrow_already_uniquely_borrowed(\n+    pub(crate) fn cannot_reborrow_already_uniquely_borrowed(\n         &self,\n         new_loan_span: Span,\n         container_name: &str,\n@@ -193,7 +193,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reborrow_already_borrowed(\n+    pub(crate) fn cannot_reborrow_already_borrowed(\n         &self,\n         span: Span,\n         desc_new: &str,\n@@ -242,7 +242,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_assign_to_borrowed(\n+    pub(crate) fn cannot_assign_to_borrowed(\n         &self,\n         span: Span,\n         borrow_span: Span,\n@@ -261,7 +261,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reassign_immutable(\n+    pub(crate) fn cannot_reassign_immutable(\n         &self,\n         span: Span,\n         desc: &str,\n@@ -271,15 +271,15 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         struct_span_err!(self, span, E0384, \"cannot assign {} {}\", msg, desc)\n     }\n \n-    crate fn cannot_assign(\n+    pub(crate) fn cannot_assign(\n         &self,\n         span: Span,\n         desc: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n-    crate fn cannot_move_out_of(\n+    pub(crate) fn cannot_move_out_of(\n         &self,\n         move_from_span: Span,\n         move_from_desc: &str,\n@@ -290,7 +290,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     /// Signal an error due to an attempt to move out of the interior\n     /// of an array or slice. `is_index` is None when error origin\n     /// didn't capture whether there was an indexing operation or not.\n-    crate fn cannot_move_out_of_interior_noncopy(\n+    pub(crate) fn cannot_move_out_of_interior_noncopy(\n         &self,\n         move_from_span: Span,\n         ty: Ty<'_>,\n@@ -313,7 +313,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_move_out_of_interior_of_drop(\n+    pub(crate) fn cannot_move_out_of_interior_of_drop(\n         &self,\n         move_from_span: Span,\n         container_ty: Ty<'_>,\n@@ -329,7 +329,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_act_on_moved_value(\n+    pub(crate) fn cannot_act_on_moved_value(\n         &self,\n         use_span: Span,\n         verb: &str,\n@@ -349,7 +349,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_borrow_path_as_mutable_because(\n+    pub(crate) fn cannot_borrow_path_as_mutable_because(\n         &self,\n         span: Span,\n         path: &str,\n@@ -358,7 +358,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{}\", path, reason,)\n     }\n \n-    crate fn cannot_mutate_in_immutable_section(\n+    pub(crate) fn cannot_mutate_in_immutable_section(\n         &self,\n         mutate_span: Span,\n         immutable_span: Span,\n@@ -380,7 +380,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_borrow_across_generator_yield(\n+    pub(crate) fn cannot_borrow_across_generator_yield(\n         &self,\n         span: Span,\n         yield_span: Span,\n@@ -395,7 +395,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_borrow_across_destructor(\n+    pub(crate) fn cannot_borrow_across_destructor(\n         &self,\n         borrow_span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n@@ -407,15 +407,15 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn path_does_not_live_long_enough(\n+    pub(crate) fn path_does_not_live_long_enough(\n         &self,\n         span: Span,\n         path: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0597, \"{} does not live long enough\", path,)\n     }\n \n-    crate fn cannot_return_reference_to_local(\n+    pub(crate) fn cannot_return_reference_to_local(\n         &self,\n         span: Span,\n         return_kind: &str,\n@@ -440,7 +440,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_capture_in_long_lived_closure(\n+    pub(crate) fn cannot_capture_in_long_lived_closure(\n         &self,\n         closure_span: Span,\n         closure_kind: &str,\n@@ -462,14 +462,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn thread_local_value_does_not_live_long_enough(\n+    pub(crate) fn thread_local_value_does_not_live_long_enough(\n         &self,\n         span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0712, \"thread-local variable borrowed past end of function\",)\n     }\n \n-    crate fn temporary_value_borrowed_for_too_long(\n+    pub(crate) fn temporary_value_borrowed_for_too_long(\n         &self,\n         span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n@@ -486,7 +486,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-crate fn borrowed_data_escapes_closure<'tcx>(\n+pub(crate) fn borrowed_data_escapes_closure<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     escape_span: Span,\n     escapes_from: &str,"}, {"sha": "609fbc2bc1515aa7e0e76bfabc3ed577316ed81a", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -13,19 +13,19 @@ use crate::{\n /// The construct graph organizes the constraints by their end-points.\n /// It can be used to view a `R1: R2` constraint as either an edge `R1\n /// -> R2` or `R2 -> R1` depending on the direction type `D`.\n-crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n+pub(crate) struct ConstraintGraph<D: ConstraintGraphDirecton> {\n     _direction: D,\n     first_constraints: IndexVec<RegionVid, Option<OutlivesConstraintIndex>>,\n     next_constraints: IndexVec<OutlivesConstraintIndex, Option<OutlivesConstraintIndex>>,\n }\n \n-crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n+pub(crate) type NormalConstraintGraph = ConstraintGraph<Normal>;\n \n-crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n+pub(crate) type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n \n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n-crate trait ConstraintGraphDirecton: Copy + 'static {\n+pub(crate) trait ConstraintGraphDirecton: Copy + 'static {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn is_normal() -> bool;\n@@ -36,7 +36,7 @@ crate trait ConstraintGraphDirecton: Copy + 'static {\n /// inference. This is because we compute the value of R1 by union'ing\n /// all the things that it relies on.\n #[derive(Copy, Clone, Debug)]\n-crate struct Normal;\n+pub(crate) struct Normal;\n \n impl ConstraintGraphDirecton for Normal {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n@@ -57,7 +57,7 @@ impl ConstraintGraphDirecton for Normal {\n /// we wish to iterate from a region (e.g., R2) to all the regions\n /// that will outlive it (e.g., R1).\n #[derive(Copy, Clone, Debug)]\n-crate struct Reverse;\n+pub(crate) struct Reverse;\n \n impl ConstraintGraphDirecton for Reverse {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n@@ -78,7 +78,11 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(direction: D, set: &OutlivesConstraintSet<'_>, num_region_vars: usize) -> Self {\n+    pub(crate) fn new(\n+        direction: D,\n+        set: &OutlivesConstraintSet<'_>,\n+        num_region_vars: usize,\n+    ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n@@ -96,7 +100,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Given the constraint set from which this graph was built\n     /// creates a region graph so that you can iterate over *regions*\n     /// and not constraints.\n-    crate fn region_graph<'rg, 'tcx>(\n+    pub(crate) fn region_graph<'rg, 'tcx>(\n         &'rg self,\n         set: &'rg OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n@@ -105,7 +109,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges<'a, 'tcx>(\n+    pub(crate) fn outgoing_edges<'a, 'tcx>(\n         &'a self,\n         region_sup: RegionVid,\n         constraints: &'a OutlivesConstraintSet<'tcx>,\n@@ -129,7 +133,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n }\n \n-crate struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n     constraints: &'s OutlivesConstraintSet<'tcx>,\n     pointer: Option<OutlivesConstraintIndex>,\n@@ -169,7 +173,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n /// This struct brings together a constraint set and a (normal, not\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n-crate struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n     set: &'s OutlivesConstraintSet<'tcx>,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n@@ -180,7 +184,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(\n+    pub(crate) fn new(\n         set: &'s OutlivesConstraintSet<'tcx>,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n@@ -190,14 +194,14 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'s, 'tcx, D> {\n+    pub(crate) fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'s, 'tcx, D> {\n         Successors {\n             edges: self.constraint_graph.outgoing_edges(region_sup, self.set, self.static_region),\n         }\n     }\n }\n \n-crate struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n     edges: Edges<'s, 'tcx, D>,\n }\n "}, {"sha": "6d5466c0c41e3c3b4e4aaa77ef8a9f5834ef973b", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,19 +8,19 @@ use std::ops::Index;\n \n use crate::type_check::Locations;\n \n-crate mod graph;\n+pub(crate) mod graph;\n \n /// A set of NLL region constraints. These include \"outlives\"\n /// constraints of the form `R1: R2`. Each constraint is identified by\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct OutlivesConstraintSet<'tcx> {\n+pub(crate) struct OutlivesConstraintSet<'tcx> {\n     outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }\n \n impl<'tcx> OutlivesConstraintSet<'tcx> {\n-    crate fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n+    pub(crate) fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n         debug!(\n             \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n@@ -38,20 +38,20 @@ impl<'tcx> OutlivesConstraintSet<'tcx> {\n     /// N.B., this graph contains a \"frozen\" view of the current\n     /// constraints. Any new constraints added to the `OutlivesConstraintSet`\n     /// after the graph is built will not be present in the graph.\n-    crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n+    pub(crate) fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n     }\n \n     /// Like `graph`, but constraints a reverse graph where `R1: R2`\n     /// represents an edge `R2 -> R1`.\n-    crate fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n+    pub(crate) fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n         graph::ConstraintGraph::new(graph::Reverse, self, num_region_vars)\n     }\n \n     /// Computes cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs.\n-    crate fn compute_sccs(\n+    pub(crate) fn compute_sccs(\n         &self,\n         constraint_graph: &graph::NormalConstraintGraph,\n         static_region: RegionVid,\n@@ -60,7 +60,7 @@ impl<'tcx> OutlivesConstraintSet<'tcx> {\n         Sccs::new(region_graph)\n     }\n \n-    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n+    pub(crate) fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n         &self.outlives\n     }\n }"}, {"sha": "97d5a8d158e1e63e7b72f2f77bc255fa1c352059", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -233,7 +233,7 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n }\n \n impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: &'a RegionInferenceContext<'tcx>,"}, {"sha": "07f182102f346009b130861e5938fd4723032652", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -22,7 +22,7 @@ use crate::region_infer::values::RegionElement;\n use crate::MirBorrowckCtxt;\n \n #[derive(Clone)]\n-crate struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n+pub(crate) struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n \n /// What operation a universe was created for.\n #[derive(Clone)]\n@@ -36,15 +36,15 @@ enum UniverseInfoInner<'tcx> {\n }\n \n impl<'tcx> UniverseInfo<'tcx> {\n-    crate fn other() -> UniverseInfo<'tcx> {\n+    pub(crate) fn other() -> UniverseInfo<'tcx> {\n         UniverseInfo(UniverseInfoInner::Other)\n     }\n \n-    crate fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n+    pub(crate) fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n         UniverseInfo(UniverseInfoInner::RelateTys { expected, found })\n     }\n \n-    crate fn report_error(\n+    pub(crate) fn report_error(\n         &self,\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         placeholder: ty::PlaceholderRegion,\n@@ -76,7 +76,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n     }\n }\n \n-crate trait ToUniverseInfo<'tcx> {\n+pub(crate) trait ToUniverseInfo<'tcx> {\n     fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n }\n "}, {"sha": "06fca4db0cf1f9ab72bb942d123a463d66ae9d3c", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n \n-crate fn find<'tcx>(\n+pub(crate) fn find<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "9581bb652362ff4fbb4fd1937b18564281d78ea8", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -35,12 +35,12 @@ mod move_errors;\n mod mutability_errors;\n mod region_errors;\n \n-crate use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n-crate use mutability_errors::AccessKind;\n-crate use outlives_suggestion::OutlivesSuggestionBuilder;\n-crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n-crate use region_name::{RegionName, RegionNameSource};\n-crate use rustc_const_eval::util::CallKind;\n+pub(crate) use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n+pub(crate) use mutability_errors::AccessKind;\n+pub(crate) use outlives_suggestion::OutlivesSuggestionBuilder;\n+pub(crate) use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n+pub(crate) use region_name::{RegionName, RegionNameSource};\n+pub(crate) use rustc_const_eval::util::CallKind;\n use rustc_middle::mir::tcx::PlaceTy;\n \n pub(super) struct IncludingDowncast(pub(super) bool);"}, {"sha": "1688d1259fa86ec3166c929f1013b09ceb976178", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -149,7 +149,7 @@ impl OutlivesSuggestionBuilder {\n     }\n \n     /// Add the outlives constraint `fr: outlived_fr` to the set of constraints we need to suggest.\n-    crate fn collect_constraint(&mut self, fr: RegionVid, outlived_fr: RegionVid) {\n+    pub(crate) fn collect_constraint(&mut self, fr: RegionVid, outlived_fr: RegionVid) {\n         debug!(\"Collected {:?}: {:?}\", fr, outlived_fr);\n \n         // Add to set of constraints for final help note.\n@@ -158,7 +158,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// Emit an intermediate note on the given `Diagnostic` if the involved regions are\n     /// suggestable.\n-    crate fn intermediate_suggestion(\n+    pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n@@ -179,7 +179,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n+    pub(crate) fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n         // No constraints to add? Done.\n         if self.constraints_to_add.is_empty() {\n             debug!(\"No constraints to suggest.\");"}, {"sha": "f2b5c83c5c1d08afd5bb5f0ff16b5d9533867ae1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -58,10 +58,10 @@ impl ConstraintDescription for ConstraintCategory {\n ///\n /// Usually we expect this to either be empty or contain a small number of items, so we can avoid\n /// allocation most of the time.\n-crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n+pub(crate) type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n \n #[derive(Clone, Debug)]\n-crate enum RegionErrorKind<'tcx> {\n+pub(crate) enum RegionErrorKind<'tcx> {\n     /// A generic bound failure for a type test (`T: 'a`).\n     TypeTestError { type_test: TypeTest<'tcx> },\n "}, {"sha": "4d2a16aa609846a1e1931b062add52cb2a6ee032", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,18 +15,18 @@ use crate::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n #[derive(Debug, Clone)]\n-crate struct RegionName {\n+pub(crate) struct RegionName {\n     /// The name of the region (interned).\n-    crate name: Symbol,\n+    pub(crate) name: Symbol,\n     /// Where the region comes from.\n-    crate source: RegionNameSource,\n+    pub(crate) source: RegionNameSource,\n }\n \n /// Denotes the source of a region that is named by a `RegionName`. For example, a free region that\n /// was named by the user would get `NamedFreeRegion` and `'static` lifetime would get `Static`.\n /// This helps to print the right kinds of diagnostics.\n #[derive(Debug, Clone)]\n-crate enum RegionNameSource {\n+pub(crate) enum RegionNameSource {\n     /// A bound (not free) region that was substituted at the def site (not an HRTB).\n     NamedEarlyBoundRegion(Span),\n     /// A free region that the user has a name (`'a`) for.\n@@ -50,7 +50,7 @@ crate enum RegionNameSource {\n /// Describes what to highlight to explain to the user that we're giving an anonymous region a\n /// synthesized name, and how to highlight it.\n #[derive(Debug, Clone)]\n-crate enum RegionNameHighlight {\n+pub(crate) enum RegionNameHighlight {\n     /// The anonymous region corresponds to a reference that was found by traversing the type in the HIR.\n     MatchedHirTy(Span),\n     /// The anonymous region corresponds to a `'_` in the generics list of a struct/enum/union.\n@@ -65,7 +65,7 @@ crate enum RegionNameHighlight {\n }\n \n impl RegionName {\n-    crate fn was_named(&self) -> bool {\n+    pub(crate) fn was_named(&self) -> bool {\n         match self.source {\n             RegionNameSource::NamedEarlyBoundRegion(..)\n             | RegionNameSource::NamedFreeRegion(..)\n@@ -79,7 +79,7 @@ impl RegionName {\n         }\n     }\n \n-    crate fn span(&self) -> Option<Span> {\n+    pub(crate) fn span(&self) -> Option<Span> {\n         match self.source {\n             RegionNameSource::Static => None,\n             RegionNameSource::NamedEarlyBoundRegion(span)\n@@ -98,7 +98,7 @@ impl RegionName {\n         }\n     }\n \n-    crate fn highlight_region_name(&self, diag: &mut Diagnostic) {\n+    pub(crate) fn highlight_region_name(&self, diag: &mut Diagnostic) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::NamedEarlyBoundRegion(span) => {\n@@ -178,11 +178,11 @@ impl Display for RegionName {\n }\n \n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n-    crate fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n+    pub(crate) fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n         self.body.source.def_id().as_local().unwrap()\n     }\n \n-    crate fn mir_hir_id(&self) -> hir::HirId {\n+    pub(crate) fn mir_hir_id(&self) -> hir::HirId {\n         self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id())\n     }\n \n@@ -222,7 +222,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// ```\n     ///\n     /// and then return the name `'1` for us to use.\n-    crate fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n+    pub(crate) fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n         debug!(\n             \"give_region_a_name(fr={:?}, counter={:?})\",\n             fr,"}, {"sha": "9ba29f04b1a9aa4cffc27b0ea8539bb3cd3098d9", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n-    crate fn get_var_name_and_span_for_region(\n+    pub(crate) fn get_var_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -34,7 +34,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Search the upvars (if any) to find one that references fr. Return its index.\n-    crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n+    pub(crate) fn get_upvar_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n         let upvar_index =\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n@@ -57,7 +61,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Given the index of an upvar, finds its name and the span from where it was\n     /// declared.\n-    crate fn get_upvar_name_and_span_for_region(\n+    pub(crate) fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar<'tcx>],\n@@ -81,7 +85,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// N.B., in the case of a closure, the index is indexing into the signature as seen by the\n     /// user - in particular, index 0 is not the implicit self parameter.\n-    crate fn get_argument_index_for_region(\n+    pub(crate) fn get_argument_index_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n@@ -107,7 +111,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Given the index of an argument, finds its name (if any) and the span from where it was\n     /// declared.\n-    crate fn get_argument_name_and_span_for_region(\n+    pub(crate) fn get_argument_name_and_span_for_region(\n         &self,\n         body: &Body<'tcx>,\n         local_names: &IndexVec<Local, Option<Symbol>>,"}, {"sha": "7f0a637c9d30bccfb4e9ce669011099aacfe606e", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -25,7 +25,7 @@ impl polonius_engine::FactTypes for RustcFacts {\n \n pub type AllFacts = PoloniusFacts<RustcFacts>;\n \n-crate trait AllFactsExt {\n+pub(crate) trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n     /// current `-Z` flags.\n     fn enabled(tcx: TyCtxt<'_>) -> bool;"}, {"sha": "a3e7c953ee3b04fb14143444a4ba66ccb1562131", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2,7 +2,6 @@\n \n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]"}, {"sha": "70a3116949894f7a8a423ca266277206a547a0a4", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -30,7 +30,7 @@ pub enum RichLocation {\n }\n \n impl LocationTable {\n-    crate fn new(body: &Body<'_>) -> Self {\n+    pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = body\n             .basic_blocks()"}, {"sha": "61838c41e393e98597ee8190d1167c1551204f92", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use std::ops::Index;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region `R0`.\n-crate struct MemberConstraintSet<'tcx, R>\n+pub(crate) struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Eq,\n {\n@@ -28,17 +28,17 @@ where\n }\n \n /// Represents a `R0 member of [R1..Rn]` constraint\n-crate struct NllMemberConstraint<'tcx> {\n+pub(crate) struct NllMemberConstraint<'tcx> {\n     next_constraint: Option<NllMemberConstraintIndex>,\n \n     /// The span where the hidden type was instantiated.\n-    crate definition_span: Span,\n+    pub(crate) definition_span: Span,\n \n     /// The hidden type in which `R0` appears. (Used in error reporting.)\n-    crate hidden_ty: Ty<'tcx>,\n+    pub(crate) hidden_ty: Ty<'tcx>,\n \n     /// The region `R0`.\n-    crate member_region_vid: ty::RegionVid,\n+    pub(crate) member_region_vid: ty::RegionVid,\n \n     /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n     start_index: usize,\n@@ -48,7 +48,7 @@ crate struct NllMemberConstraint<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    crate struct NllMemberConstraintIndex {\n+    pub(crate) struct NllMemberConstraintIndex {\n         DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n     }\n }\n@@ -73,7 +73,7 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     /// within into `RegionVid` format -- it typically consults the\n     /// `UniversalRegions` data structure that is known to the caller\n     /// (but which this code is unaware of).\n-    crate fn push_constraint(\n+    pub(crate) fn push_constraint(\n         &mut self,\n         m_c: &MemberConstraint<'tcx>,\n         mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n@@ -106,7 +106,7 @@ where\n     /// the original `RegionVid` to an scc index. In some cases, we\n     /// may have multiple `R1` values mapping to the same `R2` key -- that\n     /// is ok, the two sets will be merged.\n-    crate fn into_mapped<R2>(\n+    pub(crate) fn into_mapped<R2>(\n         self,\n         mut map_fn: impl FnMut(R1) -> R2,\n     ) -> MemberConstraintSet<'tcx, R2>\n@@ -144,14 +144,14 @@ impl<R> MemberConstraintSet<'_, R>\n where\n     R: Copy + Hash + Eq,\n {\n-    crate fn all_indices(&self) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n+    pub(crate) fn all_indices(&self) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n         self.constraints.indices()\n     }\n \n     /// Iterate down the constraint indices associated with a given\n     /// peek-region.  You can then use `choice_regions` and other\n     /// methods to access data.\n-    crate fn indices(\n+    pub(crate) fn indices(\n         &self,\n         member_region_vid: R,\n     ) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n@@ -172,7 +172,7 @@ where\n     /// ```text\n     /// R0 member of [R1..Rn]\n     /// ```\n-    crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n+    pub(crate) fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n         let NllMemberConstraint { start_index, end_index, .. } = &self.constraints[pci];\n         &self.choice_regions[*start_index..*end_index]\n     }"}, {"sha": "2440ae9780d230bacb50acdea0e082cbd9c12d37", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -42,7 +42,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n \n /// The output of `nll::compute_regions`. This includes the computed `RegionInferenceContext`, any\n /// closure requirements to propagate, and any generated errors.\n-crate struct NllOutput<'tcx> {\n+pub(crate) struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n     pub opaque_type_values: VecMap<DefId, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n@@ -457,6 +457,6 @@ impl ToRegionVid for RegionVid {\n     }\n }\n \n-crate trait ConstraintDescription {\n+pub(crate) trait ConstraintDescription {\n     fn description(&self) -> &'static str;\n }"}, {"sha": "93d202e49a159fc4173a852ce879d0941e3d16de", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::{Body, Mutability, Place};\n use rustc_middle::ty::{self, TyCtxt};\n \n /// Extension methods for the `Place` type.\n-crate trait PlaceExt<'tcx> {\n+pub(crate) trait PlaceExt<'tcx> {\n     /// Returns `true` if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true"}, {"sha": "97335fd0dffaeb4d28205c7adfd76654f4e4706e", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -14,15 +14,15 @@ use std::iter;\n /// being run in the calling context, the conservative choice is to assume the compared indices\n /// are disjoint (and therefore, do not overlap).\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum PlaceConflictBias {\n+pub(crate) enum PlaceConflictBias {\n     Overlap,\n     NoOverlap,\n }\n \n /// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n-crate fn places_conflict<'tcx>(\n+pub(crate) fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: Place<'tcx>,"}, {"sha": "f31ccd74ca6f72b198346dfcd908fa6e4ba8c057", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -11,12 +11,12 @@ use rustc_graphviz as dot;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph.\n-    crate fn dump_graphviz_raw_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+    pub(crate) fn dump_graphviz_raw_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n         dot::render(&RawConstraints { regioncx: self }, &mut w)\n     }\n \n     /// Write out the region constraint graph.\n-    crate fn dump_graphviz_scc_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+    pub(crate) fn dump_graphviz_scc_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n         let mut nodes_per_scc: IndexVec<ConstraintSccIndex, _> =\n             self.constraint_sccs.all_sccs().map(|_| Vec::new()).collect();\n "}, {"sha": "dc6337c54edd98838b5ea90967b4479f8c2cdf80", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -513,26 +513,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n+    pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n     /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    crate fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n+    pub(crate) fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    crate fn region_value_str(&self, r: RegionVid) -> String {\n+    pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_values.region_value_str(scc)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    crate fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n+    pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_universes[scc]\n     }\n@@ -1693,7 +1693,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   that cannot be named by `fr1`; in that case, we will require\n     ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n     ///   be satisfied. (See `add_incompatible_universe`.)\n-    crate fn provides_universal_region(\n+    pub(crate) fn provides_universal_region(\n         &self,\n         r: RegionVid,\n         fr1: RegionVid,\n@@ -1712,7 +1712,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If `r2` represents a placeholder region, then this returns\n     /// `true` if `r1` cannot name that placeholder in its\n     /// value; otherwise, returns `false`.\n-    crate fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+    pub(crate) fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n         debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n \n         match self.definitions[r2].origin {\n@@ -1731,7 +1731,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    crate fn retrieve_closure_constraint_info(\n+    pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n         _body: &Body<'tcx>,\n         constraint: &OutlivesConstraint<'tcx>,\n@@ -1766,7 +1766,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(\n+    pub(crate) fn find_outlives_blame_span(\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n@@ -1788,7 +1788,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns: a series of constraints as well as the region `R`\n     /// that passed the target test.\n-    crate fn find_constraint_paths_between_regions(\n+    pub(crate) fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n@@ -1882,7 +1882,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n     #[instrument(skip(self), level = \"trace\")]\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+    pub(crate) fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         trace!(scc = ?self.constraint_sccs.scc(fr1));\n         trace!(universe = ?self.scc_universes[self.constraint_sccs.scc(fr1)]);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n@@ -1919,7 +1919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Get the region outlived by `longer_fr` and live at `element`.\n-    crate fn region_from_element(\n+    pub(crate) fn region_from_element(\n         &self,\n         longer_fr: RegionVid,\n         element: &RegionElement,\n@@ -1939,17 +1939,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Get the region definition of `r`.\n-    crate fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n+    pub(crate) fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n         &self.definitions[r]\n     }\n \n     /// Check if the SCC of `r` contains `upper`.\n-    crate fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n+    pub(crate) fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n         let r_scc = self.constraint_sccs.scc(r);\n         self.scc_values.contains(r_scc, upper)\n     }\n \n-    crate fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n+    pub(crate) fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n         self.universal_regions.as_ref()\n     }\n \n@@ -1959,7 +1959,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// creating a constraint path that forces `R` to outlive\n     /// `from_region`, and then finding the best choices within that\n     /// path to blame.\n-    crate fn best_blame_constraint(\n+    pub(crate) fn best_blame_constraint(\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n@@ -2171,7 +2171,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.remove(0)\n     }\n \n-    crate fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+    pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         self.universe_causes[&universe].clone()\n     }\n }"}, {"sha": "1e6798eee3df8b056cf4379d05c8e294f2e54df7", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::RegionVid;\n use std::ops::Range;\n use std::rc::Rc;\n \n-crate struct ReverseSccGraph {\n+pub(crate) struct ReverseSccGraph {\n     graph: VecGraph<ConstraintSccIndex>,\n     /// For each SCC, the range of `universal_regions` that use that SCC as\n     /// their value."}, {"sha": "c81ef10f7c74008ac300cd421274285ada3a0a53", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -10,7 +10,7 @@ use std::fmt::Debug;\n use std::rc::Rc;\n \n /// Maps between a `Location` and a `PointIndex` (and vice versa).\n-crate struct RegionValueElements {\n+pub(crate) struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n \n@@ -22,7 +22,7 @@ crate struct RegionValueElements {\n }\n \n impl RegionValueElements {\n-    crate fn new(body: &Body<'_>) -> Self {\n+    pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block: IndexVec<BasicBlock, usize> = body\n             .basic_blocks()\n@@ -45,30 +45,30 @@ impl RegionValueElements {\n     }\n \n     /// Total number of point indices\n-    crate fn num_points(&self) -> usize {\n+    pub(crate) fn num_points(&self) -> usize {\n         self.num_points\n     }\n \n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    crate fn point_from_location(&self, location: Location) -> PointIndex {\n+    pub(crate) fn point_from_location(&self, location: Location) -> PointIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n         PointIndex::new(start_index + statement_index)\n     }\n \n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    crate fn entry_point(&self, block: BasicBlock) -> PointIndex {\n+    pub(crate) fn entry_point(&self, block: BasicBlock) -> PointIndex {\n         let start_index = self.statements_before_block[block];\n         PointIndex::new(start_index)\n     }\n \n     /// Return the PointIndex for the block start of this index.\n-    crate fn to_block_start(&self, index: PointIndex) -> PointIndex {\n+    pub(crate) fn to_block_start(&self, index: PointIndex) -> PointIndex {\n         PointIndex::new(self.statements_before_block[self.basic_blocks[index]])\n     }\n \n     /// Converts a `PointIndex` back to a location. O(1).\n-    crate fn to_location(&self, index: PointIndex) -> Location {\n+    pub(crate) fn to_location(&self, index: PointIndex) -> Location {\n         assert!(index.index() < self.num_points);\n         let block = self.basic_blocks[index];\n         let start_index = self.statements_before_block[block];\n@@ -80,7 +80,7 @@ impl RegionValueElements {\n     /// out of range (because they round up to the nearest 2^N number\n     /// of bits). Use this function to filter such points out if you\n     /// like.\n-    crate fn point_in_range(&self, index: PointIndex) -> bool {\n+    pub(crate) fn point_in_range(&self, index: PointIndex) -> bool {\n         index.index() < self.num_points\n     }\n }\n@@ -99,7 +99,7 @@ rustc_index::newtype_index! {\n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n #[derive(Debug, Clone)]\n-crate enum RegionElement {\n+pub(crate) enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n@@ -114,7 +114,7 @@ crate enum RegionElement {\n \n /// When we initially compute liveness, we use an interval matrix storing\n /// liveness ranges for each region-vid.\n-crate struct LivenessValues<N: Idx> {\n+pub(crate) struct LivenessValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     points: SparseIntervalMatrix<N, PointIndex>,\n }\n@@ -123,43 +123,43 @@ impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: Rc<RegionValueElements>) -> Self {\n+    pub(crate) fn new(elements: Rc<RegionValueElements>) -> Self {\n         Self { points: SparseIntervalMatrix::new(elements.num_points), elements }\n     }\n \n     /// Iterate through each region that has a value in this set.\n-    crate fn rows(&self) -> impl Iterator<Item = N> {\n+    pub(crate) fn rows(&self) -> impl Iterator<Item = N> {\n         self.points.rows()\n     }\n \n     /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(&mut self, row: N, location: Location) -> bool {\n+    pub(crate) fn add_element(&mut self, row: N, location: Location) -> bool {\n         debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n         let index = self.elements.point_from_location(location);\n         self.points.insert(row, index)\n     }\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns whether any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n+    pub(crate) fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_row(row, locations)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n-    crate fn add_all_points(&mut self, row: N) {\n+    pub(crate) fn add_all_points(&mut self, row: N) {\n         self.points.insert_all_into_row(row);\n     }\n \n     /// Returns `true` if the region `r` contains the given element.\n-    crate fn contains(&self, row: N, location: Location) -> bool {\n+    pub(crate) fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n         self.points.row(row).map_or(false, |r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`\n-    crate fn get_elements(&self, row: N) -> impl Iterator<Item = Location> + '_ {\n+    pub(crate) fn get_elements(&self, row: N) -> impl Iterator<Item = Location> + '_ {\n         self.points\n             .row(row)\n             .into_iter()\n@@ -169,7 +169,7 @@ impl<N: Idx> LivenessValues<N> {\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    crate fn region_value_str(&self, r: N) -> String {\n+    pub(crate) fn region_value_str(&self, r: N) -> String {\n         region_value_str(self.get_elements(r).map(RegionElement::Location))\n     }\n }\n@@ -178,25 +178,28 @@ impl<N: Idx> LivenessValues<N> {\n /// rustc to the internal `PlaceholderIndex` values that are used in\n /// NLL.\n #[derive(Default)]\n-crate struct PlaceholderIndices {\n+pub(crate) struct PlaceholderIndices {\n     indices: FxIndexSet<ty::PlaceholderRegion>,\n }\n \n impl PlaceholderIndices {\n-    crate fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n+    pub(crate) fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         let (index, _) = self.indices.insert_full(placeholder);\n         index.into()\n     }\n \n-    crate fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n+    pub(crate) fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         self.indices.get_index_of(&placeholder).unwrap().into()\n     }\n \n-    crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::PlaceholderRegion {\n+    pub(crate) fn lookup_placeholder(\n+        &self,\n+        placeholder: PlaceholderIndex,\n+    ) -> ty::PlaceholderRegion {\n         self.indices[placeholder.index()]\n     }\n \n-    crate fn len(&self) -> usize {\n+    pub(crate) fn len(&self) -> usize {\n         self.indices.len()\n     }\n }\n@@ -220,7 +223,7 @@ impl PlaceholderIndices {\n /// because (since it is returned) it must live for at least `'a`. But\n /// it would also contain various points from within the function.\n #[derive(Clone)]\n-crate struct RegionValues<N: Idx> {\n+pub(crate) struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     placeholder_indices: Rc<PlaceholderIndices>,\n     points: SparseIntervalMatrix<N, PointIndex>,\n@@ -235,7 +238,7 @@ impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(\n+    pub(crate) fn new(\n         elements: &Rc<RegionValueElements>,\n         num_universal_regions: usize,\n         placeholder_indices: &Rc<PlaceholderIndices>,\n@@ -252,41 +255,41 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n+    pub(crate) fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n         elem.add_to_row(self, r)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n-    crate fn add_all_points(&mut self, r: N) {\n+    pub(crate) fn add_all_points(&mut self, r: N) {\n         self.points.insert_all_into_row(r);\n     }\n \n     /// Adds all elements in `r_from` to `r_to` (because e.g., `r_to:\n     /// r_from`).\n-    crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n+    pub(crate) fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.points.union_rows(r_from, r_to)\n             | self.free_regions.union_rows(r_from, r_to)\n             | self.placeholders.union_rows(r_from, r_to)\n     }\n \n     /// Returns `true` if the region `r` contains the given element.\n-    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n+    pub(crate) fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         elem.contained_in_row(self, r)\n     }\n \n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`.\n-    crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n+    pub(crate) fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n             self.points.union_row(to, set);\n         }\n     }\n \n     /// Returns `true` if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n+    pub(crate) fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         if let Some(sub_row) = self.points.row(sub_region) {\n             if let Some(sup_row) = self.points.row(sup_region) {\n                 sup_row.superset(sub_row)\n@@ -301,7 +304,7 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns the locations contained within a given region `r`.\n-    crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n+    pub(crate) fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n         self.points.row(r).into_iter().flat_map(move |set| {\n             set.iter()\n                 .take_while(move |&p| self.elements.point_in_range(p))\n@@ -310,15 +313,15 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n-    crate fn universal_regions_outlived_by<'a>(\n+    pub(crate) fn universal_regions_outlived_by<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n         self.free_regions.row(r).into_iter().flat_map(|set| set.iter())\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn placeholders_contained_in<'a>(\n+    pub(crate) fn placeholders_contained_in<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n@@ -330,7 +333,10 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n+    pub(crate) fn elements_contained_in<'a>(\n+        &'a self,\n+        r: N,\n+    ) -> impl Iterator<Item = RegionElement> + 'a {\n         let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n \n         let free_regions_iter =\n@@ -343,12 +349,12 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    crate fn region_value_str(&self, r: N) -> String {\n+    pub(crate) fn region_value_str(&self, r: N) -> String {\n         region_value_str(self.elements_contained_in(r))\n     }\n }\n \n-crate trait ToElementIndex: Debug + Copy {\n+pub(crate) trait ToElementIndex: Debug + Copy {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool;\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool;\n@@ -388,7 +394,7 @@ impl ToElementIndex for ty::PlaceholderRegion {\n     }\n }\n \n-crate fn location_set_str(\n+pub(crate) fn location_set_str(\n     elements: &RegionValueElements,\n     points: impl IntoIterator<Item = PointIndex>,\n ) -> String {"}, {"sha": "f11a94d7ddd2333d815a5292926ba145282fb7b6", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     universal_regions::UniversalRegions,\n };\n \n-crate struct ConstraintConversion<'a, 'tcx> {\n+pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n@@ -32,7 +32,7 @@ crate struct ConstraintConversion<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,"}, {"sha": "670b5549afc1d7a9c3cab156261e98e7f7fc8859", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -19,7 +19,7 @@ use crate::{\n };\n \n #[derive(Debug)]\n-crate struct UniversalRegionRelations<'tcx> {\n+pub(crate) struct UniversalRegionRelations<'tcx> {\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Stores the outlives relations that are known to hold from the\n@@ -52,13 +52,13 @@ type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n /// then the output type as the last element.\n type NormalizedInputsAndOutput<'tcx> = Vec<Ty<'tcx>>;\n \n-crate struct CreateResult<'tcx> {\n-    crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate region_bound_pairs: RegionBoundPairs<'tcx>,\n-    crate normalized_inputs_and_output: NormalizedInputsAndOutput<'tcx>,\n+pub(crate) struct CreateResult<'tcx> {\n+    pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n+    pub(crate) region_bound_pairs: RegionBoundPairs<'tcx>,\n+    pub(crate) normalized_inputs_and_output: NormalizedInputsAndOutput<'tcx>,\n }\n \n-crate fn create<'tcx>(\n+pub(crate) fn create<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -96,7 +96,7 @@ impl UniversalRegionRelations<'_> {\n     ///\n     /// (See `TransitiveRelation::postdom_upper_bound` for details on\n     /// the postdominating upper bound in general.)\n-    crate fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+    pub(crate) fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n         assert!(self.universal_regions.is_universal_region(fr1));\n         assert!(self.universal_regions.is_universal_region(fr2));\n         self.inverse_outlives\n@@ -109,7 +109,7 @@ impl UniversalRegionRelations<'_> {\n     /// outlives `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we return all of them.\n-    crate fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n+    pub(crate) fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n         let res = self.non_local_bounds(&self.inverse_outlives, fr);\n         assert!(!res.is_empty(), \"can't find an upper bound!?\");\n@@ -118,7 +118,7 @@ impl UniversalRegionRelations<'_> {\n \n     /// Returns the \"postdominating\" bound of the set of\n     /// `non_local_upper_bounds` for the given region.\n-    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n         let upper_bounds = self.non_local_upper_bounds(fr);\n \n         // In case we find more than one, reduce to one for\n@@ -147,7 +147,7 @@ impl UniversalRegionRelations<'_> {\n     ///\n     /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+    pub(crate) fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n         let lower_bounds = self.non_local_bounds(&self.outlives, fr);\n \n@@ -203,18 +203,18 @@ impl UniversalRegionRelations<'_> {\n     /// Returns `true` if fr1 is known to outlive fr2.\n     ///\n     /// This will only ever be true for universally quantified regions.\n-    crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+    pub(crate) fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n         self.outlives.contains(fr1, fr2)\n     }\n \n     /// Returns a vector of free regions `x` such that `fr1: x` is\n     /// known to hold.\n-    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<RegionVid> {\n+    pub(crate) fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<RegionVid> {\n         self.outlives.reachable_from(fr1)\n     }\n \n     /// Returns the _non-transitive_ set of known `outlives` constraints between free regions.\n-    crate fn known_outlives(&self) -> impl Iterator<Item = (RegionVid, RegionVid)> + '_ {\n+    pub(crate) fn known_outlives(&self) -> impl Iterator<Item = (RegionVid, RegionVid)> + '_ {\n         self.outlives.base_edges()\n     }\n }\n@@ -232,7 +232,7 @@ struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n }\n \n impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n-    crate fn create(mut self) -> CreateResult<'tcx> {\n+    pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions\n             .unnormalized_input_tys"}, {"sha": "b88f6e689cc80c4a334bbf3879db4dbaf9c6b4d9", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -18,7 +18,7 @@ use crate::region_infer::values::{PointIndex, RegionValueElements};\n /// (and code simplicity) was favored. The rationale is that we only keep\n /// a small number of `IndexVec`s throughout the entire analysis while, in\n /// contrast, we're accessing each `Local` *many* times.\n-crate struct LocalUseMap {\n+pub(crate) struct LocalUseMap {\n     /// Head of a linked list of **definitions** of each variable --\n     /// definition in this context means assignment, e.g., `x` is\n     /// defined in `x = y` but not `y`; that first def is the head of\n@@ -58,7 +58,11 @@ impl vll::LinkElem for Appearance {\n }\n \n impl LocalUseMap {\n-    crate fn build(live_locals: &[Local], elements: &RegionValueElements, body: &Body<'_>) -> Self {\n+    pub(crate) fn build(\n+        live_locals: &[Local],\n+        elements: &RegionValueElements,\n+        body: &Body<'_>,\n+    ) -> Self {\n         let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),\n@@ -81,17 +85,17 @@ impl LocalUseMap {\n         local_use_map\n     }\n \n-    crate fn defs(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn defs(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_def_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn uses(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn uses(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_use_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn drops(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn drops(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_drop_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }"}, {"sha": "405fd9198d354a1dffee44bdb4247704ca9cf3e9", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -94,7 +94,7 @@ mod canonical;\n mod constraint_conversion;\n pub mod free_region_relations;\n mod input_output;\n-crate mod liveness;\n+pub(crate) mod liveness;\n mod relate_tys;\n \n /// Type checks the given `mir` in the context of the inference\n@@ -897,28 +897,29 @@ struct BorrowCheckContext<'a, 'tcx> {\n     upvars: &'a [Upvar<'tcx>],\n }\n \n-crate struct MirTypeckResults<'tcx> {\n-    crate constraints: MirTypeckRegionConstraints<'tcx>,\n-    crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+pub(crate) struct MirTypeckResults<'tcx> {\n+    pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n+    pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n+    pub(crate) opaque_type_values:\n+        VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n-crate struct MirTypeckRegionConstraints<'tcx> {\n+pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     /// Maps from a `ty::Placeholder` to the corresponding\n     /// `PlaceholderIndex` bit that we will use for it.\n     ///\n     /// To keep everything in sync, do not insert this set\n     /// directly. Instead, use the `placeholder_region` helper.\n-    crate placeholder_indices: PlaceholderIndices,\n+    pub(crate) placeholder_indices: PlaceholderIndices,\n \n     /// Each time we add a placeholder to `placeholder_indices`, we\n     /// also create a corresponding \"representative\" region vid for\n     /// that wraps it. This vector tracks those. This way, when we\n     /// convert the same `ty::RePlaceholder(p)` twice, we can map to\n     /// the same underlying `RegionVid`.\n-    crate placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n+    pub(crate) placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n \n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n@@ -927,18 +928,18 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_constraints: LivenessValues<RegionVid>,\n+    pub(crate) liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: OutlivesConstraintSet<'tcx>,\n+    pub(crate) outlives_constraints: OutlivesConstraintSet<'tcx>,\n \n-    crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n+    pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    crate closure_bounds_mapping:\n+    pub(crate) closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n-    crate universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n-    crate type_tests: Vec<TypeTest<'tcx>>,\n+    pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n }\n \n impl<'tcx> MirTypeckRegionConstraints<'tcx> {"}, {"sha": "7b63ec516b8c44c4561190cf9be2558bde94bb63", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n+    pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!("}, {"sha": "cdbb60b878a6cfd04210928a74d5533a8cdcfa35", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -22,7 +22,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///  been assigned to - this set is used as a proxy for locals that were not initialized due to\n     ///  unreachable code. These locals are then considered \"used\" to silence the lint for them.\n     ///  See #55344 for context.\n-    crate fn gather_used_muts(\n+    pub(crate) fn gather_used_muts(\n         &mut self,\n         temporary_used_locals: FxHashSet<Local>,\n         mut never_initialized_mut_locals: FxHashSet<Local>,"}, {"sha": "cb5359dd1e27e6b6bfc9c58337ccf0c07ce5b417", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -7,7 +7,7 @@ use rustc_parse::validate_attr;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-crate struct Expander;\n+pub(crate) struct Expander;\n \n fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n     match mi.meta_item_list() {"}, {"sha": "6485c82a119e2c00d0ce8e25abd5fcb38d1ea42a", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -19,7 +19,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use smallvec::SmallVec;\n \n-crate fn expand(\n+pub(crate) fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     _span: Span,\n     meta_item: &ast::MetaItem,\n@@ -30,7 +30,7 @@ crate fn expand(\n     vec![cfg_eval(ecx.sess, ecx.ecfg.features, annotatable, ecx.current_expansion.lint_node_id)]\n }\n \n-crate fn cfg_eval(\n+pub(crate) fn cfg_eval(\n     sess: &Session,\n     features: Option<&Features>,\n     annotatable: Annotatable,"}, {"sha": "7f25b23734b3eb20a9e3b6c483e69bba4300c835", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n-crate struct Expander;\n+pub(crate) struct Expander;\n \n impl MultiItemModifier for Expander {\n     fn expand("}, {"sha": "c678c8cbd159ee8f54e138f2b7dc8d33fbc05b1e", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -38,8 +38,8 @@ pub mod partial_ord;\n \n pub mod generic;\n \n-crate struct BuiltinDerive(\n-    crate fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n+pub(crate) struct BuiltinDerive(\n+    pub(crate) fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n );\n \n impl MultiItemModifier for BuiltinDerive {"}, {"sha": "0c9e3c22bcf3c43a875b91559b2bcc44e45733bd", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -4,7 +4,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(is_sorted)]\n #![feature(nll)]"}, {"sha": "c7497bfd355e5f042192ca9e067bf5a3929e2df4", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -354,14 +354,14 @@ fn fat_lto(\n     Ok(LtoModuleCodegen::Fat { module, _serialized_bitcode: serialized_bitcode })\n }\n \n-crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n+pub(crate) struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n impl<'a> Linker<'a> {\n-    crate fn new(llmod: &'a llvm::Module) -> Self {\n+    pub(crate) fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n-    crate fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+    pub(crate) fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n         unsafe {\n             if llvm::LLVMRustLinkerAdd(\n                 self.0,"}, {"sha": "839018e2a759f880289c8608eba7524f19aa9cb1", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1412,7 +1412,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n     }\n \n-    crate fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n+    pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n         self.call(ty, f, args, None)\n     }"}, {"sha": "5bbbfe9a4ab781ae7843bf9b955c7fe713097271", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -212,11 +212,11 @@ pub fn ptrcast<'ll>(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    pub(crate) fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMConstBitCast(val, ty) }\n     }\n \n-    crate fn static_addr_of_mut(\n+    pub(crate) fn static_addr_of_mut(\n         &self,\n         cv: &'ll Value,\n         align: Align,\n@@ -241,7 +241,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn get_static(&self, def_id: DefId) -> &'ll Value {\n+    pub(crate) fn get_static(&self, def_id: DefId) -> &'ll Value {\n         let instance = Instance::mono(self.tcx, def_id);\n         if let Some(&g) = self.instances.borrow().get(&instance) {\n             return g;"}, {"sha": "5544f0d3f6058c0ebe9384d35bb66fe87cd94197", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -330,7 +330,7 @@ pub unsafe fn create_module<'ll>(\n }\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         codegen_unit: &'tcx CodegenUnit<'tcx>,\n         llvm_module: &'ll crate::ModuleLlvm,\n@@ -447,7 +447,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    crate fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n+    pub(crate) fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n         &self.statics_to_rauw\n     }\n \n@@ -599,7 +599,7 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn get_intrinsic(&self, key: &str) -> (&'ll Type, &'ll Value) {\n+    pub(crate) fn get_intrinsic(&self, key: &str) -> (&'ll Type, &'ll Value) {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -890,7 +890,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         None\n     }\n \n-    crate fn eh_catch_typeinfo(&self) -> &'ll Value {\n+    pub(crate) fn eh_catch_typeinfo(&self) -> &'ll Value {\n         if let Some(eh_catch_typeinfo) = self.eh_catch_typeinfo.get() {\n             return eh_catch_typeinfo;\n         }"}, {"sha": "2b5154a2cf97787b24ea9f7880689f3da1b8f181", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(extern_types)]"}, {"sha": "37409dbb447005486acc686409a8f1271e2b5ee5", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -775,7 +775,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        crate fn code_region(\n+        pub(crate) fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -799,7 +799,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn branch_region(\n+        pub(crate) fn branch_region(\n             counter: coverage_map::Counter,\n             false_counter: coverage_map::Counter,\n             file_id: u32,\n@@ -824,7 +824,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn expansion_region(\n+        pub(crate) fn expansion_region(\n             file_id: u32,\n             expanded_file_id: u32,\n             start_line: u32,\n@@ -848,7 +848,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn skipped_region(\n+        pub(crate) fn skipped_region(\n             file_id: u32,\n             start_line: u32,\n             start_col: u32,\n@@ -871,7 +871,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn gap_region(\n+        pub(crate) fn gap_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,"}, {"sha": "cf2d3c423c335f6e1a674efcd7907e6c7ce994f1", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -39,33 +39,33 @@ impl fmt::Debug for Type {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn type_named_struct(&self, name: &str) -> &'ll Type {\n+    pub(crate) fn type_named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe { llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr()) }\n     }\n \n-    crate fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n+    pub(crate) fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n         unsafe { llvm::LLVMStructSetBody(ty, els.as_ptr(), els.len() as c_uint, packed as Bool) }\n     }\n \n-    crate fn type_void(&self) -> &'ll Type {\n+    pub(crate) fn type_void(&self) -> &'ll Type {\n         unsafe { llvm::LLVMVoidTypeInContext(self.llcx) }\n     }\n \n-    crate fn type_metadata(&self) -> &'ll Type {\n+    pub(crate) fn type_metadata(&self) -> &'ll Type {\n         unsafe { llvm::LLVMRustMetadataTypeInContext(self.llcx) }\n     }\n \n     ///x Creates an integer type with the given number of bits, e.g., i24\n-    crate fn type_ix(&self, num_bits: u64) -> &'ll Type {\n+    pub(crate) fn type_ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe { llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint) }\n     }\n \n-    crate fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    pub(crate) fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe { llvm::LLVMVectorType(ty, len as c_uint) }\n     }\n \n-    crate fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n+    pub(crate) fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n             let mut args = Vec::with_capacity(n_args);\n@@ -75,11 +75,11 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_bool(&self) -> &'ll Type {\n+    pub(crate) fn type_bool(&self) -> &'ll Type {\n         self.type_i8()\n     }\n \n-    crate fn type_int_from_ty(&self, t: ty::IntTy) -> &'ll Type {\n+    pub(crate) fn type_int_from_ty(&self, t: ty::IntTy) -> &'ll Type {\n         match t {\n             ty::IntTy::Isize => self.type_isize(),\n             ty::IntTy::I8 => self.type_i8(),\n@@ -90,7 +90,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_uint_from_ty(&self, t: ty::UintTy) -> &'ll Type {\n+    pub(crate) fn type_uint_from_ty(&self, t: ty::UintTy) -> &'ll Type {\n         match t {\n             ty::UintTy::Usize => self.type_isize(),\n             ty::UintTy::U8 => self.type_i8(),\n@@ -101,34 +101,34 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_float_from_ty(&self, t: ty::FloatTy) -> &'ll Type {\n+    pub(crate) fn type_float_from_ty(&self, t: ty::FloatTy) -> &'ll Type {\n         match t {\n             ty::FloatTy::F32 => self.type_f32(),\n             ty::FloatTy::F64 => self.type_f64(),\n         }\n     }\n \n-    crate fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n+    pub(crate) fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    crate fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+    pub(crate) fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n         let unit = Integer::approximate_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n         self.type_array(self.type_from_integer(unit), size / unit_size)\n     }\n \n-    crate fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    pub(crate) fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n         unsafe { llvm::LLVMFunctionType(ret, args.as_ptr(), args.len() as c_uint, True) }\n     }\n \n-    crate fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    pub(crate) fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe { llvm::LLVMRustArrayType(ty, len) }\n     }\n }"}, {"sha": "9e5b00462f3a6e1008c5b3b3077194243661e006", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -163,7 +163,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n+pub(crate) type CompileTimeEvalContext<'mir, 'tcx> =\n     InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]"}, {"sha": "5e0d1abd6c1df2639bb1edc66ed1de5da74141e4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -44,7 +44,7 @@ fn numeric_intrinsic<Tag>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<T\n \n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n /// inside an `InterpCx` and instead have their value computed directly from rustc internal info.\n-crate fn eval_nullary_intrinsic<'tcx>(\n+pub(crate) fn eval_nullary_intrinsic<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     def_id: DefId,"}, {"sha": "e66cb9837c999d9ef02b780ea24a9d99f386a5dc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,7 +15,7 @@ use crate::interpret::{\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n-    crate fn find_closest_untracked_caller_location(&self) -> Span {\n+    pub(crate) fn find_closest_untracked_caller_location(&self) -> Span {\n         for frame in self.stack().iter().rev() {\n             debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n \n@@ -74,7 +74,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers.\n-    crate fn alloc_caller_location(\n+    pub(crate) fn alloc_caller_location(\n         &mut self,\n         filename: Symbol,\n         line: u32,\n@@ -113,7 +113,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    crate fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "f9847742f0883c8af1e53b5fa3895e0bdf6c658d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -189,7 +189,7 @@ impl Write for AbsolutePathPrinter<'_> {\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-crate fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n+pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "2b73ad568e0eedc8fa8953edb1d4836bdb37be4f", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -29,5 +29,5 @@ pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};\n pub use self::visitor::{MutValueVisitor, Value, ValueVisitor};\n \n-crate use self::intrinsics::eval_nullary_intrinsic;\n+pub(crate) use self::intrinsics::eval_nullary_intrinsic;\n use eval_context::{from_known_layout, mir_assign_valid_types};"}, {"sha": "f5e1ee4e233153a65aa56b626f61adebe5e22b15", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -643,7 +643,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    crate fn const_val_to_op(\n+    pub(crate) fn const_val_to_op(\n         &self,\n         val_val: ConstValue<'tcx>,\n         ty: Ty<'tcx>,"}, {"sha": "1940b573db0d6e4842b33117d45d1f0ffa846db3", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use std::ops::ControlFlow;\n /// In case it does, returns a `TooGeneric` const eval error. Note that due to polymorphization\n /// types may be \"concrete enough\" even though they still contain generic parameters in\n /// case these parameters are unused.\n-crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n+pub(crate) fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "eacb5978d993a18dcc76afd0abd17c025689fd5e", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -7,7 +7,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(let_else)]"}, {"sha": "f130b5aa9a6b17244d4e140ea76709dba39c016d", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -90,7 +90,7 @@ pub trait AddSubdiagnostic {\n pub struct Diagnostic {\n     // NOTE(eddyb) this is private to disallow arbitrary after-the-fact changes,\n     // outside of what methods in this crate themselves allow.\n-    crate level: Level,\n+    pub(crate) level: Level,\n \n     pub message: Vec<(DiagnosticMessage, Style)>,\n     pub code: Option<DiagnosticId>,"}, {"sha": "6ef2c832c6526166f9a41e6bdda16d4412756ed2", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -88,7 +88,7 @@ mod sealed_level_is_error {\n     use crate::Level;\n \n     /// Sealed helper trait for statically checking that a `Level` is an error.\n-    crate trait IsError<const L: Level> {}\n+    pub(crate) trait IsError<const L: Level> {}\n \n     impl IsError<{ Level::Bug }> for () {}\n     impl IsError<{ Level::DelayedBug }> for () {}\n@@ -101,7 +101,7 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n+    pub(crate) fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n         handler: &'a Handler,\n         message: M,\n     ) -> Self\n@@ -168,7 +168,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new<M: Into<DiagnosticMessage>>(\n+    pub(crate) fn new<M: Into<DiagnosticMessage>>(\n         handler: &'a Handler,\n         level: Level,\n         message: M,\n@@ -179,7 +179,7 @@ impl<'a> DiagnosticBuilder<'a, ()> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+    pub(crate) fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n             inner: DiagnosticBuilderInner {\n@@ -210,14 +210,14 @@ impl EmissionGuarantee for () {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+    pub(crate) fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)\n     }\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    crate fn new_diagnostic_fatal(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+    pub(crate) fn new_diagnostic_fatal(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n             inner: DiagnosticBuilderInner {"}, {"sha": "d2f50d5df54655aed349625e87a4df56f7050409", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -3,7 +3,6 @@\n //! This module contains the code for creating and emitting diagnostics.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(backtrace)]\n #![feature(if_let_guard)]"}, {"sha": "6ef03d1243d1d060b60882feb20b733396dc9a87", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -28,7 +28,7 @@ use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n-crate use rustc_span::hygiene::MacroKind;\n+pub(crate) use rustc_span::hygiene::MacroKind;\n \n // When adding new variants, make sure to\n // adjust the `visit_*` / `flat_map_*` calls in `InvocationCollector`"}, {"sha": "3cada372570851c44e7dfe48c5fd640061ca286d", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -347,7 +347,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    crate fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n+    pub(crate) fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n         let Some((cfg_predicate, expanded_attrs)) =\n             rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) else {\n                 return vec![];\n@@ -451,7 +451,7 @@ impl<'a> StripUnconfigured<'a> {\n         attrs.iter().all(|attr| !is_cfg(attr) || self.cfg_true(attr))\n     }\n \n-    crate fn cfg_true(&self, attr: &Attribute) -> bool {\n+    pub(crate) fn cfg_true(&self, attr: &Attribute) -> bool {\n         let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n             Ok(meta_item) => meta_item,\n             Err(mut err) => {\n@@ -465,7 +465,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    pub(crate) fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,"}, {"sha": "676abc92b633fd77b948cd06f4ab1c73ae2f7cdc", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -214,7 +214,7 @@ pub enum SupportsMacroExpansion {\n }\n \n impl AstFragmentKind {\n-    crate fn dummy(self, span: Span) -> AstFragment {\n+    pub(crate) fn dummy(self, span: Span) -> AstFragment {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n "}, {"sha": "7043ad5464530391711ebf3658520d4d3dced6f3", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]\n@@ -21,7 +20,7 @@ mod placeholders;\n mod proc_macro_server;\n \n pub use mbe::macro_rules::compile_declarative_macro;\n-crate use rustc_span::hygiene;\n+pub(crate) use rustc_span::hygiene;\n pub mod base;\n pub mod build;\n #[macro_use]\n@@ -30,7 +29,7 @@ pub mod expand;\n pub mod module;\n pub mod proc_macro;\n \n-crate mod mbe;\n+pub(crate) mod mbe;\n \n // HACK(Centril, #64197): These shouldn't really be here.\n // Rather, they should be with their respective modules which are defined in other crates."}, {"sha": "f42576b16f5204d13f2a2ed69c6d34b8c0eb0e19", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -3,12 +3,12 @@\n //! why we call this module `mbe`. For external documentation, prefer the\n //! official terminology: \"declarative macros\".\n \n-crate mod macro_check;\n-crate mod macro_parser;\n-crate mod macro_rules;\n-crate mod metavar_expr;\n-crate mod quoted;\n-crate mod transcribe;\n+pub(crate) mod macro_check;\n+pub(crate) mod macro_parser;\n+pub(crate) mod macro_rules;\n+pub(crate) mod metavar_expr;\n+pub(crate) mod quoted;\n+pub(crate) mod transcribe;\n \n use metavar_expr::MetaVarExpr;\n use rustc_ast::token::{Delimiter, NonterminalKind, Token, TokenKind};"}, {"sha": "0631a5e42c25d730bd282165d718b1ef25176566", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -70,8 +70,8 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n-crate use NamedMatch::*;\n-crate use ParseResult::*;\n+pub(crate) use NamedMatch::*;\n+pub(crate) use ParseResult::*;\n \n use crate::mbe::{KleeneOp, TokenTree};\n \n@@ -262,7 +262,7 @@ enum EofMatcherPositions {\n }\n \n /// Represents the possible results of an attempted parse.\n-crate enum ParseResult<T> {\n+pub(crate) enum ParseResult<T> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n@@ -276,7 +276,7 @@ crate enum ParseResult<T> {\n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n+pub(crate) type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n \n /// Count how many metavars declarations are in `matcher`.\n pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n@@ -340,7 +340,7 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n /// ])\n /// ```\n #[derive(Debug, Clone)]\n-crate enum NamedMatch {\n+pub(crate) enum NamedMatch {\n     MatchedSeq(Vec<NamedMatch>),\n \n     // A metavar match of type `tt`."}, {"sha": "b16fa7111c51941236bf430345260128aee3d66b", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -33,7 +33,7 @@ use std::collections::hash_map::Entry;\n use std::{mem, slice};\n use tracing::debug;\n \n-crate struct ParserAnyMacro<'a> {\n+pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n@@ -47,7 +47,7 @@ crate struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-crate fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n+pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n     match kind {\n         AstFragmentKind::Ty => {\n             err.span_label(span, \"this macro call doesn't expand to a type\");\n@@ -113,7 +113,7 @@ fn emit_frag_parse_err(\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n+    pub(crate) fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro {\n             site_span,\n             macro_ident,"}, {"sha": "ccc1c2b2ca05b37d81b27c23b08adf4dd9d2595c", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::Span;\n \n /// A meta-variable expression, for expansions based on properties of meta-variables.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n-crate enum MetaVarExpr {\n+pub(crate) enum MetaVarExpr {\n     /// The number of repetitions of an identifier, optionally limited to a number\n     /// of outer-most repetition depths. If the depth limit is `None` then the depth is unlimited.\n     Count(Ident, Option<usize>),\n@@ -28,7 +28,7 @@ crate enum MetaVarExpr {\n \n impl MetaVarExpr {\n     /// Attempt to parse a meta-variable expression from a token stream.\n-    crate fn parse<'sess>(\n+    pub(crate) fn parse<'sess>(\n         input: &TokenStream,\n         outer_span: Span,\n         sess: &'sess ParseSess,\n@@ -62,7 +62,7 @@ impl MetaVarExpr {\n         Ok(rslt)\n     }\n \n-    crate fn ident(&self) -> Option<Ident> {\n+    pub(crate) fn ident(&self) -> Option<Ident> {\n         match *self {\n             MetaVarExpr::Count(ident, _) | MetaVarExpr::Ignore(ident) => Some(ident),\n             MetaVarExpr::Index(..) | MetaVarExpr::Length(..) => None,"}, {"sha": "876faad33b678d2e4aa9bc6a3008080e9e63ccd6", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -26,7 +26,7 @@ pub struct ModulePathSuccess {\n     pub dir_ownership: DirOwnership,\n }\n \n-crate struct ParsedExternalMod {\n+pub(crate) struct ParsedExternalMod {\n     pub items: Vec<P<Item>>,\n     pub spans: ModSpans,\n     pub file_path: PathBuf,\n@@ -42,7 +42,7 @@ pub enum ModError<'a> {\n     ParserError(DiagnosticBuilder<'a, ErrorGuaranteed>),\n }\n \n-crate fn parse_external_mod(\n+pub(crate) fn parse_external_mod(\n     sess: &Session,\n     ident: Ident,\n     span: Span, // The span to blame on errors.\n@@ -78,7 +78,7 @@ crate fn parse_external_mod(\n     ParsedExternalMod { items, spans, file_path, dir_path, dir_ownership }\n }\n \n-crate fn mod_dir_path(\n+pub(crate) fn mod_dir_path(\n     sess: &Session,\n     ident: Ident,\n     attrs: &[Attribute],"}, {"sha": "8b7153776e4dc6580aef89db7bc4afa6973aada3", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -22,7 +22,7 @@ fn string_to_parser(ps: &ParseSess, source_str: String) -> Parser<'_> {\n     new_parser_from_source_str(ps, PathBuf::from(\"bogofile\").into(), source_str)\n }\n \n-crate fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n+pub(crate) fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n where\n     F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n {\n@@ -33,7 +33,7 @@ where\n }\n \n /// Maps a string to tts, using a made-up filename.\n-crate fn string_to_stream(source_str: String) -> TokenStream {\n+pub(crate) fn string_to_stream(source_str: String) -> TokenStream {\n     let ps = ParseSess::new(FilePathMapping::empty());\n     source_file_to_stream(\n         &ps,\n@@ -44,7 +44,7 @@ crate fn string_to_stream(source_str: String) -> TokenStream {\n }\n \n /// Parses a string, returns a crate.\n-crate fn string_to_crate(source_str: String) -> ast::Crate {\n+pub(crate) fn string_to_crate(source_str: String) -> ast::Crate {\n     let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| p.parse_crate_mod())\n }\n@@ -53,7 +53,7 @@ crate fn string_to_crate(source_str: String) -> ast::Crate {\n /// may be deleted or replaced with other whitespace to match the pattern.\n /// This function is relatively Unicode-ignorant; fortunately, the careful design\n /// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n-crate fn matches_codepattern(a: &str, b: &str) -> bool {\n+pub(crate) fn matches_codepattern(a: &str, b: &str) -> bool {\n     let mut a_iter = a.chars().peekable();\n     let mut b_iter = b.chars().peekable();\n \n@@ -109,7 +109,7 @@ struct SpanLabel {\n     label: &'static str,\n }\n \n-crate struct Shared<T: Write> {\n+pub(crate) struct Shared<T: Write> {\n     pub data: Arc<Mutex<T>>,\n }\n "}, {"sha": "c39f2840a5917d0be08e4704db500ab048e47076", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-crate use crate::hir_id::{HirId, ItemLocalId};\n+pub(crate) use crate::hir_id::{HirId, ItemLocalId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n "}, {"sha": "7833571f88d4348efdf242cbdcd1859a2b1a7d3d", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -4,7 +4,6 @@\n \n #![feature(associated_type_defaults)]\n #![feature(const_btree_new)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(min_specialization)]"}, {"sha": "3d50ed2096e50e1da474c1a17e5515fbb092b825", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2705,7 +2705,7 @@ impl SymbolName {\n }\n \n impl ClashingExternDeclarations {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         ClashingExternDeclarations { seen_decls: FxHashMap::default() }\n     }\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists"}, {"sha": "772ab7fe22608248949ac523d3907b14e18df8b9", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -34,7 +34,7 @@ use tracing::debug;\n \n /// Extract the `LintStore` from the query context.\n /// This function exists because we've erased `LintStore` as `dyn Any` in the context.\n-crate fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n+pub(crate) fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n     let store: &dyn Any = &*tcx.lint_store;\n     store.downcast_ref().unwrap()\n }"}, {"sha": "7c68429e1e902dc2b5277340e14526253e9688cd", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -30,7 +30,6 @@\n #![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(iter_intersperse)]\n #![feature(iter_order_by)]"}, {"sha": "55b1ba9cd964a5b80cf987d0767ff0ca049dd785", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -651,7 +651,7 @@ declare_lint! {\n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n #[derive(Clone, Copy)]\n-crate enum CItemKind {\n+pub(crate) enum CItemKind {\n     Declaration,\n     Definition,\n }\n@@ -667,7 +667,10 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+pub(crate) fn nonnull_optimization_guaranteed<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::AdtDef<'tcx>,\n+) -> bool {\n     tcx.has_attr(def.did(), sym::rustc_nonnull_optimization_guaranteed)\n }\n \n@@ -766,7 +769,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n /// FIXME: This duplicates code in codegen.\n-crate fn repr_nullable_ptr<'tcx>(\n+pub(crate) fn repr_nullable_ptr<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n     ckind: CItemKind,"}, {"sha": "dfc675a0494b125c6d0463d5f8bda51356a8c767", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -70,7 +70,7 @@ pub enum LoadedMacro {\n     ProcMacro(SyntaxExtension),\n }\n \n-crate struct Library {\n+pub(crate) struct Library {\n     pub source: CrateSource,\n     pub metadata: MetadataBlob,\n }\n@@ -82,7 +82,7 @@ enum LoadResult {\n \n /// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n #[derive(Clone, Copy)]\n-crate struct CrateMetadataRef<'a> {\n+pub(crate) struct CrateMetadataRef<'a> {\n     pub cdata: &'a CrateMetadata,\n     pub cstore: &'a CStore,\n }\n@@ -133,7 +133,7 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n+    pub(crate) fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n         let cdata = self.metas[cnum]\n             .as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum));\n@@ -145,7 +145,7 @@ impl CStore {\n         self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n-    crate fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n+    pub(crate) fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n         self.metas\n             .iter_enumerated()\n             .filter_map(|(cnum, data)| data.as_ref().map(|data| (cnum, &**data)))\n@@ -164,7 +164,7 @@ impl CStore {\n         }\n     }\n \n-    crate fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n+    pub(crate) fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n         let mut deps = Vec::new();\n         if cnum == LOCAL_CRATE {\n             for (cnum, _) in self.iter_crate_data() {\n@@ -182,15 +182,15 @@ impl CStore {\n         deps\n     }\n \n-    crate fn injected_panic_runtime(&self) -> Option<CrateNum> {\n+    pub(crate) fn injected_panic_runtime(&self) -> Option<CrateNum> {\n         self.injected_panic_runtime\n     }\n \n-    crate fn allocator_kind(&self) -> Option<AllocatorKind> {\n+    pub(crate) fn allocator_kind(&self) -> Option<AllocatorKind> {\n         self.allocator_kind\n     }\n \n-    crate fn has_global_allocator(&self) -> bool {\n+    pub(crate) fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n "}, {"sha": "245b2076ebca96bbadcfda0bbd9bd05162c38ce4", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -62,7 +62,7 @@ use rustc_session::cstore::CrateDepKind;\n use rustc_session::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n use rustc_target::spec::PanicStrategy;\n \n-crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+pub(crate) fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess\n         .crate_types()\n         .iter()"}, {"sha": "2ca4cd17fdf09fed0ff6ae79ba70e6049ae39f86", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def::DefKind;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ForeignModule;\n \n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n+pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut modules = Vec::new();\n     for id in tcx.hir().items() {\n         if !matches!(tcx.def_kind(id.def_id), DefKind::ForeignMod) {"}, {"sha": "3df18098a07fdd8b869d0120734b348a919b999f", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,5 +1,4 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(generators)]"}, {"sha": "dbe53224e2aaa7180b3b2d64e5d186c328ca7409", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -239,7 +239,7 @@ use std::{cmp, fmt, fs};\n use tracing::{debug, info};\n \n #[derive(Clone)]\n-crate struct CrateLocator<'a> {\n+pub(crate) struct CrateLocator<'a> {\n     // Immutable per-session configuration.\n     only_needs_metadata: bool,\n     sysroot: &'a Path,\n@@ -260,19 +260,19 @@ crate struct CrateLocator<'a> {\n }\n \n #[derive(Clone)]\n-crate struct CratePaths {\n+pub(crate) struct CratePaths {\n     name: Symbol,\n     source: CrateSource,\n }\n \n impl CratePaths {\n-    crate fn new(name: Symbol, source: CrateSource) -> CratePaths {\n+    pub(crate) fn new(name: Symbol, source: CrateSource) -> CratePaths {\n         CratePaths { name, source }\n     }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-crate enum CrateFlavor {\n+pub(crate) enum CrateFlavor {\n     Rlib,\n     Rmeta,\n     Dylib,\n@@ -289,7 +289,7 @@ impl fmt::Display for CrateFlavor {\n }\n \n impl<'a> CrateLocator<'a> {\n-    crate fn new(\n+    pub(crate) fn new(\n         sess: &'a Session,\n         metadata_loader: &'a dyn MetadataLoader,\n         crate_name: Symbol,\n@@ -344,7 +344,7 @@ impl<'a> CrateLocator<'a> {\n         }\n     }\n \n-    crate fn reset(&mut self) {\n+    pub(crate) fn reset(&mut self) {\n         self.crate_rejections.via_hash.clear();\n         self.crate_rejections.via_triple.clear();\n         self.crate_rejections.via_kind.clear();\n@@ -353,7 +353,7 @@ impl<'a> CrateLocator<'a> {\n         self.crate_rejections.via_invalid.clear();\n     }\n \n-    crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n+    pub(crate) fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n         if !self.exact_paths.is_empty() {\n             return self.find_commandline_library();\n         }\n@@ -728,7 +728,7 @@ impl<'a> CrateLocator<'a> {\n         Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n     }\n \n-    crate fn into_error(self, root: Option<CratePaths>) -> CrateError {\n+    pub(crate) fn into_error(self, root: Option<CratePaths>) -> CrateError {\n         CrateError::LocatorCombined(CombinedLocatorError {\n             crate_name: self.crate_name,\n             root,\n@@ -894,7 +894,7 @@ struct CrateRejections {\n /// Candidate rejection reasons collected during crate search.\n /// If no candidate is accepted, then these reasons are presented to the user,\n /// otherwise they are ignored.\n-crate struct CombinedLocatorError {\n+pub(crate) struct CombinedLocatorError {\n     crate_name: Symbol,\n     root: Option<CratePaths>,\n     triple: TargetTriple,\n@@ -903,7 +903,7 @@ crate struct CombinedLocatorError {\n     crate_rejections: CrateRejections,\n }\n \n-crate enum CrateError {\n+pub(crate) enum CrateError {\n     NonAsciiName(Symbol),\n     ExternLocationNotExist(Symbol, PathBuf),\n     ExternLocationNotFile(Symbol, PathBuf),\n@@ -937,7 +937,7 @@ impl fmt::Display for MetadataError<'_> {\n }\n \n impl CrateError {\n-    crate fn report(self, sess: &Session, span: Span, missing_core: bool) {\n+    pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         let mut diag = match self {\n             CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n                 span,"}, {"sha": "8d044be195ae6113f4a1821217d12816ed72236a", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -12,7 +12,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n+pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     for id in tcx.hir().items() {\n         collector.process_item(id);\n@@ -21,7 +21,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     collector.libs\n }\n \n-crate fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n+pub(crate) fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, CRATE_NODE_ID, None),\n         None => true,"}, {"sha": "4038af38a2cbe898fdba1c24d6ad90717486f157", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -57,7 +57,7 @@ mod cstore_impl;\n /// A `MetadataBlob` internally is just a reference counted pointer to\n /// the actual data, so cloning it is cheap.\n #[derive(Clone)]\n-crate struct MetadataBlob(Lrc<MetadataRef>);\n+pub(crate) struct MetadataBlob(Lrc<MetadataRef>);\n \n // This is needed so we can create an OwningRef into the blob.\n // The data behind a `MetadataBlob` has a stable address because it is\n@@ -78,9 +78,9 @@ impl std::ops::Deref for MetadataBlob {\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+pub(crate) type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-crate struct CrateMetadata {\n+pub(crate) struct CrateMetadata {\n     /// The primary crate data - binary metadata blob.\n     blob: MetadataBlob,\n \n@@ -744,20 +744,20 @@ where\n implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n impl<'tcx> MetadataBlob {\n-    crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n+    pub(crate) fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n         MetadataBlob(Lrc::new(metadata_ref))\n     }\n \n-    crate fn is_compatible(&self) -> bool {\n+    pub(crate) fn is_compatible(&self) -> bool {\n         self.blob().starts_with(METADATA_HEADER)\n     }\n \n-    crate fn get_rustc_version(&self) -> String {\n+    pub(crate) fn get_rustc_version(&self) -> String {\n         Lazy::<String>::from_position(NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap())\n             .decode(self)\n     }\n \n-    crate fn get_root(&self) -> CrateRoot<'tcx> {\n+    pub(crate) fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24)\n@@ -767,7 +767,7 @@ impl<'tcx> MetadataBlob {\n         Lazy::<CrateRoot<'tcx>>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n     }\n \n-    crate fn list_crate_metadata(&self, out: &mut dyn io::Write) -> io::Result<()> {\n+    pub(crate) fn list_crate_metadata(&self, out: &mut dyn io::Write) -> io::Result<()> {\n         let root = self.get_root();\n         writeln!(out, \"Crate info:\")?;\n         writeln!(out, \"name {}{}\", root.name, root.extra_filename)?;\n@@ -792,27 +792,27 @@ impl<'tcx> MetadataBlob {\n }\n \n impl CrateRoot<'_> {\n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    pub(crate) fn is_proc_macro_crate(&self) -> bool {\n         self.proc_macro_data.is_some()\n     }\n \n-    crate fn name(&self) -> Symbol {\n+    pub(crate) fn name(&self) -> Symbol {\n         self.name\n     }\n \n-    crate fn hash(&self) -> Svh {\n+    pub(crate) fn hash(&self) -> Svh {\n         self.hash\n     }\n \n-    crate fn stable_crate_id(&self) -> StableCrateId {\n+    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n         self.stable_crate_id\n     }\n \n-    crate fn triple(&self) -> &TargetTriple {\n+    pub(crate) fn triple(&self) -> &TargetTriple {\n         &self.triple\n     }\n \n-    crate fn decode_crate_deps<'a>(\n+    pub(crate) fn decode_crate_deps<'a>(\n         &self,\n         metadata: &'a MetadataBlob,\n     ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {\n@@ -1759,7 +1759,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n }\n \n impl CrateMetadata {\n-    crate fn new(\n+    pub(crate) fn new(\n         sess: &Session,\n         cstore: &CStore,\n         blob: MetadataBlob,\n@@ -1819,15 +1819,15 @@ impl CrateMetadata {\n         cdata\n     }\n \n-    crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n+    pub(crate) fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n         self.dependencies.borrow()\n     }\n \n-    crate fn add_dependency(&self, cnum: CrateNum) {\n+    pub(crate) fn add_dependency(&self, cnum: CrateNum) {\n         self.dependencies.borrow_mut().push(cnum);\n     }\n \n-    crate fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {\n+    pub(crate) fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {\n         let mut extern_crate = self.extern_crate.borrow_mut();\n         let update = Some(new_extern_crate.rank()) > extern_crate.as_ref().map(ExternCrate::rank);\n         if update {\n@@ -1836,59 +1836,59 @@ impl CrateMetadata {\n         update\n     }\n \n-    crate fn source(&self) -> &CrateSource {\n+    pub(crate) fn source(&self) -> &CrateSource {\n         &*self.source\n     }\n \n-    crate fn dep_kind(&self) -> CrateDepKind {\n+    pub(crate) fn dep_kind(&self) -> CrateDepKind {\n         *self.dep_kind.lock()\n     }\n \n-    crate fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n+    pub(crate) fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n \n-    crate fn panic_strategy(&self) -> PanicStrategy {\n+    pub(crate) fn panic_strategy(&self) -> PanicStrategy {\n         self.root.panic_strategy\n     }\n \n-    crate fn needs_panic_runtime(&self) -> bool {\n+    pub(crate) fn needs_panic_runtime(&self) -> bool {\n         self.root.needs_panic_runtime\n     }\n \n-    crate fn is_panic_runtime(&self) -> bool {\n+    pub(crate) fn is_panic_runtime(&self) -> bool {\n         self.root.panic_runtime\n     }\n \n-    crate fn is_profiler_runtime(&self) -> bool {\n+    pub(crate) fn is_profiler_runtime(&self) -> bool {\n         self.root.profiler_runtime\n     }\n \n-    crate fn needs_allocator(&self) -> bool {\n+    pub(crate) fn needs_allocator(&self) -> bool {\n         self.root.needs_allocator\n     }\n \n-    crate fn has_global_allocator(&self) -> bool {\n+    pub(crate) fn has_global_allocator(&self) -> bool {\n         self.root.has_global_allocator\n     }\n \n-    crate fn has_default_lib_allocator(&self) -> bool {\n+    pub(crate) fn has_default_lib_allocator(&self) -> bool {\n         self.root.has_default_lib_allocator\n     }\n \n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    pub(crate) fn is_proc_macro_crate(&self) -> bool {\n         self.root.is_proc_macro_crate()\n     }\n \n-    crate fn name(&self) -> Symbol {\n+    pub(crate) fn name(&self) -> Symbol {\n         self.root.name\n     }\n \n-    crate fn stable_crate_id(&self) -> StableCrateId {\n+    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n         self.root.stable_crate_id\n     }\n \n-    crate fn hash(&self) -> Svh {\n+    pub(crate) fn hash(&self) -> Svh {\n         self.root.hash\n     }\n "}, {"sha": "06045bb3e3d977ecb06fc1b53b2b44a807bae6a6", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_span::def_id::{DefIndex, DefPathHash};\n \n-crate enum DefPathHashMapRef<'tcx> {\n+pub(crate) enum DefPathHashMapRef<'tcx> {\n     OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n     BorrowedFromTcx(&'tcx DefPathHashMap),\n }"}, {"sha": "7ae177c3a563afaf763724d6b98357196037b9c2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -36,7 +36,7 @@ use std::num::NonZeroUsize;\n \n pub use decoder::provide_extern;\n use decoder::DecodeContext;\n-crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n+pub(crate) use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n use encoder::EncodeContext;\n pub use encoder::{encode_metadata, EncodedMetadata};\n use rustc_span::hygiene::SyntaxContextData;\n@@ -46,7 +46,7 @@ mod def_path_hash_map;\n mod encoder;\n mod table;\n \n-crate fn rustc_version() -> String {\n+pub(crate) fn rustc_version() -> String {\n     format!(\"rustc {}\", option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n@@ -169,7 +169,7 @@ type ExpnDataTable = Lazy<Table<ExpnIndex, Lazy<ExpnData>>>;\n type ExpnHashTable = Lazy<Table<ExpnIndex, Lazy<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct ProcMacroData {\n+pub(crate) struct ProcMacroData {\n     proc_macro_decls_static: DefIndex,\n     stability: Option<attr::Stability>,\n     macros: Lazy<[DefIndex]>,\n@@ -192,7 +192,7 @@ crate struct ProcMacroData {\n /// a normal crate, much of what we serialized would be unusable in addition\n /// to being unused.\n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct CrateRoot<'tcx> {\n+pub(crate) struct CrateRoot<'tcx> {\n     name: Symbol,\n     triple: TargetTriple,\n     extra_filename: String,\n@@ -245,7 +245,7 @@ crate struct CrateRoot<'tcx> {\n /// This creates a type-safe way to enforce that we remap the CrateNum between the on-disk\n /// representation and the compilation session.\n #[derive(Copy, Clone)]\n-crate struct RawDefId {\n+pub(crate) struct RawDefId {\n     krate: u32,\n     index: u32,\n }\n@@ -265,7 +265,7 @@ impl RawDefId {\n }\n \n #[derive(Encodable, Decodable)]\n-crate struct CrateDep {\n+pub(crate) struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n@@ -274,13 +274,13 @@ crate struct CrateDep {\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct TraitImpls {\n+pub(crate) struct TraitImpls {\n     trait_id: (u32, DefIndex),\n     impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct IncoherentImpls {\n+pub(crate) struct IncoherentImpls {\n     self_ty: SimplifiedType,\n     impls: Lazy<[DefIndex]>,\n }\n@@ -289,7 +289,7 @@ crate struct IncoherentImpls {\n macro_rules! define_tables {\n     ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n-        crate struct LazyTables<'tcx> {\n+        pub(crate) struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<$IDX, $T>)),+\n         }\n "}, {"sha": "555baae35f506a647d601db0b3d457c3cf056d47", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -195,13 +195,16 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n // WARNING: `construct` is generic and does not know that `CompileCodegenUnit` takes `Symbol`s as keys.\n // Be very careful changing this type signature!\n-crate fn make_compile_codegen_unit(tcx: TyCtxt<'_>, name: Symbol) -> DepNode {\n+pub(crate) fn make_compile_codegen_unit(tcx: TyCtxt<'_>, name: Symbol) -> DepNode {\n     DepNode::construct(tcx, DepKind::CompileCodegenUnit, &name)\n }\n \n // WARNING: `construct` is generic and does not know that `CompileMonoItem` takes `MonoItem`s as keys.\n // Be very careful changing this type signature!\n-crate fn make_compile_mono_item<'tcx>(tcx: TyCtxt<'tcx>, mono_item: &MonoItem<'tcx>) -> DepNode {\n+pub(crate) fn make_compile_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+) -> DepNode {\n     DepNode::construct(tcx, DepKind::CompileMonoItem, mono_item)\n }\n "}, {"sha": "e335cb395f84f3b9d4305975cd7835e37928d621", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -12,7 +12,7 @@ pub use rustc_query_system::dep_graph::{\n };\n \n pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n-crate use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n+pub(crate) use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;"}, {"sha": "b4dd253b83914a1628ddc4104dee98c04a34c103", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -46,7 +46,6 @@\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(type_alias_impl_trait)]\n-#![feature(crate_visibility_modifier)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(half_open_range_patterns)]"}, {"sha": "16ef8d68be3a3b0fc1339c5ce5f99e3a301baa99", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -414,7 +414,7 @@ impl<'tcx> GlobalAlloc<'tcx> {\n     }\n }\n \n-crate struct AllocMap<'tcx> {\n+pub(crate) struct AllocMap<'tcx> {\n     /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n@@ -430,7 +430,7 @@ crate struct AllocMap<'tcx> {\n }\n \n impl<'tcx> AllocMap<'tcx> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         AllocMap {\n             alloc_map: Default::default(),\n             dedup: Default::default(),"}, {"sha": "31e131182cc63a2132f2b9d5f5a9de0bde2888e8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1230,7 +1230,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    crate fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n+    pub(crate) fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n         &self.query_kinds[k as usize]\n     }\n "}, {"sha": "471a164386f265aa24c87463bcb8b8f835122072", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -409,7 +409,7 @@ pub struct CReaderCacheKey {\n ///   of the relevant methods.\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[allow(rustc::usage_of_ty_tykind)]\n-crate struct TyS<'tcx> {\n+pub(crate) struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n     /// Use `Ty::kind()` instead.\n     kind: TyKind<'tcx>,\n@@ -500,7 +500,7 @@ impl ty::EarlyBoundRegion {\n /// See comments on `TyS`, which apply here too (albeit for\n /// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n #[derive(Debug)]\n-crate struct PredicateS<'tcx> {\n+pub(crate) struct PredicateS<'tcx> {\n     kind: Binder<'tcx, PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS]."}, {"sha": "a83328c0cabc63c9e679271525f10b86402e8edb", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::{mir::*, ty};\n use rustc_span::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn ast_block(\n+    pub(crate) fn ast_block(\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,"}, {"sha": "d7b4b1f731a677b24b07e974ec922d69b83f5e2c", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -5,33 +5,33 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n impl<'tcx> CFG<'tcx> {\n-    crate fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n+    pub(crate) fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.basic_blocks[blk]\n     }\n \n-    crate fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+    pub(crate) fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks[blk]\n     }\n \n     // llvm.org/PR32488 makes this function use an excess of stack space. Mark\n     // it as #[inline(never)] to keep rustc's stack use in check.\n     #[inline(never)]\n-    crate fn start_new_block(&mut self) -> BasicBlock {\n+    pub(crate) fn start_new_block(&mut self) -> BasicBlock {\n         self.basic_blocks.push(BasicBlockData::new(None))\n     }\n \n-    crate fn start_new_cleanup_block(&mut self) -> BasicBlock {\n+    pub(crate) fn start_new_cleanup_block(&mut self) -> BasicBlock {\n         let bb = self.start_new_block();\n         self.block_data_mut(bb).is_cleanup = true;\n         bb\n     }\n \n-    crate fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n+    pub(crate) fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    crate fn push_assign(\n+    pub(crate) fn push_assign(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -44,7 +44,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_assign_constant(\n+    pub(crate) fn push_assign_constant(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -59,7 +59,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_assign_unit(\n+    pub(crate) fn push_assign_unit(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -78,7 +78,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_fake_read(\n+    pub(crate) fn push_fake_read(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -90,7 +90,7 @@ impl<'tcx> CFG<'tcx> {\n         self.push(block, stmt);\n     }\n \n-    crate fn terminate(\n+    pub(crate) fn terminate(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -107,7 +107,7 @@ impl<'tcx> CFG<'tcx> {\n     }\n \n     /// In the `origin` block, push a `goto -> target` terminator.\n-    crate fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n+    pub(crate) fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n         self.terminate(origin, source_info, TerminatorKind::Goto { target })\n     }\n }"}, {"sha": "035e94eecee230acaa1a52621f94f27618c6fcb2", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n+    pub(crate) fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n         let create_uneval_from_def_id =\n             |tcx: TyCtxt<'tcx>, def_id: DefId, ty: Ty<'tcx>, substs: SubstsRef<'tcx>| {\n                 let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);"}, {"sha": "e707c373f0dde9faf7c1499fe48bc056c446f4f8", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// after the current enclosing `ExprKind::Scope` has ended, so\n     /// please do *not* return it from functions to avoid bad\n     /// miscompiles.\n-    crate fn as_local_operand(\n+    pub(crate) fn as_local_operand(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// value to the stack.\n     ///\n     /// See #68034 for more details.\n-    crate fn as_local_call_operand(\n+    pub(crate) fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Like `as_local_call_operand`, except that the argument will\n     /// not be valid once `scope` ends.\n     #[instrument(level = \"debug\", skip(self, scope))]\n-    crate fn as_operand(\n+    pub(crate) fn as_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn as_call_operand(\n+    pub(crate) fn as_call_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,"}, {"sha": "045d6eb1c3021d8df34301ac37a85b2fd9533d73", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -21,7 +21,7 @@ use std::iter;\n \n /// The \"outermost\" place that holds this value.\n #[derive(Copy, Clone, Debug, PartialEq)]\n-crate enum PlaceBase {\n+pub(crate) enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n \n@@ -71,7 +71,7 @@ crate enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-crate struct PlaceBuilder<'tcx> {\n+pub(crate) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -283,7 +283,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    crate fn into_place<'a>(\n+    pub(crate) fn into_place<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n@@ -314,35 +314,35 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    crate fn try_upvars_resolved<'a>(\n+    pub(crate) fn try_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results)\n     }\n \n-    crate fn base(&self) -> PlaceBase {\n+    pub(crate) fn base(&self) -> PlaceBase {\n         self.base\n     }\n \n-    crate fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n+    pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n         self.project(PlaceElem::Field(f, ty))\n     }\n \n-    crate fn deref(self) -> Self {\n+    pub(crate) fn deref(self) -> Self {\n         self.project(PlaceElem::Deref)\n     }\n \n-    crate fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx) -> Self {\n+    pub(crate) fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx) -> Self {\n         self.project(PlaceElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index))\n     }\n \n     fn index(self, index: Local) -> Self {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    crate fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+    pub(crate) fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n         self.projection.push(elem);\n         self\n     }\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Extra care is needed if any user code is allowed to run between calling\n     /// this method and using it, as is the case for `match` and index\n     /// expressions.\n-    crate fn as_place(\n+    pub(crate) fn as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    crate fn as_place_builder(\n+    pub(crate) fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    crate fn as_read_only_place(\n+    pub(crate) fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "0fd67f15b7501396ebcddafeffba1d6c4bc7b550", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    crate fn as_local_rvalue(\n+    pub(crate) fn as_local_rvalue(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -31,7 +31,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    crate fn as_rvalue(\n+    pub(crate) fn as_rvalue(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn build_binary_op(\n+    pub(crate) fn build_binary_op(\n         &mut self,\n         mut block: BasicBlock,\n         op: BinOp,"}, {"sha": "724b72f8769b8bc8bd460880f3a3cb90a5fc2d44", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::thir::*;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    crate fn as_temp(\n+    pub(crate) fn as_temp(\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,"}, {"sha": "b1a706439342ebbdfe5365b174bcf225f106f8af", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,7 @@\n use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n-crate enum Category {\n+pub(crate) enum Category {\n     // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n     // sort of thing. Something that could appear on the LHS of an `=`\n     // sign.\n@@ -19,7 +19,7 @@ crate enum Category {\n // Rvalues fall into different \"styles\" that will determine which fn\n // is best suited to generate them.\n #[derive(Debug, PartialEq)]\n-crate enum RvalueFunc {\n+pub(crate) enum RvalueFunc {\n     // Best generated by `into`. This is generally exprs that\n     // cause branching, like `match`, but also includes calls.\n     Into,\n@@ -31,7 +31,7 @@ crate enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n+    pub(crate) fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "e912501d55f2255e740158910cef105dd7216e6d", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,7 +15,7 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    crate fn expr_into_dest(\n+    pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,"}, {"sha": "f5ae060d603f6eca5d68b61657eda725319a15fc", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -60,7 +60,7 @@\n //! basically the point where the \"by value\" operations are bridged\n //! over to the \"by reference\" mode (`as_place`).\n \n-crate mod as_constant;\n+pub(crate) mod as_constant;\n mod as_operand;\n pub mod as_place;\n mod as_rvalue;"}, {"sha": "a7e1331aabca3f7aa7a5416dfc2b8ce22e4394af", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -10,7 +10,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n     /// The scope is used if a statement temporary must be dropped.\n-    crate fn stmt_expr(\n+    pub(crate) fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "83ecd185b3c6054895ff88194db248505f7c354a", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// * From each pre-binding block to the next pre-binding block.\n     /// * From each otherwise block to the next pre-binding block.\n-    crate fn match_expr(\n+    pub(crate) fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n         span: Span,\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn place_into_pattern(\n+    pub(crate) fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    crate fn declare_bindings(\n+    pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         visibility_scope\n     }\n \n-    crate fn storage_live_binding(\n+    pub(crate) fn storage_live_binding(\n         &mut self,\n         block: BasicBlock,\n         var: HirId,\n@@ -709,7 +709,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         Place::from(local_id)\n     }\n \n-    crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n+    pub(crate) fn schedule_drop_for_binding(\n+        &mut self,\n+        var: HirId,\n+        span: Span,\n+        for_guard: ForGuard,\n+    ) {\n         let local_id = self.var_local_id(var, for_guard);\n         if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n@@ -934,7 +939,7 @@ struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-crate struct MatchPair<'pat, 'tcx> {\n+pub(crate) struct MatchPair<'pat, 'tcx> {\n     // this place...\n     place: PlaceBuilder<'tcx>,\n \n@@ -991,15 +996,15 @@ enum TestKind<'tcx> {\n /// [`Test`] is just the test to perform; it does not include the value\n /// to be tested.\n #[derive(Debug)]\n-crate struct Test<'tcx> {\n+pub(crate) struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n /// `ArmHasGuard` is a wrapper around a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n-crate struct ArmHasGuard(crate bool);\n+pub(crate) struct ArmHasGuard(pub(crate) bool);\n \n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n@@ -1769,7 +1774,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n // Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn lower_let_expr(\n+    pub(crate) fn lower_let_expr(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "9a1e98d3bb18ddc8d6b6e646a1de00610ae4ae33", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use smallvec::SmallVec;\n use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn field_match_pairs<'pat>(\n+    pub(crate) fn field_match_pairs<'pat>(\n         &mut self,\n         place: PlaceBuilder<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .collect()\n     }\n \n-    crate fn prefix_slice_suffix<'pat>(\n+    pub(crate) fn prefix_slice_suffix<'pat>(\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n         place: &PlaceBuilder<'tcx>,\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates a false edge to `imaginary_target` and a real edge to\n     /// real_target. If `imaginary_target` is none, or is the same as the real\n     /// target, a Goto is generated instead to simplify the generated MIR.\n-    crate fn false_edges(\n+    pub(crate) fn false_edges(\n         &mut self,\n         from_block: BasicBlock,\n         real_target: BasicBlock,\n@@ -100,7 +100,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    crate fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub(crate) fn new(\n+        place: PlaceBuilder<'tcx>,\n+        pattern: &'pat Pat<'tcx>,\n+    ) -> MatchPair<'pat, 'tcx> {\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "86f466ff7672e8def0b7787494bdda78372c10e3", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// N.B., **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    crate fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n+    pub(crate) fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         // Mark this local as internal to avoid temporaries with types not present in the\n         // user's code resulting in ICEs from the generator transform.\n         let temp = self.local_decls.push(LocalDecl::new(ty, span).internal());\n@@ -25,20 +25,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(&mut self, span: Span, literal: ConstantKind<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn literal_operand(\n+        &mut self,\n+        span: Span,\n+        literal: ConstantKind<'tcx>,\n+    ) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n-    crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }\n \n-    crate fn push_usize(\n+    pub(crate) fn push_usize(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -59,7 +63,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         temp\n     }\n \n-    crate fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {"}, {"sha": "4ae74433df63dc7051cb9ad61169ac4437b13b15", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::lints;\n \n-crate fn mir_built<'tcx>(\n+pub(crate) fn mir_built<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> &'tcx rustc_data_structures::steal::Steal<Body<'tcx>> {"}, {"sha": "2d14a78accf9cef5d15d3794713f0c33e4e0713d", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -177,7 +177,7 @@ struct IfThenScope {\n \n /// The target of an expression that breaks out of a scope\n #[derive(Clone, Copy, Debug)]\n-crate enum BreakableTarget {\n+pub(crate) enum BreakableTarget {\n     Continue(region::Scope),\n     Break(region::Scope),\n     Return,\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // ==========================\n     //  Start a breakable scope, which tracks where `continue`, `break` and\n     //  `return` should branch to.\n-    crate fn in_breakable_scope<F>(\n+    pub(crate) fn in_breakable_scope<F>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n         break_destination: Place<'tcx>,\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// - We don't need to keep a stack of scopes in the `Builder` because the\n     ///   'else' paths will only leave the innermost scope.\n     /// - This is also used for match guards.\n-    crate fn in_if_then_scope<F>(\n+    pub(crate) fn in_if_then_scope<F>(\n         &mut self,\n         region_scope: region::Scope,\n         f: F,\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         (then_block, else_block)\n     }\n \n-    crate fn in_opt_scope<F, R>(\n+    pub(crate) fn in_opt_scope<F, R>(\n         &mut self,\n         opt_scope: Option<(region::Scope, SourceInfo)>,\n         f: F,\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    crate fn in_scope<F, R>(\n+    pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         lint_level: LintLevel,\n@@ -597,14 +597,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    crate fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n+    pub(crate) fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n         self.scopes.push_scope(region_scope, self.source_scope);\n     }\n \n     /// Pops a scope, which should have region scope `region_scope`,\n     /// adding any drops onto the end of `block` that are needed.\n     /// This must match 1-to-1 with `push_scope`.\n-    crate fn pop_scope(\n+    pub(crate) fn pop_scope(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         mut block: BasicBlock,\n@@ -619,7 +619,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Sets up the drops for breaking from `block` to `target`.\n-    crate fn break_scope(\n+    pub(crate) fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n         value: Option<&Expr<'tcx>>,\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.start_new_block().unit()\n     }\n \n-    crate fn break_for_else(\n+    pub(crate) fn break_for_else(\n         &mut self,\n         block: BasicBlock,\n         target: region::Scope,\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Creates a new source scope, nested in the current one.\n-    crate fn new_source_scope(\n+    pub(crate) fn new_source_scope(\n         &mut self,\n         span: Span,\n         lint_level: LintLevel,\n@@ -791,7 +791,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Given a span and the current source scope, make a SourceInfo.\n-    crate fn source_info(&self, span: Span) -> SourceInfo {\n+    pub(crate) fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo { span, scope: self.source_scope }\n     }\n \n@@ -816,13 +816,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// We would allocate the box but then free it on the unwinding\n     /// path; we would also emit a free on the 'success' path from\n     /// panic, but that will turn out to be removed as dead-code.\n-    crate fn local_scope(&self) -> region::Scope {\n+    pub(crate) fn local_scope(&self) -> region::Scope {\n         self.scopes.topmost()\n     }\n \n     // Scheduling drops\n     // ================\n-    crate fn schedule_drop_storage_and_value(\n+    pub(crate) fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -836,7 +836,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// When called with `DropKind::Storage`, `place` shouldn't be the return\n     /// place, or a function parameter.\n-    crate fn schedule_drop(\n+    pub(crate) fn schedule_drop(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// spurious borrow-check errors -- the problem, ironically, is\n     /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n     /// that it creates. See #64391 for an example.\n-    crate fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n+    pub(crate) fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n         let local_scope = self.local_scope();\n         let scope = self.scopes.scopes.last_mut().unwrap();\n \n@@ -1026,7 +1026,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This path terminates in Resume. The path isn't created until after all\n     /// of the non-unwind paths in this item have been lowered.\n-    crate fn diverge_from(&mut self, start: BasicBlock) {\n+    pub(crate) fn diverge_from(&mut self, start: BasicBlock) {\n         debug_assert!(\n             matches!(\n                 self.cfg.block_data(start).terminator().kind,\n@@ -1048,7 +1048,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// [TerminatorKind::Yield].\n     ///\n     /// This path terminates in GeneratorDrop.\n-    crate fn generator_drop_cleanup(&mut self, yield_block: BasicBlock) {\n+    pub(crate) fn generator_drop_cleanup(&mut self, yield_block: BasicBlock) {\n         debug_assert!(\n             matches!(\n                 self.cfg.block_data(yield_block).terminator().kind,\n@@ -1078,7 +1078,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n-    crate fn build_drop_and_replace(\n+    pub(crate) fn build_drop_and_replace(\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates an `Assert` terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n-    crate fn assert(\n+    pub(crate) fn assert(\n         &mut self,\n         block: BasicBlock,\n         cond: Operand<'tcx>,\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    crate fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+    pub(crate) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n         let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n@@ -1262,7 +1262,7 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n     }\n \n     /// Build the unwind and generator drop trees.\n-    crate fn build_drop_trees(&mut self) {\n+    pub(crate) fn build_drop_trees(&mut self) {\n         if self.generator_kind.is_some() {\n             self.build_generator_drop_trees();\n         } else {"}, {"sha": "94b2722dca86d1e2884bae852307fe68a1cf0082", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -678,15 +678,15 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n     visitor.visit_expr(&thir[expr]);\n }\n \n-crate fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+pub(crate) fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n         tcx.thir_check_unsafety_for_const_arg(def)\n     } else {\n         check_unsafety(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n }\n \n-crate fn thir_check_unsafety_for_const_arg<'tcx>(\n+pub(crate) fn thir_check_unsafety_for_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n ) {"}, {"sha": "11cd2a9aa4dea9b03ed61d3e6658aa0ad15084fe", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -4,7 +4,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "5470cc1262e8451d071319f0b759bb95e51a5a71", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -9,7 +9,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n use std::ops::ControlFlow;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n+pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n \n     if let Some(fn_kind) = tcx.hir().get_by_def_id(def_id).fn_kind() {"}, {"sha": "d82e6688633d01667f91a144b85fac711a41e008", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::Symbol;\n use rustc_target::abi::Size;\n \n // FIXME Once valtrees are available, get rid of this function and the query\n-crate fn lit_to_const<'tcx>(\n+pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n ) -> Result<ty::Const<'tcx>, LitToConstError> {"}, {"sha": "72ce8c24cdd5b3484f506da2cde8fc6aaaa52192", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_index::vec::Idx;\n \n impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block {\n+    pub(crate) fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = self.mirror_stmts(block.hir_id.local_id, block.stmts);"}, {"sha": "b9879b9159fb363ba5feea20bf59ac2452537a4e", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -22,12 +22,12 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n+    pub(crate) fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n         // `mirror_expr` is recursing very deep. Make sure the stack doesn't overflow.\n         ensure_sufficient_stack(|| self.mirror_expr_inner(expr))\n     }\n \n-    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Box<[ExprId]> {\n+    pub(crate) fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Box<[ExprId]> {\n         exprs.iter().map(|expr| self.mirror_expr_inner(expr)).collect()\n     }\n "}, {"sha": "81eb7efad371fc4caefb4b094ea389877ed75b02", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::thir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n-crate fn thir_body<'tcx>(\n+pub(crate) fn thir_body<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n ) -> Result<(&'tcx Steal<Thir<'tcx>>, ExprId), ErrorGuaranteed> {\n@@ -33,7 +33,7 @@ crate fn thir_body<'tcx>(\n     Ok((tcx.alloc_steal_thir(cx.thir), expr))\n }\n \n-crate fn thir_tree<'tcx>(\n+pub(crate) fn thir_tree<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n ) -> String {\n@@ -47,10 +47,10 @@ struct Cx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     thir: Thir<'tcx>,\n \n-    crate param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n-    crate region_scope_tree: &'tcx region::ScopeTree,\n-    crate typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    pub(crate) region_scope_tree: &'tcx region::ScopeTree,\n+    pub(crate) typeck_results: &'tcx ty::TypeckResults<'tcx>,\n \n     /// When applying adjustments to the expression\n     /// with the given `HirId`, use the given `Span`,\n@@ -79,7 +79,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    crate fn const_eval_literal(\n+    pub(crate) fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n         ty: Ty<'tcx>,\n@@ -96,7 +96,7 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n+    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "e0e6ac26654ab174bdb413de9b79b3539beb1b06", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -4,10 +4,10 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-crate mod constant;\n+pub(crate) mod constant;\n \n-crate mod cx;\n+pub(crate) mod cx;\n \n-crate mod pattern;\n+pub(crate) mod pattern;\n \n mod util;"}, {"sha": "dc204eb47aefa670a633712ddebc6e1e03eeafda", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -23,7 +23,7 @@ use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span};\n \n-crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().local_def_id_to_hir_id(id)),\n@@ -880,7 +880,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     err.emit();\n }\n \n-crate fn joined_uncovered_patterns<'p, 'tcx>(\n+pub(crate) fn joined_uncovered_patterns<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     witnesses: &[DeconstructedPat<'p, 'tcx>],\n ) -> String {\n@@ -901,7 +901,7 @@ crate fn joined_uncovered_patterns<'p, 'tcx>(\n     }\n }\n \n-crate fn pattern_not_covered_label(\n+pub(crate) fn pattern_not_covered_label(\n     witnesses: &[DeconstructedPat<'_, '_>],\n     joined_patterns: &str,\n ) -> String {"}, {"sha": "1f152549a63f03bf48792a6202ec3b677715b495", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -27,22 +27,22 @@ use rustc_span::{Span, Symbol};\n use std::cmp::Ordering;\n \n #[derive(Clone, Debug)]\n-crate enum PatternError {\n+pub(crate) enum PatternError {\n     AssocConstInPattern(Span),\n     ConstParamInPattern(Span),\n     StaticInPattern(Span),\n     NonConstPath(Span),\n }\n \n-crate struct PatCtxt<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n-    crate param_env: ty::ParamEnv<'tcx>,\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n-    crate errors: Vec<PatternError>,\n+pub(crate) struct PatCtxt<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) typeck_results: &'a ty::TypeckResults<'tcx>,\n+    pub(crate) errors: Vec<PatternError>,\n     include_lint_checks: bool,\n }\n \n-crate fn pat_from_hir<'a, 'tcx>(\n+pub(crate) fn pat_from_hir<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n@@ -59,20 +59,20 @@ crate fn pat_from_hir<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Self {\n         PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n     }\n \n-    crate fn include_lint_checks(&mut self) -> &mut Self {\n+    pub(crate) fn include_lint_checks(&mut self) -> &mut Self {\n         self.include_lint_checks = true;\n         self\n     }\n \n-    crate fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -608,15 +608,15 @@ impl<'tcx> UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     }\n }\n \n-crate trait PatternFoldable<'tcx>: Sized {\n+pub(crate) trait PatternFoldable<'tcx>: Sized {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n-crate trait PatternFolder<'tcx>: Sized {\n+pub(crate) trait PatternFolder<'tcx>: Sized {\n     fn fold_pattern(&mut self, pattern: &Pat<'tcx>) -> Pat<'tcx> {\n         pattern.super_fold_with(self)\n     }\n@@ -746,7 +746,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n-crate fn compare_const_vals<'tcx>(\n+pub(crate) fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: mir::ConstantKind<'tcx>,\n     b: mir::ConstantKind<'tcx>,"}, {"sha": "9e7a267ecbd7fc86dd9d057324d9595f21ac5b74", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -309,16 +309,16 @@ use smallvec::{smallvec, SmallVec};\n use std::fmt;\n use std::iter::once;\n \n-crate struct MatchCheckCtxt<'p, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n     /// not. E.g., `struct Foo { _private: ! }` cannot be seen to be empty\n     /// outside its module and should not be matchable with an empty match statement.\n-    crate module: DefId,\n-    crate param_env: ty::ParamEnv<'tcx>,\n-    crate pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    pub(crate) module: DefId,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -691,7 +691,7 @@ enum ArmType {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Debug)]\n-crate struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n+pub(crate) struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n \n impl<'p, 'tcx> Witness<'p, 'tcx> {\n     /// Asserts that the witness contains a single pattern, and returns it.\n@@ -908,16 +908,16 @@ fn is_useful<'p, 'tcx>(\n \n /// The arm of a match expression.\n #[derive(Clone, Copy, Debug)]\n-crate struct MatchArm<'p, 'tcx> {\n+pub(crate) struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p DeconstructedPat<'p, 'tcx>,\n-    crate hir_id: HirId,\n-    crate has_guard: bool,\n+    pub(crate) pat: &'p DeconstructedPat<'p, 'tcx>,\n+    pub(crate) hir_id: HirId,\n+    pub(crate) has_guard: bool,\n }\n \n /// Indicates whether or not a given arm is reachable.\n #[derive(Clone, Debug)]\n-crate enum Reachability {\n+pub(crate) enum Reachability {\n     /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n     /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n     /// of or-patterns, otherwise it stays empty.\n@@ -927,12 +927,12 @@ crate enum Reachability {\n }\n \n /// The output of checking a match for exhaustiveness and arm reachability.\n-crate struct UsefulnessReport<'p, 'tcx> {\n+pub(crate) struct UsefulnessReport<'p, 'tcx> {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n-    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n+    pub(crate) arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    pub(crate) non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -941,7 +941,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n /// Note: the input patterns must have been lowered through\n /// `check_match::MatchVisitor::lower_pattern`.\n #[instrument(skip(cx, arms), level = \"debug\")]\n-crate fn compute_match_usefulness<'p, 'tcx>(\n+pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n     scrut_hir_id: HirId,"}, {"sha": "c58ed1ac0b89119197c36d08f28746d8f8d253a7", "filename": "compiler/rustc_mir_build/src/thir/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir as hir;\n use rustc_middle::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n-crate trait UserAnnotatedTyHelpers<'tcx> {\n+pub(crate) trait UserAnnotatedTyHelpers<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn typeck_results(&self) -> &ty::TypeckResults<'tcx>;"}, {"sha": "017d9e74dc4bc3b529bd97cc9efe4c217c0a511c", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -17,7 +17,7 @@ use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n \n-crate mod cycle;\n+pub(crate) mod cycle;\n \n const INSTR_COST: usize = 5;\n const CALL_PENALTY: usize = 25;"}, {"sha": "fd7de2bd1dcf86347665d2ac5396b39b874befb6", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -9,7 +9,7 @@ use rustc_session::Limit;\n // FIXME: check whether it is cheaper to precompute the entire call graph instead of invoking\n // this query ridiculously often.\n #[instrument(level = \"debug\", skip(tcx, root, target))]\n-crate fn mir_callgraph_reachable<'tcx>(\n+pub(crate) fn mir_callgraph_reachable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (root, target): (ty::Instance<'tcx>, LocalDefId),\n ) -> bool {\n@@ -136,7 +136,7 @@ crate fn mir_callgraph_reachable<'tcx>(\n     )\n }\n \n-crate fn mir_inliner_callees<'tcx>(\n+pub(crate) fn mir_inliner_callees<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n ) -> &'tcx [(DefId, SubstsRef<'tcx>)] {"}, {"sha": "1e8c373a411feecddcdd4cb38700163efe78d413", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(map_try_insert)]"}, {"sha": "ef4560b5ec48edc153a3ad9fc553491b678bdf6e", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,5 +1,4 @@\n #![feature(array_windows)]\n-#![feature(crate_visibility_modifier)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n #![recursion_limit = \"256\"]"}, {"sha": "d3aaad46015619dd97d027dd49bacb11d23811a9", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -7,7 +7,7 @@ use std::io::prelude::*;\n ///\n /// During the same compile all closures dump the information in the same file\n /// \"closure_profile_XXXXX.csv\", which is created in the directory where the compiler is invoked.\n-crate fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instance<'tcx>) {\n+pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instance<'tcx>) {\n     let Ok(mut file) = OpenOptions::new()\n         .create(true)\n         .append(true)"}, {"sha": "e9701ec2d7f456f3b85158c29f481b8be0539e91", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -31,7 +31,7 @@ pub struct UnmatchedBrace {\n     pub candidate_span: Option<Span>,\n }\n \n-crate fn parse_token_trees<'a>(\n+pub(crate) fn parse_token_trees<'a>(\n     sess: &'a ParseSess,\n     src: &'a str,\n     start_pos: BytePos,"}, {"sha": "c46a8b58c293606fdcc08597be8e5ab97d9b8915", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(array_windows)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "3ae8bb07cd07002019784b33715493b32ef4124a", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -284,7 +284,7 @@ impl<'a> Parser<'a> {\n     /// terminated by a semicolon.\n     ///\n     /// Matches `inner_attrs*`.\n-    crate fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n+    pub(crate) fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             let start_pos: u32 = self.token_cursor.num_next_calls.try_into().unwrap();\n@@ -322,7 +322,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    crate fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `COMMASEP(meta_item_inner)`.\n-    crate fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n         // Presumably, the majority of the time there will only be one attr.\n         let mut nmis = Vec::with_capacity(1);\n         while self.token.kind != token::Eof {\n@@ -401,7 +401,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::MetaItem { path, kind, span })\n     }\n \n-    crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n+    pub(crate) fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {"}, {"sha": "69e12063cc134ad59094b001b9f11c129f4e308f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -132,7 +132,7 @@ impl RecoverQPath for Expr {\n }\n \n /// Control whether the closing delimiter should be consumed when calling `Parser::consume_block`.\n-crate enum ConsumeClosingDelim {\n+pub(crate) enum ConsumeClosingDelim {\n     Yes,\n     No,\n }\n@@ -2459,7 +2459,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    crate fn maybe_recover_colon_colon_in_pat_typo(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n         ra: RecoverColon,\n@@ -2575,7 +2575,7 @@ impl<'a> Parser<'a> {\n         first_pat\n     }\n \n-    crate fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n+    pub(crate) fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n         let Some(label) = self.eat_label().filter(|_| {\n             self.eat(&token::Colon) && self.token.kind == token::OpenDelim(Delimiter::Brace)\n         }) else {\n@@ -2596,7 +2596,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    crate fn maybe_recover_unexpected_comma(\n+    pub(crate) fn maybe_recover_unexpected_comma(\n         &mut self,\n         lo: Span,\n         rc: RecoverComma,\n@@ -2643,7 +2643,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    crate fn maybe_recover_bounds_doubled_colon(&mut self, ty: &Ty) -> PResult<'a, ()> {\n+    pub(crate) fn maybe_recover_bounds_doubled_colon(&mut self, ty: &Ty) -> PResult<'a, ()> {\n         let TyKind::Path(qself, path) = &ty.kind else { return Ok(()) };\n         let qself_position = qself.as_ref().map(|qself| qself.position);\n         for (i, segments) in path.segments.windows(2).enumerate() {"}, {"sha": "b5467c659a205a2db8e0ebf2b47b8bae123fda47", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2380,7 +2380,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n-    crate fn eat_label(&mut self) -> Option<Label> {\n+    pub(crate) fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n             self.bump();\n             Label { ident }\n@@ -3049,7 +3049,7 @@ impl<'a> Parser<'a> {\n         await_expr\n     }\n \n-    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n+    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n         P(Expr { kind, span, attrs, id: DUMMY_NODE_ID, tokens: None })\n     }\n "}, {"sha": "1930dec8c3b227c1c7616925b5b507caefae1b4d", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -51,7 +51,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    crate fn parse_const_param(\n+    pub(crate) fn parse_const_param(\n         &mut self,\n         preceding_attrs: Vec<Attribute>,\n     ) -> PResult<'a, GenericParam> {"}, {"sha": "5bd07c31c0e7b3777d13b888f3cbac0380e2e474", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1415,7 +1415,7 @@ impl<'a> Parser<'a> {\n     }\n }\n \n-crate fn make_unclosed_delims_error(\n+pub(crate) fn make_unclosed_delims_error(\n     unmatched: UnmatchedBrace,\n     sess: &ParseSess,\n ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {"}, {"sha": "27a6a48747408f959bb312f409cd951ea65c4e1a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -36,7 +36,7 @@ impl<'a> Parser<'a> {\n \n     /// If `force_capture` is true, forces collection of tokens regardless of whether\n     /// or not we have attributes\n-    crate fn parse_stmt_without_recovery(\n+    pub(crate) fn parse_stmt_without_recovery(\n         &mut self,\n         capture_semi: bool,\n         force_collect: ForceCollect,\n@@ -500,7 +500,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    crate fn parse_block_tail(\n+    pub(crate) fn parse_block_tail(\n         &mut self,\n         lo: Span,\n         s: BlockCheckMode,"}, {"sha": "2c79ac49b36da3556272560686bf0f3041d76efa", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -6,7 +6,6 @@\n \n #![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(iter_intersperse)]\n #![feature(let_else)]\n #![feature(let_chains)]"}, {"sha": "83f728d407667ba8f2402d7b880af157b1d7ff84", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -17,7 +17,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut CheckNakedFunctions { tcx });\n }\n \n-crate fn provide(providers: &mut Providers) {\n+pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n "}, {"sha": "c9574e81216268cdb8e04ff081455da1fedb9f59", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,6 @@\n //! Support for serializing the dep-graph and reloading it.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(once_cell)]"}, {"sha": "634236c0dac75089e25869cb6b36f14d1489c1ef", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n         QueryCtxt { tcx, queries }\n     }\n \n-    crate fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n+    pub(crate) fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n         self.queries.on_disk_cache.as_ref()\n     }\n "}, {"sha": "3879779635b32ffe689668768c0bc27c3d5576f4", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -81,7 +81,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroE\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    crate fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    pub(crate) fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n     where\n         T: ToNameBinding<'a>,\n     {\n@@ -127,7 +127,7 @@ impl<'a> Resolver<'a> {\n     /// If `def_id` refers to a module (in resolver's sense, i.e. a module item, crate root, enum,\n     /// or trait), then this function returns that module's resolver representation, otherwise it\n     /// returns `None`.\n-    crate fn get_module(&mut self, def_id: DefId) -> Option<Module<'a>> {\n+    pub(crate) fn get_module(&mut self, def_id: DefId) -> Option<Module<'a>> {\n         if let module @ Some(..) = self.module_map.get(&def_id) {\n             return module.copied();\n         }\n@@ -162,7 +162,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+    pub(crate) fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         match expn_id.expn_data().macro_def_id {\n             Some(def_id) => self.macro_def_scope(def_id),\n             None => expn_id\n@@ -172,23 +172,23 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn macro_def_scope(&mut self, def_id: DefId) -> Module<'a> {\n+    pub(crate) fn macro_def_scope(&mut self, def_id: DefId) -> Module<'a> {\n         if let Some(id) = def_id.as_local() {\n             self.local_macro_def_scopes[&id]\n         } else {\n             self.get_nearest_non_block_module(def_id)\n         }\n     }\n \n-    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+    pub(crate) fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         match res {\n             Res::Def(DefKind::Macro(..), def_id) => Some(self.get_macro_by_def_id(def_id)),\n             Res::NonMacroAttr(_) => Some(self.non_macro_attr.clone()),\n             _ => None,\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n+    pub(crate) fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return ext.clone();\n         }\n@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n         ext\n     }\n \n-    crate fn build_reduced_graph(\n+    pub(crate) fn build_reduced_graph(\n         &mut self,\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n@@ -213,7 +213,7 @@ impl<'a> Resolver<'a> {\n         visitor.parent_scope.macro_rules\n     }\n \n-    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+    pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         for child in self.cstore().module_children_untracked(module.def_id(), self.session) {\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }"}, {"sha": "5dc720e0abc9fa50925f256eb0957691e93d8936", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -224,7 +224,7 @@ fn calc_unused_spans(\n }\n \n impl Resolver<'_> {\n-    crate fn check_unused(&mut self, krate: &ast::Crate) {\n+    pub(crate) fn check_unused(&mut self, krate: &ast::Crate) {\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {\n                 _ if import.used.get()"}, {"sha": "f9aff7fd68685e6a37d75604166cc2e87c364695", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use tracing::debug;\n \n-crate fn collect_definitions(\n+pub(crate) fn collect_definitions(\n     resolver: &mut Resolver<'_>,\n     fragment: &AstFragment,\n     expansion: LocalExpnId,"}, {"sha": "c199cff2038729e3ce0aa59961e8fcfb1b9f78bc", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -41,36 +41,36 @@ mod tests;\n type Res = def::Res<ast::NodeId>;\n \n /// A vector of spans and replacements, a message and applicability.\n-crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n+pub(crate) type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n /// Potential candidate for an undeclared or out-of-scope label - contains the ident of a\n /// similarly named label and whether or not it is reachable.\n-crate type LabelSuggestion = (Ident, bool);\n+pub(crate) type LabelSuggestion = (Ident, bool);\n \n-crate enum SuggestionTarget {\n+pub(crate) enum SuggestionTarget {\n     /// The target has a similar name as the name used by the programmer (probably a typo)\n     SimilarlyNamed,\n     /// The target is the only valid item that can be used in the corresponding context\n     SingleItem,\n }\n \n-crate struct TypoSuggestion {\n+pub(crate) struct TypoSuggestion {\n     pub candidate: Symbol,\n     pub res: Res,\n     pub target: SuggestionTarget,\n }\n \n impl TypoSuggestion {\n-    crate fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    pub(crate) fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         Self { candidate, res, target: SuggestionTarget::SimilarlyNamed }\n     }\n-    crate fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    pub(crate) fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         Self { candidate, res, target: SuggestionTarget::SingleItem }\n     }\n }\n \n /// A free importable items suggested in case of resolution failure.\n-crate struct ImportSuggestion {\n+pub(crate) struct ImportSuggestion {\n     pub did: Option<DefId>,\n     pub descr: &'static str,\n     pub path: Path,\n@@ -92,7 +92,7 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn report_errors(&mut self, krate: &Crate) {\n+    pub(crate) fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n         for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n@@ -147,7 +147,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_conflict<'b>(\n+    pub(crate) fn report_conflict<'b>(\n         &mut self,\n         parent: Module<'_>,\n         ident: Ident,\n@@ -419,7 +419,7 @@ impl<'a> Resolver<'a> {\n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n     }\n \n-    crate fn lint_if_path_starts_with_module(\n+    pub(crate) fn lint_if_path_starts_with_module(\n         &mut self,\n         finalize: Option<Finalize>,\n         path: &[Segment],\n@@ -475,7 +475,7 @@ impl<'a> Resolver<'a> {\n         );\n     }\n \n-    crate fn add_module_candidates(\n+    pub(crate) fn add_module_candidates(\n         &mut self,\n         module: Module<'a>,\n         names: &mut Vec<TypoSuggestion>,\n@@ -495,11 +495,11 @@ impl<'a> Resolver<'a> {\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n     /// error and emits it.\n-    crate fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n+    pub(crate) fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n         self.into_struct_error(span, resolution_error).emit();\n     }\n \n-    crate fn into_struct_error(\n+    pub(crate) fn into_struct_error(\n         &mut self,\n         span: Span,\n         resolution_error: ResolutionError<'a>,\n@@ -1052,7 +1052,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_vis_error(\n+    pub(crate) fn report_vis_error(\n         &mut self,\n         vis_resolution_error: VisResolutionError<'_>,\n     ) -> ErrorGuaranteed {\n@@ -1413,7 +1413,7 @@ impl<'a> Resolver<'a> {\n     ///\n     /// N.B., the method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports).\n-    crate fn lookup_import_candidates<FilterFn>(\n+    pub(crate) fn lookup_import_candidates<FilterFn>(\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n@@ -1460,7 +1460,7 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    crate fn unresolved_macro_suggestions(\n+    pub(crate) fn unresolved_macro_suggestions(\n         &mut self,\n         err: &mut Diagnostic,\n         macro_kind: MacroKind,\n@@ -1551,7 +1551,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn add_typo_suggestion(\n+    pub(crate) fn add_typo_suggestion(\n         &self,\n         err: &mut Diagnostic,\n         suggestion: Option<TypoSuggestion>,\n@@ -1780,7 +1780,7 @@ impl<'a> Resolver<'a> {\n         err.emit();\n     }\n \n-    crate fn find_similarly_named_module_or_crate(\n+    pub(crate) fn find_similarly_named_module_or_crate(\n         &mut self,\n         ident: Symbol,\n         current_module: &Module<'a>,\n@@ -1807,7 +1807,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_path_resolution_error(\n+    pub(crate) fn report_path_resolution_error(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -2680,7 +2680,7 @@ fn is_span_suitable_for_use_injection(s: Span) -> bool {\n }\n \n /// Convert the given number into the corresponding ordinal\n-crate fn ordinalize(v: usize) -> String {\n+pub(crate) fn ordinalize(v: usize) -> String {\n     let suffix = match ((11..=13).contains(&(v % 100)), v % 10) {\n         (false, 1) => \"st\",\n         (false, 2) => \"nd\","}, {"sha": "b25393c3ed8e4daccfbff4a072b1f6d520cf792a", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -28,7 +28,7 @@ impl<'a> Resolver<'a> {\n     /// A generic scope visitor.\n     /// Visits scopes in order to resolve some identifier in them or perform other actions.\n     /// If the callback returns `Some` result, we stop visiting scopes and return it.\n-    crate fn visit_scopes<T>(\n+    pub(crate) fn visit_scopes<T>(\n         &mut self,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n@@ -274,7 +274,7 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     #[tracing::instrument(level = \"debug\", skip(self, ribs))]\n-    crate fn resolve_ident_in_lexical_scope(\n+    pub(crate) fn resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n@@ -368,7 +368,7 @@ impl<'a> Resolver<'a> {\n     /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n     /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     #[tracing::instrument(level = \"debug\", skip(self, scope_set))]\n-    crate fn early_resolve_ident_in_lexical_scope(\n+    pub(crate) fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n@@ -717,7 +717,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn maybe_resolve_ident_in_module(\n+    pub(crate) fn maybe_resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n@@ -729,7 +729,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn resolve_ident_in_module(\n+    pub(crate) fn resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n@@ -1303,7 +1303,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn maybe_resolve_path(\n+    pub(crate) fn maybe_resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -1313,7 +1313,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn resolve_path(\n+    pub(crate) fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -1324,7 +1324,7 @@ impl<'a> Resolver<'a> {\n         self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, ignore_binding)\n     }\n \n-    crate fn resolve_path_with_ribs(\n+    pub(crate) fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import"}, {"sha": "a8c8c674d2dd0ff4c0baa1fff96bc5b510a67a99", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -64,7 +64,7 @@ pub enum ImportKind<'a> {\n \n /// One import.\n #[derive(Debug, Clone)]\n-crate struct Import<'a> {\n+pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n     /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n@@ -125,7 +125,7 @@ impl<'a> Import<'a> {\n \n /// Records information about the resolution of a name in a namespace of a module.\n #[derive(Clone, Default, Debug)]\n-crate struct NameResolution<'a> {\n+pub(crate) struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n     pub single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n@@ -146,7 +146,7 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n+    pub(crate) fn add_single_import(&mut self, import: &'a Import<'a>) {\n         self.single_imports.insert(Interned::new_unchecked(import));\n     }\n }\n@@ -169,7 +169,7 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n impl<'a> Resolver<'a> {\n     // Given a binding and an import that resolves to it,\n     // return the corresponding binding defined by the import.\n-    crate fn import(\n+    pub(crate) fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n         import: &'a Import<'a>,\n@@ -198,7 +198,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    crate fn try_define(\n+    pub(crate) fn try_define(\n         &mut self,\n         module: Module<'a>,\n         key: BindingKey,"}, {"sha": "ff87baeef3e66ea6ef522ca69145970ddfcde3df", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -37,7 +37,7 @@ use std::mem::{replace, take};\n use tracing::debug;\n \n mod diagnostics;\n-crate mod lifetimes;\n+pub(crate) mod lifetimes;\n \n type Res = def::Res<NodeId>;\n \n@@ -90,7 +90,7 @@ enum PatBoundCtx {\n \n /// Does this the item (from the item rib scope) allow generic parameters?\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum HasGenericParams {\n+pub(crate) enum HasGenericParams {\n     Yes,\n     No,\n }\n@@ -102,15 +102,15 @@ impl HasGenericParams {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum ConstantItemKind {\n+pub(crate) enum ConstantItemKind {\n     Const,\n     Static,\n }\n \n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n-crate enum RibKind<'a> {\n+pub(crate) enum RibKind<'a> {\n     /// No restriction needs to be applied.\n     NormalRibKind,\n \n@@ -159,7 +159,7 @@ crate enum RibKind<'a> {\n impl RibKind<'_> {\n     /// Whether this rib kind contains generic parameters, as opposed to local\n     /// variables.\n-    crate fn contains_params(&self) -> bool {\n+    pub(crate) fn contains_params(&self) -> bool {\n         match self {\n             NormalRibKind\n             | ClosureOrAsyncRibKind\n@@ -187,7 +187,7 @@ impl RibKind<'_> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-crate struct Rib<'a, R = Res> {\n+pub(crate) struct Rib<'a, R = Res> {\n     pub bindings: IdentMap<R>,\n     pub kind: RibKind<'a>,\n }\n@@ -278,13 +278,13 @@ impl LifetimeRib {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum AliasPossibility {\n+pub(crate) enum AliasPossibility {\n     No,\n     Maybe,\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum PathSource<'a> {\n+pub(crate) enum PathSource<'a> {\n     // Type paths `Path`.\n     Type,\n     // Trait paths in bounds or impls.\n@@ -366,7 +366,7 @@ impl<'a> PathSource<'a> {\n         matches!(self, PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })))\n     }\n \n-    crate fn is_expected(self, res: Res) -> bool {\n+    pub(crate) fn is_expected(self, res: Res) -> bool {\n         match self {\n             PathSource::Type => matches!(\n                 res,"}, {"sha": "673b2e3a55a35f22df2ef43d5cd4f9f043251487", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -59,28 +59,28 @@ impl AssocSuggestion {\n     }\n }\n \n-crate enum MissingLifetimeSpot<'tcx> {\n+pub(crate) enum MissingLifetimeSpot<'tcx> {\n     Generics(&'tcx hir::Generics<'tcx>),\n     HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n     Static,\n }\n \n-crate enum ForLifetimeSpanType {\n+pub(crate) enum ForLifetimeSpanType {\n     BoundEmpty,\n     BoundTail,\n     TypeEmpty,\n     TypeTail,\n }\n \n impl ForLifetimeSpanType {\n-    crate fn descr(&self) -> &'static str {\n+    pub(crate) fn descr(&self) -> &'static str {\n         match self {\n             Self::BoundEmpty | Self::BoundTail => \"bound\",\n             Self::TypeEmpty | Self::TypeTail => \"type\",\n         }\n     }\n \n-    crate fn suggestion(&self, sugg: &str) -> String {\n+    pub(crate) fn suggestion(&self, sugg: &str) -> String {\n         match self {\n             Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n             Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n@@ -1221,7 +1221,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     /// Given the target `ident` and `kind`, search for the similarly named associated item\n     /// in `self.current_trait_ref`.\n-    crate fn find_similarly_named_assoc_item(\n+    pub(crate) fn find_similarly_named_assoc_item(\n         &mut self,\n         ident: Symbol,\n         kind: &AssocItemKind,\n@@ -1729,7 +1729,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    crate fn report_missing_type_error(\n+    pub(crate) fn report_missing_type_error(\n         &self,\n         path: &[Segment],\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n@@ -1809,7 +1809,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     /// Given the target `label`, search the `rib_index`th label rib for similarly named labels,\n     /// optionally returning the closest match and whether it is reachable.\n-    crate fn suggestion_for_label_in_rib(\n+    pub(crate) fn suggestion_for_label_in_rib(\n         &self,\n         rib_index: usize,\n         label: Ident,\n@@ -1834,7 +1834,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         })\n     }\n \n-    crate fn maybe_report_lifetime_uses(\n+    pub(crate) fn maybe_report_lifetime_uses(\n         &mut self,\n         generics_span: Span,\n         params: &[ast::GenericParam],\n@@ -1904,7 +1904,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    crate fn emit_undeclared_lifetime_error(\n+    pub(crate) fn emit_undeclared_lifetime_error(\n         &self,\n         lifetime_ref: &ast::Lifetime,\n         outer_lifetime_ref: Option<Ident>,\n@@ -2000,7 +2000,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         err.emit();\n     }\n \n-    crate fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n+    pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n         struct_span_err!(\n             self.r.session,\n             lifetime_ref.ident.span,\n@@ -2018,7 +2018,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n     /// This function will emit an error if `generic_const_exprs` is not enabled, the body identified by\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    crate fn maybe_emit_forbidden_non_static_lifetime_error(&self, lifetime_ref: &ast::Lifetime) {\n+    pub(crate) fn maybe_emit_forbidden_non_static_lifetime_error(\n+        &self,\n+        lifetime_ref: &ast::Lifetime,\n+    ) {\n         let feature_active = self.r.session.features_untracked().generic_const_exprs;\n         if !feature_active {\n             feature_err(\n@@ -2033,7 +2036,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n }\n \n impl<'tcx> LifetimeContext<'_, 'tcx> {\n-    crate fn report_missing_lifetime_specifiers(\n+    pub(crate) fn report_missing_lifetime_specifiers(\n         &self,\n         spans: Vec<Span>,\n         count: usize,\n@@ -2048,7 +2051,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     }\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n-    crate fn report_elision_failure(\n+    pub(crate) fn report_elision_failure(\n         &mut self,\n         diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n@@ -2126,7 +2129,10 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n     }\n \n-    crate fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n+    pub(crate) fn is_trait_ref_fn_scope(\n+        &mut self,\n+        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n+    ) -> bool {\n         if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n             if [\n                 self.tcx.lang_items().fn_once_trait(),\n@@ -2147,7 +2153,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         false\n     }\n \n-    crate fn add_missing_lifetime_specifiers_label(\n+    pub(crate) fn add_missing_lifetime_specifiers_label(\n         &self,\n         err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,"}, {"sha": "2fe65441ac90e8e6da53b35dd4a06157744e1627", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -151,8 +151,8 @@ struct NamedRegionMap {\n     scope_for_path: Option<FxHashMap<LocalDefId, FxHashMap<ItemLocalId, LifetimeScopeForPath>>>,\n }\n \n-crate struct LifetimeContext<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct LifetimeContext<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -169,7 +169,7 @@ crate struct LifetimeContext<'a, 'tcx> {\n \n     /// When encountering an undefined named lifetime, we will suggest introducing it in these\n     /// places.\n-    crate missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n+    pub(crate) missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n }\n \n #[derive(Debug)]\n@@ -335,14 +335,14 @@ enum Elide {\n }\n \n #[derive(Clone, Debug)]\n-crate struct ElisionFailureInfo {\n+pub(crate) struct ElisionFailureInfo {\n     /// Where we can find the argument pattern.\n-    crate parent: Option<hir::BodyId>,\n+    pub(crate) parent: Option<hir::BodyId>,\n     /// The index of the argument in the original definition.\n-    crate index: usize,\n-    crate lifetime_count: usize,\n-    crate have_bound_regions: bool,\n-    crate span: Span,\n+    pub(crate) index: usize,\n+    pub(crate) lifetime_count: usize,\n+    pub(crate) have_bound_regions: bool,\n+    pub(crate) span: Span,\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;"}, {"sha": "73c8a9d28bd5f4372d364ea95d657086a8b6ec4c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -9,7 +9,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "7e6375968aeb64b58fab58e84b148d185de5b4c0", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -41,10 +41,10 @@ type Res = def::Res<NodeId>;\n /// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n pub struct MacroRulesBinding<'a> {\n-    crate binding: &'a NameBinding<'a>,\n+    pub(crate) binding: &'a NameBinding<'a>,\n     /// `macro_rules` scope into which the `macro_rules` item was planted.\n-    crate parent_macro_rules_scope: MacroRulesScopeRef<'a>,\n-    crate ident: Ident,\n+    pub(crate) parent_macro_rules_scope: MacroRulesScopeRef<'a>,\n+    pub(crate) ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n@@ -74,7 +74,10 @@ pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>\n /// Macro namespace is separated into two sub-namespaces, one for bang macros and\n /// one for attribute-like macros (attributes, derives).\n /// We ignore resolutions from one sub-namespace when searching names in scope for another.\n-crate fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n+pub(crate) fn sub_namespace_match(\n+    candidate: Option<MacroKind>,\n+    requirement: Option<MacroKind>,\n+) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS {\n         Bang,\n@@ -140,7 +143,7 @@ fn registered_idents(\n     registered\n }\n \n-crate fn registered_attrs_and_tools(\n+pub(crate) fn registered_attrs_and_tools(\n     sess: &Session,\n     attrs: &[ast::Attribute],\n ) -> (FxHashSet<Ident>, FxHashSet<Ident>) {\n@@ -651,7 +654,7 @@ impl<'a> Resolver<'a> {\n         res.map(|res| (self.get_macro(res), res))\n     }\n \n-    crate fn finalize_macro_resolutions(&mut self) {\n+    pub(crate) fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self,\n                                  path: &[Segment],\n                                  span,\n@@ -839,7 +842,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n+    pub(crate) fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n@@ -856,7 +859,7 @@ impl<'a> Resolver<'a> {\n     /// Compile the macro into a `SyntaxExtension` and its rule spans.\n     ///\n     /// Possibly replace its expander to a pre-defined one for built-in macros.\n-    crate fn compile_macro(\n+    pub(crate) fn compile_macro(\n         &mut self,\n         item: &ast::Item,\n         edition: Edition,"}, {"sha": "997f361737b349236d4e36039674a3c12356da2b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1912,7 +1912,7 @@ fn select_debuginfo(\n     }\n }\n \n-crate fn parse_assert_incr_state(\n+pub(crate) fn parse_assert_incr_state(\n     opt_assertion: &Option<String>,\n     error_format: ErrorOutputType,\n ) -> Option<IncrementalStateAssertion> {\n@@ -2755,7 +2755,7 @@ impl PpMode {\n /// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n-crate mod dep_tracking {\n+pub(crate) mod dep_tracking {\n     use super::{\n         BranchProtection, CFGuard, CFProtection, CrateType, DebugInfo, ErrorOutputType,\n         InstrumentCoverage, LdImpl, LinkerPluginLto, LocationDetail, LtoCli, OomStrategy, OptLevel,\n@@ -2933,7 +2933,7 @@ crate mod dep_tracking {\n     }\n \n     // This is a stable hash because BTreeMap is a sorted container\n-    crate fn stable_hash(\n+    pub(crate) fn stable_hash(\n         sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n         hasher: &mut DefaultHasher,\n         error_format: ErrorOutputType,"}, {"sha": "f84a154950f646925e2e8106e9df16372396518b", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,4 +1,3 @@\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![cfg_attr(bootstrap, feature(derive_default_enum))]"}, {"sha": "12e00ef51140bbacf89dc612ed2f10d8ab6a3564", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 72, "deletions": 48, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -421,12 +421,12 @@ mod desc {\n }\n \n mod parse {\n-    crate use super::*;\n+    pub(crate) use super::*;\n     use std::str::FromStr;\n \n     /// This is for boolean options that don't take a value and start with\n     /// `no-`. This style of option is deprecated.\n-    crate fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n         match v {\n             None => {\n                 *slot = true;\n@@ -437,7 +437,7 @@ mod parse {\n     }\n \n     /// Use this for any boolean option that has a static default.\n-    crate fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n         match v {\n             Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n                 *slot = true;\n@@ -454,7 +454,7 @@ mod parse {\n     /// Use this for any boolean option that lacks a static default. (The\n     /// actions taken when such an option is not specified will depend on\n     /// other factors, such as other options, or target options.)\n-    crate fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n         match v {\n             Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n                 *slot = Some(true);\n@@ -469,7 +469,7 @@ mod parse {\n     }\n \n     /// Use this for any string option that has a static default.\n-    crate fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.to_string();\n@@ -480,7 +480,7 @@ mod parse {\n     }\n \n     /// Use this for any string option that lacks a static default.\n-    crate fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = Some(s.to_string());\n@@ -491,7 +491,7 @@ mod parse {\n     }\n \n     /// Parse an optional language identifier, e.g. `en-US` or `zh-CN`.\n-    crate fn parse_opt_langid(slot: &mut Option<LanguageIdentifier>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_langid(slot: &mut Option<LanguageIdentifier>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = rustc_errors::LanguageIdentifier::from_str(s).ok();\n@@ -501,7 +501,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = Some(PathBuf::from(s));\n@@ -511,7 +511,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 slot.push(s.to_string());\n@@ -521,7 +521,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_list(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_list(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 slot.extend(s.split_whitespace().map(|s| s.to_string()));\n@@ -531,7 +531,10 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_list_with_polarity(slot: &mut Vec<(String, bool)>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_list_with_polarity(\n+        slot: &mut Vec<(String, bool)>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 for s in s.split(\",\") {\n@@ -544,7 +547,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_location_detail(ld: &mut LocationDetail, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_location_detail(ld: &mut LocationDetail, v: Option<&str>) -> bool {\n         if let Some(v) = v {\n             ld.line = false;\n             ld.file = false;\n@@ -563,7 +566,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 let mut v: Vec<_> = s.split(',').map(|s| s.to_string()).collect();\n@@ -575,7 +578,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n         match v.and_then(|s| s.parse().ok()) {\n             Some(0) => {\n                 *slot = std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get);\n@@ -590,7 +593,7 @@ mod parse {\n     }\n \n     /// Use this for any numeric option that has a static default.\n-    crate fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n         match v.and_then(|s| s.parse().ok()) {\n             Some(i) => {\n                 *slot = i;\n@@ -601,7 +604,10 @@ mod parse {\n     }\n \n     /// Use this for any numeric option that lacks a static default.\n-    crate fn parse_opt_number<T: Copy + FromStr>(slot: &mut Option<T>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_number<T: Copy + FromStr>(\n+        slot: &mut Option<T>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.parse().ok();\n@@ -611,7 +617,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n         match v {\n             Some(\"all\") => {\n                 *slot = Passes::All;\n@@ -629,7 +635,10 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_panic_strategy(\n+        slot: &mut Option<PanicStrategy>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n             Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n@@ -638,7 +647,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n         match v {\n             Some(\"unwind\") => *slot = PanicStrategy::Unwind,\n             Some(\"abort\") => *slot = PanicStrategy::Abort,\n@@ -647,7 +656,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_oom_strategy(slot: &mut OomStrategy, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_oom_strategy(slot: &mut OomStrategy, v: Option<&str>) -> bool {\n         match v {\n             Some(\"panic\") => *slot = OomStrategy::Panic,\n             Some(\"abort\") => *slot = OomStrategy::Abort,\n@@ -656,7 +665,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => match s.parse::<RelroLevel>() {\n                 Ok(level) => *slot = Some(level),\n@@ -667,7 +676,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n         if let Some(v) = v {\n             for s in v.split(',') {\n                 *slot |= match s {\n@@ -687,7 +696,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n         match v {\n             Some(\"2\") | None => {\n                 *slot = 2;\n@@ -705,7 +714,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n         match v {\n             Some(\"none\") => *slot = Strip::None,\n             Some(\"debuginfo\") => *slot = Strip::Debuginfo,\n@@ -715,7 +724,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -733,7 +742,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_cfprotection(slot: &mut CFProtection, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_cfprotection(slot: &mut CFProtection, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -752,15 +761,18 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_linker_flavor(slot: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_linker_flavor(slot: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n         match v.and_then(LinkerFlavor::from_str) {\n             Some(lf) => *slot = Some(lf),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_optimization_fuel(\n+        slot: &mut Option<(String, u64)>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             None => false,\n             Some(s) => {\n@@ -779,7 +791,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n         match v {\n             None => false,\n             Some(s) if s.split('=').count() <= 2 => {\n@@ -790,7 +802,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -813,7 +825,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_instrument_coverage(\n+    pub(crate) fn parse_instrument_coverage(\n         slot: &mut Option<InstrumentCoverage>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -844,7 +856,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.parse().ok();\n@@ -857,7 +869,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -875,7 +887,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -895,23 +907,29 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_switch_with_opt_path(\n+        slot: &mut SwitchWithOptPath,\n+        v: Option<&str>,\n+    ) -> bool {\n         *slot = match v {\n             None => SwitchWithOptPath::Enabled(None),\n             Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n         };\n         true\n     }\n \n-    crate fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_merge_functions(\n+        slot: &mut Option<MergeFunctions>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n             Some(mergefunc) => *slot = Some(mergefunc),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| RelocModel::from_str(s).ok()) {\n             Some(relocation_model) => *slot = Some(relocation_model),\n             None if v == Some(\"default\") => *slot = None,\n@@ -920,23 +938,23 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| CodeModel::from_str(s).ok()) {\n             Some(code_model) => *slot = Some(code_model),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| TlsModel::from_str(s).ok()) {\n             Some(tls_model) => *slot = Some(tls_model),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_symbol_mangling_version(\n+    pub(crate) fn parse_symbol_mangling_version(\n         slot: &mut Option<SymbolManglingVersion>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -948,7 +966,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_src_file_hash(\n+    pub(crate) fn parse_src_file_hash(\n         slot: &mut Option<SourceFileHashAlgorithm>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -959,7 +977,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 if !slot.is_empty() {\n@@ -972,7 +990,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n         match v {\n             Some(\"command\") => *slot = Some(WasiExecModel::Command),\n             Some(\"reactor\") => *slot = Some(WasiExecModel::Reactor),\n@@ -981,23 +999,26 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_split_debuginfo(slot: &mut Option<SplitDebuginfo>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_split_debuginfo(\n+        slot: &mut Option<SplitDebuginfo>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v.and_then(|s| SplitDebuginfo::from_str(s).ok()) {\n             Some(e) => *slot = Some(e),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n         match v.and_then(|s| SplitDwarfKind::from_str(s).ok()) {\n             Some(e) => *slot = e,\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n         match v {\n             None => *slot = None,\n             Some(\"lld\") => *slot = Some(LdImpl::Lld),\n@@ -1006,15 +1027,18 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_stack_protector(slot: &mut StackProtector, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_stack_protector(slot: &mut StackProtector, v: Option<&str>) -> bool {\n         match v.and_then(|s| StackProtector::from_str(s).ok()) {\n             Some(ssp) => *slot = ssp,\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_branch_protection(slot: &mut Option<BranchProtection>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_branch_protection(\n+        slot: &mut Option<BranchProtection>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 let slot = slot.get_or_insert_default();"}, {"sha": "59f2badbabbf62df56e8af0aa6b61592e2202d7f", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -352,7 +352,7 @@ pub struct HygieneData {\n }\n \n impl HygieneData {\n-    crate fn new(edition: Edition) -> Self {\n+    pub(crate) fn new(edition: Edition) -> Self {\n         let root_data = ExpnData::default(\n             ExpnKind::Root,\n             DUMMY_SP,\n@@ -668,17 +668,17 @@ impl SyntaxContext {\n     }\n \n     #[inline]\n-    crate fn as_u32(self) -> u32 {\n+    pub(crate) fn as_u32(self) -> u32 {\n         self.0\n     }\n \n     #[inline]\n-    crate fn from_u32(raw: u32) -> SyntaxContext {\n+    pub(crate) fn from_u32(raw: u32) -> SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n     /// Extend a syntax context with a given expansion and transparency.\n-    crate fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+    pub(crate) fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n "}, {"sha": "8737e45487e9088bca701491341b0141b1e611c2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,7 +15,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(if_let_guard)]\n #![feature(negative_impls)]"}, {"sha": "f46e8ff000423b9288c90686d33baeff689285a7", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -14,7 +14,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]"}, {"sha": "452b0d73c97cacff6bef0b4c64215ab288b33717", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -500,7 +500,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits.\n #[instrument(skip(tcx, predicates), level = \"debug\")]\n-crate fn required_region_bounds<'tcx>(\n+pub(crate) fn required_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     erased_self_ty: Ty<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,"}, {"sha": "592b0ab477a393056420847aada1759498d4eaf1", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -17,7 +17,7 @@ pub struct FulfillmentContext<'tcx> {\n }\n \n impl FulfillmentContext<'_> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         FulfillmentContext {\n             obligations: FxIndexSet::default(),\n             relationships: FxHashMap::default(),"}, {"sha": "a51e6e58f67a984349ca44d61e313df2cdef3d83", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1488,7 +1488,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        crate fn build_fn_sig_string<'tcx>(\n+        pub(crate) fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n             trait_ref: ty::PolyTraitRef<'tcx>,\n         ) -> String {"}, {"sha": "a71621a4d52c0b90572d4adab0626af53008cb8e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2116,7 +2116,7 @@ fn assoc_def(\n     }\n }\n \n-crate trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n+pub(crate) trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: ty::PolyProjectionPredicate<'tcx>,"}, {"sha": "b0b17d0f9e6673b28e3909f4d9c2a59d9d89ac53", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -332,7 +332,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    crate fn select_from_obligation(\n+    pub(crate) fn select_from_obligation(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {"}, {"sha": "95f1e224a4c7f2ae66ba02d1113c22c13d49fdca", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -486,7 +486,7 @@ fn report_conflicting_impls(\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a\n /// string.\n-crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n+pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n     let trait_ref = tcx.impl_trait_ref(impl_def_id)?;"}, {"sha": "2b7ba22c4de38c1d29b22733101173faaf81a15c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -44,7 +44,7 @@ use std::collections::btree_map::{BTreeMap, Entry};\n use std::ops::ControlFlow;\n \n /// Essentially an `Into` with a `&RustInterner` parameter\n-crate trait LowerInto<'tcx, T> {\n+pub(crate) trait LowerInto<'tcx, T> {\n     /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk type, consuming `self`.\n     fn lower_into(self, interner: RustInterner<'tcx>) -> T;\n }\n@@ -836,7 +836,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n /// It's important to note that because of prior substitution, we may have\n /// late-bound regions, even outside of fn contexts, since this is the best way\n /// to prep types for chalk lowering.\n-crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n+pub(crate) fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     interner: RustInterner<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     ty: Binder<'tcx, T>,\n@@ -870,14 +870,14 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     (new_ty, binders, named_parameters)\n }\n \n-crate struct BoundVarsCollector<'tcx> {\n+pub(crate) struct BoundVarsCollector<'tcx> {\n     binder_index: ty::DebruijnIndex,\n-    crate parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n-    crate named_parameters: Vec<DefId>,\n+    pub(crate) parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n+    pub(crate) named_parameters: Vec<DefId>,\n }\n \n impl<'tcx> BoundVarsCollector<'tcx> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         BoundVarsCollector {\n             binder_index: ty::INNERMOST,\n             parameters: BTreeMap::new(),\n@@ -1001,17 +1001,17 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n \n /// Used to substitute `Param`s with placeholders. We do this since Chalk\n /// have a notion of `Param`s.\n-crate struct ParamsSubstitutor<'tcx> {\n+pub(crate) struct ParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n     next_ty_placeholder: usize,\n-    crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n-    crate named_regions: BTreeMap<DefId, u32>,\n+    pub(crate) params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    pub(crate) named_regions: BTreeMap<DefId, u32>,\n }\n \n impl<'tcx> ParamsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n         ParamsSubstitutor {\n             tcx,\n             binder_index: ty::INNERMOST,\n@@ -1083,13 +1083,13 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n     }\n }\n \n-crate struct ReverseParamsSubstitutor<'tcx> {\n+pub(crate) struct ReverseParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n }\n \n impl<'tcx> ReverseParamsSubstitutor<'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n     ) -> Self {\n@@ -1117,14 +1117,14 @@ impl<'tcx> TypeFolder<'tcx> for ReverseParamsSubstitutor<'tcx> {\n }\n \n /// Used to collect `Placeholder`s.\n-crate struct PlaceholdersCollector {\n+pub(crate) struct PlaceholdersCollector {\n     universe_index: ty::UniverseIndex,\n-    crate next_ty_placeholder: usize,\n-    crate next_anon_region_placeholder: u32,\n+    pub(crate) next_ty_placeholder: usize,\n+    pub(crate) next_anon_region_placeholder: u32,\n }\n \n impl PlaceholdersCollector {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         PlaceholdersCollector {\n             universe_index: ty::UniverseIndex::ROOT,\n             next_ty_placeholder: 0,"}, {"sha": "59cf37fee9c4327ad3a7f05c76519e0a73367964", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -3,8 +3,8 @@\n //! In order to call `chalk-solve`, this file must convert a `CanonicalChalkEnvironmentAndGoal` into\n //! a Chalk uncanonical goal. It then calls Chalk, and converts the answer back into rustc solution.\n \n-crate mod db;\n-crate mod lowering;\n+pub(crate) mod db;\n+pub(crate) mod lowering;\n \n use rustc_data_structures::fx::FxHashMap;\n \n@@ -27,11 +27,11 @@ use crate::chalk::lowering::{ParamsSubstitutor, PlaceholdersCollector, ReversePa\n \n use chalk_solve::Solution;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { evaluate_goal, ..*p };\n }\n \n-crate fn evaluate_goal<'tcx>(\n+pub(crate) fn evaluate_goal<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     obligation: CanonicalChalkEnvironmentAndGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {"}, {"sha": "a20de08b4eff28c947f5026f24b7c00c82533d1b", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -17,7 +17,7 @@ use rustc_trait_selection::traits::{\n     Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n };\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n }\n \n@@ -304,7 +304,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n }\n \n /// Calculates the dtorck constraint for a type.\n-crate fn adt_dtorck_constraint(\n+pub(crate) fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> Result<&DropckConstraint<'_>, NoSolution> {"}, {"sha": "3fc141471b92ab31264e12876115542c33c0be92", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -7,7 +7,7 @@ use rustc_trait_selection::traits::{\n     EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n };\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { evaluate_obligation, ..*p };\n }\n "}, {"sha": "965324113d526edaa2b1c49adbbd601b0ae3c75d", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -18,7 +18,7 @@ use rustc_trait_selection::traits::FulfillmentContext;\n use rustc_trait_selection::traits::TraitEngine;\n use smallvec::{smallvec, SmallVec};\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { implied_outlives_bounds, ..*p };\n }\n "}, {"sha": "6489bd2202deba0734346ab58031480d806b5a97", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1,7 +1,6 @@\n //! New recursive solver modeled on Chalk's recursive solver. Most of\n //! the guts are broken up into modules; see the comments in those modules.\n \n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]"}, {"sha": "a8a324dec97ba7045f440a3703f9f307b13e3417", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -6,7 +6,7 @@ use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n         try_normalize_generic_arg_after_erasing_regions: |tcx, goal| {\n             debug!(\"try_normalize_generic_arg_after_erasing_regions(goal={:#?}\", goal);"}, {"sha": "98bb42c9afda1cf0566ed535bb2c3e033dd129b0", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::query::{\n use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { normalize_projection_ty, ..*p };\n }\n "}, {"sha": "f8bac1d7b263f65c42a577b251fbbb4118f735c6", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -23,7 +23,7 @@ use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n         type_op_ascribe_user_type,\n         type_op_eq,"}, {"sha": "96d083bb94f3c9353d7d55e85a3ae0e317d03989", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -640,7 +640,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         assoc_bindings\n     }\n \n-    crate fn create_substs_for_associated_item(\n+    pub(crate) fn create_substs_for_associated_item(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         span: Span,"}, {"sha": "a17b13d49fd7f2cd42f1f678967e99d76b0bf423", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1351,7 +1351,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n     #[instrument(skip(self, fcx, augment_error, label_expression_as_expected), level = \"debug\")]\n-    crate fn coerce_inner<'a>(\n+    pub(crate) fn coerce_inner<'a>(\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "277bc1cf0f06514abfdf23df83dc4f9d49f81275", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -28,7 +28,7 @@ use super::{potentially_plural_count, FnCtxt, Inherited};\n /// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n-crate fn compare_impl_method<'tcx>(\n+pub(crate) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n@@ -1038,7 +1038,7 @@ fn compare_generic_param_kinds<'tcx>(\n     Ok(())\n }\n \n-crate fn compare_const_impl<'tcx>(\n+pub(crate) fn compare_const_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_c: &ty::AssocItem,\n     impl_c_span: Span,\n@@ -1144,7 +1144,7 @@ crate fn compare_const_impl<'tcx>(\n     });\n }\n \n-crate fn compare_ty_impl<'tcx>(\n+pub(crate) fn compare_ty_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n     impl_ty_span: Span,"}, {"sha": "ceb57386e300f177059de32a0ad9f0d149f0d9eb", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn maybe_get_struct_pattern_shorthand_field(\n+    pub(crate) fn maybe_get_struct_pattern_shorthand_field(\n         &self,\n         expr: &hir::Expr<'_>,\n     ) -> Option<Symbol> {\n@@ -539,15 +539,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// If the given `HirId` corresponds to a block with a trailing expression, return that expression\n-    crate fn maybe_get_block_expr(&self, expr: &hir::Expr<'tcx>) -> Option<&'tcx hir::Expr<'tcx>> {\n+    pub(crate) fn maybe_get_block_expr(\n+        &self,\n+        expr: &hir::Expr<'tcx>,\n+    ) -> Option<&'tcx hir::Expr<'tcx>> {\n         match expr {\n             hir::Expr { kind: hir::ExprKind::Block(block, ..), .. } => block.expr,\n             _ => None,\n         }\n     }\n \n     /// Returns whether the given expression is an `else if`.\n-    crate fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n+    pub(crate) fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n         if let hir::ExprKind::If(..) = expr.kind {\n             let parent_id = self.tcx.hir().get_parent_node(expr.hir_id);\n             if let Some(Node::Expr(hir::Expr {"}, {"sha": "307064327c5a35bf804de8d0e42aaba93af0cd5b", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -231,7 +231,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n /// This function is not only checking that the dropck obligations are met for\n /// the given type, but it's also currently preventing non-regular recursion in\n /// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n-crate fn check_drop_obligations<'a, 'tcx>(\n+pub(crate) fn check_drop_obligations<'a, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n@@ -248,7 +248,7 @@ crate fn check_drop_obligations<'a, 'tcx>(\n // This is an implementation of the TypeRelation trait with the\n // aim of simply comparing for equality (without side-effects).\n // It is not intended to be used anywhere else other than here.\n-crate struct SimpleEqRelation<'tcx> {\n+pub(crate) struct SimpleEqRelation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }"}, {"sha": "09b0dc0a0ea2ed24837b681e30f424b7ed8b2671", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -2430,7 +2430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    crate fn get_field_candidates(\n+    pub(crate) fn get_field_candidates(\n         &self,\n         span: Span,\n         base_t: Ty<'tcx>,\n@@ -2455,7 +2455,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// This method is called after we have encountered a missing field error to recursively\n     /// search for the field\n-    crate fn check_for_nested_field_satisfying(\n+    pub(crate) fn check_for_nested_field_satisfying(\n         &self,\n         span: Span,\n         matches: &impl Fn(&ty::FieldDef, Ty<'tcx>) -> bool,"}, {"sha": "3249157c4f4541cb465a34ee0c3d94aa230696e8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1486,7 +1486,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Add all the obligations that are required, substituting and normalized appropriately.\n-    crate fn add_required_obligations(&self, span: Span, def_id: DefId, substs: &SubstsRef<'tcx>) {\n+    pub(crate) fn add_required_obligations(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        substs: &SubstsRef<'tcx>,\n+    ) {\n         self.add_required_obligations_with_code(\n             span,\n             def_id,"}, {"sha": "d4c5caa6e92925d105fc8fbf6ddce6b67e470e1c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Adds a suggestion to call the given method to the provided diagnostic.\n     #[instrument(level = \"debug\", skip(self, err, call_expr))]\n-    crate fn suggest_method_call(\n+    pub(crate) fn suggest_method_call(\n         &self,\n         err: &mut Diagnostic,\n         msg: &str,"}, {"sha": "f9c0ea82e02f1a0f3ec6c36a552e0b268177331d", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -1343,7 +1343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    crate fn note_unmet_impls_on_type(\n+    pub(crate) fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,\n         errors: Vec<FulfillmentError<'tcx>>,"}, {"sha": "583958ade625dc5155474bdc90331c2548994c4a", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -646,7 +646,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-crate trait Locatable {\n+pub(crate) trait Locatable {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n "}, {"sha": "c7823b444bfa5dcc953b0f40065302a9c00b2721", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -110,7 +110,7 @@ pub struct ItemCtxt<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n #[derive(Default)]\n-crate struct HirPlaceholderCollector(crate Vec<Span>);\n+pub(crate) struct HirPlaceholderCollector(pub(crate) Vec<Span>);\n \n impl<'v> Visitor<'v> for HirPlaceholderCollector {\n     fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n@@ -144,7 +144,7 @@ struct CollectItemTypesVisitor<'tcx> {\n /// If there are any placeholder types (`_`), emit an error explaining that this is not allowed\n /// and suggest adding type parameters in the appropriate place, taking into consideration any and\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n-crate fn placeholder_type_error<'tcx>(\n+pub(crate) fn placeholder_type_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n@@ -160,7 +160,7 @@ crate fn placeholder_type_error<'tcx>(\n         .emit();\n }\n \n-crate fn placeholder_type_error_diag<'tcx>(\n+pub(crate) fn placeholder_type_error_diag<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,"}, {"sha": "4ffd199b133ad080f8efeb88540a7e7b9dbd575c", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -59,7 +59,6 @@ This API is completely unstable and subject to change.\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n #![feature(if_let_guard)]"}, {"sha": "21916352532b1698231bc935415ad7594aa53d14", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -65,7 +65,7 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-crate trait HirNode {\n+pub(crate) trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;\n }\n@@ -89,19 +89,19 @@ impl HirNode for hir::Pat<'_> {\n }\n \n #[derive(Clone)]\n-crate struct MemCategorizationContext<'a, 'tcx> {\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n+pub(crate) struct MemCategorizationContext<'a, 'tcx> {\n+    pub(crate) typeck_results: &'a ty::TypeckResults<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_owner: LocalDefId,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n }\n \n-crate type McResult<T> = Result<T, ()>;\n+pub(crate) type McResult<T> = Result<T, ()>;\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext`.\n-    crate fn new(\n+    pub(crate) fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: LocalDefId,\n@@ -116,11 +116,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn tcx(&self) -> TyCtxt<'tcx> {\n+    pub(crate) fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    crate fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n \n@@ -162,15 +162,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(hir_id, self.typeck_results.node_type_opt(hir_id))\n     }\n \n     fn expr_ty(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_opt(expr))\n     }\n \n-    crate fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_adjusted_opt(expr))\n     }\n \n@@ -184,7 +184,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    crate fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n+    pub(crate) fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         helper(self, expr, self.typeck_results.expr_adjustments(expr))\n     }\n \n-    crate fn cat_expr_adjusted(\n+    pub(crate) fn cat_expr_adjusted(\n         &self,\n         expr: &hir::Expr<'_>,\n         previous: PlaceWithHirId<'tcx>,\n@@ -298,7 +298,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n+    pub(crate) fn cat_expr_unadjusted(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -383,7 +386,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_res(\n+    pub(crate) fn cat_res(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n@@ -440,7 +443,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_rvalue(\n+    pub(crate) fn cat_rvalue(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n@@ -452,7 +455,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    crate fn cat_projection<N: HirNode>(\n+    pub(crate) fn cat_projection<N: HirNode>(\n         &self,\n         node: &N,\n         base_place: PlaceWithHirId<'tcx>,\n@@ -521,7 +524,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_pattern<F>(\n+    pub(crate) fn cat_pattern<F>(\n         &self,\n         place: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,"}, {"sha": "dccfee19960c50d28243529417bdeabf3fdb2905", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::Span;\n \n mod explicit;\n mod implicit_infer;\n-crate mod outlives_bounds;\n+pub(crate) mod outlives_bounds;\n /// Code to write unit test for outlives.\n pub mod test;\n mod utils;"}, {"sha": "f1dc3cbbac459f72305b4ebe5d09d318d5536289", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c82f31a85f04a709810de4ccfb8ba765c1377b/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=49c82f31a85f04a709810de4ccfb8ba765c1377b", "patch": "@@ -15,28 +15,28 @@ use GenericArgsInfo::*;\n \n /// Handles the `wrong number of type / lifetime / ... arguments` family of error messages.\n pub struct WrongNumberOfGenericArgs<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n \n-    crate angle_brackets: AngleBrackets,\n+    pub(crate) angle_brackets: AngleBrackets,\n \n-    crate gen_args_info: GenericArgsInfo,\n+    pub(crate) gen_args_info: GenericArgsInfo,\n \n     /// Offending path segment\n-    crate path_segment: &'a hir::PathSegment<'a>,\n+    pub(crate) path_segment: &'a hir::PathSegment<'a>,\n \n     /// Generic parameters as expected by type or trait\n-    crate gen_params: &'a ty::Generics,\n+    pub(crate) gen_params: &'a ty::Generics,\n \n     /// Index offset into parameters. Depends on whether `Self` is included and on\n     /// number of lifetime parameters in case we're processing missing or redundant\n     /// type or constant arguments.\n-    crate params_offset: usize,\n+    pub(crate) params_offset: usize,\n \n     /// Generic arguments as provided by user\n-    crate gen_args: &'a hir::GenericArgs<'a>,\n+    pub(crate) gen_args: &'a hir::GenericArgs<'a>,\n \n     /// DefId of the generic type\n-    crate def_id: DefId,\n+    pub(crate) def_id: DefId,\n }\n \n // Provides information about the kind of arguments that were provided for"}]}