{"sha": "a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZjNmMGNkYjMwZjRlOThlMGVkMjJjMGM1MWJlZmNjMGNmYmVkNDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-02T16:25:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-02T16:25:12Z"}, "message": "Rollup merge of #59166 - seanmonstar:trait-alias-import, r=alexreg\n\nresolve: collect trait aliases along with traits\n\nIt seems trait aliases weren't being collected as `TraitCandidates` in resolve, this should change that. (I can't compile the full compiler locally, so relying on CI...)\n\nFixes https://github.com/rust-lang/rust/issues/56485\n\nr? @alexreg", "tree": {"sha": "02fdc9a2bb8ea750026a4b82af6a02a511a9f8e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02fdc9a2bb8ea750026a4b82af6a02a511a9f8e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJco4zoCRBK7hj4Ov3rIwAAdHIIAGmM9I1DOYR1l5ILvmuCPHzd\nf79mD/+Yt0XIHCtGqM2AGkbjvF2+f/xed1nm6uG5w3LlAM+yLOIqUxVbjvMwmO+m\ngoCS/GXzcD/F2mw/sm+y74bPaLzrW6Dhavx77Zda0lx3QYUN/N4qw1abbQ21xmab\nZvJt4BII+YzmVIU4XmyjgrQsOroa2saHM4KQ1f9lFxG2/DGwQKB5jlJXxJqVw7lt\nu4rH/8uWxUuJ5rm4GPj62RQ4CmJbUVkbbk3FBnHg2l17hSAv4bxr7fghI/K9VI8D\naViGG4DBrB+Vhtz+iGu5tSV1sfK8l84zEAeIE8nFBnHLSeiEvBTAXorMvjMqyMc=\n=6J4Q\n-----END PGP SIGNATURE-----\n", "payload": "tree 02fdc9a2bb8ea750026a4b82af6a02a511a9f8e0\nparent e008e4fde837313d4a72da603ef492a721afc998\nparent 3ccd35cd70eed139de411f9533d406c498ed4d62\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554222312 +0200\ncommitter GitHub <noreply@github.com> 1554222312 +0200\n\nRollup merge of #59166 - seanmonstar:trait-alias-import, r=alexreg\n\nresolve: collect trait aliases along with traits\n\nIt seems trait aliases weren't being collected as `TraitCandidates` in resolve, this should change that. (I can't compile the full compiler locally, so relying on CI...)\n\nFixes https://github.com/rust-lang/rust/issues/56485\n\nr? @alexreg\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "html_url": "https://github.com/rust-lang/rust/commit/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e008e4fde837313d4a72da603ef492a721afc998", "url": "https://api.github.com/repos/rust-lang/rust/commits/e008e4fde837313d4a72da603ef492a721afc998", "html_url": "https://github.com/rust-lang/rust/commit/e008e4fde837313d4a72da603ef492a721afc998"}, {"sha": "3ccd35cd70eed139de411f9533d406c498ed4d62", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccd35cd70eed139de411f9533d406c498ed4d62", "html_url": "https://github.com/rust-lang/rust/commit/3ccd35cd70eed139de411f9533d406c498ed4d62"}], "stats": {"total": 229, "additions": 192, "deletions": 37}, "files": [{"sha": "1934f800af7575a8e9886fb809d0753408acd62d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -1352,7 +1352,7 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    // We sometimes need to treat variants as `pub` for backwards compatibility\n+    // We sometimes need to treat variants as `pub` for backwards compatibility.\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() && self.def().def_id().is_local() {\n             ty::Visibility::Public\n@@ -2714,7 +2714,7 @@ impl<'a> Resolver<'a> {\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n-        // plain insert (no renaming, types are not currently hygienic....)\n+        // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n@@ -4438,26 +4438,47 @@ impl<'a> Resolver<'a> {\n             let mut collected_traits = Vec::new();\n             module.for_each_child(|name, ns, binding| {\n                 if ns != TypeNS { return }\n-                if let Def::Trait(_) = binding.def() {\n-                    collected_traits.push((name, binding));\n+                match binding.def() {\n+                    Def::Trait(_) |\n+                    Def::TraitAlias(_) => collected_traits.push((name, binding)),\n+                    _ => (),\n                 }\n             });\n             *traits = Some(collected_traits.into_boxed_slice());\n         }\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            let module = binding.module().unwrap();\n-            let mut ident = ident;\n-            if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n-                continue\n-            }\n-            if self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                false,\n-                module.span,\n-            ).is_ok() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(\n+                    module.expansion,\n+                    binding.span.ctxt().modern(),\n+                ).is_none() {\n+                    continue\n+                }\n+                if self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    false,\n+                    module.span,\n+                ).is_ok() {\n+                    let import_id = match binding.kind {\n+                        NameBindingKind::Import { directive, .. } => {\n+                            self.maybe_unused_trait_imports.insert(directive.id);\n+                            self.add_to_glob_map(&directive, trait_name);\n+                            Some(directive.id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+                }\n+            } else if let Def::TraitAlias(_) = binding.def() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -4466,8 +4487,10 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n-                let trait_def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+                let trait_def_id = binding.def().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n             }\n         }\n     }"}, {"sha": "97b630ba5f298c8e1632b40a4289f3057baa590b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -1334,7 +1334,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = module.def() {\n+        if module.is_trait() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id()  {"}, {"sha": "42156213f21df8713a14fa1687d33de69a8a63cc", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -896,20 +896,36 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let trait_substs = self.fresh_item_substs(trait_def_id);\n         let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n \n-        for item in self.impl_or_trait_item(trait_def_id) {\n-            // Check whether `trait_def_id` defines a method with suitable name:\n-            if !self.has_applicable_self(&item) {\n-                debug!(\"method has inapplicable self\");\n-                self.record_static_candidate(TraitSource(trait_def_id));\n-                continue;\n-            }\n+        if self.tcx.is_trait_alias(trait_def_id) {\n+            // For trait aliases, assume all super-traits are relevant.\n+            let bounds = iter::once(trait_ref.to_poly_trait_ref());\n+            self.elaborate_bounds(bounds, |this, new_trait_ref, item| {\n+                let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+\n+                let (xform_self_ty, xform_ret_ty) =\n+                    this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n+                this.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(new_trait_ref),\n+                }, true);\n+            });\n+        } else {\n+            debug_assert!(self.tcx.is_trait(trait_def_id));\n+            for item in self.impl_or_trait_item(trait_def_id) {\n+                // Check whether `trait_def_id` defines a method with suitable name.\n+                if !self.has_applicable_self(&item) {\n+                    debug!(\"method has inapplicable self\");\n+                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    continue;\n+                }\n \n-            let (xform_self_ty, xform_ret_ty) =\n-                self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n-            self.push_candidate(Candidate {\n-                xform_self_ty, xform_ret_ty, item, import_id,\n-                kind: TraitCandidate(trait_ref),\n-            }, false);\n+                let (xform_self_ty, xform_ret_ty) =\n+                    self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+                self.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(trait_ref),\n+                }, false);\n+            }\n         }\n         Ok(())\n     }\n@@ -930,7 +946,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             .filter(|&name| set.insert(name))\n             .collect();\n \n-        // sort them by the name so we have a stable result\n+        // Sort them by the name so we have a stable result.\n         names.sort_by_cached_key(|n| n.as_str());\n         names\n     }\n@@ -945,6 +961,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return r;\n         }\n \n+        debug!(\"pick: actual search failed, assemble diagnotics\");\n+\n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n         let private_candidate = self.private_candidate.take();\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);"}, {"sha": "5f5c7cfec9578c4b1889b883f013bcca44f0dfa9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -757,9 +757,13 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n-            if let hir::ItemKind::Trait(..) = i.node {\n-                let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n-                self.traits.push(def_id);\n+            match i.node {\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) => {\n+                    let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n+                    self.traits.push(def_id);\n+                }\n+                _ => ()\n             }\n         }\n \n@@ -781,7 +785,8 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n         match def {\n-            Def::Trait(def_id) => {\n+            Def::Trait(def_id) |\n+            Def::TraitAlias(def_id) => {\n                 traits.push(def_id);\n             }\n             Def::Mod(def_id) => {"}, {"sha": "9e412215512c90bc4e978bea8116d88a8637a9ee", "filename": "src/test/run-pass/traits/auxiliary/trait_alias.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -0,0 +1,13 @@\n+#![feature(trait_alias)]\n+\n+pub trait Hello {\n+    fn hello(&self);\n+}\n+\n+pub struct Hi;\n+\n+impl Hello for Hi {\n+    fn hello(&self) {}\n+}\n+\n+pub trait Greet = Hello;"}, {"sha": "975542ab49b591edc531efb3b5047a901eaafeae", "filename": "src/test/run-pass/traits/trait-alias-import-cross-crate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// aux-build:trait_alias.rs\n+\n+#![feature(trait_alias)]\n+\n+extern crate trait_alias;\n+\n+// Import only the alias, not the real trait.\n+use trait_alias::{Greet, Hi};\n+\n+fn main() {\n+    let hi = Hi;\n+    hi.hello(); // From `Hello`, via `Greet` alias.\n+}"}, {"sha": "7d63320b9aad433a225b5b139030e1b5be67ebc4", "filename": "src/test/run-pass/traits/trait-alias-import.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -0,0 +1,38 @@\n+#![feature(trait_alias)]\n+\n+mod inner {\n+    pub trait Foo {\n+        fn foo(&self);\n+    }\n+\n+    pub struct Qux;\n+\n+    impl Foo for Qux {\n+        fn foo(&self) {}\n+    }\n+\n+    pub trait Bar = Foo;\n+}\n+\n+mod two {\n+    pub trait A {\n+        fn foo();\n+    }\n+\n+    impl A for u8 {\n+        fn foo() {}\n+    }\n+}\n+\n+// Import only the alias, not the `Foo` trait.\n+use inner::{Bar, Qux};\n+\n+// Declaring an alias also brings in aliased methods.\n+trait Two = two::A;\n+\n+fn main() {\n+    let q = Qux;\n+    q.foo(); // From Bar.\n+\n+    u8::foo(); // From A.\n+}"}, {"sha": "28409e0c662775a88d86f42b31ff0d573f98b08d", "filename": "src/test/ui/traits/trait-alias-ambiguous.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -0,0 +1,24 @@\n+#![feature(trait_alias)]\n+\n+mod inner {\n+    pub trait A { fn foo(&self); }\n+    pub trait B { fn foo(&self); }\n+\n+    impl A for u8 {\n+        fn foo(&self) {}\n+    }\n+    impl B for u8 {\n+        fn foo(&self) {}\n+    }\n+\n+    pub trait C = A + B;\n+}\n+\n+use inner::C;\n+\n+fn main() {\n+    let t = 1u8;\n+    t.foo(); //~ ERROR E0034\n+\n+    inner::A::foo(&t); // ok\n+}"}, {"sha": "b7443269b882d63509ef4a8063b540fa0144ed23", "filename": "src/test/ui/traits/trait-alias-ambiguous.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr?ref=a2f3f0cdb30f4e98e0ed22c0c51befcc0cfbed47", "patch": "@@ -0,0 +1,20 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/trait-alias-ambiguous.rs:21:7\n+   |\n+LL |     t.foo();\n+   |       ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `inner::A` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:8:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+note: candidate #2 is defined in an impl of the trait `inner::B` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:11:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}]}