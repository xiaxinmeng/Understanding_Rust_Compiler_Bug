{"sha": "6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOWU2ZWEzOWJiYzJjOWU1OGNkYzg1NGM1NWRmYzE0ODdhNzdhZTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-16T06:26:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-16T06:26:36Z"}, "message": "Rollup merge of #63535 - petrochenkov:expndata, r=matthewjasper\n\nContinue refactoring resolve and hygiene\n\nThe general goal is addressing FIXMEs from the previous PRs.\n\nMerging similar data structures (+ prerequisites for such merging), accounting for the fact that all `ExpnId`s have associated data in `HygieneData` now (less `Option`s).\n\nAlso, some renaming.\nThis should be the last renaming session in this area, I think.\n\nr? @matthewjasper", "tree": {"sha": "3f954fcac1528b39e95ca78bc3ebad58a30613e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f954fcac1528b39e95ca78bc3ebad58a30613e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVkycCRBK7hj4Ov3rIwAAdHIIAIw/+eSJ/78NXyh/42H9S2Hn\nS0QYR4zi1sqr7+8L84760j8czT/ZyCL+xo1eeUZcrVPYYa3e/9fkDbJzndG5FnS5\n74btrejN2uH4ynLoHC3IeU59+DAtUOYuswSobWd9aP08GiqCCds4Q6ZQzCYCsrIk\ncPJ/ve8/RCSclvo/TgggSbXtkzUp4HtEZor5bqul015gI2wDkr8pe0iyRWJX8r05\n4vT6YN2CqzsxtLsU6qY+PurftKam5Ldh3AGi+UFkdBtAJlpKDYJDIhq1yZ60o3DW\nvLidtc7OhumS/rou+6AoL/R6+wL8eK4bs8eQzyw1A/bDDQPZk3jKXCypDqmZ/ek=\n=hYLM\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f954fcac1528b39e95ca78bc3ebad58a30613e0\nparent 32c10056525d427292fdb5e7db7497e2bbe9551b\nparent c76277340e3e5e8d6aca9c926c45cac3484eb5f8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565936796 +0200\ncommitter GitHub <noreply@github.com> 1565936796 +0200\n\nRollup merge of #63535 - petrochenkov:expndata, r=matthewjasper\n\nContinue refactoring resolve and hygiene\n\nThe general goal is addressing FIXMEs from the previous PRs.\n\nMerging similar data structures (+ prerequisites for such merging), accounting for the fact that all `ExpnId`s have associated data in `HygieneData` now (less `Option`s).\n\nAlso, some renaming.\nThis should be the last renaming session in this area, I think.\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "html_url": "https://github.com/rust-lang/rust/commit/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c10056525d427292fdb5e7db7497e2bbe9551b", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c10056525d427292fdb5e7db7497e2bbe9551b", "html_url": "https://github.com/rust-lang/rust/commit/32c10056525d427292fdb5e7db7497e2bbe9551b"}, {"sha": "c76277340e3e5e8d6aca9c926c45cac3484eb5f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c76277340e3e5e8d6aca9c926c45cac3484eb5f8", "html_url": "https://github.com/rust-lang/rust/commit/c76277340e3e5e8d6aca9c926c45cac3484eb5f8"}], "stats": {"total": 1364, "additions": 636, "deletions": 728}, "files": [{"sha": "0f6e834ca26df730518044e7c615e0ed91808b86", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -67,7 +67,7 @@ use syntax::errors;\n use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n-use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n@@ -704,10 +704,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(ExpnId::root(), ExpnInfo {\n-            def_site: span,\n+        span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n         })\n     }\n \n@@ -1224,7 +1223,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Path {\n                         res,\n                         segments: hir_vec![hir::PathSegment::from_ident(\n-                            Ident::with_empty_ctxt(kw::SelfUpper)\n+                            Ident::with_dummy_span(kw::SelfUpper)\n                         )],\n                         span: t.span,\n                     }),\n@@ -1558,7 +1557,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_empty_ctxt(kw::UnderscoreLifetime)),\n+                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n                             hir::LifetimeParamKind::Elided,\n                         ),\n                         hir::LifetimeName::Param(param_name) => (\n@@ -2002,7 +2001,7 @@ impl<'a> LoweringContext<'a> {\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n-                                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                                 kind: hir::TypeBindingKind::Equality {\n                                     ty: output\n                                         .as_ref()\n@@ -2394,7 +2393,7 @@ impl<'a> LoweringContext<'a> {\n         let future_params = P(hir::GenericArgs {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n-                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality {\n                     ty: output_ty,\n                 },"}, {"sha": "4ba61e9d4fdc8ad8deb8c6b9557c565fe17e5781", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -552,7 +552,7 @@ impl LoweringContext<'_> {\n \n         // let mut pinned = <expr>;\n         let expr = P(self.lower_expr(expr));\n-        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n+        let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n@@ -593,7 +593,7 @@ impl LoweringContext<'_> {\n         let loop_node_id = self.sess.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n-            let x_ident = Ident::with_empty_ctxt(sym::result);\n+            let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n@@ -1070,9 +1070,9 @@ impl LoweringContext<'_> {\n         );\n         head.span = desugared_span;\n \n-        let iter = Ident::with_empty_ctxt(sym::iter);\n+        let iter = Ident::with_dummy_span(sym::iter);\n \n-        let next_ident = Ident::with_empty_ctxt(sym::__next);\n+        let next_ident = Ident::with_dummy_span(sym::__next);\n         let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n             desugared_span,\n             next_ident,\n@@ -1081,7 +1081,7 @@ impl LoweringContext<'_> {\n \n         // `::std::option::Option::Some(val) => __next = val`\n         let pat_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n             let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n             let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n@@ -1247,7 +1247,7 @@ impl LoweringContext<'_> {\n \n         // `Ok(val) => #[allow(unreachable_code)] val,`\n         let ok_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n             let val_expr = P(self.expr_ident_with_attrs(\n                 span,\n@@ -1263,7 +1263,7 @@ impl LoweringContext<'_> {\n         // `Err(err) => #[allow(unreachable_code)]\n         //              return Try::from_error(From::from(err)),`\n         let err_arm = {\n-            let err_ident = Ident::with_empty_ctxt(sym::err);\n+            let err_ident = Ident::with_dummy_span(sym::err);\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];"}, {"sha": "57fd0be77ecff108c5dd4c56598a77170fe5c786", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -202,7 +202,7 @@ impl ParamName {\n         match *self {\n             ParamName::Plain(ident) => ident,\n             ParamName::Fresh(_) |\n-            ParamName::Error => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n+            ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -237,8 +237,8 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n-            LifetimeName::Underscore => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n-            LifetimeName::Static => Ident::with_empty_ctxt(kw::StaticLifetime),\n+            LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n+            LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }"}, {"sha": "2fd683ed83c54917def6d4ab97fad3f14c34537f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1457,7 +1457,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) {\n-        self.print_ident(ast::Ident::with_empty_ctxt(name))\n+        self.print_ident(ast::Ident::with_dummy_span(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) {"}, {"sha": "e77faea1e4c5855989ae6bf152c21b0af25510a3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -350,7 +350,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         let line_col_len = col | line | len;\n         std_hash::Hash::hash(&line_col_len, hasher);\n \n-        if span.ctxt == SyntaxContext::empty() {\n+        if span.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(hcx, hasher);\n@@ -370,7 +370,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n                 }\n \n                 let mut hasher = StableHasher::new();\n-                expn_id.expn_info().hash_stable(hcx, &mut hasher);\n+                expn_id.expn_data().hash_stable(hcx, &mut hasher);\n                 let sub_hash: Fingerprint = hasher.finish();\n                 let sub_hash = sub_hash.to_smaller_hash();\n                 cache.borrow_mut().insert(expn_id, sub_hash);"}, {"sha": "7003f71c8baa06ae1e02e8f3946b9d4d141d6e80", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -397,9 +397,10 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n     Opaque,\n });\n \n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n-    call_site,\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     kind,\n+    parent -> _,\n+    call_site,\n     def_site,\n     default_transparency,\n     allow_internal_unstable,"}, {"sha": "be73b305e2c50bd56d68f1c8b2cf9a1143e0556c", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -9,7 +9,6 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n-use syntax_pos::ExpnInfo;\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                             .help(\"try using `Ty` instead\")\n                             .emit();\n                         } else {\n-                            if ty.span.ctxt().outer_expn_info().is_some() {\n+                            if ty.span.from_expansion() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n@@ -228,30 +227,20 @@ impl EarlyLintPass for LintPassImpl {\n         if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n-                    match &lint_pass.path.span.ctxt().outer_expn_info() {\n-                        Some(info) if is_lint_pass_expansion(info) => {}\n-                        _ => {\n-                            cx.struct_span_lint(\n-                                LINT_PASS_IMPL_WITHOUT_MACRO,\n-                                lint_pass.path.span,\n-                                \"implementing `LintPass` by hand\",\n-                            )\n-                            .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                            .emit();\n-                        }\n+                    let expn_data = lint_pass.path.span.ctxt().outer_expn_data();\n+                    let call_site = expn_data.call_site;\n+                    if expn_data.kind.descr() != sym::impl_lint_pass &&\n+                       call_site.ctxt().outer_expn_data().kind.descr() != sym::declare_lint_pass {\n+                        cx.struct_span_lint(\n+                            LINT_PASS_IMPL_WITHOUT_MACRO,\n+                            lint_pass.path.span,\n+                            \"implementing `LintPass` by hand\",\n+                        )\n+                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                        .emit();\n                     }\n                 }\n             }\n         }\n     }\n }\n-\n-fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n-    if expn_info.kind.descr() == sym::impl_lint_pass {\n-        true\n-    } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n-        info.kind.descr() == sym::declare_lint_pass\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "2b58627cdea563544c5d24a958ea88dd74a0aa28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -885,21 +885,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let info = match span.ctxt().outer_expn_info() {\n-        Some(info) => info,\n-        // no ExpnInfo means this span doesn't come from a macro\n-        None => return false,\n-    };\n-\n-    match info.kind {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n         ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if info.def_site.is_dummy() {\n+            if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro\n                 return true;\n             }\n-            match sess.source_map().span_to_snippet(info.def_site) {\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n@@ -911,10 +906,8 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    if let Some(info) = span.ctxt().outer_expn_info() {\n-        if let ExpnKind::Macro(MacroKind::Derive, _) = info.kind {\n-            return true;\n-        }\n+    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n+        return true;\n     }\n     false\n }"}, {"sha": "ba92e851141a655cd929964c0a9d8b29096f39b8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -36,7 +36,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -61,9 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            if let Some(ExpnInfo { kind: ExpnKind::Desugaring(_), def_site, .. })\n-                    = span.ctxt().outer_expn_info() {\n-                span = def_site;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n             }\n \n             error_map.entry(span).or_default().push("}, {"sha": "72df45df92314247f82063c386da1010c980301e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1417,7 +1417,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n                     trait_ref,\n-                    Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                    Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 ),\n                 ty: ret_type\n             }"}, {"sha": "8bf01970eb592f13464fd43efc6a3f8c6e788ee1", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -23,16 +23,16 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-const TAG_NO_EXPANSION_INFO: u8 = 0;\n-const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n-const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+const TAG_NO_EXPN_DATA: u8 = 0;\n+const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n+const TAG_EXPN_DATA_INLINE: u8 = 2;\n \n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n@@ -58,7 +58,7 @@ pub struct OnDiskCache<'sess> {\n \n     // These two fields caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -135,7 +135,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n@@ -151,7 +151,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n             prev_diagnostics_index: Default::default(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encoder,\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n-                expn_info_shorthands: Default::default(),\n+                expn_data_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n                 interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n@@ -383,7 +383,7 @@ impl<'sess> OnDiskCache<'sess> {\n             cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n@@ -440,7 +440,7 @@ struct CacheDecoder<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n@@ -586,37 +586,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        let expn_info_tag = u8::decode(self)?;\n+        let expn_data_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `InternalExpnData::parent` or\n+        // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n-        let location = || Span::new(lo, hi, SyntaxContext::empty());\n-        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(ExpnId::root(), expn_info);\n-            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+        let location = || Span::with_root_ctxt(lo, hi);\n+        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n+            let span = location().fresh_expansion(expn_data);\n+            this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n-        Ok(match expn_info_tag {\n-            TAG_NO_EXPANSION_INFO => {\n+        Ok(match expn_data_tag {\n+            TAG_NO_EXPN_DATA => {\n                 location()\n             }\n-            TAG_EXPANSION_INFO_INLINE => {\n-                let expn_info = Decodable::decode(self)?;\n-                recover_from_expn_info(\n-                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+            TAG_EXPN_DATA_INLINE => {\n+                let expn_data = Decodable::decode(self)?;\n+                recover_from_expn_data(\n+                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n-            TAG_EXPANSION_INFO_SHORTHAND => {\n+            TAG_EXPN_DATA_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos.borrow().get(&pos).cloned();\n+                let cached_ctxt = self.synthetic_syntax_contexts.borrow().get(&pos).cloned();\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_info =\n-                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n-                    recover_from_expn_info(self, expn_info, pos)\n+                    let expn_data =\n+                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, pos)\n                 }\n             }\n             _ => {\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n+    expn_data_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n@@ -816,22 +816,18 @@ where\n         col_lo.encode(self)?;\n         len.encode(self)?;\n \n-        if span_data.ctxt == SyntaxContext::empty() {\n-            TAG_NO_EXPANSION_INFO.encode(self)\n+        if span_data.ctxt == SyntaxContext::root() {\n+            TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n-            if let Some(expn_info) = expn_info {\n-                if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n-                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n-                    pos.encode(self)\n-                } else {\n-                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n-                    let pos = AbsoluteBytePos::new(self.position());\n-                    self.expn_info_shorthands.insert(expn_id, pos);\n-                    expn_info.encode(self)\n-                }\n+            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n+                TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n+                pos.encode(self)\n             } else {\n-                TAG_NO_EXPANSION_INFO.encode(self)\n+                TAG_EXPN_DATA_INLINE.encode(self)?;\n+                let pos = AbsoluteBytePos::new(self.position());\n+                self.expn_data_shorthands.insert(expn_id, pos);\n+                expn_data.encode(self)\n             }\n         }\n     }"}, {"sha": "eec098426239c4550301a065bc5e3ad0d41aac7b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1775,10 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match ExpnId::from_u32(cookie).expn_info() {\n-                        Some(ei) => sess.span_err(ei.call_site, &msg),\n-                        None     => sess.err(&msg),\n-                    }\n+                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "32bcdebc1c46787f963ac9bd67d3c38a9b912275", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -8,7 +8,7 @@ use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n+use syntax_pos::{DUMMY_SP, BytePos, Span};\n use syntax::symbol::kw;\n \n use std::iter;\n@@ -120,7 +120,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.ctxt() == NO_EXPANSION ||\n+        if !source_info.span.from_expansion() ||\n            self.cx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)"}, {"sha": "fdd0773b73ae2066dc0232b47cb2a2a529cd9625", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -678,7 +678,7 @@ impl RustcDefaultCalls {\n \n                     let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            path: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n+                            path: ast::Path::from_ident(ast::Ident::with_dummy_span(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "4018a667bf26497ac9e88c4850538dae7558fe03", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -43,8 +43,7 @@ use syntax_pos::{BytePos,\n                  SourceFile,\n                  FileName,\n                  MultiSpan,\n-                 Span,\n-                 NO_EXPANSION};\n+                 Span};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -189,7 +188,7 @@ impl CodeSuggestion {\n             // Find the bounding span.\n             let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n             let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n-            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let bounding_span = Span::with_root_ctxt(lo, hi);\n             let lines = cm.span_to_lines(bounding_span).unwrap();\n             assert!(!lines.lines.is_empty());\n "}, {"sha": "82160080a44d4c09bb6ff4f7959a005c169365b5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -42,7 +42,7 @@ use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{self, AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n-use syntax_pos::{BytePos, Span, SyntaxContext};\n+use syntax_pos::{BytePos, Span};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n@@ -78,7 +78,7 @@ impl EarlyLintPass for WhileTrue {\n         if let ast::ExprKind::While(cond, ..) = &e.node {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n-                    if lit.span.ctxt() == SyntaxContext::empty() {\n+                    if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 if fieldpat.is_shorthand {\n                     continue;\n                 }\n-                if fieldpat.span.ctxt().outer_expn_info().is_some() {\n+                if fieldpat.span.from_expansion() {\n                     // Don't lint if this is a macro expansion: macro authors\n                     // shouldn't have to worry about this kind of style issue\n                     // (Issue #49588)\n@@ -1012,7 +1012,7 @@ impl UnreachablePub {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n             hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n-                if span.ctxt().outer_expn_info().is_some() {\n+                if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);"}, {"sha": "90e467713968bd07fdfc31f47ec2239453deebaa", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -517,9 +517,8 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer_expn_info()\n-                    .map_or(false, |info| info.call_site.ctxt().outer_expn_info().is_some()) {\n-                        return;\n+                if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n+                    return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {"}, {"sha": "b46758abb5f2c31439bfc71e645f0cc44c8106bb", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -35,7 +35,7 @@ use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{Span, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n macro_rules! provide {\n@@ -443,7 +443,7 @@ impl cstore::CStore {\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n-        let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n+        let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.diagnostic());\n "}, {"sha": "0bec31d70765f7c786db98fd8c83795672fc0c11", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use log::debug;\n \n pub struct DecodeContext<'a, 'tcx> {\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let hi = (hi + source_file.translated_source_file.start_pos)\n                  - source_file.original_start_pos;\n \n-        Ok(Span::new(lo, hi, NO_EXPANSION))\n+        Ok(Span::with_root_ctxt(lo, hi))\n     }\n }\n \n@@ -569,15 +569,15 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_empty_ctxt(self.item_name(index)),\n+            Ident::with_dummy_span(self.item_name(index)),\n             variant_did,\n             ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_empty_ctxt(self.item_name(index)),\n+                    ident: Ident::with_dummy_span(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -741,7 +741,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n-                    let ident = Ident::with_empty_ctxt(name);\n+                    let ident = Ident::with_dummy_span(name);\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -783,7 +783,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n+                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });"}, {"sha": "539e4a301e01238ca8225c06e84d858907d9c69d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,9 +1,11 @@\n-//! Reduced graph building.\n+//! After we obtain a fresh AST fragment from a macro, code in this module helps to integrate\n+//! that fragment into the module structures that are already partially built.\n //!\n-//! Here we build the \"reduced graph\": the graph of the module tree without\n-//! any imports resolved.\n+//! Items from the fragment are placed into modules,\n+//! unexpanded macros in the fragment are visited and registered.\n+//! Imports are also considered items and placed into modules here, but not resolved yet.\n \n-use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n+use crate::macros::{LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n@@ -30,6 +32,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::expand::AstFragment;\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n@@ -67,7 +70,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n     }\n }\n \n-pub(crate) struct IsMacroExport;\n+struct IsMacroExport;\n \n impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n@@ -84,7 +87,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    crate fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n@@ -93,7 +96,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         if def_id.krate == LOCAL_CRATE {\n             return self.module_map[&def_id]\n         }\n@@ -119,7 +122,7 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+    crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n@@ -141,7 +144,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }\n@@ -158,21 +161,29 @@ impl<'a> Resolver<'a> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n+    crate fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n         let def_id = module.def_id().unwrap();\n         for child in self.cstore.item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n-                .build_reduced_graph_for_external_crate_res(module, child);\n+            BuildReducedGraphVisitor { parent_scope: ParentScope::module(module), r: self }\n+                .build_reduced_graph_for_external_crate_res(child);\n         }\n         module.populated.set(true)\n     }\n+\n+    crate fn build_reduced_graph(\n+        &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n+    ) -> LegacyScope<'a> {\n+        let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n+        fragment.visit_with(&mut visitor);\n+        visitor.parent_scope.legacy\n+    }\n }\n \n-pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub r: &'b mut Resolver<'a>,\n-    pub parent_scope: ParentScope<'a>,\n+struct BuildReducedGraphVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+    parent_scope: ParentScope<'a>,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n@@ -300,10 +311,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         root_id: NodeId,\n         vis: ty::Visibility,\n     ) {\n-        let parent_scope = &self.parent_scope;\n-        let current_module = parent_scope.module;\n+        let current_module = self.parent_scope.module;\n         let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -601,7 +611,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope: self.parent_scope.clone(),\n+                    parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -706,7 +716,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n-                    self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n+                    self.build_reduced_graph_for_variant(variant, module, vis);\n                 }\n             }\n \n@@ -797,8 +807,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n-                                       vis: ty::Visibility,\n-                                       expn_id: ExpnId) {\n+                                       vis: ty::Visibility) {\n+        let expn_id = self.parent_scope.expansion;\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n@@ -861,11 +871,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(\n-        &mut self,\n-        parent: Module<'a>,\n-        child: Export<ast::NodeId>,\n-    ) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+        let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n         // but metadata cannot encode gensyms currently, so we create it here.\n@@ -997,7 +1004,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: this.parent_scope.clone(),\n+            parent_scope: this.parent_scope,\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -1066,20 +1073,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n-            module: self.parent_scope.module,\n-            parent_legacy_scope: self.parent_scope.legacy,\n-            output_legacy_scope: Cell::new(None),\n-        });\n-        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n-        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+        let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n+        assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        invocation_data\n+        LegacyScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1180,7 +1182,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = self.visit_invoc(item.id);\n                 return\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n@@ -1199,7 +1201,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1267,9 +1269,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.parent_scope.module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, self.parent_scope.clone()\n-            ));\n+            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "861b0fd44ac41f1ae53981b523260227405aa562", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -376,9 +376,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n-                        for derive in &parent_scope.derives {\n+                        for derive in parent_scope.derives {\n                             let parent_scope =\n-                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                                &ParentScope { derives: &[], ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n                                 derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {\n@@ -455,7 +455,7 @@ impl<'a> Resolver<'a> {\n                         let mut tmp_suggestions = Vec::new();\n                         add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n-                            use_prelude || this.is_builtin_macro(s.res.opt_def_id())\n+                            use_prelude || this.is_builtin_macro(s.res)\n                         }));\n                     }\n                 }\n@@ -595,7 +595,7 @@ impl<'a> Resolver<'a> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+            lookup_ident, namespace, self.graph_root, Ident::with_dummy_span(kw::Crate), &filter_fn\n         );\n \n         if lookup_ident.span.rust_2018() {"}, {"sha": "ffdfd85002bca66794f0557c3013b0810a26c74c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,3 +1,10 @@\n+//! \"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\n+//! It runs when the crate is fully expanded and its module structure is fully built.\n+//! So it just walks through the crate and resolves all the expressions, types, etc.\n+//!\n+//! If you wonder why there's no `early.rs`, that's because it's split into three files -\n+//! `build_reduced_graph.rs`, `macros.rs` and `resolve_imports.rs`.\n+\n use GenericParameters::*;\n use RibKind::*;\n \n@@ -352,7 +359,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n+                let self_ty = Ident::with_dummy_span(kw::SelfUpper);\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -442,7 +449,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     found_default |= default.is_some();\n                     if found_default {\n-                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n+                        Some((Ident::with_dummy_span(param.ident.name), Res::Err))\n                     } else {\n                         None\n                     }\n@@ -459,7 +466,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     false\n                 }\n             })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n+            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n \n         for param in &generics.params {\n             match param.kind {\n@@ -476,7 +483,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     }\n \n                     // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                    default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n                     self.ribs[TypeNS].push(const_ty_param_ban_rib);\n@@ -501,8 +508,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n-        let parent_scope = resolver.dummy_parent_scope();\n         let graph_root = resolver.graph_root;\n+        let parent_scope = ParentScope::module(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n@@ -574,7 +581,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n-            self.r.finalize_current_module_macro_resolutions(module);\n             let ret = f(self);\n \n             self.parent_scope.module = orig_module;\n@@ -965,7 +971,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -976,7 +982,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     {\n         let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -1227,7 +1233,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.parent_scope.module = anonymous_module;\n-            self.r.finalize_current_module_macro_resolutions(anonymous_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -1476,7 +1481,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n+                let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n                 std_path.extend(path);\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n                     let cl = CrateLint::No;\n@@ -1507,7 +1512,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_empty_ctxt(kw::SelfUpper),\n+            Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n             None,\n             span,\n@@ -1984,7 +1989,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n-        self.finalize_current_module_macro_resolutions(self.graph_root);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.unused_labels.iter() {"}, {"sha": "9b5eb51eb582dfb6b3df8adf3f2d00931420a159", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 74, "deletions": 46, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,3 +1,12 @@\n+//! This crate is responsible for the part of name resolution that doesn't require type checker.\n+//!\n+//! Module structure of the crate is built here.\n+//! Paths in macros, imports, expressions, types, patterns are resolved here.\n+//! Label names are resolved here as well.\n+//!\n+//! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n+//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n@@ -54,7 +63,7 @@ use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use late::{PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{LegacyBinding, LegacyScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -122,12 +131,25 @@ enum ScopeSet {\n /// Serves as a starting point for the scope visitor.\n /// This struct is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n-    derives: Vec<ast::Path>,\n+    derives: &'a [ast::Path],\n+}\n+\n+impl<'a> ParentScope<'a> {\n+    /// Creates a parent scope with the passed argument used as the module scope component,\n+    /// and other scope components set to default empty values.\n+    pub fn module(module: Module<'a>) -> ParentScope<'a> {\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            legacy: LegacyScope::Empty,\n+            derives: &[],\n+        }\n+    }\n }\n \n #[derive(Eq)]\n@@ -274,7 +296,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -284,7 +306,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());\n@@ -418,11 +440,6 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n-                                                   Option<&'a NameBinding<'a>>)>>,\n-    multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n-                                                  Option<Res>)>>,\n-    builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n@@ -459,9 +476,6 @@ impl<'a> ModuleData<'a> {\n             kind,\n             normal_ancestor_id,\n             resolutions: Default::default(),\n-            single_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            multi_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            builtin_attrs: RefCell::new(Vec::new()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -807,7 +821,7 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n-    graph_root: Module<'a>,\n+    pub graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n     pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n@@ -896,15 +910,24 @@ pub struct Resolver<'a> {\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n+    /// Traces collected during macro resolution and validated when it's complete.\n+    single_segment_macro_resolutions: Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                           Option<&'a NameBinding<'a>>)>,\n+    multi_segment_macro_resolutions: Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n+                                          Option<Res>)>,\n+    builtin_attrs: Vec<(Ident, ParentScope<'a>)>,\n     /// Some built-in derives mark items they are applied to so they are treated specially later.\n     /// Derive macros cannot modify the item themselves and have to store the markers in the global\n     /// context, so they attach the markers to derive container IDs using this resolver table.\n     /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n     /// by marking the produced impls rather than the original items.\n     special_derives: FxHashMap<ExpnId, SpecialDerives>,\n-\n-    /// Maps the `ExpnId` of an expansion to its containing module or block.\n-    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n+    /// Parent scopes in which the macros were invoked.\n+    /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n+    invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n+    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// include all the `macro_rules` items and other invocations generated by them.\n+    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -927,8 +950,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    invocation_data: arena::TypedArena<InvocationData<'a>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    ast_paths: arena::TypedArena<ast::Path>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -952,13 +975,12 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n-                             -> &'a InvocationData<'a> {\n-        self.invocation_data.alloc(expansion_data)\n-    }\n     fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n         self.legacy_bindings.alloc(binding)\n     }\n+    fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n+        self.ast_paths.alloc_from_iter(paths.iter().cloned())\n+    }\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n@@ -985,19 +1007,19 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         } else {\n             kw::Crate\n         };\n-        let segments = iter::once(Ident::with_empty_ctxt(root))\n+        let segments = iter::once(Ident::with_dummy_span(root))\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::with_empty_ctxt)\n+                    .map(Ident::with_dummy_span)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n         let path = ast::Path {\n             span,\n             segments,\n         };\n \n-        let parent_scope = &self.dummy_parent_scope();\n+        let parent_scope = &ParentScope::module(self.graph_root);\n         let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n             Ok(res) => res,\n             Err((span, error)) => {\n@@ -1060,18 +1082,17 @@ impl<'a> Resolver<'a> {\n                                        .collect();\n \n         if !attr::contains_name(&krate.attrs, sym::no_core) {\n-            extern_prelude.insert(Ident::with_empty_ctxt(sym::core), Default::default());\n+            extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n             if !attr::contains_name(&krate.attrs, sym::no_std) {\n-                extern_prelude.insert(Ident::with_empty_ctxt(sym::std), Default::default());\n+                extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n                 if session.rust_2018() {\n-                    extern_prelude.insert(Ident::with_empty_ctxt(sym::meta), Default::default());\n+                    extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n                 }\n             }\n         }\n \n-        let mut invocations = FxHashMap::default();\n-        invocations.insert(ExpnId::root(),\n-                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n+        let mut invocation_parent_scopes = FxHashMap::default();\n+        invocation_parent_scopes.insert(ExpnId::root(), ParentScope::module(graph_root));\n \n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(ExpnId::root(), root_def_id);\n@@ -1143,14 +1164,18 @@ impl<'a> Resolver<'a> {\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n-            invocations,\n+            invocation_parent_scopes,\n+            output_legacy_scopes: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n+            single_segment_macro_resolutions: Default::default(),\n+            multi_segment_macro_resolutions: Default::default(),\n+            builtin_attrs: Default::default(),\n             special_derives: Default::default(),\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n@@ -1182,9 +1207,8 @@ impl<'a> Resolver<'a> {\n         f(self, MacroNS);\n     }\n \n-    fn is_builtin_macro(&mut self, def_id: Option<DefId>) -> bool {\n-        def_id.and_then(|def_id| self.get_macro_by_def_id(def_id))\n-              .map_or(false, |ext| ext.is_builtin)\n+    fn is_builtin_macro(&mut self, res: Res) -> bool {\n+        self.get_macro(res).map_or(false, |ext| ext.is_builtin)\n     }\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n@@ -1203,6 +1227,7 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { r: self }.finalize_imports();\n+        self.finalize_macro_resolutions();\n \n         self.late_resolve_crate(krate);\n \n@@ -1319,13 +1344,15 @@ impl<'a> Resolver<'a> {\n             ScopeSet::AbsolutePath(ns) => (ns, true),\n             ScopeSet::Macro(_) => (MacroNS, false),\n         };\n+        // Jump out of trait or enum modules, they do not act as scopes.\n+        let module = parent_scope.module.nearest_item_scope();\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n+            TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers,\n         };\n         let mut ident = ident.modern();\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+        let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n             let visit = match scope {\n@@ -1355,10 +1382,11 @@ impl<'a> Resolver<'a> {\n                     LegacyScope::Binding(binding) => Scope::MacroRules(\n                         binding.parent_legacy_scope\n                     ),\n-                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_legacy_scopes.get(&invoc_id).cloned()\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy)\n                     ),\n-                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n+                    LegacyScope::Empty => Scope::Module(module),\n                 }\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1430,7 +1458,7 @@ impl<'a> Resolver<'a> {\n         }\n         let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::empty());\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n             let modern_span = ident.span.modern();\n@@ -1501,7 +1529,7 @@ impl<'a> Resolver<'a> {\n                 self.hygienic_lexical_parent(module, &mut ident.span)\n             };\n             module = unwrap_or!(opt_module, break);\n-            let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+            let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n@@ -1637,7 +1665,7 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(m) => {\n                 if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n@@ -2624,7 +2652,7 @@ impl<'a> Resolver<'a> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n+                segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2645,7 +2673,7 @@ impl<'a> Resolver<'a> {\n             let def_id = self.definitions.local_def_id(module_id);\n             self.module_map.get(&def_id).copied().unwrap_or(self.graph_root)\n         });\n-        let parent_scope = &ParentScope { module, ..self.dummy_parent_scope() };\n+        let parent_scope = &ParentScope::module(module);\n         let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))\n     }\n@@ -2713,7 +2741,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n         if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(Ident::with_empty_ctxt(name));\n+                names.push(Ident::with_dummy_span(name));\n                 collect_mod(names, parent);\n             }\n         } else {"}, {"sha": "079145e816cd533b88239fcbdfacfa6f9d95c0f1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 51, "deletions": 97, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,9 +1,11 @@\n+//! A bunch of methods and structures more or less related to resolving macros and\n+//! interface provided by `Resolver` to macro expander.\n+\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n-use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::DefCollector;\n@@ -15,43 +17,18 @@ use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::cell::Cell;\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n type Res = def::Res<ast::NodeId>;\n \n-// FIXME: Merge this with `ParentScope`.\n-#[derive(Clone, Debug)]\n-pub struct InvocationData<'a> {\n-    /// The module in which the macro was invoked.\n-    crate module: Module<'a>,\n-    /// The legacy scope in which the macro was invoked.\n-    /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n-    /// The legacy scope *produced* by expanding this macro invocation,\n-    /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// `None` if the macro is not expanded yet.\n-    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n-}\n-\n-impl<'a> InvocationData<'a> {\n-    pub fn root(graph_root: Module<'a>) -> Self {\n-        InvocationData {\n-            module: graph_root,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }\n-    }\n-}\n-\n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n #[derive(Debug)]\n@@ -75,7 +52,7 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n-    Invocation(&'a InvocationData<'a>),\n+    Invocation(ExpnId),\n }\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n@@ -120,17 +97,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n-        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::default(\n+        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        ));\n-        let expn_id = span.ctxt().outer_expn();\n+        )));\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n+        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n         self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        self.invocations.insert(expn_id, self.arenas.alloc_invocation_data(InvocationData {\n-            module,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }));\n         expn_id\n     }\n \n@@ -144,29 +116,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n-\n-        let invocation = self.invocations[&expn_id];\n-        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(expn_id);\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+    ) {\n+        // Fill in some data for derives if the fragment is from a derive container.\n+        // We are inside the `expansion` now, but other parent scope components are still the same.\n+        let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n+        let parent_def = self.definitions.invocation_parent(expansion);\n+        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n-        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n-        let mut visitor = BuildReducedGraphVisitor {\n-            r: self,\n-            parent_scope: ParentScope {\n-                module: invocation.module,\n-                expansion: expn_id,\n-                legacy: invocation.parent_legacy_scope,\n-                derives: Vec::new(),\n-            },\n-        };\n-        fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n+        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n+        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n+\n+        // Integrate the new AST fragment into all the definition and module structures.\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expansion));\n+        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n+        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -182,24 +149,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n+        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n+        let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n+                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.path, MacroKind::Bang, Vec::new(), false),\n+                (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), false),\n+                (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of derives in the container until we know whether one of them\n                 // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n                 // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      parent_scope, true, force) {\n+                                                      &parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -213,11 +180,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        // Derives are not included when `invocations` are collected, so we have to add them here.\n+        let parent_scope = &ParentScope { derives, ..parent_scope };\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n+        invoc.expansion_data.id.set_expn_data(\n+            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n+        );\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n@@ -251,20 +221,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n-        self.invoc_parent_scope(ExpnId::root(), Vec::new())\n-    }\n-\n-    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n-        let invoc = self.invocations[&invoc_id];\n-        ParentScope {\n-            module: invoc.module.nearest_item_scope(),\n-            expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope,\n-            derives,\n-        }\n-    }\n-\n     /// Resolve macro path with error reporting and recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n@@ -346,8 +302,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer_expn_info()\n-               .map_or(false, |info| info.local_inner_macros) {\n+           path[0].ident.span.ctxt().outer_expn_data().local_inner_macros {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }\n@@ -367,8 +322,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n-                    .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n+                self.multi_segment_macro_resolutions\n+                    .push((path, path_span, kind, *parent_scope, res.ok()));\n             }\n \n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n@@ -384,8 +339,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n-                    .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+                self.single_segment_macro_resolutions\n+                    .push((path[0].ident, kind, *parent_scope, binding.ok()));\n             }\n \n             let res = binding.map(|binding| binding.res());\n@@ -454,8 +409,8 @@ impl<'a> Resolver<'a> {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                    for derive in parent_scope.derives {\n+                        let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n@@ -475,8 +430,9 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n-                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n-                        Err(Determinacy::Undetermined),\n+                    LegacyScope::Invocation(invoc_id)\n+                        if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                            Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 Scope::CrateRoot => {\n@@ -500,7 +456,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+                    let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n@@ -575,7 +531,7 @@ impl<'a> Resolver<'a> {\n                             false,\n                             path_span,\n                         ) {\n-                            if use_prelude || this.is_builtin_macro(binding.res().opt_def_id()) {\n+                            if use_prelude || this.is_builtin_macro(binding.res()) {\n                                 result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n@@ -694,7 +650,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn finalize_current_module_macro_resolutions(&mut self, module: Module<'a>) {\n+    crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n                                  initial_res: Option<Res>, res: Res| {\n             if let Some(initial_res) = initial_res {\n@@ -730,8 +686,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.multi_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.multi_segment_macro_resolutions);\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n@@ -758,8 +713,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.single_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.single_segment_macro_resolutions);\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n             match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n@@ -784,7 +738,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let builtin_attrs = mem::take(&mut *module.builtin_attrs.borrow_mut());\n+        let builtin_attrs = mem::take(&mut self.builtin_attrs);\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n                 ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span"}, {"sha": "693893e9ef13b00c1d3cbbea42a5a46bb1958a59", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,3 +1,5 @@\n+//! A bunch of methods and structures more or less related to resolving imports.\n+\n use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n@@ -394,7 +396,7 @@ impl<'a> Resolver<'a> {\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n                 Some(None) => {}\n@@ -848,7 +850,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         directive.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n-                // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                // Consistency checks, analogous to `finalize_macro_resolutions`.\n                 if let Some(initial_module) = directive.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n                         span_bug!(directive.span, \"inconsistent resolution for an import\");\n@@ -973,7 +975,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             match binding {\n                 Ok(binding) => {\n-                    // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                    // Consistency checks, analogous to `finalize_macro_resolutions`.\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {"}, {"sha": "0bbbbb8249c207c7b284e7d53dc4d4b41a340a40", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1156,7 +1156,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt() != NO_EXPANSION || span.is_dummy()\n+    span.from_expansion() || span.is_dummy()\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "c72966edc5ae8847fb7199143f47c9b9658cf46f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -347,9 +347,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n         );\n \n-        // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n-        // extract the text and make a good suggestion, so don't bother.\n-        let is_macro = sp.ctxt().outer_expn_info().is_some();\n+        // If the span is from a macro, then it's hard to extract the text\n+        // and make a good suggestion, so don't bother.\n+        let is_macro = sp.from_expansion();\n \n         match (&expr.node, &expected.sty, &checked_ty.sty) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {"}, {"sha": "53024d97c3b134eb04581257bb55cddab50950b9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -985,7 +985,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones.\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -995,7 +995,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::ExternCrate(_) => {}\n                 // ...but do place them before the first other item.\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // Don't insert between attributes and an item.\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());"}, {"sha": "fc1ee649e287f7d64d3deba68e29ce998843f55e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -2943,7 +2943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n             (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n-        (tr, ast::Ident::with_empty_ctxt(name))\n+        (tr, ast::Ident::with_dummy_span(name))\n     }\n \n     fn try_overloaded_place_op(&self,"}, {"sha": "fede9e930101215768d6139c8ead06e35bd875a0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -930,7 +930,7 @@ impl Attributes {\n             if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(\n-                        Ident::with_empty_ctxt(sym::target_feature), feat, DUMMY_SP\n+                        Ident::with_dummy_span(sym::target_feature), feat, DUMMY_SP\n                     );\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;"}, {"sha": "c73c46472d804aeeb0fbf1c2e03dc343ab4ca8fa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n use rustc::ty;\n+use rustc_resolve::ParentScope;\n use syntax;\n use syntax::ast::{self, Ident};\n use syntax::ext::base::SyntaxExtensionKind;\n@@ -431,7 +432,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &resolver.dummy_parent_scope(), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));"}, {"sha": "bcf03b5237a8d1a33c73b0ee66b5ea2caa702d6e", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -327,7 +327,7 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Ident::with_empty_ctxt(sym::doc),\n+                Ident::with_dummy_span(sym::doc),\n                 Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())),\n                 DUMMY_SP,\n             );\n@@ -412,7 +412,7 @@ pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id: mk_attr_id(),\n         style,\n-        path: Path::from_ident(Ident::with_empty_ctxt(sym::doc).with_span_pos(span)),\n+        path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,"}, {"sha": "9618b5acfb0f18d8b72d8e07b385a265398507c9", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -172,7 +172,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    let static_ = ecx.lifetime(span, Ident::with_empty_ctxt(kw::StaticLifetime));\n+    let static_ = ecx.lifetime(span, Ident::with_dummy_span(kw::StaticLifetime));\n     let ty_str = ecx.ty_rptr(\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),"}, {"sha": "fb1bf4d7160e7e2ed7e576fa808a3d8699ee1e69", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -15,7 +15,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -640,10 +640,11 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_info(&self, call_site: Span, descr: Symbol) -> ExpnInfo {\n-        ExpnInfo {\n-            call_site,\n+    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+        ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n+            parent,\n+            call_site,\n             def_site: self.span,\n             default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n@@ -707,7 +708,7 @@ pub struct ExpansionData {\n \n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n-/// -> expn_info` of their expansion context stored into their span.\n+/// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n@@ -756,13 +757,10 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.id.expn_info() {\n-            Some(expn_info) => expn_info.call_site,\n-            None => DUMMY_SP,\n-        }\n+        self.current_expansion.id.expn_data().call_site\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n+        SyntaxContext::root().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n@@ -772,17 +770,13 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if ctxt.outer_expn_info().map_or(None, |info| {\n-                if info.kind.descr() == sym::include {\n-                    // Stop going up the backtrace once include! is encountered\n-                    return None;\n-                }\n-                ctxt = info.call_site.ctxt();\n-                last_macro = Some(info.call_site);\n-                Some(())\n-            }).is_none() {\n-                break\n+            let expn_data = ctxt.outer_expn_data();\n+            // Stop going up the backtrace once include! is encountered\n+            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n+                break;\n             }\n+            ctxt = expn_data.call_site.ctxt();\n+            last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n     }\n@@ -872,7 +866,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n-            .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n+            .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {"}, {"sha": "e2ac4d573a1e0adde3c0892dd2d48557948727e9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -340,7 +340,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     pub fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, Ident::with_empty_ctxt(kw::SelfLower))\n+        self.expr_ident(span, Ident::with_dummy_span(kw::SelfLower))\n     }\n \n     pub fn expr_binary(&self, sp: Span, op: ast::BinOpKind,"}, {"sha": "e7deadbc9a043d0d9c5ee652efe1b8a035872f2e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::collect_derives;\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n@@ -353,7 +353,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n+                    let expn_id = ExpnId::fresh(None);\n                     derives.push(expn_id);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n@@ -475,11 +475,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.id.expn_info().unwrap();\n+            let expn_data = self.cx.current_expansion.id.expn_data();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(info.call_site,\n+            let mut err = self.cx.struct_span_err(expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.kind.descr()));\n+                         expn_data.kind.descr()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -759,7 +759,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n-            let def_site_span = self.token.span.with_ctxt(SyntaxContext::empty());\n+            let def_site_span = self.token.span.with_ctxt(SyntaxContext::root());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!(\n@@ -796,17 +796,20 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        // Expansion info for all the collected invocations is set upon their resolution,\n+        // Expansion data for all the collected invocations is set upon their resolution,\n         // with exception of the derive container case which is not resolved and can get\n-        // its expansion info immediately.\n-        let expn_info = match &kind {\n-            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo::default(\n-                ExpnKind::Macro(MacroKind::Attr, sym::derive),\n-                item.span(), self.cx.parse_sess.edition,\n-            )),\n+        // its expansion data immediately.\n+        let expn_data = match &kind {\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnData {\n+                parent: self.cx.current_expansion.id,\n+                ..ExpnData::default(\n+                    ExpnKind::Macro(MacroKind::Attr, sym::derive),\n+                    item.span(), self.cx.parse_sess.edition,\n+                )\n+            }),\n             _ => None,\n         };\n-        let expn_id = ExpnId::fresh(self.cx.current_expansion.id, expn_info);\n+        let expn_id = ExpnId::fresh(expn_data);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n@@ -1249,21 +1252,21 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                             let include_info = vec![\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::file),\n+                                        Ident::with_dummy_span(sym::file),\n                                         file,\n                                         DUMMY_SP,\n                                     ),\n                                 ),\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::contents),\n+                                        Ident::with_dummy_span(sym::contents),\n                                         src_interned,\n                                         DUMMY_SP,\n                                     ),\n                                 ),\n                             ];\n \n-                            let include_ident = Ident::with_empty_ctxt(sym::include);\n+                            let include_ident = Ident::with_dummy_span(sym::include);\n                             let item = attr::mk_list_item(include_ident, include_info);\n                             items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n@@ -1325,7 +1328,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(Ident::with_empty_ctxt(sym::doc), items);\n+            let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n                 span: at.span,\n                 id: at.id,"}, {"sha": "1619fa6994198efb139dcd6d3c9981b3ce7be439", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -362,10 +362,10 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_data().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n-                SyntaxContext::empty()\n+                SyntaxContext::root()\n                     .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };\n@@ -677,7 +677,7 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n-        span.ctxt().outer_expn_info().map(|i| i.call_site)\n+        span.parent()\n     }\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()"}, {"sha": "17629d392cd3d25acc18079c88ee8ac19045ee8c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -4,7 +4,7 @@ use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n use errors::{FatalError, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n@@ -84,7 +84,7 @@ impl<'a> StringReader<'a> {\n \n \n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n+        self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }\n \n     /// Returns the next token, including trivia like whitespace or comments."}, {"sha": "94570140996f1480400dff15dec2172ea894a18f", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,41 +1,17 @@\n use super::*;\n \n-use crate::ast::CrateConfig;\n use crate::symbol::Symbol;\n use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::feature_gate::UnstableFeatures;\n use crate::parse::token;\n-use crate::diagnostics::plugin::ErrorMap;\n use crate::with_default_globals;\n use std::io;\n use std::path::PathBuf;\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_data_structures::sync::{Lock, Once};\n+use errors::{Handler, emitter::EmitterWriter};\n+use syntax_pos::{BytePos, Span};\n \n fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n-    let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n-                                                        Some(sm.clone()),\n-                                                        false,\n-                                                        false,\n-                                                        false);\n-    ParseSess {\n-        span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),\n-        unstable_features: UnstableFeatures::from_environment(),\n-        config: CrateConfig::default(),\n-        included_mod_stack: Lock::new(Vec::new()),\n-        source_map: sm,\n-        missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-        raw_identifier_spans: Lock::new(Vec::new()),\n-        registered_diagnostics: Lock::new(ErrorMap::new()),\n-        buffered_lints: Lock::new(vec![]),\n-        edition: Edition::from_session(),\n-        ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-        param_attr_spans: Lock::new(Vec::new()),\n-        let_chains_spans: Lock::new(Vec::new()),\n-        async_closure_spans: Lock::new(Vec::new()),\n-        injected_crate_name: Once::new(),\n-    }\n+    let emitter = EmitterWriter::new(Box::new(io::sink()), Some(sm.clone()), false, false, false);\n+    ParseSess::with_span_handler(Handler::with_emitter(true, None, Box::new(emitter)), sm)\n }\n \n // open a string reader for the given string\n@@ -61,7 +37,7 @@ fn t1() {\n         let tok1 = string_reader.next_token();\n         let tok2 = Token::new(\n             mk_ident(\"fn\"),\n-            Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(21), BytePos(23)),\n         );\n         assert_eq!(tok1.kind, tok2.kind);\n         assert_eq!(tok1.span, tok2.span);\n@@ -71,7 +47,7 @@ fn t1() {\n         assert_eq!(string_reader.pos.clone(), BytePos(28));\n         let tok4 = Token::new(\n             mk_ident(\"main\"),\n-            Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(24), BytePos(28)),\n         );\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);"}, {"sha": "525b4215affb180c710009c4d2c8ac1383628c90", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -3,7 +3,7 @@\n \n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION, symbol::kw};\n+use syntax_pos::{BytePos, Pos, Span, symbol::kw};\n use crate::parse::token;\n \n #[rustfmt::skip] // for line breaks\n@@ -343,7 +343,7 @@ crate fn check_for_substitution<'a>(\n         None => return None,\n     };\n \n-    let span = Span::new(pos, pos + Pos::from_usize(ch.len_utf8()), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n \n     let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n         Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n@@ -362,10 +362,9 @@ crate fn check_for_substitution<'a>(\n             ascii_char, ascii_name\n         );\n         err.span_suggestion(\n-            Span::new(\n+            Span::with_root_ctxt(\n                 pos,\n                 pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n-                NO_EXPANSION,\n             ),\n             &msg,\n             format!(\"\\\"{}\\\"\", s),"}, {"sha": "26f78b9c5c78441b9089b2942fe1e8a34196120e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -16,6 +16,7 @@ use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic,\n use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n+use syntax_pos::hygiene::ExpnId;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n@@ -86,7 +87,7 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n-            edition: Edition::from_session(),\n+            edition: ExpnId::root().expn_data().edition,\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),"}, {"sha": "89725d8b3395c8ab5dde64f80a705a0bac695c6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -13,7 +13,6 @@ mod generics;\n use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n use crate::ast::{FnDecl, Ident, IsAsync, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n-use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n use crate::parse::{SeqSep, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n@@ -1101,7 +1100,7 @@ impl<'a> Parser<'a> {\n \n     crate fn process_potential_macro_variable(&mut self) {\n         self.token = match self.token.kind {\n-            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n+            token::Dollar if self.token.span.from_expansion() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token.kind {"}, {"sha": "3f6f87b1c44b612cd41ecd84d3af728e1b5050ab", "filename": "src/libsyntax/parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -60,7 +60,7 @@ impl<'a> Parser<'a> {\n                 // Record that we fetched the mod from an external file\n                 if warn {\n                     let attr = attr::mk_attr_outer(\n-                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n+                        attr::mk_word_item(Ident::with_dummy_span(sym::warn_directory_ownership)));\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }"}, {"sha": "6a789ef99d672c3d21655325382a56402b1283b8", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -12,7 +12,7 @@ use crate::symbol::{kw, sym};\n use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n use crate::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use crate::with_default_globals;\n-use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos, Pos};\n \n use std::path::PathBuf;\n \n@@ -27,7 +27,7 @@ fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n \n // produce a syntax_pos::span\n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n /// Parse a string, return an expr"}, {"sha": "8a7009828bc44e15e765910e3e7fdc5c733de2c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -123,13 +123,13 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let pi_nested = attr::mk_nested_word_item(ast::Ident::with_empty_ctxt(sym::prelude_import));\n-        let list = attr::mk_list_item(ast::Ident::with_empty_ctxt(sym::feature), vec![pi_nested]);\n+        let pi_nested = attr::mk_nested_word_item(ast::Ident::with_dummy_span(sym::prelude_import));\n+        let list = attr::mk_list_item(ast::Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::no_std));\n+        let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n         let fake_attr = attr::mk_attr_inner(no_std_meta);\n         s.print_attribute(&fake_attr);\n     }"}, {"sha": "940687cb5d4e447b6f7d3e4ce75092b02424f2e2", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -8,7 +8,7 @@\n //! information, source code snippets, etc.\n \n pub use syntax_pos::*;\n-pub use syntax_pos::hygiene::{ExpnKind, ExpnInfo};\n+pub use syntax_pos::hygiene::{ExpnKind, ExpnData};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -29,14 +29,15 @@ mod tests;\n \n /// Returns the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n-/// following the `expn_info` chain.\n+/// following the `expn_data` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    let call_site2 = enclosing_sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    match (call_site1, call_site2) {\n-        (None, _) => sp,\n-        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n-        (Some(call_site1), _) => original_sp(call_site1, enclosing_sp),\n+    let expn_data1 = sp.ctxt().outer_expn_data();\n+    let expn_data2 = enclosing_sp.ctxt().outer_expn_data();\n+    if expn_data1.is_root() ||\n+       !expn_data2.is_root() && expn_data1.call_site == expn_data2.call_site {\n+        sp\n+    } else {\n+        original_sp(expn_data1.call_site, enclosing_sp)\n     }\n }\n "}, {"sha": "c7b8332c53ef721eec7decfd282a2391e9d5be64", "filename": "src/libsyntax/source_map/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map%2Ftests.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -91,7 +91,7 @@ fn t6() {\n fn t7() {\n     // Test span_to_lines for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let file_lines = sm.span_to_lines(span).unwrap();\n \n     assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n@@ -107,7 +107,7 @@ fn span_from_selection(input: &str, selection: &str) -> Span {\n     assert_eq!(input.len(), selection.len());\n     let left_index = selection.find('~').unwrap() as u32;\n     let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-    Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(left_index), BytePos(right_index + 1))\n }\n \n /// Tests span_to_snippet and span_to_lines for a span converting 3\n@@ -137,7 +137,7 @@ fn span_to_snippet_and_lines_spanning_multiple_lines() {\n fn t8() {\n     // Test span_to_snippet for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let snippet = sm.span_to_snippet(span);\n \n     assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -147,7 +147,7 @@ fn t8() {\n fn t9() {\n     // Test span_to_str for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let sstr =  sm.span_to_string(span);\n \n     assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -198,10 +198,9 @@ impl SourceMapExtension for SourceMap {\n             let lo = hi + offset;\n             hi = lo + substring.len();\n             if i == n {\n-                let span = Span::new(\n+                let span = Span::with_root_ctxt(\n                     BytePos(lo as u32 + file.start_pos.0),\n                     BytePos(hi as u32 + file.start_pos.0),\n-                    NO_EXPANSION,\n                 );\n                 assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                         substring);"}, {"sha": "4c0e1e3704dffa9df5b758fe68edd9440a5c527f", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -9,7 +9,7 @@ use crate::with_default_globals;\n use errors::emitter::EmitterWriter;\n use errors::Handler;\n use rustc_data_structures::sync::Lrc;\n-use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n+use syntax_pos::{BytePos, Span, MultiSpan};\n \n use std::io;\n use std::io::prelude::*;\n@@ -169,7 +169,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     let start = make_pos(file_text, start);\n     let end = make_pos(file_text, end) + end.string.len(); // just after matching thing ends\n     assert!(start <= end);\n-    Span::new(BytePos(start as u32), BytePos(end as u32), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(start as u32), BytePos(end as u32))\n }\n \n fn make_pos(file_text: &str, pos: &Position) -> usize {"}, {"sha": "5017e5f5424c10fa78a172e3059133e4f8bce23b", "filename": "src/libsyntax/tokenstream/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream%2Ftests.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -3,14 +3,14 @@ use super::*;\n use crate::ast::Name;\n use crate::with_default_globals;\n use crate::tests::string_to_stream;\n-use syntax_pos::{Span, BytePos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos};\n \n fn string_to_ts(string: &str) -> TokenStream {\n     string_to_stream(string.to_owned())\n }\n \n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n #[test]"}, {"sha": "d030ea4a56ebb8b49ca4657a9a5fd6b0029db336", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    let container_id = cx.current_expansion.id.parent();\n+                    let container_id = cx.current_expansion.id.expn_data().parent;\n                     if cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,\n@@ -129,7 +129,7 @@ fn cs_clone_shallow(name: &str,\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n         let self_ty =\n-            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_empty_ctxt(kw::SelfUpper)));\n+            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_dummy_span(kw::SelfUpper)));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "54027c600b4cd714202ff9a6e39b5e1b6d07bf0b", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::EQ);\n \n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = cx.meta_list_item_word(span, sym::hidden);"}, {"sha": "91e1e80e4fbfa1347da4ee6a009eefbd76f66f18", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n                                   push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::PARTIAL_EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::PARTIAL_EQ);\n \n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different"}, {"sha": "1d5234a9b7b4f90f033208fdb9bb42143a44f358", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -82,7 +82,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_empty_ctxt(sym::field),\n+                                                Ident::with_dummy_span(sym::field),\n                                                 vec![field]);\n \n                 // Use `let _ = expr;` to avoid triggering the\n@@ -106,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 let field = cx.expr_addr_of(field.span, field);\n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_empty_ctxt(sym::field),\n+                                                Ident::with_dummy_span(sym::field),\n                                                 vec![name, field]);\n                 stmts.push(stmt_let_undescore(cx, span, expr));\n             }"}, {"sha": "55fb7677038ba6223b38d05e71dc1d0f38384a5c", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -425,7 +425,7 @@ impl<'a> TraitDef<'a> {\n                         return;\n                     }\n                 };\n-                let container_id = cx.current_expansion.id.parent();\n+                let container_id = cx.current_expansion.id.expn_data().parent;\n                 let is_always_copy =\n                     cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                     has_no_type_params;\n@@ -928,7 +928,7 @@ impl<'a> MethodDef<'a> {\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                let ident = Ident::with_empty_ctxt(kw::SelfLower).with_span_pos(trait_.span);\n+                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n                 ast::Arg::from_self(ThinVec::default(), explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()"}, {"sha": "9834130fa23f0871b44145e187ab492d97945bfa", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -23,13 +23,13 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     let sp = sp.apply_mark(cx.current_expansion.id);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n-            let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));\n+            let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[sym::option, sym::Option, sym::None]),\n                                      vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp,\n-                                                                 Ident::with_empty_ctxt(sym::str)),\n+                                                                 Ident::with_dummy_span(sym::str)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n                                      vec![]))"}, {"sha": "d2121abe3b466b5313938138017597fc1f20de53", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -29,7 +29,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let span = item.span.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,\n@@ -44,7 +44,7 @@ pub fn expand(\n     let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item =\n-        ecx.item_const(span, Ident::with_empty_ctxt(kw::Underscore), const_ty, const_body);\n+        ecx.item_const(span, Ident::with_dummy_span(kw::Underscore), const_ty, const_body);\n \n     // Return the original item and the new methods.\n     vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n@@ -120,7 +120,7 @@ impl AllocFnFactory<'_, '_> {\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+                let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n@@ -178,12 +178,12 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+        let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n         self.cx.ty_path(usize)\n     }\n \n     fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n+        let u8 = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::u8));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }"}, {"sha": "3ded808bb358aaa6427503e18d9551603e0ed11f", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -42,7 +42,7 @@ pub mod test_harness;\n \n pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n     let mut register = |name, kind| resolver.register_builtin_macro(\n-        Ident::with_empty_ctxt(name), SyntaxExtension {\n+        Ident::with_dummy_span(name), SyntaxExtension {\n             is_builtin: true, ..SyntaxExtension::default(kind, edition)\n         },\n     );"}, {"sha": "dbfd8fe98f38999c582f1d935de57a54fcc85cd0", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnId, ExpnInfo, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n \n use std::mem;\n \n@@ -43,12 +43,12 @@ pub fn inject(\n ) {\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n-        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+        let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));\n         for (name, ext) in named_exts {\n-            resolver.register_builtin_macro(Ident::with_empty_ctxt(name), ext);\n+            resolver.register_builtin_macro(Ident::with_dummy_span(name), ext);\n             extra_items.push(plugin_macro_def(name, span));\n         }\n         // The `macro_rules` items must be inserted before any other items."}, {"sha": "e772eaf834964359b8870fb081390517c48cf262", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -3,10 +3,9 @@ use std::mem;\n use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n-use syntax::ext::hygiene::ExpnId;\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -328,7 +327,7 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n         [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));\n@@ -337,7 +336,7 @@ fn mk_decls(\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n     let doc_hidden = cx.attribute(doc);\n \n-    let proc_macro = Ident::with_empty_ctxt(sym::proc_macro);\n+    let proc_macro = Ident::with_dummy_span(sym::proc_macro);\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n@@ -349,7 +348,7 @@ fn mk_decls(\n     let custom_derive = Ident::from_str(\"custom_derive\");\n     let attr = Ident::from_str(\"attr\");\n     let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_empty_ctxt(kw::Crate);\n+    let crate_kw = Ident::with_dummy_span(kw::Crate);\n \n     let decls = {\n         let local_path = |sp: Span, name| {"}, {"sha": "8ca376341fcdb7b72f6016c6ddbfa93bfe101f83", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,8 +1,8 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n-use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::ext::hygiene::MacroKind;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n@@ -32,15 +32,15 @@ pub fn inject(\n         // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n         // so they don't accidentally interfere with the new import paths.\n         let orig_name_sym = Symbol::intern(orig_name_str);\n-        let orig_name_ident = Ident::with_empty_ctxt(orig_name_sym);\n+        let orig_name_ident = Ident::with_dummy_span(orig_name_sym);\n         let (rename, orig_name) = if rust_2018 {\n             (orig_name_ident.gensym(), Some(orig_name_sym))\n         } else {\n             (orig_name_ident, None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::macro_use))\n+                attr::mk_word_item(ast::Ident::with_dummy_span(sym::macro_use))\n             )],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n@@ -55,7 +55,7 @@ pub fn inject(\n     // the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n     ));\n@@ -66,7 +66,7 @@ pub fn inject(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(ast::Ident::with_empty_ctxt(kw::PathRoot))\n+                segments: iter::once(ast::Ident::with_dummy_span(kw::PathRoot))\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)"}, {"sha": "08582e714ccb26aba0bb51c4b627740b8451af0e", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -29,7 +29,7 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let sp = attr_sp.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n@@ -93,7 +93,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.id);\n+    let ctxt = SyntaxContext::root().apply_mark(cx.current_expansion.id);\n     let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names"}, {"sha": "4a6ea0ebf85e5b6fc5c0f215c754ee16a06b2419", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -5,14 +5,13 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n-use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::ext::base::{ExtCtxt, MacroKind, Resolver};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n-use syntax::ext::hygiene::{ExpnId, MacroKind};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -150,7 +149,7 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_ident = Ident::with_empty_ctxt(sym::allow);\n+                    let allow_ident = Ident::with_dummy_span(sym::allow);\n                     let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n@@ -191,7 +190,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n                    tests: Vec<Ident>,\n                    tested_submods: Vec<(Ident, Ident)>)\n                    -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_empty_ctxt(kw::Super);\n+    let super_ = Ident::with_dummy_span(kw::Super);\n \n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n@@ -269,12 +268,12 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n         [sym::main, sym::test, sym::rustc_attrs][..].into(),\n     ));\n     let ecx = &cx.ext_cx;\n-    let test_id = Ident::with_empty_ctxt(sym::test);\n+    let test_id = Ident::with_dummy_span(sym::test);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or("}, {"sha": "00cd00f2837849b10cbe646f4b7fcfc28796fada", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,7 +1,6 @@\n use crate::symbol::{Symbol, sym};\n use std::fmt;\n use std::str::FromStr;\n-use crate::GLOBALS;\n \n /// The edition of the compiler (RFC 2052)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n@@ -39,10 +38,6 @@ impl fmt::Display for Edition {\n }\n \n impl Edition {\n-    pub fn from_session() -> Edition {\n-        GLOBALS.with(|globals| globals.edition)\n-    }\n-\n     pub fn lint_name(&self) -> &'static str {\n         match *self {\n             Edition::Edition2015 => \"rust_2015_compatibility\","}, {"sha": "87d930f897afc45d817c03c478887b308ddf0980", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 82, "deletions": 98, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -13,8 +13,8 @@\n //\n // This explains why `HygieneData`, `SyntaxContext` and `ExpnId` have interfaces\n // with a certain amount of redundancy in them. For example,\n-// `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n-// `ExpnId::expn_info` so that two `HygieneData` accesses can be performed within\n+// `SyntaxContext::outer_expn_data` combines `SyntaxContext::outer` and\n+// `ExpnId::expn_data` so that two `HygieneData` accesses can be performed within\n // a single `HygieneData::with` call.\n //\n // It also explains why many functions appear in `HygieneData` and again in\n@@ -56,16 +56,6 @@ struct SyntaxContextData {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ExpnId(u32);\n \n-// FIXME: Find a way to merge this with `ExpnInfo`.\n-#[derive(Debug)]\n-struct InternalExpnData {\n-    parent: ExpnId,\n-    /// Each expansion should have an associated expansion info, but sometimes there's a delay\n-    /// between creation of an expansion ID and obtaining its info (e.g. macros are collected\n-    /// first and then resolved later), so we use an `Option` here.\n-    expn_info: Option<ExpnInfo>,\n-}\n-\n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -86,8 +76,8 @@ pub enum Transparency {\n }\n \n impl ExpnId {\n-    pub fn fresh(parent: ExpnId, expn_info: Option<ExpnInfo>) -> Self {\n-        HygieneData::with(|data| data.fresh_expn(parent, expn_info))\n+    pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n+        HygieneData::with(|data| data.fresh_expn(expn_data))\n     }\n \n     /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -107,21 +97,16 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn parent(self) -> ExpnId {\n-        HygieneData::with(|data| data.parent_expn(self))\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     #[inline]\n-    pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self).cloned())\n-    }\n-\n-    #[inline]\n-    pub fn set_expn_info(self, info: ExpnInfo) {\n+    pub fn set_expn_data(self, expn_data: ExpnData) {\n         HygieneData::with(|data| {\n-            let old_info = &mut data.expn_data[self.0 as usize].expn_info;\n-            assert!(old_info.is_none(), \"expansion info is reset for an expansion ID\");\n-            *old_info = Some(info);\n+            let old_expn_data = &mut data.expn_data[self.0 as usize];\n+            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n+            *old_expn_data = Some(expn_data);\n         })\n     }\n \n@@ -139,12 +124,9 @@ impl ExpnId {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            if data.default_transparency(self) == Transparency::Opaque {\n-                if let Some(expn_info) = data.expn_info(self) {\n-                    if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n-                        return true;\n-                    }\n-                }\n+            let expn_data = data.expn_data(self);\n+            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_data.kind {\n+                return expn_data.default_transparency == Transparency::Opaque;\n             }\n             false\n         })\n@@ -153,18 +135,18 @@ impl ExpnId {\n \n #[derive(Debug)]\n crate struct HygieneData {\n-    expn_data: Vec<InternalExpnData>,\n+    /// Each expansion should have an associated expansion data, but sometimes there's a delay\n+    /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n+    /// first and then resolved later), so we use an `Option` here.\n+    expn_data: Vec<Option<ExpnData>>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            expn_data: vec![InternalExpnData {\n-                parent: ExpnId::root(),\n-                expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n-            }],\n+            expn_data: vec![Some(ExpnData::default(ExpnKind::Root, DUMMY_SP, edition))],\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n                 outer_transparency: Transparency::Opaque,\n@@ -181,43 +163,26 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_expn(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n-        self.expn_data.push(InternalExpnData { parent, expn_info });\n+    fn fresh_expn(&mut self, expn_data: Option<ExpnData>) -> ExpnId {\n+        self.expn_data.push(expn_data);\n         ExpnId(self.expn_data.len() as u32 - 1)\n     }\n \n-    fn parent_expn(&self, expn_id: ExpnId) -> ExpnId {\n-        self.expn_data[expn_id.0 as usize].parent\n-    }\n-\n-    fn expn_info(&self, expn_id: ExpnId) -> Option<&ExpnInfo> {\n-        if expn_id != ExpnId::root() {\n-            Some(self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n-                     .expect(\"no expansion info for an expansion ID\"))\n-        } else {\n-            // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n-            // Introduce a method for checking for \"no expansion\" instead and always return\n-            // `ExpnInfo` from this function instead of the `Option`.\n-            None\n-        }\n+    fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n+        self.expn_data[expn_id.0 as usize].as_ref()\n+            .expect(\"no expansion data for an expansion ID\")\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n         while expn_id != ancestor {\n             if expn_id == ExpnId::root() {\n                 return false;\n             }\n-            expn_id = self.parent_expn(expn_id);\n+            expn_id = self.expn_data(expn_id).parent;\n         }\n         true\n     }\n \n-    fn default_transparency(&self, expn_id: ExpnId) -> Transparency {\n-        self.expn_info(expn_id).map_or(\n-            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n-        )\n-    }\n-\n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n@@ -246,7 +211,7 @@ impl HygieneData {\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n-        while ctxt != SyntaxContext::empty() {\n+        while ctxt != SyntaxContext::root() {\n             marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n             ctxt = self.parent_ctxt(ctxt);\n         }\n@@ -255,12 +220,8 @@ impl HygieneData {\n     }\n \n     fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n-        while span.ctxt() != crate::NO_EXPANSION && span.ctxt() != to {\n-            if let Some(info) = self.expn_info(self.outer_expn(span.ctxt())) {\n-                span = info.call_site;\n-            } else {\n-                break;\n-            }\n+        while span.from_expansion() && span.ctxt() != to {\n+            span = self.expn_data(self.outer_expn(span.ctxt())).call_site;\n         }\n         span\n     }\n@@ -275,7 +236,9 @@ impl HygieneData {\n \n     fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(ctxt, expn_id, self.default_transparency(expn_id))\n+        self.apply_mark_with_transparency(\n+            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n+        )\n     }\n \n     fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n@@ -285,15 +248,14 @@ impl HygieneData {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        let call_site_ctxt =\n-            self.expn_info(expn_id).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+        let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n             self.modern_and_legacy(call_site_ctxt)\n         };\n \n-        if call_site_ctxt == SyntaxContext::empty() {\n+        if call_site_ctxt == SyntaxContext::root() {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n@@ -400,7 +362,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n \n impl SyntaxContext {\n     #[inline]\n-    pub const fn empty() -> Self {\n+    pub const fn root() -> Self {\n         SyntaxContext(0)\n     }\n \n@@ -578,20 +540,20 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.outer_expn(self))\n     }\n \n-    /// `ctxt.outer_expn_info()` is equivalent to but faster than\n-    /// `ctxt.outer_expn().expn_info()`.\n+    /// `ctxt.outer_expn_data()` is equivalent to but faster than\n+    /// `ctxt.outer_expn().expn_data()`.\n     #[inline]\n-    pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).cloned())\n+    pub fn outer_expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n-    /// `ctxt.outer_expn_with_info()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_info()) }`.\n+    /// `ctxt.outer_expn_with_data()` is equivalent to but faster than\n+    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_data()) }`.\n     #[inline]\n-    pub fn outer_expn_with_info(self) -> (ExpnId, Option<ExpnInfo>) {\n+    pub fn outer_expn_with_data(self) -> (ExpnId, ExpnData) {\n         HygieneData::with(|data| {\n             let outer = data.outer_expn(self);\n-            (outer, data.expn_info(outer).cloned())\n+            (outer, data.expn_data(outer).clone())\n         })\n     }\n \n@@ -612,38 +574,42 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n+    pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n         HygieneData::with(|data| {\n-            let expn_id = data.fresh_expn(parent, Some(expn_info));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), expn_id))\n+            let expn_id = data.fresh_expn(Some(expn_data));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n         })\n     }\n }\n \n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ExpnInfo {\n+pub struct ExpnData {\n     // --- The part unique to each expansion.\n+    /// The kind of this expansion - macro or compiler desugaring.\n+    pub kind: ExpnKind,\n+    /// The expansion that produced this expansion.\n+    pub parent: ExpnId,\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n     /// This may recursively refer to other macro invocations, e.g., if\n     /// `foo!()` invoked `bar!()` internally, and there was an\n     /// expression inside `bar!`; the call_site of the expression in\n     /// the expansion would point to the `bar!` invocation; that\n-    /// call_site span would have its own ExpnInfo, with the call_site\n+    /// call_site span would have its own ExpnData, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// The kind of this expansion - macro or compiler desugaring.\n-    pub kind: ExpnKind,\n \n     // --- The part specific to the macro/desugaring definition.\n-    // --- FIXME: Share it between expansions with the same definition.\n+    // --- It may be reasonable to share this part between expansions with the same definition,\n+    // --- but such sharing is known to bring some minor inconveniences without also bringing\n+    // --- noticeable perf improvements (PR #62898).\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for the expansion with this expansion info by default.\n+    /// Transparency used by `apply_mark` for the expansion with this expansion data by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n@@ -659,12 +625,13 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n-impl ExpnInfo {\n-    /// Constructs an expansion info with default properties.\n-    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnInfo {\n-        ExpnInfo {\n-            call_site,\n+impl ExpnData {\n+    /// Constructs expansion data with default properties.\n+    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnData {\n+        ExpnData {\n             kind,\n+            parent: ExpnId::root(),\n+            call_site,\n             def_site: DUMMY_SP,\n             default_transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n@@ -675,12 +642,17 @@ impl ExpnInfo {\n     }\n \n     pub fn allow_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n-                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnInfo {\n-        ExpnInfo {\n+                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnData {\n+        ExpnData {\n             allow_internal_unstable: Some(allow_internal_unstable),\n-            ..ExpnInfo::default(kind, call_site, edition)\n+            ..ExpnData::default(kind, call_site, edition)\n         }\n     }\n+\n+    #[inline]\n+    pub fn is_root(&self) -> bool {\n+        if let ExpnKind::Root = self.kind { true } else { false }\n+    }\n }\n \n /// Expansion kind.\n@@ -767,14 +739,26 @@ impl DesugaringKind {\n     }\n }\n \n+impl Encodable for ExpnId {\n+    fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n+        Ok(()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}\n+\n+impl Decodable for ExpnId {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        Ok(ExpnId::root()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}\n+\n impl Encodable for SyntaxContext {\n     fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n         Ok(()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n \n impl Decodable for SyntaxContext {\n-    fn decode<D: Decoder>(_: &mut D) -> Result<SyntaxContext, D::Error> {\n-        Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        Ok(SyntaxContext::root()) // FIXME(jseyfried) intercrate hygiene\n     }\n }"}, {"sha": "aa36fe27d8ec4dddd786884a44cf6467cce6bae3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -21,7 +21,7 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n+pub use hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -49,7 +49,6 @@ pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n     span_interner: Lock<span_encoding::SpanInterner>,\n     hygiene_data: Lock<hygiene::HygieneData>,\n-    edition: Edition,\n }\n \n impl Globals {\n@@ -58,7 +57,6 @@ impl Globals {\n             symbol_interner: Lock::new(symbol::Interner::fresh()),\n             span_interner: Lock::new(span_encoding::SpanInterner::default()),\n             hygiene_data: Lock::new(hygiene::HygieneData::new(edition)),\n-            edition,\n         }\n     }\n }\n@@ -288,6 +286,17 @@ impl Span {\n         span.lo.0 == 0 && span.hi.0 == 0\n     }\n \n+    /// Returns `true` if this span comes from a macro or desugaring.\n+    #[inline]\n+    pub fn from_expansion(self) -> bool {\n+        self.ctxt() != SyntaxContext::root()\n+    }\n+\n+    #[inline]\n+    pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n+        Span::new(lo, hi, SyntaxContext::root())\n+    }\n+\n     /// Returns a new span representing an empty span at the beginning of this span\n     #[inline]\n     pub fn shrink_to_lo(self) -> Span {\n@@ -344,20 +353,20 @@ impl Span {\n     /// Returns the source span -- this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        self.ctxt().outer_expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { expn_data.call_site.source_callsite() } else { self }\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,\n     /// if any.\n     pub fn parent(self) -> Option<Span> {\n-        self.ctxt().outer_expn_info().map(|i| i.call_site)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(expn_data.call_site) } else { None }\n     }\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer_expn_info().map_or_else(|| {\n-            Edition::from_session()\n-        }, |einfo| einfo.edition)\n+        self.ctxt().outer_expn_data().edition\n     }\n \n     #[inline]\n@@ -373,72 +382,63 @@ impl Span {\n     /// Returns the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,\n-    /// else returns the `ExpnInfo` for the macro definition\n+    /// else returns the `ExpnData` for the macro definition\n     /// corresponding to the source callsite.\n-    pub fn source_callee(self) -> Option<ExpnInfo> {\n-        fn source_callee(info: ExpnInfo) -> ExpnInfo {\n-            match info.call_site.ctxt().outer_expn_info() {\n-                Some(info) => source_callee(info),\n-                None => info,\n-            }\n+    pub fn source_callee(self) -> Option<ExpnData> {\n+        fn source_callee(expn_data: ExpnData) -> ExpnData {\n+            let next_expn_data = expn_data.call_site.ctxt().outer_expn_data();\n+            if !next_expn_data.is_root() { source_callee(next_expn_data) } else { expn_data }\n         }\n-        self.ctxt().outer_expn_info().map(source_callee)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(source_callee(expn_data)) } else { None }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self, feature: Symbol) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info\n-                .allow_internal_unstable\n-                .map_or(false, |features| features.iter().any(|&f|\n-                    f == feature || f == sym::allow_internal_unstable_backcompat_hack\n-                )),\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_data().allow_internal_unstable.map_or(false, |features| {\n+            features.iter().any(|&f| {\n+                f == feature || f == sym::allow_internal_unstable_backcompat_hack\n+            })\n+        })\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => k == kind,\n-                _ => false,\n-            },\n-            None => false,\n+        match self.ctxt().outer_expn_data().kind {\n+            ExpnKind::Desugaring(k) => k == kind,\n+            _ => false,\n         }\n     }\n \n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n     pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => Some(k),\n-                _ => None\n-            },\n-            None => None\n+        match self.ctxt().outer_expn_data().kind {\n+            ExpnKind::Desugaring(k) => Some(k),\n+            _ => None\n         }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info.allow_internal_unsafe,\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_data().allow_internal_unsafe\n     }\n \n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n-        while let Some(info) = self.ctxt().outer_expn_info() {\n+        loop {\n+            let expn_data = self.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n+                break;\n+            }\n             // Don't print recursive invocations.\n-            if !info.call_site.source_equal(&prev_span) {\n-                let (pre, post) = match info.kind {\n+            if !expn_data.call_site.source_equal(&prev_span) {\n+                let (pre, post) = match expn_data.kind {\n                     ExpnKind::Root => break,\n                     ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n                     ExpnKind::Macro(macro_kind, _) => match macro_kind {\n@@ -448,14 +448,14 @@ impl Span {\n                     }\n                 };\n                 result.push(MacroBacktrace {\n-                    call_site: info.call_site,\n-                    macro_decl_name: format!(\"{}{}{}\", pre, info.kind.descr(), post),\n-                    def_site_span: info.def_site,\n+                    call_site: expn_data.call_site,\n+                    macro_decl_name: format!(\"{}{}{}\", pre, expn_data.kind.descr(), post),\n+                    def_site_span: expn_data.def_site,\n                 });\n             }\n \n             prev_span = self;\n-            self = info.call_site;\n+            self = expn_data.call_site;\n         }\n         result\n     }\n@@ -468,9 +468,9 @@ impl Span {\n         // Return the macro span on its own to avoid weird diagnostic output. It is preferable to\n         // have an incomplete span than a completely nonsensical one.\n         if span_data.ctxt != end_data.ctxt {\n-            if span_data.ctxt == SyntaxContext::empty() {\n+            if span_data.ctxt == SyntaxContext::root() {\n                 return end;\n-            } else if end_data.ctxt == SyntaxContext::empty() {\n+            } else if end_data.ctxt == SyntaxContext::root() {\n                 return self;\n             }\n             // Both spans fall within a macro.\n@@ -479,7 +479,7 @@ impl Span {\n         Span::new(\n             cmp::min(span_data.lo, end_data.lo),\n             cmp::max(span_data.hi, end_data.hi),\n-            if span_data.ctxt == SyntaxContext::empty() { end_data.ctxt } else { span_data.ctxt },\n+            if span_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },\n         )\n     }\n \n@@ -490,7 +490,7 @@ impl Span {\n         Span::new(\n             span.hi,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -501,7 +501,7 @@ impl Span {\n         Span::new(\n             span.lo,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -611,7 +611,7 @@ impl rustc_serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span::new(lo, hi, NO_EXPANSION))\n+            Ok(Span::with_root_ctxt(lo, hi))\n         })\n     }\n }\n@@ -755,8 +755,6 @@ impl From<Vec<Span>> for MultiSpan {\n     }\n }\n \n-pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n-\n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {"}, {"sha": "e2d1635f31216606adaaf4ee46ba60ca6d537b59", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -14,7 +14,6 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::str;\n \n-use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n \n #[cfg(test)]\n@@ -745,25 +744,25 @@ impl Ident {\n         Ident { name, span }\n     }\n \n-    /// Constructs a new identifier with an empty syntax context.\n+    /// Constructs a new identifier with a dummy span.\n     #[inline]\n-    pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n+    pub const fn with_dummy_span(name: Symbol) -> Ident {\n         Ident::new(name, DUMMY_SP)\n     }\n \n     #[inline]\n     pub fn invalid() -> Ident {\n-        Ident::with_empty_ctxt(kw::Invalid)\n+        Ident::with_dummy_span(kw::Invalid)\n     }\n \n     /// Maps an interned string to an identifier with an empty syntax context.\n     pub fn from_interned_str(string: InternedString) -> Ident {\n-        Ident::with_empty_ctxt(string.as_symbol())\n+        Ident::with_dummy_span(string.as_symbol())\n     }\n \n     /// Maps a string to an identifier with an empty span.\n     pub fn from_str(string: &str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::intern(string))\n+        Ident::with_dummy_span(Symbol::intern(string))\n     }\n \n     /// Maps a string and a span to an identifier.\n@@ -851,7 +850,7 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        if self.span.ctxt().modern() == SyntaxContext::empty() {\n+        if !self.span.modern().from_expansion() {\n             s.emit_str(&self.as_str())\n         } else { // FIXME(jseyfried): intercrate hygiene\n             let mut string = \"#\".to_owned();"}, {"sha": "676b8b9f056c1288c79909c5340a26eedffa3711", "filename": "src/test/ui/feature-gates/feature-gate-rustc-diagnostic-macros.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-diagnostic-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-diagnostic-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-diagnostic-macros.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -4,17 +4,17 @@ error: cannot find macro `__build_diagnostic_array!` in this scope\n LL | __build_diagnostic_array!(DIAGNOSTICS);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot find macro `__register_diagnostic!` in this scope\n-  --> $DIR/feature-gate-rustc-diagnostic-macros.rs:4:1\n-   |\n-LL | __register_diagnostic!(E0001);\n-   | ^^^^^^^^^^^^^^^^^^^^^\n-\n error: cannot find macro `__diagnostic_used!` in this scope\n   --> $DIR/feature-gate-rustc-diagnostic-macros.rs:8:5\n    |\n LL |     __diagnostic_used!(E0001);\n    |     ^^^^^^^^^^^^^^^^^\n \n+error: cannot find macro `__register_diagnostic!` in this scope\n+  --> $DIR/feature-gate-rustc-diagnostic-macros.rs:4:1\n+   |\n+LL | __register_diagnostic!(E0001);\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n error: aborting due to 3 previous errors\n "}, {"sha": "643f803f62049b1695bd14e3289ab8eb160e2fd9", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,3 +1,11 @@\n+error: cannot find macro `panic!` in this scope\n+  --> $DIR/no_implicit_prelude.rs:16:9\n+   |\n+LL |         assert_eq!(0, 0);\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n error[E0433]: failed to resolve: use of undeclared type or module `Vec`\n   --> $DIR/no_implicit_prelude.rs:11:9\n    |\n@@ -7,14 +15,6 @@ LL |     fn f() { ::bar::m!(); }\n LL |         Vec::new();\n    |         ^^^ use of undeclared type or module `Vec`\n \n-error: cannot find macro `panic!` in this scope\n-  --> $DIR/no_implicit_prelude.rs:16:9\n-   |\n-LL |         assert_eq!(0, 0);\n-   |         ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n error[E0599]: no method named `clone` found for type `()` in the current scope\n   --> $DIR/no_implicit_prelude.rs:12:12\n    |"}, {"sha": "7d013828bd90857603388ce5092c3ba751bb933a", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -21,25 +21,6 @@ LL | use inner1::*;\n    |     ^^^^^^^^^\n    = help: consider adding an explicit import of `exported` to disambiguate\n \n-error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n-  --> $DIR/local-modularized-tricky-fail-1.rs:46:1\n-   |\n-LL | include!();\n-   | ^^^^^^^ ambiguous name\n-   |\n-   = note: `include` could refer to a macro from prelude\n-note: `include` could also refer to the macro defined here\n-  --> $DIR/local-modularized-tricky-fail-1.rs:17:5\n-   |\n-LL | /     macro_rules! include {\n-LL | |         () => ()\n-LL | |     }\n-   | |_____^\n-...\n-LL |       define_include!();\n-   |       ------------------ in this macro invocation\n-   = help: use `crate::include` to refer to this macro unambiguously\n-\n error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:35:5\n    |\n@@ -59,6 +40,25 @@ LL |       define_panic!();\n    |       ---------------- in this macro invocation\n    = help: use `crate::panic` to refer to this macro unambiguously\n \n+error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n+  --> $DIR/local-modularized-tricky-fail-1.rs:46:1\n+   |\n+LL | include!();\n+   | ^^^^^^^ ambiguous name\n+   |\n+   = note: `include` could refer to a macro from prelude\n+note: `include` could also refer to the macro defined here\n+  --> $DIR/local-modularized-tricky-fail-1.rs:17:5\n+   |\n+LL | /     macro_rules! include {\n+LL | |         () => ()\n+LL | |     }\n+   | |_____^\n+...\n+LL |       define_include!();\n+   |       ------------------ in this macro invocation\n+   = help: use `crate::include` to refer to this macro unambiguously\n+\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "2f2ab20cdf077058cc6e3c15cd3fc3e81e470627", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -13,20 +13,6 @@ LL |     use foo::*;\n    = help: consider adding an explicit import of `panic` to disambiguate\n    = help: or use `self::panic` to refer to this macro unambiguously\n \n-error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n-  --> $DIR/shadow_builtin_macros.rs:20:14\n-   |\n-LL |     fn f() { panic!(); }\n-   |              ^^^^^ ambiguous name\n-   |\n-   = note: `panic` could refer to a macro from prelude\n-note: `panic` could also refer to the macro imported here\n-  --> $DIR/shadow_builtin_macros.rs:19:26\n-   |\n-LL |     ::two_macros::m!(use foo::panic;);\n-   |                          ^^^^^^^^^^\n-   = help: use `self::panic` to refer to this macro unambiguously\n-\n error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:33:5\n    |\n@@ -62,6 +48,20 @@ note: `n` could also refer to the macro imported here\n LL | #[macro_use(n)]\n    |             ^\n \n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n+  --> $DIR/shadow_builtin_macros.rs:20:14\n+   |\n+LL |     fn f() { panic!(); }\n+   |              ^^^^^ ambiguous name\n+   |\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro imported here\n+  --> $DIR/shadow_builtin_macros.rs:19:26\n+   |\n+LL |     ::two_macros::m!(use foo::panic;);\n+   |                          ^^^^^^^^^^\n+   = help: use `self::panic` to refer to this macro unambiguously\n+\n error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "e0d3bb3ecc2e17b4562bbe81b420314a6c7d8814", "filename": "src/test/ui/issues/issue-49074.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -1,9 +1,3 @@\n-error: cannot find attribute macro `marco_use` in this scope\n-  --> $DIR/issue-49074.rs:3:3\n-   |\n-LL | #[marco_use] // typo\n-   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_use`\n-\n error: cannot find macro `bar!` in this scope\n   --> $DIR/issue-49074.rs:12:4\n    |\n@@ -12,5 +6,11 @@ LL |    bar!();\n    |\n    = help: have you added the `#[macro_use]` on the module/import?\n \n+error: cannot find attribute macro `marco_use` in this scope\n+  --> $DIR/issue-49074.rs:3:3\n+   |\n+LL | #[marco_use] // typo\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_use`\n+\n error: aborting due to 2 previous errors\n "}, {"sha": "0c863e919670dad375f5feb9419eb9d491d26ee8", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -88,18 +88,6 @@ error: expected derive macro, found macro `crate::my_macro`\n LL | #[derive(crate::my_macro)]\n    |          ^^^^^^^^^^^^^^^ not a derive macro\n \n-error: cannot find attribute macro `my_macro` in this scope\n-  --> $DIR/macro-namespace-reserved-2.rs:38:3\n-   |\n-LL | #[my_macro]\n-   |   ^^^^^^^^\n-\n-error: cannot find derive macro `my_macro` in this scope\n-  --> $DIR/macro-namespace-reserved-2.rs:48:10\n-   |\n-LL | #[derive(my_macro)]\n-   |          ^^^^^^^^\n-\n error: cannot find macro `my_macro_attr!` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:28:5\n    |\n@@ -112,5 +100,17 @@ error: cannot find macro `MyTrait!` in this scope\n LL |     MyTrait!();\n    |     ^^^^^^^\n \n+error: cannot find attribute macro `my_macro` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:38:3\n+   |\n+LL | #[my_macro]\n+   |   ^^^^^^^^\n+\n+error: cannot find derive macro `my_macro` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:48:10\n+   |\n+LL | #[derive(my_macro)]\n+   |          ^^^^^^^^\n+\n error: aborting due to 19 previous errors\n "}, {"sha": "856162b318deac96517713556131de2b7ffdcf11", "filename": "src/test/ui/reserved/reserved-attr-on-macro.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr?ref=6e9e6ea39bbc2c9e58cdc854c55dfc1487a77ae1", "patch": "@@ -7,12 +7,6 @@ LL | #[rustc_attribute_should_be_reserved]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error: cannot find attribute macro `rustc_attribute_should_be_reserved` in this scope\n-  --> $DIR/reserved-attr-on-macro.rs:1:3\n-   |\n-LL | #[rustc_attribute_should_be_reserved]\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: cannot determine resolution for the macro `foo`\n   --> $DIR/reserved-attr-on-macro.rs:10:5\n    |\n@@ -21,6 +15,12 @@ LL |     foo!();\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n+error: cannot find attribute macro `rustc_attribute_should_be_reserved` in this scope\n+  --> $DIR/reserved-attr-on-macro.rs:1:3\n+   |\n+LL | #[rustc_attribute_should_be_reserved]\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}]}