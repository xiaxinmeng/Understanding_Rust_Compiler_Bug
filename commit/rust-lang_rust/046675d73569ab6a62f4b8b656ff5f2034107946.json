{"sha": "046675d73569ab6a62f4b8b656ff5f2034107946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NjY3NWQ3MzU2OWFiNmE2MmY0YjhiNjU2ZmY1ZjIwMzQxMDc5NDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T21:05:45Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:20:45Z"}, "message": "Also release locks on ReleaseValidation and EndRegion", "tree": {"sha": "d251be3b355e4be504e8b38c9fe4751acb144298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d251be3b355e4be504e8b38c9fe4751acb144298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/046675d73569ab6a62f4b8b656ff5f2034107946", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll2/10ACgkQpp+NIls6\n19lfog/8CobE4+KWdX9F3MuurTtFg2ZUyKl3GUYH45IcIqcc2hu7elUAZzgfpjPX\nJ3pBVhv0kPK0iDaUI3o5u5mn/uZpDy++XsPp8yqV9f+aL9w07t1dTQ5UGVGO5aqt\nGQkDpYQCkqSOUv4v9WKbB2+5KKIIJnDRIxyppFdJiiNjpA3mNVBLBg+EuuGGjqCK\n0q6ZBJgv3+FJ3TPazExV1jcrhDBwcOJ0D1rBmu+rLqmBIi2U6B1aMN6KLmcl5FTL\nSwM6Vpp1uEkVYCG7dno2DxCrZI4VVxcmQAvSrWmFptCGiKN7KSNCw3EwwMah0+Bf\nLzl9X+GLKsH9QOhoWslogf2Jd947EypOTfuwAoc7NI5w772PzS9GETjdnHn0WBX6\n9YhhRHZIJ7PeqrqqeRGRwnz+dTQZzWL/TMC/fJCHTMnZeHFtJoN3BAjZY2qhWzXH\nE2PlLknFn8cam+vLnDExwJ6LVbbqRFuUY1Fo6fI+qXYADr7duX2rGJwiNiJgv7YW\nRYiFhSgchdkTsFhWtXnQVnnseI6p9inmpOzgm6Wdd3qT84fzYhgFyx6A077pt2Wv\nmQGy/GPMVUvziVA5nfdqSr8qUNHpN16sGd+YmGDbV+hRvUHJ99Y8QXNjhZs7OrOm\ngLDPlqoUzpKoilCIReV44rbwLXEwA1sqzRUqYyGNgx8RTpvzHFs=\n=18lP\n-----END PGP SIGNATURE-----", "payload": "tree d251be3b355e4be504e8b38c9fe4751acb144298\nparent aaae815b44e7071707aa61ccc43f399ffc429c77\nauthor Ralf Jung <post@ralfj.de> 1499979945 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500970845 +0200\n\nAlso release locks on ReleaseValidation and EndRegion\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/046675d73569ab6a62f4b8b656ff5f2034107946", "html_url": "https://github.com/rust-lang/rust/commit/046675d73569ab6a62f4b8b656ff5f2034107946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/046675d73569ab6a62f4b8b656ff5f2034107946/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaae815b44e7071707aa61ccc43f399ffc429c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaae815b44e7071707aa61ccc43f399ffc429c77", "html_url": "https://github.com/rust-lang/rust/commit/aaae815b44e7071707aa61ccc43f399ffc429c77"}], "stats": {"total": 92, "additions": 61, "deletions": 31}, "files": [{"sha": "c0976e9ded974c0853717bc2d325ff0ce0dcab63", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 53, "deletions": 20, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/046675d73569ab6a62f4b8b656ff5f2034107946/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046675d73569ab6a62f4b8b656ff5f2034107946/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=046675d73569ab6a62f4b8b656ff5f2034107946", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::Mutability as TyMutability;\n-use rustc::mir;\n+use rustc::mir::{self, ValidationOp};\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc::middle::region::CodeExtent;\n@@ -469,45 +469,66 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n // Validity checks\n+#[derive(Copy, Clone, Debug)]\n+pub struct ValidationCtx {\n+    op: ValidationOp,\n+    region: Option<CodeExtent>,\n+    mutbl: TyMutability,\n+}\n+\n+impl ValidationCtx {\n+    pub fn new(op: ValidationOp) -> Self {\n+        ValidationCtx {\n+            op, region: None, mutbl: TyMutability::MutMutable,\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn validate_variant(\n         &mut self,\n         lvalue: Lvalue<'tcx>,\n         ty: Ty<'tcx>,\n         variant: &ty::VariantDef,\n         subst: &ty::subst::Substs<'tcx>,\n-        outer_mutbl: TyMutability\n+        vctx: ValidationCtx,\n     ) -> EvalResult<'tcx> {\n         // TODO: Take visibility/privacy into account.\n         for (idx, field) in variant.fields.iter().enumerate() {\n             let field_ty = field.ty(self.tcx, subst);\n             let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-            self.acquire_valid(field_lvalue, field_ty, outer_mutbl)?;\n+            self.validate(field_lvalue, field_ty, vctx)?;\n         }\n         Ok(())\n     }\n \n-    fn validate_ptr(&mut self, val: Value, region: Option<CodeExtent>, pointee_ty: Ty<'tcx>, mutbl: TyMutability) -> EvalResult<'tcx> {\n+    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, vctx: ValidationCtx) -> EvalResult<'tcx> {\n         use self::TyMutability::*;\n \n         // Acquire lock\n         let (len, _) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&mut self.memory)?.to_ptr()?;\n-        let access = match mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n-        self.memory.acquire_lock(ptr, len, region, access)?;\n+        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+        match vctx.op {\n+            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n+            ValidationOp::Release => self.memory.release_lock_until(ptr, len, None)?,\n+            ValidationOp::Suspend(region) => self.memory.release_lock_until(ptr, len, Some(region))?,\n+        }\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n-        self.acquire_valid(pointee_lvalue, pointee_ty, mutbl)\n+        self.validate(pointee_lvalue, pointee_ty, vctx)\n     }\n \n-    pub(super) fn acquire_valid(&mut self, lvalue: Lvalue<'tcx>, ty: Ty<'tcx>, outer_mutbl: TyMutability) -> EvalResult<'tcx> {\n+    /// Validate the lvalue at the given type. If `release` is true, just do a release of all write locks\n+    pub(super) fn validate(&mut self, lvalue: Lvalue<'tcx>, ty: Ty<'tcx>, mut vctx: ValidationCtx) -> EvalResult<'tcx>\n+    {\n         use rustc::ty::TypeVariants::*;\n         use rustc::ty::RegionKind::*;\n         use rustc::ty::AdtKind;\n         use self::TyMutability::*;\n \n-        trace!(\"Validating {:?} at type {}, outer mutability {:?}\", lvalue, ty, outer_mutbl);\n+        trace!(\"Validating {:?} at type {}, context {:?}\", lvalue, ty, vctx);\n         match ty.sty {\n             TyChar | TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n                 // TODO: Make sure these are not undef.\n@@ -520,17 +541,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n                 let val = self.read_lvalue(lvalue)?;\n-                let combined_mutbl = match outer_mutbl { MutMutable => mutbl, MutImmutable => MutImmutable };\n-                let extent = match *region {\n-                    ReScope(extent) => Some(extent),\n-                    _ => None,\n-                };\n-                self.validate_ptr(val, extent, pointee_ty, combined_mutbl)\n+                // Sharing restricts our context\n+                if mutbl == MutImmutable {\n+                    // Actually, in case of releasing-validation, this means we are done.\n+                    if vctx.op != ValidationOp::Acquire {\n+                        return Ok(());\n+                    }\n+                    vctx.mutbl = MutImmutable;\n+                }\n+                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n+                // we record the region of this borrow to the context.\n+                if vctx.region == None {\n+                    match *region {\n+                        ReScope(ce) => vctx.region = Some(ce),\n+                        // It is possible for us to encode erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n+                        _ => {},\n+                    }\n+                }\n+                self.validate_ptr(val, pointee_ty, vctx)\n             }\n             TyAdt(adt, _) if adt.is_box() => {\n                 let val = self.read_lvalue(lvalue)?;\n-                // TODO: The region can't always be None.  It must take outer borrows into account.\n-                self.validate_ptr(val, None, ty.boxed_ty(), outer_mutbl)\n+                self.validate_ptr(val, ty.boxed_ty(), vctx)\n             }\n             TySlice(elem_ty) => {\n                 let len = match lvalue {\n@@ -539,7 +572,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 for i in 0..len {\n                     let inner_lvalue = self.lvalue_index(lvalue, ty, i)?;\n-                    self.acquire_valid(inner_lvalue, elem_ty, outer_mutbl)?;\n+                    self.validate(inner_lvalue, elem_ty, vctx)?;\n                 }\n                 Ok(())\n             }\n@@ -568,14 +601,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let lvalue = self.eval_lvalue_projection(lvalue, ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?;\n \n                             // Recursively validate the fields\n-                            self.validate_variant(lvalue, ty, variant, subst, outer_mutbl)\n+                            self.validate_variant(lvalue, ty, variant, subst, vctx)\n                         } else {\n                             // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n                             Ok(())\n                         }\n                     }\n                     AdtKind::Struct => {\n-                        self.validate_variant(lvalue, ty, adt.struct_variant(), subst, outer_mutbl)\n+                        self.validate_variant(lvalue, ty, adt.struct_variant(), subst, vctx)\n                     }\n                     AdtKind::Union => {\n                         // No guarantees are provided for union types."}, {"sha": "f148a096128ac384d747a99137cbd8218d41d158", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/046675d73569ab6a62f4b8b656ff5f2034107946/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046675d73569ab6a62f4b8b656ff5f2034107946/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=046675d73569ab6a62f4b8b656ff5f2034107946", "patch": "@@ -5,14 +5,14 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use rustc::mir::{self, ValidationOp};\n+use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::Layout;\n use rustc::ty::{subst, self};\n \n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n-use lvalue::{Global, GlobalId, Lvalue};\n+use lvalue::{Global, GlobalId, Lvalue, ValidationCtx};\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -132,19 +132,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Validity checks.\n             Validate(ref op, ref lvalues) => {\n-                match *op {\n-                    ValidationOp::Acquire => {\n-                        for operand in lvalues {\n-                            let lvalue = self.eval_lvalue(&operand.lval)?;\n-                            self.acquire_valid(lvalue, operand.ty, hir::MutMutable)?;\n-                        }\n-                    }\n-                    _ => { /* not yet implemented */ }\n+                for operand in lvalues {\n+                    let lvalue = self.eval_lvalue(&operand.lval)?;\n+                    self.validate(lvalue, operand.ty, ValidationCtx::new(*op))?;\n                 }\n             }\n \n             // Just a borrowck thing\n-            EndRegion(..) => {}\n+            EndRegion(ce) => {\n+                self.memory.locks_lifetime_ended(Some(ce));\n+            }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}]}