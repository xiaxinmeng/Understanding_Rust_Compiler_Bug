{"sha": "f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NjIwOGNhNWJkMzRiYTVlOTEwNmZlNjUyN2RiNDNhOWJkYzNhOGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-26T12:22:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-28T17:57:05Z"}, "message": "address nits", "tree": {"sha": "18857fb568c05f46f5b242ce3782c5103accb457", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18857fb568c05f46f5b242ce3782c5103accb457"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "html_url": "https://github.com/rust-lang/rust/commit/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c78fa822a311e30e6421525570f472bf19e32fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c78fa822a311e30e6421525570f472bf19e32fd", "html_url": "https://github.com/rust-lang/rust/commit/6c78fa822a311e30e6421525570f472bf19e32fd"}], "stats": {"total": 306, "additions": 178, "deletions": 128}, "files": [{"sha": "c598f99a2b54dfed9785ef4b1b741373c9dc0c56", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -517,7 +517,6 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             InvalidMemoryAccess |\n             InvalidFunctionPointer |\n             InvalidBool |\n-            InvalidDiscriminant |\n             InvalidNullPointerUsage |\n             ReadPointerAsBytes |\n             ReadBytesAsPointer |\n@@ -550,6 +549,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             GeneratorResumedAfterReturn |\n             GeneratorResumedAfterPanic |\n             InfiniteLoop => {}\n+            InvalidDiscriminant(val) => val.hash_stable(hcx, hasher),\n             Panic { ref msg, ref file, line, col } => {\n                 msg.hash_stable(hcx, hasher);\n                 file.hash_stable(hcx, hasher);"}, {"sha": "ab38f8fa72135dbb12054024c23a65fee2e8ae5b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -190,7 +190,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n-    InvalidDiscriminant,\n+    InvalidDiscriminant(u128),\n     PointerOutOfBounds {\n         ptr: Pointer,\n         access: bool,\n@@ -302,8 +302,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"tried to use a function pointer after offsetting it\",\n             InvalidBool =>\n                 \"invalid boolean value read\",\n-            InvalidDiscriminant =>\n-                \"invalid enum discriminant value read or written\",\n+            InvalidDiscriminant(..) =>\n+                \"invalid enum discriminant value read\",\n             PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n             InvalidNullPointerUsage =>\n@@ -488,6 +488,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                        align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n             Panic { ref msg, line, col, ref file } =>\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col),\n+            InvalidDiscriminant(val) =>\n+                write!(f, \"encountered invalid enum discriminant {}\", val),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "1f3c31405043502312ac5182a313b6b0220e682a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n             InvalidMemoryAccess => InvalidMemoryAccess,\n             InvalidFunctionPointer => InvalidFunctionPointer,\n             InvalidBool => InvalidBool,\n-            InvalidDiscriminant => InvalidDiscriminant,\n+            InvalidDiscriminant(val) => InvalidDiscriminant(val),\n             PointerOutOfBounds {\n                 ptr,\n                 access,"}, {"sha": "9aba7c78caf929739a6519dd1b7219d210fa0a59", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -585,7 +585,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     .expect(\"tagged layout for non adt\")\n                     .discriminants(self.tcx.tcx)\n                     .position(|var| var.val == real_discr)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant)?;\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(real_discr))?;\n                 (real_discr, index)\n             },\n             layout::Variants::NicheFilling {"}, {"sha": "34ca6613c1a1b122832a1c5b69944ada05aa88be", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 149, "deletions": 102, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -48,111 +48,100 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Returns the result of the specified operation and whether it overflowed.\n-    pub fn binary_op(\n+    fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,\n-        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n-        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+        l: char,\n+        r: char,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let left = left.to_scalar()?;\n-        let right = right.to_scalar()?;\n+        let res = match bin_op {\n+            Eq => l == r,\n+            Ne => l != r,\n+            Lt => l < r,\n+            Le => l <= r,\n+            Gt => l > r,\n+            Ge => l >= r,\n+            _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n+        };\n+        return Ok((Scalar::from_bool(res), false));\n+    }\n \n-        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-            bin_op, left, left_layout.ty.sty, right, right_layout.ty.sty);\n+    fn binary_bool_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        l: bool,\n+        r: bool,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n \n-        // Handle non-integer operations\n-        if let ty::Char = left_layout.ty.sty {\n-            assert_eq!(right_layout.ty.sty, ty::Char);\n-            let l = left.to_char()?;\n-            let r = right.to_char()?;\n-            let res = match bin_op {\n-                Eq => l == r,\n-                Ne => l != r,\n-                Lt => l < r,\n-                Le => l <= r,\n-                Gt => l > r,\n-                Ge => l >= r,\n-                _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n-            };\n-            return Ok((Scalar::from_bool(res), false));\n-        }\n-        if let ty::Bool = left_layout.ty.sty {\n-            assert_eq!(right_layout.ty.sty, ty::Bool);\n-            let l = left.to_bool()?;\n-            let r = right.to_bool()?;\n-            let res = match bin_op {\n-                Eq => l == r,\n-                Ne => l != r,\n-                Lt => l < r,\n-                Le => l <= r,\n-                Gt => l > r,\n-                Ge => l >= r,\n-                BitAnd => l & r,\n-                BitOr => l | r,\n-                BitXor => l ^ r,\n-                _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n-            };\n-            return Ok((Scalar::from_bool(res), false));\n-        }\n-        if let ty::Float(fty) = left_layout.ty.sty {\n-            let l = left.to_bits(left_layout.size)?;\n-            let r = right.to_bits(right_layout.size)?;\n-            assert_eq!(right_layout.ty.sty, ty::Float(fty));\n-            macro_rules! float_math {\n-                ($ty:path, $size:expr) => {{\n-                    let l = <$ty>::from_bits(l);\n-                    let r = <$ty>::from_bits(r);\n-                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n-                        bits: res.value.to_bits(),\n-                        size: $size,\n-                    };\n-                    let val = match bin_op {\n-                        Eq => Scalar::from_bool(l == r),\n-                        Ne => Scalar::from_bool(l != r),\n-                        Lt => Scalar::from_bool(l < r),\n-                        Le => Scalar::from_bool(l <= r),\n-                        Gt => Scalar::from_bool(l > r),\n-                        Ge => Scalar::from_bool(l >= r),\n-                        Add => bitify(l + r),\n-                        Sub => bitify(l - r),\n-                        Mul => bitify(l * r),\n-                        Div => bitify(l / r),\n-                        Rem => bitify(l % r),\n-                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n-                    };\n-                    return Ok((val, false));\n-                }};\n-            }\n-            match fty {\n-                FloatTy::F32 => float_math!(Single, 4),\n-                FloatTy::F64 => float_math!(Double, 8),\n-            }\n-        }\n-        // Only integers left\n-        #[inline]\n-        fn is_ptr<'tcx>(ty: ty::Ty<'tcx>) -> bool {\n-            match ty.sty {\n-                ty::RawPtr(..) | ty::Ref(..) | ty::FnPtr(..) => true,\n-                _ => false,\n-            }\n+        let res = match bin_op {\n+            Eq => l == r,\n+            Ne => l != r,\n+            Lt => l < r,\n+            Le => l <= r,\n+            Gt => l > r,\n+            Ge => l >= r,\n+            BitAnd => l & r,\n+            BitOr => l | r,\n+            BitXor => l ^ r,\n+            _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n+        };\n+        return Ok((Scalar::from_bool(res), false));\n+    }\n+\n+    fn binary_float_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        fty: FloatTy,\n+        // passing in raw bits\n+        l: u128,\n+        r: u128,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        macro_rules! float_math {\n+            ($ty:path, $size:expr) => {{\n+                let l = <$ty>::from_bits(l);\n+                let r = <$ty>::from_bits(r);\n+                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n+                    bits: res.value.to_bits(),\n+                    size: $size,\n+                };\n+                let val = match bin_op {\n+                    Eq => Scalar::from_bool(l == r),\n+                    Ne => Scalar::from_bool(l != r),\n+                    Lt => Scalar::from_bool(l < r),\n+                    Le => Scalar::from_bool(l <= r),\n+                    Gt => Scalar::from_bool(l > r),\n+                    Ge => Scalar::from_bool(l >= r),\n+                    Add => bitify(l + r),\n+                    Sub => bitify(l - r),\n+                    Mul => bitify(l * r),\n+                    Div => bitify(l / r),\n+                    Rem => bitify(l % r),\n+                    _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                };\n+                return Ok((val, false));\n+            }};\n         }\n-        assert!(left_layout.ty.is_integral() || is_ptr(left_layout.ty));\n-        assert!(right_layout.ty.is_integral() || is_ptr(right_layout.ty));\n-\n-        // Handle operations that support pointers\n-        if let Some(handled) =\n-            M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n-        {\n-            return Ok(handled);\n+        match fty {\n+            FloatTy::F32 => float_math!(Single, 4),\n+            FloatTy::F64 => float_math!(Double, 8),\n         }\n+    }\n \n-        // From now on, everything must be bytes, no pointer values\n-        // (this is independent of the type)\n-        let l = left.to_bits(left_layout.size)?;\n-        let r = right.to_bits(right_layout.size)?;\n+    fn binary_int_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        // passing in raw bits\n+        l: u128,\n+        left_layout: TyLayout<'tcx>,\n+        r: u128,\n+        right_layout: TyLayout<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n         if bin_op == Shl || bin_op == Shr {\n@@ -189,11 +178,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // For the remaining ops, the types must be the same on both sides\n         if left_layout.ty != right_layout.ty {\n             let msg = format!(\n-                \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                \"unimplemented asymmetric binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                 bin_op,\n-                left,\n+                l,\n                 left_layout.ty,\n-                right,\n+                r,\n                 right_layout.ty\n             );\n             return err!(Unimplemented(msg));\n@@ -289,11 +278,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             _ => {\n                 let msg = format!(\n-                    \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                    \"unimplemented binary op {:?}: {:?}, {:?} (both {:?})\",\n                     bin_op,\n-                    left,\n-                    left_layout.ty,\n-                    right,\n+                    l,\n+                    r,\n                     right_layout.ty,\n                 );\n                 return err!(Unimplemented(msg));\n@@ -303,6 +291,65 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((val, false))\n     }\n \n+    /// Returns the result of the specified operation and whether it overflowed.\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n+        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        let left = left.to_scalar()?;\n+        let right = right.to_scalar()?;\n+\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+            bin_op, left, left_layout.ty.sty, right, right_layout.ty.sty);\n+\n+        match left_layout.ty.sty {\n+            ty::Char => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let l = left.to_char()?;\n+                let r = right.to_char()?;\n+                self.binary_char_op(bin_op, l, r)\n+            }\n+            ty::Bool => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let l = left.to_bool()?;\n+                let r = right.to_bool()?;\n+                self.binary_bool_op(bin_op, l, r)\n+            }\n+            ty::Float(fty) => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let l = left.to_bits(left_layout.size)?;\n+                let r = right.to_bits(right_layout.size)?;\n+                self.binary_float_op(bin_op, fty, l, r)\n+            }\n+            _ => {\n+                // Must be integer(-like) types\n+                #[inline]\n+                fn is_ptr<'tcx>(ty: ty::Ty<'tcx>) -> bool {\n+                    match ty.sty {\n+                        ty::RawPtr(..) | ty::Ref(..) | ty::FnPtr(..) => true,\n+                        _ => false,\n+                    }\n+                }\n+                assert!(left_layout.ty.is_integral() || is_ptr(left_layout.ty));\n+                assert!(right_layout.ty.is_integral() || is_ptr(right_layout.ty));\n+\n+                // Handle operations that support pointer values\n+                if let Some(handled) =\n+                    M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n+                {\n+                    return Ok(handled);\n+                }\n+\n+                // Everything else only works with \"proper\" bits\n+                let l = left.to_bits(left_layout.size)?;\n+                let r = right.to_bits(right_layout.size)?;\n+                self.binary_int_op(bin_op, l, left_layout, r, right_layout)\n+            }\n+        }\n+    }\n+\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,"}, {"sha": "0411256520203c3a53f738b95c607d7525c4b51b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -660,7 +660,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         // a fake pointer?  Are we even called for ZST?\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n-                        // that might e.g. be a downcast variant!\n+                        // that might e.g. be an inner field of a struct with `Scalar` layout,\n+                        // that has different alignment than the outer field.\n                         let local_layout = self.layout_of_local(frame, local)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n                         self.write_value_to_mplace(value, ptr)?;\n@@ -695,15 +696,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx> {\n         match dest.layout.variants {\n             layout::Variants::Single { index } => {\n-                if index != variant_index {\n-                    return err!(InvalidDiscriminant);\n-                }\n+                assert_eq!(index, variant_index);\n             }\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n-                if variant_index >= adt_def.variants.len() {\n-                    return err!(InvalidDiscriminant);\n-                }\n+                assert!(variant_index < adt_def.variants.len());\n                 let discr_val = adt_def\n                     .discriminant_for_variant(*self.tcx, variant_index)\n                     .val;\n@@ -727,9 +724,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 niche_start,\n                 ..\n             } => {\n-                if variant_index >= dest.layout.ty.ty_adt_def().unwrap().variants.len() {\n-                    return err!(InvalidDiscriminant);\n-                }\n+                assert!(variant_index < dest.layout.ty.ty_adt_def().unwrap().variants.len());\n                 if variant_index != dataful_variant {\n                     let niche_dest =\n                         self.place_field(dest, 0)?;"}, {"sha": "11826e0ce0c25897a31a1d2748905df7cc0a8f9e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n-    /// `sig` is ptional in case of FnPtr/FnDef -- but mandatory for closures!\n+    /// `sig` is optional in case of FnPtr/FnDef -- but mandatory for closures!\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -462,7 +462,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n-        let ty = self.tcx.mk_tup((&[] as &[ty::Ty<'tcx>]).iter()); // return type is ()\n+        let ty = self.tcx.mk_nil(); // return type is ()\n         let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n \n         self.eval_fn_call("}, {"sha": "d50fd6e13c1069b137cf35c4ea443747436ea7c2", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -208,10 +208,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::Variants::Tagged { .. } => {\n                 let variant = match self.read_discriminant(dest) {\n                     Ok(res) => res.1,\n-                    Err(_) =>\n-                        return validation_failure!(\n-                            \"invalid enum discriminant\", path\n-                        ),\n+                    Err(err) => match err.kind {\n+                        EvalErrorKind::InvalidDiscriminant(val) =>\n+                            return validation_failure!(\n+                                format!(\"invalid enum discriminant {}\", val), path\n+                            ),\n+                        _ =>\n+                            return validation_failure!(\n+                                format!(\"non-integer enum discriminant\"), path\n+                            ),\n+                    }\n                 };\n                 let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field"}, {"sha": "70179c86765f3c86a9d27b9fadbabd2c9b28186d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -170,7 +170,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     | DoubleFree\n                     | InvalidFunctionPointer\n                     | InvalidBool\n-                    | InvalidDiscriminant\n+                    | InvalidDiscriminant(..)\n                     | PointerOutOfBounds { .. }\n                     | InvalidNullPointerUsage\n                     | MemoryLockViolation { .. }"}, {"sha": "21025877340eabd482f19268d2a2535b003577bf", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { usize: &BAR }.foo,\n LL | |     Union { usize: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered invalid enum discriminant at .1.<deref>\n+   | |___^ type validation failed: encountered invalid enum discriminant 5 at .1.<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "572d08ddfeebd0958d9db040dc249c98ac783ed2", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=f96208ca5bd34ba5e9106fe6527db43a9bdc3a8f", "patch": "@@ -2,15 +2,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:22:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:35:1\n    |\n LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant 0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}