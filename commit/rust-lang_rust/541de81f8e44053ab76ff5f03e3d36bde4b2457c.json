{"sha": "541de81f8e44053ab76ff5f03e3d36bde4b2457c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MWRlODFmOGU0NDA1M2FiNzZmZjVmMDNlM2QzNmJkZTRiMjQ1N2M=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T21:27:33Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:11:20Z"}, "message": "Create ShallowResolver\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "a3985f3007e35f090c27b5ed91da85639dcab160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3985f3007e35f090c27b5ed91da85639dcab160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/541de81f8e44053ab76ff5f03e3d36bde4b2457c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/541de81f8e44053ab76ff5f03e3d36bde4b2457c", "html_url": "https://github.com/rust-lang/rust/commit/541de81f8e44053ab76ff5f03e3d36bde4b2457c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/541de81f8e44053ab76ff5f03e3d36bde4b2457c/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1369132afae1e9721828370b37de7baca221a6b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1369132afae1e9721828370b37de7baca221a6b6", "html_url": "https://github.com/rust-lang/rust/commit/1369132afae1e9721828370b37de7baca221a6b6"}], "stats": {"total": 236, "additions": 128, "deletions": 108}, "files": [{"sha": "0e9dbcac5cd64c3b1c00f26717f38b41c14f2074", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -684,7 +684,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     /// `ty_var`.\n     fn canonicalize_ty_var(&mut self, info: CanonicalVarInfo, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n         let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n-        let bound_to = infcx.shallow_resolve_type(ty_var);\n+        let bound_to = infcx.shallow_resolve(ty_var);\n         if bound_to != ty_var {\n             self.fold_ty(bound_to)\n         } else {"}, {"sha": "65bc2b3e945cec2f571e8b334281f858307ab0b3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 89, "deletions": 67, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -18,7 +18,7 @@ use crate::mir::interpret::ConstValue;\n use crate::session::config::BorrowckMode;\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use crate::ty::fold::TypeFoldable;\n+use crate::ty::fold::{TypeFolder, TypeFoldable};\n use crate::ty::relate::RelateResult;\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners, InferConst};\n@@ -919,17 +919,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         predicate: &ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve_type` just ignores anything that is not a type\n+        // `shallow_resolve` just ignores anything that is not a type\n         // variable, and because type variable's can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n         // Really, there is no *particular* reason to do this\n-        // `shallow_resolve_type` here except as a\n+        // `shallow_resolve` here except as a\n         // micro-optimization. Naturally I could not\n         // resist. -nmatsakis\n         let two_unbound_type_vars = {\n-            let a = self.shallow_resolve_type(predicate.skip_binder().a);\n-            let b = self.shallow_resolve_type(predicate.skip_binder().b);\n+            let a = self.shallow_resolve(predicate.skip_binder().a);\n+            let b = self.shallow_resolve(predicate.skip_binder().b);\n             a.is_ty_var() && b.is_ty_var()\n         };\n \n@@ -1274,46 +1274,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type_vars_if_possible(t).to_string()\n     }\n \n-    // We have this force-inlined variant of `shallow_resolve_type` for the one\n-    // callsite that is extremely hot. All other callsites use the normal\n-    // variant.\n-    #[inline(always)]\n-    pub fn inlined_shallow_resolve_type(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.sty {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifyxing to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                self.type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.shallow_resolve_type(t))\n-                    .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self.int_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self.float_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n     /// universe index of `TyVar(vid)`.\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n@@ -1325,8 +1285,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve_type(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve_type(typ)\n+    pub fn shallow_resolve<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut r = ShallowResolver::new(self);\n+        value.fold_with(&mut r)\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1391,24 +1355,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve_const(\n-        &self,\n-        ct: &'tcx ty::Const<'tcx>\n-    ) -> &'tcx ty::Const<'tcx> {\n-        match ct {\n-            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n-                self.const_unification_table\n-                    .borrow_mut()\n-                    .probe_value(*vid)\n-                    .val\n-                    .known()\n-                    .map(|c| self.shallow_resolve_const(c))\n-                    .unwrap_or(ct)\n-            }\n-            _ => ct,\n-        }\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n         /*!\n          * Attempts to resolve all type/region/const variables in\n@@ -1528,7 +1474,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n-        let closure_kind_ty = self.shallow_resolve_type(&closure_kind_ty);\n+        let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n@@ -1542,7 +1488,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n-        let closure_sig_ty = self.shallow_resolve_type(&closure_sig_ty);\n+        let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n         closure_sig_ty.fn_sig(self.tcx)\n     }\n \n@@ -1598,6 +1544,82 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub struct ShallowResolver<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n+    #[inline(always)]\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        ShallowResolver { infcx }\n+    }\n+\n+    // We have this force-inlined variant of `shallow_resolve` for the one\n+    // callsite that is extremely hot. All other callsites use the normal\n+    // variant.\n+    #[inline(always)]\n+    pub fn inlined_shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+        match typ.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifyxing to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                self.infcx.type_variables\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .known()\n+                    .map(|t| self.fold_ty(t))\n+                    .unwrap_or(typ)\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self.infcx.int_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            ty::Infer(ty::FloatVar(v)) => self.infcx.float_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.inlined_shallow_resolve(ty)\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct {\n+            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+                self.infcx.const_unification_table\n+                    .borrow_mut()\n+                    .probe_value(*vid)\n+                    .val\n+                    .known()\n+                    .map(|c| self.fold_const(c))\n+                    .unwrap_or(ct)\n+            }\n+            _ => ct,\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.cause.span"}, {"sha": "a3800d8f0754e4a31b7517ebed91fa372ddc0cd3", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -538,10 +538,10 @@ where\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let a = self.infcx.shallow_resolve_type(a);\n+        let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n-            b = self.infcx.shallow_resolve_type(b);\n+            b = self.infcx.shallow_resolve(b);\n         }\n \n         match (&a.sty, &b.sty) {"}, {"sha": "61563a8ba269d23b7e2d708d5ccfd3fa245a6e78", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -8,7 +8,7 @@ use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n /// The opportunistic type resolver can be used at any time. It simply replaces\n /// type variables that have been unified with the things they have\n-/// been unified with (similar to `shallow_resolve_type`, but deep). This is\n+/// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -31,7 +31,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'g\n         if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve_type(t);\n+            let t0 = self.infcx.shallow_resolve(t);\n             t0.super_fold_with(self)\n         }\n     }\n@@ -59,7 +59,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve_type(t);\n+            let t0 = self.infcx.shallow_resolve(t);\n             t0.super_fold_with(self)\n         }\n     }\n@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         if !ct.needs_infer() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n-            let c0 = self.infcx.shallow_resolve_const(ct);\n+            let c0 = self.infcx.shallow_resolve(ct);\n             c0.super_fold_with(self)\n         }\n     }\n@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        let t = self.infcx.shallow_resolve_type(t);\n+        let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n             if let ty::Infer(infer_ty) = t.sty {\n                 // Since we called `shallow_resolve` above, this must\n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n               // ^ we need to have the `keep_local` check to un-default\n               // defaulted tuples.\n         } else {\n-            let t = self.infcx.shallow_resolve_type(t);\n+            let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n               // ^ we need to have the `keep_local` check to un-default\n               // defaulted tuples.\n         } else {\n-            let c = self.infcx.shallow_resolve_const(c);\n+            let c = self.infcx.shallow_resolve(c);\n             match c.val {\n                 ConstValue::Infer(InferConst::Var(vid)) => {\n                     self.err = Some(FixupError::UnresolvedConst(vid));"}, {"sha": "96212d829d44884cec1c4aef2d47e4b3093ecf43", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::InferCtxt;\n+use crate::infer::{InferCtxt, ShallowResolver};\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n use crate::ty::error::ExpectedFound;\n@@ -255,9 +255,9 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         // doing more work yet\n         if !pending_obligation.stalled_on.is_empty() {\n             if pending_obligation.stalled_on.iter().all(|&ty| {\n-                // Use the force-inlined variant of shallow_resolve_type() because this code is hot.\n-                let resolved_ty = self.selcx.infcx().inlined_shallow_resolve_type(&ty);\n-                resolved_ty == ty // nothing changed here\n+                // Use the force-inlined variant of shallow_resolve() because this code is hot.\n+                let resolved = ShallowResolver::new(self.selcx.infcx()).inlined_shallow_resolve(ty);\n+                resolved == ty // nothing changed here\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()"}, {"sha": "dabb8a728901cf554326d2be6d70b9d809c524c8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -1229,7 +1229,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve_type(self_ty);\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n@@ -1346,7 +1346,7 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let fn_type = selcx.infcx().shallow_resolve_type(fn_pointer_vtable.fn_ty);\n+    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized {\n         value: sig,\n@@ -1371,7 +1371,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n-    let closure_sig = infcx.shallow_resolve_type(&closure_sig_ty).fn_sig(tcx);\n+    let closure_sig = infcx.shallow_resolve(closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n         value: closure_sig,\n         obligations"}, {"sha": "f0c402789c4cd192428a241e4493672c4ce08715", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -2403,7 +2403,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx\n-            .shallow_resolve_type(obligation.predicate.skip_binder().self_ty());\n+            .shallow_resolve(obligation.predicate.skip_binder().self_ty());\n \n         match self_ty.sty {\n             ty::Infer(ty::IntVar(_))\n@@ -2467,7 +2467,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> BuiltinImplConditions<'tcx> {\n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx\n-            .shallow_resolve_type(obligation.predicate.skip_binder().self_ty());\n+            .shallow_resolve(obligation.predicate.skip_binder().self_ty());\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n@@ -2866,7 +2866,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         );\n \n         let types = obligation.predicate.map_bound(|inner| {\n-            let self_ty = self.infcx.shallow_resolve_type(inner.self_ty());\n+            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n             self.constituent_types_for_ty(self_ty)\n         });\n         self.vtable_auto_impl(obligation, trait_def_id, types)\n@@ -2990,7 +2990,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // from the object. Have to try to make a broken test case that\n         // results.\n         let self_ty = self.infcx\n-            .shallow_resolve_type(*obligation.self_ty().skip_binder());\n+            .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::Dynamic(ref data, ..) =>\n                 data.principal().unwrap_or_else(|| {\n@@ -3045,7 +3045,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // OK to skip binder; it is reintroduced below\n         let self_ty = self.infcx\n-            .shallow_resolve_type(*obligation.self_ty().skip_binder());\n+            .shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref = self.tcx()\n             .closure_trait_ref_and_return_type(\n@@ -3124,8 +3124,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx\n-            .shallow_resolve_type(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -3182,8 +3181,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx\n-            .shallow_resolve_type(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -3278,14 +3276,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx\n-            .shallow_resolve_type(obligation.self_ty().no_bound_vars().unwrap());\n+            .shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n         let target = obligation\n             .predicate\n             .skip_binder()\n             .trait_ref\n             .substs\n             .type_at(1);\n-        let target = self.infcx.shallow_resolve_type(target);\n+        let target = self.infcx.shallow_resolve(target);\n \n         debug!(\n             \"confirm_builtin_unsize_candidate(source={:?}, target={:?})\","}, {"sha": "c474baac3d1293d98b5b9a31b8c6d87896b2d710", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -406,7 +406,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 //    moving. (Goal is that an \"inductive hypothesis\"\n                 //    is satisfied to ensure termination.)\n                 ty::Infer(_) => {\n-                    let ty = self.infcx.shallow_resolve_type(ty);\n+                    let ty = self.infcx.shallow_resolve(ty);\n                     if let ty::Infer(_) = ty.sty { // not yet resolved...\n                         if ty == ty0 { // ...this is the type we started from! no progress.\n                             return false;"}, {"sha": "9d234e93b837bc797aed624171a3dc41006503f5", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -204,7 +204,7 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let b = self.infcx.shallow_resolve_type(b);\n+        let b = self.infcx.shallow_resolve(b);\n         debug!(\"AnswerSubstitutor::tys(a = {:?}, b = {:?})\", a, b);\n \n         if let &ty::Bound(debruijn, bound_ty) = &a.sty {"}, {"sha": "8cdfbf5f55ca050ace9ca29c7f9089ddc97e68f4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve_type(expected);\n+                let expected = self.shallow_resolve(expected);\n                 if self.check_dereferencable(pat.span, expected, &inner) {\n                     // `demand::subtype` would be good enough, but using\n                     // `eqtype` turns out to be equally general. See (*)\n@@ -519,7 +519,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve_type(expected).builtin_deref(true) {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error."}, {"sha": "85eb0f9d499669fd27424fd81ccb24cd6352d736", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -154,7 +154,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     }\n \n     fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        let a = self.shallow_resolve_type(a);\n+        let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n@@ -170,8 +170,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            let b = self.shallow_resolve_type(b);\n-            return if self.shallow_resolve_type(b).is_ty_var() {\n+            let b = self.shallow_resolve(b);\n+            return if self.shallow_resolve(b).is_ty_var() {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n@@ -659,7 +659,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! into a closure or a `proc`.\n         //!\n \n-        let b = self.shallow_resolve_type(b);\n+        let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n         self.coerce_from_safe_fn(a, fn_ty_a, b,\n@@ -673,7 +673,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n         //! into a closure or a `proc`.\n \n-        let b = self.shallow_resolve_type(b);\n+        let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n@@ -719,7 +719,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! into a function pointer.\n         //!\n \n-        let b = self.shallow_resolve_type(b);\n+        let b = self.shallow_resolve(b);\n \n         let hir_id_a = self.tcx.hir().as_local_hir_id(def_id_a).unwrap();\n         match b.sty {\n@@ -1128,7 +1128,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         // compatibility (hopefully that is true) by helping us\n         // uncover never types better.\n         if expression_ty.is_ty_var() {\n-            expression_ty = fcx.infcx.shallow_resolve_type(expression_ty);\n+            expression_ty = fcx.infcx.shallow_resolve(expression_ty);\n         }\n \n         // If we see any error types, just propagate that error"}, {"sha": "d2d486b52b3f86bc950290d08a77204084f89872", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541de81f8e44053ab76ff5f03e3d36bde4b2457c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=541de81f8e44053ab76ff5f03e3d36bde4b2457c", "patch": "@@ -281,7 +281,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n-                let ety = fcx.shallow_resolve_type(ety);\n+                let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() {\n                     ExpectHasType(ety)\n                 } else {\n@@ -2792,7 +2792,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         expected_vid: ty::TyVid,\n     ) -> bool {\n-        let self_ty = self.shallow_resolve_type(trait_ref.self_ty());\n+        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n         debug!(\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n             trait_ref, self_ty, expected_vid"}]}