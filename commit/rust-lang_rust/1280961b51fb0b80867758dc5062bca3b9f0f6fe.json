{"sha": "1280961b51fb0b80867758dc5062bca3b9f0f6fe", "node_id": "C_kwDOAAsO6NoAKDEyODA5NjFiNTFmYjBiODA4Njc3NThkYzUwNjJiY2EzYjlmMGY2ZmU", "commit": {"author": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2021-11-21T13:15:21Z"}, "committer": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2021-12-19T19:10:01Z"}, "message": "internal: sync match checking with rust-lang/rust f31622a50 2021-11-12", "tree": {"sha": "6634512f856925cec14985027e63c6ba4497f25b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6634512f856925cec14985027e63c6ba4497f25b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1280961b51fb0b80867758dc5062bca3b9f0f6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1280961b51fb0b80867758dc5062bca3b9f0f6fe", "html_url": "https://github.com/rust-lang/rust/commit/1280961b51fb0b80867758dc5062bca3b9f0f6fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1280961b51fb0b80867758dc5062bca3b9f0f6fe/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deb05930ef3764b03582459d001fa3717d9b63f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/deb05930ef3764b03582459d001fa3717d9b63f7", "html_url": "https://github.com/rust-lang/rust/commit/deb05930ef3764b03582459d001fa3717d9b63f7"}], "stats": {"total": 91, "additions": 57, "deletions": 34}, "files": [{"sha": "00c7b952157acebc1ed2f89fc333315ccd67c3c2", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=1280961b51fb0b80867758dc5062bca3b9f0f6fe", "patch": "@@ -335,7 +335,7 @@ impl ExprValidator {\n         let report = compute_match_usefulness(&cx, &m_arms, match_expr_ty);\n \n         // FIXME Report unreacheble arms\n-        // https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200-L201\n+        // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200\n \n         let witnesses = report.non_exhaustiveness_witnesses;\n         // FIXME Report witnesses"}, {"sha": "acb3280329f5233a1374bcf7f66608ae0c46bc40", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=1280961b51fb0b80867758dc5062bca3b9f0f6fe", "patch": "@@ -332,6 +332,14 @@ impl Constructor {\n         }\n     }\n \n+    pub(super) fn is_unstable_variant(&self, _pcx: PatCtxt<'_, '_>) -> bool {\n+        false //FIXME: implement this\n+    }\n+\n+    pub(super) fn is_doc_hidden_variant(&self, _pcx: PatCtxt<'_, '_>) -> bool {\n+        false //FIXME: implement this\n+    }\n+\n     fn variant_id_for_adt(&self, adt: hir_def::AdtId) -> VariantId {\n         match *self {\n             Variant(id) => id.into(),\n@@ -556,32 +564,33 @@ impl SplitWildcard {\n                 // witness.\n                 let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n \n+                let is_exhaustive_pat_feature = cx.feature_exhaustive_patterns();\n+\n                 // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n                 // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n                 // exception is if the pattern is at the top level, because we want empty matches to be\n                 // considered exhaustive.\n                 let is_secretly_empty = enum_data.variants.is_empty()\n-                    && !cx.feature_exhaustive_patterns()\n+                    && !is_exhaustive_pat_feature\n                     && !pcx.is_top_level;\n \n-                if is_secretly_empty {\n-                    smallvec![NonExhaustive]\n-                } else if is_declared_nonexhaustive {\n-                    enum_data\n-                        .variants\n-                        .iter()\n-                        .map(|(local_id, ..)| Variant(EnumVariantId { parent: enum_id, local_id }))\n-                        .chain(Some(NonExhaustive))\n-                        .collect()\n-                } else if cx.feature_exhaustive_patterns() {\n-                    unimplemented!() // see MatchCheckCtx.feature_exhaustive_patterns()\n-                } else {\n-                    enum_data\n-                        .variants\n-                        .iter()\n-                        .map(|(local_id, ..)| Variant(EnumVariantId { parent: enum_id, local_id }))\n-                        .collect()\n+                let mut ctors: SmallVec<[_; 1]> = enum_data\n+                    .variants\n+                    .iter()\n+                    .filter(|&(_, _v)| {\n+                        // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                        // uninhabited.\n+                        let is_uninhabited = is_exhaustive_pat_feature\n+                            && unimplemented!(\"after MatchCheckCtx.feature_exhaustive_patterns()\");\n+                        !is_uninhabited\n+                    })\n+                    .map(|(local_id, _)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                    .collect();\n+\n+                if is_secretly_empty || is_declared_nonexhaustive {\n+                    ctors.push(NonExhaustive);\n                 }\n+                ctors\n             }\n             TyKind::Scalar(Scalar::Char) => unhandled(),\n             TyKind::Scalar(Scalar::Int(..) | Scalar::Uint(..)) => unhandled(),\n@@ -661,9 +670,7 @@ impl SplitWildcard {\n                     Missing {\n                         nonexhaustive_enum_missing_real_variants: self\n                             .iter_missing(pcx)\n-                            .filter(|c| !c.is_non_exhaustive())\n-                            .next()\n-                            .is_some(),\n+                            .any(|c| !(c.is_non_exhaustive() || c.is_unstable_variant(pcx))),\n                     }\n                 } else {\n                     Missing { nonexhaustive_enum_missing_real_variants: false }\n@@ -820,9 +827,9 @@ impl<'p> Fields<'p> {\n \n /// Values and patterns can be represented as a constructor applied to some fields. This represents\n /// a pattern in this form.\n-/// This also keeps track of whether the pattern has been foundreachable during analysis. For this\n+/// This also keeps track of whether the pattern has been found reachable during analysis. For this\n /// reason we should be careful not to clone patterns for which we care about that. Use\n-/// `clone_and_forget_reachability` is you're sure.\n+/// `clone_and_forget_reachability` if you're sure.\n pub(crate) struct DeconstructedPat<'p> {\n     ctor: Constructor,\n     fields: Fields<'p>,"}, {"sha": "9b00c4dccf303f07bf1d03049e0b76b25145e94b", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1280961b51fb0b80867758dc5062bca3b9f0f6fe/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=1280961b51fb0b80867758dc5062bca3b9f0f6fe", "patch": "@@ -1,5 +1,5 @@\n-//! Based on rust-lang/rust (last sync 68b76a483 2021-10-01)\n-//! <https://github.com/rust-lang/rust/blob/68b76a483/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs>\n+//! Based on rust-lang/rust (last sync f31622a50 2021-11-12)\n+//! <https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs>\n //!\n //! -----\n //!\n@@ -402,9 +402,7 @@ impl<'p> Matrix<'p> {\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p>) {\n         if !row.is_empty() && row.head().is_or_pat() {\n-            for row in row.expand_or_pat() {\n-                self.patterns.push(row);\n-            }\n+            self.patterns.extend(row.expand_or_pat());\n         } else {\n             self.patterns.push(row);\n         }\n@@ -500,15 +498,33 @@ impl<'p> Usefulness<'p> {\n                     } else {\n                         let mut split_wildcard = SplitWildcard::new(pcx);\n                         split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n+\n+                        // This lets us know if we skipped any variants because they are marked\n+                        // `doc(hidden)` or they are unstable feature gate (only stdlib types).\n+                        let mut hide_variant_show_wild = false;\n                         // Construct for each missing constructor a \"wild\" version of this\n                         // constructor, that matches everything that can be built with\n                         // it. For example, if `ctor` is a `Constructor::Variant` for\n                         // `Option::Some`, we get the pattern `Some(_)`.\n-                        split_wildcard\n+                        let mut new: Vec<DeconstructedPat<'_>> = split_wildcard\n                             .iter_missing(pcx)\n-                            .cloned()\n-                            .map(|missing_ctor| DeconstructedPat::wild_from_ctor(pcx, missing_ctor))\n-                            .collect()\n+                            .filter_map(|missing_ctor| {\n+                                // Check if this variant is marked `doc(hidden)`\n+                                if missing_ctor.is_doc_hidden_variant(pcx)\n+                                    || missing_ctor.is_unstable_variant(pcx)\n+                                {\n+                                    hide_variant_show_wild = true;\n+                                    return None;\n+                                }\n+                                Some(DeconstructedPat::wild_from_ctor(pcx, missing_ctor.clone()))\n+                            })\n+                            .collect();\n+\n+                        if hide_variant_show_wild {\n+                            new.push(DeconstructedPat::wildcard(pcx.ty.clone()))\n+                        }\n+\n+                        new\n                     };\n \n                     witnesses\n@@ -660,7 +676,7 @@ fn is_useful<'p>(\n         return ret;\n     }\n \n-    assert!(rows.iter().all(|r| r.len() == v.len()));\n+    debug_assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     let ty = v.head().ty();\n     let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);"}]}