{"sha": "dedbb4edd1c3056208d1892c7c4045240d96b15a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZGJiNGVkZDFjMzA1NjIwOGQxODkyYzdjNDA0NTI0MGQ5NmIxNWE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-30T23:18:38Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2017-11-30T23:18:38Z"}, "message": "Immutable unique closure upvars cannot be mutated.", "tree": {"sha": "9b172cf264fb429a380787915ba5ece3369406b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b172cf264fb429a380787915ba5ece3369406b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dedbb4edd1c3056208d1892c7c4045240d96b15a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCgAGBQJaIJHOAAoJEAF2C0+fU/FUVxcP/i/2o+/61HFkqWr4bv54anZL\n9w/Pwp8tQ8UdDbQrFSQ63II8pu3HUx6Fqp8x86Zapggok8TPSR5DWbAGTZs4UyM8\n5tXwt3wHbqDSNNufI9wDACL6oz6OLVvhcE+uwYogaYhhjZkpXguhFaSy6ErHj8eJ\nuxzwIP7BFJvAx+GYBQNR5C6A4XxI1Nxer7aVLQC7AQuSh5SflrN3HajRk0jYJ54K\nhxV/2opytIL1sLm0mqxLu2q85G7oWBVzF20xeu/tcAnpzJ5W1c5Cv1/NqrriEF2C\nkEcut6CORRzsmKc74SbwU3ijvfrOY1c8FQUGVDf0I874Z+C5ubmYNfIUiWHdNwpb\nieQLZ/IQku3xu2R4yd0wVa0aURWWkUUdwwokRW0y0926Oh/ylieaaU3zJO9XDfz2\ntxVac62FPQRq+GDJuatjJzOaiFVlhzlWhmsYyoCbF/RdoeLWwZxF3bISmUBHTP4l\nAj9z2U1CL1B3MtJmh01xKAIw9ZnJGuRb80JzSnTNxgdzjMFKHsS8PX8xsE6TCAYi\nilptT0yXhaLHkkwsYRYhdgUBaYZH9uiZL4cIUqsVd5eWZ043uP2YHBCndjBiinym\ntWNn8Q9gMqBUarYy0Retx6tNUoAe8nkalsYZSAuKfkbQDVruKvLZvwEZEelWvGbv\nuyfPqgoB8PZm6A48o+aE\n=5gju\n-----END PGP SIGNATURE-----", "payload": "tree 9b172cf264fb429a380787915ba5ece3369406b1\nparent c3459b0c9c11125ed6918144f9fedc852a37c3c5\nauthor David Wood <david@davidtw.co> 1512083918 +0000\ncommitter David Wood <david@davidtw.co> 1512083918 +0000\n\nImmutable unique closure upvars cannot be mutated.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dedbb4edd1c3056208d1892c7c4045240d96b15a", "html_url": "https://github.com/rust-lang/rust/commit/dedbb4edd1c3056208d1892c7c4045240d96b15a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dedbb4edd1c3056208d1892c7c4045240d96b15a/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3459b0c9c11125ed6918144f9fedc852a37c3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3459b0c9c11125ed6918144f9fedc852a37c3c5", "html_url": "https://github.com/rust-lang/rust/commit/c3459b0c9c11125ed6918144f9fedc852a37c3c5"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "1c554dde2328a1dae2bf46b62f69f2cb902d484e", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=dedbb4edd1c3056208d1892c7c4045240d96b15a", "patch": "@@ -31,7 +31,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     lexical_scope,\n     is_user_variable\n });\n-impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref, mutability });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });"}, {"sha": "3e59de33563bee100b5fd6f036cd7a08e9cc62f4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dedbb4edd1c3056208d1892c7c4045240d96b15a", "patch": "@@ -554,7 +554,9 @@ pub struct UpvarDecl {\n     pub debug_name: Name,\n \n     /// If true, the capture is behind a reference.\n-    pub by_ref: bool\n+    pub by_ref: bool,\n+\n+    pub mutability: Mutability,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "642df2e179f603360c8e3884098485346919c397", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=dedbb4edd1c3056208d1892c7c4045240d96b15a", "patch": "@@ -761,47 +761,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n-        let mut l = lvalue;\n-        loop {\n-            match *l {\n-                Lvalue::Projection(ref proj) => {\n-                    l = &proj.base;\n-                    continue;\n-                }\n-                Lvalue::Local(local) => {\n-                    match self.mir.local_decls[local].mutability {\n-                        Mutability::Not => break, // needs check\n-                        Mutability::Mut => return,\n-                    }\n-                }\n-                Lvalue::Static(ref static_) => {\n-                    // mutation of non-mut static is always illegal,\n-                    // independent of dataflow. However it will be catched by\n-                    // `check_access_permissions()`, we call delay_span_bug here\n-                    // to be sure that no case has been missed\n-                    if !self.tcx.is_static_mut(static_.def_id) {\n-                        let item_msg = match self.describe_lvalue(lvalue) {\n-                            Some(name) => format!(\"immutable static item `{}`\", name),\n-                            None => \"immutable static item\".to_owned()\n-                        };\n-                        self.tcx.sess.delay_span_bug(span,\n-                            &format!(\"cannot assign to {}, should have been caught by \\\n-                            `check_access_permissions()`\", item_msg));\n-                    }\n-                    return;\n-                }\n-            }\n+        if let Ok(()) = self.is_mutable(lvalue, LocalMutationIsAllowed::No) {\n+            return;\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n-            for ii in &move_data.init_path_map[mpi] {\n-                if flow_state.ever_inits.curr_state.contains(ii) {\n-                    let first_assign_span = self.move_data.inits[*ii].span;\n-                    self.report_illegal_reassignment(\n-                        context, (lvalue, span), first_assign_span);\n-                    break;\n+        if let Err(_) = self.is_mutable(lvalue, LocalMutationIsAllowed::Yes) {\n+            return;\n+        }\n+\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                for ii in &move_data.init_path_map[mpi] {\n+                    if flow_state.ever_inits.curr_state.contains(ii) {\n+                        let first_assign_span = self.move_data.inits[*ii].span;\n+                        self.report_illegal_reassignment(\n+                            context, (lvalue, span), first_assign_span);\n+                        break;\n+                    }\n                 }\n-            }\n+            },\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                let item_msg = match self.describe_lvalue(lvalue) {\n+                    Some(name) => format!(\"immutable static item `{}`\", name),\n+                    None => \"immutable static item\".to_owned()\n+                };\n+                self.tcx.sess.delay_span_bug(span,\n+                    &format!(\"cannot assign to {}, should have been caught by \\\n+                    `check_access_permissions()`\", item_msg));\n+            },\n         }\n     }\n \n@@ -1108,20 +1095,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Deref => {\n                         let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n-                        // `Box<T>` owns its content, so mutable if its location is mutable\n-                        if base_ty.is_box() {\n-                            return self.is_mutable(&proj.base, LocalMutationIsAllowed::No);\n-                        }\n-\n-                        // Otherwise we check the kind of deref to decide\n+                        // Check the kind of deref to decide\n                         match base_ty.sty {\n                             ty::TyRef(_, tnm) => {\n                                 match tnm.mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(lvalue),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                    hir::MutMutable => {\n+                                        if self.is_upvar_field_projection(&proj.base).is_some() {\n+                                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                        } else {\n+                                            self.is_unique(&proj.base)\n+                                        }\n+                                    },\n                                 }\n                             },\n                             ty::TyRawPtr(tnm) => {\n@@ -1133,8 +1121,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     hir::MutMutable => Ok(()),\n                                 }\n                             },\n+                            // `Box<T>` owns its content, so mutable if its location is mutable\n+                            _ if base_ty.is_box() =>\n+                                self.is_mutable(&proj.base, LocalMutationIsAllowed::No),\n                             // Deref should only be for reference, pointers or boxes\n-                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n                         }\n                     },\n                     // All other projections are owned by their base path, so mutable if\n@@ -1143,8 +1134,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Index(..) |\n                     ProjectionElem::ConstantIndex{..} |\n                     ProjectionElem::Subslice{..} |\n-                    ProjectionElem::Downcast(..) =>\n+                    ProjectionElem::Downcast(..) => {\n+                        let field_projection = self.is_upvar_field_projection(lvalue);\n+\n+                        if let Some(field) = field_projection {\n+                            let decl = &self.mir.upvar_decls[field.index()];\n+\n+                            return match decl.mutability {\n+                                Mutability::Mut => self.is_unique(&proj.base),\n+                                Mutability::Not => Err(lvalue),\n+                            };\n+                        }\n+\n                         self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                    }\n                 }\n             }\n         }"}, {"sha": "d8011e151d8e380834b4f4ae39ff9f4d751e9721", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedbb4edd1c3056208d1892c7c4045240d96b15a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=dedbb4edd1c3056208d1892c7c4045240d96b15a", "patch": "@@ -443,10 +443,20 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n                 by_ref,\n+                mutability: Mutability::Not,\n             };\n             if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n+\n+                    let bm = *hir.tables.pat_binding_modes()\n+                                        .get(pat.hir_id)\n+                                        .expect(\"missing binding mode\");\n+                    if bm == ty::BindByValue(hir::MutMutable) {\n+                        decl.mutability = Mutability::Mut;\n+                    } else {\n+                        decl.mutability = Mutability::Not;\n+                    }\n                 }\n             }\n             decl"}]}