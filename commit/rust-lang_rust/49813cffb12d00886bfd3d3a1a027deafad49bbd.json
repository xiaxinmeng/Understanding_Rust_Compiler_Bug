{"sha": "49813cffb12d00886bfd3d3a1a027deafad49bbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ODEzY2ZmYjEyZDAwODg2YmZkM2QzYTFhMDI3ZGVhZmFkNDliYmQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-21T15:46:11Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T09:11:37Z"}, "message": "Use a slightly nicer hack to get zero-length strings in trans_build\n\nWrapping calls in str::by_ref(, ...) heap-allocated an empty string\nevery time (and looked really bad).", "tree": {"sha": "31a6ba968c468c926fc0beb5f85853538e6b4653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a6ba968c468c926fc0beb5f85853538e6b4653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49813cffb12d00886bfd3d3a1a027deafad49bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49813cffb12d00886bfd3d3a1a027deafad49bbd", "html_url": "https://github.com/rust-lang/rust/commit/49813cffb12d00886bfd3d3a1a027deafad49bbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49813cffb12d00886bfd3d3a1a027deafad49bbd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "420484579dee03d9b306a45a2fd005d3305206b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/420484579dee03d9b306a45a2fd005d3305206b1", "html_url": "https://github.com/rust-lang/rust/commit/420484579dee03d9b306a45a2fd005d3305206b1"}], "stats": {"total": 273, "additions": 97, "deletions": 176}, "files": [{"sha": "86348f8d5acdd6505e76392b48dd28164605c54b", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 97, "deletions": 176, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/49813cffb12d00886bfd3d3a1a027deafad49bbd/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49813cffb12d00886bfd3d3a1a027deafad49bbd/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=49813cffb12d00886bfd3d3a1a027deafad49bbd", "patch": "@@ -76,26 +76,29 @@ fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n     llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n+// This is a really awful way to get a zero-length c-string, but better (and a\n+// lot more efficient) than doing str::as_buf(\"\", ...) every time.\n+fn noname() -> sbuf {\n+    const cnull: uint = 0u;\n+    ret std::unsafe::reinterpret_cast(std::ptr::addr_of(cnull));\n+}\n+\n fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch, buf)\n-    });\n+    llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                          vec::len(Args), Then, Catch, noname());\n }\n \n fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let v = str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch, buf)\n-    });\n+    let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                                  vec::len(Args), Then, Catch, noname());\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n }\n \n@@ -112,182 +115,178 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSub(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMul(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildURem(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildShl(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildOr(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildXor(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf) });\n+    ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNeg(B(cx), V, buf) });\n+    ret llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWNeg(B(cx), V, buf) });\n+    ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWNeg(B(cx), V, buf) });\n+    ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFNeg(B(cx), V, buf) });\n+    ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNot(B(cx), V, buf) });\n+    ret llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMalloc(B(cx), Ty, buf) });\n+    ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf) });\n+    ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAlloca(B(cx), Ty, buf) });\n+    ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf) });\n+    ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n@@ -302,7 +301,7 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { T_int() };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLoad(B(cx), PointerVal, buf) });\n+    ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n@@ -312,197 +311,150 @@ fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n \n fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    ret str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildGEP(B(cx), Pointer,\n-                           vec::to_ptr(Indices),\n-                           vec::len(Indices), buf)\n-    });\n+    ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n+                           vec::len(Indices), noname());\n }\n \n fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    ret str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                                   vec::len(Indices), buf)\n-    });\n+    ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n+                                   vec::len(Indices), noname());\n }\n \n fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n-                    });\n+    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n }\n \n fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildGlobalString(B(cx), _Str, buf) });\n+    ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n-                    });\n+    ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n-                    });\n+    ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf) });\n+    ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n \n /* Comparisons */\n fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf) });\n+    ret llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf) });\n+    ret llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n }\n \n \n /* Miscellaneous instructions */\n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n    -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    let phi = str::as_buf(\"\", {|buf| llvm::LLVMBuildPhi(B(cx), Ty, buf) });\n+    let phi = llvm::LLVMBuildPhi(B(cx), Ty, noname());\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n@@ -525,108 +477,80 @@ fn _UndefReturn(Fn: ValueRef) -> ValueRef {\n \n fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(Fn); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                            vec::len(Args), buf)\n-                    });\n+    ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                            vec::len(Args), noname());\n }\n \n fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(Fn); }\n-    let v =\n-        str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                            vec::len(Args), buf)\n-                    });\n+    let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                vec::len(Args), noname());\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n     ret v;\n }\n \n fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n    -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(Fn); }\n-    let v =\n-        str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                            vec::len(Args), buf)\n-                    });\n+    let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                vec::len(Args), noname());\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n     ret v;\n }\n \n fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(Then); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n-                    });\n+    ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildVAArg(B(cx), list, Ty, buf) });\n+    ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildExtractElement(B(cx), VecVal, Index,\n-                                                      buf)\n-                    });\n+    ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { ret; }\n-    str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, buf)\n-    });\n+    llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { ret; }\n-    str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n-    });\n+    llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    ret str::as_buf(\"\",\n-                    {|buf|\n-                        llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n-                    });\n+    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n }\n \n fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n-    str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, buf)\n-    });\n+    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, noname());\n }\n \n fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNull(B(cx), Val, buf) });\n+    ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNotNull(B(cx), Val, buf) });\n+    ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_int()); }\n-    ret str::as_buf(\"\",\n-                    {|buf| llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf) });\n+    ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n fn Trap(cx: @block_ctxt) {\n@@ -635,21 +559,18 @@ fn Trap(cx: @block_ctxt) {\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef =\n-        str::as_buf(\"llvm.trap\", {|buf| llvm::LLVMGetNamedFunction(M, buf) });\n+    let T: ValueRef = str::as_buf(\"llvm.trap\", {|buf|\n+        llvm::LLVMGetNamedFunction(M, buf)\n+    });\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), buf)\n-    });\n+    llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), noname());\n }\n \n fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    ret str::as_buf(\"\", {|buf|\n-        llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, buf)\n-    });\n+    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, noname());\n }\n \n fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {"}]}