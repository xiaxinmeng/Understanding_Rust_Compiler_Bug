{"sha": "a90551b711b0a5dcdd7511b14c012462449b69dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDU1MWI3MTFiMGE1ZGNkZDc1MTFiMTRjMDEyNDYyNDQ5YjY5ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-10T01:39:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-10T01:39:42Z"}, "message": "auto merge of #5302 : thestinger/rust/vec, r=nikomatsakis", "tree": {"sha": "ec1ddcdad2f90985425e77bc99c397ecb3a42848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec1ddcdad2f90985425e77bc99c397ecb3a42848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a90551b711b0a5dcdd7511b14c012462449b69dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a90551b711b0a5dcdd7511b14c012462449b69dd", "html_url": "https://github.com/rust-lang/rust/commit/a90551b711b0a5dcdd7511b14c012462449b69dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a90551b711b0a5dcdd7511b14c012462449b69dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a347e9d635dd7546f36a5027fcae539f3150573d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a347e9d635dd7546f36a5027fcae539f3150573d", "html_url": "https://github.com/rust-lang/rust/commit/a347e9d635dd7546f36a5027fcae539f3150573d"}, {"sha": "788de758e39f0ba1281c6244c10ce5701c436c33", "url": "https://api.github.com/repos/rust-lang/rust/commits/788de758e39f0ba1281c6244c10ce5701c436c33", "html_url": "https://github.com/rust-lang/rust/commit/788de758e39f0ba1281c6244c10ce5701c436c33"}], "stats": {"total": 473, "additions": 227, "deletions": 246}, "files": [{"sha": "655db1c83d063d444eb6220d18581b575650392b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 227, "deletions": 246, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/a90551b711b0a5dcdd7511b14c012462449b69dd/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90551b711b0a5dcdd7511b14c012462449b69dd/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a90551b711b0a5dcdd7511b14c012462449b69dd", "patch": "@@ -53,7 +53,7 @@ pub pure fn is_empty<T>(v: &[const T]) -> bool {\n \n /// Returns true if two vectors have the same length\n pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n-    len(xs) == len(ys)\n+    xs.len() == ys.len()\n }\n \n /**\n@@ -136,7 +136,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n             }\n         }\n         raw::set_len(&mut v, n_elts);\n-        return v;\n+        v\n     }\n }\n \n@@ -158,7 +158,7 @@ pub pure fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n-    return vec;\n+    vec\n }\n \n /**\n@@ -257,8 +257,8 @@ pub pure fn last_opt<T>(v: &r/[T]) -> Option<&r/T> {\n /// Return a slice that points into another slice.\n #[inline(always)]\n pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n-    fail_unless!((start <= end));\n-    fail_unless!((end <= len(v)));\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -274,8 +274,8 @@ pub pure fn mut_slice<T>(v: &r/mut [T],\n                          start: uint,\n                          end: uint)\n                       -> &r/mut [T] {\n-    fail_unless!((start <= end));\n-    fail_unless!((end <= len(v)));\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -291,8 +291,8 @@ pub pure fn const_slice<T>(v: &r/[const T],\n                            start: uint,\n                            end: uint)\n                         -> &r/[const T] {\n-    fail_unless!((start <= end));\n-    fail_unless!((end <= len(v)));\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -371,7 +371,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     }\n     result.push(slice(v, 0u, end).to_vec());\n     reverse(result);\n-    return result;\n+    result\n }\n \n /**\n@@ -496,7 +496,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         let vp = ptr::mut_offset(vp, next_ln - 1);\n         *vp <-> work_elt;\n \n-        return work_elt;\n+        work_elt\n     }\n }\n \n@@ -584,7 +584,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n     if index < ln - 1 {\n         v[index] <-> v[ln - 1];\n     }\n-    vec::pop(v)\n+    v.pop()\n }\n \n /// Append an element to a vector\n@@ -650,7 +650,7 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n /// Shorten a vector, dropping excess elements.\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n-        fail_unless!((newlen <= oldlen));\n+        fail_unless!(newlen <= oldlen);\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n@@ -973,7 +973,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n         accum = p(accum, &v[i]);\n         i += 1;\n     }\n-    return accum;\n+    accum\n }\n \n /**\n@@ -1000,7 +1000,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n     for rev_each(v) |elt| {\n         accum = p(elt, accum);\n     }\n-    return accum;\n+    accum\n }\n \n /**\n@@ -1010,7 +1010,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n  */\n pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n-    return false;\n+    false\n }\n \n /**\n@@ -1027,7 +1027,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n         if f(&v0[i], &v1[i]) { return true; };\n         i += 1u;\n     }\n-    return false;\n+    false\n }\n \n /**\n@@ -1037,7 +1037,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n  */\n pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n-    return true;\n+    true\n }\n \n /**\n@@ -1047,7 +1047,7 @@ pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  */\n pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n-    return true;\n+    true\n }\n \n /**\n@@ -1061,20 +1061,20 @@ pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n     if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n     while i < v0_len { if !f(&v0[i], &v1[i]) { return false; }; i += 1u; }\n-    return true;\n+    true\n }\n \n /// Return true if a vector contains an element with the given value\n pub pure fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n-    return false;\n+    false\n }\n \n /// Returns the number of elements that are equal to a given value\n pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n-    return cnt;\n+    cnt\n }\n \n /**\n@@ -1152,7 +1152,7 @@ pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n     fail_unless!(end <= len(v));\n     let mut i = start;\n     while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n-    return None;\n+    None\n }\n \n /// Find the last index containing a matching value\n@@ -1188,7 +1188,7 @@ pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n         if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n         i -= 1u;\n     }\n-    return None;\n+    None\n }\n \n // FIXME: if issue #586 gets implemented, could have a postcondition\n@@ -1207,7 +1207,7 @@ pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n             us.push(u);\n         }\n     }\n-    return (ts, us);\n+    (ts, us)\n }\n \n /**\n@@ -1478,7 +1478,7 @@ pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     fail_unless!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n-        let len = vec::len(xx);\n+        let len = xx.len();\n         if ii+nn <= len {\n             unsafe {\n                 ww.push(slice(xx, ii, ii+nn).to_vec());\n@@ -1551,7 +1551,7 @@ pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n         i += 1;\n     }\n \n-    return true;\n+    true\n }\n \n #[cfg(notest)]\n@@ -1631,7 +1631,7 @@ pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n         i += 1;\n     }\n \n-    return a_len < b_len;\n+    a_len < b_len\n }\n \n pure fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n@@ -2114,21 +2114,21 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn to_ptr<T>(v: &[T]) -> *T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n-        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n+        ::cast::reinterpret_cast(&addr_of(&((**repr).data)))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n-        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n+        ::cast::reinterpret_cast(&addr_of(&((**repr).data)))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n-        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n+        ::cast::reinterpret_cast(&addr_of(&((**repr).data)))\n     }\n \n     /**\n@@ -2165,7 +2165,7 @@ pub mod raw {\n             let mut box2 = None;\n             box2 <-> box;\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n-                                 option::unwrap(box2));\n+                                      box2.unwrap());\n         }\n     }\n \n@@ -2210,14 +2210,13 @@ pub mod raw {\n pub mod bytes {\n     use libc;\n     use uint;\n-    use vec::len;\n     use vec::raw;\n     use vec;\n \n     /// Bytewise string comparison\n     pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n-        let a_len = len(*a);\n-        let b_len = len(*b);\n+        let a_len = a.len();\n+        let b_len = b.len();\n         let n = uint::min(a_len, b_len) as libc::size_t;\n         let r = unsafe {\n             libc::memcmp(raw::to_ptr(*a) as *libc::c_void,\n@@ -2268,46 +2267,28 @@ pub mod bytes {\n \n // ___________________________________________________________________________\n // ITERATION TRAIT METHODS\n-//\n-// This cannot be used with iter-trait.rs because of the region pointer\n-// required in the slice.\n \n impl<A> iter::BaseIter<A> for &self/[A] {\n-    pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n-        // FIXME(#2263)---should be able to call each(self, blk)\n-        for each(*self) |e| {\n-            if (!blk(e)) {\n-                return;\n-            }\n-        }\n-    }\n-    pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n+    #[inline(always)]\n+    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for ~[A] {\n-    pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n-        // FIXME(#2263)---should be able to call each(self, blk)\n-        for each(*self) |e| {\n-            if (!blk(e)) {\n-                return;\n-            }\n-        }\n-    }\n-    pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n+    #[inline(always)]\n+    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for @[A] {\n-    pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n-        // FIXME(#2263)---should be able to call each(self, blk)\n-        for each(*self) |e| {\n-            if (!blk(e)) {\n-                return;\n-            }\n-        }\n-    }\n-    pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n+    #[inline(always)]\n+    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<A> iter::ExtendedIter<A> for &self/[A] {\n@@ -2495,25 +2476,25 @@ mod tests {\n     use vec::*;\n     use cmp::*;\n \n-    fn square(n: uint) -> uint { return n * n; }\n+    fn square(n: uint) -> uint { n * n }\n \n-    fn square_ref(n: &uint) -> uint { return square(*n); }\n+    fn square_ref(n: &uint) -> uint { square(*n) }\n \n-    pure fn is_three(n: &uint) -> bool { return *n == 3u; }\n+    pure fn is_three(n: &uint) -> bool { *n == 3u }\n \n-    pure fn is_odd(n: &uint) -> bool { return *n % 2u == 1u; }\n+    pure fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n \n-    pure fn is_equal(x: &uint, y:&uint) -> bool { return *x == *y; }\n+    pure fn is_equal(x: &uint, y:&uint) -> bool { *x == *y }\n \n     fn square_if_odd_r(n: &uint) -> Option<uint> {\n-        return if *n % 2u == 1u { Some(*n * *n) } else { None };\n+        if *n % 2u == 1u { Some(*n * *n) } else { None }\n     }\n \n     fn square_if_odd_v(n: uint) -> Option<uint> {\n-        return if n % 2u == 1u { Some(n * n) } else { None };\n+        if n % 2u == 1u { Some(n * n) } else { None }\n     }\n \n-    fn add(x: uint, y: &uint) -> uint { return x + *y; }\n+    fn add(x: uint, y: &uint) -> uint { x + *y }\n \n     #[test]\n     fn test_unsafe_ptrs() {\n@@ -2522,65 +2503,65 @@ mod tests {\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n             let b = from_buf(ptr, 3u);\n-            fail_unless!((len(b) == 3u));\n-            fail_unless!((b[0] == 1));\n-            fail_unless!((b[1] == 2));\n-            fail_unless!((b[2] == 3));\n+            fail_unless!(b.len() == 3u);\n+            fail_unless!(b[0] == 1);\n+            fail_unless!(b[1] == 2);\n+            fail_unless!(b[2] == 3);\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n             let d = from_buf(ptr, 5u);\n-            fail_unless!((len(d) == 5u));\n-            fail_unless!((d[0] == 1));\n-            fail_unless!((d[1] == 2));\n-            fail_unless!((d[2] == 3));\n-            fail_unless!((d[3] == 4));\n-            fail_unless!((d[4] == 5));\n+            fail_unless!(d.len() == 5u);\n+            fail_unless!(d[0] == 1);\n+            fail_unless!(d[1] == 2);\n+            fail_unless!(d[2] == 3);\n+            fail_unless!(d[3] == 4);\n+            fail_unless!(d[4] == 5);\n         }\n     }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n         let mut v = from_fn(3u, square);\n-        fail_unless!((len(v) == 3u));\n-        fail_unless!((v[0] == 0u));\n-        fail_unless!((v[1] == 1u));\n-        fail_unless!((v[2] == 4u));\n+        fail_unless!(v.len() == 3u);\n+        fail_unless!(v[0] == 0u);\n+        fail_unless!(v[1] == 1u);\n+        fail_unless!(v[2] == 4u);\n \n         // Test on-heap from_fn.\n         v = from_fn(5u, square);\n-        fail_unless!((len(v) == 5u));\n-        fail_unless!((v[0] == 0u));\n-        fail_unless!((v[1] == 1u));\n-        fail_unless!((v[2] == 4u));\n-        fail_unless!((v[3] == 9u));\n-        fail_unless!((v[4] == 16u));\n+        fail_unless!(v.len() == 5u);\n+        fail_unless!(v[0] == 0u);\n+        fail_unless!(v[1] == 1u);\n+        fail_unless!(v[2] == 4u);\n+        fail_unless!(v[3] == 9u);\n+        fail_unless!(v[4] == 16u);\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n         let mut v = from_elem(2u, 10u);\n-        fail_unless!((len(v) == 2u));\n-        fail_unless!((v[0] == 10u));\n-        fail_unless!((v[1] == 10u));\n+        fail_unless!(v.len() == 2u);\n+        fail_unless!(v[0] == 10u);\n+        fail_unless!(v[1] == 10u);\n \n         // Test on-heap from_elem.\n         v = from_elem(6u, 20u);\n-        fail_unless!((v[0] == 20u));\n-        fail_unless!((v[1] == 20u));\n-        fail_unless!((v[2] == 20u));\n-        fail_unless!((v[3] == 20u));\n-        fail_unless!((v[4] == 20u));\n-        fail_unless!((v[5] == 20u));\n+        fail_unless!(v[0] == 20u);\n+        fail_unless!(v[1] == 20u);\n+        fail_unless!(v[2] == 20u);\n+        fail_unless!(v[3] == 20u);\n+        fail_unless!(v[4] == 20u);\n+        fail_unless!(v[5] == 20u);\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        fail_unless!((is_empty::<int>(~[])));\n-        fail_unless!((!is_empty(~[0])));\n+        fail_unless!(is_empty::<int>(~[]));\n+        fail_unless!(!is_empty(~[0]));\n     }\n \n     #[test]\n@@ -2589,10 +2570,10 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        fail_unless!((sys::size_of::<Z>() == 0));\n-        fail_unless!((len(v0) == 0));\n-        fail_unless!((len(v1) == 1));\n-        fail_unless!((len(v2) == 2));\n+        fail_unless!(sys::size_of::<Z>() == 0);\n+        fail_unless!(v0.len() == 0);\n+        fail_unless!(v1.len() == 1);\n+        fail_unless!(v2.len() == 2);\n     }\n \n     #[test]\n@@ -2714,64 +2695,64 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = slice(vec_fixed, 1u, len(vec_fixed)).to_vec();\n-        fail_unless!((len(v_a) == 3u));\n-        fail_unless!((v_a[0] == 2));\n-        fail_unless!((v_a[1] == 3));\n-        fail_unless!((v_a[2] == 4));\n+        let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_vec();\n+        fail_unless!(v_a.len() == 3u);\n+        fail_unless!(v_a[0] == 2);\n+        fail_unless!(v_a[1] == 3);\n+        fail_unless!(v_a[2] == 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n         let v_b = slice(vec_stack, 1u, 3u).to_vec();\n-        fail_unless!((len(v_b) == 2u));\n-        fail_unless!((v_b[0] == 2));\n-        fail_unless!((v_b[1] == 3));\n+        fail_unless!(v_b.len() == 2u);\n+        fail_unless!(v_b[0] == 2);\n+        fail_unless!(v_b[1] == 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n         let v_c = slice(vec_managed, 0u, 3u).to_vec();\n-        fail_unless!((len(v_c) == 3u));\n-        fail_unless!((v_c[0] == 1));\n-        fail_unless!((v_c[1] == 2));\n-        fail_unless!((v_c[2] == 3));\n+        fail_unless!(v_c.len() == 3u);\n+        fail_unless!(v_c[0] == 1);\n+        fail_unless!(v_c[1] == 2);\n+        fail_unless!(v_c[2] == 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = slice(vec_unique, 1u, 6u).to_vec();\n-        fail_unless!((len(v_d) == 5u));\n-        fail_unless!((v_d[0] == 2));\n-        fail_unless!((v_d[1] == 3));\n-        fail_unless!((v_d[2] == 4));\n-        fail_unless!((v_d[3] == 5));\n-        fail_unless!((v_d[4] == 6));\n+        fail_unless!(v_d.len() == 5u);\n+        fail_unless!(v_d[0] == 2);\n+        fail_unless!(v_d[1] == 3);\n+        fail_unless!(v_d[2] == 4);\n+        fail_unless!(v_d[3] == 5);\n+        fail_unless!(v_d[4] == 6);\n     }\n \n     #[test]\n     fn test_pop() {\n         // Test on-heap pop.\n         let mut v = ~[1, 2, 3, 4, 5];\n         let e = v.pop();\n-        fail_unless!((len(v) == 4u));\n-        fail_unless!((v[0] == 1));\n-        fail_unless!((v[1] == 2));\n-        fail_unless!((v[2] == 3));\n-        fail_unless!((v[3] == 4));\n-        fail_unless!((e == 5));\n+        fail_unless!(v.len() == 4u);\n+        fail_unless!(v[0] == 1);\n+        fail_unless!(v[1] == 2);\n+        fail_unless!(v[2] == 3);\n+        fail_unless!(v[3] == 4);\n+        fail_unless!(e == 5);\n     }\n \n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        fail_unless!((len(v) == 4));\n+        fail_unless!(v.len() == 4);\n         fail_unless!(e == 1);\n-        fail_unless!((v[0] == 5));\n+        fail_unless!(v[0] == 5);\n         e = v.swap_remove(3);\n-        fail_unless!((len(v) == 3));\n+        fail_unless!(v.len() == 3);\n         fail_unless!(e == 4);\n-        fail_unless!((v[0] == 5));\n-        fail_unless!((v[1] == 2));\n-        fail_unless!((v[2] == 3));\n+        fail_unless!(v[0] == 5);\n+        fail_unless!(v[1] == 2);\n+        fail_unless!(v[2] == 3);\n     }\n \n     #[test]\n@@ -2780,83 +2761,83 @@ mod tests {\n         let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n                       ::unstable::exclusive(())];\n         let mut _e = v.swap_remove(0);\n-        fail_unless!((len(v) == 2));\n+        fail_unless!(v.len() == 2);\n         _e = v.swap_remove(1);\n-        fail_unless!((len(v) == 1));\n+        fail_unless!(v.len() == 1);\n         _e = v.swap_remove(0);\n-        fail_unless!((len(v) == 0));\n+        fail_unless!(v.len() == 0);\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n         v.push(1);\n-        fail_unless!((len(v) == 1u));\n-        fail_unless!((v[0] == 1));\n+        fail_unless!(v.len() == 1u);\n+        fail_unless!(v[0] == 1);\n \n         // Test on-heap push().\n         v.push(2);\n-        fail_unless!((len(v) == 2u));\n-        fail_unless!((v[0] == 1));\n-        fail_unless!((v[1] == 2));\n+        fail_unless!(v.len() == 2u);\n+        fail_unless!(v[0] == 1);\n+        fail_unless!(v[1] == 2);\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n         v.grow(2u, &1);\n-        fail_unless!((len(v) == 2u));\n-        fail_unless!((v[0] == 1));\n-        fail_unless!((v[1] == 1));\n+        fail_unless!(v.len() == 2u);\n+        fail_unless!(v[0] == 1);\n+        fail_unless!(v[1] == 1);\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        fail_unless!((len(v) == 5u));\n-        fail_unless!((v[0] == 1));\n-        fail_unless!((v[1] == 1));\n-        fail_unless!((v[2] == 2));\n-        fail_unless!((v[3] == 2));\n-        fail_unless!((v[4] == 2));\n+        fail_unless!(v.len() == 5u);\n+        fail_unless!(v[0] == 1);\n+        fail_unless!(v[1] == 1);\n+        fail_unless!(v[2] == 2);\n+        fail_unless!(v[3] == 2);\n+        fail_unless!(v[4] == 2);\n     }\n \n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n         v.grow_fn(3u, square);\n-        fail_unless!((len(v) == 3u));\n-        fail_unless!((v[0] == 0u));\n-        fail_unless!((v[1] == 1u));\n-        fail_unless!((v[2] == 4u));\n+        fail_unless!(v.len() == 3u);\n+        fail_unless!(v[0] == 0u);\n+        fail_unless!(v[1] == 1u);\n+        fail_unless!(v[2] == 4u);\n     }\n \n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n         v.grow_set(4u, &4, 5);\n-        fail_unless!((len(v) == 5u));\n-        fail_unless!((v[0] == 1));\n-        fail_unless!((v[1] == 2));\n-        fail_unless!((v[2] == 3));\n-        fail_unless!((v[3] == 4));\n-        fail_unless!((v[4] == 5));\n+        fail_unless!(v.len() == 5u);\n+        fail_unless!(v[0] == 1);\n+        fail_unless!(v[1] == 2);\n+        fail_unless!(v[2] == 3);\n+        fail_unless!(v[3] == 4);\n+        fail_unless!(v[4] == 5);\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n         v.truncate(1);\n-        fail_unless!((v.len() == 1));\n-        fail_unless!((*(v[0]) == 6));\n+        fail_unless!(v.len() == 1);\n+        fail_unless!(*(v[0]) == 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut v = ~[@6,@5,@4];\n         v.clear();\n-        fail_unless!((v.len() == 0));\n+        fail_unless!(v.len() == 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n@@ -2865,7 +2846,7 @@ mod tests {\n         fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n-            fail_unless!((v == b));\n+            fail_unless!(v == b);\n         }\n         case(~[], ~[]);\n         case(~[1], ~[1]);\n@@ -2910,95 +2891,95 @@ mod tests {\n         // Test on-stack map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = map(v, square_ref);\n-        fail_unless!((len(w) == 3u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 4u));\n-        fail_unless!((w[2] == 9u));\n+        fail_unless!(w.len() == 3u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 4u);\n+        fail_unless!(w[2] == 9u);\n \n         // Test on-heap map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = map(v, square_ref);\n-        fail_unless!((len(w) == 5u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 4u));\n-        fail_unless!((w[2] == 9u));\n-        fail_unless!((w[3] == 16u));\n-        fail_unless!((w[4] == 25u));\n+        fail_unless!(w.len() == 5u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 4u);\n+        fail_unless!(w[2] == 9u);\n+        fail_unless!(w[3] == 16u);\n+        fail_unless!(w[4] == 25u);\n     }\n \n     #[test]\n     fn test_map2() {\n-        fn times(x: &int, y: &int) -> int { return *x * *y; }\n+        fn times(x: &int, y: &int) -> int { *x * *y }\n         let f = times;\n         let v0 = ~[1, 2, 3, 4, 5];\n         let v1 = ~[5, 4, 3, 2, 1];\n         let u = map2::<int, int, int>(v0, v1, f);\n         let mut i = 0;\n-        while i < 5 { fail_unless!((v0[i] * v1[i] == u[i])); i += 1; }\n+        while i < 5 { fail_unless!(v0[i] * v1[i] == u[i]); i += 1; }\n     }\n \n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_mapped(v, square_if_odd_r);\n-        fail_unless!((len(w) == 2u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 9u));\n+        fail_unless!(w.len() == 2u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_mapped(v, square_if_odd_r);\n-        fail_unless!((len(w) == 3u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 9u));\n-        fail_unless!((w[2] == 25u));\n+        fail_unless!(w.len() == 3u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 9u);\n+        fail_unless!(w[2] == 25u);\n \n         fn halve(i: &int) -> Option<int> {\n             if *i % 2 == 0 {\n-                return option::Some::<int>(*i / 2);\n+                Some::<int>(*i / 2)\n             } else {\n-                return option::None::<int>;\n+                None::<int>\n             }\n         }\n-        fn halve_for_sure(i: &int) -> int { return *i / 2; }\n+        fn halve_for_sure(i: &int) -> int { *i / 2 }\n         let all_even: ~[int] = ~[0, 2, 8, 6];\n         let all_odd1: ~[int] = ~[1, 7, 3];\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         fail_unless!(filter_mapped(all_even, halve) ==\n                      map(all_even, halve_for_sure));\n-        fail_unless!((filter_mapped(all_odd1, halve) == ~[]));\n-        fail_unless!((filter_mapped(all_odd2, halve) == ~[]));\n-        fail_unless!((filter_mapped(mix, halve) == mix_dest));\n+        fail_unless!(filter_mapped(all_odd1, halve) == ~[]);\n+        fail_unless!(filter_mapped(all_odd2, halve) == ~[]);\n+        fail_unless!(filter_mapped(mix, halve) == mix_dest);\n     }\n \n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_map(v, square_if_odd_v);\n-        fail_unless!((len(w) == 2u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 9u));\n+        fail_unless!(w.len() == 2u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_map(v, square_if_odd_v);\n-        fail_unless!((len(w) == 3u));\n-        fail_unless!((w[0] == 1u));\n-        fail_unless!((w[1] == 9u));\n-        fail_unless!((w[2] == 25u));\n+        fail_unless!(w.len() == 3u);\n+        fail_unless!(w[0] == 1u);\n+        fail_unless!(w[1] == 9u);\n+        fail_unless!(w[2] == 25u);\n \n         fn halve(i: int) -> Option<int> {\n             if i % 2 == 0 {\n-                return option::Some::<int>(i / 2);\n+                Some::<int>(i / 2)\n             } else {\n-                return option::None::<int>;\n+                None::<int>\n             }\n         }\n-        fn halve_for_sure(i: &int) -> int { return *i / 2; }\n+        fn halve_for_sure(i: &int) -> int { *i / 2 }\n         let all_even: ~[int] = ~[0, 2, 8, 6];\n         let all_even0: ~[int] = copy all_even;\n         let all_odd1: ~[int] = ~[1, 7, 3];\n@@ -3007,9 +2988,9 @@ mod tests {\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         fail_unless!(filter_map(all_even, halve) ==\n                      map(all_even0, halve_for_sure));\n-        fail_unless!((filter_map(all_odd1, halve) == ~[]));\n-        fail_unless!((filter_map(all_odd2, halve) == ~[]));\n-        fail_unless!((filter_map(mix, halve) == mix_dest));\n+        fail_unless!(filter_map(all_odd1, halve) == ~[]);\n+        fail_unless!(filter_map(all_odd2, halve) == ~[]);\n+        fail_unless!(filter_map(mix, halve) == mix_dest);\n     }\n \n     #[test]\n@@ -3030,12 +3011,12 @@ mod tests {\n         // Test on-stack fold.\n         let mut v = ~[1u, 2u, 3u];\n         let mut sum = foldl(0u, v, add);\n-        fail_unless!((sum == 6u));\n+        fail_unless!(sum == 6u);\n \n         // Test on-heap fold.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         sum = foldl(0u, v, add);\n-        fail_unless!((sum == 15u));\n+        fail_unless!(sum == 15u);\n     }\n \n     #[test]\n@@ -3137,29 +3118,29 @@ mod tests {\n \n     #[test]\n     fn test_any_and_all() {\n-        fail_unless!((any(~[1u, 2u, 3u], is_three)));\n-        fail_unless!((!any(~[0u, 1u, 2u], is_three)));\n-        fail_unless!((any(~[1u, 2u, 3u, 4u, 5u], is_three)));\n-        fail_unless!((!any(~[1u, 2u, 4u, 5u, 6u], is_three)));\n+        fail_unless!(any(~[1u, 2u, 3u], is_three));\n+        fail_unless!(!any(~[0u, 1u, 2u], is_three));\n+        fail_unless!(any(~[1u, 2u, 3u, 4u, 5u], is_three));\n+        fail_unless!(!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n \n-        fail_unless!((all(~[3u, 3u, 3u], is_three)));\n-        fail_unless!((!all(~[3u, 3u, 2u], is_three)));\n-        fail_unless!((all(~[3u, 3u, 3u, 3u, 3u], is_three)));\n-        fail_unless!((!all(~[3u, 3u, 0u, 1u, 2u], is_three)));\n+        fail_unless!(all(~[3u, 3u, 3u], is_three));\n+        fail_unless!(!all(~[3u, 3u, 2u], is_three));\n+        fail_unless!(all(~[3u, 3u, 3u, 3u, 3u], is_three));\n+        fail_unless!(!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n-        fail_unless!((any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n-        fail_unless!((!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n-        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n+        fail_unless!(any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n+        fail_unless!(any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n+        fail_unless!(!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n+        fail_unless!(any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n \n-        fail_unless!((all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n-        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n-        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n-        fail_unless!((!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n+        fail_unless!(all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n+        fail_unless!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n+        fail_unless!(!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n+        fail_unless!(!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n     }\n \n     #[test]\n@@ -3169,15 +3150,15 @@ mod tests {\n \n         let z1 = zip(v1, v2);\n \n-        fail_unless!(((1, 4) == z1[0]));\n-        fail_unless!(((2, 5) == z1[1]));\n-        fail_unless!(((3, 6) == z1[2]));\n+        fail_unless!((1, 4) == z1[0]);\n+        fail_unless!((2, 5) == z1[1]);\n+        fail_unless!((3, 6) == z1[2]);\n \n         let (left, right) = unzip(z1);\n \n-        fail_unless!(((1, 4) == (left[0], right[0])));\n-        fail_unless!(((2, 5) == (left[1], right[1])));\n-        fail_unless!(((3, 6) == (left[2], right[2])));\n+        fail_unless!((1, 4) == (left[0], right[0]));\n+        fail_unless!((2, 5) == (left[1], right[1]));\n+        fail_unless!((3, 6) == (left[2], right[2]));\n     }\n \n     #[test]\n@@ -3193,8 +3174,8 @@ mod tests {\n \n     #[test]\n     fn test_position() {\n-        fn less_than_three(i: &int) -> bool { return *i < 3; }\n-        fn is_eighteen(i: &int) -> bool { return *i == 18; }\n+        fn less_than_three(i: &int) -> bool { *i < 3 }\n+        fn is_eighteen(i: &int) -> bool { *i == 18 }\n \n         fail_unless!(position(~[], less_than_three).is_none());\n \n@@ -3354,29 +3335,29 @@ mod tests {\n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n-        fail_unless!((v[0] == 10));\n-        fail_unless!((v[1] == 20));\n+        fail_unless!(v[0] == 10);\n+        fail_unless!(v[1] == 20);\n         reverse(v);\n-        fail_unless!((v[0] == 20));\n-        fail_unless!((v[1] == 10));\n+        fail_unless!(v[0] == 20);\n+        fail_unless!(v[1] == 10);\n         let v2 = reversed::<int>(~[10, 20]);\n-        fail_unless!((v2[0] == 20));\n-        fail_unless!((v2[1] == 10));\n+        fail_unless!(v2[0] == 20);\n+        fail_unless!(v2[1] == 10);\n         v[0] = 30;\n-        fail_unless!((v2[0] == 20));\n+        fail_unless!(v2[0] == 20);\n         // Make sure they work with 0-length vectors too.\n \n         let v4 = reversed::<int>(~[]);\n-        fail_unless!((v4 == ~[]));\n+        fail_unless!(v4 == ~[]);\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n         let mut v2 = reversed::<int>(~[10, 20]);\n-        fail_unless!((v2[0] == 20));\n-        fail_unless!((v2[1] == 10));\n+        fail_unless!(v2[0] == 20);\n+        fail_unless!(v2[1] == 10);\n     }\n \n     #[test]\n@@ -3548,9 +3529,9 @@ mod tests {\n     fn test_view() {\n         let v = ~[1, 2, 3, 4, 5];\n         let v = v.view(1u, 3u);\n-        fail_unless!((len(v) == 2u));\n-        fail_unless!((v[0] == 2));\n-        fail_unless!((v[1] == 3));\n+        fail_unless!(v.len() == 2u);\n+        fail_unless!(v[0] == 2);\n+        fail_unless!(v[1] == 3);\n     }\n \n "}]}