{"sha": "9239760da89cd8e9a51536beeb0a23762064037d", "node_id": "C_kwDOAAsO6NoAKDkyMzk3NjBkYTg5Y2Q4ZTlhNTE1MzZiZWViMGEyMzc2MjA2NDAzN2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-16T13:10:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-16T13:10:24Z"}, "message": "Auto merge of #105750 - oli-obk:valtrees, r=lcnr\n\nAlways fall back to PartialEq when a constant in a pattern is not recursively structural-eq\n\nRight now we destructure the constant as far as we can, but with this PR we just don't take it apart anymore. This is preparatory work for moving to always using valtrees, as these will just do a single conversion of the constant to a valtree at the start, and if that fails, fall back to `PartialEq`.\n\nThis removes a few cases where we emitted the `unreachable pattern` lint, because we stop looking into the constant deeply enough to detect that a constant is already covered by another pattern.\n\nPrevious work: https://github.com/rust-lang/rust/pull/70743\n\nThis is groundwork towards fixing https://github.com/rust-lang/rust/issues/83085 and https://github.com/rust-lang/rust/issues/105047", "tree": {"sha": "322523d6608b046ba3de89b4e86e786ac64d80c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322523d6608b046ba3de89b4e86e786ac64d80c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9239760da89cd8e9a51536beeb0a23762064037d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9239760da89cd8e9a51536beeb0a23762064037d", "html_url": "https://github.com/rust-lang/rust/commit/9239760da89cd8e9a51536beeb0a23762064037d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9239760da89cd8e9a51536beeb0a23762064037d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a673ad6b5746a6256cb898edb8b888163df1872c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a673ad6b5746a6256cb898edb8b888163df1872c", "html_url": "https://github.com/rust-lang/rust/commit/a673ad6b5746a6256cb898edb8b888163df1872c"}, {"sha": "228225842b0345b037fa1959b99178f68ea26d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/228225842b0345b037fa1959b99178f68ea26d6e", "html_url": "https://github.com/rust-lang/rust/commit/228225842b0345b037fa1959b99178f68ea26d6e"}], "stats": {"total": 231, "additions": 137, "deletions": 94}, "files": [{"sha": "dbdb5b4a9a17980886700b4207c6510bea318351", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -380,18 +380,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n     }\n \n-    /// Compare two `&T` values using `<T as std::compare::PartialEq>::eq`\n+    /// Compare two values using `<T as std::compare::PartialEq>::eq`.\n+    /// If the values are already references, just call it directly, otherwise\n+    /// take a reference to the values first and then call it.\n     fn non_scalar_compare(\n         &mut self,\n         block: BasicBlock,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n         value: ConstantKind<'tcx>,\n-        place: Place<'tcx>,\n+        mut val: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n         let mut expect = self.literal_operand(source_info.span, value);\n-        let mut val = Operand::Copy(place);\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n         // unsizing coercion, as the byte string has the type `&[u8; N]`.\n@@ -421,9 +422,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         block,\n                         source_info,\n                         temp,\n-                        Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), val, ty),\n+                        Rvalue::Cast(\n+                            CastKind::Pointer(PointerCast::Unsize),\n+                            Operand::Copy(val),\n+                            ty,\n+                        ),\n                     );\n-                    val = Operand::Move(temp);\n+                    val = temp;\n                 }\n                 if opt_ref_test_ty.is_some() {\n                     let slice = self.temp(ty, source_info.span);\n@@ -438,12 +443,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let ty::Ref(_, deref_ty, _) = *ty.kind() else {\n-            bug!(\"non_scalar_compare called on non-reference type: {}\", ty);\n-        };\n+        match *ty.kind() {\n+            ty::Ref(_, deref_ty, _) => ty = deref_ty,\n+            _ => {\n+                // non_scalar_compare called on non-reference type\n+                let temp = self.temp(ty, source_info.span);\n+                self.cfg.push_assign(block, source_info, temp, Rvalue::Use(expect));\n+                let ref_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, ty);\n+                let ref_temp = self.temp(ref_ty, source_info.span);\n+\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    ref_temp,\n+                    Rvalue::Ref(self.tcx.lifetimes.re_erased, BorrowKind::Shared, temp),\n+                );\n+                expect = Operand::Move(ref_temp);\n+\n+                let ref_temp = self.temp(ref_ty, source_info.span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    ref_temp,\n+                    Rvalue::Ref(self.tcx.lifetimes.re_erased, BorrowKind::Shared, val),\n+                );\n+                val = ref_temp;\n+            }\n+        }\n \n         let eq_def_id = self.tcx.require_lang_item(LangItem::PartialEq, Some(source_info.span));\n-        let method = trait_method(self.tcx, eq_def_id, sym::eq, [deref_ty, deref_ty]);\n+        let method = trait_method(self.tcx, eq_def_id, sym::eq, [ty, ty]);\n \n         let bool_ty = self.tcx.types.bool;\n         let eq_result = self.temp(bool_ty, source_info.span);\n@@ -463,7 +492,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     literal: method,\n                 })),\n-                args: vec![val, expect],\n+                args: vec![Operand::Copy(val), expect],\n                 destination: eq_result,\n                 target: Some(eq_block),\n                 unwind: UnwindAction::Continue,"}, {"sha": "b243f1dc8d0df504efe383891715820bfe64678e", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -62,21 +62,13 @@ struct ConstToPat<'tcx> {\n     treat_byte_string_as_slice: bool,\n }\n \n-mod fallback_to_const_ref {\n-    #[derive(Debug)]\n-    /// This error type signals that we encountered a non-struct-eq situation behind a reference.\n-    /// We bubble this up in order to get back to the reference destructuring and make that emit\n-    /// a const pattern instead of a deref pattern. This allows us to simply call `PartialEq::eq`\n-    /// on such patterns (since that function takes a reference) and not have to jump through any\n-    /// hoops to get a reference to the value.\n-    pub(super) struct FallbackToConstRef(());\n-\n-    pub(super) fn fallback_to_const_ref(c2p: &super::ConstToPat<'_>) -> FallbackToConstRef {\n-        assert!(c2p.behind_reference.get());\n-        FallbackToConstRef(())\n-    }\n-}\n-use fallback_to_const_ref::{fallback_to_const_ref, FallbackToConstRef};\n+/// This error type signals that we encountered a non-struct-eq situation.\n+/// We bubble this up in order to get back to the reference destructuring and make that emit\n+/// a const pattern instead of a deref pattern. This allows us to simply call `PartialEq::eq`\n+/// on such patterns (since that function takes a reference) and not have to jump through any\n+/// hoops to get a reference to the value.\n+#[derive(Debug)]\n+struct FallbackToConstRef;\n \n impl<'tcx> ConstToPat<'tcx> {\n     fn new(\n@@ -236,13 +228,13 @@ impl<'tcx> ConstToPat<'tcx> {\n \n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n-                    tcx.emit_spanned_lint(\n-                        lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                        id,\n-                        span,\n-                        FloatPattern,\n-                    );\n-                PatKind::Constant { value: cv }\n+                tcx.emit_spanned_lint(\n+                    lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    FloatPattern,\n+                );\n+                return Err(FallbackToConstRef);\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n@@ -289,7 +281,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n                 // constant at reference type, making it easy to let the fallback call\n                 // `PartialEq::eq` on it.\n-                return Err(fallback_to_const_ref(self));\n+                return Err(FallbackToConstRef);\n             }\n             ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty()) => {\n                 debug!(\n@@ -393,11 +385,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                     self.behind_reference.set(old);\n                     val\n                 }\n-                // Backwards compatibility hack: support references to non-structural types.\n-                // We'll lower\n-                // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n-                // reference. This makes the rest of the matching logic simpler as it doesn't have\n-                // to figure out how to get a reference again.\n+                // Backwards compatibility hack: support references to non-structural types,\n+                // but hard error if we aren't behind a double reference. We could just use\n+                // the fallback code path below, but that would allow *more* of this fishy\n+                // code to compile, as then it only goes through the future incompat lint\n+                // instead of a hard error.\n                 ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if !self.saw_const_match_error.get()\n@@ -411,7 +403,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                                 IndirectStructuralMatch { non_sm_ty: *pointee_ty },\n                             );\n                         }\n-                        PatKind::Constant { value: cv }\n+                        return Err(FallbackToConstRef);\n                     } else {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n@@ -435,24 +427,17 @@ impl<'tcx> ConstToPat<'tcx> {\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n-                        // In case there are structural-match violations somewhere in this subpattern,\n-                        // we fall back to a const pattern. If we do not do this, we may end up with\n-                        // a !structural-match constant that is not of reference type, which makes it\n-                        // very hard to invoke `PartialEq::eq` on it as a fallback.\n-                        let val = match self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false) {\n-                            Ok(subpattern) => PatKind::Deref { subpattern },\n-                            Err(_) => PatKind::Constant { value: cv },\n-                        };\n+                        let subpattern = self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false)?;\n                         self.behind_reference.set(old);\n-                        val\n+                        PatKind::Deref { subpattern }\n                     }\n                 }\n             },\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n                 PatKind::Constant { value: cv }\n             }\n             ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n-                PatKind::Constant { value: cv }\n+                return Err(FallbackToConstRef);\n             }\n             // FIXME: these can have very surprising behaviour where optimization levels or other\n             // compilation choices change the runtime behaviour of the match.\n@@ -469,7 +454,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         PointerPattern\n                     );\n                 }\n-                PatKind::Constant { value: cv }\n+                return Err(FallbackToConstRef);\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);"}, {"sha": "6a77146138bb582aa2df5cf59614c56598b379ab", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -844,8 +844,8 @@ impl<'tcx> Constructor<'tcx> {\n     }\n \n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n-    /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n-    /// assumed to have been split from a wildcard.\n+    /// assumed to be built from `matrix.head_ctors()` with wildcards and opaques filtered out,\n+    /// and `self` is assumed to have been split from a wildcard.\n     fn is_covered_by_any<'p>(\n         &self,\n         pcx: &PatCtxt<'_, 'p, 'tcx>,\n@@ -894,7 +894,7 @@ impl<'tcx> Constructor<'tcx> {\n /// in `to_ctors`: in some cases we only return `Missing`.\n #[derive(Debug)]\n pub(super) struct SplitWildcard<'tcx> {\n-    /// Constructors seen in the matrix.\n+    /// Constructors (other than wildcards and opaques) seen in the matrix.\n     matrix_ctors: Vec<Constructor<'tcx>>,\n     /// All the constructors for this type\n     all_ctors: SmallVec<[Constructor<'tcx>; 1]>,\n@@ -1037,7 +1037,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n         self.all_ctors =\n             self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx, ctors.clone())).collect();\n-        self.matrix_ctors = ctors.filter(|c| !c.is_wildcard()).cloned().collect();\n+        self.matrix_ctors = ctors.filter(|c| !matches!(c, Wildcard | Opaque)).cloned().collect();\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix."}, {"sha": "e5b6350690609812c788847ec2389c72350ac982", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -288,6 +288,22 @@\n //!\n //! The details are not necessary to understand this file, so we explain them in\n //! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n+//!\n+//! # Constants in patterns\n+//!\n+//! There are two kinds of constants in patterns:\n+//!\n+//! * literals (`1`, `true`, `\"foo\"`)\n+//! * named or inline consts (`FOO`, `const { 5 + 6 }`)\n+//!\n+//! The latter are converted into other patterns with literals at the leaves. For example\n+//! `const_to_pat(const { [1, 2, 3] })` becomes an `Array(vec![Const(1), Const(2), Const(3)])`\n+//! pattern. This gets problematic when comparing the constant via `==` would behave differently\n+//! from matching on the constant converted to a pattern. Situations like that can occur, when\n+//! the user implements `PartialEq` manually, and thus could make `==` behave arbitrarily different.\n+//! In order to honor the `==` implementation, constants of types that implement `PartialEq` manually\n+//! stay as a full constant and become an `Opaque` pattern. These `Opaque` patterns do not participate\n+//! in exhaustiveness, specialization or overlap checking.\n \n use self::ArmType::*;\n use self::Usefulness::*;"}, {"sha": "c10c6205a084b3ef8835a3f2546ec8216fada5a6", "filename": "tests/ui/pattern/usefulness/consts-opaque.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -20,11 +20,12 @@ const BAR: Bar = Bar;\n #[derive(PartialEq)]\n enum Baz {\n     Baz1,\n-    Baz2\n+    Baz2,\n }\n impl Eq for Baz {}\n const BAZ: Baz = Baz::Baz1;\n \n+#[rustfmt::skip]\n fn main() {\n     match FOO {\n         FOO => {}\n@@ -124,8 +125,16 @@ fn main() {\n \n     match WRAPQUUX {\n         Wrap(_) => {}\n-        WRAPQUUX => {} // detected unreachable because we do inspect the `Wrap` layer\n-        //~^ ERROR unreachable pattern\n+        WRAPQUUX => {}\n+    }\n+\n+    match WRAPQUUX {\n+        Wrap(_) => {}\n+    }\n+\n+    match WRAPQUUX {\n+        //~^ ERROR: non-exhaustive patterns: `Wrap(_)` not covered\n+        WRAPQUUX => {}\n     }\n \n     #[derive(PartialEq, Eq)]\n@@ -138,8 +147,7 @@ fn main() {\n     match WHOKNOWSQUUX {\n         WHOKNOWSQUUX => {}\n         WhoKnows::Yay(_) => {}\n-        WHOKNOWSQUUX => {} // detected unreachable because we do inspect the `WhoKnows` layer\n-        //~^ ERROR unreachable pattern\n+        WHOKNOWSQUUX => {}\n         WhoKnows::Nope => {}\n     }\n }"}, {"sha": "e01b06ccc82e4f5d6bb071dbe453276f3ae37fd1", "filename": "tests/ui/pattern/usefulness/consts-opaque.stderr", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9239760da89cd8e9a51536beeb0a23762064037d/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9239760da89cd8e9a51536beeb0a23762064037d/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=9239760da89cd8e9a51536beeb0a23762064037d", "patch": "@@ -1,5 +1,5 @@\n error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:30:9\n+  --> $DIR/consts-opaque.rs:31:9\n    |\n LL |         FOO => {}\n    |         ^^^\n@@ -8,7 +8,7 @@ LL |         FOO => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:37:9\n+  --> $DIR/consts-opaque.rs:38:9\n    |\n LL |         FOO_REF => {}\n    |         ^^^^^^^\n@@ -17,7 +17,7 @@ LL |         FOO_REF => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:45:9\n+  --> $DIR/consts-opaque.rs:46:9\n    |\n LL |         FOO_REF_REF => {}\n    |         ^^^^^^^^^^^\n@@ -29,7 +29,7 @@ LL |         FOO_REF_REF => {}\n    = note: `#[warn(indirect_structural_match)]` on by default\n \n error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:53:9\n+  --> $DIR/consts-opaque.rs:54:9\n    |\n LL |         BAR => {} // should not be emitting unreachable warning\n    |         ^^^\n@@ -38,7 +38,7 @@ LL |         BAR => {} // should not be emitting unreachable warning\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:61:9\n+  --> $DIR/consts-opaque.rs:62:9\n    |\n LL |         BAR => {}\n    |         ^^^\n@@ -47,7 +47,7 @@ LL |         BAR => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:70:9\n+  --> $DIR/consts-opaque.rs:71:9\n    |\n LL |         BAR => {}\n    |         ^^^\n@@ -56,7 +56,7 @@ LL |         BAR => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:72:9\n+  --> $DIR/consts-opaque.rs:73:9\n    |\n LL |         BAR => {} // should not be emitting unreachable warning\n    |         ^^^\n@@ -65,7 +65,7 @@ LL |         BAR => {} // should not be emitting unreachable warning\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:80:9\n+  --> $DIR/consts-opaque.rs:81:9\n    |\n LL |         BAZ => {}\n    |         ^^^\n@@ -74,7 +74,7 @@ LL |         BAZ => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:90:9\n+  --> $DIR/consts-opaque.rs:91:9\n    |\n LL |         BAZ => {}\n    |         ^^^\n@@ -83,7 +83,7 @@ LL |         BAZ => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:97:9\n+  --> $DIR/consts-opaque.rs:98:9\n    |\n LL |         BAZ => {}\n    |         ^^^\n@@ -92,7 +92,7 @@ LL |         BAZ => {}\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:32:9\n+  --> $DIR/consts-opaque.rs:33:9\n    |\n LL |         FOO => {}\n    |         --- matches any value\n@@ -107,7 +107,7 @@ LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:39:9\n+  --> $DIR/consts-opaque.rs:40:9\n    |\n LL |         FOO_REF => {}\n    |         ------- matches any value\n@@ -116,15 +116,15 @@ LL |         Foo(_) => {} // should not be emitting unreachable warning\n    |         ^^^^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:53:9\n+  --> $DIR/consts-opaque.rs:54:9\n    |\n LL |         Bar => {}\n    |         --- matches any value\n LL |         BAR => {} // should not be emitting unreachable warning\n    |         ^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:56:9\n+  --> $DIR/consts-opaque.rs:57:9\n    |\n LL |         Bar => {}\n    |         --- matches any value\n@@ -133,7 +133,7 @@ LL |         _ => {}\n    |         ^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:63:9\n+  --> $DIR/consts-opaque.rs:64:9\n    |\n LL |         BAR => {}\n    |         --- matches any value\n@@ -142,7 +142,7 @@ LL |         Bar => {} // should not be emitting unreachable warning\n    |         ^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:65:9\n+  --> $DIR/consts-opaque.rs:66:9\n    |\n LL |         BAR => {}\n    |         --- matches any value\n@@ -151,7 +151,7 @@ LL |         _ => {}\n    |         ^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:72:9\n+  --> $DIR/consts-opaque.rs:73:9\n    |\n LL |         BAR => {}\n    |         --- matches any value\n@@ -160,7 +160,7 @@ LL |         BAR => {} // should not be emitting unreachable warning\n    |         ^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:75:9\n+  --> $DIR/consts-opaque.rs:76:9\n    |\n LL |         BAR => {}\n    |         --- matches any value\n@@ -169,7 +169,7 @@ LL |         _ => {} // should not be emitting unreachable warning\n    |         ^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:82:9\n+  --> $DIR/consts-opaque.rs:83:9\n    |\n LL |         BAZ => {}\n    |         --- matches any value\n@@ -178,7 +178,7 @@ LL |         Baz::Baz1 => {} // should not be emitting unreachable warning\n    |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:84:9\n+  --> $DIR/consts-opaque.rs:85:9\n    |\n LL |         BAZ => {}\n    |         --- matches any value\n@@ -187,7 +187,7 @@ LL |         _ => {}\n    |         ^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:92:9\n+  --> $DIR/consts-opaque.rs:93:9\n    |\n LL |         BAZ => {}\n    |         --- matches any value\n@@ -196,7 +196,7 @@ LL |         _ => {}\n    |         ^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:99:9\n+  --> $DIR/consts-opaque.rs:100:9\n    |\n LL |         BAZ => {}\n    |         --- matches any value\n@@ -205,27 +205,32 @@ LL |         Baz::Baz2 => {} // should not be emitting unreachable warning\n    |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:101:9\n+  --> $DIR/consts-opaque.rs:102:9\n    |\n LL |         BAZ => {}\n    |         --- matches any value\n ...\n LL |         _ => {} // should not be emitting unreachable warning\n    |         ^ unreachable pattern\n \n-error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:127:9\n+error[E0004]: non-exhaustive patterns: `Wrap(_)` not covered\n+  --> $DIR/consts-opaque.rs:135:11\n    |\n-LL |         Wrap(_) => {}\n-   |         ------- matches any value\n-LL |         WRAPQUUX => {} // detected unreachable because we do inspect the `Wrap` layer\n-   |         ^^^^^^^^ unreachable pattern\n-\n-error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:141:9\n+LL |     match WRAPQUUX {\n+   |           ^^^^^^^^ pattern `Wrap(_)` not covered\n+   |\n+note: `Wrap<fn(usize, usize) -> usize>` defined here\n+  --> $DIR/consts-opaque.rs:117:12\n+   |\n+LL |     struct Wrap<T>(T);\n+   |            ^^^^\n+   = note: the matched value is of type `Wrap<fn(usize, usize) -> usize>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         WRAPQUUX => {},\n+LL +         Wrap(_) => todo!()\n    |\n-LL |         WHOKNOWSQUUX => {} // detected unreachable because we do inspect the `WhoKnows` layer\n-   |         ^^^^^^^^^^^^\n \n-error: aborting due to 24 previous errors; 1 warning emitted\n+error: aborting due to 23 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0004`."}]}