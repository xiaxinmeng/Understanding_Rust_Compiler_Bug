{"sha": "159dcb2194e6af28e070f15b9a69af354f87d6d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWRjYjIxOTRlNmFmMjhlMDcwZjE1YjlhNjlhZjM1NGY4N2Q2ZDY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-07-30T01:19:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-07-30T01:19:21Z"}, "message": "On `format!()` arg count mismatch provide extra info\n\nWhen positional width and precision formatting flags are present in a\nformatting string that has an argument count mismatch, provide extra\ninformation pointing at them making it easiser to understand where the\nproblem may lay:\n\n```\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:78:15\n   |\nLL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n   |                    |\n   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:81:15\n   |\nLL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^-----^ ^^      --- this parameter corresponds to the precision flag\n   |                    |  |\n   |                    |  this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: 3 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:84:15\n   |\nLL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n   |               ^^ ^^---^ ^^\n   |                    |\n   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n```", "tree": {"sha": "241959e6e006824b6a3396c0c62f87f10a438745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/241959e6e006824b6a3396c0c62f87f10a438745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159dcb2194e6af28e070f15b9a69af354f87d6d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159dcb2194e6af28e070f15b9a69af354f87d6d6", "html_url": "https://github.com/rust-lang/rust/commit/159dcb2194e6af28e070f15b9a69af354f87d6d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159dcb2194e6af28e070f15b9a69af354f87d6d6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c798dffac9dc8c82374db48f5b474690cc6e9686", "url": "https://api.github.com/repos/rust-lang/rust/commits/c798dffac9dc8c82374db48f5b474690cc6e9686", "html_url": "https://github.com/rust-lang/rust/commit/c798dffac9dc8c82374db48f5b474690cc6e9686"}], "stats": {"total": 246, "additions": 206, "deletions": 40}, "files": [{"sha": "b01c3a4aa7f21114f1c25ad8bf89c407c8bd05f3", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=159dcb2194e6af28e070f15b9a69af354f87d6d6", "patch": "@@ -59,16 +59,20 @@ pub struct Argument<'a> {\n /// Specification for the formatting of an argument in the format string.\n #[derive(Copy, Clone, PartialEq)]\n pub struct FormatSpec<'a> {\n-    /// Optionally specified character to fill alignment with\n+    /// Optionally specified character to fill alignment with.\n     pub fill: Option<char>,\n-    /// Optionally specified alignment\n+    /// Optionally specified alignment.\n     pub align: Alignment,\n-    /// Packed version of various flags provided\n+    /// Packed version of various flags provided.\n     pub flags: u32,\n-    /// The integer precision to use\n+    /// The integer precision to use.\n     pub precision: Count,\n-    /// The string width requested for the resulting format\n+    /// The span of the precision formatting flag (for diagnostics).\n+    pub precision_span: Option<InnerSpan>,\n+    /// The string width requested for the resulting format.\n     pub width: Count,\n+    /// The span of the width formatting flag (for diagnostics).\n+    pub width_span: Option<InnerSpan>,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -285,19 +289,24 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n-    /// the current position, then the current iterator isn't moved and false is\n-    /// returned, otherwise the character is consumed and true is returned.\n+    /// the current position, then the current iterator isn't moved and `false` is\n+    /// returned, otherwise the character is consumed and `true` is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        if let Some(&(_, maybe)) = self.cur.peek() {\n+        self.consume_pos(c).is_some()\n+    }\n+\n+    /// Optionally consumes the specified character. If the character is not at\n+    /// the current position, then the current iterator isn't moved and `None` is\n+    /// returned, otherwise the character is consumed and the current position is\n+    /// returned.\n+    fn consume_pos(&mut self, c: char) -> Option<usize> {\n+        if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n-                true\n-            } else {\n-                false\n+                return Some(pos);\n             }\n-        } else {\n-            false\n         }\n+        None\n     }\n \n     fn to_span_index(&self, pos: usize) -> InnerOffset {\n@@ -465,7 +474,9 @@ impl<'a> Parser<'a> {\n             align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n+            precision_span: None,\n             width: CountImplied,\n+            width_span: None,\n             ty: &self.input[..0],\n         };\n         if !self.consume(':') {\n@@ -502,6 +513,11 @@ impl<'a> Parser<'a> {\n         }\n         // Width and precision\n         let mut havewidth = false;\n+\n+        let mut width_span_start = 0;\n+        if let Some((pos, '0')) = self.cur.peek() {\n+            width_span_start = *pos;\n+        }\n         if self.consume('0') {\n             // small ambiguity with '0$' as a format string. In theory this is a\n             // '0' flag and then an ill-formatted format string with just a '$'\n@@ -515,17 +531,28 @@ impl<'a> Parser<'a> {\n             }\n         }\n         if !havewidth {\n-            spec.width = self.count();\n+            if width_span_start == 0 {\n+                if let Some((pos, _)) = self.cur.peek() {\n+                    width_span_start = *pos;\n+                }\n+            }\n+            let (w, sp) = self.count(width_span_start);\n+            spec.width = w;\n+            spec.width_span = sp;\n         }\n-        if self.consume('.') {\n-            if self.consume('*') {\n+        if let Some(start) = self.consume_pos('.') {\n+            if let Some(end) = self.consume_pos('*') {\n                 // Resolve `CountIsNextParam`.\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n                 spec.precision = CountIsParam(i);\n+                spec.precision_span =\n+                    Some(self.to_span_index(start).to(self.to_span_index(end + 1)));\n             } else {\n-                spec.precision = self.count();\n+                let (p, sp) = self.count(start);\n+                spec.precision = p;\n+                spec.precision_span = sp;\n             }\n         }\n         // Optional radix followed by the actual format specifier\n@@ -554,24 +581,25 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count {\n+    fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {\n         if let Some(i) = self.integer() {\n-            if self.consume('$') {\n-                CountIsParam(i)\n+            if let Some(end) = self.consume_pos('$') {\n+                let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n+                (CountIsParam(i), Some(span))\n             } else {\n-                CountIs(i)\n+                (CountIs(i), None)\n             }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n             if word.is_empty() {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             } else if self.consume('$') {\n-                CountIsName(Symbol::intern(word))\n+                (CountIsName(Symbol::intern(word)), None)\n             } else {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             }\n         }\n     }"}, {"sha": "aa8fc70d806470d02691729a0d958451baf92e4f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 92, "deletions": 15, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=159dcb2194e6af28e070f15b9a69af354f87d6d6", "patch": "@@ -109,6 +109,8 @@ struct Context<'a, 'b> {\n     invalid_refs: Vec<(usize, usize)>,\n     /// Spans of all the formatting arguments, in order.\n     arg_spans: Vec<Span>,\n+    /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n+    arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n     /// Whether this formatting string is a literal or it comes from a macro.\n     is_literal: bool,\n }\n@@ -279,14 +281,20 @@ impl<'a, 'b> Context<'a, 'b> {\n             .iter()\n             .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n \n+        let mut zero_based_note = false;\n+\n         if self.names.is_empty() && !numbered_position_args {\n+            let count = self.pieces.len() + self.arg_with_formatting\n+                .iter()\n+                .filter(|fmt| fmt.precision_span.is_some())\n+                .count();\n             e = self.ecx.mut_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n-                         self.pieces.len(),\n-                         if self.pieces.len() > 1 { \"s\" } else { \"\" },\n-                    self.describe_num_args()\n+                    count,\n+                    if count > 1 { \"s\" } else { \"\" },\n+                    self.describe_num_args(),\n                 ),\n             );\n         } else {\n@@ -317,9 +325,70 @@ impl<'a, 'b> Context<'a, 'b> {\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));\n-            e.note(\"positional arguments are zero-based\");\n+            zero_based_note = true;\n         };\n \n+        for fmt in &self.arg_with_formatting {\n+            if let Some(span) = fmt.precision_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.precision {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this precision flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    parse::CountIsParam(pos) => {\n+                        let count = self.pieces.len() + self.arg_with_formatting\n+                            .iter()\n+                            .filter(|fmt| fmt.precision_span.is_some())\n+                            .count();\n+                        e.span_label(span, &format!(\n+                            \"this precision flag adds an extra required argument at position {}, \\\n+                             which is why there {} expected\",\n+                            pos,\n+                            if count == 1 {\n+                                \"is 1 argument\".to_string()\n+                            } else {\n+                                format!(\"are {} arguments\", count)\n+                            },\n+                        ));\n+                        e.span_label(\n+                            self.args[pos].span,\n+                            \"this parameter corresponds to the precision flag\",\n+                        );\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            if let Some(span) = fmt.width_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.width {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this width flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if zero_based_note {\n+            e.note(\"positional arguments are zero-based\");\n+        }\n+        if !self.arg_with_formatting.is_empty() {\n+            e.note(\"for information about formatting flags, visit \\\n+                    https://doc.rust-lang.org/std/fmt/index.html\");\n+        }\n+\n         e.emit();\n     }\n \n@@ -435,10 +504,11 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Builds a static `rt::Argument` from a `parse::Piece` or append\n     /// to the `literal` string.\n-    fn build_piece(&mut self,\n-                   piece: &parse::Piece<'_>,\n-                   arg_index_consumed: &mut Vec<usize>)\n-                   -> Option<P<ast::Expr>> {\n+    fn build_piece(\n+        &mut self,\n+        piece: &parse::Piece<'a>,\n+        arg_index_consumed: &mut Vec<usize>,\n+    ) -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -496,7 +566,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n+                        precision_span: None,\n                         width: parse::CountImplied,\n+                        width_span: None,\n                         ty: arg.format.ty,\n                     },\n                 };\n@@ -506,6 +578,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos_simple =\n                     arg.position.index() == simple_arg.position.index();\n \n+                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n+                    self.arg_with_formatting.push(arg.format); //'liself.fmtsp.from_inner(span));\n+                }\n                 if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n                     self.all_pieces_simple = false;\n                 }\n@@ -530,7 +605,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n-                                         path,\n+                    path,\n                     vec![\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n@@ -657,12 +732,13 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt<'_>,\n-                  macsp: Span,\n-                  mut sp: Span,\n-                  ty: &ArgumentType,\n-                  arg: ast::Ident)\n-                  -> P<ast::Expr> {\n+    fn format_arg(\n+        ecx: &ExtCtxt<'_>,\n+        macsp: Span,\n+        mut sp: Span,\n+        ty: &ArgumentType,\n+        arg: ast::Ident,\n+    ) -> P<ast::Expr> {\n         sp = sp.apply_mark(ecx.current_expansion.id);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n@@ -941,6 +1017,7 @@ pub fn expand_preparsed_format_args(\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n         arg_spans,\n+        arg_with_formatting: Vec::new(),\n         is_literal,\n     };\n "}, {"sha": "d5c7950542dd8128190de7aa4301c99964194f37", "filename": "src/test/ui/if/ifmt-bad-arg.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs?ref=159dcb2194e6af28e070f15b9a69af354f87d6d6", "patch": "@@ -75,4 +75,12 @@ ninth number: {\n tenth number: {}\",\n         1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     //~^^ ERROR: invalid format string\n+    println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+    //~^ ERROR 3 positional arguments in format string, but there are 3 arguments\n }"}, {"sha": "1eaeb017587fc9e30e5f03947d6ca89728ffcfa7", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/159dcb2194e6af28e070f15b9a69af354f87d6d6/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=159dcb2194e6af28e070f15b9a69af354f87d6d6", "patch": "@@ -220,5 +220,58 @@ LL | tenth number: {}\",\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n-error: aborting due to 28 previous errors\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:78:15\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n+   |                    |\n+   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:81:15\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^-----^ ^^      --- this parameter corresponds to the precision flag\n+   |                    |  |\n+   |                    |  this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: 3 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:84:15\n+   |\n+LL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+   |               ^^ ^^---^ ^^\n+   |                    |\n+   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:78:32\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |                                ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:81:35\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |                                   ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error: aborting due to 33 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}]}