{"sha": "4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMzFjZjFkYzU4Nzk0YjhmNzIyNDBlYjE5YzQ4YjM5MmU5ZGU3YjI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-27T18:19:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-27T18:19:43Z"}, "message": "Distill semantics of use-def maps to fewer and more-obvious words.\n\n- Remove redundant uses of 'resolve' and 'referent' in semant.\n- Use defn, defn_id, lval, lval_base more consistently.\n- Make associated query functions more consistent.\n- Closes #127.", "tree": {"sha": "a5b4c7eb4cc39dac8d1a86cc13b8526c4c7f730b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5b4c7eb4cc39dac8d1a86cc13b8526c4c7f730b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "html_url": "https://github.com/rust-lang/rust/commit/4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7d7f70d09e38ce9331826eaba6b78e06cec6a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d7f70d09e38ce9331826eaba6b78e06cec6a63", "html_url": "https://github.com/rust-lang/rust/commit/b7d7f70d09e38ce9331826eaba6b78e06cec6a63"}], "stats": {"total": 396, "additions": 216, "deletions": 180}, "files": [{"sha": "94d34fb2df04c9dc5d6a2066bb1a026f11926b47", "filename": "src/boot/me/alias.ml", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Falias.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Falias.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Falias.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -20,10 +20,9 @@ let alias_analysis_visitor\n   in\n \n   let alias lval =\n-    let lv_id = lval_base_id lval in\n-    let referent = Hashtbl.find cx.ctxt_lval_to_referent lv_id in\n-      if (referent_is_slot cx referent)\n-      then alias_slot referent\n+    let defn_id = lval_base_defn_id cx lval in\n+      if (defn_id_is_slot cx defn_id)\n+      then alias_slot defn_id\n   in\n \n   let alias_atom at =\n@@ -85,8 +84,8 @@ let alias_analysis_visitor\n   in\n \n   let visit_lval_pre lv =\n-    let slot_id = lval_to_referent cx (lval_base_id lv) in\n-      if (not (Stack.is_empty curr_stmt)) && (referent_is_slot cx slot_id)\n+    let slot_id = lval_base_defn_id cx lv in\n+      if (not (Stack.is_empty curr_stmt)) && (defn_id_is_slot cx slot_id)\n       then\n         begin\n           let slot_depth = get_slot_depth cx slot_id in"}, {"sha": "79868defa418e5504a98c76995c1a590ea66023d", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -172,7 +172,7 @@ let function_effect_propagation_visitor\n                     lower_to s taux.Ast.fn_effect;\n                 | _ -> bug () \"non-fn callee\"\n             in\n-              if lval_is_slot cx fn\n+              if lval_base_is_slot cx fn\n               then\n                 lower_to_callee_ty (lval_ty cx fn)\n               else\n@@ -335,7 +335,7 @@ let process_crate\n     match lookup_by_name cx [] root_scope name with\n         None -> ()\n       | Some (_, id) ->\n-          if referent_is_item cx id\n+          if defn_id_is_item cx id\n           then htab_put item_auth id eff\n           else err (Some id) \"auth clause in crate refers to non-item\"\n   in"}, {"sha": "a9358795ed38da3260ee9424ecc491793d871a87", "filename": "src/boot/me/layout.ml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -412,9 +412,9 @@ let layout_visitor\n               let static = lval_is_static cx callee in\n               let closure = if static then None else Some Il.OpaqueTy in\n               let n_ty_params =\n-                match resolve_lval cx callee with\n-                    DEFN_item i -> Array.length i.Ast.decl_params\n-                  | _ -> 0\n+                if lval_base_is_item cx callee\n+                then Array.length (lval_item cx callee).node.Ast.decl_params\n+                else 0\n               in\n               let rty =\n                 call_args_referent_type cx n_ty_params lv_ty closure"}, {"sha": "bf11ad23245dcada7b36c3f71f14c7b74cc49553", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -562,7 +562,7 @@ let type_resolving_visitor\n           | Ast.MOD_ITEM_tag (header_slots, _, nid)\n               when Hashtbl.mem recursive_tag_groups nid ->\n               begin\n-                match ty_of_mod_item true item with\n+                match ty_of_mod_item item with\n                     Ast.TY_fn (tsig, taux) ->\n                       let input_slots =\n                         Array.map\n@@ -586,7 +586,7 @@ let type_resolving_visitor\n               end\n \n           | _ ->\n-              let t = ty_of_mod_item true item in\n+              let t = ty_of_mod_item item in\n               let ty =\n                 resolve_type cx (!scopes) recursive_tag_groups\n                   all_tags empty_recur_info t\n@@ -686,7 +686,7 @@ let lval_base_resolving_visitor\n     (scopes:(scope list) ref)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n-  let lookup_referent_by_ident id ident =\n+  let lookup_defn_by_ident id ident =\n     log cx \"looking up slot or item with ident '%s'\" ident;\n     match lookup cx (!scopes) (Ast.KEY_ident ident) with\n         None -> err (Some id) \"unresolved identifier '%s'\" ident\n@@ -702,10 +702,10 @@ let lval_base_resolving_visitor\n         | Some (_, id) ->\n             (log cx \"resolved to node id #%d\" (int_of_node id); id)\n   in\n-  let lookup_referent_by_name_base id nb =\n+  let lookup_defn_by_name_base id nb =\n     match nb with\n         Ast.BASE_ident ident\n-      | Ast.BASE_app (ident, _) -> lookup_referent_by_ident id ident\n+      | Ast.BASE_app (ident, _) -> lookup_defn_by_ident id ident\n       | Ast.BASE_temp temp -> lookup_slot_by_temp id temp\n   in\n \n@@ -723,10 +723,10 @@ let lval_base_resolving_visitor\n                 | _ -> ()\n             end\n         | Ast.LVAL_base nb ->\n-            let referent_id = lookup_referent_by_name_base nb.id nb.node in\n-              iflog cx (fun _ -> log cx \"resolved lval #%d to referent #%d\"\n-                          (int_of_node nb.id) (int_of_node referent_id));\n-              htab_put cx.ctxt_lval_to_referent nb.id referent_id\n+            let defn_id = lookup_defn_by_name_base nb.id nb.node in\n+              iflog cx (fun _ -> log cx \"resolved lval #%d to defn #%d\"\n+                          (int_of_node nb.id) (int_of_node defn_id));\n+              htab_put cx.ctxt_lval_base_id_to_defn_base_id nb.id defn_id\n     in\n \n     (*\n@@ -745,7 +745,7 @@ let lval_base_resolving_visitor\n             -> lval_is_name lv'\n           | _ -> false\n       in\n-        if lval_is_name lv && lval_is_item cx lv\n+        if lval_is_name lv && lval_base_is_item cx lv\n         then ignore (lookup_by_name cx [] (!scopes) (lval_to_name lv))\n     in\n \n@@ -932,7 +932,7 @@ let pattern_resolving_visitor\n           let lval_nm = lval_to_name lval in\n           let lval_id = lval_base_id lval in\n           let tag_ctor_id = (lval_item cx lval).id in\n-            if referent_is_item cx tag_ctor_id\n+            if defn_id_is_item cx tag_ctor_id\n \n             (* FIXME (issue #76): we should actually check here that the\n              * function is a tag value-ctor.  For now this actually allows\n@@ -1050,7 +1050,7 @@ let process_crate\n           Hashtbl.iter\n             begin\n               fun n _ ->\n-                if referent_is_item cx n\n+                if defn_id_is_item cx n\n                 then\n                   log cx \"referenced: %a\"\n                     Ast.sprintf_name"}, {"sha": "7a9aa922e6e91429461947fce7468ea4a2354c10", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 119, "deletions": 137, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -105,8 +105,8 @@ type ctxt =\n       (* definition id --> definition *)\n       ctxt_all_defns: (node_id,defn) Hashtbl.t;\n \n-      (* reference id --> definition id *)\n-      ctxt_lval_to_referent: (node_id,node_id) Hashtbl.t;\n+      (* reference id --> definitition id *)\n+      ctxt_lval_base_id_to_defn_base_id: (node_id,node_id) Hashtbl.t;\n \n       ctxt_required_items: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n       ctxt_required_syms: (node_id, string) Hashtbl.t;\n@@ -187,7 +187,7 @@ let new_ctxt sess abi crate =\n     ctxt_all_lvals = Hashtbl.create 0;\n     ctxt_all_defns = Hashtbl.create 0;\n     ctxt_call_lval_params = Hashtbl.create 0;\n-    ctxt_lval_to_referent = Hashtbl.create 0;\n+    ctxt_lval_base_id_to_defn_base_id = Hashtbl.create 0;\n     ctxt_required_items = crate.Ast.crate_required;\n     ctxt_required_syms = crate.Ast.crate_required_syms;\n \n@@ -254,58 +254,122 @@ let bugi (cx:ctxt) (i:node_id) =\n   in Printf.ksprintf k\n ;;\n \n-(* Convenience accessors. *)\n+(* Building blocks for semantic lookups. *)\n \n-(* resolve an lval reference id to the id of its definition *)\n-let lval_to_referent (cx:ctxt) (id:node_id) : node_id =\n-  if Hashtbl.mem cx.ctxt_lval_to_referent id\n-  then Hashtbl.find cx.ctxt_lval_to_referent id\n-  else bug () \"unresolved lval\"\n+let get_defn (cx:ctxt) (defn_id:node_id) : defn =\n+  match htab_search cx.ctxt_all_defns defn_id with\n+      Some defn -> defn\n+    | None -> bugi cx defn_id \"use of defn without entry in ctxt\"\n ;;\n \n-(* resolve an lval reference id to its definition *)\n-let resolve_lval_id (cx:ctxt) (id:node_id) : defn =\n-  Hashtbl.find cx.ctxt_all_defns (lval_to_referent cx id)\n+let get_item (cx:ctxt) (defn_id:node_id) : Ast.mod_item_decl =\n+  match get_defn cx defn_id with\n+      DEFN_item item -> item\n+    | _ -> bugi cx defn_id \"defn is not an item\"\n ;;\n \n-let referent_is_slot (cx:ctxt) (id:node_id) : bool =\n-  match Hashtbl.find cx.ctxt_all_defns id with\n+let get_slot (cx:ctxt) (defn_id:node_id) : Ast.slot =\n+  match get_defn cx defn_id with\n+      DEFN_slot slot -> slot\n+    | _ -> bugi cx defn_id \"defn is not an slot\"\n+;;\n+\n+let rec lval_base_id (lv:Ast.lval) : node_id =\n+  match lv with\n+      Ast.LVAL_base nbi -> nbi.id\n+    | Ast.LVAL_ext (lv, _) -> lval_base_id lv\n+;;\n+\n+let lval_is_base (lv:Ast.lval) : bool =\n+  match lv with\n+      Ast.LVAL_base _ -> true\n+    | _ -> false\n+;;\n+\n+let lval_base_id_to_defn_base_id (cx:ctxt) (lid:node_id) : node_id =\n+  match htab_search cx.ctxt_lval_base_id_to_defn_base_id lid with\n+      Some defn_id -> defn_id\n+    | None -> bugi cx lid \"use of unresolved lval\"\n+;;\n+\n+let lval_base_defn_id (cx:ctxt) (lval:Ast.lval) : node_id =\n+  lval_base_id_to_defn_base_id cx (lval_base_id lval)\n+;;\n+\n+let lval_base_defn (cx:ctxt) (lval:Ast.lval) : defn =\n+  get_defn cx (lval_base_defn_id cx lval)\n+;;\n+\n+let lval_base_slot (cx:ctxt) (lval:Ast.lval) : Ast.slot =\n+  get_slot cx (lval_base_defn_id cx lval)\n+;;\n+\n+let lval_base_item (cx:ctxt) (lval:Ast.lval) : Ast.mod_item_decl =\n+  get_item cx (lval_base_defn_id cx lval)\n+;;\n+\n+(* Judgements on defns and lvals. *)\n+\n+let defn_is_slot (defn:defn) : bool =\n+  match defn with\n       DEFN_slot _ -> true\n     | _ -> false\n ;;\n \n-let referent_is_item (cx:ctxt) (id:node_id) : bool =\n-  match Hashtbl.find cx.ctxt_all_defns id with\n+let defn_is_item (defn:defn) : bool =\n+  match defn with\n       DEFN_item _ -> true\n     | _ -> false\n ;;\n \n-let rec lval_base_id (lv:Ast.lval) : node_id =\n-  match lv with\n-      Ast.LVAL_base nbi -> nbi.id\n-    | Ast.LVAL_ext (lv, _) -> lval_base_id lv\n+let defn_is_obj_fn (defn:defn) : bool =\n+  match defn with\n+      DEFN_obj_fn _ -> true\n+    | _ -> false\n+;;\n+\n+let defn_is_obj_drop (defn:defn) : bool =\n+  match defn with\n+      DEFN_obj_drop _ -> true\n+    | _ -> false\n+;;\n+\n+let defn_id_is_slot (cx:ctxt) (defn_id:node_id) : bool =\n+  defn_is_slot (get_defn cx defn_id)\n+;;\n+\n+let defn_id_is_item (cx:ctxt) (defn_id:node_id) : bool =\n+  defn_is_item (get_defn cx defn_id)\n+;;\n+\n+let defn_id_is_obj_fn (cx:ctxt) (defn_id:node_id) : bool =\n+  defn_is_obj_fn (get_defn cx defn_id)\n+;;\n+\n+\n+let defn_id_is_obj_drop (cx:ctxt) (defn_id:node_id) : bool =\n+  defn_is_obj_drop (get_defn cx defn_id)\n+;;\n+\n+let lval_base_is_slot (cx:ctxt) (lval:Ast.lval) : bool =\n+  defn_id_is_slot cx (lval_base_defn_id cx lval)\n ;;\n \n-let get_item (cx:ctxt) (node:node_id) : Ast.mod_item_decl =\n-  match htab_search cx.ctxt_all_defns node with\n-      Some (DEFN_item item) -> item\n-    | Some _ -> bugi cx node \"defn is not an item\"\n-    | None -> bugi cx node \"missing defn\"\n+let lval_base_is_item (cx:ctxt) (lval:Ast.lval) : bool =\n+  defn_id_is_item cx (lval_base_defn_id cx lval)\n ;;\n \n-let get_slot (cx:ctxt) (node:node_id) : Ast.slot =\n-  match htab_search cx.ctxt_all_defns node with\n-      Some (DEFN_slot slot) -> slot\n-    | Some _ -> bugi cx node \"defn is not a slot\"\n-    | None -> bugi cx node \"missing defn\"\n+let lval_is_static (cx:ctxt) (lval:Ast.lval) : bool =\n+  not (lval_base_is_slot cx lval)\n ;;\n \n (* coerce an lval reference id to its definition slot *)\n+\n let lval_base_to_slot (cx:ctxt) (lval:Ast.lval) : Ast.slot identified =\n-  let lid = lval_base_id lval in\n-  let rid = lval_to_referent cx lid in\n-  let slot = get_slot cx rid in\n-    { node = slot; id = rid }\n+  assert (lval_is_base lval);\n+  let sid = lval_base_defn_id cx lval in\n+  let slot = get_slot cx sid in\n+    { node = slot; id = sid }\n ;;\n \n let get_stmt_depth (cx:ctxt) (id:node_id) : int =\n@@ -343,13 +407,6 @@ let rec n_item_ty_params (cx:ctxt) (id:node_id) : int =\n     | _ -> bugi cx id \"n_item_ty_params on non-item\"\n ;;\n \n-let item_is_obj_fn (cx:ctxt) (id:node_id) : bool =\n-  match Hashtbl.find cx.ctxt_all_defns id with\n-      DEFN_obj_fn _\n-    | DEFN_obj_drop _ -> true\n-    | _ -> false\n-;;\n-\n let get_spill (cx:ctxt) (id:node_id) : fixup =\n   if Hashtbl.mem cx.ctxt_spill_fixups id\n   then Hashtbl.find cx.ctxt_spill_fixups id\n@@ -522,57 +579,6 @@ let rec lval_to_name (lv:Ast.lval) : Ast.name =\n           Ast.NAME_ext (lval_to_name lv, comp)\n ;;\n \n-let rec lval_slots (cx:ctxt) (lv:Ast.lval) : node_id array =\n-  match lv with\n-      Ast.LVAL_base nbi ->\n-        let referent = lval_to_referent cx nbi.id in\n-          if referent_is_slot cx referent\n-          then [| referent |]\n-          else [| |]\n-    | Ast.LVAL_ext (lv, Ast.COMP_named _)\n-    | Ast.LVAL_ext (lv, Ast.COMP_deref) -> lval_slots cx lv\n-    | Ast.LVAL_ext (lv, Ast.COMP_atom a) ->\n-        Array.append (lval_slots cx lv) (atom_slots cx a)\n-\n-and atom_slots (cx:ctxt) (a:Ast.atom) : node_id array =\n-  match a with\n-      Ast.ATOM_literal _ -> [| |]\n-    | Ast.ATOM_lval lv -> lval_slots cx lv\n-;;\n-\n-let lval_option_slots (cx:ctxt) (lv:Ast.lval option) : node_id array =\n-  match lv with\n-      None -> [| |]\n-    | Some lv -> lval_slots cx lv\n-;;\n-\n-let resolve_lval (cx:ctxt) (lv:Ast.lval) : defn =\n-  resolve_lval_id cx (lval_base_id lv)\n-;;\n-\n-let atoms_slots (cx:ctxt) (az:Ast.atom array) : node_id array =\n-  Array.concat (List.map (atom_slots cx) (Array.to_list az))\n-;;\n-\n-let tup_inputs_slots (cx:ctxt) (az:Ast.tup_input array) : node_id array =\n-  Array.concat (List.map (atom_slots cx) (Array.to_list (Array.map snd az)))\n-;;\n-\n-let rec_inputs_slots (cx:ctxt)\n-    (inputs:Ast.rec_input array) : node_id array =\n-  Array.concat (List.map\n-                  (fun (_, _, atom) -> atom_slots cx atom)\n-                  (Array.to_list inputs))\n-;;\n-\n-let expr_slots (cx:ctxt) (e:Ast.expr) : node_id array =\n-    match e with\n-        Ast.EXPR_binary (_, a, b) ->\n-          Array.append (atom_slots cx a) (atom_slots cx b)\n-      | Ast.EXPR_unary (_, u) -> atom_slots cx u\n-      | Ast.EXPR_atom a -> atom_slots cx a\n-;;\n-\n \n (* Type extraction. *)\n \n@@ -1111,14 +1117,11 @@ let exports_permit (view:Ast.mod_view) (ident:Ast.ident) : bool =\n (* NB: this will fail if lval is not an item. *)\n let rec lval_item (cx:ctxt) (lval:Ast.lval) : Ast.mod_item =\n   match lval with\n-      Ast.LVAL_base nb ->\n-        begin\n-          let referent = lval_to_referent cx nb.id in\n-            match htab_search cx.ctxt_all_defns referent with\n-                Some (DEFN_item item) -> {node=item; id=referent}\n-              | _ -> err (Some (lval_base_id lval))\n-                  \"lval does not name an item\"\n-        end\n+      Ast.LVAL_base _ ->\n+        let defn_id = lval_base_defn_id cx lval in\n+        let item = get_item cx defn_id in\n+            { node = item; id = defn_id }\n+\n     | Ast.LVAL_ext (base, comp) ->\n         let base_item = lval_item cx base in\n         match base_item.node.Ast.decl_item with\n@@ -1146,43 +1149,16 @@ let rec lval_item (cx:ctxt) (lval:Ast.lval) : Ast.mod_item =\n               \"lval base %a does not name a module\" Ast.sprintf_lval base\n ;;\n \n-let lval_is_slot (cx:ctxt) (lval:Ast.lval) : bool =\n-  match resolve_lval cx lval with\n-      DEFN_slot _ -> true\n-    | _ -> false\n-;;\n-\n-let lval_is_item (cx:ctxt) (lval:Ast.lval) : bool =\n-  match resolve_lval cx lval with\n-      DEFN_item _ -> true\n-    | _ -> false\n-;;\n-\n-let lval_is_direct_fn (cx:ctxt) (lval:Ast.lval) : bool =\n-  let defn = resolve_lval cx lval in\n-    (defn_is_static defn) && (defn_is_callable defn)\n-;;\n-\n-let lval_is_direct_mod (cx:ctxt) (lval:Ast.lval) : bool =\n-  let defn = resolve_lval cx lval in\n-    if not (defn_is_static defn)\n-    then false\n-    else\n-      match defn with\n-          DEFN_item { Ast.decl_item = Ast.MOD_ITEM_mod _ } -> true\n-        | _ -> false\n-;;\n-\n (* \n  * FIXME: this function is a bad idea and exists only as a workaround\n  * for other logic that is even worse. Untangle.\n  *)\n let rec project_lval_ty_from_slot (cx:ctxt) (lval:Ast.lval) : Ast.ty =\n   match lval with\n       Ast.LVAL_base nbi ->\n-        let referent = lval_to_referent cx nbi.id in\n-          if lval_is_slot cx lval\n-          then slot_ty (get_slot cx referent)\n+        let defn_id = lval_base_id_to_defn_base_id cx nbi.id in\n+          if lval_base_is_slot cx lval\n+          then slot_ty (get_slot cx defn_id)\n           else Hashtbl.find cx.ctxt_all_item_types nbi.id\n     | Ast.LVAL_ext (base, comp) ->\n         let base_ty = project_lval_ty_from_slot cx base in\n@@ -1197,16 +1173,18 @@ let lval_ty (cx:ctxt) (lval:Ast.lval) : Ast.ty =\n         Ast.sprintf_lval lval\n ;;\n \n-let lval_is_static (cx:ctxt) (lval:Ast.lval) : bool =\n-  defn_is_static (resolve_lval cx lval)\n+let ty_is_fn (t:Ast.ty) : bool =\n+  match t with\n+      Ast.TY_fn _ -> true\n+    | _ -> false\n ;;\n \n-let lval_is_callable (cx:ctxt) (lval:Ast.lval) : bool =\n-  defn_is_callable (resolve_lval cx lval)\n+let lval_is_direct_fn (cx:ctxt) (lval:Ast.lval) : bool =\n+  (lval_base_is_item cx lval) && (ty_is_fn (lval_ty cx lval))\n ;;\n \n let lval_is_obj_vtbl (cx:ctxt) (lval:Ast.lval) : bool =\n-  if lval_is_slot cx lval\n+  if lval_base_is_slot cx lval\n   then\n     match lval with\n         Ast.LVAL_ext (base, _) ->\n@@ -1266,7 +1244,7 @@ let ty_obj_of_obj (obj:Ast.obj) : Ast.ty_obj =\n    htab_map obj.Ast.obj_fns (fun i f -> (i, ty_fn_of_fn f.node)))\n ;;\n \n-let ty_of_mod_item ((*inside*)_:bool) (item:Ast.mod_item) : Ast.ty =\n+let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n   match item.node.Ast.decl_item with\n       Ast.MOD_ITEM_type _ -> Ast.TY_type\n     | Ast.MOD_ITEM_fn f -> (Ast.TY_fn (ty_fn_of_fn f))\n@@ -2044,13 +2022,17 @@ let indirect_call_args_referent_type\n   call_args_referent_type cx n_ty_params callee_ty (Some closure)\n ;;\n \n+let defn_id_is_obj_fn_or_drop (cx:ctxt) (defn_id:node_id) : bool =\n+  (defn_id_is_obj_fn cx defn_id) || (defn_id_is_obj_drop cx defn_id)\n+;;\n+\n let direct_call_args_referent_type\n     (cx:ctxt)\n     (callee_node:node_id)\n     : Il.referent_ty =\n   let ity = Hashtbl.find cx.ctxt_all_item_types callee_node in\n   let n_ty_params =\n-    if item_is_obj_fn cx callee_node\n+    if defn_id_is_obj_fn_or_drop cx callee_node\n     then 0\n     else n_item_ty_params cx callee_node\n   in"}, {"sha": "5584b48587bcf15b3fe462a0509331f35d82ff0a", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -150,7 +150,7 @@ let trans_visitor\n       (closure:Il.referent_ty option)\n       : Il.referent_ty =\n     let n_params =\n-      if item_is_obj_fn cx id\n+      if defn_id_is_obj_fn_or_drop cx id\n       then 0\n       else n_item_ty_params cx id\n     in\n@@ -522,7 +522,7 @@ let trans_visitor\n   let get_ty_params_of_current_frame _ : Il.cell =\n     let id = current_fn() in\n     let n_ty_params = n_item_ty_params cx id in\n-      if item_is_obj_fn cx id\n+      if defn_id_is_obj_fn_or_drop cx id\n       then\n         begin\n           let obj_box = get_obj_for_current_frame() in\n@@ -1019,14 +1019,14 @@ let trans_visitor\n         (cell, ty)\n \n     in\n-      if lval_is_slot cx lv\n+      if lval_base_is_slot cx lv\n       then trans_slot_lval_full initializing true lv\n       else\n         if initializing\n         then err None \"init item\"\n         else\n           begin\n-            assert (lval_is_item cx lv);\n+            assert (lval_base_is_item cx lv);\n             bug ()\n               \"trans_lval_full called on item lval '%a'\" Ast.sprintf_lval lv\n           end\n@@ -1048,7 +1048,7 @@ let trans_visitor\n       : (Il.operand * Ast.ty) =\n     (* direct call to item *)\n     let fty = Hashtbl.find cx.ctxt_all_lval_types (lval_base_id flv) in\n-      if lval_is_item cx flv then\n+      if lval_base_is_item cx flv then\n         let fn_item = lval_item cx flv in\n         let fn_ptr = code_fixup_to_ptr_operand (get_fn_fixup cx fn_item.id) in\n           (fn_ptr, fty)"}, {"sha": "c63be4640be0dc18227874d2eac8c2381a4bd364", "filename": "src/boot/me/transutil.ml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftransutil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftransutil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftransutil.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -243,8 +243,6 @@ let iter_rec_parts\n ;;\n \n \n-\n-\n (*\n  * Local Variables:\n  * fill-column: 78;"}, {"sha": "ce5cf9f478b8cb3c7f392f683b1e0f78e248e1e8", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -285,12 +285,12 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n       (nbi:Ast.name_base Common.identified)\n       : ltype =\n     let lval_id = nbi.Common.id in\n-    let referent = Semant.lval_to_referent cx lval_id in\n+    let defn_id = Semant.lval_base_id_to_defn_base_id cx lval_id in\n     let lty =\n-      match Hashtbl.find cx.Semant.ctxt_all_defns referent with\n+      match Hashtbl.find cx.Semant.ctxt_all_defns defn_id with\n           Semant.DEFN_slot _ ->\n-            LTYPE_mono (internal_check_slot infer referent)\n-        | Semant.DEFN_item mid -> internal_check_mod_item_decl mid referent\n+            LTYPE_mono (internal_check_slot infer defn_id)\n+        | Semant.DEFN_item mid -> internal_check_mod_item_decl mid defn_id\n         | _ -> Common.bug () \"internal_check_base_lval: unexpected defn type\"\n     in\n     match nbi.Common.node with"}, {"sha": "baf4a54398ccd02eb32cae02efa75c6057a578af", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -120,7 +120,7 @@ let determine_constr_key\n   let cid =\n     match lookup_by_name cx [] scopes c.Ast.constr_name with\n         Some (_, cid) ->\n-          if referent_is_item cx cid\n+          if defn_id_is_item cx cid\n           then\n             begin\n               match Hashtbl.find cx.ctxt_all_item_types cid with\n@@ -155,7 +155,7 @@ let determine_constr_key\n                     match lookup_by_name cx [] scopes (Ast.NAME_base nb) with\n                         None -> bug () \"constraint-arg not found\"\n                       | Some (_, aid) ->\n-                          if referent_is_slot cx aid\n+                          if defn_id_is_slot cx aid\n                           then\n                             if type_has_state\n                               (strip_mutable_or_constrained_ty\n@@ -187,7 +187,7 @@ let fmt_constr_key cx ckey =\n                 let rec fmt_pth pth =\n                   match pth with\n                       Ast.CARG_base _ ->\n-                        if referent_is_slot cx id\n+                        if defn_id_is_slot cx id\n                         then\n                           let key = Hashtbl.find cx.ctxt_slot_keys id in\n                             Fmt.fmt_to_str Ast.fmt_slot_key key\n@@ -241,6 +241,54 @@ let fn_keys fn resolver =\n     entry_keys fn.Ast.fn_input_slots fn.Ast.fn_input_constrs resolver\n ;;\n \n+\n+let rec lval_slots (cx:ctxt) (lv:Ast.lval) : node_id array =\n+  match lv with\n+      Ast.LVAL_base nbi ->\n+        let defn_id = lval_base_id_to_defn_base_id cx nbi.id in\n+          if defn_id_is_slot cx defn_id\n+          then [| defn_id |]\n+          else [| |]\n+    | Ast.LVAL_ext (lv, Ast.COMP_named _)\n+    | Ast.LVAL_ext (lv, Ast.COMP_deref) -> lval_slots cx lv\n+    | Ast.LVAL_ext (lv, Ast.COMP_atom a) ->\n+        Array.append (lval_slots cx lv) (atom_slots cx a)\n+\n+and atom_slots (cx:ctxt) (a:Ast.atom) : node_id array =\n+  match a with\n+      Ast.ATOM_literal _ -> [| |]\n+    | Ast.ATOM_lval lv -> lval_slots cx lv\n+;;\n+\n+let lval_option_slots (cx:ctxt) (lv:Ast.lval option) : node_id array =\n+  match lv with\n+      None -> [| |]\n+    | Some lv -> lval_slots cx lv\n+;;\n+\n+let atoms_slots (cx:ctxt) (az:Ast.atom array) : node_id array =\n+  Array.concat (List.map (atom_slots cx) (Array.to_list az))\n+;;\n+\n+let tup_inputs_slots (cx:ctxt) (az:Ast.tup_input array) : node_id array =\n+  Array.concat (List.map (atom_slots cx) (Array.to_list (Array.map snd az)))\n+;;\n+\n+let rec_inputs_slots (cx:ctxt)\n+    (inputs:Ast.rec_input array) : node_id array =\n+  Array.concat (List.map\n+                  (fun (_, _, atom) -> atom_slots cx atom)\n+                  (Array.to_list inputs))\n+;;\n+\n+let expr_slots (cx:ctxt) (e:Ast.expr) : node_id array =\n+    match e with\n+        Ast.EXPR_binary (_, a, b) ->\n+          Array.append (atom_slots cx a) (atom_slots cx b)\n+      | Ast.EXPR_unary (_, u) -> atom_slots cx u\n+      | Ast.EXPR_atom a -> atom_slots cx a\n+;;\n+\n let constr_id_assigning_visitor\n     (cx:ctxt)\n     (tables_stack:typestate_tables Stack.t)\n@@ -328,17 +376,17 @@ let constr_id_assigning_visitor\n     begin\n       match s.node with\n           Ast.STMT_call (_, lv, args) ->\n-            let referent = lval_to_referent cx (lval_base_id lv) in\n-            let referent_ty = lval_ty cx lv in\n+            let defn_id = lval_base_defn_id cx lv in\n+            let defn_ty = lval_ty cx lv in\n               begin\n-                match referent_ty with\n+                match defn_ty with\n                     Ast.TY_fn (tsig,_) ->\n                       let constrs = tsig.Ast.sig_input_constrs in\n                       let names = atoms_to_names args in\n                       let constrs' =\n                         Array.map (apply_names_to_constr names) constrs\n                       in\n-                        Array.iter (visit_constr_pre (Some referent)) constrs'\n+                        Array.iter (visit_constr_pre (Some defn_id)) constrs'\n \n                   | _ -> ()\n               end\n@@ -488,9 +536,9 @@ let condition_assigning_visitor\n   in\n \n   let visit_callable_pre id dst_slot_ids lv args =\n-    let referent_ty = lval_ty cx lv in\n+    let defn_ty = lval_ty cx lv in\n       begin\n-        match referent_ty with\n+        match defn_ty with\n             Ast.TY_fn (tsig,_) ->\n               let formal_constrs = tsig.Ast.sig_input_constrs in\n               let names = atoms_to_names args in"}, {"sha": "68f665df7d8d04371854250a618051cb64d739a2", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d31cf1dc58794b8f72240eb19c48b392e9de7b2/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=4d31cf1dc58794b8f72240eb19c48b392e9de7b2", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+  auto x = spawn m.child(10);\n+  join x;\n+}\n+mod m {\n+  fn child(int i) {\n+    log i;\n+  }\n+}"}]}