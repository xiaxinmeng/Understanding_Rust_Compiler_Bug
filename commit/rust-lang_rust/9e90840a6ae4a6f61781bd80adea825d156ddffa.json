{"sha": "9e90840a6ae4a6f61781bd80adea825d156ddffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOTA4NDBhNmFlNGE2ZjYxNzgxYmQ4MGFkZWE4MjVkMTU2ZGRmZmE=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-12-26T18:01:22Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-01-10T16:19:50Z"}, "message": "Simplify NodeHeader by avoiding slices in BTreeMaps with shared roots", "tree": {"sha": "09e10a30646f9f5d894c484d277759cfa4e01cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09e10a30646f9f5d894c484d277759cfa4e01cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e90840a6ae4a6f61781bd80adea825d156ddffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e90840a6ae4a6f61781bd80adea825d156ddffa", "html_url": "https://github.com/rust-lang/rust/commit/9e90840a6ae4a6f61781bd80adea825d156ddffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e90840a6ae4a6f61781bd80adea825d156ddffa/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f795e8a216b44982706d41e5cbfa245d13b83fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f795e8a216b44982706d41e5cbfa245d13b83fc1", "html_url": "https://github.com/rust-lang/rust/commit/f795e8a216b44982706d41e5cbfa245d13b83fc1"}], "stats": {"total": 79, "additions": 19, "deletions": 60}, "files": [{"sha": "e70f881bc3d7e4b9c7efb2b15872aebe0b12c2d0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=9e90840a6ae4a6f61781bd80adea825d156ddffa", "patch": "@@ -1968,7 +1968,7 @@ where\n                 (i, false) => i,\n             },\n             (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.keys().len(),\n+            (true, Included(_)) => min_node.len(),\n             (true, Excluded(_)) => 0,\n         };\n \n@@ -1987,9 +1987,9 @@ where\n                 }\n                 (i, false) => i,\n             },\n-            (_, Unbounded) => max_node.keys().len(),\n+            (_, Unbounded) => max_node.len(),\n             (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.keys().len(),\n+            (true, Excluded(_)) => max_node.len(),\n         };\n \n         if !diverged {"}, {"sha": "f190209503d3e1c819183c12677ab02c3b60b700", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9e90840a6ae4a6f61781bd80adea825d156ddffa", "patch": "@@ -54,10 +54,8 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n /// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n-/// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n-struct NodeHeader<K, V, K2 = ()> {\n+struct NodeHeader<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -72,9 +70,6 @@ struct NodeHeader<K, V, K2 = ()> {\n     /// This next to `parent_idx` to encourage the compiler to join `len` and\n     /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n-\n-    /// See `into_key_slice`.\n-    keys_start: [K2; 0],\n }\n #[repr(C)]\n struct LeafNode<K, V> {\n@@ -128,7 +123,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0, keys_start: [] };\n+    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n@@ -390,7 +385,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Works on all possible nodes, including the shared root.\n+    /// The caller must ensure that the node is not the shared root.\n     pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n@@ -528,47 +523,9 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        // We have to be careful here because we might be pointing to the shared root.\n-        // In that case, we must not create an `&LeafNode`.  We could just return\n-        // an empty slice whenever the length is 0 (this includes the shared root),\n-        // but we want to avoid that run-time check.\n-        // Instead, we create a slice pointing into the node whenever possible.\n-        // We can sometimes do this even for the shared root, as the slice will be\n-        // empty and `NodeHeader` contains an empty `keys_start` array.\n-        // We cannot *always* do this because:\n-        // - `keys_start` is not correctly typed because we want `NodeHeader`'s size to\n-        //   not depend on the alignment of `K` (needed because `as_header` should be safe).\n-        //   For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n-        //   and hence just adds a size-0-align-1 field, not affecting layout).\n-        //   If the correctly typed header is more highly aligned than the allocated header,\n-        //   we cannot transmute safely.\n-        // - Even if we can transmute, the offset of a correctly typed `keys_start` might\n-        //   be different and outside the bounds of the allocated header!\n-        // So we do an alignment check and a size check first, that will be evaluated\n-        // at compile-time, and only do any run-time check in the rare case that\n-        // the compile-time checks signal danger.\n-        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n-            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n-            && self.is_shared_root()\n-        {\n-            &[]\n-        } else {\n-            // If we are a `LeafNode<K, V>`, we can always transmute to\n-            // `NodeHeader<K, V, K>` and `keys_start` always has the same offset\n-            // as the actual `keys`.\n-            // Thanks to the checks above, we know that we can transmute to\n-            // `NodeHeader<K, V, K>` and that `keys_start` will be\n-            // in-bounds of some allocation even if this is the shared root!\n-            // (We might be one-past-the-end, but that is allowed by LLVM.)\n-            // Thus we can use `NodeHeader<K, V, K>`\n-            // to compute the pointer where the keys start.\n-            // This entire hack will become unnecessary once\n-            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n-            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n-            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n-            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n-            unsafe { slice::from_raw_parts(keys, self.len()) }\n-        }\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot be the shared root, so `as_leaf` is okay.\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n     }\n \n     /// The caller must ensure that the node is not the shared root."}, {"sha": "25e206f4f73db77d251881e040cbbf1290023cc3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e90840a6ae4a6f61781bd80adea825d156ddffa/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=9e90840a6ae4a6f61781bd80adea825d156ddffa", "patch": "@@ -61,16 +61,18 @@ where\n {\n     // This function is defined over all borrow types (immutable, mutable, owned),\n     // and may be called on the shared root in each case.\n-    // Crucially, we use `keys()` here, i.e., we work with immutable data.\n-    // `keys_mut()` does not support the shared root, so we cannot use it.\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n-    for (i, k) in node.keys().iter().enumerate() {\n-        match key.cmp(k.borrow()) {\n-            Ordering::Greater => {}\n-            Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false),\n+    let len = node.len();\n+    // Skip search for empty nodes because `keys()` does not work on shared roots.\n+    if len > 0 {\n+        for (i, k) in node.keys().iter().enumerate() {\n+            match key.cmp(k.borrow()) {\n+                Ordering::Greater => {}\n+                Ordering::Equal => return (i, true),\n+                Ordering::Less => return (i, false),\n+            }\n         }\n     }\n-    (node.keys().len(), false)\n+    (len, false)\n }"}]}