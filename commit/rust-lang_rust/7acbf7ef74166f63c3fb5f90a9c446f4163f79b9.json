{"sha": "7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhY2JmN2VmNzQxNjZmNjNjM2ZiNWY5MGE5YzQ0NmY0MTYzZjc5Yjk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-04T21:09:10Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-04T21:09:10Z"}, "message": "Cleanup: EvalResult<'a, ()> becomes EvalResult<'a>.", "tree": {"sha": "fedb6968d65e0fc8be2126fbc65d35e54b5aba34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fedb6968d65e0fc8be2126fbc65d35e54b5aba34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "html_url": "https://github.com/rust-lang/rust/commit/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0451b74c6258a014a24d713e0aa50ba2f4011219", "url": "https://api.github.com/repos/rust-lang/rust/commits/0451b74c6258a014a24d713e0aa50ba2f4011219", "html_url": "https://github.com/rust-lang/rust/commit/0451b74c6258a014a24d713e0aa50ba2f4011219"}], "stats": {"total": 109, "additions": 56, "deletions": 53}, "files": [{"sha": "a7168bd19115e688808c018ba4cc803dbd3d8a98", "filename": "src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -55,7 +55,7 @@ pub enum EvalError<'tcx> {\n     Unreachable,\n }\n \n-pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n+pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {"}, {"sha": "a64b3fc3548c696286c4796abac2e1547c129f3e", "filename": "src/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -277,7 +277,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n         temporaries: Vec<Pointer>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n         // Subtract 1 because `local_decls` includes the ReturnPointer, but we don't store a local\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx, ()> {\n+    pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         operands: J,\n         discr_val: u128,\n         discr_size: u64,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n@@ -390,7 +390,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue<'tcx>,\n         offsets: I,\n         operands: J,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         // FIXME(solson)\n         let dest = self.force_allocation(dest)?.to_ptr();\n \n@@ -410,7 +410,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         lvalue: &mir::Lvalue<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         let dest = self.eval_lvalue(lvalue)?;\n         let dest_ty = self.lvalue_ty(lvalue);\n         let dest_layout = self.type_layout(dest_ty)?;\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n \n-    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align)?;\n@@ -909,7 +909,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue<'tcx>,\n         val: PrimVal,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         match dest {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         src_val: Value,\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         match dest {\n             Lvalue::Global(cid) => {\n                 let dest = *self.globals.get_mut(&cid).expect(\"global should be cached\");\n@@ -977,7 +977,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         write_dest: F,\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         if let Value::ByRef(dest_ptr) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         value: Value,\n         dest: Pointer,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         match value {\n             Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n             Value::ByVal(primval) => {\n@@ -1038,7 +1038,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         b: PrimVal,\n         ptr: Pointer,\n         ty: Ty<'tcx>\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         assert_eq!(self.get_field_count(ty)?, 2);\n         let field_0 = self.get_field_offset(ty, 0)?.bytes();\n         let field_1 = self.get_field_offset(ty, 1)?.bytes();\n@@ -1127,7 +1127,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(kind)\n     }\n \n-    fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+    fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool if val.to_bytes()? > 1 => Err(EvalError::InvalidBool),\n \n@@ -1256,7 +1256,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n         sty: Ty<'tcx>,\n         dty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n         let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n \n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         src_ty: Ty<'tcx>,\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         match (&src_ty.sty, &dest_ty.sty) {\n             (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n             (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n@@ -1371,7 +1371,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// Convenience function to ensure correct usage of globals and code-sharing with locals.\n-    pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx, ()>\n+    pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n         let mut val = *self.globals.get(&cid).expect(\"global not cached\");\n@@ -1389,7 +1389,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         frame: usize,\n         local: mir::Local,\n         f: F,\n-    ) -> EvalResult<'tcx, ()>\n+    ) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n         let val = self.stack[frame].get_local(local);"}, {"sha": "8df4940c113ecb320ed68c8f0b7c6de4505419f2", "filename": "src/memory.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx, ()> {\n+    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n         if ptr.points_to_zst() {\n             return Ok(());\n         }\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx, ()> {\n+    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         // check whether the memory was marked as packed\n         // we select all elements that have the correct alloc_id and are within\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n+    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx> {\n         // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64) -> EvalResult<'tcx, ()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(());\n         }\n@@ -599,13 +599,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes(ptr, size, 1)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n+    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         let bytes = self.get_bytes_mut(ptr, src.len() as u64, 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx, ()> {\n+    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n         self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         dest: Pointer,\n         val: PrimVal,\n         size: u64,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         match val {\n             PrimVal::Ptr(ptr) => {\n                 assert_eq!(size, self.pointer_size());\n@@ -671,7 +671,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n+    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx> {\n         let align = self.layout.i1_align.abi();\n         self.get_bytes_mut(ptr, 1, align)\n             .map(|bytes| bytes[0] = b as u8)\n@@ -693,7 +693,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i128, size: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u128, size: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n@@ -718,7 +718,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n     }\n \n-    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx, ()> {\n+    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_int(ptr, n as i128, size)\n     }\n@@ -727,20 +727,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n     }\n \n-    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_uint(ptr, n as u128, size)\n     }\n \n-    pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n+    pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f32_align.abi();\n         let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n-    pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx, ()> {\n+    pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f64_align.abi();\n         let b = self.get_bytes_mut(ptr, 8, align)?;\n@@ -769,7 +769,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(self.get(ptr.alloc_id)?.relocations.range(start..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n+    fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size), 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n@@ -802,7 +802,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n+    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Undefined bytes\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n+    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size as usize as u64, size);\n         let mut v = Vec::with_capacity(size as usize);\n@@ -831,17 +831,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n+    fn check_defined(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n         }\n         Ok(())\n     }\n \n-    pub fn mark_definedness(&mut self, ptr: Pointer, size: u64, new_state: bool)\n-        -> EvalResult<'tcx, ()>\n-    {\n+    pub fn mark_definedness(\n+        &mut self,\n+        ptr: Pointer,\n+        size: u64,\n+        new_state: bool\n+    ) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(())\n         }"}, {"sha": "c4c724c594e2a2ea9480d6890a9bd14805285c5d", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         right: &mir::Operand<'tcx>,\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n         let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n         self.write_value(val, dest, dest_ty)"}, {"sha": "33237b84637a58af3e294f1110f859b27742b2d3", "filename": "src/step.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -17,7 +17,7 @@ use lvalue::{Global, GlobalId, Lvalue};\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx, ()> {\n+    pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n         self.steps_remaining = self.steps_remaining.saturating_sub(n);\n         if self.steps_remaining > 0 {\n             Ok(())\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(true)\n     }\n \n-    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx, ()> {\n+    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", stmt);\n \n         use rustc::mir::StatementKind::*;\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx, ()> {\n+    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n@@ -164,7 +164,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup, Vec::new())\n         });\n     }\n-    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n+    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx>>(&mut self, f: F) {\n         if let Ok(ref mut n) = *self.new_constants {\n             *n += 1;\n         } else {"}, {"sha": "811ae7888d7295bf3c26e3149f977a26514525ea", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         let arg_vals: EvalResult<Vec<Value>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();"}, {"sha": "85d52f1a08d44d2495e30711a1f52a12fe2a33d5", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7acbf7ef74166f63c3fb5f90a9c446f4163f79b9/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=7acbf7ef74166f63c3fb5f90a9c446f4163f79b9", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n@@ -161,7 +161,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx, ()> {\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n         // add them to the stack in reverse order, because the impl that needs to run the last\n         // is the one that needs to be at the bottom of the stack\n         for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n@@ -194,7 +194,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         use syntax::abi::Abi;\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n@@ -513,7 +513,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx, ()> {\n+    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n         if let Some((last, last_ty)) = args.pop() {\n             let last_layout = self.type_layout(last_ty)?;\n             match (&last_ty.sty, last_layout) {\n@@ -649,7 +649,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         lval: Lvalue<'tcx>,\n         ty: Ty<'tcx>,\n         drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx, ()> {\n+    ) -> EvalResult<'tcx> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n             return Ok(());\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mut fields: I,\n         lval: Lvalue<'tcx>,\n         drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx, ()>\n+    ) -> EvalResult<'tcx>\n         where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n     {\n         // FIXME: some aggregates may be represented by Value::ByValPair"}]}