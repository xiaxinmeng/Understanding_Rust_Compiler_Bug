{"sha": "e5286d9fa6155291f8a66f96191ecd20f5c971a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1Mjg2ZDlmYTYxNTUyOTFmOGE2NmY5NjE5MWVjZDIwZjVjOTcxYTE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2018-07-04T18:07:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-21T12:56:44Z"}, "message": "Convert implied_outlives_bounds to a query", "tree": {"sha": "914a9d2c3581d2f7f95c114053167c596cd6662b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/914a9d2c3581d2f7f95c114053167c596cd6662b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5286d9fa6155291f8a66f96191ecd20f5c971a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5286d9fa6155291f8a66f96191ecd20f5c971a1", "html_url": "https://github.com/rust-lang/rust/commit/e5286d9fa6155291f8a66f96191ecd20f5c971a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5286d9fa6155291f8a66f96191ecd20f5c971a1/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9781358daa0a70bdaf11c9f792210ea30dd396", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9781358daa0a70bdaf11c9f792210ea30dd396", "html_url": "https://github.com/rust-lang/rust/commit/ef9781358daa0a70bdaf11c9f792210ea30dd396"}], "stats": {"total": 602, "additions": 381, "deletions": 221}, "files": [{"sha": "78e57c6a5d78fb01afabd86525f0662a9343abe7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -649,6 +649,7 @@ define_dep_nodes!( <'tcx>\n     [input] OutputFilenames,\n     [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n     [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),"}, {"sha": "57abdd18d353cb52a5084480b76726d3ddc2b27d", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9781358daa0a70bdaf11c9f792210ea30dd396/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=ef9781358daa0a70bdaf11c9f792210ea30dd396", "patch": "@@ -1,216 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use infer::InferCtxt;\n-use syntax::ast;\n-use syntax::codemap::Span;\n-use traits::{FulfillmentContext, TraitEngine, TraitEngineExt};\n-use ty::{self, Ty, TypeFoldable};\n-use ty::outlives::Component;\n-use ty::wf;\n-\n-/// Outlives bounds are relationships between generic parameters,\n-/// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`).  These relationships can be extracted from the\n-/// full set of predicates we understand or also from types (in which\n-/// case they are called implied bounds). They are fed to the\n-/// `OutlivesEnv` which in turn is supplied to the region checker and\n-/// other parts of the inference system.\n-#[derive(Debug)]\n-pub enum OutlivesBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n-    /// Implied bounds are region relationships that we deduce\n-    /// automatically.  The idea is that (e.g.) a caller must check that a\n-    /// function's argument types are well-formed immediately before\n-    /// calling that fn, and hence the *callee* can assume that its\n-    /// argument types are well-formed. This may imply certain relationships\n-    /// between generic parameters. For example:\n-    ///\n-    ///     fn foo<'a,T>(x: &'a T)\n-    ///\n-    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `param_env`, the where-clauses in scope\n-    /// - `body_id`, the body-id to use when normalizing assoc types.\n-    ///   Note that this may cause outlives obligations to be injected\n-    ///   into the inference context with this body-id.\n-    /// - `ty`, the type that we are supposed to assume is WF.\n-    /// - `span`, a span to use when normalizing, hopefully not important,\n-    ///   might be useful if a `bug!` occurs.\n-    pub fn implied_outlives_bounds(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Vec<OutlivesBound<'tcx>> {\n-        let tcx = self.tcx;\n-\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        let mut fulfill_cx = FulfillmentContext::new();\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations = wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            fulfill_cx.register_predicate_obligations(\n-                self,\n-                obligations\n-                    .iter()\n-                    .filter(|o| o.predicate.has_infer_types())\n-                    .cloned(),\n-            );\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ConstEvaluatable(..) => vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n-                        None => vec![],\n-                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                            vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n-                        }\n-                    },\n-\n-                    ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n-                        None => vec![],\n-                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                            let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n-                            let components = tcx.outlives_components(ty_a);\n-                            Self::implied_bounds_from_components(r_b, components)\n-                        }\n-                    },\n-                }\n-            }));\n-        }\n-\n-        // Ensure that those obligations that we had to solve\n-        // get solved *here*.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => (),\n-            Err(errors) => self.report_fulfillment_errors(&errors, None, false),\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(\n-        sub_region: ty::Region<'tcx>,\n-        sup_components: Vec<Component<'tcx>>,\n-    ) -> Vec<OutlivesBound<'tcx>> {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![OutlivesBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n-pub fn explicit_outlives_bounds<'tcx>(\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n-    debug!(\"explicit_outlives_bounds()\");\n-    param_env\n-        .caller_bounds\n-        .into_iter()\n-        .filter_map(move |predicate| match predicate {\n-            ty::Predicate::Projection(..) |\n-            ty::Predicate::Trait(..) |\n-            ty::Predicate::Subtype(..) |\n-            ty::Predicate::WellFormed(..) |\n-            ty::Predicate::ObjectSafe(..) |\n-            ty::Predicate::ClosureKind(..) |\n-            ty::Predicate::TypeOutlives(..) |\n-            ty::Predicate::ConstEvaluatable(..) => None,\n-            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n-                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n-            ),\n-        })\n-}"}, {"sha": "7f59a6794efbd15efcc67469326c9ecdbed3a53a", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -10,7 +10,7 @@\n \n use infer::{GenericKind, InferCtxt};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use infer::outlives::bounds::{self, OutlivesBound};\n+use traits::query::outlives_bounds::{self, OutlivesBound};\n use ty::{self, Ty};\n \n use syntax::ast;\n@@ -50,7 +50,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: vec![],\n         };\n \n-        env.add_outlives_bounds(None, bounds::explicit_outlives_bounds(param_env));\n+        env.add_outlives_bounds(None, outlives_bounds::explicit_outlives_bounds(param_env));\n \n         env\n     }"}, {"sha": "bb3703b2157328cd88f9b65a855d2b48dcd0749e", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -12,5 +12,4 @@\n \n pub mod env;\n pub mod free_region_map;\n-pub mod bounds;\n pub mod obligations;"}, {"sha": "35f17aebc0443481f0bfa1f913ddcc8c00915f7e", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -23,6 +23,7 @@ pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n+pub mod outlives_bounds;\n pub mod type_op;\n \n pub type CanonicalProjectionGoal<'tcx> ="}, {"sha": "c4fc17771b02335f5233f6bf0efc54debd69da1e", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use rustc_data_structures::small_vec::SmallVec;\n+use traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n+use traits::query::NoSolution;\n+use ty::{self, Ty, TyCtxt};\n+\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::mem;\n+\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n+#[derive(Clone, Debug)]\n+pub enum OutlivesBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for self::OutlivesBound<'a> {\n+        type Lifted = self::OutlivesBound<'tcx>;\n+        (self::OutlivesBound::RegionSubRegion)(a, b),\n+        (self::OutlivesBound::RegionSubParam)(a, b),\n+        (self::OutlivesBound::RegionSubProjection)(a, b),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for self::OutlivesBound<'tcx> {\n+        (self::OutlivesBound::RegionSubRegion)(a, b),\n+        (self::OutlivesBound::RegionSubParam)(a, b),\n+        (self::OutlivesBound::RegionSubProjection)(a, b),\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubParam(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Implied bounds are region relationships that we deduce\n+    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// function's argument types are well-formed immediately before\n+    /// calling that fn, and hence the *callee* can assume that its\n+    /// argument types are well-formed. This may imply certain relationships\n+    /// between generic parameters. For example:\n+    ///\n+    ///     fn foo<'a,T>(x: &'a T)\n+    ///\n+    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `param_env`, the where-clauses in scope\n+    /// - `body_id`, the body-id to use when normalizing assoc types.\n+    ///   Note that this may cause outlives obligations to be injected\n+    ///   into the inference context with this body-id.\n+    /// - `ty`, the type that we are supposed to assume is WF.\n+    /// - `span`, a span to use when normalizing, hopefully not important,\n+    ///   might be useful if a `bug!` occurs.\n+    pub fn implied_outlives_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        _body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<OutlivesBound<'tcx>> {\n+        let mut orig_values = SmallVec::new();\n+        let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n+        let result = match self.tcx.global_tcx().implied_outlives_bounds(key) {\n+            Ok(r) => r,\n+            Err(NoSolution) => {\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    \"implied_outlives_bounds failed to solve all obligations\"\n+                );\n+                return vec![];\n+            }\n+        };\n+        assert!(result.value.is_proven());\n+\n+        let result = self.instantiate_query_result_and_region_obligations(\n+            &ObligationCause::dummy(), param_env, &orig_values, &result);\n+        debug!(\"implied_outlives_bounds for {:?}: {:?}\", ty, result);\n+        let result = match result {\n+            Ok(v) => v,\n+            Err(_) => {\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    \"implied_outlives_bounds failed to instantiate\"\n+                );\n+                return vec![];\n+            }\n+        };\n+\n+        // Instantiation may have produced new inference variables and constraints on those\n+        // variables. Process these constraints.\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        fulfill_cx.register_predicate_obligations(self, result.obligations);\n+        if let Err(_) = fulfill_cx.select_all_or_error(self) {\n+            self.tcx.sess.delay_span_bug(\n+                span,\n+                \"implied_outlives_bounds failed to solve obligations from instantiation\"\n+            );\n+        }\n+\n+        result.value\n+    }\n+}\n+\n+pub fn explicit_outlives_bounds<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n+    debug!(\"explicit_outlives_bounds()\");\n+    param_env\n+        .caller_bounds\n+        .into_iter()\n+        .filter_map(move |predicate| match predicate {\n+            ty::Predicate::Projection(..) |\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Subtype(..) |\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n+            ty::Predicate::ClosureKind(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::ConstEvaluatable(..) => None,\n+            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n+            ),\n+        })\n+}"}, {"sha": "8db33032625b262d6f3d6e37c2745ac59a4b563f", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -87,6 +87,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n+        format!(\"computing implied outlives bounds for `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n     fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n         format!(\"computing dropck types for `{:?}`\", goal)"}, {"sha": "1b1020c9bd86dbe47d18eb8d3c466909451e6d7c", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -38,6 +38,7 @@ use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n                     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n+use traits::query::outlives_bounds::OutlivesBound;\n use traits::specialization_graph;\n use traits::Clauses;\n use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n@@ -551,6 +552,13 @@ define_queries! { <'tcx>\n             ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Ty<'tcx>,\n \n+        [] fn implied_outlives_bounds: ImpliedOutlivesBounds(\n+            CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+            NoSolution,\n+        >,\n+\n         /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n         [] fn dropck_outlives: DropckOutlives(\n             CanonicalTyGoal<'tcx>"}, {"sha": "7a9827b50a176ec35910d2429fdd370f5ac2ec5d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -1036,6 +1036,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ConstValueToAllocation |\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n+        DepKind::ImpliedOutlivesBounds |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n         DepKind::TypeOpEq |"}, {"sha": "ad29f808285b1ae99d9b6cf3f993b546830e57b1", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -56,6 +56,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::ty::BoundRegion,\n     ::ty::ClosureKind,\n     ::ty::IntVarValue,\n+    ::ty::ParamTy,\n     ::syntax_pos::Span,\n }\n "}, {"sha": "e7930b2148156132919fc633c1217caf176ee5ef", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -25,10 +25,10 @@\n use either::Either;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{self, BodyOwnerKind, HirId};\n-use rustc::infer::outlives::bounds::{self, OutlivesBound};\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n@@ -494,7 +494,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let num_universals = self.infcx.num_region_vars();\n \n         // Insert the facts we know from the predicates. Why? Why not.\n-        self.add_outlives_bounds(&indices, bounds::explicit_outlives_bounds(param_env));\n+        self.add_outlives_bounds(\n+            &indices,\n+            outlives_bounds::explicit_outlives_bounds(param_env),\n+        );\n \n         // Add the implied bounds from inputs and outputs.\n         for ty in inputs_and_output {"}, {"sha": "b6560fae110d52cae26b63d0a8646d6fca3562de", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Provider for the `implied_outlives_bounds` query.\n+//! Do not call this query directory. See [`rustc::traits::query::implied_outlives_bounds`].\n+\n+use rustc::infer::InferCtxt;\n+use rustc::infer::canonical::{self, Canonical};\n+use rustc::traits::{TraitEngine, TraitEngineExt};\n+use rustc::traits::query::outlives_bounds::OutlivesBound;\n+use rustc::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::outlives::Component;\n+use rustc::ty::query::Providers;\n+use rustc::ty::wf;\n+use syntax::ast::DUMMY_NODE_ID;\n+use syntax::codemap::DUMMY_SP;\n+use rustc::traits::FulfillmentContext;\n+\n+use rustc_data_structures::sync::Lrc;\n+\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        implied_outlives_bounds,\n+        ..*p\n+    };\n+}\n+\n+fn implied_outlives_bounds<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+        NoSolution,\n+> {\n+    tcx.infer_ctxt()\n+       .enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {\n+           let (param_env, ty) = key.into_parts();\n+           compute_implied_outlives_bounds(&infcx, param_env, ty)\n+       })\n+}\n+\n+fn compute_implied_outlives_bounds<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>\n+) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n+    let tcx = infcx.tcx;\n+\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Currently (at least) these resulting\n+    // predicates are always guaranteed to be a subset of the original\n+    // type, so we need not fear non-termination.\n+    let mut wf_types = vec![ty];\n+\n+    let mut implied_bounds = vec![];\n+\n+    let mut fulfill_cx = FulfillmentContext::new();\n+\n+    while let Some(ty) = wf_types.pop() {\n+        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        let obligations =\n+            wf::obligations(infcx, param_env, DUMMY_NODE_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+\n+        // NB: All of these predicates *ought* to be easily proven\n+        // true. In fact, their correctness is (mostly) implied by\n+        // other parts of the program. However, in #42552, we had\n+        // an annoying scenario where:\n+        //\n+        // - Some `T::Foo` gets normalized, resulting in a\n+        //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+        //   (not sure why it couldn't immediately get\n+        //   solved). This result of `_1` got cached.\n+        // - These obligations were dropped on the floor here,\n+        //   rather than being registered.\n+        // - Then later we would get a request to normalize\n+        //   `T::Foo` which would result in `_1` being used from\n+        //   the cache, but hence without the `T: Trait<Foo=_1>`\n+        //   constraint. As a result, `_1` never gets resolved,\n+        //   and we get an ICE (in dropck).\n+        //\n+        // Therefore, we register any predicates involving\n+        // inference variables. We restrict ourselves to those\n+        // involving inference variables both for efficiency and\n+        // to avoids duplicate errors that otherwise show up.\n+        fulfill_cx.register_predicate_obligations(\n+            infcx,\n+            obligations\n+                .iter()\n+                .filter(|o| o.predicate.has_infer_types())\n+                .cloned(),\n+        );\n+\n+        // From the full set of obligations, just filter down to the\n+        // region relationships.\n+        implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+            assert!(!obligation.has_escaping_regions());\n+            match obligation.predicate {\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Subtype(..) |\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::ObjectSafe(..) |\n+                ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                ty::Predicate::WellFormed(subty) => {\n+                    wf_types.push(subty);\n+                    vec![]\n+                }\n+\n+                ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                    None => vec![],\n+                    Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                    }\n+                },\n+\n+                ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                    None => vec![],\n+                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                        let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                        let components = tcx.outlives_components(ty_a);\n+                        implied_bounds_from_components(r_b, components)\n+                    }\n+                },\n+            }\n+        }));\n+    }\n+\n+    // Ensure that those obligations that we had to solve\n+    // get solved *here*.\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => Ok(implied_bounds),\n+        Err(_) => Err(NoSolution),\n+    }\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components(\n+    sub_region: ty::Region<'tcx>,\n+    sup_components: Vec<Component<'tcx>>,\n+) -> Vec<OutlivesBound<'tcx>> {\n+    sup_components\n+        .into_iter()\n+        .flat_map(|component| {\n+            match component {\n+                Component::Region(r) =>\n+                    vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n+                Component::Param(p) =>\n+                    vec![OutlivesBound::RegionSubParam(sub_region, p)],\n+                Component::Projection(p) =>\n+                    vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n+                Component::EscapingProjection(_) =>\n+                // If the projection has escaping regions, don't\n+                // try to infer any implied bounds even for its\n+                // free components. This is conservative, because\n+                // the caller will still have to prove that those\n+                // free components outlive `sub_region`. But the\n+                // idea is that the WAY that the caller proves\n+                // that may change in the future and we want to\n+                // give ourselves room to get smarter here.\n+                    vec![],\n+                Component::UnresolvedInferenceVariable(..) =>\n+                    vec![],\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "2a4cacb5623ecc6b7db5b94404fdff3bb8cf08da", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5286d9fa6155291f8a66f96191ecd20f5c971a1/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=e5286d9fa6155291f8a66f96191ecd20f5c971a1", "patch": "@@ -33,6 +33,7 @@ extern crate syntax_pos;\n mod chalk_context;\n mod dropck_outlives;\n mod evaluate_obligation;\n+mod implied_outlives_bounds;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n pub mod lowering;\n@@ -43,6 +44,7 @@ use rustc::ty::query::Providers;\n pub fn provide(p: &mut Providers) {\n     dropck_outlives::provide(p);\n     evaluate_obligation::provide(p);\n+    implied_outlives_bounds::provide(p);\n     lowering::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);"}]}