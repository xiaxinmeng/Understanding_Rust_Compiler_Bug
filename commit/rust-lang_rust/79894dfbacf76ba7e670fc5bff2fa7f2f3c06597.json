{"sha": "79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ODk0ZGZiYWNmNzZiYTdlNjcwZmM1YmZmMmZhN2YyZjNjMDY1OTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-14T14:39:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T14:39:00Z"}, "message": "Rollup merge of #73986 - RalfJung:raw-slice-as-ptr, r=sfackler\n\nadd (unchecked) indexing methods to raw (and NonNull) slices\n\nThis complements the existing (unstable) `len` method. Unfortunately, for non-null slices, we cannot call this method `as_ptr` as that overlaps with the existing method of the same name.\n\nIf this looks reasonable to accept, I propose to reuse the https://github.com/rust-lang/rust/issues/71146 tracking issue and rename the feature get to `slice_ptr_methods` or so.\n\nCc @SimonSapin\nFixes https://github.com/rust-lang/rust/issues/60639", "tree": {"sha": "ae8b222182457f18a8c273dc6616f5a8272d6a0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae8b222182457f18a8c273dc6616f5a8272d6a0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDcOFCRBK7hj4Ov3rIwAAdHIIADWNa9Hr3onX9ebLKHg4ZYn/\nSnIv9TTf1UsrXOwZxGT4pNlQVrfWvrXDIVwxWeQREaQe6rMWdfvh2uRAPMWN2mtf\n8nwR1CHjs0e7bfOO/sLozDnG4czts/ZJ83BIurkeeO/A6/PBKgbMXXAc/QuOK5/w\ngYiD3Nn+F1hcLki98TZgwuuKN/N/05mnGREMeoVP5pGzFC5LHYsP2kU2gjeKwxcg\nPWS3pJJV1lJWf6batpA8fCZORjabq8cL1v+jgwWSTy/e1wOPXbcERZKvTnB3klVQ\n2KhVw7LvRg47JhPjFfvNJiXt8QkOq4B8mtzm6w5iAwDwoPHo3lGmKm0Y0HkB+p4=\n=fEFE\n-----END PGP SIGNATURE-----\n", "payload": "tree ae8b222182457f18a8c273dc6616f5a8272d6a0d\nparent 6a4faa2da18330c067babb6acf9041c599c4ad27\nparent ff5e1078fc911c6ca97c64fbaefe7a2aebedbb0d\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594737540 -0700\ncommitter GitHub <noreply@github.com> 1594737540 -0700\n\nRollup merge of #73986 - RalfJung:raw-slice-as-ptr, r=sfackler\n\nadd (unchecked) indexing methods to raw (and NonNull) slices\n\nThis complements the existing (unstable) `len` method. Unfortunately, for non-null slices, we cannot call this method `as_ptr` as that overlaps with the existing method of the same name.\n\nIf this looks reasonable to accept, I propose to reuse the https://github.com/rust-lang/rust/issues/71146 tracking issue and rename the feature get to `slice_ptr_methods` or so.\n\nCc @SimonSapin\nFixes https://github.com/rust-lang/rust/issues/60639\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "html_url": "https://github.com/rust-lang/rust/commit/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a4faa2da18330c067babb6acf9041c599c4ad27", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a4faa2da18330c067babb6acf9041c599c4ad27", "html_url": "https://github.com/rust-lang/rust/commit/6a4faa2da18330c067babb6acf9041c599c4ad27"}, {"sha": "ff5e1078fc911c6ca97c64fbaefe7a2aebedbb0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff5e1078fc911c6ca97c64fbaefe7a2aebedbb0d", "html_url": "https://github.com/rust-lang/rust/commit/ff5e1078fc911c6ca97c64fbaefe7a2aebedbb0d"}], "stats": {"total": 418, "additions": 287, "deletions": 131}, "files": [{"sha": "c7496c209bcb06427a96adaeee727559a6ede34b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -148,6 +148,7 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n+#![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n #![deny(unsafe_op_in_unsafe_fn)]"}, {"sha": "39d4aca636a05c6a632bc1a0347dd1913f52e4d1", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -2,6 +2,7 @@ use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n+use crate::slice::SliceIndex;\n \n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n@@ -826,6 +827,55 @@ impl<T> *const [T] {\n         // Only `std` can make this guarantee.\n         unsafe { Repr { rust: self }.raw }.len\n     }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// This is equivalent to casting `self` to `*const T`, but more type-safe.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get)]\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *const [i8] = ptr::slice_from_raw_parts(ptr::null(), 3);\n+    /// assert_eq!(slice.as_ptr(), 0 as *const i8);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get)]\n+    ///\n+    /// let x = &[1, 2, 4] as *const [i32];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked(1), x.as_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        unsafe { index.get_unchecked(self) }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "644465d7d17f8a60fc92dcb49f515124a4a6ab84", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n+use crate::slice::SliceIndex;\n \n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n@@ -1014,7 +1015,6 @@ impl<T> *mut [T] {\n     ///\n     /// ```rust\n     /// #![feature(slice_ptr_len)]\n-    ///\n     /// use std::ptr;\n     ///\n     /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n@@ -1028,6 +1028,55 @@ impl<T> *mut [T] {\n         // Only `std` can make this guarantee.\n         unsafe { Repr { rust_mut: self }.raw }.len\n     }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// This is equivalent to casting `self` to `*mut T`, but more type-safe.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get)]\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n+    /// assert_eq!(slice.as_mut_ptr(), 0 as *mut i8);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_mut_ptr(self) -> *mut T {\n+        self as *mut T\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get)]\n+    ///\n+    /// let x = &mut [1, 2, 4] as *mut [i32];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked_mut(1), x.as_mut_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        unsafe { index.get_unchecked_mut(self) }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "b362a49d604e7ffd2a3ccdecee89c4f33c17f440", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -6,6 +6,7 @@ use crate::marker::Unsize;\n use crate::mem;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n+use crate::slice::SliceIndex;\n \n /// `*mut T` but non-zero and covariant.\n ///\n@@ -192,7 +193,6 @@ impl<T> NonNull<[T]> {\n     ///\n     /// ```rust\n     /// #![feature(slice_ptr_len, nonnull_slice_from_raw_parts)]\n-    ///\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n@@ -204,6 +204,57 @@ impl<T> NonNull<[T]> {\n     pub const fn len(self) -> usize {\n         self.as_ptr().len()\n     }\n+\n+    /// Returns a non-null pointer to the slice's buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n+    /// assert_eq!(slice.as_non_null_ptr(), NonNull::new(1 as *mut i8).unwrap());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_non_null_ptr(self) -> NonNull<T> {\n+        // SAFETY: We know `self` is non-null.\n+        unsafe { NonNull::new_unchecked(self.as_ptr().as_mut_ptr()) }\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let x = &mut [1, 2, 4];\n+    /// let x = NonNull::slice_from_raw_parts(NonNull::new(x.as_mut_ptr()).unwrap(), x.len());\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked_mut(1).as_ptr(), x.as_non_null_ptr().as_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        // As a consequence, the resulting pointer cannot be NULL.\n+        unsafe { NonNull::new_unchecked(self.as_ptr().get_unchecked_mut(index)) }\n+    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "0e202bb7801cff50e7d16e597e70ce710447761d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -310,8 +310,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n-        unsafe { index.get_unchecked(self) }\n+        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -342,8 +344,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n-        unsafe { index.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -3010,6 +3014,9 @@ mod private_slice_index {\n }\n \n /// A helper trait used for indexing operations.\n+///\n+/// Implementations of this trait have to promise that if the argument\n+/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n #[rustc_on_unimplemented(\n     on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n@@ -3021,7 +3028,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n     message = \"the type `{T}` cannot be indexed by `{Self}`\",\n     label = \"slice indices are of type `usize` or ranges of `usize`\"\n )]\n-pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n+pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n     type Output: ?Sized;\n@@ -3038,21 +3045,21 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n \n     /// Returns a shared reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n \n     /// Returns a mutable reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n+    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n \n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n@@ -3068,33 +3075,32 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for usize {\n+unsafe impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked_mut(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // The obtained pointer comes from a reference which is guaranteed\n-        // to be valid.\n-        unsafe { &*slice.as_ptr().add(self) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { &mut *slice.as_mut_ptr().add(self) }\n+        unsafe { slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -3111,15 +3117,15 @@ impl<T> SliceIndex<[T]> for usize {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::Range<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked(slice)) }\n+            unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n \n@@ -3128,24 +3134,25 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked_mut(slice)) }\n+            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n-        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n-        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        }\n     }\n \n     #[inline]\n@@ -3155,7 +3162,7 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked(slice) }\n+        unsafe { &*self.get_unchecked(slice) }\n     }\n \n     #[inline]\n@@ -3165,12 +3172,12 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked_mut(slice) }\n+        unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3184,13 +3191,13 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n@@ -3207,7 +3214,7 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3221,13 +3228,13 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n@@ -3244,7 +3251,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFull {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -3258,12 +3265,12 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         slice\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         slice\n     }\n \n@@ -3279,7 +3286,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3297,13 +3304,13 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n@@ -3326,7 +3333,7 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3340,13 +3347,13 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }"}, {"sha": "89233259a04dbe7fc475a552dc1d6489243101b3", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79894dfbacf76ba7e670fc5bff2fa7f2f3c06597/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=79894dfbacf76ba7e670fc5bff2fa7f2f3c06597", "patch": "@@ -1731,7 +1731,8 @@ Section: Trait implementations\n mod traits {\n     use crate::cmp::Ordering;\n     use crate::ops;\n-    use crate::slice::{self, SliceIndex};\n+    use crate::ptr;\n+    use crate::slice::SliceIndex;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1822,7 +1823,7 @@ mod traits {\n     ///\n     /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFull {\n+    unsafe impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -1833,11 +1834,11 @@ mod traits {\n             Some(slice)\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             slice\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             slice\n         }\n         #[inline]\n@@ -1886,16 +1887,18 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::Range<usize> {\n+    unsafe impl SliceIndex<str> for ops::Range<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if self.start <= self.end\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                // We also checked char boundaries, so this is valid UTF-8.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n@@ -1907,34 +1910,28 @@ mod traits {\n                 && slice.is_char_boundary(self.end)\n             {\n                 // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // We know the pointer is unique because we got it from `slice`.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` and `self.end` are char boundaries.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: see comments for `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n-            // can return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1949,8 +1946,9 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n             }\n@@ -1973,44 +1971,39 @@ mod traits {\n     /// Panics if `end` does not point to the starting byte offset of a\n     /// character (as defined by `is_char_boundary`), or if `end > len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeTo<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             let ptr = slice.as_ptr();\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.end` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n+            ptr::slice_from_raw_parts(ptr, self.end) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             let ptr = slice.as_mut_ptr();\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n+            ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2020,8 +2013,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n             }\n@@ -2045,49 +2039,44 @@ mod traits {\n     /// Panics if `begin` does not point to the starting byte offset of\n     /// a character (as defined by `is_char_boundary`), or if `begin >= len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFrom<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: identical to `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2097,8 +2086,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n             }\n@@ -2122,7 +2112,7 @@ mod traits {\n     /// to the ending byte offset of a character (`end + 1` is either a starting\n     /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2141,12 +2131,12 @@ mod traits {\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n@@ -2181,7 +2171,7 @@ mod traits {\n     /// (`end + 1` is either a starting byte offset as defined by\n     /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2192,12 +2182,12 @@ mod traits {\n             if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n@@ -2560,8 +2550,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { i.get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2593,8 +2585,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { i.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2644,8 +2638,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (begin..end).get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*(begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2676,8 +2672,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (begin..end).get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *(begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index."}]}