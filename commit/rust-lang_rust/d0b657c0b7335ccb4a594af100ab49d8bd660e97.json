{"sha": "d0b657c0b7335ccb4a594af100ab49d8bd660e97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYjY1N2MwYjczMzVjY2I0YTU5NGFmMTAwYWI0OWQ4YmQ2NjBlOTc=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-21T15:37:09Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Refactor while let on iterator lint to its module; rename for loop explicit counter to explicit counter loop", "tree": {"sha": "b009ef956d5b417228c97a25afd0bbb0aafd4e9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b009ef956d5b417228c97a25afd0bbb0aafd4e9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0b657c0b7335ccb4a594af100ab49d8bd660e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b657c0b7335ccb4a594af100ab49d8bd660e97", "html_url": "https://github.com/rust-lang/rust/commit/d0b657c0b7335ccb4a594af100ab49d8bd660e97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0b657c0b7335ccb4a594af100ab49d8bd660e97/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "html_url": "https://github.com/rust-lang/rust/commit/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac"}], "stats": {"total": 345, "additions": 179, "deletions": 166}, "files": [{"sha": "68fee269eb1d6f3ac5f65e9ef5ab864745805417", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=d0b657c0b7335ccb4a594af100ab49d8bd660e97", "previous_filename": "clippy_lints/src/loops/for_loop_explicit_counter.rs"}, {"sha": "cadf92412562ba6e6b8a70795772f13d98fb7e1e", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 8, "deletions": 166, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=d0b657c0b7335ccb4a594af100ab49d8bd660e97", "patch": "@@ -1,5 +1,5 @@\n+mod explicit_counter_loop;\n mod for_loop_arg;\n-mod for_loop_explicit_counter;\n mod for_loop_over_map_kv;\n mod for_loop_range;\n mod for_mut_range_bound;\n@@ -11,27 +11,20 @@ mod needless_collect;\n mod never_loop;\n mod same_item_push;\n mod utils;\n+mod while_let_on_iterator;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    get_enclosing_block, get_trait_def_id, higher, implements_trait, is_in_panic_handler, is_no_std_crate,\n-    is_refutable, last_path_segment, match_trait_method, path_to_local, path_to_local_id, paths,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_sugg, sugg,\n+    higher, is_in_panic_handler, is_no_std_crate, snippet_with_applicability, span_lint_and_help, span_lint_and_sugg,\n+    sugg,\n };\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, PatKind, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, LoopSource, MatchSource, Pat, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n-use utils::{\n-    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, LoopNestVisitor, Nesting,\n-};\n+use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for for-loops that manually copy items between\n@@ -625,54 +618,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n                 }\n             }\n         }\n-        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n-            let pat = &arms[0].pat.kind;\n-            if let (\n-                &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n-            ) = (pat, &match_expr.kind)\n-            {\n-                let iter_expr = &method_args[0];\n-\n-                // Don't lint when the iterator is recreated on every iteration\n-                if_chain! {\n-                    if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n-                    if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n-                    if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n-                    then {\n-                        return;\n-                    }\n-                }\n \n-                let lhs_constructor = last_path_segment(qpath);\n-                if method_path.ident.name == sym::next\n-                    && match_trait_method(cx, match_expr, &paths::ITERATOR)\n-                    && lhs_constructor.ident.name == sym::Some\n-                    && (pat_args.is_empty()\n-                        || !is_refutable(cx, &pat_args[0])\n-                            && !is_used_inside(cx, iter_expr, &arms[0].body)\n-                            && !is_iterator_used_after_while_let(cx, iter_expr)\n-                            && !is_nested(cx, expr, &method_args[0]))\n-                {\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n-                    let loop_var = if pat_args.is_empty() {\n-                        \"_\".to_string()\n-                    } else {\n-                        snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        WHILE_LET_ON_ITERATOR,\n-                        expr.span.with_hi(match_expr.span.hi()),\n-                        \"this loop could be written as a `for` loop\",\n-                        \"try\",\n-                        format!(\"for {} in {}\", loop_var, iterator),\n-                        applicability,\n-                    );\n-                }\n-            }\n-        }\n+        while_let_on_iterator::check_while_let_on_iterator(cx, expr);\n \n         if let Some((cond, body)) = higher::while_loop(&expr) {\n             infinite_loop::check_infinite_loop(cx, cond, body);\n@@ -693,7 +640,7 @@ fn check_for_loop<'tcx>(\n     let is_manual_memcpy_triggered = manual_memcpy::detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n         for_loop_range::check_for_loop_range(cx, pat, arg, body, expr);\n-        for_loop_explicit_counter::check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n+        explicit_counter_loop::check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n     for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n     for_loop_over_map_kv::check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n@@ -773,61 +720,6 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     }\n }\n \n-fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(expr) {\n-        Some(id) => id,\n-        None => return false,\n-    };\n-    if let Some(used_mutably) = mutated_variables(container, cx) {\n-        if used_mutably.contains(&def_id) {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(iter_expr) {\n-        Some(id) => id,\n-        None => return false,\n-    };\n-    let mut visitor = VarUsedAfterLoopVisitor {\n-        def_id,\n-        iter_expr_id: iter_expr.hir_id,\n-        past_while_let: false,\n-        var_used_after_while_let: false,\n-    };\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n-        walk_block(&mut visitor, enclosing_block);\n-    }\n-    visitor.var_used_after_while_let\n-}\n-\n-struct VarUsedAfterLoopVisitor {\n-    def_id: HirId,\n-    iter_expr_id: HirId,\n-    past_while_let: bool,\n-    var_used_after_while_let: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.past_while_let {\n-            if path_to_local_id(expr, self.def_id) {\n-                self.var_used_after_while_let = true;\n-            }\n-        } else if self.iter_expr_id == expr.hir_id {\n-            self.past_while_let = true;\n-        }\n-        walk_expr(self, expr);\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n@@ -863,53 +755,3 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n         _ => false,\n     }\n }\n-\n-fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n-        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n-        then {\n-            return is_loop_nested(cx, loop_expr, iter_expr)\n-        }\n-    }\n-    false\n-}\n-\n-fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    let mut id = loop_expr.hir_id;\n-    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n-        id\n-    } else {\n-        return true;\n-    };\n-    loop {\n-        let parent = cx.tcx.hir().get_parent_node(id);\n-        if parent == id {\n-            return false;\n-        }\n-        match cx.tcx.hir().find(parent) {\n-            Some(Node::Expr(expr)) => {\n-                if let ExprKind::Loop(..) = expr.kind {\n-                    return true;\n-                };\n-            },\n-            Some(Node::Block(block)) => {\n-                let mut block_visitor = LoopNestVisitor {\n-                    hir_id: id,\n-                    iterator: iter_id,\n-                    nesting: Nesting::Unknown,\n-                };\n-                walk_block(&mut block_visitor, block);\n-                if block_visitor.nesting == Nesting::RuledOut {\n-                    return false;\n-                }\n-            },\n-            Some(Node::Stmt(_)) => (),\n-            _ => {\n-                return false;\n-            },\n-        }\n-        id = parent;\n-    }\n-}"}, {"sha": "090c8ceba974459a816bbf7bd2af0e746f2e31c0", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b657c0b7335ccb4a594af100ab49d8bd660e97/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=d0b657c0b7335ccb4a594af100ab49d8bd660e97", "patch": "@@ -0,0 +1,171 @@\n+use super::utils::{LoopNestVisitor, Nesting};\n+use super::WHILE_LET_ON_ITERATOR;\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{\n+    get_enclosing_block, get_trait_def_id, implements_trait, is_refutable, last_path_segment, match_trait_method,\n+    path_to_local, path_to_local_id, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ExprKind, HirId, MatchSource, Node, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn check_while_let_on_iterator(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+        let pat = &arms[0].pat.kind;\n+        if let (\n+            &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+            &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n+        ) = (pat, &match_expr.kind)\n+        {\n+            let iter_expr = &method_args[0];\n+\n+            // Don't lint when the iterator is recreated on every iteration\n+            if_chain! {\n+                if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n+                if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+                if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let lhs_constructor = last_path_segment(qpath);\n+            if method_path.ident.name == sym::next\n+                && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                && lhs_constructor.ident.name == sym::Some\n+                && (pat_args.is_empty()\n+                    || !is_refutable(cx, &pat_args[0])\n+                        && !is_used_inside(cx, iter_expr, &arms[0].body)\n+                        && !is_iterator_used_after_while_let(cx, iter_expr)\n+                        && !is_nested(cx, expr, &method_args[0]))\n+            {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n+                let loop_var = if pat_args.is_empty() {\n+                    \"_\".to_string()\n+                } else {\n+                    snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n+                };\n+                span_lint_and_sugg(\n+                    cx,\n+                    WHILE_LET_ON_ITERATOR,\n+                    expr.span.with_hi(match_expr.span.hi()),\n+                    \"this loop could be written as a `for` loop\",\n+                    \"try\",\n+                    format!(\"for {} in {}\", loop_var, iterator),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    if let Some(used_mutably) = mutated_variables(container, cx) {\n+        if used_mutably.contains(&def_id) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(iter_expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    let mut visitor = VarUsedAfterLoopVisitor {\n+        def_id,\n+        iter_expr_id: iter_expr.hir_id,\n+        past_while_let: false,\n+        var_used_after_while_let: false,\n+    };\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n+        walk_block(&mut visitor, enclosing_block);\n+    }\n+    visitor.var_used_after_while_let\n+}\n+\n+fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n+        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n+        then {\n+            return is_loop_nested(cx, loop_expr, iter_expr)\n+        }\n+    }\n+    false\n+}\n+\n+fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    let mut id = loop_expr.hir_id;\n+    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n+        id\n+    } else {\n+        return true;\n+    };\n+    loop {\n+        let parent = cx.tcx.hir().get_parent_node(id);\n+        if parent == id {\n+            return false;\n+        }\n+        match cx.tcx.hir().find(parent) {\n+            Some(Node::Expr(expr)) => {\n+                if let ExprKind::Loop(..) = expr.kind {\n+                    return true;\n+                };\n+            },\n+            Some(Node::Block(block)) => {\n+                let mut block_visitor = LoopNestVisitor {\n+                    hir_id: id,\n+                    iterator: iter_id,\n+                    nesting: Nesting::Unknown,\n+                };\n+                walk_block(&mut block_visitor, block);\n+                if block_visitor.nesting == Nesting::RuledOut {\n+                    return false;\n+                }\n+            },\n+            Some(Node::Stmt(_)) => (),\n+            _ => {\n+                return false;\n+            },\n+        }\n+        id = parent;\n+    }\n+}\n+\n+struct VarUsedAfterLoopVisitor {\n+    def_id: HirId,\n+    iter_expr_id: HirId,\n+    past_while_let: bool,\n+    var_used_after_while_let: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.past_while_let {\n+            if path_to_local_id(expr, self.def_id) {\n+                self.var_used_after_while_let = true;\n+            }\n+        } else if self.iter_expr_id == expr.hir_id {\n+            self.past_while_let = true;\n+        }\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}]}