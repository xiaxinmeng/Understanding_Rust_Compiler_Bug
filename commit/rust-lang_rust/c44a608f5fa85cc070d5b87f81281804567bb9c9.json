{"sha": "c44a608f5fa85cc070d5b87f81281804567bb9c9", "node_id": "C_kwDOAAsO6NoAKGM0NGE2MDhmNWZhODVjYzA3MGQ1Yjg3ZjgxMjgxODA0NTY3YmI5Yzk", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-05-31T18:26:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-31T18:26:30Z"}, "message": "Merge pull request #278 from rust-lang/feature/simd-traits\n\nMove element-specific functions to traits", "tree": {"sha": "e199a3ac7b06073f0362afd846597d5429545f06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e199a3ac7b06073f0362afd846597d5429545f06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c44a608f5fa85cc070d5b87f81281804567bb9c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJill3WCRBK7hj4Ov3rIwAANoYIAH/KWnFO/5gLmxI2LEgcGjOZ\n8/g1UrxyZsKmJuDSy1iWLZpq2RGQHTe1bE+7kEQVBu9zRXpaLLry3t8oejfs7ANL\njzCZPV4eRLSqySRc/RbMF6bmAH90xroML6b39WqMXY+xrbTMa8uaG56FaUGQljbX\n976uHh+X0p9aY397kYK86s1wr2ko7SgVot1vilIPlN/MdviFahR9Dbn1Q2ZcHwr4\nmE8sWamKRoh3g6fWD/mpZB40R0bRuk8TUgg1Rv/37wsiTChHgrHPcY/S3losMS46\n1YIWMbcGyjt30zHtj9ixgXNnA1n08L5+TqZSVzpJZPVLX7CLoH+rJevJ0szQdxY=\n=TITT\n-----END PGP SIGNATURE-----\n", "payload": "tree e199a3ac7b06073f0362afd846597d5429545f06\nparent 939914e39da859b82e904210db144bd67a41486e\nparent 62d3b2e39c3610046afd927843942cfdddab6753\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1654021590 -0400\ncommitter GitHub <noreply@github.com> 1654021590 -0400\n\nMerge pull request #278 from rust-lang/feature/simd-traits\n\nMove element-specific functions to traits"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c44a608f5fa85cc070d5b87f81281804567bb9c9", "html_url": "https://github.com/rust-lang/rust/commit/c44a608f5fa85cc070d5b87f81281804567bb9c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c44a608f5fa85cc070d5b87f81281804567bb9c9/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939914e39da859b82e904210db144bd67a41486e", "url": "https://api.github.com/repos/rust-lang/rust/commits/939914e39da859b82e904210db144bd67a41486e", "html_url": "https://github.com/rust-lang/rust/commit/939914e39da859b82e904210db144bd67a41486e"}, {"sha": "62d3b2e39c3610046afd927843942cfdddab6753", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d3b2e39c3610046afd927843942cfdddab6753", "html_url": "https://github.com/rust-lang/rust/commit/62d3b2e39c3610046afd927843942cfdddab6753"}], "stats": {"total": 1458, "additions": 777, "deletions": 681}, "files": [{"sha": "701eb66b248afb2877a08b10b3c0537d22dfc1db", "filename": "crates/core_simd/src/elements.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -0,0 +1,11 @@\n+mod float;\n+mod int;\n+mod uint;\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+pub use float::*;\n+pub use int::*;\n+pub use uint::*;"}, {"sha": "5a628f2121e1176a3cdedfcd2b6219239e3a69ab", "filename": "crates/core_simd/src/elements/float.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Ffloat.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -0,0 +1,344 @@\n+use super::sealed::Sealed;\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialEq, SimdPartialOrd,\n+    SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of floats.\n+pub trait SimdFloat: Copy + Sealed {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Bit representation of this SIMD vector type.\n+    type Bits;\n+\n+    /// Raw transmutation to an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Raw transmutation from an unsigned integer vector type with the\n+    /// same size and number of lanes.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn from_bits(bits: Self::Bits) -> Self;\n+\n+    /// Produces a vector where every lane has the absolute value of the\n+    /// equivalently-indexed lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn abs(self) -> Self;\n+\n+    /// Takes the reciprocal (inverse) of each lane, `1/x`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn recip(self) -> Self;\n+\n+    /// Converts each lane from radians to degrees.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_degrees(self) -> Self;\n+\n+    /// Converts each lane from degrees to radians.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn to_radians(self) -> Self;\n+\n+    /// Returns true for each lane if it has a positive sign, including\n+    /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if it has a negative sign, including\n+    /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_sign_negative(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_nan(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is positive infinity or negative infinity.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_infinite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_finite(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is subnormal.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_subnormal(self) -> Self::Mask;\n+\n+    /// Returns true for each lane if its value is neither zero, infinite,\n+    /// subnormal, nor `NaN`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn is_normal(self) -> Self::Mask;\n+\n+    /// Replaces each lane with a number that represents its sign.\n+    ///\n+    /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n+    /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n+    /// * `NAN` if the number is `NAN`\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn signum(self) -> Self;\n+\n+    /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n+    ///\n+    /// For any lane containing a `NAN`, a `NAN` with the sign of `sign` is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn copysign(self, sign: Self) -> Self;\n+\n+    /// Returns the minimum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_min(self, other: Self) -> Self;\n+\n+    /// Returns the maximum of each lane.\n+    ///\n+    /// If one of the values is `NAN`, then the other value is returned.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_max(self, other: Self) -> Self;\n+\n+    /// Restrict each lane to a certain interval unless it is NaN.\n+    ///\n+    /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+    /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+    /// than `min`.  Otherwise returns the lane in `self`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_sum(), 3.);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Reducing multiply.  Returns the product of the lanes of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([3., 4.]);\n+    /// assert_eq!(v.reduce_product(), 12.);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([1., 2.]);\n+    /// assert_eq!(v.reduce_max(), 2.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_max(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_max().is_nan());\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+    /// return either.\n+    ///\n+    /// This function will not return `NaN` unless all lanes are `NaN`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::f32x2;\n+    /// let v = f32x2::from_array([3., 7.]);\n+    /// assert_eq!(v.reduce_min(), 3.);\n+    ///\n+    /// // NaN values are skipped...\n+    /// let v = f32x2::from_array([1., f32::NAN]);\n+    /// assert_eq!(v.reduce_min(), 1.);\n+    ///\n+    /// // ...unless all values are NaN\n+    /// let v = f32x2::from_array([f32::NAN, f32::NAN]);\n+    /// assert!(v.reduce_min().is_nan());\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty { bits: $bits_ty:ty, mask: $mask_ty:ty }),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdFloat for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$mask_ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+            type Bits = Simd<$bits_ty, LANES>;\n+\n+            #[inline]\n+            fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            #[inline]\n+            fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Self::Bits>());\n+                unsafe { core::mem::transmute_copy(&bits) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                unsafe { intrinsics::simd_fabs(self) }\n+            }\n+\n+            #[inline]\n+            fn recip(self) -> Self {\n+                Self::splat(1.0) / self\n+            }\n+\n+            #[inline]\n+            fn to_degrees(self) -> Self {\n+                // to_degrees uses a special constant for better precision, so extract that constant\n+                self * Self::splat(Self::Scalar::to_degrees(1.))\n+            }\n+\n+            #[inline]\n+            fn to_radians(self) -> Self {\n+                self * Self::splat(Self::Scalar::to_radians(1.))\n+            }\n+\n+            #[inline]\n+            fn is_sign_positive(self) -> Self::Mask {\n+                !self.is_sign_negative()\n+            }\n+\n+            #[inline]\n+            fn is_sign_negative(self) -> Self::Mask {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.simd_gt(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_nan(self) -> Self::Mask {\n+                self.simd_ne(self)\n+            }\n+\n+            #[inline]\n+            fn is_infinite(self) -> Self::Mask {\n+                self.abs().simd_eq(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_finite(self) -> Self::Mask {\n+                self.abs().simd_lt(Self::splat(Self::Scalar::INFINITY))\n+            }\n+\n+            #[inline]\n+            fn is_subnormal(self) -> Self::Mask {\n+                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(Self::Scalar::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n+            }\n+\n+            #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+            fn is_normal(self) -> Self::Mask {\n+                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_nan().select(Self::splat(Self::Scalar::NAN), Self::splat(1.0).copysign(self))\n+            }\n+\n+            #[inline]\n+            fn copysign(self, sign: Self) -> Self {\n+                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n+                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n+                Self::from_bits(sign_bit | magnitude)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                unsafe { intrinsics::simd_fmin(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                unsafe { intrinsics::simd_fmax(self, other) }\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.simd_lt(min).select(min, x);\n+                x = x.simd_gt(max).select(max, x);\n+                x\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // LLVM sum is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().sum()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_add_ordered(self, 0.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // LLVM product is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().product()\n+                } else {\n+                    // Safety: `self` is a float vector\n+                    unsafe { intrinsics::simd_reduce_mul_ordered(self, 1.) }\n+                }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is a float vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { f32 { bits: u32, mask: i32 }, f64 { bits: u64, mask: i64 } }"}, {"sha": "787a07411467a68de8e6e63a8959793710e86ac3", "filename": "crates/core_simd/src/elements/int.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -0,0 +1,280 @@\n+use super::sealed::Sealed;\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialOrd, SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of signed integers.\n+pub trait SimdInt: Copy + Sealed {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+    /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+    /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Lanewise absolute value, implemented in Rust.\n+    /// Every lane becomes its absolute value.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+    /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n+    /// ```\n+    fn abs(self) -> Self;\n+\n+    /// Lanewise saturating absolute value, implemented in Rust.\n+    /// As abs(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n+    /// let unsat = xs.abs();\n+    /// let sat = xs.saturating_abs();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n+    /// ```\n+    fn saturating_abs(self) -> Self;\n+\n+    /// Lanewise saturating negation, implemented in Rust.\n+    /// As neg(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n+    /// let unsat = -x;\n+    /// let sat = x.saturating_neg();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n+    /// ```\n+    fn saturating_neg(self) -> Self;\n+\n+    /// Returns true for each positive lane and false if it is zero or negative.\n+    fn is_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each negative lane and false if it is zero or positive.\n+    fn is_negative(self) -> Self::Mask;\n+\n+    /// Returns numbers representing the sign of each lane.\n+    /// * `0` if the number is zero\n+    /// * `1` if the number is positive\n+    /// * `-1` if the number is negative\n+    fn signum(self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_sum(), 10);\n+    ///\n+    /// // SIMD integer addition is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 1, 0, 0]);\n+    /// assert_eq!(v.reduce_sum(), i32::MIN);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_product(), 24);\n+    ///\n+    /// // SIMD integer multiplication is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 2, 1, 1]);\n+    /// assert!(v.reduce_product() < i32::MAX);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_max(), 4);\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_min(), 1);\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdInt for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m) - m\n+            }\n+\n+            #[inline]\n+            fn saturating_abs(self) -> Self {\n+                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m).saturating_sub(m)\n+            }\n+\n+            #[inline]\n+            fn saturating_neg(self) -> Self {\n+                Self::splat(0).saturating_sub(self)\n+            }\n+\n+            #[inline]\n+            fn is_positive(self) -> Self::Mask {\n+                self.simd_gt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_negative(self) -> Self::Mask {\n+                self.simd_lt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_positive().select(\n+                    Self::splat(1),\n+                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n+                )\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { i8, i16, i32, i64, isize }"}, {"sha": "f9d43a1d19b064c4c1591e5a595f2384f9be128e", "filename": "crates/core_simd/src/elements/uint.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -0,0 +1,135 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Simd, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of unsigned integers.\n+pub trait SimdUint: Copy + Sealed {\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n+    /// assert_eq!(sat, max);\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n+    /// assert_eq!(sat, Simd::splat(0));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> Sealed for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+        }\n+\n+        impl<const LANES: usize> SimdUint for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { u8, u16, u32, u64, usize }"}, {"sha": "606021e983ed176b2c73c8117b9dde4f362bf808", "filename": "crates/core_simd/src/math.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/939914e39da859b82e904210db144bd67a41486e/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939914e39da859b82e904210db144bd67a41486e/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=939914e39da859b82e904210db144bd67a41486e", "patch": "@@ -1,156 +0,0 @@\n-use crate::simd::intrinsics::{simd_saturating_add, simd_saturating_sub};\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-macro_rules! impl_uint_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n-            /// assert_eq!(sat, max);\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n-            /// assert_eq!(sat, Simd::splat(0));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-        })+\n-    }\n-}\n-\n-macro_rules! impl_int_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n-            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n-            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-\n-            /// Lanewise absolute value, implemented in Rust.\n-            /// Every lane becomes its absolute value.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n-            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n-            /// ```\n-            #[inline]\n-            pub fn abs(self) -> Self {\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m) - m\n-            }\n-\n-            /// Lanewise saturating absolute value, implemented in Rust.\n-            /// As abs(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n-            /// let unsat = xs.abs();\n-            /// let sat = xs.saturating_abs();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_abs(self) -> Self {\n-                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m).saturating_sub(m)\n-            }\n-\n-            /// Lanewise saturating negation, implemented in Rust.\n-            /// As neg(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n-            /// let unsat = -x;\n-            /// let sat = x.saturating_neg();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_neg(self) -> Self {\n-                Self::splat(0).saturating_sub(self)\n-            }\n-        })+\n-    }\n-}\n-\n-impl_uint_arith! { u8, u16, u32, u64, usize }\n-impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "590b2e4a1531db34a4bb87d1b633f4128b2a1c75", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -1,6 +1,3 @@\n-#[macro_use]\n-mod reduction;\n-\n #[macro_use]\n mod swizzle;\n \n@@ -9,12 +6,12 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n+mod elements;\n mod eq;\n mod fmt;\n mod iter;\n mod lane_count;\n mod masks;\n-mod math;\n mod ops;\n mod ord;\n mod round;\n@@ -26,6 +23,7 @@ mod vendor;\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;"}, {"sha": "642ab319cdda05aa90211fb293147562151f91c4", "filename": "crates/core_simd/src/reduction.rs", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/939914e39da859b82e904210db144bd67a41486e/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939914e39da859b82e904210db144bd67a41486e/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=939914e39da859b82e904210db144bd67a41486e", "patch": "@@ -1,267 +0,0 @@\n-use crate::simd::intrinsics::{\n-    simd_reduce_add_ordered, simd_reduce_and, simd_reduce_max, simd_reduce_min,\n-    simd_reduce_mul_ordered, simd_reduce_or, simd_reduce_xor,\n-};\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n-use core::ops::{BitAnd, BitOr, BitXor};\n-\n-macro_rules! impl_integer_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_sum(), 10);\n-            ///\n-            /// // SIMD integer addition is always wrapping\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 1, 0, 0]);\")]\n-            #[doc = concat!(\"assert_eq!(v.reduce_sum(), \", stringify!($scalar), \"::MIN);\")]\n-            /// ```\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_add_ordered(self, 0) }\n-            }\n-\n-            /// Reducing wrapping multiply. Returns the product of the lanes of the vector, with wrapping multiplication.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_product(), 24);\n-            ///\n-            /// // SIMD integer multiplication is always wrapping\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 2, 1, 1]);\")]\n-            #[doc = concat!(\"assert!(v.reduce_product() < \", stringify!($scalar), \"::MAX);\")]\n-            /// ```\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_mul_ordered(self, 1) }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_max(), 4);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_min(), 1);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_reductions! { i8 }\n-impl_integer_reductions! { i16 }\n-impl_integer_reductions! { i32 }\n-impl_integer_reductions! { i64 }\n-impl_integer_reductions! { isize }\n-impl_integer_reductions! { u8 }\n-impl_integer_reductions! { u16 }\n-impl_integer_reductions! { u32 }\n-impl_integer_reductions! { u64 }\n-impl_integer_reductions! { usize }\n-\n-macro_rules! impl_float_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-\n-            /// Reducing add.  Returns the sum of the lanes of the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n-            /// assert_eq!(v.reduce_sum(), 3.);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // LLVM sum is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().sum()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_add_ordered(self, 0.) }\n-                }\n-            }\n-\n-            /// Reducing multiply.  Returns the product of the lanes of the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 4.]);\")]\n-            /// assert_eq!(v.reduce_product(), 12.);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // LLVM product is inaccurate on i586\n-                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_array().iter().product()\n-                } else {\n-                    // Safety: `self` is a float vector\n-                    unsafe { simd_reduce_mul_ordered(self, 1.) }\n-                }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.\n-            ///\n-            /// This function will not return `NaN` unless all lanes are `NaN`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., 2.]);\")]\n-            /// assert_eq!(v.reduce_max(), 2.);\n-            ///\n-            /// // NaN values are skipped...\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n-            /// assert_eq!(v.reduce_max(), 1.);\n-            ///\n-            /// // ...unless all values are NaN\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n-                stringify!($scalar), \"::NAN, \",\n-                stringify!($scalar), \"::NAN]);\"\n-            )]\n-            /// assert!(v.reduce_max().is_nan());\n-            /// ```\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            ///\n-            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n-            /// return either.\n-            ///\n-            /// This function will not return `NaN` unless all lanes are `NaN`.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x2;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([3., 7.]);\")]\n-            /// assert_eq!(v.reduce_min(), 3.);\n-            ///\n-            /// // NaN values are skipped...\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([1., \", stringify!($scalar), \"::NAN]);\")]\n-            /// assert_eq!(v.reduce_min(), 1.);\n-            ///\n-            /// // ...unless all values are NaN\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x2::from_array([\",\n-                stringify!($scalar), \"::NAN, \",\n-                stringify!($scalar), \"::NAN]);\"\n-            )]\n-            /// assert!(v.reduce_min().is_nan());\n-            /// ```\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is a float vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_float_reductions! { f32 }\n-impl_float_reductions! { f64 }\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitAnd<Self, Output = Self>,\n-    T: SimdElement + BitAnd<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_and(self) -> T {\n-        unsafe { simd_reduce_and(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitOr<Self, Output = Self>,\n-    T: SimdElement + BitOr<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_or(self) -> T {\n-        unsafe { simd_reduce_or(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitXor<Self, Output = Self>,\n-    T: SimdElement + BitXor<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_xor(self) -> T {\n-        unsafe { simd_reduce_xor(self) }\n-    }\n-}"}, {"sha": "f836c99b1e2dc41564f0e85ad648f5ad2d476c04", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 210, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -1,145 +1,6 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SimdPartialEq, SimdPartialOrd, SupportedLaneCount};\n-\n-/// Implements inherent methods for a float vector containing multiple\n-/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation.\n-macro_rules! impl_float_vector {\n-    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Raw transmutation to an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&self) }\n-            }\n-\n-            /// Raw transmutation from an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n-                unsafe { core::mem::transmute_copy(&bits) }\n-            }\n-\n-            /// Produces a vector where every lane has the absolute value of the\n-            /// equivalently-indexed lane in `self`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn abs(self) -> Self {\n-                unsafe { intrinsics::simd_fabs(self) }\n-            }\n-\n-            /// Takes the reciprocal (inverse) of each lane, `1/x`.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn recip(self) -> Self {\n-                Self::splat(1.0) / self\n-            }\n-\n-            /// Converts each lane from radians to degrees.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_degrees(self) -> Self {\n-                // to_degrees uses a special constant for better precision, so extract that constant\n-                self * Self::splat(<$type>::to_degrees(1.))\n-            }\n-\n-            /// Converts each lane from degrees to radians.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn to_radians(self) -> Self {\n-                self * Self::splat(<$type>::to_radians(1.))\n-            }\n-\n-            /// Returns true for each lane if it has a positive sign, including\n-            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n-                !self.is_sign_negative()\n-            }\n-\n-            /// Returns true for each lane if it has a negative sign, including\n-            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n-                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n-                sign_bits.simd_gt(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n-                self.simd_ne(self)\n-            }\n-\n-            /// Returns true for each lane if its value is positive infinity or negative infinity.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_eq(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_lt(Self::splat(<$type>::INFINITY))\n-            }\n-\n-            /// Returns true for each lane if its value is subnormal.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n-            }\n-\n-            /// Returns true for each lane if its value is neither zero, infinite,\n-            /// subnormal, nor `NaN`.\n-            #[inline]\n-            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n-                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n-            }\n-\n-            /// Replaces each lane with a number that represents its sign.\n-            ///\n-            /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n-            /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n-            /// * `NAN` if the number is `NAN`\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn signum(self) -> Self {\n-                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n-            }\n-\n-            /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n-            ///\n-            /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn copysign(self, sign: Self) -> Self {\n-                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n-                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n-                Self::from_bits(sign_bit | magnitude)\n-            }\n-        }\n-    };\n-}\n-\n-impl_float_vector! { f32, u32, i32 }\n-impl_float_vector! { f64, u64, i64 }\n+use crate::simd::Simd;\n \n /// A 64-bit SIMD vector with two elements of type `f32`.\n pub type f32x2 = Simd<f32, 2>;\n@@ -161,73 +22,3 @@ pub type f64x4 = Simd<f64, 4>;\n \n /// A 512-bit SIMD vector with eight elements of type `f64`.\n pub type f64x8 = Simd<f64, 8>;\n-\n-mod sealed {\n-    pub trait Sealed {}\n-}\n-use sealed::Sealed;\n-\n-/// SIMD operations on vectors of floating point numbers.\n-pub trait SimdFloat: Sized + Sealed {\n-    /// Returns the minimum of each lane.\n-    ///\n-    /// If one of the values is `NAN`, then the other value is returned.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_min(self, other: Self) -> Self;\n-\n-    /// Returns the maximum of each lane.\n-    ///\n-    /// If one of the values is `NAN`, then the other value is returned.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_max(self, other: Self) -> Self;\n-\n-    /// Restrict each lane to a certain interval unless it is NaN.\n-    ///\n-    /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n-    /// greater than `max`, and the corresponding lane in `min` if the lane is less\n-    /// than `min`.  Otherwise returns the lane in `self`.\n-    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-    fn simd_clamp(self, min: Self, max: Self) -> Self;\n-}\n-\n-macro_rules! impl_simd_float {\n-    { $($float:ty),* } => {\n-        $(\n-        impl <const LANES: usize> Sealed for Simd<$float, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-        }\n-\n-        impl <const LANES: usize> SimdFloat for Simd<$float, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            fn simd_min(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmin(self, other) }\n-            }\n-\n-            #[inline]\n-            fn simd_max(self, other: Self) -> Self {\n-                unsafe { intrinsics::simd_fmax(self, other) }\n-            }\n-\n-            #[inline]\n-            fn simd_clamp(self, min: Self, max: Self) -> Self {\n-                assert!(\n-                    min.simd_le(max).all(),\n-                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n-                );\n-                let mut x = self;\n-                x = x.simd_lt(min).select(min, x);\n-                x = x.simd_gt(max).select(max, x);\n-                x\n-            }\n-        }\n-        )*\n-    }\n-}\n-\n-impl_simd_float! { f32, f64 }"}, {"sha": "20e56c7dc6443bdca6b8922dc3659e4f554c665e", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -1,46 +1,6 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::{LaneCount, Mask, Simd, SimdPartialOrd, SupportedLaneCount};\n-\n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_integer_vector {\n-    { $type:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns true for each positive lane and false if it is zero or negative.\n-            #[inline]\n-            pub fn is_positive(self) -> Mask<$type, LANES> {\n-                self.simd_gt(Self::splat(0))\n-            }\n-\n-            /// Returns true for each negative lane and false if it is zero or positive.\n-            #[inline]\n-            pub fn is_negative(self) -> Mask<$type, LANES> {\n-                self.simd_lt(Self::splat(0))\n-            }\n-\n-            /// Returns numbers representing the sign of each lane.\n-            /// * `0` if the number is zero\n-            /// * `1` if the number is positive\n-            /// * `-1` if the number is negative\n-            #[inline]\n-            pub fn signum(self) -> Self {\n-                self.is_positive().select(\n-                    Self::splat(1),\n-                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_vector! { isize }\n-impl_integer_vector! { i16 }\n-impl_integer_vector! { i32 }\n-impl_integer_vector! { i64 }\n-impl_integer_vector! { i8 }\n+use crate::simd::Simd;\n \n /// A SIMD vector with two elements of type `isize`.\n pub type isizex2 = Simd<isize, 2>;"}, {"sha": "f759394d0758211d61abdb9dde5d1adbe150801e", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44a608f5fa85cc070d5b87f81281804567bb9c9/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=c44a608f5fa85cc070d5b87f81281804567bb9c9", "patch": "@@ -172,6 +172,7 @@ macro_rules! impl_common_integer_tests {\n macro_rules! impl_signed_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdInt;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -312,6 +313,7 @@ macro_rules! impl_signed_tests {\n macro_rules! impl_unsigned_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdUint;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -346,6 +348,7 @@ macro_rules! impl_unsigned_tests {\n macro_rules! impl_float_tests {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n+            use core_simd::SimdFloat;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -462,7 +465,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_min<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n                         &Vector::<LANES>::simd_min,\n@@ -486,7 +488,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_max<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n                         &Vector::<LANES>::simd_max,\n@@ -510,7 +511,6 @@ macro_rules! impl_float_tests {\n                 }\n \n                 fn simd_clamp<const LANES: usize>() {\n-                    use core_simd::simd::SimdFloat;\n                     test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n                         for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n                             if max < min {"}]}