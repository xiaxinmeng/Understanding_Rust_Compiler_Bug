{"sha": "7c72fd89f103a1629525b87d98b3adb4d1e6bd14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzJmZDg5ZjEwM2ExNjI5NTI1Yjg3ZDk4YjNhZGI0ZDFlNmJkMTQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T23:14:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T23:15:17Z"}, "message": "Add some docs to codemap", "tree": {"sha": "a0af1870c377c293dc9b78b4013f484b70836c3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0af1870c377c293dc9b78b4013f484b70836c3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c72fd89f103a1629525b87d98b3adb4d1e6bd14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c72fd89f103a1629525b87d98b3adb4d1e6bd14", "html_url": "https://github.com/rust-lang/rust/commit/7c72fd89f103a1629525b87d98b3adb4d1e6bd14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c72fd89f103a1629525b87d98b3adb4d1e6bd14/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af088529fbb4baf2fa4e71735c27ffa9edefd3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af088529fbb4baf2fa4e71735c27ffa9edefd3d", "html_url": "https://github.com/rust-lang/rust/commit/2af088529fbb4baf2fa4e71735c27ffa9edefd3d"}], "stats": {"total": 61, "additions": 48, "deletions": 13}, "files": [{"sha": "63750e6cd65fe4ceb79682e9d91365abb73d5d88", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7c72fd89f103a1629525b87d98b3adb4d1e6bd14/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c72fd89f103a1629525b87d98b3adb4d1e6bd14/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7c72fd89f103a1629525b87d98b3adb4d1e6bd14", "patch": "@@ -1,11 +1,15 @@\n-/*! A codemap is a thing that maps uints to file/line/column positions\n- * in a crate. This to make it possible to represent the positions\n- * with single-word things, rather than passing records all over the\n- * compiler.\n- *\n- * All represented positions are *absolute* positions within the codemap,\n- * not relative positions within a single file.\n- */\n+/*!\n+\n+The CodeMap tracks all the source code used within a single crate, mapping\n+from integer byte positions to the original source code location. Each bit of\n+source parsed during crate parsing (typically files, in-memory strings, or\n+various bits of macro expansion) cover a continuous range of bytes in the\n+CodeMap and are represented by FileMaps. Byte positions are stored in `spans`\n+and used pervasively in the compiler. They are absolute positions within the\n+CodeMap, which upon request can be converted to line and column information,\n+source code snippets, etc.\n+\n+*/\n \n use dvec::DVec;\n use std::serialization::{Serializable,\n@@ -18,9 +22,16 @@ trait Pos {\n     pure fn to_uint(&self) -> uint;\n }\n \n+/// A byte offset\n pub enum BytePos = uint;\n+/// A character offset. Because of multibyte utf8 characters, a byte offset\n+/// is not equivalent to a character offset. The CodeMap will convert BytePos\n+/// values to CharPos values as necessary.\n pub enum CharPos = uint;\n \n+// XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n+// have been unsuccessful\n+\n impl BytePos: Pos {\n     static pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n@@ -117,6 +128,12 @@ impl CharPos: to_bytes::IterBytes {\n     }\n }\n \n+/**\n+Spans represent a region of code, used for error reporting. Positions in spans\n+are *absolute* positions from the beginning of the codemap, not positions\n+relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n+to the original source.\n+*/\n pub struct span {\n     lo: BytePos,\n     hi: BytePos,\n@@ -141,10 +158,17 @@ impl<D: Deserializer> span: Deserializable<D> {\n     }\n }\n \n+/// A source code location used for error reporting\n pub struct Loc {\n-    file: @FileMap, line: uint, col: CharPos\n+    /// Information about the original source\n+    file: @FileMap,\n+    /// The (1-based) line number\n+    line: uint,\n+    /// The (0-based) column offset\n+    col: CharPos\n }\n \n+/// Extra information for tracking macro expansion of spans\n pub enum ExpnInfo {\n     ExpandedFrom({call_site: span,\n                   callie: {name: ~str, span: Option<span>}})\n@@ -174,12 +198,21 @@ pub struct MultiByteChar {\n     sum: uint\n }\n \n+/// A single source in the CodeMap\n pub struct FileMap {\n+    /// The name of the file that the source came from, source that doesn't\n+    /// originate from files has names between angle brackets by convention,\n+    /// e.g. `<anon>`\n     name: FileName,\n+    /// Extra information used by qquote\n     substr: FileSubstr,\n+    /// The complete source code\n     src: @~str,\n+    /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n+    /// Locations of lines beginnings in the source code\n     mut lines: ~[BytePos],\n+    /// Locations of multi-byte characters in the source code\n     multibyte_chars: DVec<MultiByteChar>\n }\n \n@@ -226,6 +259,11 @@ pub impl CodeMap {\n         }\n     }\n \n+    /// Add a new FileMap to the CodeMap and return it\n+    fn new_filemap(+filename: FileName, src: @~str) -> @FileMap {\n+        return self.new_filemap_w_substr(filename, FssNone, src);\n+    }\n+\n     fn new_filemap_w_substr(+filename: FileName, +substr: FileSubstr,\n                             src: @~str) -> @FileMap {\n         let start_pos = if self.files.len() == 0 {\n@@ -248,16 +286,13 @@ pub impl CodeMap {\n         return filemap;\n     }\n \n-    fn new_filemap(+filename: FileName, src: @~str) -> @FileMap {\n-        return self.new_filemap_w_substr(filename, FssNone, src);\n-    }\n-\n     pub fn mk_substr_filename(&self, sp: span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n         return fmt!(\"<%s:%u:%u>\", pos.file.name,\n                     pos.line, pos.col.to_uint());\n     }\n \n+    /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, +pos: BytePos) -> Loc {\n         return self.lookup_pos(pos);\n     }"}]}