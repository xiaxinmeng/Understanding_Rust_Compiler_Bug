{"sha": "647ae50ce69e1714faebc4e2a4d252536a5663d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0N2FlNTBjZTY5ZTE3MTRmYWViYzRlMmE0ZDI1MjUzNmE1NjYzZDg=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-23T09:09:32Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-23T09:09:32Z"}, "message": "take predicates by value instead of by reference", "tree": {"sha": "9f37303f468017c38b149551653f798fa1b96ff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f37303f468017c38b149551653f798fa1b96ff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/647ae50ce69e1714faebc4e2a4d252536a5663d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/647ae50ce69e1714faebc4e2a4d252536a5663d8", "html_url": "https://github.com/rust-lang/rust/commit/647ae50ce69e1714faebc4e2a4d252536a5663d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/647ae50ce69e1714faebc4e2a4d252536a5663d8/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "html_url": "https://github.com/rust-lang/rust/commit/7f940ef5d91b53e889f111f27e00849f2f5ae4a2"}], "stats": {"total": 125, "additions": 58, "deletions": 67}, "files": [{"sha": "09a90516e91971158a1e0be5f8cc4dcb6e2c20db", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -1011,7 +1011,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        predicate: &ty::PolySubtypePredicate<'tcx>,\n+        predicate: ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n@@ -1034,7 +1034,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         Some(self.commit_if_ok(|snapshot| {\n             let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -1047,11 +1047,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn region_outlives_predicate(\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n-        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+        predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });"}, {"sha": "cac1d2f050efcf05bac31c38e449294f4c5e8257", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -223,7 +223,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // like `T` and `T::Item`. It may not work as well for things\n         // like `<T as Foo<'a>>::Item`.\n         let c_b = self.param_env.caller_bounds;\n-        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b.into_iter());\n+        let param_bounds =\n+            self.collect_outlives_from_predicate_list(&compare_ty, c_b.into_iter().copied());\n \n         // Next, collect regions we scraped from the well-formedness\n         // constraints in the fn signature. To do that, we walk the list\n@@ -334,10 +335,10 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn collect_outlives_from_predicate_list(\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-        predicates: impl Iterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+        predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         predicates\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }"}, {"sha": "03f20c13068a8e114a0de8e03f409f23cf18264c", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -8,7 +8,7 @@ use rustc_span::Span;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n+    pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n     match pred.kind() {\n         &ty::PredicateKind::Trait(ref data, constness) => {\n@@ -66,7 +66,7 @@ impl PredicateSet<'tcx> {\n         Self { tcx, set: Default::default() }\n     }\n \n-    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+    fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n         // We have to be careful here because we want\n         //\n         //    for<'a> Foo<&'a int>\n@@ -81,10 +81,10 @@ impl PredicateSet<'tcx> {\n     }\n }\n \n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+impl Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n+    fn extend<I: IntoIterator<Item = ty::Predicate<'tcx>>>(&mut self, iter: I) {\n         for pred in iter {\n-            self.insert(pred.as_ref());\n+            self.insert(pred);\n         }\n     }\n }\n@@ -132,7 +132,7 @@ pub fn elaborate_obligations<'tcx>(\n     mut obligations: Vec<PredicateObligation<'tcx>>,\n ) -> Elaborator<'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n-    obligations.retain(|obligation| visited.insert(&obligation.predicate));\n+    obligations.retain(|obligation| visited.insert(obligation.predicate));\n     Elaborator { stack: obligations, visited }\n }\n \n@@ -172,7 +172,7 @@ impl Elaborator<'tcx> {\n                 // cases. One common case is when people define\n                 // `trait Sized: Sized { }` rather than `trait Sized { }`.\n                 let visited = &mut self.visited;\n-                let obligations = obligations.filter(|o| visited.insert(&o.predicate));\n+                let obligations = obligations.filter(|o| visited.insert(o.predicate));\n \n                 self.stack.extend(obligations);\n             }\n@@ -260,7 +260,7 @@ impl Elaborator<'tcx> {\n                             }\n                         })\n                         .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n-                        .filter(|predicate| visited.insert(predicate))\n+                        .filter(|&predicate| visited.insert(predicate))\n                         .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }"}, {"sha": "877784bc506663d4727cf77a081e74bbffe7e9cf", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -1094,12 +1094,6 @@ pub struct CratePredicatesMap<'tcx> {\n     pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n }\n \n-impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n-    fn as_ref(&self) -> &Predicate<'tcx> {\n-        self\n-    }\n-}\n-\n impl<'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n@@ -1214,17 +1208,17 @@ pub struct TraitPredicate<'tcx> {\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         self.trait_ref.def_id\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> DefId {\n+    pub fn def_id(self) -> DefId {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }"}, {"sha": "0d986e60ff4889eb460c569dbdca24d4f2d5fc52", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -768,12 +768,12 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateKind::RegionOutlives(ref binder) => {\n+                &ty::PredicateKind::RegionOutlives(binder) => {\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                ty::PredicateKind::TypeOutlives(ref binder) => {\n+                &ty::PredicateKind::TypeOutlives(binder) => {\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "8d514b94c0fe803979b8e470311703c0b0d0ee4b", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -146,9 +146,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             continue;\n                         }\n \n-                        if self.error_implies(&error2.predicate, &error.predicate)\n+                        if self.error_implies(error2.predicate, error.predicate)\n                             && !(error2.index >= error.index\n-                                && self.error_implies(&error.predicate, &error2.predicate))\n+                                && self.error_implies(error.predicate, error2.predicate))\n                         {\n                             info!(\"skipping {:?} (implied by {:?})\", error, error2);\n                             is_suppressed[index] = true;\n@@ -500,7 +500,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ty::PredicateKind::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n-                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .region_outlives_predicate(&obligation.cause, predicate)\n                             .err()\n                             .unwrap();\n                         struct_span_err!(\n@@ -955,7 +955,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n trait InferCtxtPrivExt<'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool;\n+    fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool;\n \n     fn report_fulfillment_error(\n         &self,\n@@ -1042,7 +1042,7 @@ trait InferCtxtPrivExt<'tcx> {\n impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+    fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool {\n         if cond == error {\n             return true;\n         }\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n+        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n             if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();"}, {"sha": "896c4ead2df36bf97b1ad31e98d5fbff01093edf", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::RegionOutlives(ref binder) => {\n+            &ty::PredicateKind::RegionOutlives(binder) => {\n                 match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n@@ -481,7 +481,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Subtype(subtype) => {\n+            &ty::PredicateKind::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,"}, {"sha": "72f089ae2a74a23d06efec59b2774ff3b0f3ec8b", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -1541,14 +1541,14 @@ fn assoc_ty_def(\n crate trait ProjectionCacheKeyExt<'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self>;\n }\n \n impl<'tcx> ProjectionCacheKeyExt<'tcx> for ProjectionCacheKey<'tcx> {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,"}, {"sha": "05402fe3c194dbd576e58fdaf38ddec2fdc568a4", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -415,13 +415,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(t, _) => {\n+            &ty::PredicateKind::Trait(t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n-                let obligation = obligation.with(*t);\n+                let obligation = obligation.with(t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            ty::PredicateKind::Subtype(p) => {\n+            &ty::PredicateKind::Subtype(p) => {\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -463,8 +463,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Projection(data) => {\n-                let project_obligation = obligation.with(*data);\n+            &ty::PredicateKind::Projection(data) => {\n+                let project_obligation = obligation.with(data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n                         self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n@@ -962,7 +962,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n \n         if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, &cache_fresh_trait_pred)\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n         {\n             debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n             return c;\n@@ -1247,7 +1247,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn check_candidate_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n-        cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>,\n+        cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>> {\n         let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;"}, {"sha": "f6f0c62c120f1c703f5e9c04636dd132b235b3ff", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -108,9 +108,9 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         }\n \n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n-        let anon_pred = anonymize_predicate(tcx, &pred);\n+        let anon_pred = anonymize_predicate(tcx, pred);\n         if item.path.iter().rev().skip(1).any(|(tr, _)| {\n-            anonymize_predicate(tcx, &tr.without_const().to_predicate(tcx)) == anon_pred\n+            anonymize_predicate(tcx, tr.without_const().to_predicate(tcx)) == anon_pred\n         }) {\n             return false;\n         }"}, {"sha": "714ca7a30cff63b26fbef84f7d25d69cc503cf20", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -66,7 +66,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n-    predicate: &ty::Predicate<'tcx>,\n+    predicate: ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };"}, {"sha": "e0a02ff8462a67834e31f3d2e48d3a3155bd1539", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n-                    self.deduce_sig_from_projection(None, &pb)\n+                    self.deduce_sig_from_projection(None, pb)\n                 });\n                 let kind = object_type\n                     .principal_def_id()\n@@ -206,8 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let ty::PredicateKind::Projection(ref proj_predicate) =\n-                    obligation.predicate.kind()\n+                if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n@@ -238,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_sig_from_projection(\n         &self,\n         cause_span: Option<Span>,\n-        projection: &ty::PolyProjectionPredicate<'tcx>,\n+        projection: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n@@ -644,7 +643,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate.kind() {\n+            if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind() {\n                 self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n             } else {\n                 None\n@@ -665,7 +664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_future_output_from_projection(\n         &self,\n         cause_span: Span,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+        predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         debug!(\"deduce_future_output_from_projection(predicate={:?})\", predicate);\n "}, {"sha": "8c658923f0c5112965676179602f38a155f55840", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -205,7 +205,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // just to look for all the predicates directly.\n \n     assert_eq!(dtor_predicates.parent, None);\n-    for (predicate, predicate_sp) in dtor_predicates.predicates {\n+    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of\n@@ -228,7 +228,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // This implementation solves (Issue #59497) and (Issue #58311).\n         // It is unclear to me at the moment whether the approach based on `relate`\n         // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n+        let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate.kind(), p.kind()) {\n                 (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n@@ -241,12 +241,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             }\n         };\n \n-        if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n+        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n             let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n             struct_span_err!(\n                 tcx.sess,\n-                *predicate_sp,\n+                predicate_sp,\n                 E0367,\n                 \"`Drop` impl requires `{}` but the {} it is implemented for does not\",\n                 predicate,"}, {"sha": "06e2d99983b0dbdbe0e7d33119f703aeeed19355", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -819,8 +819,8 @@ fn check_where_clauses<'tcx, 'fcx>(\n     debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n-        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(p, sp)| {\n-            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, *sp)\n+        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(&p, &sp)| {\n+            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n         });\n \n     for obligation in wf_obligations.chain(default_obligations) {"}, {"sha": "b262ccf913a6891990b05b492d613778a43cae0c", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647ae50ce69e1714faebc4e2a4d252536a5663d8/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=647ae50ce69e1714faebc4e2a4d252536a5663d8", "patch": "@@ -329,16 +329,13 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates\n-        .predicates\n-        .iter()\n-        .filter(|predicate| {\n+    let always_applicable_traits =\n+        impl1_predicates.predicates.iter().copied().filter(|&predicate| {\n             matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::AlwaysApplicable)\n             )\n-        })\n-        .copied();\n+        });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n@@ -361,12 +358,12 @@ fn check_predicates<'tcx>(\n \n     for predicate in impl1_predicates.predicates {\n         if !impl2_predicates.predicates.contains(&predicate) {\n-            check_specialization_on(tcx, &predicate, span)\n+            check_specialization_on(tcx, predicate, span)\n         }\n     }\n }\n \n-fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n+fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n     match predicate.kind() {\n         // Global predicates are either always true or always false, so we\n@@ -399,7 +396,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'t\n \n fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicate: &ty::Predicate<'tcx>,\n+    predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate.kind() {\n         ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {"}]}