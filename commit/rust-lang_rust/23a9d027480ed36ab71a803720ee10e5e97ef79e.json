{"sha": "23a9d027480ed36ab71a803720ee10e5e97ef79e", "node_id": "C_kwDOAAsO6NoAKDIzYTlkMDI3NDgwZWQzNmFiNzFhODAzNzIwZWUxMGU1ZTk3ZWY3OWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T14:51:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T14:51:53Z"}, "message": "Auto merge of #1933 - 5225225:1931-condvar-false-positive, r=RalfJung\n\nFix false positive use of uninit bytes when calling `libc::pthread_condattr_destroy`\n\nFixes: #1931", "tree": {"sha": "bf532c475cecb0c63095d5109aeb8593afd41864", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf532c475cecb0c63095d5109aeb8593afd41864"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23a9d027480ed36ab71a803720ee10e5e97ef79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23a9d027480ed36ab71a803720ee10e5e97ef79e", "html_url": "https://github.com/rust-lang/rust/commit/23a9d027480ed36ab71a803720ee10e5e97ef79e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23a9d027480ed36ab71a803720ee10e5e97ef79e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81e59e6b92cf1729aabbbbf09b81a81a03775d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/81e59e6b92cf1729aabbbbf09b81a81a03775d64", "html_url": "https://github.com/rust-lang/rust/commit/81e59e6b92cf1729aabbbbf09b81a81a03775d64"}, {"sha": "fd830e7b278063c93c57028b9469875fb36718a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd830e7b278063c93c57028b9469875fb36718a6", "html_url": "https://github.com/rust-lang/rust/commit/fd830e7b278063c93c57028b9469875fb36718a6"}], "stats": {"total": 184, "additions": 165, "deletions": 19}, "files": [{"sha": "ea940df1c6e8909bd6471c27dcaef7403266e9b5", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -186,7 +186,12 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     attr_op: &OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(attr_op, 0, clock_id, ecx.machine.layouts.i32)\n+    ecx.write_scalar_at_offset(\n+        attr_op,\n+        0,\n+        clock_id,\n+        layout_of_maybe_uninit(ecx.tcx, ecx.machine.layouts.i32.ty),\n+    )\n }\n \n // pthread_cond_t\n@@ -359,6 +364,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_mutexattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n+        // Destroying an uninit pthread_mutexattr is UB, so check to make sure it's not uninit.\n+        mutexattr_get_kind(this, attr_op)?.check_init()?;\n+\n+        // To catch double-destroys, we de-initialize the mutexattr.\n+        // This is technically not right and might lead to false positives. For example, the below\n+        // code is *likely* sound, even assuming uninit numbers are UB, but miri with\n+        // -Zmiri-check-number-validity complains\n+        //\n+        // let mut x: MaybeUninit<libc::pthread_mutexattr_t> = MaybeUninit::zeroed();\n+        // libc::pthread_mutexattr_init(x.as_mut_ptr());\n+        // libc::pthread_mutexattr_destroy(x.as_mut_ptr());\n+        // x.assume_init();\n+        //\n+        // However, the way libstd uses the pthread APIs works in our favor here, so we can get away with this.\n+        // This can always be revisited to have some external state to catch double-destroys\n+        // but not complain about the above code. See https://github.com/rust-lang/miri/pull/1933\n+\n         mutexattr_set_kind(this, attr_op, ScalarMaybeUninit::Uninit)?;\n \n         Ok(0)\n@@ -497,6 +519,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_ub_format!(\"destroyed a locked mutex\");\n         }\n \n+        // Destroying an uninit pthread_mutex is UB, so check to make sure it's not uninit.\n+        mutex_get_kind(this, mutex_op)?.check_init()?;\n+        mutex_get_id(this, mutex_op)?.check_init()?;\n+\n+        // This might lead to false positives, see comment in pthread_mutexattr_destroy\n         mutex_set_kind(this, mutex_op, ScalarMaybeUninit::Uninit)?;\n         mutex_set_id(this, mutex_op, ScalarMaybeUninit::Uninit)?;\n         // FIXME: delete interpreter state associated with this mutex.\n@@ -598,6 +625,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_ub_format!(\"destroyed a locked rwlock\");\n         }\n \n+        // Destroying an uninit pthread_rwlock is UB, so check to make sure it's not uninit.\n+        rwlock_get_id(this, rwlock_op)?.check_init()?;\n+\n+        // This might lead to false positives, see comment in pthread_mutexattr_destroy\n         rwlock_set_id(this, rwlock_op, ScalarMaybeUninit::Uninit)?;\n         // FIXME: delete interpreter state associated with this rwlock.\n \n@@ -652,6 +683,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_condattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n+        // Destroying an uninit pthread_condattr is UB, so check to make sure it's not uninit.\n+        condattr_get_clock_id(this, attr_op)?.check_init()?;\n+\n+        // This might lead to false positives, see comment in pthread_mutexattr_destroy\n         condattr_set_clock_id(this, attr_op, ScalarMaybeUninit::Uninit)?;\n \n         Ok(0)\n@@ -789,6 +824,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }\n+\n+        // Destroying an uninit pthread_cond is UB, so check to make sure it's not uninit.\n+        cond_get_id(this, cond_op)?.check_init()?;\n+        cond_get_clock_id(this, cond_op)?.check_init()?;\n+\n+        // This might lead to false positives, see comment in pthread_mutexattr_destroy\n         cond_set_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n         cond_set_clock_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n         // FIXME: delete interpreter state associated with this condvar."}, {"sha": "c376618357d27b696f24d9f4e63afb5716ca3abd", "filename": "tests/compile-fail/sync/libc_pthread_cond_double_destroy.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -0,0 +1,22 @@\n+// ignore-windows: No libc on Windows\n+#![feature(rustc_private)]\n+\n+/// Test that destroying a pthread_cond twice fails, even without a check for number validity\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        use core::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+        libc::pthread_condattr_init(attr.as_mut_ptr());\n+\n+        let mut cond = MaybeUninit::<libc::pthread_cond_t>::uninit();\n+\n+        libc::pthread_cond_init(cond.as_mut_ptr(), attr.as_ptr());\n+\n+        libc::pthread_cond_destroy(cond.as_mut_ptr());\n+\n+        libc::pthread_cond_destroy(cond.as_mut_ptr());\n+        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+    }\n+}"}, {"sha": "44af51a3e8711661a478cb6b2f08da11c2bf9f96", "filename": "tests/compile-fail/sync/libc_pthread_condattr_double_destroy.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -0,0 +1,19 @@\n+// ignore-windows: No libc on Windows\n+#![feature(rustc_private)]\n+\n+/// Test that destroying a pthread_condattr twice fails, even without a check for number validity\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        use core::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+\n+        libc::pthread_condattr_init(attr.as_mut_ptr());\n+\n+        libc::pthread_condattr_destroy(attr.as_mut_ptr());\n+\n+        libc::pthread_condattr_destroy(attr.as_mut_ptr());\n+        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+    }\n+}"}, {"sha": "08abc0ca12c5bd59176844a6a4337f38653d8d28", "filename": "tests/compile-fail/sync/libc_pthread_mutex_double_destroy.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -0,0 +1,23 @@\n+// ignore-windows: No libc on Windows\n+#![feature(rustc_private)]\n+\n+/// Test that destroying a pthread_mutex twice fails, even without a check for number validity\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        use core::mem::MaybeUninit;\n+\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        libc::pthread_mutexattr_init(attr.as_mut_ptr());\n+\n+        let mut mutex = MaybeUninit::<libc::pthread_mutex_t>::uninit();\n+\n+        libc::pthread_mutex_init(mutex.as_mut_ptr(), attr.as_ptr());\n+\n+        libc::pthread_mutex_destroy(mutex.as_mut_ptr());\n+\n+        libc::pthread_mutex_destroy(mutex.as_mut_ptr());\n+        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+    }\n+}"}, {"sha": "69ca3ad512fa2852a8313740f70cd8814a476a70", "filename": "tests/compile-fail/sync/libc_pthread_mutexattr_double_destroy.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -0,0 +1,19 @@\n+// ignore-windows: No libc on Windows\n+#![feature(rustc_private)]\n+\n+/// Test that destroying a pthread_mutexattr twice fails, even without a check for number validity\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        use core::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+\n+        libc::pthread_mutexattr_init(attr.as_mut_ptr());\n+\n+        libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n+\n+        libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n+        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+    }\n+}"}, {"sha": "d20c78155fd2c25d7f7f2921ee5b569b8f6e3a5e", "filename": "tests/compile-fail/sync/libc_pthread_rwlock_double_destroy.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+#![feature(rustc_private)]\n+\n+/// Test that destroying a pthread_rwlock twice fails, even without a check for number validity\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mut lock = libc::PTHREAD_RWLOCK_INITIALIZER;\n+\n+        libc::pthread_rwlock_destroy(&mut lock);\n+\n+        libc::pthread_rwlock_destroy(&mut lock);\n+        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+    }\n+}"}, {"sha": "0e09ec9126a54ac6ed63f20ca896b1b6a736f022", "filename": "tests/run-pass/concurrency/libc_pthread_cond.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -1,46 +1,47 @@\n // ignore-windows: No libc on Windows\n // ignore-macos: pthread_condattr_setclock is not supported on MacOS.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-check-number-validity\n \n #![feature(rustc_private)]\n \n /// Test that conditional variable timeouts are working properly with both\n /// monotonic and system clocks.\n extern crate libc;\n \n-use std::mem;\n+use std::mem::MaybeUninit;\n use std::time::Instant;\n \n fn test_timed_wait_timeout(clock_id: i32) {\n     unsafe {\n-        let mut attr: libc::pthread_condattr_t = mem::zeroed();\n-        assert_eq!(libc::pthread_condattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, clock_id), 0);\n+        let mut attr: MaybeUninit<libc::pthread_condattr_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_condattr_init(attr.as_mut_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(attr.as_mut_ptr(), clock_id), 0);\n \n-        let mut cond: libc::pthread_cond_t = mem::zeroed();\n-        assert_eq!(libc::pthread_cond_init(&mut cond as *mut _, &attr as *const _), 0);\n-        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n+        let mut cond: MaybeUninit<libc::pthread_cond_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_cond_init(cond.as_mut_ptr(), attr.as_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_destroy(attr.as_mut_ptr()), 0);\n \n-        let mut mutex: libc::pthread_mutex_t = mem::zeroed();\n+        let mut mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n \n-        let mut now: libc::timespec = mem::zeroed();\n-        assert_eq!(libc::clock_gettime(clock_id, &mut now), 0);\n+        let mut now_mu: MaybeUninit<libc::timespec> = MaybeUninit::uninit();\n+        assert_eq!(libc::clock_gettime(clock_id, now_mu.as_mut_ptr()), 0);\n+        let now = now_mu.assume_init();\n         // Waiting for a second... mostly because waiting less requires mich more tricky arithmetic.\n         // FIXME: wait less.\n         let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n \n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n         let current_time = Instant::now();\n         assert_eq!(\n-            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n             libc::ETIMEDOUT\n         );\n         let elapsed_time = current_time.elapsed().as_millis();\n         assert!(900 <= elapsed_time && elapsed_time <= 1300);\n \n         // Test calling `pthread_cond_timedwait` again with an already elapsed timeout.\n         assert_eq!(\n-            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n             libc::ETIMEDOUT\n         );\n \n@@ -49,7 +50,7 @@ fn test_timed_wait_timeout(clock_id: i32) {\n         let invalid_timeout_1 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: 1_000_000_000 };\n         assert_eq!(\n             libc::pthread_cond_timedwait(\n-                &mut cond as *mut _,\n+                cond.as_mut_ptr(),\n                 &mut mutex as *mut _,\n                 &invalid_timeout_1\n             ),\n@@ -58,7 +59,7 @@ fn test_timed_wait_timeout(clock_id: i32) {\n         let invalid_timeout_2 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: -1 };\n         assert_eq!(\n             libc::pthread_cond_timedwait(\n-                &mut cond as *mut _,\n+                cond.as_mut_ptr(),\n                 &mut mutex as *mut _,\n                 &invalid_timeout_2\n             ),\n@@ -68,7 +69,7 @@ fn test_timed_wait_timeout(clock_id: i32) {\n         let invalid_timeout_3 = libc::timespec { tv_sec: -1, tv_nsec: 0 };\n         assert_eq!(\n             libc::pthread_cond_timedwait(\n-                &mut cond as *mut _,\n+                cond.as_mut_ptr(),\n                 &mut mutex as *mut _,\n                 &invalid_timeout_3\n             ),\n@@ -77,7 +78,7 @@ fn test_timed_wait_timeout(clock_id: i32) {\n \n         assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n         assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);\n+        assert_eq!(libc::pthread_cond_destroy(cond.as_mut_ptr()), 0);\n     }\n }\n "}, {"sha": "da6f6f25ec1cdfeaeb7faa1fcbfdeeafa356644c", "filename": "tests/run-pass/concurrency/sync.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a9d027480ed36ab71a803720ee10e5e97ef79e/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=23a9d027480ed36ab71a803720ee10e5e97ef79e", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-check-number-validity\n \n use std::sync::mpsc::{channel, sync_channel};\n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n@@ -340,6 +340,10 @@ fn park_unpark() {\n     assert!((200..1000).contains(&start.elapsed().as_millis()));\n }\n \n+fn check_condvar() {\n+    let _ = std::sync::Condvar::new();\n+}\n+\n fn main() {\n     check_barriers();\n     check_conditional_variables_notify_one();\n@@ -357,4 +361,5 @@ fn main() {\n     check_rwlock_unlock_bug2();\n     park_timeout();\n     park_unpark();\n+    check_condvar();\n }"}]}