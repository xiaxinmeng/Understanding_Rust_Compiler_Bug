{"sha": "0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOWUwZjJkODIwY2YyZjU1ZjhmYzc2MTk0MDE2ZmI1MTNhYzViOGM=", "commit": {"author": {"name": "Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-05T16:02:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-05T16:02:38Z"}, "message": "Merge pull request #510 from solson/rustup\n\nrustup: value -> immediate, by-value HasLayout, edition 2018", "tree": {"sha": "79543f5df85c295c41817a398e023272665be8ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79543f5df85c295c41817a398e023272665be8ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb4GmeCRBK7hj4Ov3rIwAAdHIIADQGUU7Kan/9XQia8NiTJko6\nO1oxfqEiLLzflhiAJeY6trTDYf/f99caEd9HERRu+m8ttq2DJj2YJm3fUbCQjfCg\nscjbnU6UdAQ50VgmJy5NZgueffFyAjo+BUkCLoz7Tm2gQtnM1EOHaOMS5fB2i79V\nPZvslAJXFGcI83D05CtfNK1TuBaYxe2T1tDreWcVukQ8wD106uTXfYaEUmrS8JIn\nXduKrm8a04Yxo9P8rvC/Z8psycRdnKuzHyFlRhubg9J4xTdnUo/Tk1X7FXc6IjB1\nPXPlTtJKgKeqvif/KHQsEf5Ao/rq21YcJVGHkw+CH5PShd+kQuwgZfDz+ncqRYM=\n=D8hf\n-----END PGP SIGNATURE-----\n", "payload": "tree 79543f5df85c295c41817a398e023272665be8ec\nparent c6ffcd0aa827712303f659d42526a007af74676e\nparent f6d6470bc4e332eadaba27d9c494f79aafd75a66\nauthor Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer <github35764891676564198441@oli-obk.de> 1541433758 +0100\ncommitter GitHub <noreply@github.com> 1541433758 +0100\n\nMerge pull request #510 from solson/rustup\n\nrustup: value -> immediate, by-value HasLayout, edition 2018"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "html_url": "https://github.com/rust-lang/rust/commit/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ffcd0aa827712303f659d42526a007af74676e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ffcd0aa827712303f659d42526a007af74676e", "html_url": "https://github.com/rust-lang/rust/commit/c6ffcd0aa827712303f659d42526a007af74676e"}, {"sha": "f6d6470bc4e332eadaba27d9c494f79aafd75a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d6470bc4e332eadaba27d9c494f79aafd75a66", "html_url": "https://github.com/rust-lang/rust/commit/f6d6470bc4e332eadaba27d9c494f79aafd75a66"}], "stats": {"total": 155, "additions": 78, "deletions": 77}, "files": [{"sha": "390efe0a073a1c560ca7b5a147f5f6105ab6a860", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -9,6 +9,7 @@ repository = \"https://github.com/solson/miri\"\n version = \"0.1.0\"\n build = \"build.rs\"\n default-run = \"miri\"\n+edition = \"2018\"\n \n [lib]\n test = true # we have unit tests"}, {"sha": "734df301d8e0eb76474d5642e0720c5550f0cc4c", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -1 +1 @@\n-nightly-2018-11-04\n+nightly-2018-11-05"}, {"sha": "c9ec1011ddbb94e1c9ebef7adb017110d78cd64b", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, extern_crate_item_prelude)]\n extern crate miri;\n extern crate getopts;\n extern crate rustc;"}, {"sha": "bfe631b51f0fdb81dc2e015f0ec82a3825187634", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, extern_crate_item_prelude)]\n \n extern crate getopts;\n extern crate miri;"}, {"sha": "d9bf049df704a1717784ee943195249409141c41", "filename": "src/fn_call.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n         match &link_name[..] {\n             \"malloc\" => {\n-                let size = self.read_scalar(args[0])?.to_usize(&self)?;\n+                let size = self.read_scalar(args[0])?.to_usize(self)?;\n                 if size == 0 {\n                     self.write_null(dest)?;\n                 } else {\n@@ -132,7 +132,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"free\" => {\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n-                if !ptr.is_null_ptr(&self) {\n+                if !ptr.is_null_ptr(self) {\n                     self.memory_mut().deallocate(\n                         ptr.to_ptr()?.with_default_tag(),\n                         None,\n@@ -142,8 +142,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"__rust_alloc\" => {\n-                let size = self.read_scalar(args[0])?.to_usize(&self)?;\n-                let align = self.read_scalar(args[1])?.to_usize(&self)?;\n+                let size = self.read_scalar(args[0])?.to_usize(self)?;\n+                let align = self.read_scalar(args[1])?.to_usize(self)?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -160,8 +160,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                let size = self.read_scalar(args[0])?.to_usize(&self)?;\n-                let align = self.read_scalar(args[1])?.to_usize(&self)?;\n+                let size = self.read_scalar(args[0])?.to_usize(self)?;\n+                let align = self.read_scalar(args[1])?.to_usize(self)?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -180,8 +180,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n             \"__rust_dealloc\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n-                let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n-                let align = self.read_scalar(args[2])?.to_usize(&self)?;\n+                let old_size = self.read_scalar(args[1])?.to_usize(self)?;\n+                let align = self.read_scalar(args[2])?.to_usize(self)?;\n                 if old_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -196,9 +196,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n             \"__rust_realloc\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n-                let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n-                let align = self.read_scalar(args[2])?.to_usize(&self)?;\n-                let new_size = self.read_scalar(args[3])?.to_usize(&self)?;\n+                let old_size = self.read_scalar(args[1])?.to_usize(self)?;\n+                let align = self.read_scalar(args[2])?.to_usize(self)?;\n+                let new_size = self.read_scalar(args[3])?.to_usize(self)?;\n                 if old_size == 0 || new_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -222,7 +222,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 //\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n-                match self.read_scalar(args[0])?.to_usize(&self)? {\n+                match self.read_scalar(args[0])?.to_usize(self)? {\n                     318 | 511 => {\n                         return err!(Unimplemented(\n                             \"miri does not support random number generators\".to_owned(),\n@@ -260,7 +260,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n                 let mir = self.load_mir(f_instance.def)?;\n-                let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, &self).into();\n+                let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, self).into();\n                 self.push_stack_frame(\n                     f_instance,\n                     mir.span,\n@@ -294,7 +294,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"memcmp\" => {\n                 let left = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                 let right = self.read_scalar(args[1])?.not_undef()?.erase_tag(); // raw ptr operation\n-                let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(&self)?);\n+                let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(self)?);\n \n                 let result = {\n                     let left_bytes = self.memory().read_bytes(left.with_default_tag(), n)?;\n@@ -318,11 +318,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n-                let num = self.read_scalar(args[2])?.to_usize(&self)?;\n+                let num = self.read_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?\n                     .iter().rev().position(|&c| c == val)\n                 {\n-                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), self)?;\n                     self.write_scalar(new_ptr, dest)?;\n                 } else {\n                     self.write_null(dest)?;\n@@ -333,12 +333,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n-                let num = self.read_scalar(args[2])?.to_usize(&self)?;\n+                let num = self.read_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), self)?;\n                     self.write_scalar(new_ptr, dest)?;\n                 } else {\n                     self.write_null(dest)?;\n@@ -351,7 +351,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     let name = self.memory().read_c_str(name_ptr.with_default_tag())?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::ptr_null(*self.tcx),\n+                        None => Scalar::ptr_null(&*self.tcx),\n                     }\n                 };\n                 self.write_scalar(result, dest)?;\n@@ -361,7 +361,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let mut success = None;\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n-                    if !name_ptr.is_null_ptr(&self) {\n+                    if !name_ptr.is_null_ptr(self) {\n                         let name = self.memory().read_c_str(name_ptr.to_ptr()?\n                             .with_default_tag())?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -385,7 +385,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n                     let value = self.memory().read_c_str(value_ptr.with_default_tag())?;\n-                    if !name_ptr.is_null_ptr(&self) {\n+                    if !name_ptr.is_null_ptr(self) {\n                         let name = self.memory().read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n@@ -400,7 +400,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                         MiriMemoryKind::Env.into(),\n                     )?.with_default_tag();\n                     self.memory_mut().write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n+                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), self)?.into();\n                     self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n@@ -510,7 +510,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let key_layout = self.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where key_ptr wants it\n-                let key = self.machine.tls.create_tls_key(dtor, *self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(dtor, &*self.tcx) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n@@ -555,7 +555,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n             \"pthread_attr_getstack\" => {\n                 // second argument is where we are supposed to write the stack size\n-                let ptr = self.ref_to_mplace(self.read_value(args[1])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[1])?)?;\n                 let stackaddr = Scalar::from_int(0x80000, args[1].layout.size); // just any address\n                 self.write_scalar(stackaddr, ptr.into())?;\n                 // return 0\n@@ -613,7 +613,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n                 // Create key and return it\n-                let key = self.machine.tls.create_tls_key(None, *self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(None, &*self.tcx) as u128;\n \n                 // Figure out how large a TLS key actually is. This is c::DWORD.\n                 if dest.layout.size.bits() < 128 && key >= (1u128 << dest.layout.size.bits() as u128) {"}, {"sha": "9aad6f95f316a4ebef4e8e0a726ad94cff6db786", "filename": "src/intrinsic.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n \n use crate::{\n-    PlaceTy, OpTy, Value, Scalar, ScalarMaybeUndef, Borrow,\n+    PlaceTy, OpTy, Immediate, Scalar, ScalarMaybeUndef, Borrow,\n     ScalarExt, OperatorEvalContextExt\n };\n \n@@ -38,13 +38,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"arith_offset\" => {\n-                let offset = self.read_scalar(args[1])?.to_isize(&self)?;\n+                let offset = self.read_scalar(args[1])?.to_isize(self)?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n \n                 let pointee_ty = substs.type_at(0);\n                 let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n                 let offset = offset.overflowing_mul(pointee_size).0;\n-                let result_ptr = ptr.ptr_wrapping_signed_offset(offset, &self);\n+                let result_ptr = ptr.ptr_wrapping_signed_offset(offset, self);\n                 self.write_scalar(result_ptr, dest)?;\n             }\n \n@@ -59,7 +59,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let val = self.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, dest)?;\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let val = self.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, ptr.into())?;\n             }\n@@ -78,22 +78,22 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let new = self.read_scalar(args[1])?;\n                 let old = self.read_scalar(ptr.into())?;\n                 self.write_scalar(old, dest)?; // old value is returned\n                 self.write_scalar(new, ptr.into())?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op_val()`\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let expect_old = self.read_immediate(args[1])?; // read as value for the sake of `binary_op_val()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op_val()`\n+                let old = self.read_immediate(ptr.into())?; // read as value for the sake of `binary_op_val()`\n                 // binary_op_val will bail if either of them is not a scalar\n                 let (eq, _) = self.binary_op_val(mir::BinOp::Eq, old, expect_old)?;\n-                let res = Value::ScalarPair(old.to_scalar_or_undef(), eq.into());\n-                self.write_value(res, dest)?; // old value is returned\n+                let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n+                self.write_immediate(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n                 if eq.to_bool()? {\n                     self.write_scalar(new, ptr.into())?;\n@@ -125,13 +125,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_xsub_rel\" |\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 if !ptr.layout.ty.is_integral() {\n                     return err!(Unimplemented(format!(\"Atomic arithmetic operations only work on integer types\")));\n                 }\n-                let rhs = self.read_value(args[1])?;\n-                let old = self.read_value(ptr.into())?;\n-                self.write_value(*old, dest)?; // old value is returned\n+                let rhs = self.read_immediate(args[1])?;\n+                let old = self.read_immediate(ptr.into())?;\n+                self.write_immediate(*old, dest)?; // old value is returned\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => mir::BinOp::BitOr,\n                     \"xor\" => mir::BinOp::BitXor,\n@@ -151,7 +151,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = self.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n-                let count = self.read_scalar(args[2])?.to_usize(&self)?;\n+                let count = self.read_scalar(args[2])?.to_usize(self)?;\n                 let elem_align = elem_layout.align;\n                 // erase tags: this is a raw ptr operation\n                 let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n@@ -167,7 +167,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"discriminant_value\" => {\n-                let place = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n                 self.write_scalar(Scalar::from_uint(discr_val, dest.layout.size), dest)?;\n             }\n@@ -215,8 +215,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let a = self.read_value(args[0])?;\n-                let b = self.read_value(args[1])?;\n+                let a = self.read_immediate(args[0])?;\n+                let b = self.read_immediate(args[1])?;\n                 let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n@@ -231,8 +231,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"exact_div\" => {\n                 // Performs an exact division, resulting in undefined behavior where\n                 // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n-                let a = self.read_value(args[0])?;\n-                let b = self.read_value(args[1])?;\n+                let a = self.read_immediate(args[0])?;\n+                let b = self.read_immediate(args[1])?;\n                 // check x % y != 0\n                 if self.binary_op_val(mir::BinOp::Rem, a, b)?.0.to_bytes()? != 0 {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n@@ -251,13 +251,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n-                            let x = Scalar::from_int(0, s.value.size(&self));\n-                            self.write_value(Value::Scalar(x.into()), dest)?;\n+                            let x = Scalar::from_int(0, s.value.size(self));\n+                            self.write_immediate(Immediate::Scalar(x.into()), dest)?;\n                         }\n                         layout::Abi::ScalarPair(ref s1, ref s2) => {\n-                            let x = Scalar::from_int(0, s1.value.size(&self));\n-                            let y = Scalar::from_int(0, s2.value.size(&self));\n-                            self.write_value(Value::ScalarPair(x.into(), y.into()), dest)?;\n+                            let x = Scalar::from_int(0, s1.value.size(self));\n+                            let y = Scalar::from_int(0, s2.value.size(self));\n+                            self.write_immediate(Immediate::ScalarPair(x.into(), y.into()), dest)?;\n                         }\n                         _ => {\n                             // Do it in memory\n@@ -279,12 +279,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"move_val_init\" => {\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 self.copy_op(args[1], ptr.into())?;\n             }\n \n             \"offset\" => {\n-                let offset = self.read_scalar(args[1])?.to_isize(&self)?;\n+                let offset = self.read_scalar(args[1])?.to_isize(self)?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let result_ptr = self.pointer_offset_inbounds(ptr, substs.type_at(0), offset)?;\n                 self.write_scalar(result_ptr, dest)?;\n@@ -347,7 +347,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"size_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let (_, align) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n@@ -372,13 +372,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n-                let value = self.str_to_value(&ty_name)?;\n-                self.write_value(value, dest)?;\n+                let value = self.str_to_immediate(&ty_name)?;\n+                self.write_immediate(value, dest)?;\n             }\n \n             \"unchecked_div\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n+                let l = self.read_immediate(args[0])?;\n+                let r = self.read_immediate(args[1])?;\n                 let rval = r.to_scalar()?.to_bytes()?;\n                 if rval == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n@@ -392,8 +392,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"unchecked_rem\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n+                let l = self.read_immediate(args[0])?;\n+                let r = self.read_immediate(args[1])?;\n                 let rval = r.to_scalar()?.to_bytes()?;\n                 if rval == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n@@ -416,11 +416,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {\n                             let x = ScalarMaybeUndef::Undef;\n-                            self.write_value(Value::Scalar(x), dest)?;\n+                            self.write_immediate(Immediate::Scalar(x), dest)?;\n                         }\n                         layout::Abi::ScalarPair(..) => {\n                             let x = ScalarMaybeUndef::Undef;\n-                            self.write_value(Value::ScalarPair(x, x), dest)?;\n+                            self.write_immediate(Immediate::ScalarPair(x, x), dest)?;\n                         }\n                         _ => {\n                             // Do it in memory\n@@ -437,7 +437,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n-                let count = self.read_scalar(args[2])?.to_usize(&self)?;\n+                let count = self.read_scalar(args[2])?.to_usize(self)?;\n                 self.memory().check_align(ptr, ty_layout.align)?;\n                 self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;\n             }"}, {"sha": "b4b7a310ca9d954e42b0bf57318515a7a21c2ac6", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, extern_crate_item_prelude)]\n \n #![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n \n@@ -253,7 +253,7 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n impl MayLeak for MiriMemoryKind {\n     #[inline(always)]\n     fn may_leak(self) -> bool {\n-        use MiriMemoryKind::*;\n+        use self::MiriMemoryKind::*;\n         match self {\n             Rust | C => false,\n             Env | MutStatic => true,"}, {"sha": "6d3abbcc31521db8173d01fb53c479e6c1531fe0", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -539,12 +539,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         // above.  First deref, which will call `tag_dereference`.\n         // (This is somewhat redundant because validation already did the same thing,\n         // but what can you do.)\n-        let val = self.read_value(self.place_to_op(place)?)?;\n+        let val = self.read_immediate(self.place_to_op(place)?)?;\n         let dest = self.ref_to_mplace(val)?;\n         // Now put a new ref into the old place, which will call `tag_reference`.\n         // FIXME: Honor `fn_entry`!\n         let val = self.create_ref(dest, Some(mutbl))?;\n-        self.write_value(val, place)?;\n+        self.write_immediate(val, place)?;\n         Ok(())\n     }\n }"}, {"sha": "1aacc67f5ccae2228d5203bfc7623c1a42d3ee09", "filename": "src/tls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=0e9e0f2d820cf2f55f8fc76194016fb513ac5b8c", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> TlsData<'tcx> {\n     pub fn create_tls_key(\n         &mut self,\n         dtor: Option<ty::Instance<'tcx>>,\n-        cx: impl HasDataLayout,\n+        cx: &impl HasDataLayout,\n     ) -> TlsKey {\n         let new_key = self.next_key;\n         self.next_key += 1;\n@@ -109,7 +109,7 @@ impl<'tcx> TlsData<'tcx> {\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-        cx: impl HasDataLayout,\n+        cx: &impl HasDataLayout,\n     ) -> Option<(ty::Instance<'tcx>, Scalar<Borrow>, TlsKey)> {\n         use std::collections::Bound::*;\n \n@@ -135,14 +135,14 @@ impl<'tcx> TlsData<'tcx> {\n \n impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n-        let mut dtor = self.machine.tls.fetch_tls_dtor(None, *self.tcx);\n+        let mut dtor = self.machine.tls.fetch_tls_dtor(None, &*self.tcx);\n         // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n             // TODO: Potentially, this has to support all the other possible instances?\n             // See eval_fn_call in interpret/terminator/mod.rs\n             let mir = self.load_mir(instance.def)?;\n-            let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, &self).into();\n+            let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, self).into();\n             self.push_stack_frame(\n                 instance,\n                 mir.span,\n@@ -159,9 +159,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for super::MiriEvalContext<\n             // step until out of stackframes\n             self.run()?;\n \n-            dtor = match self.machine.tls.fetch_tls_dtor(Some(key), *self.tcx) {\n+            dtor = match self.machine.tls.fetch_tls_dtor(Some(key), &*self.tcx) {\n                 dtor @ Some(_) => dtor,\n-                None => self.machine.tls.fetch_tls_dtor(None, *self.tcx),\n+                None => self.machine.tls.fetch_tls_dtor(None, &*self.tcx),\n             };\n         }\n         // FIXME: On a windows target, call `unsafe extern \"system\" fn on_tls_callback`."}]}