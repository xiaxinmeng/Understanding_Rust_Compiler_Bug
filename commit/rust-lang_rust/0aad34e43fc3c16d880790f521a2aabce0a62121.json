{"sha": "0aad34e43fc3c16d880790f521a2aabce0a62121", "node_id": "C_kwDOAAsO6NoAKDBhYWQzNGU0M2ZjM2MxNmQ4ODA3OTBmNTIxYTJhYWJjZTBhNjIxMjE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-02-21T20:47:24Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-02-21T20:59:06Z"}, "message": "Normalize projections types when checking `explicit_auto_deref`", "tree": {"sha": "89c959b72caec73fac73c1ef5fb94dd0de67c36c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89c959b72caec73fac73c1ef5fb94dd0de67c36c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aad34e43fc3c16d880790f521a2aabce0a62121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aad34e43fc3c16d880790f521a2aabce0a62121", "html_url": "https://github.com/rust-lang/rust/commit/0aad34e43fc3c16d880790f521a2aabce0a62121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aad34e43fc3c16d880790f521a2aabce0a62121/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ef3cc8ca1af8df6421adf2e600b774c8e055589", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef3cc8ca1af8df6421adf2e600b774c8e055589", "html_url": "https://github.com/rust-lang/rust/commit/5ef3cc8ca1af8df6421adf2e600b774c8e055589"}], "stats": {"total": 131, "additions": 102, "deletions": 29}, "files": [{"sha": "b2ed81219942b8376ac5d84f5d7bea57aa55555e", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0aad34e43fc3c16d880790f521a2aabce0a62121/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aad34e43fc3c16d880790f521a2aabce0a62121/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=0aad34e43fc3c16d880790f521a2aabce0a62121", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::mir::{enclosing_mir, expr_local, local_assignments, used_exact\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::{expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n+use clippy_utils::ty::{adt_and_variant_of_res, expr_sig, is_copy, peel_mid_ty_refs, ty_sig};\n use clippy_utils::{\n     fn_def_id, get_parent_expr, get_parent_expr_for_hir, is_lint_allowed, path_to_local, walk_to_expr_usage,\n };\n@@ -26,8 +26,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::{Rvalue, StatementKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{\n-    self, Binder, BoundVariableKind, Clause, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n-    ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n+    self, Binder, BoundVariableKind, Clause, EarlyBinder, FnSig, GenericArgKind, List, ParamEnv, ParamTy,\n+    PredicateKind, ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n };\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol};\n@@ -736,7 +736,7 @@ fn walk_parents<'tcx>(\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(owner_id.def_id);\n-                Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n+                Some(ty_auto_deref_stability(cx.tcx, cx.param_env, ty, precedence).position_for_result(cx))\n             },\n \n             Node::Item(&Item {\n@@ -760,18 +760,31 @@ fn walk_parents<'tcx>(\n                 let output = cx\n                     .tcx\n                     .erase_late_bound_regions(cx.tcx.fn_sig(owner_id).subst_identity().output());\n-                Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n+                Some(ty_auto_deref_stability(cx.tcx, cx.param_env, output, precedence).position_for_result(cx))\n             },\n \n             Node::ExprField(field) if field.span.ctxt() == ctxt => match get_parent_expr_for_hir(cx, field.hir_id) {\n                 Some(Expr {\n                     hir_id,\n                     kind: ExprKind::Struct(path, ..),\n                     ..\n-                }) => variant_of_res(cx, cx.qpath_res(path, *hir_id))\n-                    .and_then(|variant| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                    .map(|field_def| {\n-                        ty_auto_deref_stability(cx, cx.tcx.type_of(field_def.did), precedence).position_for_arg()\n+                }) => adt_and_variant_of_res(cx, cx.qpath_res(path, *hir_id))\n+                    .and_then(|(adt, variant)| {\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .find(|f| f.name == field.ident.name)\n+                            .map(|f| (adt, f))\n+                    })\n+                    .map(|(adt, field_def)| {\n+                        ty_auto_deref_stability(\n+                            cx.tcx,\n+                            // Use the param_env of the target type.\n+                            cx.tcx.param_env(adt.did()),\n+                            cx.tcx.type_of(field_def.did),\n+                            precedence,\n+                        )\n+                        .position_for_arg()\n                     }),\n                 _ => None,\n             },\n@@ -792,7 +805,7 @@ fn walk_parents<'tcx>(\n                             let output = cx\n                                 .tcx\n                                 .erase_late_bound_regions(cx.tcx.fn_sig(owner_id).subst_identity().output());\n-                            ty_auto_deref_stability(cx, output, precedence).position_for_result(cx)\n+                            ty_auto_deref_stability(cx.tcx, cx.param_env, output, precedence).position_for_result(cx)\n                         },\n                     )\n                 },\n@@ -835,15 +848,20 @@ fn walk_parents<'tcx>(\n                                             msrv,\n                                         )\n                                     } else {\n-                                        ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                                            .position_for_arg()\n+                                        ty_auto_deref_stability(\n+                                            cx.tcx,\n+                                            // Use the param_env of the target function.\n+                                            sig.predicates_id().map_or(ParamEnv::empty(), |id| cx.tcx.param_env(id)),\n+                                            cx.tcx.erase_late_bound_regions(ty),\n+                                            precedence\n+                                        ).position_for_arg()\n                                     }\n                                 },\n                             }\n                         })\n                     }),\n                 ExprKind::MethodCall(method, receiver, args, _) => {\n-                    let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n+                    let fn_id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n                     if receiver.hir_id == child_id {\n                         // Check for calls to trait methods where the trait is implemented on a reference.\n                         // Two cases need to be handled:\n@@ -852,13 +870,17 @@ fn walk_parents<'tcx>(\n                         //   priority.\n                         if e.hir_id != child_id {\n                             return Some(Position::ReborrowStable(precedence))\n-                        } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                        } else if let Some(trait_id) = cx.tcx.trait_of_item(fn_id)\n                             && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n                             && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n                             && let subs = cx\n                                 .typeck_results()\n                                 .node_substs_opt(parent.hir_id).map(|subs| &subs[1..]).unwrap_or_default()\n-                            && let impl_ty = if cx.tcx.fn_sig(id).subst_identity().skip_binder().inputs()[0].is_ref() {\n+                            && let impl_ty = if cx.tcx.fn_sig(fn_id)\n+                                .subst_identity()\n+                                .skip_binder()\n+                                .inputs()[0].is_ref()\n+                            {\n                                 // Trait methods taking `&self`\n                                 sub_ty\n                             } else {\n@@ -879,10 +901,13 @@ fn walk_parents<'tcx>(\n                         return Some(Position::MethodReceiver);\n                     }\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n-                        let ty = cx.tcx.fn_sig(id).subst_identity().skip_binder().inputs()[i + 1];\n+                        let ty = cx.tcx.fn_sig(fn_id).subst_identity().input(i + 1);\n                         // `e.hir_id == child_id` for https://github.com/rust-lang/rust-clippy/issues/9739\n                         // `method.args.is_none()` for https://github.com/rust-lang/rust-clippy/issues/9782\n-                        if e.hir_id == child_id && method.args.is_none() && let ty::Param(param_ty) = ty.kind() {\n+                        if e.hir_id == child_id\n+                            && method.args.is_none()\n+                            && let ty::Param(param_ty) = ty.skip_binder().kind()\n+                        {\n                             needless_borrow_impl_arg_position(\n                                 cx,\n                                 possible_borrowers,\n@@ -895,8 +920,10 @@ fn walk_parents<'tcx>(\n                             )\n                         } else {\n                             ty_auto_deref_stability(\n-                                cx,\n-                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).subst_identity().input(i + 1)),\n+                                cx.tcx,\n+                                // Use the param_env of the target function.\n+                                cx.tcx.param_env(fn_id),\n+                                cx.tcx.erase_late_bound_regions(ty),\n                                 precedence,\n                             )\n                             .position_for_arg()\n@@ -1378,11 +1405,18 @@ impl<'tcx> TyPosition<'tcx> {\n }\n \n // Checks whether a type is stable when switching to auto dereferencing,\n-fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedence: i8) -> TyPosition<'tcx> {\n+fn ty_auto_deref_stability<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    precedence: i8,\n+) -> TyPosition<'tcx> {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n         return Position::Other(precedence).into();\n     };\n \n+    ty = tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty);\n+\n     loop {\n         break match *ty.kind() {\n             ty::Ref(_, ref_ty, _) => {\n@@ -1423,9 +1457,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Alias(ty::Projection, _) => {\n-                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds())).into()\n-            },\n+            | ty::Alias(ty::Projection, _) => Position::DerefStable(precedence, ty.is_sized(tcx, param_env)).into(),\n         };\n     }\n }"}, {"sha": "99ebfa8febc46ab1d71751b663c4ce1f253badcd", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0aad34e43fc3c16d880790f521a2aabce0a62121/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aad34e43fc3c16d880790f521a2aabce0a62121/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=0aad34e43fc3c16d880790f521a2aabce0a62121", "patch": "@@ -894,16 +894,29 @@ impl AdtVariantInfo {\n }\n \n /// Gets the struct or enum variant from the given `Res`\n-pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n+pub fn adt_and_variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<(AdtDef<'tcx>, &'tcx VariantDef)> {\n     match res {\n-        Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n-        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n-        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n+        Res::Def(DefKind::Struct, id) => {\n+            let adt = cx.tcx.adt_def(id);\n+            Some((adt, adt.non_enum_variant()))\n+        },\n+        Res::Def(DefKind::Variant, id) => {\n+            let adt = cx.tcx.adt_def(cx.tcx.parent(id));\n+            Some((adt, adt.variant_with_id(id)))\n+        },\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => {\n+            let adt = cx.tcx.adt_def(cx.tcx.parent(id));\n+            Some((adt, adt.non_enum_variant()))\n+        },\n         Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n             let var_id = cx.tcx.parent(id);\n-            Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n+            let adt = cx.tcx.adt_def(cx.tcx.parent(var_id));\n+            Some((adt, adt.variant_with_id(var_id)))\n+        },\n+        Res::SelfCtor(id) => {\n+            let adt = cx.tcx.type_of(id).ty_adt_def().unwrap();\n+            Some((adt, adt.non_enum_variant()))\n         },\n-        Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n         _ => None,\n     }\n }"}, {"sha": "5d40c850424ff728ea9511c64f6089ff1b7a2c72", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aad34e43fc3c16d880790f521a2aabce0a62121/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0aad34e43fc3c16d880790f521a2aabce0a62121/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=0aad34e43fc3c16d880790f521a2aabce0a62121", "patch": "@@ -269,6 +269,9 @@ fn main() {\n \n     trait WithAssoc {\n         type Assoc: ?Sized;\n+        fn to_assoc(&self) -> &Self::Assoc {\n+            panic!()\n+        }\n     }\n     impl WithAssoc for String {\n         type Assoc = str;\n@@ -281,4 +284,15 @@ fn main() {\n     // Issue #9901\n     fn takes_ref(_: &i32) {}\n     takes_ref(*Box::new(&0i32));\n+\n+    // Issue #10384\n+    impl<'a> WithAssoc for &'a u32 {\n+        type Assoc = dyn core::fmt::Display;\n+        fn to_assoc(&self) -> &Self::Assoc {\n+            *self\n+        }\n+    }\n+    fn return_dyn_assoc<'a>(x: &'a &'a u32) -> &'a <&'a u32 as WithAssoc>::Assoc {\n+        *x\n+    }\n }"}, {"sha": "79e03f4d76c171cc128c1078a481d61d6222d05a", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aad34e43fc3c16d880790f521a2aabce0a62121/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aad34e43fc3c16d880790f521a2aabce0a62121/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=0aad34e43fc3c16d880790f521a2aabce0a62121", "patch": "@@ -269,6 +269,9 @@ fn main() {\n \n     trait WithAssoc {\n         type Assoc: ?Sized;\n+        fn to_assoc(&self) -> &Self::Assoc {\n+            panic!()\n+        }\n     }\n     impl WithAssoc for String {\n         type Assoc = str;\n@@ -281,4 +284,15 @@ fn main() {\n     // Issue #9901\n     fn takes_ref(_: &i32) {}\n     takes_ref(*Box::new(&0i32));\n+\n+    // Issue #10384\n+    impl<'a> WithAssoc for &'a u32 {\n+        type Assoc = dyn core::fmt::Display;\n+        fn to_assoc(&self) -> &Self::Assoc {\n+            *self\n+        }\n+    }\n+    fn return_dyn_assoc<'a>(x: &'a &'a u32) -> &'a <&'a u32 as WithAssoc>::Assoc {\n+        *x\n+    }\n }"}]}