{"sha": "e10284a10c07065d72bdaac1ed3059ad80df8318", "node_id": "C_kwDOAAsO6NoAKGUxMDI4NGExMGMwNzA2NWQ3MmJkYWFjMWVkMzA1OWFkODBkZjgzMTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T18:25:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T18:25:02Z"}, "message": "Auto merge of #12003 - Veykril:hir-ty-simplify, r=Veykril\n\ninternal: Remove duplicated crate id field from hir::Type", "tree": {"sha": "d8a592d5ebcb19cbc303c008415dcc59bed62209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a592d5ebcb19cbc303c008415dcc59bed62209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e10284a10c07065d72bdaac1ed3059ad80df8318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e10284a10c07065d72bdaac1ed3059ad80df8318", "html_url": "https://github.com/rust-lang/rust/commit/e10284a10c07065d72bdaac1ed3059ad80df8318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e10284a10c07065d72bdaac1ed3059ad80df8318/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ed459751f9f5f4eef31f6b49557dbcbf21e2db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed459751f9f5f4eef31f6b49557dbcbf21e2db3", "html_url": "https://github.com/rust-lang/rust/commit/9ed459751f9f5f4eef31f6b49557dbcbf21e2db3"}, {"sha": "17691ee974c8eee31b24c59fae7123dfc5486ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/17691ee974c8eee31b24c59fae7123dfc5486ef6", "html_url": "https://github.com/rust-lang/rust/commit/17691ee974c8eee31b24c59fae7123dfc5486ef6"}], "stats": {"total": 142, "additions": 55, "deletions": 87}, "files": [{"sha": "06056217fdbe7d081cad723d52b98d56a4e4f119", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 45, "deletions": 79, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e10284a10c07065d72bdaac1ed3059ad80df8318", "patch": "@@ -809,7 +809,7 @@ impl Field {\n         };\n         let substs = TyBuilder::placeholder_subst(db, generic_def_id);\n         let ty = db.field_types(var_id)[self.id].clone().substitute(Interner, &substs);\n-        Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n+        Type::new(db, var_id, ty)\n     }\n \n     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n@@ -850,7 +850,7 @@ impl Struct {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db.upcast()).container.krate(), self.id)\n+        Type::from_def(db, self.id)\n     }\n \n     pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n@@ -887,7 +887,7 @@ impl Union {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db.upcast()).container.krate(), self.id)\n+        Type::from_def(db, self.id)\n     }\n \n     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n@@ -929,7 +929,7 @@ impl Enum {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db.upcast()).container.krate(), self.id)\n+        Type::from_def(db, self.id)\n     }\n }\n \n@@ -1005,7 +1005,7 @@ impl Adt {\n     /// general set of completions, but will not look very nice when printed.\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let id = AdtId::from(self);\n-        Type::from_def(db, id.module(db.upcast()).krate(), id)\n+        Type::from_def(db, id)\n     }\n \n     /// Turns this ADT into a type with the given type parameters. This isn't\n@@ -1022,8 +1022,7 @@ impl Adt {\n                 }\n             })\n             .build();\n-        let krate = id.module(db.upcast()).krate();\n-        Type::new(db, krate, id, ty)\n+        Type::new(db, id, ty)\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -1213,18 +1212,8 @@ impl DefWithBody {\n             acc.push(\n                 TypeMismatch {\n                     expr,\n-                    expected: Type::new(\n-                        db,\n-                        krate,\n-                        DefWithBodyId::from(self),\n-                        mismatch.expected.clone(),\n-                    ),\n-                    actual: Type::new(\n-                        db,\n-                        krate,\n-                        DefWithBodyId::from(self),\n-                        mismatch.actual.clone(),\n-                    ),\n+                    expected: Type::new(db, DefWithBodyId::from(self), mismatch.expected.clone()),\n+                    actual: Type::new(db, DefWithBodyId::from(self), mismatch.actual.clone()),\n                 }\n                 .into(),\n             );\n@@ -1369,11 +1358,10 @@ impl Function {\n     /// Get this function's return type\n     pub fn ret_type(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.krate_id(db);\n         let ret_type = &db.function_data(self.id).ret_type;\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let ty = ctx.lower_ty(ret_type);\n-        Type::new_with_resolver_inner(db, krate, &resolver, ty)\n+        Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n     pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n@@ -1385,15 +1373,14 @@ impl Function {\n \n     pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param> {\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.krate_id(db);\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = db.trait_environment(self.id.into());\n         db.function_data(self.id)\n             .params\n             .iter()\n             .enumerate()\n             .map(|(idx, (_, type_ref))| {\n-                let ty = Type { krate, env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n+                let ty = Type { env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n                 Param { func: self, ty, idx }\n             })\n             .collect()\n@@ -1408,7 +1395,6 @@ impl Function {\n \n     pub fn params_without_self(self, db: &dyn HirDatabase) -> Vec<Param> {\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.krate_id(db);\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = db.trait_environment(self.id.into());\n         let skip = if db.function_data(self.id).has_self_param() { 1 } else { 0 };\n@@ -1418,7 +1404,7 @@ impl Function {\n             .enumerate()\n             .skip(skip)\n             .map(|(idx, (_, type_ref))| {\n-                let ty = Type { krate, env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n+                let ty = Type { env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n                 Param { func: self, ty, idx }\n             })\n             .collect()\n@@ -1470,10 +1456,6 @@ impl Function {\n \n         result\n     }\n-\n-    fn krate_id(self, db: &dyn HirDatabase) -> CrateId {\n-        self.id.lookup(db.upcast()).module(db.upcast()).krate()\n-    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n@@ -1575,11 +1557,10 @@ impl SelfParam {\n \n     pub fn ty(&self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.func.resolver(db.upcast());\n-        let krate = self.func.lookup(db.upcast()).container.module(db.upcast()).krate();\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = db.trait_environment(self.func.into());\n \n-        Type { krate, env: environment, ty: ctx.lower_ty(&db.function_data(self.func).params[0].1) }\n+        Type { env: environment, ty: ctx.lower_ty(&db.function_data(self.func).params[0].1) }\n     }\n }\n \n@@ -1610,10 +1591,9 @@ impl Const {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let data = db.const_data(self.id);\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.id.lookup(db.upcast()).container.krate(db);\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let ty = ctx.lower_ty(&data.type_ref);\n-        Type::new_with_resolver_inner(db, krate.id, &resolver, ty)\n+        Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n     pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n@@ -1652,10 +1632,9 @@ impl Static {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let data = db.static_data(self.id);\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.id.lookup(db.upcast()).container.module(db.upcast()).krate();\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let ty = ctx.lower_ty(&data.type_ref);\n-        Type::new_with_resolver_inner(db, krate, &resolver, ty)\n+        Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n }\n \n@@ -1727,7 +1706,7 @@ impl TypeAlias {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db.upcast()).module(db.upcast()).krate(), self.id)\n+        Type::from_def(db, self.id)\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n@@ -2185,8 +2164,7 @@ impl Local {\n         let def = self.parent;\n         let infer = db.infer(def);\n         let ty = infer[self.pat_id].clone();\n-        let krate = def.module(db.upcast()).krate();\n-        Type::new(db, krate, def, ty)\n+        Type::new(db, def, ty)\n     }\n \n     pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n@@ -2373,10 +2351,9 @@ impl TypeParam {\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.parent().resolver(db.upcast());\n-        let krate = self.id.parent().module(db.upcast()).krate();\n         let ty =\n             TyKind::Placeholder(hir_ty::to_placeholder_idx(db, self.id.into())).intern(Interner);\n-        Type::new_with_resolver_inner(db, krate, &resolver, ty)\n+        Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n     /// FIXME: this only lists trait bounds from the item defining the type\n@@ -2398,14 +2375,11 @@ impl TypeParam {\n         let params = db.generic_defaults(self.id.parent());\n         let local_idx = hir_ty::param_idx(db, self.id.into())?;\n         let resolver = self.id.parent().resolver(db.upcast());\n-        let krate = self.id.parent().module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n         let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n         match ty.data(Interner) {\n-            GenericArgData::Ty(x) => {\n-                Some(Type::new_with_resolver_inner(db, krate, &resolver, x.clone()))\n-            }\n+            GenericArgData::Ty(x) => Some(Type::new_with_resolver_inner(db, &resolver, x.clone())),\n             _ => None,\n         }\n     }\n@@ -2461,9 +2435,7 @@ impl ConstParam {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let def = self.id.parent();\n-        let krate = def.module(db.upcast()).krate();\n-        Type::new(db, krate, def, db.const_param_ty(self.id))\n+        Type::new(db, self.id.parent(), db.const_param_ty(self.id))\n     }\n }\n \n@@ -2522,8 +2494,8 @@ impl Impl {\n         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n \n-    pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty, .. }: Type) -> Vec<Impl> {\n-        let def_crates = match method_resolution::def_crates(db, &ty, krate) {\n+    pub fn all_for_type(db: &dyn HirDatabase, Type { ty, env }: Type) -> Vec<Impl> {\n+        let def_crates = match method_resolution::def_crates(db, &ty, env.krate) {\n             Some(def_crates) => def_crates,\n             None => return Vec::new(),\n         };\n@@ -2589,10 +2561,9 @@ impl Impl {\n     pub fn self_ty(self, db: &dyn HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.id.lookup(db.upcast()).container.krate();\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let ty = ctx.lower_ty(&impl_data.self_ty);\n-        Type::new_with_resolver_inner(db, krate, &resolver, ty)\n+        Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n     pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n@@ -2615,31 +2586,29 @@ impl Impl {\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Type {\n-    krate: CrateId, // FIXME this is probably redundant with the TraitEnvironment\n     env: Arc<TraitEnvironment>,\n     ty: Ty,\n }\n \n impl Type {\n     pub(crate) fn new_with_resolver(db: &dyn HirDatabase, resolver: &Resolver, ty: Ty) -> Type {\n-        let krate = resolver.krate();\n-        Type::new_with_resolver_inner(db, krate, resolver, ty)\n+        Type::new_with_resolver_inner(db, resolver, ty)\n     }\n \n     pub(crate) fn new_with_resolver_inner(\n         db: &dyn HirDatabase,\n-        krate: CrateId,\n         resolver: &Resolver,\n         ty: Ty,\n     ) -> Type {\n-        let environment = resolver\n-            .generic_def()\n-            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n-        Type { krate, env: environment, ty }\n+        let environment = resolver.generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(resolver.krate())),\n+            |d| db.trait_environment(d),\n+        );\n+        Type { env: environment, ty }\n     }\n \n     pub(crate) fn new_for_crate(krate: CrateId, ty: Ty) -> Type {\n-        Type { krate, env: Arc::new(TraitEnvironment::empty(krate)), ty }\n+        Type { env: Arc::new(TraitEnvironment::empty(krate)), ty }\n     }\n \n     pub fn reference(inner: &Type, m: Mutability) -> Type {\n@@ -2653,25 +2622,22 @@ impl Type {\n         )\n     }\n \n-    fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n+    fn new(db: &dyn HirDatabase, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n-        let environment = resolver\n-            .generic_def()\n-            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n-        Type { krate, env: environment, ty }\n+        let environment = resolver.generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(resolver.krate())),\n+            |d| db.trait_environment(d),\n+        );\n+        Type { env: environment, ty }\n     }\n \n-    fn from_def(\n-        db: &dyn HirDatabase,\n-        krate: CrateId,\n-        def: impl HasResolver + Into<TyDefId>,\n-    ) -> Type {\n+    fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n         let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n-        Type::new(db, krate, def, ty)\n+        Type::new(db, def, ty)\n     }\n \n     pub fn new_slice(ty: Type) -> Type {\n-        Type { krate: ty.krate, env: ty.env, ty: TyBuilder::slice(ty.ty) }\n+        Type { env: ty.env, ty: TyBuilder::slice(ty.ty) }\n     }\n \n     pub fn is_unit(&self) -> bool {\n@@ -2727,7 +2693,7 @@ impl Type {\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n         let std_future_trait = db\n-            .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n+            .lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))\n             .and_then(|it| it.as_trait());\n         let std_future_trait = match std_future_trait {\n             Some(it) => it,\n@@ -2744,7 +2710,7 @@ impl Type {\n     /// This function can be used to check if a particular type is callable, since FnOnce is a\n     /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.\n     pub fn impls_fnonce(&self, db: &dyn HirDatabase) -> bool {\n-        let fnonce_trait = match FnTrait::FnOnce.get_id(db, self.krate) {\n+        let fnonce_trait = match FnTrait::FnOnce.get_id(db, self.env.krate) {\n             Some(it) => it,\n             None => return false,\n         };\n@@ -2780,7 +2746,7 @@ impl Type {\n             binders: CanonicalVarKinds::empty(Interner),\n         };\n \n-        db.trait_solve(self.krate, goal).is_some()\n+        db.trait_solve(self.env.krate, goal).is_some()\n     }\n \n     pub fn normalize_trait_assoc_type(\n@@ -2815,7 +2781,7 @@ impl Type {\n             [TyVariableKind::General].into_iter(),\n         );\n \n-        match db.trait_solve(self.krate, goal)? {\n+        match db.trait_solve(self.env.krate, goal)? {\n             Solution::Unique(s) => s\n                 .value\n                 .subst\n@@ -2827,7 +2793,7 @@ impl Type {\n     }\n \n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.krate, SmolStr::new_inline(\"copy\"));\n+        let lang_item = db.lang_item(self.env.krate, SmolStr::new_inline(\"copy\"));\n         let copy_trait = match lang_item {\n             Some(LangItemTarget::TraitId(it)) => it,\n             _ => return false,\n@@ -3170,7 +3136,7 @@ impl Type {\n     }\n \n     fn derived(&self, ty: Ty) -> Type {\n-        Type { krate: self.krate, env: self.env.clone(), ty }\n+        Type { env: self.env.clone(), ty }\n     }\n \n     pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n@@ -3480,7 +3446,7 @@ impl HasCrate for TypeAlias {\n \n impl HasCrate for Type {\n     fn krate(&self, _db: &dyn HirDatabase) -> Crate {\n-        self.krate.into()\n+        self.env.krate.into()\n     }\n }\n "}, {"sha": "35aef328245a2245749d07a869e16211f62396c1", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=e10284a10c07065d72bdaac1ed3059ad80df8318", "patch": "@@ -44,7 +44,6 @@ use crate::{\n     Field, Function, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait, Type, TypeAlias,\n     Variant,\n };\n-use base_db::CrateId;\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n /// original source files. It should not be used inside the HIR itself.\n@@ -414,7 +413,6 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         literal: &ast::RecordExpr,\n     ) -> Option<Vec<(Field, Type)>> {\n-        let krate = self.resolver.krate();\n         let body = self.body()?;\n         let infer = self.infer.as_ref()?;\n \n@@ -423,7 +421,7 @@ impl SourceAnalyzer {\n \n         let (variant, missing_fields, _exhaustive) =\n             record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?;\n-        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        let res = self.missing_fields(db, substs, variant, missing_fields);\n         Some(res)\n     }\n \n@@ -432,7 +430,6 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         pattern: &ast::RecordPat,\n     ) -> Option<Vec<(Field, Type)>> {\n-        let krate = self.resolver.krate();\n         let body = self.body()?;\n         let infer = self.infer.as_ref()?;\n \n@@ -441,14 +438,13 @@ impl SourceAnalyzer {\n \n         let (variant, missing_fields, _exhaustive) =\n             record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;\n-        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        let res = self.missing_fields(db, substs, variant, missing_fields);\n         Some(res)\n     }\n \n     fn missing_fields(\n         &self,\n         db: &dyn HirDatabase,\n-        krate: CrateId,\n         substs: &Substitution,\n         variant: VariantId,\n         missing_fields: Vec<LocalFieldId>,\n@@ -460,7 +456,7 @@ impl SourceAnalyzer {\n             .map(|local_id| {\n                 let field = FieldId { parent: variant, local_id };\n                 let ty = field_types[local_id].clone().substitute(Interner, substs);\n-                (field.into(), Type::new_with_resolver_inner(db, krate, &self.resolver, ty))\n+                (field.into(), Type::new_with_resolver_inner(db, &self.resolver, ty))\n             })\n             .collect()\n     }"}, {"sha": "f3dcdcfa4a169d5e702351ed3141c5236901cffd", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10284a10c07065d72bdaac1ed3059ad80df8318/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=e10284a10c07065d72bdaac1ed3059ad80df8318", "patch": "@@ -448,7 +448,13 @@ impl Resolver {\n     }\n \n     pub fn krate(&self) -> CrateId {\n-        self.module_scope().0.krate()\n+        self.scopes\n+            .get(0)\n+            .and_then(|scope| match scope {\n+                Scope::ModuleScope(m) => Some(m.def_map.krate()),\n+                _ => None,\n+            })\n+            .expect(\"module scope invariant violated\")\n     }\n \n     pub fn where_predicates_in_scope("}]}