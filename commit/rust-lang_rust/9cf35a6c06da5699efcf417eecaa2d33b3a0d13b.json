{"sha": "9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "node_id": "C_kwDOAAsO6NoAKDljZjM1YTZjMDZkYTU2OTllZmNmNDE3ZWVjYWEyZDMzYjNhMGQxM2I", "commit": {"author": {"name": "Mark Lodato", "email": "mlodato517@gmail.com", "date": "2022-03-10T02:43:04Z"}, "committer": {"name": "Mark Lodato", "email": "mlodato517@gmail.com", "date": "2022-04-09T13:27:32Z"}, "message": "Rework String UTF-8 Documentation\n\n**This Commit**\nAdds some clarity around indexing into Strings and the constraints\ndriving various decisions there.\n\n**Why?**\nThe [`String` documentation][0] mentions how `String`s can't be indexed\nbut `Range` has an implementation for `SliceIndex<str>`. This can be\nconfusing. There are also several statements to explain the lack of\n`String` indexing:\n\n- the inability to index into a `String` is an implication of UTF-8\n  encoding\n- indexing into a `String` could not be constant-time with UTF-8\n  encoding\n- indexing into a `String` does not have an obvious return type\n\nThis last statement made sense but the first two seemed contradictory to\nthe documentation around [`SliceIndex<str>`][1] which mention:\n\n- one can index into a `String` with a `Range` (also called substring\n  slicing but it uses the same syntax and the method name is `index`)\n- `Range` indexing into a `String` is constant-time\n\nTo resolve this seeming contradiction the documentation is reworked to\nmore clearly explain what factors drive the decision to disallow\nindexing into a `String` with a single number.\n\n[0]: https://doc.rust-lang.org/stable/std/string/struct.String.html#utf-8\n[1]: https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html#impl-SliceIndex%3Cstr%3E", "tree": {"sha": "ff237e97f8894c91a5ff25e6fb50de6a70873fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff237e97f8894c91a5ff25e6fb50de6a70873fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "html_url": "https://github.com/rust-lang/rust/commit/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b/comments", "author": {"login": "mlodato517", "id": 18740355, "node_id": "MDQ6VXNlcjE4NzQwMzU1", "avatar_url": "https://avatars.githubusercontent.com/u/18740355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mlodato517", "html_url": "https://github.com/mlodato517", "followers_url": "https://api.github.com/users/mlodato517/followers", "following_url": "https://api.github.com/users/mlodato517/following{/other_user}", "gists_url": "https://api.github.com/users/mlodato517/gists{/gist_id}", "starred_url": "https://api.github.com/users/mlodato517/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mlodato517/subscriptions", "organizations_url": "https://api.github.com/users/mlodato517/orgs", "repos_url": "https://api.github.com/users/mlodato517/repos", "events_url": "https://api.github.com/users/mlodato517/events{/privacy}", "received_events_url": "https://api.github.com/users/mlodato517/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mlodato517", "id": 18740355, "node_id": "MDQ6VXNlcjE4NzQwMzU1", "avatar_url": "https://avatars.githubusercontent.com/u/18740355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mlodato517", "html_url": "https://github.com/mlodato517", "followers_url": "https://api.github.com/users/mlodato517/followers", "following_url": "https://api.github.com/users/mlodato517/following{/other_user}", "gists_url": "https://api.github.com/users/mlodato517/gists{/gist_id}", "starred_url": "https://api.github.com/users/mlodato517/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mlodato517/subscriptions", "organizations_url": "https://api.github.com/users/mlodato517/orgs", "repos_url": "https://api.github.com/users/mlodato517/repos", "events_url": "https://api.github.com/users/mlodato517/events{/privacy}", "received_events_url": "https://api.github.com/users/mlodato517/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "399dd8049d4b27329350937e3e17077205bdc0bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/399dd8049d4b27329350937e3e17077205bdc0bf", "html_url": "https://github.com/rust-lang/rust/commit/399dd8049d4b27329350937e3e17077205bdc0bf"}], "stats": {"total": 92, "additions": 82, "deletions": 10}, "files": [{"sha": "e97c1637fd5a26fea0b4674e7e7de6419d363ac5", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "patch": "@@ -117,27 +117,99 @@ use crate::vec::Vec;\n ///\n /// # UTF-8\n ///\n-/// `String`s are always valid UTF-8. This has a few implications, the first of\n-/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n-/// similar, but without the UTF-8 constraint. The second implication is that\n-/// you cannot index into a `String`:\n+/// `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider\n+/// [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8\n+/// is a variable width encoding, `String`s are typically smaller than an array of\n+/// the same `chars`:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // `s` is ASCII which represents each `char` as one byte\n+/// let s = \"hello\";\n+/// assert_eq!(s.len(), 5);\n+///\n+/// // A `char` array with the same contents would be longer because\n+/// // every `char` is four bytes\n+/// let s = ['h', 'e', 'l', 'l', 'o'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+///\n+/// // However, for non-ASCII strings, the difference will be smaller\n+/// // and sometimes they are the same\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.len(), 20);\n+///\n+/// let s = ['\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+/// ```\n+///\n+/// This raises interesting questions as to how `s[i]` should work.\n+/// What should `i` be here? Several options include byte indices and\n+/// `char` indices but, because of UTF-8 encoding, only byte indices\n+/// would provide constant time indexing. Getting the `i`th `char`, for\n+/// example, is available using [`chars`]:\n+///\n+/// ```\n+/// let s = \"hello\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('l'));\n+///\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('\ud83d\udc96'));\n+/// ```\n+///\n+/// Next, what should `s[i]` return? Because indexing returns a reference\n+/// to underlying data it could be `&u8`, `&[u8]`, or something else similar.\n+/// Since we're only providing one index, `&u8` makes the most sense but that\n+/// might not be what the user expects and can be explicitly achieved with\n+/// [`as_bytes()`]:\n+///\n+/// ```\n+/// // The first byte is 104 - the byte value of `'h'`\n+/// let s = \"hello\";\n+/// assert_eq!(s.as_bytes()[0], 104);\n+/// // or\n+/// assert_eq!(s.as_bytes()[0], b'h');\n+///\n+/// // The first byte is 240 which isn't obviously useful\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.as_bytes()[0], 240);\n+/// ```\n+///\n+/// Due to these ambiguities/restrictions, indexing with a `usize` is simply\n+/// forbidden:\n ///\n /// ```compile_fail,E0277\n /// let s = \"hello\";\n ///\n-/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+/// // The following will not compile!\n+/// println!(\"The first letter of s is {}\", s[0]);\n /// ```\n ///\n+/// It is more clear, however, how `&s[i..j]` should work (that is,\n+/// indexing with a range). It should accept byte indices (to be constant-time)\n+/// and return a `&str` which is UTF-8 encoded. This is also called \"string slicing\".\n+/// Note this will panic if the byte indices provided are not character\n+/// boundaries - see [`is_char_boundary`] for more details. See the implementations\n+/// for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking\n+/// version of string slicing, see [`get`].\n+///\n /// [`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\"\n+/// [`SliceIndex<str>`]: core::slice::SliceIndex\n+/// [`as_bytes()`]: str::as_bytes\n+/// [`get`]: str::get\n+/// [`is_char_boundary`]: str::is_char_boundary\n ///\n-/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n-/// does not allow us to do this. Furthermore, it's not clear what sort of\n-/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n-/// The [`bytes`] and [`chars`] methods return iterators over the first\n-/// two, respectively.\n+/// The [`bytes`] and [`chars`] methods return iterators over the bytes and\n+/// codepoints of the string, respectively. To iterate over codepoints along\n+/// with byte indices, use [`char_indices`].\n ///\n /// [`bytes`]: str::bytes\n /// [`chars`]: str::chars\n+/// [`char_indices`]: str::char_indices\n ///\n /// # Deref\n ///"}]}