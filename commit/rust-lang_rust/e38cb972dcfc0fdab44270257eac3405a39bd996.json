{"sha": "e38cb972dcfc0fdab44270257eac3405a39bd996", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOGNiOTcyZGNmYzBmZGFiNDQyNzAyNTdlYWMzNDA1YTM5YmQ5OTY=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-01T01:02:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-03T19:54:51Z"}, "message": "Simplify PatIdent to contain an Ident rather than a Path\n\nRationale: for what appear to be historical reasons only, the PatIdent contains\na Path rather than an Ident.  This means that there are many places in the code\nwhere an ident is artificially promoted to a path, and---much more problematically---\na bunch of elements from a path are simply thrown away, which seems like an invitation\nto some really nasty bugs.\n\nThis commit replaces the Path in a PatIdent with a SpannedIdent, which just contains an ident\nand a span.", "tree": {"sha": "f45affb2ba2b0e35e03f102755103f93063ac9e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f45affb2ba2b0e35e03f102755103f93063ac9e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e38cb972dcfc0fdab44270257eac3405a39bd996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e38cb972dcfc0fdab44270257eac3405a39bd996", "html_url": "https://github.com/rust-lang/rust/commit/e38cb972dcfc0fdab44270257eac3405a39bd996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e38cb972dcfc0fdab44270257eac3405a39bd996/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff79ab5633f0900eb71a53ccb924632f7b1090c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff79ab5633f0900eb71a53ccb924632f7b1090c", "html_url": "https://github.com/rust-lang/rust/commit/cff79ab5633f0900eb71a53ccb924632f7b1090c"}], "stats": {"total": 408, "additions": 153, "deletions": 255}, "files": [{"sha": "3e7c491252745e4f86fc205fed12df1146827d4e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -902,12 +902,10 @@ impl LintPass for NonUppercasePatternStatics {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-            (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n-                // last identifier alone is right choice for this lint.\n-                let ident = path.segments.last().unwrap().identifier;\n-                let s = token::get_ident(ident);\n+            (&ast::PatIdent(_, ref path1, _), Some(&def::DefStatic(_, false))) => {\n+                let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path.span,\n+                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path1.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -931,15 +929,13 @@ impl LintPass for UppercaseVariables {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         match &p.node {\n-            &ast::PatIdent(_, ref path, _) => {\n+            &ast::PatIdent(_, ref path1, _) => {\n                 match cx.tcx.def_map.borrow().find(&p.id) {\n                     Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n                             Some(&def::DefArg(_, _)) => {\n-                        // last identifier alone is right choice for this lint.\n-                        let ident = path.segments.last().unwrap().identifier;\n-                        let s = token::get_ident(ident);\n+                        let s = token::get_ident(path1.node);\n                         if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                            cx.span_lint(UPPERCASE_VARIABLES, path.span,\n+                            cx.span_lint(UPPERCASE_VARIABLES, path1.span,\n                                          \"variable names should start with \\\n                                           a lowercase character\");\n                         }\n@@ -1113,15 +1109,10 @@ impl UnusedMut {\n         // avoid false warnings in match arms with multiple patterns\n         let mut mutables = HashMap::new();\n         for &p in pats.iter() {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path1| {\n+                let ident = path1.node;\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n-                        if path.segments.len() != 1 {\n-                            cx.sess().span_bug(p.span,\n-                                               \"mutable binding that doesn't consist \\\n-                                                of exactly one segment\");\n-                        }\n-                        let ident = path.segments.get(0).identifier;\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n                             mutables.insert_or_update_with(ident.name as uint,\n                                 vec!(id), |_, old| { old.push(id); });"}, {"sha": "6eb7c5a4310e6f9cb61abc55001000ae275839cc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -809,9 +809,8 @@ fn encode_method_argument_names(ebml_w: &mut Encoder,\n     for arg in decl.inputs.iter() {\n         ebml_w.start_tag(tag_method_argument_name);\n         match arg.pat.node {\n-            ast::PatIdent(_, ref name, _) => {\n-                let name = name.segments.last().unwrap().identifier;\n-                let name = token::get_ident(name);\n+            ast::PatIdent(_, ref path1, _) => {\n+                let name = token::get_ident(path1.node);\n                 ebml_w.writer.write(name.get().as_bytes());\n             }\n             _ => {}\n@@ -1106,8 +1105,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n+                let ident = path.segments.last().unwrap().identifier;\n                 assert!(bounds.is_none());\n-                encode_impl_type_basename(ebml_w, ast_util::path_to_ident(path));\n+                encode_impl_type_basename(ebml_w, ident);\n             }\n             _ => {}\n         }"}, {"sha": "de77fa602c9b406a0bf85a4e8c58b04bb72b7975", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -66,9 +66,9 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_pat: &ast::Pat,\n                             cmt: mc::cmt) {\n     let pat_span_path_opt = match move_pat.node {\n-        ast::PatIdent(_, ref path, _) => {\n-            Some(MoveSpanAndPath::with_span_and_path(move_pat.span,\n-                                                     (*path).clone()))\n+        ast::PatIdent(_, ref path1, _) => {\n+            Some(MoveSpanAndPath{span: move_pat.span,\n+                                 ident: path1.node})\n         },\n         _ => None,\n     };"}, {"sha": "f5c91f7b1b3bf4441e664ff0fd479486864b6d22", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -56,19 +56,8 @@ impl MoveError {\n \n #[deriving(Clone)]\n pub struct MoveSpanAndPath {\n-    span: codemap::Span,\n-    path: ast::Path\n-}\n-\n-impl MoveSpanAndPath {\n-    pub fn with_span_and_path(span: codemap::Span,\n-                              path: ast::Path)\n-                              -> MoveSpanAndPath {\n-        MoveSpanAndPath {\n-            span: span,\n-            path: path,\n-        }\n-    }\n+    pub span: codemap::Span,\n+    pub ident: ast::Ident\n }\n \n pub struct GroupedMoveErrors {\n@@ -83,7 +72,7 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n         let mut is_first_note = true;\n         for move_to in error.move_to_places.iter() {\n             note_move_destination(bccx, move_to.span,\n-                                  &move_to.path, is_first_note);\n+                                  &move_to.ident, is_first_note);\n             is_first_note = false;\n         }\n     }\n@@ -154,9 +143,9 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n \n fn note_move_destination(bccx: &BorrowckCtxt,\n                          move_to_span: codemap::Span,\n-                         pat_ident_path: &ast::Path,\n+                         pat_ident: &ast::Ident,\n                          is_first_note: bool) {\n-    let pat_name = pprust::path_to_str(pat_ident_path);\n+    let pat_name = pprust::ident_to_str(pat_ident);\n     if is_first_note {\n         bccx.span_note(\n             move_to_span,"}, {"sha": "70db3e964abb3273cc2f4d078a3c809b1c7fdad0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -247,6 +247,10 @@ impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n+            ast::PatIdent(_, _, _) => {\n+                // it might be the only use of a static:\n+                self.lookup_and_handle_definition(&pat.id)\n+            }\n             _ => ()\n         }\n "}, {"sha": "8163331667198a8b48035291d786c7c44a3cd93b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -20,7 +20,7 @@ use util::ppaux::UserString;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::print::pprust::{expr_to_str,path_to_str};\n+use syntax::print::pprust::{expr_to_str, ident_to_str};\n use syntax::{visit};\n use syntax::visit::Visitor;\n \n@@ -627,7 +627,7 @@ fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n fn check_pat(cx: &mut Context, pat: &Pat) {\n     let var_name = match pat.node {\n         PatWild => Some(\"_\".to_string()),\n-        PatIdent(_, ref path, _) => Some(path_to_str(path).to_string()),\n+        PatIdent(_, ref path1, _) => Some(ident_to_str(&path1.node).to_string()),\n         _ => None\n     };\n "}, {"sha": "d48f7f541f0da016d1c85cfe980a529656c89031", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -367,9 +367,9 @@ fn visit_fn(ir: &mut IrMaps,\n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n                                &*arg.pat,\n-                               |_bm, arg_id, _x, path| {\n+                               |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n-            let ident = ast_util::path_to_ident(path);\n+            let ident = path1.node;\n             fn_maps.add_variable(Arg(arg_id, ident));\n         })\n     };\n@@ -399,9 +399,9 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n-        let name = ast_util::path_to_ident(path);\n+        let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         ir.add_variable(Local(LocalInfo {\n           id: p_id,\n@@ -413,10 +413,10 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n-            let name = ast_util::path_to_ident(path);\n+            let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n             ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n@@ -1522,10 +1522,10 @@ impl<'a> Liveness<'a> {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n-                                   |_bm, p_id, sp, path| {\n+                                   |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n-                let ident = ast_util::path_to_ident(path);\n+                let ident = path1.node;\n                 if ident.name != special_idents::self_.name {\n                     self.warn_about_unused(sp, p_id, entry_ln, var);\n                 }"}, {"sha": "2d53d742ee44b15800ed580c6f375f65b1e87a24", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -14,7 +14,7 @@ use middle::resolve;\n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n use syntax::ast::*;\n-use syntax::ast_util::{path_to_ident, walk_pat};\n+use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n@@ -23,8 +23,8 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n-    pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n-      map.insert(path_to_ident(n), p_id);\n+    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n+      map.insert(path1.node, p_id);\n     });\n     map\n }\n@@ -75,7 +75,7 @@ pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings(dm: &resolve::DefMap,\n                     pat: &Pat,\n-                    it: |BindingMode, NodeId, Span, &Path|) {\n+                    it: |BindingMode, NodeId, Span, &SpannedIdent|) {\n     walk_pat(pat, |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n@@ -102,10 +102,10 @@ pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Path> {\n+pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     match pat.node {\n-        PatIdent(BindByValue(_), ref path, None) => {\n-            Some(path)\n+        PatIdent(BindByValue(_), ref path1, None) => {\n+            Some(&path1.node)\n         }\n         _ => {\n             None"}, {"sha": "b7b4618a7904619a97f34eacd6d26a0efe1a2b0f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -23,11 +23,10 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n-use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n+use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n-use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n@@ -1247,7 +1246,7 @@ impl<'a> Resolver<'a> {\n                 // Create the module and add all methods.\n                 match ty.node {\n                     TyPath(ref path, _, _) if path.segments.len() == 1 => {\n-                        let name = path_to_ident(path);\n+                        let name = path.segments.last().unwrap().identifier;\n \n                         let parent_opt = parent.module().children.borrow()\n                                                .find_copy(&name.name);\n@@ -4104,8 +4103,8 @@ impl<'a> Resolver<'a> {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path| {\n-            let name = mtwt::resolve(path_to_ident(path));\n+        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n+            let name = mtwt::resolve(path1.node);\n             result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n@@ -4314,8 +4313,7 @@ impl<'a> Resolver<'a> {\n         let pat_id = pattern.id;\n         walk_pat(pattern, |pattern| {\n             match pattern.node {\n-                PatIdent(binding_mode, ref path, _)\n-                        if !path.global && path.segments.len() == 1 => {\n+                PatIdent(binding_mode, ref path1, _) => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n@@ -4326,7 +4324,7 @@ impl<'a> Resolver<'a> {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.segments.get(0).identifier;\n+                    let ident = path1.node;\n                     let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n@@ -4416,57 +4414,12 @@ impl<'a> Resolver<'a> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            path_to_str(path)).as_slice());\n+                                            token::get_ident(ident)).as_slice());\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n                         }\n                     }\n-\n-                    // Check the types in the path pattern.\n-                    for ty in path.segments\n-                                  .iter()\n-                                  .flat_map(|seg| seg.types.iter()) {\n-                        self.resolve_type(&**ty);\n-                    }\n-                }\n-\n-                PatIdent(binding_mode, ref path, _) => {\n-                    // This must be an enum variant, struct, or constant.\n-                    match self.resolve_path(pat_id, path, ValueNS, false) {\n-                        Some(def @ (DefVariant(..), _)) |\n-                        Some(def @ (DefStruct(..), _)) => {\n-                            self.record_def(pattern.id, def);\n-                        }\n-                        Some(def @ (DefStatic(..), _)) => {\n-                            self.enforce_default_binding_mode(\n-                                pattern,\n-                                binding_mode,\n-                                \"a constant\");\n-                            self.record_def(pattern.id, def);\n-                        }\n-                        Some(_) => {\n-                            self.resolve_error(\n-                                path.span,\n-                                format!(\"`{}` is not an enum variant or constant\",\n-                                        token::get_ident(\n-                                            path.segments\n-                                                .last()\n-                                                .unwrap()\n-                                                .identifier)).as_slice())\n-                        }\n-                        None => {\n-                            self.resolve_error(path.span,\n-                                                  \"unresolved enum variant\");\n-                        }\n-                    }\n-\n-                    // Check the types in the path pattern.\n-                    for ty in path.segments\n-                                  .iter()\n-                                  .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(&**ty);\n-                    }\n                 }\n \n                 PatEnum(ref path, _) => {\n@@ -5202,8 +5155,8 @@ impl<'a> Resolver<'a> {\n                                              in a static method. Maybe a \\\n                                              `self` argument is missing?\");\n                                 } else {\n-                                    let name = path_to_ident(path).name;\n-                                    let mut msg = match self.find_fallback_in_self_type(name) {\n+                                    let last_name = path.segments.last().unwrap().identifier.name;\n+                                    let mut msg = match self.find_fallback_in_self_type(last_name) {\n                                         NoSuggestion => {\n                                             // limit search to 5 to reduce the number\n                                             // of stupid suggestions"}, {"sha": "56894ad3e5c2b70c94bd720d291997226df8007b", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -926,7 +926,7 @@ impl <'l> DxrVisitor<'l> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n                 visit::walk_pat(self, p, e);\n             }\n-            ast::PatIdent(bm, ref path, ref optional_subpattern) => {\n+            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n@@ -940,7 +940,8 @@ impl <'l> DxrVisitor<'l> {\n                     }\n                 };\n                 // collect path for either visit_local or visit_arm\n-                self.collected_paths.push((p.id, path.clone(), immut, recorder::VarRef));\n+                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n                 match *optional_subpattern {\n                     None => {}\n                     Some(subpattern) => self.visit_pat(&*subpattern, e),"}, {"sha": "55939e6ea7a9fd56b7b03e5b28ed171df5efc022", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -231,8 +231,6 @@ use std::rc::Rc;\n use std::gc::{Gc};\n use syntax::ast;\n use syntax::ast::Ident;\n-use syntax::ast_util::path_to_ident;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n \n@@ -435,13 +433,13 @@ fn expand_nested_bindings<'a, 'b>(\n \n     m.iter().map(|br| {\n         match br.pats.get(col).node {\n-            ast::PatIdent(_, ref path, Some(inner)) => {\n+            ast::PatIdent(_, ref path1, Some(inner)) => {\n                 let pats = Vec::from_slice(br.pats.slice(0u, col))\n                            .append((vec!(inner))\n                                    .append(br.pats.slice(col + 1u, br.pats.len())).as_slice());\n \n                 let mut bound_ptrs = br.bound_ptrs.clone();\n-                bound_ptrs.push((path_to_ident(path), val));\n+                bound_ptrs.push((path1.node, val));\n                 Match {\n                     pats: pats,\n                     data: &*br.data,\n@@ -479,9 +477,9 @@ fn enter_match<'a, 'b>(\n             let this = *br.pats.get(col);\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                ast::PatIdent(_, ref path, None) => {\n+                ast::PatIdent(_, ref path1, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path_to_ident(path), val));\n+                        bound_ptrs.push((path1.node, val));\n                     }\n                 }\n                 _ => {}\n@@ -1431,8 +1429,8 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path| {\n-        let ident = path_to_ident(path);\n+    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+        let ident = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n \n@@ -1586,10 +1584,10 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n             match simple_identifier(&*pat) {\n-                Some(path) => {\n+                Some(ident) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, path, BindLocal, var_scope, (),\n+                        bcx, pat.id, ident, BindLocal, var_scope, (),\n                         |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1621,10 +1619,10 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path1| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n-                    bcx, p_id, path, BindLocal, scope, (),\n+                    bcx, p_id, &path1.node, BindLocal, scope, (),\n                     |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n             });\n         bcx\n@@ -1652,7 +1650,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"match::store_arg\");\n \n     match simple_identifier(&*pat) {\n-        Some(path) => {\n+        Some(ident) => {\n             // Generate nicer LLVM for the common case of fn a pattern\n             // like `x: T`\n             let arg_ty = node_id_type(bcx, pat.id);\n@@ -1667,7 +1665,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n                 bcx\n             } else {\n                 mk_binding_alloca(\n-                    bcx, pat.id, path, BindArgument, arg_scope, arg,\n+                    bcx, pat.id, ident, BindArgument, arg_scope, arg,\n                     |arg, bcx, llval, _| arg.store_to(bcx, llval))\n             }\n         }\n@@ -1685,17 +1683,16 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n                            p_id: ast::NodeId,\n-                           path: &ast::Path,\n+                           ident: &ast::Ident,\n                            binding_mode: IrrefutablePatternBindingMode,\n                            cleanup_scope: cleanup::ScopeId,\n                            arg: A,\n                            populate: |A, &'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>)\n                          -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n-    let ident = ast_util::path_to_ident(path);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident).as_slice());\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).as_slice());\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1753,13 +1750,13 @@ fn bind_irrefutable_pat<'a>(\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        ast::PatIdent(pat_binding_mode, ref path, inner) => {\n+        ast::PatIdent(pat_binding_mode, ref path1, inner) => {\n             if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, path, binding_mode, cleanup_scope, (),\n+                    bcx, pat.id, &path1.node, binding_mode, cleanup_scope, (),\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {"}, {"sha": "afa0b3041550e707eeffeb7e6f1407cfed9321ed", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -842,8 +842,8 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n     let def_map = &cx.tcx.def_map;\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path_ref| {\n-        let var_ident = ast_util::path_to_ident(path_ref);\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n+        let var_ident = path1.node;\n \n         let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n             Some(datum) => datum,\n@@ -890,8 +890,8 @@ pub fn create_captured_var_metadata(bcx: &Block,\n         }\n         Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n-                ast::PatIdent(_, ref path, _) => {\n-                    ast_util::path_to_ident(path)\n+                ast::PatIdent(_, ref path1, _) => {\n+                    path1.node\n                 }\n                 _ => {\n                     cx.sess()\n@@ -990,7 +990,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n         let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -1005,8 +1005,6 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n                                     Referenced variable location is not an alloca!\");\n         }\n \n-        let argument_ident = ast_util::path_to_ident(path_ref);\n-\n         let argument_index = {\n             let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n             let argument_index = counter.get();\n@@ -1015,7 +1013,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n         };\n \n         declare_local(bcx,\n-                      argument_ident,\n+                      path1.node,\n                       llarg.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: llarg.val },\n@@ -3220,10 +3218,9 @@ fn populate_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path_ref| {\n-            let ident = ast_util::path_to_ident(path_ref);\n+        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               ident: Some(ident) });\n+                                               ident: Some(path1.node) });\n         })\n     }\n \n@@ -3331,13 +3328,13 @@ fn populate_scope_map(cx: &CrateContext,\n         // ast_util::walk_pat() here because we have to visit *all* nodes in\n         // order to put them into the scope map. The above functions don't do that.\n         match pat.node {\n-            ast::PatIdent(_, ref path_ref, ref sub_pat_opt) => {\n+            ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n \n                 // Check if this is a binding. If so we need to put it on the\n                 // scope stack and maybe introduce an artificial scope\n                 if pat_util::pat_is_binding(def_map, &*pat) {\n \n-                    let ident = ast_util::path_to_ident(path_ref);\n+                    let ident = path1.node;\n \n                     // LLVM does not properly generate 'DW_AT_start_scope' fields\n                     // for variable DIEs. For this reason we have to introduce"}, {"sha": "9629fb38af80fb62cf58726d520725b139aba143", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -2771,8 +2771,8 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n     match cx.map.find(id) {\n         Some(ast_map::NodeLocal(pat)) => {\n             match pat.node {\n-                ast::PatIdent(_, ref path, _) => {\n-                    token::get_ident(ast_util::path_to_ident(path))\n+                ast::PatIdent(_, ref path1, _) => {\n+                    token::get_ident(path1.node)\n                 }\n                 _ => {\n                     cx.sess.bug("}, {"sha": "697c5d367ee5a51ab3a65cd2a6945de0d3ae5db6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -485,7 +485,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_pty.ty);\n         fcx.write_ty(pat.id, const_pty.ty);\n       }\n-      ast::PatIdent(bm, ref name, sub) if pat_is_binding(&tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref path1, sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -507,7 +507,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = *pcx.map.get(&ast_util::path_to_ident(name));\n+        let canon_id = *pcx.map.get(&path1.node);\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);\n@@ -521,8 +521,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::PatIdent(_, ref path, _) => {\n-        check_pat_variant(pcx, pat, path, &Some(Vec::new()), expected);\n+      // it's not a binding, it's an enum in disguise:\n+      ast::PatIdent(_, ref path1, _) => {\n+        let path = ast_util::ident_to_path(path1.span,path1.node);\n+        check_pat_variant(pcx, pat, &path, &Some(Vec::new()), expected);\n       }\n       ast::PatEnum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);"}, {"sha": "b68991aed70963c53c341788689c4f11e1652a7a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -406,11 +406,11 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n-              ast::PatIdent(_, ref path, _)\n+              ast::PatIdent(_, ref path1, _)\n                   if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding {} is assigned to {}\",\n-                       token::get_ident(path.segments.get(0).identifier),\n+                       token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.borrow().get_copy(&p.id)));\n               }"}, {"sha": "58985f832ce32091e01106dfe80e0c73aabcc22c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -1583,8 +1583,6 @@ impl Clean<PathSegment> for ast::PathSegment {\n }\n \n fn path_to_str(p: &ast::Path) -> String {\n-    use syntax::parse::token;\n-\n     let mut s = String::new();\n     let mut first = true;\n     for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n@@ -1953,7 +1951,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n     match p.node {\n         PatWild => \"_\".to_string(),\n         PatWildMulti => \"..\".to_string(),\n-        PatIdent(_, ref p, _) => path_to_str(p),\n+        PatIdent(_, ref p, _) => token::get_ident(p.node).get().to_string(),\n         PatEnum(ref p, _) => path_to_str(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),"}, {"sha": "237d0660a41dcca5edb5f15875cd41bdc5fd2f5a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -293,8 +293,8 @@ pub enum Pat_ {\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's NodeId in an auxiliary\n-    // set (of \"pat_idents that refer to nullary enums\")\n-    PatIdent(BindingMode, Path, Option<Gc<Pat>>),\n+    // set (of \"PatIdents that refer to nullary enums\")\n+    PatIdent(BindingMode, SpannedIdent, Option<Gc<Pat>>),\n     PatEnum(Path, Option<Vec<Gc<Pat>>>), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n     PatStruct(Path, Vec<FieldPat>, bool),\n@@ -818,7 +818,7 @@ pub struct Arg {\n \n impl Arg {\n     pub fn new_self(span: Span, mutability: Mutability) -> Arg {\n-        let path = ast_util::ident_to_path(span, special_idents::self_);\n+        let path = Spanned{span:span,node:special_idents::self_};\n         Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {"}, {"sha": "036d6b4b43adc62d537c8c0f9dfc745964d6bca3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -33,12 +33,6 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n     }).collect::<Vec<String>>().connect(\"::\")\n }\n \n-// totally scary function: ignores all but the last element, should have\n-// a different name\n-pub fn path_to_ident(path: &Path) -> Ident {\n-    path.segments.last().unwrap().identifier\n-}\n-\n pub fn local_def(id: NodeId) -> DefId {\n     ast::DefId { krate: LOCAL_CRATE, node: id }\n }\n@@ -186,6 +180,8 @@ pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n     })\n }\n \n+// convert a span and an identifier to the corresponding\n+// 1-segment path\n pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     ast::Path {\n         span: s,\n@@ -202,7 +198,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n \n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n     box(GC) ast::Pat { id: id,\n-                node: PatIdent(BindByValue(MutImmutable), ident_to_path(s, i), None),\n+                node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n                 span: s }\n }\n "}, {"sha": "46bc4ec11ce4f044ac14b35d1f603042558bf089", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -759,8 +759,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> Gc<ast::Pat> {\n-        let path = self.path_ident(span, ident);\n-        let pat = ast::PatIdent(bm, path, None);\n+        let pat = ast::PatIdent(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n     fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {"}, {"sha": "b9bc500933750d53a6a703448c3608c50d2ee70a", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -1049,7 +1049,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: Vec<ast::Path> ,\n+                          field_paths: Vec<ast::SpannedIdent> ,\n                           mutbl: ast::Mutability)\n                           -> Vec<Gc<ast::Pat>> {\n         field_paths.iter().map(|path| {\n@@ -1095,15 +1095,10 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `deriving`\");\n                 }\n             };\n-            let path =\n-                cx.path_ident(sp,\n-                              cx.ident_of(format!(\"{}_{}\",\n-                                                  prefix,\n-                                                  i).as_slice()));\n-            paths.push(path.clone());\n+            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+            paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n-                sp, ast::ExprParen(\n-                    cx.expr_deref(sp, cx.expr_path(path))));\n+                sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n             ident_expr.push((sp, opt_id, val));\n         }\n \n@@ -1145,15 +1140,11 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let path =\n-                        cx.path_ident(sp,\n-                                      cx.ident_of(format!(\"{}_{}\",\n-                                                          prefix,\n-                                                          i).as_slice()));\n-\n-                    paths.push(path.clone());\n-                    let val = cx.expr(\n-                        sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+                    let path1 = codemap::Spanned{span: sp, node: ident};\n+                    paths.push(path1);\n+                    let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n+                    let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, expr_path)));\n                     ident_expr.push((sp, None, val));\n                 }\n "}, {"sha": "d1eb0147b9cf454253dc9adc4b4b5dd5d2f87785", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -705,22 +705,10 @@ impl Visitor<()> for NameFinderContext {\n             // we found a pat_ident!\n             ast::Pat {\n                 id: _,\n-                node: ast::PatIdent(_, ref path, ref inner),\n+                node: ast::PatIdent(_, ref path1, ref inner),\n                 span: _\n             } => {\n-                match path {\n-                    // a path of length one:\n-                    &ast::Path {\n-                        global: false,\n-                        span: _,\n-                        segments: ref segments\n-                    } if segments.len() == 1 => {\n-                        self.ident_accumulator.push(segments.get(0)\n-                                                            .identifier)\n-                    }\n-                    // I believe these must be enums...\n-                    _ => ()\n-                }\n+                self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of pat_ident:\n                 for subpat in inner.iter() {\n                     self.visit_pat(&**subpat, ())"}, {"sha": "f9d7078da3dcbe4377132259c3c5699ae66fca36", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -791,9 +791,10 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n     let node = match p.node {\n         PatWild => PatWild,\n         PatWildMulti => PatWildMulti,\n-        PatIdent(binding_mode, ref pth, ref sub) => {\n+        PatIdent(binding_mode, ref pth1, ref sub) => {\n             PatIdent(binding_mode,\n-                     folder.fold_path(pth),\n+                     Spanned{span: folder.new_span(pth1.span),\n+                                       node: folder.fold_ident(pth1.node)},\n                      sub.map(|x| folder.fold_pat(x)))\n         }\n         PatLit(e) => PatLit(folder.fold_expr(e)),"}, {"sha": "4b5252bfba3118eb081d8a1783d18631a265b9bc", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -594,23 +594,15 @@ mod test {\n     #[test] fn parse_ident_pat () {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n-        assert!(parser.parse_pat() ==\n-                   box(GC) ast::Pat{id: ast::DUMMY_NODE_ID,\n-                             node: ast::PatIdent(\n-                                ast::BindByValue(ast::MutImmutable),\n-                                ast::Path {\n-                                    span:sp(0,1),\n-                                    global:false,\n-                                    segments: vec!(\n-                                        ast::PathSegment {\n-                                            identifier: str_to_ident(\"b\"),\n-                                            lifetimes: Vec::new(),\n-                                            types: OwnedSlice::empty(),\n-                                        }\n-                                    ),\n-                                },\n-                                None /* no idea */),\n-                             span: sp(0,1)});\n+        assert!(parser.parse_pat()\n+                == box(GC) ast::Pat{\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),\n+                                    Spanned{ span:sp(0, 1),\n+                                             node: str_to_ident(\"b\")\n+                    },\n+                                    None),\n+                span: sp(0,1)});\n         parser_done(parser);\n     }\n \n@@ -643,24 +635,15 @@ mod test {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n-                                            ast::Path {\n-                                                span:sp(6,7),\n-                                                global:false,\n-                                                segments: vec!(\n-                                                    ast::PathSegment {\n-                                                        identifier:\n-                                                            str_to_ident(\"b\"),\n-                                                        lifetimes: Vec::new(),\n-                                                        types: OwnedSlice::empty(),\n-                                                    }\n-                                                ),\n-                                            },\n-                                            None // no idea\n-                                        ),\n-                                        span: sp(6,7)\n-                                    },\n-                                    id: ast::DUMMY_NODE_ID\n-                                }),\n+                                                Spanned{\n+                                                    span: sp(6,7),\n+                                                    node: str_to_ident(\"b\")},\n+                                                None\n+                                                    ),\n+                                            span: sp(6,7)\n+                                        },\n+                                        id: ast::DUMMY_NODE_ID\n+                                    }),\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyNil,\n                                                        span:sp(15,15)}), // not sure"}, {"sha": "2aa2da3ba4b001b81c4bc3731f9e1b7429632a74", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -58,7 +58,7 @@ use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::Visibility;\n use ast;\n-use ast_util::{as_prec, lit_is_str, operator_prec};\n+use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n@@ -2854,8 +2854,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 self.parse_pat()\n             } else {\n-                let fieldpath = ast_util::ident_to_path(self.last_span,\n-                                                        fieldname);\n+                let fieldpath = codemap::Spanned{span:self.last_span, node: fieldname};\n                 box(GC) ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n@@ -2961,6 +2960,7 @@ impl<'a> Parser<'a> {\n           }\n           _ => {}\n         }\n+        // at this point, token != _, ~, &, &&, (, [\n \n         if (!is_ident_or_path(&self.token) && self.token != token::MOD_SEP)\n                 || self.is_keyword(keywords::True)\n@@ -3017,7 +3017,9 @@ impl<'a> Parser<'a> {\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n-                let name = self.parse_path(NoTypesAllowed).path;\n+                let id = self.parse_ident();\n+                let id_span = self.last_span;\n+                let pth1 = codemap::Spanned{span:id_span, node: id};\n                 if self.eat(&token::NOT) {\n                     // macro invocation\n                     let ket = token::close_delimiter_for(&self.token)\n@@ -3028,7 +3030,7 @@ impl<'a> Parser<'a> {\n                                                     seq_sep_none(),\n                                                     |p| p.parse_token_tree());\n \n-                    let mac = MacInvocTT(name, tts, EMPTY_CTXT);\n+                    let mac = MacInvocTT(ident_to_path(id_span,id), tts, EMPTY_CTXT);\n                     pat = ast::PatMac(codemap::Spanned {node: mac, span: self.span});\n                 } else {\n                     let sub = if self.eat(&token::AT) {\n@@ -3038,7 +3040,7 @@ impl<'a> Parser<'a> {\n                         // or just foo\n                         None\n                     };\n-                    pat = PatIdent(BindByValue(MutImmutable), name, sub);\n+                    pat = PatIdent(BindByValue(MutImmutable), pth1, sub);\n                 }\n             } else {\n                 // parse an enum pat\n@@ -3084,8 +3086,11 @@ impl<'a> Parser<'a> {\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n                                   pat = PatIdent(BindByValue(MutImmutable),\n-                                                  enum_path,\n-                                                  None);\n+                                                 codemap::Spanned{\n+                                                    span: enum_path.span,\n+                                                    node: enum_path.segments.get(0)\n+                                                           .identifier},\n+                                                 None);\n                               } else {\n                                   pat = PatEnum(enum_path, Some(args));\n                               }\n@@ -3115,7 +3120,7 @@ impl<'a> Parser<'a> {\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n-        let name = self.parse_path(NoTypesAllowed).path;\n+        let name = codemap::Spanned{span: self.last_span, node: self.parse_ident()};\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat())\n         } else {"}, {"sha": "4660bb337ab23e1d46c4d8ad2fb608a214d5804c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -196,6 +196,10 @@ pub fn path_to_str(p: &ast::Path) -> String {\n     to_str(|s| s.print_path(p, false))\n }\n \n+pub fn ident_to_str(id: &ast::Ident) -> String {\n+    to_str(|s| s.print_ident(*id))\n+}\n+\n pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n@@ -1705,7 +1709,7 @@ impl<'a> State<'a> {\n         match pat.node {\n             ast::PatWild => try!(word(&mut self.s, \"_\")),\n             ast::PatWildMulti => try!(word(&mut self.s, \"..\")),\n-            ast::PatIdent(binding_mode, ref path, sub) => {\n+            ast::PatIdent(binding_mode, ref path1, sub) => {\n                 match binding_mode {\n                     ast::BindByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -1716,7 +1720,7 @@ impl<'a> State<'a> {\n                         try!(self.word_nbsp(\"mut\"));\n                     }\n                 }\n-                try!(self.print_path(path, true));\n+                try!(self.print_ident(path1.node));\n                 match sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n@@ -2148,9 +2152,8 @@ impl<'a> State<'a> {\n             ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n                 match input.pat.node {\n-                    ast::PatIdent(_, ref path, _) if\n-                        path.segments.len() == 1 &&\n-                        path.segments.get(0).identifier.name ==\n+                    ast::PatIdent(_, ref path1, _) if\n+                        path1.node.name ==\n                             parse::token::special_idents::invalid.name => {\n                         // Do nothing.\n                     }"}, {"sha": "4ab064a88b7950d3ede7d4ab57d8c05591666205", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38cb972dcfc0fdab44270257eac3405a39bd996/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e38cb972dcfc0fdab44270257eac3405a39bd996", "patch": "@@ -454,8 +454,8 @@ pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E)\n         PatRegion(ref subpattern) => {\n             visitor.visit_pat(&**subpattern, env)\n         }\n-        PatIdent(_, ref path, ref optional_subpattern) => {\n-            visitor.visit_path(path, pattern.id, env.clone());\n+        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_ident(pth1.span, pth1.node, env.clone());\n             match *optional_subpattern {\n                 None => {}\n                 Some(ref subpattern) => visitor.visit_pat(&**subpattern, env),"}]}