{"sha": "3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNDIyN2FmMTM5ZjFkYTMwNzEwYTlmMDdkYzI4ZTVhM2NjYzZmZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-10T22:51:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-10T22:51:43Z"}, "message": "Auto merge of #31409 - alexcrichton:command-exec, r=aturon\n\nThese commits are an implementation of https://github.com/rust-lang/rfcs/pull/1359 which is tracked via https://github.com/rust-lang/rust/issues/31398. The `before_exec` implementation fit easily with the current process spawning framework we have, but unfortunately the `exec` implementation required a bit of a larger refactoring. The stdio handles were all largely managed as implementation details of `std::process` and the `exec` function lived in `std::sys`, so the two didn't have access to one another.\n\nI took this as a sign that a deeper refactoring was necessary, and I personally feel that the end result is cleaner for both Windows and Unix. The commits should be separated nicely for reviewing (or all at once if you're feeling ambitious), but the changes made here were:\n\n* The process spawning on Unix was refactored in to a pre-exec and post-exec function. The post-exec function isn't allowed to do any allocations of any form, and management of transmitting errors back to the parent is managed by the pre-exec function (as it's the one that actually forks).\n* Some management of the exit status was pushed into platform-specific modules. On Unix we must cache the return value of `wait` as the pid is consumed after we wait on it, but on Windows we can just keep querying the system because the handle stays valid.\n* The `Stdio::None` variant was renamed to `Stdio::Null` to better reflect what it's doing.\n* The global lock on `CreateProcess` is now correctly positioned to avoid unintended inheritance of pipe handles that other threads are sending to their child processes. After a more careful reading of the article referenced the race is not in `CreateProcess` itself, but rather the property that handles are unintentionally shared.\n* All stdio management now happens in platform-specific modules. This provides a cleaner implementation/interpretation for `FromFraw{Fd,Handle}` for each platform as well as a cleaner transition from a configuration to what-to-do once we actually need to do the spawn.\n\nWith these refactorings in place, implementing `before_exec` and `exec` ended up both being pretty trivial! (each in their own commit)", "tree": {"sha": "d39752f1086f8d1773aded41dd30cdab39c4beac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39752f1086f8d1773aded41dd30cdab39c4beac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "html_url": "https://github.com/rust-lang/rust/commit/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d771cd5b3c736f8217ff49d57a409b7587279b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d771cd5b3c736f8217ff49d57a409b7587279b7", "html_url": "https://github.com/rust-lang/rust/commit/5d771cd5b3c736f8217ff49d57a409b7587279b7"}, {"sha": "d9c6a51c3b4b7f215a4cfcb7d3e1921fe2fa9657", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c6a51c3b4b7f215a4cfcb7d3e1921fe2fa9657", "html_url": "https://github.com/rust-lang/rust/commit/d9c6a51c3b4b7f215a4cfcb7d3e1921fe2fa9657"}], "stats": {"total": 1388, "additions": 826, "deletions": 562}, "files": [{"sha": "8db8ad324bea984c9fd2b8d64c2e7dd2cbd84ed2", "filename": "src/libstd/process.rs", "status": "modified", "additions": 52, "deletions": 130, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -11,17 +11,16 @@\n //! Working with processes.\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n-#![allow(non_upper_case_globals)]\n \n use prelude::v1::*;\n use io::prelude::*;\n \n use ffi::OsStr;\n use fmt;\n-use io::{self, Error, ErrorKind};\n-use path;\n+use io;\n+use path::Path;\n use str;\n-use sys::pipe::{self, AnonPipe};\n+use sys::pipe::AnonPipe;\n use sys::process as imp;\n use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use thread::{self, JoinHandle};\n@@ -61,9 +60,6 @@ use thread::{self, JoinHandle};\n pub struct Child {\n     handle: imp::Process,\n \n-    /// None until wait() or wait_with_output() is called.\n-    status: Option<imp::ExitStatus>,\n-\n     /// The handle for writing to the child's stdin, if it has been captured\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n@@ -81,6 +77,17 @@ impl AsInner<imp::Process> for Child {\n     fn as_inner(&self) -> &imp::Process { &self.handle }\n }\n \n+impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n+    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -> Child {\n+        Child {\n+            handle: handle,\n+            stdin: io.stdin.map(ChildStdin::from_inner),\n+            stdout: io.stdout.map(ChildStdout::from_inner),\n+            stderr: io.stderr.map(ChildStderr::from_inner),\n+        }\n+    }\n+}\n+\n impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n@@ -110,6 +117,12 @@ impl IntoInner<AnonPipe> for ChildStdin {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStdin {\n+    fn from_inner(pipe: AnonPipe) -> ChildStdin {\n+        ChildStdin { inner: pipe }\n+    }\n+}\n+\n /// A handle to a child process's stdout\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n@@ -131,6 +144,12 @@ impl IntoInner<AnonPipe> for ChildStdout {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStdout {\n+    fn from_inner(pipe: AnonPipe) -> ChildStdout {\n+        ChildStdout { inner: pipe }\n+    }\n+}\n+\n /// A handle to a child process's stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n@@ -152,6 +171,12 @@ impl IntoInner<AnonPipe> for ChildStderr {\n     fn into_inner(self) -> AnonPipe { self.inner }\n }\n \n+impl FromInner<AnonPipe> for ChildStderr {\n+    fn from_inner(pipe: AnonPipe) -> ChildStderr {\n+        ChildStderr { inner: pipe }\n+    }\n+}\n+\n /// The `Command` type acts as a process builder, providing fine-grained control\n /// over how a new process should be spawned. A default configuration can be\n /// generated using `Command::new(program)`, where `program` gives a path to the\n@@ -171,11 +196,6 @@ impl IntoInner<AnonPipe> for ChildStderr {\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Command {\n     inner: imp::Command,\n-\n-    // Details explained in the builder methods\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n }\n \n impl Command {\n@@ -191,12 +211,7 @@ impl Command {\n     /// otherwise configure the process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n-        Command {\n-            inner: imp::Command::new(program.as_ref()),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n+        Command { inner: imp::Command::new(program.as_ref()) }\n     }\n \n     /// Add an argument to pass to the program.\n@@ -209,7 +224,9 @@ impl Command {\n     /// Add multiple arguments to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n-        self.inner.args(args.iter().map(AsRef::as_ref));\n+        for arg in args {\n+            self.arg(arg.as_ref());\n+        }\n         self\n     }\n \n@@ -241,65 +258,38 @@ impl Command {\n \n     /// Sets the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n+    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdin = Some(cfg);\n+        self.inner.stdin(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdout = Some(cfg);\n+        self.inner.stdout(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stderr = Some(cfg);\n+        self.inner.stderr(cfg.0);\n         self\n     }\n \n-    fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> {\n-        let default_io = Stdio(default_io);\n-\n-        // See comment on `setup_io` for what `_drop_later` is.\n-        let (their_stdin, our_stdin, _drop_later) = try!(\n-            setup_io(self.stdin.as_ref().unwrap_or(&default_io), true)\n-        );\n-        let (their_stdout, our_stdout, _drop_later) = try!(\n-            setup_io(self.stdout.as_ref().unwrap_or(&default_io), false)\n-        );\n-        let (their_stderr, our_stderr, _drop_later) = try!(\n-            setup_io(self.stderr.as_ref().unwrap_or(&default_io), false)\n-        );\n-\n-        match imp::Process::spawn(&self.inner, their_stdin, their_stdout,\n-                                  their_stderr) {\n-            Err(e) => Err(e),\n-            Ok(handle) => Ok(Child {\n-                handle: handle,\n-                status: None,\n-                stdin: our_stdin.map(|fd| ChildStdin { inner: fd }),\n-                stdout: our_stdout.map(|fd| ChildStdout { inner: fd }),\n-                stderr: our_stderr.map(|fd| ChildStderr { inner: fd }),\n-            })\n-        }\n-    }\n-\n     /// Executes the command as a child process, returning a handle to it.\n     ///\n     /// By default, stdin, stdout and stderr are inherited from the parent.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        self.spawn_inner(StdioImp::Inherit)\n+        self.inner.spawn(imp::Stdio::Inherit).map(Child::from_inner)\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -322,7 +312,8 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.spawn_inner(StdioImp::MakePipe).and_then(|p| p.wait_with_output())\n+        self.inner.spawn(imp::Stdio::MakePipe).map(Child::from_inner)\n+            .and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a command as a child process, waiting for it to finish and\n@@ -365,33 +356,6 @@ impl AsInnerMut<imp::Command> for Command {\n     fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }\n }\n \n-// Takes a `Stdio` configuration (this module) and whether the to-be-owned\n-// handle will be readable.\n-//\n-// Returns a triple of (stdio to spawn with, stdio to store, stdio to drop). The\n-// stdio to spawn with is passed down to the `sys` module and indicates how the\n-// stdio stream should be set up. The \"stdio to store\" is an object which\n-// should be returned in the `Child` that makes its way out. The \"stdio to drop\"\n-// represents the raw value of \"stdio to spawn with\", but is the owned variant\n-// for it. This needs to be dropped after the child spawns\n-fn setup_io(io: &Stdio, readable: bool)\n-            -> io::Result<(imp::Stdio, Option<AnonPipe>, Option<AnonPipe>)>\n-{\n-    Ok(match io.0 {\n-        StdioImp::MakePipe => {\n-            let (reader, writer) = try!(pipe::anon_pipe());\n-            if readable {\n-                (imp::Stdio::Raw(reader.raw()), Some(writer), Some(reader))\n-            } else {\n-                (imp::Stdio::Raw(writer.raw()), Some(reader), Some(writer))\n-            }\n-        }\n-        StdioImp::Raw(ref owned) => (imp::Stdio::Raw(owned.raw()), None, None),\n-        StdioImp::Inherit => (imp::Stdio::Inherit, None, None),\n-        StdioImp::None => (imp::Stdio::None, None, None),\n-    })\n-}\n-\n /// The output of a finished process.\n #[derive(PartialEq, Eq, Clone)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -435,34 +399,26 @@ impl fmt::Debug for Output {\n \n /// Describes what to do with a standard I/O stream for a child process.\n #[stable(feature = \"process\", since = \"1.0.0\")]\n-pub struct Stdio(StdioImp);\n-\n-// The internal enum for stdio setup; see below for descriptions.\n-enum StdioImp {\n-    MakePipe,\n-    Raw(imp::RawStdio),\n-    Inherit,\n-    None,\n-}\n+pub struct Stdio(imp::Stdio);\n \n impl Stdio {\n     /// A new pipe should be arranged to connect the parent and child processes.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn piped() -> Stdio { Stdio(StdioImp::MakePipe) }\n+    pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }\n \n     /// The child inherits from the corresponding parent descriptor.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }\n+    pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn null() -> Stdio { Stdio(StdioImp::None) }\n+    pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }\n }\n \n-impl FromInner<imp::RawStdio> for Stdio {\n-    fn from_inner(inner: imp::RawStdio) -> Stdio {\n-        Stdio(StdioImp::Raw(inner))\n+impl FromInner<imp::Stdio> for Stdio {\n+    fn from_inner(inner: imp::Stdio) -> Stdio {\n+        Stdio(inner)\n     }\n }\n \n@@ -506,34 +462,7 @@ impl Child {\n     /// SIGKILL on unix platforms.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n-        #[cfg(unix)] fn collect_status(p: &mut Child) {\n-            // On Linux (and possibly other unices), a process that has exited will\n-            // continue to accept signals because it is \"defunct\". The delivery of\n-            // signals will only fail once the child has been reaped. For this\n-            // reason, if the process hasn't exited yet, then we attempt to collect\n-            // their status with WNOHANG.\n-            if p.status.is_none() {\n-                match p.handle.try_wait() {\n-                    Some(status) => { p.status = Some(status); }\n-                    None => {}\n-                }\n-            }\n-        }\n-        #[cfg(windows)] fn collect_status(_p: &mut Child) {}\n-\n-        collect_status(self);\n-\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.status.is_some() {\n-            return Err(Error::new(\n-                ErrorKind::InvalidInput,\n-                \"invalid argument: can't kill an exited process\",\n-            ))\n-        }\n-\n-        unsafe { self.handle.kill() }\n+        self.handle.kill()\n     }\n \n     /// Returns the OS-assigned process identifier associated with this child.\n@@ -553,14 +482,7 @@ impl Child {\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         drop(self.stdin.take());\n-        match self.status {\n-            Some(code) => Ok(ExitStatus(code)),\n-            None => {\n-                let status = try!(self.handle.wait());\n-                self.status = Some(status);\n-                Ok(ExitStatus(status))\n-            }\n-        }\n+        self.handle.wait().map(ExitStatus)\n     }\n \n     /// Simultaneously waits for the child to exit and collect all remaining"}, {"sha": "fa19a2620bacffcd83a0a9fd4460a099cbf54551", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -12,8 +12,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use os::unix::raw::{uid_t, gid_t};\n+use prelude::v1::*;\n+\n+use io;\n use os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use os::unix::raw::{uid_t, gid_t};\n use process;\n use sys;\n use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n@@ -44,6 +47,56 @@ pub trait CommandExt {\n     #[unstable(feature = \"process_session_leader\", reason = \"recently added\",\n                issue = \"27811\")]\n     fn session_leader(&mut self, on: bool) -> &mut process::Command;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// The closure is allowed to return an I/O error whose OS error code will\n+    /// be communicated back to the parent and returned as an error from when\n+    /// the spawn was requested.\n+    ///\n+    /// Multiple closures can be registered and they will be called in order of\n+    /// their registration. If a closure returns `Err` then no further closures\n+    /// will be called and the spawn operation will immediately return with a\n+    /// failure.\n+    ///\n+    /// # Notes\n+    ///\n+    /// This closure will be run in the context of the child process after a\n+    /// `fork`. This primarily means that any modificatons made to memory on\n+    /// behalf of this closure will **not** be visible to the parent process.\n+    /// This is often a very constrained environment where normal operations\n+    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n+    /// other threads perhaps still running when the `fork` was run).\n+    ///\n+    /// When this closure is run, aspects such as the stdio file descriptors and\n+    /// working directory have successfully been changed, so output to these\n+    /// locations may not appear where intended.\n+    #[unstable(feature = \"process_exec\", issue = \"31398\")]\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Performs all the required setup by this `Command`, followed by calling\n+    /// the `execvp` syscall.\n+    ///\n+    /// On success this function will not return, and otherwise it will return\n+    /// an error indicating why the exec (or another part of the setup of the\n+    /// `Command`) failed.\n+    ///\n+    /// This function, unlike `spawn`, will **not** `fork` the process to create\n+    /// a new child. Like spawn, however, the default behavior for the stdio\n+    /// descriptors will be to inherited from the current process.\n+    ///\n+    /// # Notes\n+    ///\n+    /// The process may be in a \"broken state\" if this function returns in\n+    /// error. For example the working directory, environment variables, signal\n+    /// handling settings, various user/group information, or aspects of stdio\n+    /// file descriptors may have changed. If a \"transactional spawn\" is\n+    /// required to gracefully handle errors it is recommended to use the\n+    /// cross-platform `spawn` instead.\n+    #[unstable(feature = \"process_exec\", issue = \"31398\")]\n+    fn exec(&mut self) -> io::Error;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -62,6 +115,17 @@ impl CommandExt for process::Command {\n         self.as_inner_mut().session_leader(on);\n         self\n     }\n+\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        self.as_inner_mut().before_exec(Box::new(f));\n+        self\n+    }\n+\n+    fn exec(&mut self) -> io::Error {\n+        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n+    }\n }\n \n /// Unix-specific extensions to `std::process::ExitStatus`\n@@ -82,7 +146,9 @@ impl ExitStatusExt for process::ExitStatus {\n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawFd for process::Stdio {\n     unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        process::Stdio::from_inner(sys::fd::FileDesc::new(fd))\n+        let fd = sys::fd::FileDesc::new(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n     }\n }\n "}, {"sha": "667f0f9e6bf62044775dbad7850cfcc0b2685db8", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -61,7 +61,6 @@ impl AnonPipe {\n         self.0.write(buf)\n     }\n \n-    pub fn raw(&self) -> libc::c_int { self.0.raw() }\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n     pub fn into_fd(self) -> FileDesc { self.0 }\n }"}, {"sha": "28475f50ce63e49267b9f7e63314a7793e33fb6f", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 385, "deletions": 319, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -8,89 +8,186 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_snake_case)]\n-\n use prelude::v1::*;\n use os::unix::prelude::*;\n \n-use collections::HashMap;\n+use collections::hash_map::{HashMap, Entry};\n use env;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n+use libc::{self, pid_t, c_int, gid_t, uid_t, c_char};\n+use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n-use sys::pipe::AnonPipe;\n+use sys::pipe::{self, AnonPipe};\n use sys::{self, cvt, cvt_r};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Clone)]\n pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n     program: CString,\n     args: Vec<CString>,\n-    env: Option<HashMap<OsString, OsString>>, // Guaranteed to have no NULs.\n+    env: Option<HashMap<OsString, (usize, CString)>>,\n+    argv: Vec<*const c_char>,\n+    envp: Option<Vec<*const c_char>>,\n+\n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n     gid: Option<gid_t>,\n     session_leader: bool,\n     saw_nul: bool,\n+    closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+struct ChildPipes {\n+    stdin: ChildStdio,\n+    stdout: ChildStdio,\n+    stderr: ChildStdio,\n+}\n+\n+enum ChildStdio {\n+    Inherit,\n+    Explicit(c_int),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n }\n \n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n         Command {\n-            program: os2c(program, &mut saw_nul),\n+            argv: vec![program.as_ptr(), 0 as *const _],\n+            program: program,\n             args: Vec::new(),\n             env: None,\n+            envp: None,\n             cwd: None,\n             uid: None,\n             gid: None,\n             session_leader: false,\n             saw_nul: saw_nul,\n+            closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n         }\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(os2c(arg, &mut self.saw_nul));\n-    }\n-    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        let mut saw_nul = self.saw_nul;\n-        self.args.extend(args.map(|arg| os2c(arg, &mut saw_nul)));\n-        self.saw_nul = saw_nul;\n+        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n+        // pointer.\n+        let arg = os2c(arg, &mut self.saw_nul);\n+        self.argv[self.args.len() + 1] = arg.as_ptr();\n+        self.argv.push(0 as *const _);\n+\n+        // Also make sure we keep track of the owned value to schedule a\n+        // destructor for this memory.\n+        self.args.push(arg);\n     }\n-    fn init_env_map(&mut self) {\n+\n+    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,\n+                                   &mut Vec<*const c_char>) {\n         if self.env.is_none() {\n-            // Will not add NULs to env: preexisting environment will not contain any.\n-            self.env = Some(env::vars_os().collect());\n+            let mut map = HashMap::new();\n+            let mut envp = Vec::new();\n+            for (k, v) in env::vars_os() {\n+                let s = pair_to_key(&k, &v, &mut self.saw_nul);\n+                envp.push(s.as_ptr());\n+                map.insert(k, (envp.len() - 1, s));\n+            }\n+            envp.push(0 as *const _);\n+            self.env = Some(map);\n+            self.envp = Some(envp);\n         }\n+        (self.env.as_mut().unwrap(), self.envp.as_mut().unwrap())\n     }\n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        let k = OsString::from_vec(os2c(key, &mut self.saw_nul).into_bytes());\n-        let v = OsString::from_vec(os2c(val, &mut self.saw_nul).into_bytes());\n \n-        // Will not add NULs to env: return without inserting if any were seen.\n-        if self.saw_nul {\n-            return;\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        let new_key = pair_to_key(key, val, &mut self.saw_nul);\n+        let (map, envp) = self.init_env_map();\n+\n+        // If `key` is already present then we we just update `envp` in place\n+        // (and store the owned value), but if it's not there we override the\n+        // trailing NULL pointer, add a new NULL pointer, and store where we\n+        // were located.\n+        match map.entry(key.to_owned()) {\n+            Entry::Occupied(mut e) => {\n+                let (i, ref mut s) = *e.get_mut();\n+                envp[i] = new_key.as_ptr();\n+                *s = new_key;\n+            }\n+            Entry::Vacant(e) => {\n+                let len = envp.len();\n+                envp[len - 1] = new_key.as_ptr();\n+                envp.push(0 as *const _);\n+                e.insert((len - 1, new_key));\n+            }\n         }\n-\n-        self.init_env_map();\n-        self.env.as_mut()\n-            .unwrap()\n-            .insert(k, v);\n     }\n+\n     pub fn env_remove(&mut self, key: &OsStr) {\n-        self.init_env_map();\n-        self.env.as_mut().unwrap().remove(key);\n+        let (map, envp) = self.init_env_map();\n+\n+        // If we actually ended up removing a key, then we need to update the\n+        // position of all keys that come after us in `envp` because they're all\n+        // one element sooner now.\n+        if let Some((i, _)) = map.remove(key) {\n+            envp.remove(i);\n+\n+            for (_, &mut (ref mut j, _)) in map.iter_mut() {\n+                if *j >= i {\n+                    *j -= 1;\n+                }\n+            }\n+        }\n     }\n+\n     pub fn env_clear(&mut self) {\n-        self.env = Some(HashMap::new())\n+        self.env = Some(HashMap::new());\n+        self.envp = Some(vec![0 as *const _]);\n     }\n+\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(os2c(dir, &mut self.saw_nul));\n     }\n@@ -103,147 +200,66 @@ impl Command {\n     pub fn session_leader(&mut self, session_leader: bool) {\n         self.session_leader = session_leader;\n     }\n-}\n-\n-fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n-    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"<string-with-nul>\").unwrap()\n-    })\n-}\n \n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n-        }\n-        Ok(())\n+    pub fn before_exec(&mut self,\n+                       f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n+        self.closures.push(f);\n     }\n-}\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"android\",\n-          target_os = \"nacl\", target_os = \"solaris\",\n-          target_os = \"emscripten\"))]\n-mod status_imp {\n-    pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-    pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-    pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n-}\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\"))]\n-mod status_imp {\n-    pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-    pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-    pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-}\n-\n-impl ExitStatus {\n-    fn exited(&self) -> bool {\n-        status_imp::WIFEXITED(self.0)\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n     }\n-\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n     }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() {\n-            Some(status_imp::WEXITSTATUS(self.0))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() {\n-            Some(status_imp::WTERMSIG(self.0))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n     }\n-}\n \n-/// The unique id of the process (this should never be negative).\n-pub struct Process {\n-    pid: pid_t\n-}\n+    pub fn spawn(&mut self, default: Stdio)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n-pub enum Stdio {\n-    Inherit,\n-    None,\n-    Raw(c_int),\n-}\n-\n-pub type RawStdio = FileDesc;\n-\n-const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n-impl Process {\n-    pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(libc::kill(self.pid, libc::SIGKILL)));\n-        Ok(())\n-    }\n-\n-    pub fn spawn(cfg: &Command,\n-                 in_fd: Stdio,\n-                 out_fd: Stdio,\n-                 err_fd: Stdio) -> io::Result<Process> {\n-        if cfg.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n+        if self.saw_nul {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n         }\n \n-        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n-        let (argv, _a) = make_argv(&cfg.program, &cfg.args);\n+        let (ours, theirs) = try!(self.setup_io(default));\n         let (input, output) = try!(sys::pipe::anon_pipe());\n \n         let pid = unsafe {\n-            match libc::fork() {\n+            match try!(cvt(libc::fork())) {\n                 0 => {\n                     drop(input);\n-                    Process::child_after_fork(cfg, output, argv, envp, dirp,\n-                                              in_fd, out_fd, err_fd)\n+                    let err = self.do_exec(theirs);\n+                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                    // we want to be sure we *don't* run at_exit destructors as\n+                    // we're being torn down regardless\n+                    assert!(output.write(&bytes).is_ok());\n+                    libc::_exit(1)\n                 }\n-                n if n < 0 => return Err(Error::last_os_error()),\n                 n => n,\n             }\n         };\n \n-        let p = Process{ pid: pid };\n+        let mut p = Process { pid: pid, status: None };\n         drop(output);\n         let mut bytes = [0; 8];\n \n         // loop to handle EINTR\n         loop {\n             match input.read(&mut bytes) {\n-                Ok(0) => return Ok(p),\n+                Ok(0) => return Ok((p, ours)),\n                 Ok(8) => {\n                     assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n                             \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n@@ -276,6 +292,18 @@ impl Process {\n         }\n     }\n \n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default) {\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Err(e) => e,\n+        }\n+    }\n+\n     // And at this point we've reached a special time in the life of the\n     // child. The child must now be considered hamstrung and unable to\n     // do anything other than syscalls really. Consider the following\n@@ -306,98 +334,28 @@ impl Process {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke libc::exit)\n-    unsafe fn child_after_fork(cfg: &Command,\n-                               mut output: AnonPipe,\n-                               argv: *const *const libc::c_char,\n-                               envp: *const libc::c_void,\n-                               dirp: *const libc::c_char,\n-                               in_fd: Stdio,\n-                               out_fd: Stdio,\n-                               err_fd: Stdio) -> ! {\n-        fn fail(output: &mut AnonPipe) -> ! {\n-            let errno = sys::os::errno() as u32;\n-            let bytes = [\n-                (errno >> 24) as u8,\n-                (errno >> 16) as u8,\n-                (errno >>  8) as u8,\n-                (errno >>  0) as u8,\n-                CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-            ];\n-            // pipe I/O up to PIPE_BUF bytes should be atomic, and then we want\n-            // to be sure we *don't* run at_exit destructors as we're being torn\n-            // down regardless\n-            assert!(output.write(&bytes).is_ok());\n-            unsafe { libc::_exit(1) }\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        macro_rules! try {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n         }\n \n-        // Make sure that the source descriptors are not an stdio descriptor,\n-        // otherwise the order which we set the child's descriptors may blow\n-        // away a descriptor which we are hoping to save. For example,\n-        // suppose we want the child's stderr to be the parent's stdout, and\n-        // the child's stdout to be the parent's stderr. No matter which we\n-        // dup first, the second will get overwritten prematurely.\n-        let maybe_migrate = |src: Stdio, output: &mut AnonPipe| {\n-            match src {\n-                Stdio::Raw(fd @ libc::STDIN_FILENO) |\n-                Stdio::Raw(fd @ libc::STDOUT_FILENO) |\n-                Stdio::Raw(fd @ libc::STDERR_FILENO) => {\n-                    let fd = match cvt_r(|| libc::dup(fd)) {\n-                        Ok(fd) => fd,\n-                        Err(_) => fail(output),\n-                    };\n-                    let fd = FileDesc::new(fd);\n-                    fd.set_cloexec();\n-                    Stdio::Raw(fd.into_raw())\n-                },\n-\n-                s @ Stdio::None |\n-                s @ Stdio::Inherit |\n-                s @ Stdio::Raw(_) => s,\n-            }\n-        };\n-\n-        let setup = |src: Stdio, dst: c_int| {\n-            match src {\n-                Stdio::Inherit => true,\n-                Stdio::Raw(fd) => cvt_r(|| libc::dup2(fd, dst)).is_ok(),\n-\n-                // If a stdio file descriptor is set to be ignored, we open up\n-                // /dev/null into that file descriptor. Otherwise, the first\n-                // file descriptor opened up in the child would be numbered as\n-                // one of the stdio file descriptors, which is likely to wreak\n-                // havoc.\n-                Stdio::None => {\n-                    let mut opts = OpenOptions::new();\n-                    opts.read(dst == libc::STDIN_FILENO);\n-                    opts.write(dst != libc::STDIN_FILENO);\n-                    let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n-                                                    as *const _);\n-                    if let Ok(f) = File::open_c(devnull, &opts) {\n-                        cvt_r(|| libc::dup2(f.fd().raw(), dst)).is_ok()\n-                    } else {\n-                        false\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Make sure we migrate all source descriptors before\n-        // we start overwriting them\n-        let in_fd = maybe_migrate(in_fd, &mut output);\n-        let out_fd = maybe_migrate(out_fd, &mut output);\n-        let err_fd = maybe_migrate(err_fd, &mut output);\n-\n-        if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-        if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-        if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+        if let Some(fd) = stdio.stdin.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            try!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+        }\n \n-        if let Some(u) = cfg.gid {\n-            if libc::setgid(u as libc::gid_t) != 0 {\n-                fail(&mut output);\n-            }\n+        if let Some(u) = self.gid {\n+            try!(cvt(libc::setgid(u as gid_t)));\n         }\n-        if let Some(u) = cfg.uid {\n+        if let Some(u) = self.uid {\n             // When dropping privileges from root, the `setgroups` call\n             // will remove any extraneous groups. If we don't call this,\n             // then even though our uid has dropped, we may still have\n@@ -407,26 +365,23 @@ impl Process {\n             // privilege dropping function.\n             let _ = libc::setgroups(0, ptr::null());\n \n-            if libc::setuid(u as libc::uid_t) != 0 {\n-                fail(&mut output);\n-            }\n+            try!(cvt(libc::setuid(u as uid_t)));\n         }\n-        if cfg.session_leader {\n+        if self.session_leader {\n             // Don't check the error of setsid because it fails if we're the\n             // process leader already. We just forked so it shouldn't return\n             // error, but ignore it anyway.\n             let _ = libc::setsid();\n         }\n-        if !dirp.is_null() && libc::chdir(dirp) == -1 {\n-            fail(&mut output);\n+        if let Some(ref cwd) = self.cwd {\n+            try!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if !envp.is_null() {\n-            *sys::os::environ() = envp as *const _;\n+        if let Some(ref envp) = self.envp {\n+            *sys::os::environ() = envp.as_ptr();\n         }\n \n-        #[cfg(not(target_os = \"nacl\"))]\n-        unsafe fn reset_signal_handling(output: &mut AnonPipe) {\n-            use mem;\n+        // NaCl has no signal support.\n+        if cfg!(not(target_os = \"nacl\")) {\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored\n@@ -435,93 +390,205 @@ impl Process {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set: libc::sigset_t = mem::uninitialized();\n-            if libc::sigemptyset(&mut set) != 0 ||\n-                libc::pthread_sigmask(libc::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n-                libc::signal(\n-                    libc::SIGPIPE, mem::transmute(libc::SIG_DFL)\n-                        ) == mem::transmute(libc::SIG_ERR)\n-            {\n-                fail(output);\n+            try!(cvt(libc::sigemptyset(&mut set)));\n+            try!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                           ptr::null_mut())));\n+            let ret = libc::signal(libc::SIGPIPE, libc::SIG_DFL);\n+            if ret == libc::SIG_ERR {\n+                return io::Error::last_os_error()\n             }\n         }\n-        #[cfg(target_os = \"nacl\")]\n-        unsafe fn reset_signal_handling(_output: &mut AnonPipe) {\n-            // NaCl has no signal support.\n+\n+        for callback in self.closures.iter_mut() {\n+            try!(callback());\n         }\n-        reset_signal_handling(&mut output);\n \n-        let _ = libc::execvp(*argv, argv);\n-        fail(&mut output)\n+        libc::execvp(self.argv[0], self.argv.as_ptr());\n+        io::Error::last_os_error()\n     }\n \n-    pub fn id(&self) -> u32 {\n-        self.pid as u32\n+\n+    fn setup_io(&self, default: Stdio) -> io::Result<(StdioPipes, ChildPipes)> {\n+        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = try!(stdin.to_child_stdio(true));\n+        let (their_stdout, our_stdout) = try!(stdout.to_child_stdio(false));\n+        let (their_stderr, our_stderr) = try!(stderr.to_child_stdio(false));\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n     }\n+}\n \n-    pub fn wait(&self) -> io::Result<ExitStatus> {\n-        let mut status = 0 as c_int;\n-        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n-        Ok(ExitStatus(status))\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n+}\n+\n+impl Stdio {\n+    fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                    Ok((ChildStdio::Owned(try!(fd.duplicate())), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let path = unsafe {\n+                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n+                };\n+                let fd = try!(File::open_c(&path, &opts));\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n     }\n+}\n \n-    pub fn try_wait(&self) -> Option<ExitStatus> {\n-        let mut status = 0 as c_int;\n-        match cvt_r(|| unsafe {\n-            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n-        }) {\n-            Ok(0) => None,\n-            Ok(n) if n == self.pid => Some(ExitStatus(status)),\n-            Ok(n) => panic!(\"unknown pid: {}\", n),\n-            Err(e) => panic!(\"unknown waitpid error: {}\", e),\n+impl ChildStdio {\n+    fn fd(&self) -> Option<c_int> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n         }\n     }\n }\n \n-fn make_argv(prog: &CString, args: &[CString])\n-             -> (*const *const libc::c_char, Vec<*const libc::c_char>)\n-{\n-    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n+fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n+    let (key, value) = (key.as_bytes(), value.as_bytes());\n+    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n+    v.extend(key);\n+    v.push(b'=');\n+    v.extend(value);\n+    CString::new(v).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"foo=bar\").unwrap()\n+    })\n+}\n \n-    // Convert the CStrings into an array of pointers. Also return the\n-    // vector that owns the raw pointers, to ensure they live long\n-    // enough.\n-    ptrs.push(prog.as_ptr());\n-    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n \n-    // Add a terminating null pointer (required by libc).\n-    ptrs.push(ptr::null());\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n \n-    (ptrs.as_ptr(), ptrs)\n+impl ExitStatus {\n+    fn exited(&self) -> bool {\n+        unsafe { libc::WIFEXITED(self.0) }\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some(unsafe { libc::WEXITSTATUS(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(unsafe { libc::WTERMSIG(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n-fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n-             -> (*const c_void, Vec<Vec<u8>>, Vec<*const libc::c_char>)\n-{\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. As with make_argv, we\n-    // return two vectors that own the data to ensure that they live\n-    // long enough.\n-    if let Some(env) = env {\n-        let mut tmps = Vec::with_capacity(env.len());\n-\n-        for pair in env {\n-            let mut kv = Vec::new();\n-            kv.extend_from_slice(pair.0.as_bytes());\n-            kv.push('=' as u8);\n-            kv.extend_from_slice(pair.1.as_bytes());\n-            kv.push(0); // terminating null\n-            tmps.push(kv);\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n         }\n+    }\n+}\n \n-        let mut ptrs: Vec<*const libc::c_char> =\n-            tmps.iter()\n-                .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                .collect();\n-        ptrs.push(ptr::null());\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n+}\n \n-        (ptrs.as_ptr() as *const _, tmps, ptrs)\n-    } else {\n-        (ptr::null(), Vec::new(), Vec::new())\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n+        self.status = Some(ExitStatus(status));\n+        Ok(ExitStatus(status))\n     }\n }\n \n@@ -534,7 +601,7 @@ mod tests {\n     use mem;\n     use ptr;\n     use libc;\n-    use sys::{self, cvt};\n+    use sys::cvt;\n \n     macro_rules! t {\n         ($e:expr) => {\n@@ -570,21 +637,20 @@ mod tests {\n     fn test_process_mask() {\n         unsafe {\n             // Test to make sure that a signal mask does not get inherited.\n-            let cmd = Command::new(OsStr::new(\"cat\"));\n-            let (stdin_read, stdin_write) = t!(sys::pipe::anon_pipe());\n-            let (stdout_read, stdout_write) = t!(sys::pipe::anon_pipe());\n+            let mut cmd = Command::new(OsStr::new(\"cat\"));\n \n             let mut set: libc::sigset_t = mem::uninitialized();\n             let mut old_set: libc::sigset_t = mem::uninitialized();\n             t!(cvt(libc::sigemptyset(&mut set)));\n             t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n \n-            let cat = t!(Process::spawn(&cmd, Stdio::Raw(stdin_read.raw()),\n-                                              Stdio::Raw(stdout_write.raw()),\n-                                              Stdio::None));\n-            drop(stdin_read);\n-            drop(stdout_write);\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n \n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n                                          ptr::null_mut())));"}, {"sha": "f6ee59eec327ae936f06b95dcaaf4a863e2552ca", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -21,7 +21,8 @@ use sys_common::{AsInner, FromInner, IntoInner};\n impl FromRawHandle for process::Stdio {\n     unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio {\n         let handle = sys::handle::Handle::new(handle as *mut _);\n-        process::Stdio::from_inner(handle)\n+        let io = sys::process::Stdio::Handle(handle);\n+        process::Stdio::from_inner(io)\n     }\n }\n "}, {"sha": "aec41885f3b879123c5f624bade4e09f80ce7b03", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -37,8 +37,6 @@ impl AnonPipe {\n     pub fn handle(&self) -> &Handle { &self.inner }\n     pub fn into_handle(self) -> Handle { self.inner }\n \n-    pub fn raw(&self) -> c::HANDLE { self.inner.raw() }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }"}, {"sha": "fa118be6fe6b19c8908fc61e7ffc6bd4032e19cb", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 157, "deletions": 107, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -26,9 +26,9 @@ use path::Path;\n use ptr;\n use sync::StaticMutex;\n use sys::c;\n-\n use sys::fs::{OpenOptions, File};\n-use sys::handle::{Handle, RawHandle};\n+use sys::handle::Handle;\n+use sys::pipe::{self, AnonPipe};\n use sys::stdio;\n use sys::{self, cvt};\n use sys_common::{AsInner, FromInner};\n@@ -51,13 +51,28 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     }\n }\n \n-#[derive(Clone)]\n pub struct Command {\n     program: OsString,\n     args: Vec<OsString>,\n     env: Option<HashMap<OsString, OsString>>,\n     cwd: Option<OsString>,\n     detach: bool, // not currently exposed in std::process\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Handle(Handle),\n+}\n+\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n }\n \n impl Command {\n@@ -68,15 +83,15 @@ impl Command {\n             env: None,\n             cwd: None,\n             detach: false,\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n         }\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n         self.args.push(arg.to_os_string())\n     }\n-    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        self.args.extend(args.map(OsStr::to_os_string))\n-    }\n     fn init_env_map(&mut self){\n         if self.env.is_none() {\n             self.env = Some(env::vars_os().map(|(key, val)| {\n@@ -98,56 +113,29 @@ impl Command {\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(dir.to_os_string())\n     }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n-        }\n-        Ok(())\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// A value representing a child process.\n-///\n-/// The lifetime of this value is linked to the lifetime of the actual\n-/// process - the Process destructor calls self.finish() which waits\n-/// for the process to terminate.\n-pub struct Process {\n-    handle: Handle,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    None,\n-    Raw(c::HANDLE),\n-}\n-\n-pub type RawStdio = Handle;\n \n-impl Process {\n-    pub fn spawn(cfg: &Command,\n-                 in_handle: Stdio,\n-                 out_handle: Stdio,\n-                 err_handle: Stdio) -> io::Result<Process>\n-    {\n+    pub fn spawn(&mut self, default: Stdio)\n+                 -> io::Result<(Process, StdioPipes)> {\n         // To have the spawning semantics of unix/windows stay the same, we need\n         // to read the *child's* PATH if one is provided. See #15149 for more\n         // details.\n-        let program = cfg.env.as_ref().and_then(|env| {\n+        let program = self.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n                 if OsStr::new(\"PATH\") != &**key { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n                 for path in split_paths(&v) {\n-                    let path = path.join(cfg.program.to_str().unwrap())\n+                    let path = path.join(self.program.to_str().unwrap())\n                                    .with_extension(env::consts::EXE_EXTENSION);\n                     if fs::metadata(&path).is_ok() {\n                         return Some(path.into_os_string())\n@@ -162,33 +150,50 @@ impl Process {\n         si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n-        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n-        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n-        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n-\n-        si.hStdInput = stdin.raw();\n-        si.hStdOutput = stdout.raw();\n-        si.hStdError = stderr.raw();\n-\n-        let program = program.as_ref().unwrap_or(&cfg.program);\n-        let mut cmd_str = try!(make_command_line(program, &cfg.args));\n+        let program = program.as_ref().unwrap_or(&self.program);\n+        let mut cmd_str = try!(make_command_line(program, &self.args));\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n         let mut flags = c::CREATE_UNICODE_ENVIRONMENT;\n-        if cfg.detach {\n+        if self.detach {\n             flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        let (envp, _data) = try!(make_envp(cfg.env.as_ref()));\n-        let (dirp, _data) = try!(make_dirp(cfg.cwd.as_ref()));\n+        let (envp, _data) = try!(make_envp(self.env.as_ref()));\n+        let (dirp, _data) = try!(make_dirp(self.cwd.as_ref()));\n         let mut pi = zeroed_process_information();\n-        try!(unsafe {\n-            // `CreateProcess` is racy!\n-            // http://support.microsoft.com/kb/315939\n-            static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n-            let _lock = CREATE_PROCESS_LOCK.lock();\n \n+        // Prepare all stdio handles to be inherited by the child. This\n+        // currently involves duplicating any existing ones with the ability to\n+        // be inherited by child processes. Note, however, that once an\n+        // inheritable handle is created, *any* spawned child will inherit that\n+        // handle. We only want our own child to inherit this handle, so we wrap\n+        // the remaining portion of this spawn in a mutex.\n+        //\n+        // For more information, msdn also has an article about this race:\n+        // http://support.microsoft.com/kb/315939\n+        static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n+        let _lock = CREATE_PROCESS_LOCK.lock();\n+\n+        let mut pipes = StdioPipes {\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        };\n+        let stdin = self.stdin.as_ref().unwrap_or(&default);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let stdin = try!(stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin));\n+        let stdout = try!(stdout.to_handle(c::STD_OUTPUT_HANDLE,\n+                                           &mut pipes.stdout));\n+        let stderr = try!(stderr.to_handle(c::STD_ERROR_HANDLE,\n+                                           &mut pipes.stderr));\n+        si.hStdInput = stdin.raw();\n+        si.hStdOutput = stdout.raw();\n+        si.hStdError = stderr.raw();\n+\n+        try!(unsafe {\n             cvt(c::CreateProcessW(ptr::null(),\n                                   cmd_str.as_mut_ptr(),\n                                   ptr::null_mut(),\n@@ -202,11 +207,96 @@ impl Process {\n         // around to be able to close it later.\n         drop(Handle::new(pi.hThread));\n \n-        Ok(Process { handle: Handle::new(pi.hProcess) })\n+        Ok((Process { handle: Handle::new(pi.hProcess) }, pipes))\n+    }\n+\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Stdio {\n+    fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>)\n+                 -> io::Result<Handle> {\n+        match *self {\n+            // If no stdio handle is available, then inherit means that it\n+            // should still be unavailable so propagate the\n+            // INVALID_HANDLE_VALUE.\n+            Stdio::Inherit => {\n+                match stdio::get(stdio_id) {\n+                    Ok(io) => io.handle().duplicate(0, true,\n+                                                    c::DUPLICATE_SAME_ACCESS),\n+                    Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (ours, theirs) = if stdio_id == c::STD_INPUT_HANDLE {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                *pipe = Some(ours);\n+                try!(cvt(unsafe {\n+                    c::SetHandleInformation(theirs.handle().raw(),\n+                                            c::HANDLE_FLAG_INHERIT,\n+                                            c::HANDLE_FLAG_INHERIT)\n+                }));\n+                Ok(theirs.into_handle())\n+            }\n+\n+            Stdio::Handle(ref handle) => {\n+                handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n+            }\n+\n+            // Open up a reference to NUL with appropriate read/write\n+            // permissions as well as the ability to be inherited to child\n+            // processes (as this is about to be inherited).\n+            Stdio::Null => {\n+                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n+                let mut sa = c::SECURITY_ATTRIBUTES {\n+                    nLength: size as c::DWORD,\n+                    lpSecurityDescriptor: ptr::null_mut(),\n+                    bInheritHandle: 1,\n+                };\n+                let mut opts = OpenOptions::new();\n+                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n+                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n+                opts.security_attributes(&mut sa);\n+                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n+                    file.into_handle()\n+                })\n+            }\n+        }\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// A value representing a child process.\n+///\n+/// The lifetime of this value is linked to the lifetime of the actual\n+/// process - the Process destructor calls self.finish() which waits\n+/// for the process to terminate.\n+pub struct Process {\n+    handle: Handle,\n+}\n \n-    pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(c::TerminateProcess(self.handle.raw(), 1)));\n+impl Process {\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        try!(cvt(unsafe {\n+            c::TerminateProcess(self.handle.raw(), 1)\n+        }));\n         Ok(())\n     }\n \n@@ -216,7 +306,7 @@ impl Process {\n         }\n     }\n \n-    pub fn wait(&self) -> io::Result<ExitStatus> {\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         unsafe {\n             let res = c::WaitForSingleObject(self.handle.raw(), c::INFINITE);\n             if res != c::WAIT_OBJECT_0 {\n@@ -370,46 +460,6 @@ fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n     }\n }\n \n-impl Stdio {\n-    fn to_handle(&self, stdio_id: c::DWORD) -> io::Result<Handle> {\n-        match *self {\n-            // If no stdio handle is available, then inherit means that it\n-            // should still be unavailable so propagate the\n-            // INVALID_HANDLE_VALUE.\n-            Stdio::Inherit => {\n-                match stdio::get(stdio_id) {\n-                    Ok(io) => io.handle().duplicate(0, true,\n-                                                    c::DUPLICATE_SAME_ACCESS),\n-                    Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n-                }\n-            }\n-            Stdio::Raw(handle) => {\n-                RawHandle::new(handle).duplicate(0, true, c::DUPLICATE_SAME_ACCESS)\n-            }\n-\n-            // Similarly to unix, we don't actually leave holes for the\n-            // stdio file descriptors, but rather open up /dev/null\n-            // equivalents. These equivalents are drawn from libuv's\n-            // windows process spawning.\n-            Stdio::None => {\n-                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n-                let mut sa = c::SECURITY_ATTRIBUTES {\n-                    nLength: size as c::DWORD,\n-                    lpSecurityDescriptor: ptr::null_mut(),\n-                    bInheritHandle: 1,\n-                };\n-                let mut opts = OpenOptions::new();\n-                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n-                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n-                opts.security_attributes(&mut sa);\n-                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n-                    file.into_handle()\n-                })\n-            }\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "16560637b692667da1e96c0588ec638c1d1f29f7", "filename": "src/test/run-pass/command-before-exec.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows - this is a unix-specific test\n+\n+#![feature(process_exec, libc)]\n+\n+extern crate libc;\n+\n+use std::env;\n+use std::io::Error;\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+use std::sync::Arc;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn main() {\n+    if let Some(arg) = env::args().skip(1).next() {\n+        match &arg[..] {\n+            \"test1\" => println!(\"hello2\"),\n+            \"test2\" => assert_eq!(env::var(\"FOO\").unwrap(), \"BAR\"),\n+            \"test3\" => assert_eq!(env::current_dir().unwrap()\n+                                      .to_str().unwrap(), \"/\"),\n+            \"empty\" => {}\n+            _ => panic!(\"unknown argument: {}\", arg),\n+        }\n+        return\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+\n+    let output = Command::new(&me).arg(\"test1\").before_exec(|| {\n+        println!(\"hello\");\n+        Ok(())\n+    }).output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"hello\\nhello2\\n\");\n+\n+    let output = Command::new(&me).arg(\"test2\").before_exec(|| {\n+        env::set_var(\"FOO\", \"BAR\");\n+        Ok(())\n+    }).output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let output = Command::new(&me).arg(\"test3\").before_exec(|| {\n+        env::set_current_dir(\"/\").unwrap();\n+        Ok(())\n+    }).output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let output = Command::new(&me).arg(\"bad\").before_exec(|| {\n+        Err(Error::from_raw_os_error(102))\n+    }).output().err().unwrap();\n+    assert_eq!(output.raw_os_error(), Some(102));\n+\n+    let pid = unsafe { libc::getpid() };\n+    assert!(pid >= 0);\n+    let output = Command::new(&me).arg(\"empty\").before_exec(move || {\n+        let child = unsafe { libc::getpid() };\n+        assert!(child >= 0);\n+        assert!(pid != child);\n+        Ok(())\n+    }).output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let mem = Arc::new(AtomicUsize::new(0));\n+    let mem2 = mem.clone();\n+    let output = Command::new(&me).arg(\"empty\").before_exec(move || {\n+        assert_eq!(mem2.fetch_add(1, Ordering::SeqCst), 0);\n+        Ok(())\n+    }).output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+    assert_eq!(mem.load(Ordering::SeqCst), 0);\n+}"}, {"sha": "039245bfd08ba9eceb748a625d4298901f9802fe", "filename": "src/test/run-pass/command-exec.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4227af139f1da30710a9f07dc28e5a3ccc6fe5/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=3f4227af139f1da30710a9f07dc28e5a3ccc6fe5", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows - this is a unix-specific test\n+// ignore-pretty\n+\n+#![feature(process_exec)]\n+\n+use std::env;\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+\n+fn main() {\n+    let mut args = env::args();\n+    let me = args.next().unwrap();\n+\n+    if let Some(arg) = args.next() {\n+        match &arg[..] {\n+            \"test1\" => println!(\"passed\"),\n+\n+            \"exec-test1\" => {\n+                let err = Command::new(&me).arg(\"test1\").exec();\n+                panic!(\"failed to spawn: {}\", err);\n+            }\n+\n+            \"exec-test2\" => {\n+                Command::new(\"/path/to/nowhere\").exec();\n+                println!(\"passed\");\n+            }\n+\n+            \"exec-test3\" => {\n+                Command::new(&me).arg(\"bad\\0\").exec();\n+                println!(\"passed\");\n+            }\n+\n+            \"exec-test4\" => {\n+                Command::new(&me).current_dir(\"/path/to/nowhere\").exec();\n+                println!(\"passed\");\n+            }\n+\n+            _ => panic!(\"unknown argument: {}\", arg),\n+        }\n+        return\n+    }\n+\n+    let output = Command::new(&me).arg(\"exec-test1\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    let output = Command::new(&me).arg(\"exec-test2\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    let output = Command::new(&me).arg(\"exec-test3\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    let output = Command::new(&me).arg(\"exec-test4\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+}"}]}