{"sha": "8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMGQ4OWFkYzgxYmUxZmE3NzY2ZmYxN2FhNGYyYzZkNWU4YzY5Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T20:27:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T20:27:43Z"}, "message": "Auto merge of #5720 - bugadani:new-lint, r=flip1995,yaahc\n\nAdd unnecessary lazy evaluation lint\n\nchangelog: Add [`unnecessary_lazy_evaluations`] lint that checks for usages of `unwrap_or_else` and similar functions that can be simplified.\n\nCloses #5715", "tree": {"sha": "643ec7d5623db9c133c8019fbfb2747a6f5d6d47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643ec7d5623db9c133c8019fbfb2747a6f5d6d47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "html_url": "https://github.com/rust-lang/rust/commit/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d723d0de18441e72264335dea3e80dd9fee970e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d723d0de18441e72264335dea3e80dd9fee970e", "html_url": "https://github.com/rust-lang/rust/commit/5d723d0de18441e72264335dea3e80dd9fee970e"}, {"sha": "fc1e07e0c1803edb3ade2db2f46034cf227642c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc1e07e0c1803edb3ade2db2f46034cf227642c9", "html_url": "https://github.com/rust-lang/rust/commit/fc1e07e0c1803edb3ade2db2f46034cf227642c9"}], "stats": {"total": 566, "additions": 561, "deletions": 5}, "files": [{"sha": "f662de122f9918bd156d9bb2005b3bc6eae674d2", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -1754,6 +1754,7 @@ Released 2018-09-13\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by"}, {"sha": "17501e8e6da4591f3f521a84dd66116e8d7c523c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -685,6 +685,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::UNINIT_ASSUMED_INIT,\n         &methods::UNNECESSARY_FILTER_MAP,\n         &methods::UNNECESSARY_FOLD,\n+        &methods::UNNECESSARY_LAZY_EVALUATIONS,\n         &methods::UNWRAP_USED,\n         &methods::USELESS_ASREF,\n         &methods::WRONG_PUB_SELF_CONVENTION,\n@@ -1360,6 +1361,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::UNINIT_ASSUMED_INIT),\n         LintId::of(&methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::USELESS_ASREF),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&methods::ZST_OFFSET),\n@@ -1540,6 +1542,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::SINGLE_CHAR_PUSH_STR),\n         LintId::of(&methods::STRING_EXTEND_CHARS),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATIONS),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&misc::TOPLEVEL_REF_ARG),\n         LintId::of(&misc::ZERO_PTR),"}, {"sha": "0f50a4c813adfede561e0e5a03b90dda3351f1e6", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -3,6 +3,7 @@ mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n+mod unnecessary_lazy_eval;\n \n use std::borrow::Cow;\n use std::fmt;\n@@ -1329,6 +1330,42 @@ declare_clippy_lint! {\n     \"`push_str()` used with a single-character string literal as parameter\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** As the counterpart to `or_fun_call`, this lint looks for unnecessary\n+    /// lazily evaluated closures on `Option` and `Result`.\n+    ///\n+    /// This lint suggests changing the following functions, when eager evaluation results in\n+    /// simpler code:\n+    ///  - `unwrap_or_else` to `unwrap_or`\n+    ///  - `and_then` to `and`\n+    ///  - `or_else` to `or`\n+    ///  - `get_or_insert_with` to `get_or_insert`\n+    ///  - `ok_or_else` to `ok_or`\n+    ///\n+    /// **Why is this bad?** Using eager evaluation is shorter and simpler in some cases.\n+    ///\n+    /// **Known problems:** It is possible, but not recommended for `Deref` and `Index` to have\n+    /// side effects. Eagerly evaluating them can change the semantics of the program.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code where clippy issues a warning\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or_else(|| 42);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or(42);\n+    /// ```\n+    pub UNNECESSARY_LAZY_EVALUATIONS,\n+    style,\n+    \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1378,6 +1415,7 @@ declare_lint_pass!(Methods => [\n     ZST_OFFSET,\n     FILETYPE_IS_FILE,\n     OPTION_AS_REF_DEREF,\n+    UNNECESSARY_LAZY_EVALUATIONS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n@@ -1398,13 +1436,19 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or_else\", \"map\"] => {\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                }\n+            },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n                 bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n             },\n             [\"or_else\", ..] => {\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n                 bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1448,6 +1492,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n             _ => {},\n         }\n \n@@ -2664,12 +2711,13 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n-) {\n+) -> bool {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n@@ -2681,10 +2729,10 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n-                return;\n+                return false;\n             }\n         } else {\n-            return;\n+            return false;\n         }\n \n         // lint message\n@@ -2714,10 +2762,14 @@ fn lint_map_unwrap_or_else<'tcx>(\n                     map_snippet, unwrap_snippet,\n                 ),\n             );\n+            return true;\n         } else if same_span && multiline {\n             span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n-        };\n+            return true;\n+        }\n     }\n+\n+    false\n }\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s"}, {"sha": "31517659c34dcbc9efa957fa7ba3c6f06603d1af", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -0,0 +1,111 @@\n+use crate::utils::{is_type_diagnostic_item, match_qpath, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::UNNECESSARY_LAZY_EVALUATIONS;\n+\n+// Return true if the expression is an accessor of any of the arguments\n+fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+    params.iter().any(|arg| {\n+        if_chain! {\n+            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+            if let [p, ..] = path.segments;\n+            then {\n+                ident.name == p.ident.name\n+            } else {\n+                false\n+            }\n+        }\n+    })\n+}\n+\n+fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+    paths.iter().any(|candidate| match_qpath(path, candidate))\n+}\n+\n+fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n+    match expr.kind {\n+        // Closures returning literals can be unconditionally simplified\n+        hir::ExprKind::Lit(_) => true,\n+\n+        hir::ExprKind::Index(ref object, ref index) => {\n+            // arguments are not being indexed into\n+            if expr_uses_argument(object, params) {\n+                false\n+            } else {\n+                // arguments are not used as index\n+                !expr_uses_argument(index, params)\n+            }\n+        },\n+\n+        // Reading fields can be simplified if the object is not an argument of the closure\n+        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+        // Paths can be simplified if the root is not the argument, this also covers None\n+        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+\n+        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+            if let hir::ExprKind::Path(ref path) = func.kind;\n+            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+            then {\n+                // Recursively check all arguments\n+                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n+            } else {\n+                false\n+            }\n+        },\n+\n+        // For anything more complex than the above, a closure is probably the right solution,\n+        // or the case is handled by an other lint\n+        _ => false,\n+    }\n+}\n+\n+/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n+/// replaced with `<fn>(return value of simple closure)`\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    args: &'tcx [hir::Expr<'_>],\n+    allow_variant_calls: bool,\n+    simplify_using: &str,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+\n+    if is_option || is_result {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+            let body = cx.tcx.hir().body(eid);\n+            let ex = &body.value;\n+            let params = &body.params;\n+\n+            if can_simplify(ex, params, allow_variant_calls) {\n+                let msg = if is_option {\n+                    \"unnecessary closure used to substitute value for `Option::None`\"\n+                } else {\n+                    \"unnecessary closure used to substitute value for `Result::Err`\"\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_LAZY_EVALUATIONS,\n+                    expr.span,\n+                    msg,\n+                    &format!(\"Use `{}` instead\", simplify_using),\n+                    format!(\n+                        \"{0}.{1}({2})\",\n+                        snippet(cx, args[0].span, \"..\"),\n+                        simplify_using,\n+                        snippet(cx, ex.span, \"..\"),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "3229c8da50778187b0cc7354590e93eeb521f241", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -2383,6 +2383,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"unnecessary_lazy_evaluations\",\n+        group: \"style\",\n+        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"unnecessary_mut_passed\",\n         group: \"style\","}, {"sha": "fa66e68794e4be0d6b1ac082c2c9b2044b0e36bb", "filename": "tests/ui/unnecessary_lazy_eval.fixed", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.fixed?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or(2);\n+    let _ = opt.unwrap_or(astronomers_pi);\n+    let _ = opt.unwrap_or(ext_str.some_field);\n+    let _ = opt.unwrap_or(ext_arr[0]);\n+    let _ = opt.and(ext_opt);\n+    let _ = opt.or(ext_opt);\n+    let _ = opt.or(None);\n+    let _ = opt.get_or_insert(2);\n+    let _ = opt.ok_or(2);\n+    let _ = opt.ok_or(ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or(2);\n+    let _ = Some(10).and(ext_opt);\n+    let _: Option<usize> = None.or(ext_opt);\n+    let _ = None.get_or_insert(2);\n+    let _: Result<usize, usize> = None.ok_or(2);\n+    let _: Option<usize> = None.or(None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or(2);\n+    let _ = deep.0.and(ext_opt);\n+    let _ = deep.0.or(None);\n+    let _ = deep.0.get_or_insert(2);\n+    let _ = deep.0.ok_or(2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or(2);\n+    let _ = res2.unwrap_or(astronomers_pi);\n+    let _ = res2.unwrap_or(ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "04f47d1aa2978f8afb54126b6d2cd97532f20521", "filename": "tests/ui/unnecessary_lazy_eval.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.rs?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -0,0 +1,117 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> usize {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_arr: [usize; 1] = [2];\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let nested_opt = Some(Some(42));\n+    let nested_tuple_opt = Some(Some((42, 43)));\n+\n+    // Should lint - Option\n+    let _ = opt.unwrap_or_else(|| 2);\n+    let _ = opt.unwrap_or_else(|| astronomers_pi);\n+    let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+    let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+    let _ = opt.and_then(|_| ext_opt);\n+    let _ = opt.or_else(|| ext_opt);\n+    let _ = opt.or_else(|| None);\n+    let _ = opt.get_or_insert_with(|| 2);\n+    let _ = opt.ok_or_else(|| 2);\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or_else(|| 2);\n+    let _ = Some(10).and_then(|_| ext_opt);\n+    let _: Option<usize> = None.or_else(|| ext_opt);\n+    let _ = None.get_or_insert_with(|| 2);\n+    let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+    let _: Option<usize> = None.or_else(|| None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or_else(|| 2);\n+    let _ = deep.0.and_then(|_| ext_opt);\n+    let _ = deep.0.or_else(|| None);\n+    let _ = deep.0.get_or_insert_with(|| 2);\n+    let _ = deep.0.ok_or_else(|| 2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(|| some_call());\n+    let _: Result<usize, usize> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n+    let _ = Some(10).and_then(|idx| Some(idx));\n+    let _: Option<usize> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<usize, usize> = Err(5);\n+    let res2: Result<usize, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or_else(|_| 2);\n+    let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+    let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res.unwrap_or_else(|err| ext_arr[err]);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+    let _: Result<usize, usize> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "5c1b2eb1f14e833bd7aecb01e58c78a7699641da", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "patch": "@@ -0,0 +1,148 @@\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |\n+   = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:38:13\n+   |\n+LL |     let _ = opt.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:39:13\n+   |\n+LL |     let _ = opt.or_else(|| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+   |\n+LL |     let _ = opt.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+   |\n+LL |     let _ = opt.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:42:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| ext_arr[0]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(ext_arr[0])`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:46:13\n+   |\n+LL |     let _ = Some(10).unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:47:13\n+   |\n+LL |     let _ = Some(10).and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:48:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+   |\n+LL |     let _ = None.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:50:35\n+   |\n+LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:51:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| None);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:54:13\n+   |\n+LL |     let _ = deep.0.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:55:13\n+   |\n+LL |     let _ = deep.0.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:56:13\n+   |\n+LL |     let _ = deep.0.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:57:13\n+   |\n+LL |     let _ = deep.0.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:58:13\n+   |\n+LL |     let _ = deep.0.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:84:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:85:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:86:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+\n+error: aborting due to 24 previous errors\n+"}]}