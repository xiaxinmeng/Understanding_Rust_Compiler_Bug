{"sha": "1855ab742458cc4359e27deadbdf3d8747ce361d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NTVhYjc0MjQ1OGNjNDM1OWUyN2RlYWRiZGYzZDg3NDdjZTM2MWQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-01-16T09:52:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-02-08T11:16:30Z"}, "message": "Restrict two-phase borrows to solely borrows introduced via autoref.\n\nAdded `-Z two-phase-beyond-autoref` to bring back old behavior (mainly\nto allow demonstration of desugared examples).\n\nUpdated tests to use aforementioned flag when necessary. (But in each\ncase where I added the flag, I made sure to also include a revision\nwithout the flag so that one can readily see what the actual behavior\nwe expect is for the initial deployment of NLL.)", "tree": {"sha": "d33b5aedc00abf0d1116a9cc70005b1de1a18658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d33b5aedc00abf0d1116a9cc70005b1de1a18658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1855ab742458cc4359e27deadbdf3d8747ce361d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1855ab742458cc4359e27deadbdf3d8747ce361d", "html_url": "https://github.com/rust-lang/rust/commit/1855ab742458cc4359e27deadbdf3d8747ce361d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1855ab742458cc4359e27deadbdf3d8747ce361d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c00266b7ac97a8c04136e14f10eb70fb64ec2c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/c00266b7ac97a8c04136e14f10eb70fb64ec2c94", "html_url": "https://github.com/rust-lang/rust/commit/c00266b7ac97a8c04136e14f10eb70fb64ec2c94"}], "stats": {"total": 109, "additions": 89, "deletions": 20}, "files": [{"sha": "c035d02a612328fa3d2b8d0e60f0548ce367577d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -420,6 +420,15 @@ pub enum BorrowKind {\n     }\n }\n \n+impl BorrowKind {\n+    pub fn allows_two_phase_borrow(&self) -> bool {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Unique => false,\n+            BorrowKind::Mut { allow_two_phase_borrow } => allow_two_phase_borrow,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n "}, {"sha": "76564b9b7d2ac7e2a1668b7ac2e5384135f3d584", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -1085,6 +1085,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select which borrowck is used (`ast`, `mir`, or `compare`)\"),\n     two_phase_borrows: bool = (false, parse_bool, [UNTRACKED],\n         \"use two-phase reserved/active distinction for `&mut` borrows in MIR borrowck\"),\n+    two_phase_beyond_autoref: bool = (false, parse_bool, [UNTRACKED],\n+        \"when using two-phase-borrows, allow two phases even for non-autoref `&mut` borrows\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,"}, {"sha": "217dfdf8d416e3117af902bde36b363e03e21f2d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -707,6 +707,15 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n+        self.tcx.sess.two_phase_borrows() &&\n+            (kind.allows_two_phase_borrow() ||\n+             self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -799,7 +808,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.tcx.sess.two_phase_borrows() && index.is_reservation()\n+                    if this.allow_two_phase_borrow(borrow.kind) && index.is_reservation()\n                     {\n                         return Control::Continue;\n                     }\n@@ -947,7 +956,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if self.tcx.sess.two_phase_borrows() {\n+                        if self.allow_two_phase_borrow(bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))"}, {"sha": "709c00ba8464a41590333caa3926b0d92181563d", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -8,16 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+\n+//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is an important corner case pointed out by Niko: one is\n // allowed to initiate a shared borrow during a reservation, but it\n // *must end* before the activation occurs.\n //\n // FIXME: for clarity, diagnostics for these cases might be better off\n // if they specifically said \"cannot activate mutable borrow of `x`\"\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n \n #![allow(dead_code)]\n \n@@ -27,35 +39,41 @@ fn ok() {\n     let mut x = 3;\n     let y = &mut x;\n     { let z = &x; read(z); }\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n }\n \n fn not_ok() {\n     let mut x = 3;\n     let y = &mut x;\n     let z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[lxl_beyond]~^   ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll_beyond]~^^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll_target]~^^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     read(z);\n }\n \n fn should_be_ok_with_nll() {\n     let mut x = 3;\n     let y = &mut x;\n     let z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     read(z);\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    // (okay with nll today)\n+    //[lxl_beyond]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with (generalized) nll today)\n }\n \n fn should_also_eventually_be_ok_with_nll() {\n     let mut x = 3;\n     let y = &mut x;\n     let _z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[lxl_beyond]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with (generalized) nll today)\n }\n \n fn main() { }"}, {"sha": "dd174981fb1e289543cee49e0f5de09585effedd", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -8,28 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is the second counter-example from Niko's blog post\n // smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n //\n // It is \"artificial\". It is meant to illustrate directly that we\n // should allow an aliasing access during reservation, but *not* while\n // the mutable borrow is active.\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n \n fn main() {\n     /*0*/ let mut i = 0;\n \n     /*1*/ let p = &mut i; // (reservation of `i` starts here)\n \n     /*2*/ let j = i;      // OK: `i` is only reserved here\n+                          //[nll_target]~^  ERROR cannot use `i` because it was mutably borrowed [E0503]\n \n     /*3*/ *p += 1;        // (mutable borrow of `i` starts here, since `p` is used)\n \n-    /*4*/ let k = i;      //[lxl]~  ERROR cannot use `i` because it was mutably borrowed [E0503]\n-                          //[nll]~^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n+    /*4*/ let k = i;      //[lxl_beyond]~   ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll_beyond]~^  ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll_target]~^^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n \n     /*5*/ *p += 1;\n "}, {"sha": "b5fda4985f23f1173a9c44d50b99249f9f887b91", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1855ab742458cc4359e27deadbdf3d8747ce361d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=1855ab742458cc4359e27deadbdf3d8747ce361d", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+\n+//[lxl_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is a corner case that the current implementation is (probably)\n // treating more conservatively than is necessary. But it also does\n@@ -19,6 +23,18 @@\n // So this test is just making a note of the current behavior, with\n // the caveat that in the future, the rules may be loosened, at which\n // point this test might be thrown out.\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n+//\n+// FIXME: in \"nll_target\", we currently see the same error reported\n+// twice. This is injected by `-Z two-phase-borrows`; not sure why as\n+// of yet.\n \n fn main() {\n     let mut vec = vec![0, 1];\n@@ -30,8 +46,10 @@ fn main() {\n         // with the shared borrow. But in the current implementation,\n         // its an error.\n         delay = &mut vec;\n-        //[lxl]~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll]~^^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[lxl_beyond]~^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_beyond]~^^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_target]~^^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_target]~|   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         shared[0];\n     }"}]}