{"sha": "c0507a63fb30a14ea7b819af8241b6555d4ffea8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNTA3YTYzZmIzMGExNGVhN2I4MTlhZjgyNDFiNjU1NWQ0ZmZlYTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-09-29T11:22:01Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-09-29T11:22:01Z"}, "message": "Invoke panic handler instead of trap for assert_* intrinsics", "tree": {"sha": "be9715acdf4e5074d6690576db3ecbd5c629ba26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be9715acdf4e5074d6690576db3ecbd5c629ba26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0507a63fb30a14ea7b819af8241b6555d4ffea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0507a63fb30a14ea7b819af8241b6555d4ffea8", "html_url": "https://github.com/rust-lang/rust/commit/c0507a63fb30a14ea7b819af8241b6555d4ffea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0507a63fb30a14ea7b819af8241b6555d4ffea8/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcb0862703698810c67829511436133040210641", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb0862703698810c67829511436133040210641", "html_url": "https://github.com/rust-lang/rust/commit/bcb0862703698810c67829511436133040210641"}], "stats": {"total": 119, "additions": 75, "deletions": 44}, "files": [{"sha": "d1b97420aa28d47fa715247040ffbec2154d3a72", "filename": "src/base.rs", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=c0507a63fb30a14ea7b819af8241b6555d4ffea8", "patch": "@@ -274,47 +274,26 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 fx.bcx.switch_to_block(failure);\n                 fx.bcx.ins().nop();\n \n-                let location = fx\n-                    .get_caller_location(bb_data.terminator().source_info.span)\n-                    .load_scalar(fx);\n-\n-                let args;\n-                let lang_item = match msg {\n+                match msg {\n                     AssertKind::BoundsCheck { ref len, ref index } => {\n                         let len = trans_operand(fx, len).load_scalar(fx);\n                         let index = trans_operand(fx, index).load_scalar(fx);\n-                        args = [index, len, location];\n-                        rustc_hir::LangItem::PanicBoundsCheck\n+                        let location = fx\n+                            .get_caller_location(bb_data.terminator().source_info.span)\n+                            .load_scalar(fx);\n+\n+                        codegen_panic_inner(\n+                            fx,\n+                            rustc_hir::LangItem::PanicBoundsCheck,\n+                            &[index, len, location],\n+                            bb_data.terminator().source_info.span,\n+                        );\n                     }\n                     _ => {\n                         let msg_str = msg.description();\n-                        let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-                        let msg_len = fx\n-                            .bcx\n-                            .ins()\n-                            .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n-                        args = [msg_ptr, msg_len, location];\n-                        rustc_hir::LangItem::Panic\n+                        codegen_panic(fx, msg_str, bb_data.terminator().source_info.span);\n                     }\n-                };\n-\n-                let def_id = fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| {\n-                    fx.tcx\n-                        .sess\n-                        .span_fatal(bb_data.terminator().source_info.span, &s)\n-                });\n-\n-                let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n-                let symbol_name = fx.tcx.symbol_name(instance).name;\n-\n-                fx.lib_call(\n-                    &*symbol_name,\n-                    vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n-                    vec![],\n-                    &args,\n-                );\n-\n-                crate::trap::trap_unreachable(fx, \"panic lang item returned\");\n+                }\n             }\n \n             TerminatorKind::SwitchInt {\n@@ -997,3 +976,45 @@ pub(crate) fn trans_operand<'tcx>(\n         Operand::Constant(const_) => crate::constant::trans_constant(fx, const_),\n     }\n }\n+\n+pub(crate) fn codegen_panic<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    msg_str: &str,\n+    span: Span,\n+) {\n+    let location = fx.get_caller_location(span).load_scalar(fx);\n+\n+    let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n+    let msg_len = fx\n+        .bcx\n+        .ins()\n+        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let args = [msg_ptr, msg_len, location];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n+}\n+\n+pub(crate) fn codegen_panic_inner<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    lang_item: rustc_hir::LangItem,\n+    args: &[Value],\n+    span: Span,\n+) {\n+    let def_id = fx\n+        .tcx\n+        .lang_items()\n+        .require(lang_item)\n+        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+\n+    let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+    let symbol_name = fx.tcx.symbol_name(instance).name;\n+\n+    fx.lib_call(\n+        &*symbol_name,\n+        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![],\n+        args,\n+    );\n+\n+    crate::trap::trap_unreachable(fx, \"panic lang item returned\");\n+}"}, {"sha": "e75e83b56d69ec7e718179f218be82beed15493e", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=c0507a63fb30a14ea7b819af8241b6555d4ffea8", "patch": "@@ -413,13 +413,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // Insert non returning intrinsics here\n             match intrinsic {\n                 \"abort\" => {\n-                    trap_panic(fx, \"Called intrinsic::abort.\");\n+                    trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n                 \"unreachable\" => {\n                     trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n                 }\n                 \"transmute\" => {\n-                    trap_unreachable(fx, \"[corruption] Transmuting to uninhabited type.\");\n+                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n             }\n@@ -819,17 +819,29 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         assert_inhabited | assert_zero_valid | assert_uninit_valid, <T> () {\n             let layout = fx.layout_of(T);\n             if layout.abi.is_uninhabited() {\n-                crate::trap::trap_panic(fx, &format!(\"attempted to instantiate uninhabited type `{}`\", T));\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to instantiate uninhabited type `{}`\", T),\n+                    span,\n+                );\n                 return;\n             }\n \n             if intrinsic == \"assert_zero_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n-                crate::trap::trap_panic(fx, &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T));\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n+                    span,\n+                );\n                 return;\n             }\n \n             if intrinsic == \"assert_uninit_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n-                crate::trap::trap_panic(fx, &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T));\n+                crate::base::codegen_panic(\n+                    fx,\n+                    &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n+                    span,\n+                );\n                 return;\n             }\n         };"}, {"sha": "f3ce0ee4beb944ce1a075e39d119bc448ca408bf", "filename": "src/trap.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0507a63fb30a14ea7b819af8241b6555d4ffea8/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=c0507a63fb30a14ea7b819af8241b6555d4ffea8", "patch": "@@ -28,15 +28,13 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n-/// Use this when `rustc_codegen_llvm` would insert a call to the panic handler.\n-///\n-/// Trap code: user0\n-pub(crate) fn trap_panic(\n+/// Trap code: user1\n+pub(crate) fn trap_abort(\n     fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>,\n     msg: impl AsRef<str>,\n ) {\n     codegen_print(fx, msg.as_ref());\n-    fx.bcx.ins().trap(TrapCode::User(0));\n+    fx.bcx.ins().trap(TrapCode::User(1));\n }\n \n /// Use this for example when a function call should never return. This will fill the current block,"}]}