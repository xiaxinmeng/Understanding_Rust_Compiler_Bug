{"sha": "e2e8746acc1d4fd236552a59f54b732680b4524e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZTg3NDZhY2MxZDRmZDIzNjU1MmE1OWY1NGI3MzI2ODBiNDUyNGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-05T18:18:50Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:15:15Z"}, "message": "resolve: Move late resolution into a separate visitor\n\nMove `Resolver` fields specific to late resolution to the new visitor.\nThe `current_module` field from `Resolver` is replaced with two `current_module`s in `LateResolutionVisitor` and `BuildReducedGraphVisitor`.\nOutside of those visitors `current_module` is replaced by passing `parent_scope` to more functions and using the parent module from it.\n\nVisibility resolution no longer have access to later resolution methods and has to use early resolution, so its diagnostics in case of errors regress slightly.", "tree": {"sha": "dec766d81966df1c227c3ee40aabe3072c0df202", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec766d81966df1c227c3ee40aabe3072c0df202"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e8746acc1d4fd236552a59f54b732680b4524e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e8746acc1d4fd236552a59f54b732680b4524e", "html_url": "https://github.com/rust-lang/rust/commit/e2e8746acc1d4fd236552a59f54b732680b4524e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e8746acc1d4fd236552a59f54b732680b4524e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19a359444295bab01de7ff44a9d72302e573bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19a359444295bab01de7ff44a9d72302e573bc9", "html_url": "https://github.com/rust-lang/rust/commit/d19a359444295bab01de7ff44a9d72302e573bc9"}], "stats": {"total": 777, "additions": 477, "deletions": 300}, "files": [{"sha": "668daaba643a8b99f84a92f4759ea23cd395c7e6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 70, "deletions": 41, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -19,6 +19,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n \n use std::cell::Cell;\n+use std::ops::{Deref, DerefMut};\n use std::ptr;\n use rustc_data_structures::sync::Lrc;\n \n@@ -115,7 +116,7 @@ impl<'a> Resolver<'a> {\n         parent_prefix: &[Segment],\n         nested: bool,\n         // The whole `use` item\n-        parent_scope: ParentScope<'a>,\n+        parent_scope: &ParentScope<'a>,\n         item: &Item,\n         vis: ty::Visibility,\n         root_span: Span,\n@@ -249,7 +250,7 @@ impl<'a> Resolver<'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope,\n+                    parent_scope.clone(),\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -266,7 +267,7 @@ impl<'a> Resolver<'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope,\n+                    parent_scope.clone(),\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -297,7 +298,7 @@ impl<'a> Resolver<'a> {\n                         // This particular use tree\n                         tree, id, &prefix, true,\n                         // The whole `use` item\n-                        parent_scope.clone(), item, vis, root_span,\n+                        parent_scope, item, vis, root_span,\n                     );\n                 }\n \n@@ -327,14 +328,16 @@ impl<'a> Resolver<'a> {\n             }\n         }\n     }\n+}\n \n+impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: ParentScope<'a>) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: &ParentScope<'a>) {\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident.gensym_if_underscore();\n         let sp = item.span;\n-        let vis = self.resolve_visibility(&item.vis);\n+        let vis = self.resolve_visibility(&item.vis, parent_scope);\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n@@ -361,7 +364,9 @@ impl<'a> Resolver<'a> {\n                 } else if orig_name == Some(kw::SelfLower) {\n                     self.graph_root\n                 } else {\n-                    let crate_id = self.crate_loader.process_extern_crate(item, &self.definitions);\n+                    let crate_id = self.resolver.crate_loader.process_extern_crate(\n+                        item, &self.resolver.definitions\n+                    );\n                     self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n@@ -372,13 +377,13 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n+                let used = self.process_legacy_macro_imports(item, module, parent_scope);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope,\n+                    parent_scope: parent_scope.clone(),\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -395,7 +400,7 @@ impl<'a> Resolver<'a> {\n                 });\n                 self.potentially_unused_imports.push(directive);\n                 let imported_binding = self.import(binding, directive);\n-                if ptr::eq(self.current_module, self.graph_root) {\n+                if ptr::eq(parent, self.graph_root) {\n                     if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root() && orig_name.is_some() &&\n                            entry.extern_crate_item.is_none() {\n@@ -455,7 +460,7 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                self.define_macro(item, expansion, &mut LegacyScope::Empty);\n+                self.define_macro(item, parent_scope);\n             }\n \n             // These items live in the type namespace.\n@@ -511,8 +516,8 @@ impl<'a> Resolver<'a> {\n \n                 // Record field names for error reporting.\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n-                    let field_vis = self.resolve_visibility(&field.vis);\n-                    if ctor_vis.is_at_least(field_vis, &*self) {\n+                    let field_vis = self.resolve_visibility(&field.vis, parent_scope);\n+                    if ctor_vis.is_at_least(field_vis, &*self.resolver) {\n                         ctor_vis = field_vis;\n                     }\n                     field.ident.map(|ident| ident.name)\n@@ -538,7 +543,7 @@ impl<'a> Resolver<'a> {\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n-                    self.resolve_visibility(&field.vis);\n+                    self.resolve_visibility(&field.vis, parent_scope);\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n@@ -614,7 +619,13 @@ impl<'a> Resolver<'a> {\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n         let parent = self.current_module;\n-        let vis = self.resolve_visibility(&item.vis);\n+        let parent_scope = &ParentScope {\n+            module: self.current_module,\n+            expansion: self.expansion,\n+            legacy: self.current_legacy_scope,\n+            derives: Vec::new(),\n+        };\n+        let vis = self.resolver.resolve_visibility(&item.vis, parent_scope);\n         self.define(parent, item.ident, ns, (res, vis, item.span, expn_id));\n     }\n \n@@ -630,7 +641,9 @@ impl<'a> Resolver<'a> {\n             self.current_module = module; // Descend into the block.\n         }\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(\n         &mut self,\n@@ -804,7 +817,9 @@ impl<'a> Resolver<'a> {\n             self.session.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n+}\n \n+impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n     fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n                                     parent_scope: &ParentScope<'a>) -> bool {\n@@ -873,7 +888,7 @@ impl<'a> Resolver<'a> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n-                    None,\n+                    parent_scope,\n                     false,\n                     ident.span,\n                 );\n@@ -918,22 +933,36 @@ impl<'a> Resolver<'a> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n+    pub current_module: Module<'b>,\n     pub current_legacy_scope: LegacyScope<'b>,\n     pub expansion: ExpnId,\n }\n \n+impl<'b> Deref for BuildReducedGraphVisitor<'_, 'b> {\n+    type Target = Resolver<'b>;\n+    fn deref(&self) -> &Self::Target {\n+        self.resolver\n+    }\n+}\n+\n+impl<'b> DerefMut for BuildReducedGraphVisitor<'_, 'b> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.resolver\n+    }\n+}\n+\n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.resolver.arenas.alloc_invocation_data(InvocationData {\n-            module: self.resolver.current_module,\n+        let invocation_data = self.arenas.alloc_invocation_data(InvocationData {\n+            module: self.current_module,\n             parent_legacy_scope: self.current_legacy_scope,\n             output_legacy_scope: Cell::new(None),\n         });\n-        let old_invocation_data = self.resolver.invocations.insert(invoc_id, invocation_data);\n+        let old_invocation_data = self.invocations.insert(invoc_id, invocation_data);\n         assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n \n         invocation_data\n@@ -959,30 +988,30 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &'a Item) {\n+        let parent_scope = &ParentScope {\n+            module: self.current_module,\n+            expansion: self.expansion,\n+            legacy: self.current_legacy_scope,\n+            derives: Vec::new(),\n+        };\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, self.expansion, &mut self.current_legacy_scope);\n+                self.current_legacy_scope = self.resolver.define_macro(item, parent_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n                 self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(item.id));\n                 return\n             }\n-            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n \n-        let orig_current_module = self.resolver.current_module;\n+        let orig_current_module = self.current_module;\n         let orig_current_legacy_scope = self.current_legacy_scope;\n-        let parent_scope = ParentScope {\n-            module: self.resolver.current_module,\n-            expansion: self.expansion,\n-            legacy: self.current_legacy_scope,\n-            derives: Vec::new(),\n-        };\n-        self.resolver.build_reduced_graph_for_item(item, parent_scope);\n+        self.build_reduced_graph_for_item(item, parent_scope);\n         visit::walk_item(self, item);\n-        self.resolver.current_module = orig_current_module;\n+        self.current_module = orig_current_module;\n         if !macro_use {\n             self.current_legacy_scope = orig_current_legacy_scope;\n         }\n@@ -1002,34 +1031,34 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n             return;\n         }\n \n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n+        self.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n     fn visit_block(&mut self, block: &'a Block) {\n-        let orig_current_module = self.resolver.current_module;\n+        let orig_current_module = self.current_module;\n         let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.resolver.build_reduced_graph_for_block(block, self.expansion);\n+        self.build_reduced_graph_for_block(block, self.expansion);\n         visit::walk_block(self, block);\n-        self.resolver.current_module = orig_current_module;\n+        self.current_module = orig_current_module;\n         self.current_legacy_scope = orig_current_legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {\n-        let parent = self.resolver.current_module;\n+        let parent = self.current_module;\n \n         if let TraitItemKind::Macro(_) = item.node {\n             self.visit_invoc(item.id);\n             return\n         }\n \n         // Add the item to the trait info.\n-        let item_def_id = self.resolver.definitions.local_def_id(item.id);\n+        let item_def_id = self.definitions.local_def_id(item.id);\n         let (res, ns) = match item.node {\n             TraitItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n-                    self.resolver.has_self.insert(item_def_id);\n+                    self.has_self.insert(item_def_id);\n                 }\n                 (Res::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n@@ -1040,9 +1069,9 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         let vis = ty::Visibility::Public;\n         self.resolver.define(parent, item.ident, ns, (res, vis, item.span, self.expansion));\n \n-        self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n+        self.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);\n-        self.resolver.current_module = parent;\n+        self.current_module = parent;\n     }\n \n     fn visit_token(&mut self, t: Token) {\n@@ -1058,7 +1087,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n             let parent_scope = ParentScope {\n-                module: self.resolver.current_module.nearest_item_scope(),\n+                module: self.current_module.nearest_item_scope(),\n                 expansion: self.expansion,\n                 legacy: self.current_legacy_scope,\n                 // Let's hope discerning built-in attributes from derive helpers is not necessary"}, {"sha": "d733a32c9c38e5a2508289d4bf28a24140586b37", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -270,10 +270,6 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n         }\n     }\n \n-    for (id, span) in resolver.unused_labels.iter() {\n-        resolver.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n-    }\n-\n     let mut visitor = UnusedImportCheckVisitor {\n         resolver,\n         unused_imports: Default::default(),"}, {"sha": "c1fe7188f6ddaba52d4585aeb7fe880307f0b468", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -18,7 +18,7 @@ use syntax_pos::{BytePos, Span};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{is_self_type, is_self_value, path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{CrateLint, LateResolutionVisitor, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -78,7 +78,7 @@ fn add_module_candidates(\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a> LateResolutionVisitor<'a, '_> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n     pub(crate) fn smart_resolve_report_errors(\n@@ -112,7 +112,7 @@ impl<'a> Resolver<'a> {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path_without_parent_scope(\n+                let mod_prefix = match self.resolve_path(\n                     mod_path, Some(TypeNS), false, span, CrateLint::No\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -288,7 +288,9 @@ impl<'a> Resolver<'a> {\n         }\n         (err, candidates)\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n         // HACK(estebank): find a better way to figure out that this was a\n         // parser issue where a struct literal is being used on an expression\n@@ -338,7 +340,9 @@ impl<'a> Resolver<'a> {\n         }\n         return (followed_by_brace, closing_brace)\n     }\n+}\n \n+impl<'a> LateResolutionVisitor<'a, '_> {\n     /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n     /// function.\n     /// Returns `true` if able to provide context-dependent help.\n@@ -457,7 +461,7 @@ impl<'a> Resolver<'a> {\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis))\n                         = self.struct_constructors.get(&def_id).cloned() {\n-                    let accessible_ctor = self.is_accessible(ctor_vis);\n+                    let accessible_ctor = self.is_accessible_from(ctor_vis, self.current_module);\n                     if is_expected(ctor_def) && !accessible_ctor {\n                         err.span_label(\n                             span,\n@@ -532,11 +536,12 @@ impl<'a> Resolver<'a> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n             if let Ok(binding) = self.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n-                    None,\n+                    parent_scope,\n                     false,\n                     module.span,\n                 ) {\n@@ -553,7 +558,9 @@ impl<'a> Resolver<'a> {\n \n         None\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,\n@@ -569,9 +576,10 @@ impl<'a> Resolver<'a> {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n                         for derive in &parent_scope.derives {\n-                            let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                            let parent_scope =\n+                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n-                                derive, Some(MacroKind::Derive), &parent_scope, false, false\n+                                derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {\n                                 suggestions.extend(ext.helper_attrs.iter().map(|name| {\n                                     TypoSuggestion::from_res(*name, res)\n@@ -682,7 +690,9 @@ impl<'a> Resolver<'a> {\n             _ => None,\n         }\n     }\n+}\n \n+impl<'a> LateResolutionVisitor<'a, '_> {\n     fn lookup_typo_candidate(\n         &mut self,\n         path: &[Segment],\n@@ -750,7 +760,7 @@ impl<'a> Resolver<'a> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n+            if let PathResult::Module(module) = self.resolve_path(\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n@@ -774,7 +784,9 @@ impl<'a> Resolver<'a> {\n             _ => None,\n         }\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n                                           lookup_ident: Ident,\n                                           namespace: Namespace,\n@@ -969,7 +981,7 @@ impl<'a> Resolver<'a> {\n     ) {\n         let is_expected = &|res: Res| res.macro_kind() == Some(macro_kind);\n         let suggestion = self.early_lookup_typo_candidate(\n-            ScopeSet::Macro(macro_kind), &parent_scope, ident, is_expected\n+            ScopeSet::Macro(macro_kind), parent_scope, ident, is_expected\n         );\n         add_typo_suggestion(err, suggestion, ident.span);\n "}, {"sha": "e11413fcda9ea7a8adf6e79cbee7d4209f3a8fa8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 248, "deletions": 169, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -59,6 +59,7 @@ use log::debug;\n \n use std::cell::{Cell, RefCell};\n use std::{cmp, fmt, iter, mem, ptr};\n+use std::ops::{Deref, DerefMut};\n use std::collections::BTreeSet;\n use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n@@ -537,35 +538,22 @@ enum PathSource<'a> {\n     TupleStruct,\n     // `m::A::B` in `<T as m::A>::B::C`.\n     TraitItem(Namespace),\n-    // Path in `pub(path)`\n-    Visibility,\n }\n \n impl<'a> PathSource<'a> {\n     fn namespace(self) -> Namespace {\n         match self {\n-            PathSource::Type | PathSource::Trait(_) | PathSource::Struct |\n-            PathSource::Visibility => TypeNS,\n+            PathSource::Type | PathSource::Trait(_) | PathSource::Struct => TypeNS,\n             PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n             PathSource::TraitItem(ns) => ns,\n         }\n     }\n \n-    fn global_by_default(self) -> bool {\n-        match self {\n-            PathSource::Visibility => true,\n-            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n-            PathSource::Struct | PathSource::TupleStruct |\n-            PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n-        }\n-    }\n-\n     fn defer_to_typeck(self) -> bool {\n         match self {\n             PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n             PathSource::Struct | PathSource::TupleStruct => true,\n-            PathSource::Trait(_) | PathSource::TraitItem(..) |\n-            PathSource::Visibility => false,\n+            PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n         }\n     }\n \n@@ -576,7 +564,6 @@ impl<'a> PathSource<'a> {\n             PathSource::Pat => \"unit struct/variant or constant\",\n             PathSource::Struct => \"struct, variant or union type\",\n             PathSource::TupleStruct => \"tuple struct/variant\",\n-            PathSource::Visibility => \"module\",\n             PathSource::TraitItem(ns) => match ns {\n                 TypeNS => \"associated type\",\n                 ValueNS => \"method or associated constant\",\n@@ -655,10 +642,6 @@ impl<'a> PathSource<'a> {\n                 Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n                 _ => false,\n             },\n-            PathSource::Visibility => match res {\n-                Res::Def(DefKind::Mod, _) => true,\n-                _ => false,\n-            },\n         }\n     }\n \n@@ -675,8 +658,6 @@ impl<'a> PathSource<'a> {\n         __diagnostic_used!(E0574);\n         __diagnostic_used!(E0575);\n         __diagnostic_used!(E0576);\n-        __diagnostic_used!(E0577);\n-        __diagnostic_used!(E0578);\n         match (self, has_unexpected_resolution) {\n             (PathSource::Trait(_), true) => \"E0404\",\n             (PathSource::Trait(_), false) => \"E0405\",\n@@ -690,8 +671,6 @@ impl<'a> PathSource<'a> {\n             (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n             (PathSource::TraitItem(..), true) => \"E0575\",\n             (PathSource::TraitItem(..), false) => \"E0576\",\n-            (PathSource::Visibility, true) => \"E0577\",\n-            (PathSource::Visibility, false) => \"E0578\",\n         }\n     }\n }\n@@ -801,8 +780,80 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     }\n }\n \n+struct LateResolutionVisitor<'a, 'b> {\n+    resolver: &'b mut Resolver<'a>,\n+\n+    /// The module that represents the current item scope.\n+    current_module: Module<'a>,\n+\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n+    ribs: PerNS<Vec<Rib<'a>>>,\n+\n+    /// The current set of local scopes, for labels.\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n+\n+    /// The trait that the current context can refer to.\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n+\n+    /// The current trait's associated types' ident, used for diagnostic suggestions.\n+    current_trait_assoc_types: Vec<Ident>,\n+\n+    /// The current self type if inside an impl (used for better errors).\n+    current_self_type: Option<Ty>,\n+\n+    /// The current self item if inside an ADT (used for better errors).\n+    current_self_item: Option<NodeId>,\n+\n+    /// A list of labels as of yet unused. Labels will be removed from this map when\n+    /// they are used (in a `break` or `continue` statement)\n+    unused_labels: FxHashMap<NodeId, Span>,\n+\n+    /// Only used for better errors on `fn(): fn()`.\n+    current_type_ascription: Vec<Span>,\n+}\n+\n+impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n+    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n+        let graph_root = resolver.graph_root;\n+        LateResolutionVisitor {\n+            resolver,\n+            current_module: graph_root,\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+            },\n+            label_ribs: Vec::new(),\n+            current_trait_ref: None,\n+            current_trait_assoc_types: Vec::new(),\n+            current_self_type: None,\n+            current_self_item: None,\n+            unused_labels: Default::default(),\n+            current_type_ascription: Vec::new(),\n+        }\n+    }\n+\n+    fn parent_scope(&self) -> ParentScope<'a> {\n+        ParentScope { module: self.current_module, ..self.dummy_parent_scope() }\n+    }\n+}\n+\n+impl<'a> Deref for LateResolutionVisitor<'a, '_> {\n+    type Target = Resolver<'a>;\n+    fn deref(&self) -> &Self::Target {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a> DerefMut for LateResolutionVisitor<'a, '_> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.resolver\n+    }\n+}\n+\n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n-impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n+impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         self.resolve_item(item);\n     }\n@@ -1587,28 +1638,6 @@ pub struct Resolver<'a> {\n     /// All non-determined imports.\n     indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n \n-    /// The module that represents the current item scope.\n-    current_module: Module<'a>,\n-\n-    /// The current set of local scopes for types and values.\n-    /// FIXME #4948: Reuse ribs to avoid allocation.\n-    ribs: PerNS<Vec<Rib<'a>>>,\n-\n-    /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a, NodeId>>,\n-\n-    /// The trait that the current context can refer to.\n-    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n-\n-    /// The current trait's associated types' ident, used for diagnostic suggestions.\n-    current_trait_assoc_types: Vec<Ident>,\n-\n-    /// The current self type if inside an impl (used for better errors).\n-    current_self_type: Option<Ty>,\n-\n-    /// The current self item if inside an ADT (used for better errors).\n-    current_self_item: Option<NodeId>,\n-\n     /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n     /// We are resolving a last import segment during import validation.\n     last_import_segment: bool,\n@@ -1655,10 +1684,6 @@ pub struct Resolver<'a> {\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n \n-    /// A list of labels as of yet unused. Labels will be removed from this map when\n-    /// they are used (in a `break` or `continue` statement)\n-    pub unused_labels: FxHashMap<NodeId, Span>,\n-\n     /// Privacy errors are delayed until the end in order to deduplicate them.\n     privacy_errors: Vec<PrivacyError<'a>>,\n     /// Ambiguity errors are delayed for deduplication.\n@@ -1703,9 +1728,6 @@ pub struct Resolver<'a> {\n     /// it's not used during normal resolution, only for better error reporting.\n     struct_constructors: DefIdMap<(Res, ty::Visibility)>,\n \n-    /// Only used for better errors on `fn(): fn()`.\n-    current_type_ascription: Vec<Span>,\n-\n     injected_crate: Option<Module<'a>>,\n \n     /// Features enabled for this crate.\n@@ -1872,8 +1894,8 @@ impl<'a> Resolver<'a> {\n         let span = path.span;\n         let path = Segment::from_path(&path);\n         // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n-                                                               span, CrateLint::No) {\n+        let parent_scope = &self.dummy_parent_scope();\n+        match self.resolve_path(&path, Some(namespace), parent_scope, true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 Ok(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n@@ -1969,18 +1991,6 @@ impl<'a> Resolver<'a> {\n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n \n-            current_module: graph_root,\n-            ribs: PerNS {\n-                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-            },\n-            label_ribs: Vec::new(),\n-\n-            current_trait_ref: None,\n-            current_trait_assoc_types: Vec::new(),\n-            current_self_type: None,\n-            current_self_item: None,\n             last_import_segment: false,\n             blacklisted_binding: None,\n \n@@ -2002,8 +2012,6 @@ impl<'a> Resolver<'a> {\n             maybe_unused_trait_imports: Default::default(),\n             maybe_unused_extern_crates: Vec::new(),\n \n-            unused_labels: FxHashMap::default(),\n-\n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n             use_injections: Vec::new(),\n@@ -2036,7 +2044,6 @@ impl<'a> Resolver<'a> {\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n             special_derives: Default::default(),\n-            current_type_ascription: Vec::new(),\n             injected_crate: None,\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n@@ -2089,10 +2096,13 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { resolver: self }.finalize_imports();\n-        self.current_module = self.graph_root;\n-        self.finalize_current_module_macro_resolutions();\n \n-        visit::walk_crate(self, krate);\n+        self.finalize_current_module_macro_resolutions(self.graph_root);\n+        let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n+        visit::walk_crate(&mut late_resolution_visitor, krate);\n+        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n+            self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n+        }\n \n         check_unused::check_crate(self, krate);\n         self.report_errors(krate);\n@@ -2287,7 +2297,9 @@ impl<'a> Resolver<'a> {\n \n         None\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it).\n@@ -2308,8 +2320,10 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: Ident,\n                                       ns: Namespace,\n+                                      parent_scope: &ParentScope<'a>,\n                                       record_used_id: Option<NodeId>,\n-                                      path_span: Span)\n+                                      path_span: Span,\n+                                      ribs: &[Rib<'a>])\n                                       -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n         if ident.name == kw::Invalid {\n@@ -2331,23 +2345,23 @@ impl<'a> Resolver<'a> {\n         // Walk backwards up the ribs in scope.\n         let record_used = record_used_id.is_some();\n         let mut module = self.graph_root;\n-        for i in (0 .. self.ribs[ns].len()).rev() {\n-            debug!(\"walk rib\\n{:?}\", self.ribs[ns][i].bindings);\n+        for i in (0 .. ribs.len()).rev() {\n+            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n             // (modern hygiene) or local variables (legacy hygiene).\n-            let rib_ident = if let AssocItemRibKind | ItemRibKind = self.ribs[ns][i].kind {\n+            let rib_ident = if let AssocItemRibKind | ItemRibKind = ribs[i].kind {\n                 modern_ident\n             } else {\n                 ident\n             };\n-            if let Some(res) = self.ribs[ns][i].bindings.get(&rib_ident).cloned() {\n+            if let Some(res) = ribs[i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(\n-                    self.validate_res_from_ribs(ns, i, res, record_used, path_span),\n+                    self.validate_res_from_ribs(i, res, record_used, path_span, ribs),\n                 ));\n             }\n \n-            module = match self.ribs[ns][i].kind {\n+            module = match ribs[i].kind {\n                 ModuleRibKind(module) => module,\n                 MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n@@ -2358,10 +2372,12 @@ impl<'a> Resolver<'a> {\n                 _ => continue,\n             };\n \n+\n             let item = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                parent_scope,\n                 record_used,\n                 path_span,\n             );\n@@ -2386,16 +2402,15 @@ impl<'a> Resolver<'a> {\n                 self.hygienic_lexical_parent(module, &mut ident.span)\n             };\n             module = unwrap_or!(opt_module, break);\n-            let orig_current_module = self.current_module;\n-            self.current_module = module; // Lexical resolutions can never be a privacy error.\n+            let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                adjusted_parent_scope,\n                 record_used,\n                 path_span,\n             );\n-            self.current_module = orig_current_module;\n \n             match result {\n                 Ok(binding) => {\n@@ -2433,6 +2448,7 @@ impl<'a> Resolver<'a> {\n                     ModuleOrUniformRoot::Module(prelude),\n                     ident,\n                     ns,\n+                    parent_scope,\n                     false,\n                     path_span,\n                 ) {\n@@ -2498,7 +2514,7 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n-        parent_scope: Option<&ParentScope<'a>>,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -2512,15 +2528,18 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         mut ident: Ident,\n         ns: Namespace,\n-        parent_scope: Option<&ParentScope<'a>>,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let orig_current_module = self.current_module;\n+        let tmp_parent_scope;\n+        let mut adjusted_parent_scope = parent_scope;\n         match module {\n-            ModuleOrUniformRoot::Module(module) => {\n-                if let Some(def) = ident.span.modernize_and_adjust(module.expansion) {\n-                    self.current_module = self.macro_def_scope(def);\n+            ModuleOrUniformRoot::Module(m) => {\n+                if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n@@ -2532,9 +2551,8 @@ impl<'a> Resolver<'a> {\n             }\n         }\n         let result = self.resolve_ident_in_module_unadjusted_ext(\n-            module, ident, ns, parent_scope, false, record_used, path_span,\n+            module, ident, ns, adjusted_parent_scope, false, record_used, path_span,\n         );\n-        self.current_module = orig_current_module;\n         result\n     }\n \n@@ -2587,7 +2605,9 @@ impl<'a> Resolver<'a> {\n         }\n         module\n     }\n+}\n \n+impl<'a> LateResolutionVisitor<'a, '_> {\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -2606,8 +2626,32 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n+    fn resolve_ident_in_lexical_scope(&mut self,\n+                                      ident: Ident,\n+                                      ns: Namespace,\n+                                      record_used_id: Option<NodeId>,\n+                                      path_span: Span)\n+                                      -> Option<LexicalScopeBinding<'a>> {\n+        self.resolver.resolve_ident_in_lexical_scope(\n+            ident, ns, &self.parent_scope(), record_used_id, path_span, &self.ribs[ns]\n+        )\n+    }\n+\n+    fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n+        self.resolver.resolve_path_with_ribs(\n+            path, opt_ns, &self.parent_scope(), record_used, path_span, crate_lint, &self.ribs\n+        )\n+    }\n+\n     pub fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'_>) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n     {\n         let id = self.definitions.local_def_id(id);\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n@@ -2617,7 +2661,7 @@ impl<'a> Resolver<'a> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n-            self.finalize_current_module_macro_resolutions();\n+            self.resolver.finalize_current_module_macro_resolutions(self.current_module);\n             let ret = f(self);\n \n             self.current_module = orig_module;\n@@ -2827,7 +2871,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_generic_param_rib<'b, F>(&'b mut self, generic_params: GenericParameters<'a, 'b>, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         debug!(\"with_generic_param_rib\");\n         match generic_params {\n@@ -2901,15 +2945,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n     fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n         self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n@@ -2919,7 +2963,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         debug!(\"with_constant_rib\");\n         self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n@@ -2930,7 +2974,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'_>) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n     {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n@@ -2940,7 +2984,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'_>) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n     {\n         let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n         let result = f(self);\n@@ -2950,7 +2994,7 @@ impl<'a> Resolver<'a> {\n \n     /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n     fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'_>) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n     {\n         let trait_assoc_types = replace(\n             &mut self.current_trait_assoc_types,\n@@ -2966,7 +3010,7 @@ impl<'a> Resolver<'a> {\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'_>, Option<DefId>) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n         let mut new_id = None;\n@@ -2984,7 +3028,7 @@ impl<'a> Resolver<'a> {\n                 new_id = Some(res.def_id());\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                    self.resolve_path_without_parent_scope(\n+                    self.resolve_path(\n                         &path,\n                         Some(TypeNS),\n                         false,\n@@ -3003,7 +3047,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n@@ -3015,7 +3059,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n@@ -3053,8 +3097,9 @@ impl<'a> Resolver<'a> {\n                             this.with_self_struct_ctor_rib(item_def_id, |this| {\n                                 debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n                                 for impl_item in impl_items {\n-                                    this.resolve_visibility(&impl_item.vis);\n-\n+                                    this.resolver.resolve_visibility(\n+                                        &impl_item.vis, &this.parent_scope()\n+                                    );\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n                                                                           AssocItemRibKind);\n@@ -3129,11 +3174,12 @@ impl<'a> Resolver<'a> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n             if self.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                None,\n+                parent_scope,\n                 false,\n                 span,\n             ).is_err() {\n@@ -3282,7 +3328,7 @@ impl<'a> Resolver<'a> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.current_module = anonymous_module;\n-            self.finalize_current_module_macro_resolutions();\n+            self.resolver.finalize_current_module_macro_resolutions(self.current_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -3497,7 +3543,6 @@ impl<'a> Resolver<'a> {\n             ns,\n             span,\n             source.defer_to_typeck(),\n-            source.global_by_default(),\n             crate_lint,\n         ) {\n             Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n@@ -3510,7 +3555,8 @@ impl<'a> Resolver<'a> {\n                     if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n                         if let Some((ctor_res, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n-                            if is_expected(ctor_res) && self.is_accessible(ctor_vis) {\n+                            if is_expected(ctor_res) &&\n+                               self.is_accessible_from(ctor_vis, self.current_module) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n                                 self.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n@@ -3540,8 +3586,7 @@ impl<'a> Resolver<'a> {\n                     let cl = CrateLint::No;\n                     let ns = Some(ns);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path_without_parent_scope(&std_path, ns, false, span, cl)\n-                    {\n+                            self.resolve_path(&std_path, ns, false, span, cl) {\n                         // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span = path.iter().last().map(|segment| segment.ident.span)\n                             .unwrap_or(span);\n@@ -3678,13 +3723,12 @@ impl<'a> Resolver<'a> {\n         primary_ns: Namespace,\n         span: Span,\n         defer_to_typeck: bool,\n-        global_by_default: bool,\n         crate_lint: CrateLint,\n     ) -> Option<PartialRes> {\n         let mut fin_res = None;\n         for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n+                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n                     Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n@@ -3700,10 +3744,9 @@ impl<'a> Resolver<'a> {\n         if qself.is_none() {\n             let path_seg = |seg: &Segment| ast::PathSegment::from_ident(seg.ident);\n             let path = Path { segments: path.iter().map(path_seg).collect(), span };\n-            let parent_scope =\n-                ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n+            let parent_scope = &self.parent_scope();\n             if let Ok((_, res)) =\n-                    self.resolve_macro_path(&path, None, &parent_scope, false, false) {\n+                    self.resolve_macro_path(&path, None, parent_scope, false, false) {\n                 return Some(PartialRes::new(res));\n             }\n         }\n@@ -3719,18 +3762,15 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         ns: Namespace,\n         span: Span,\n-        global_by_default: bool,\n         crate_lint: CrateLint,\n     ) -> Option<PartialRes> {\n         debug!(\n-            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n-             ns={:?}, span={:?}, global_by_default={:?})\",\n+            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n             id,\n             qself,\n             path,\n             ns,\n             span,\n-            global_by_default,\n         );\n \n         if let Some(qself) = qself {\n@@ -3779,13 +3819,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path_without_parent_scope(\n-            &path,\n-            Some(ns),\n-            true,\n-            span,\n-            crate_lint,\n-        ) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PartialRes::new(module.res().unwrap())\n@@ -3820,11 +3854,11 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() > 1 && !global_by_default && result.base_res() != Res::Err &&\n+        if path.len() > 1 && result.base_res() != Res::Err &&\n            path[0].ident.name != kw::PathRoot &&\n            path[0].ident.name != kw::DollarCrate {\n             let unqualified_result = {\n-                match self.resolve_path_without_parent_scope(\n+                match self.resolve_path(\n                     &[*path.last().unwrap()],\n                     Some(ns),\n                     false,\n@@ -3845,35 +3879,36 @@ impl<'a> Resolver<'a> {\n \n         Some(result)\n     }\n+}\n \n-    fn resolve_path_without_parent_scope(\n+impl<'a> Resolver<'a> {\n+    fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        // Macro and import paths must have full parent scope available during resolution,\n-        // other paths will do okay with parent module alone.\n-        assert!(opt_ns != None && opt_ns != Some(MacroNS));\n-        let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n-        self.resolve_path(path, opt_ns, &parent_scope, record_used, path_span, crate_lint)\n+        self.resolve_path_with_ribs(\n+            path, opt_ns, parent_scope, record_used, path_span, crate_lint, &Default::default()\n+        )\n     }\n \n-    fn resolve_path(\n+    fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n+        ribs: &PerNS<Vec<Rib<'a>>>,\n     ) -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n-        self.current_module = parent_scope.module;\n \n         debug!(\n             \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n@@ -3910,7 +3945,7 @@ impl<'a> Resolver<'a> {\n                 if allow_super && name == kw::Super {\n                     let mut ctxt = ident.span.ctxt().modern();\n                     let self_module = match i {\n-                        0 => Some(self.resolve_self(&mut ctxt, self.current_module)),\n+                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n                         _ => match module {\n                             Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n                             _ => None,\n@@ -3935,7 +3970,7 @@ impl<'a> Resolver<'a> {\n                     if name == kw::SelfLower {\n                         let mut ctxt = ident.span.ctxt().modern();\n                         module = Some(ModuleOrUniformRoot::Module(\n-                            self.resolve_self(&mut ctxt, self.current_module)));\n+                            self.resolve_self(&mut ctxt, parent_scope.module)));\n                         continue;\n                     }\n                     if name == kw::PathRoot && ident.span.rust_2018() {\n@@ -3980,7 +4015,9 @@ impl<'a> Resolver<'a> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, None, record_used, path_span)\n+                self.resolve_ident_in_module(\n+                    module, ident, ns, parent_scope, record_used, path_span\n+                )\n             } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n                 let scopes = if opt_ns.is_none() { ScopeSet::Import(ns) } else { ScopeSet::Module };\n@@ -3989,7 +4026,9 @@ impl<'a> Resolver<'a> {\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used_id, path_span) {\n+                match self.resolve_ident_in_lexical_scope(\n+                    ident, ns, parent_scope, record_used_id, path_span, &ribs[ns]\n+                ) {\n                     // we found a locally-imported or available item/module\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     // we found a local variable or type param\n@@ -4176,17 +4215,17 @@ impl<'a> Resolver<'a> {\n     // Validate a local resolution (from ribs).\n     fn validate_res_from_ribs(\n         &mut self,\n-        ns: Namespace,\n         rib_index: usize,\n         res: Res,\n         record_used: bool,\n         span: Span,\n+        all_ribs: &[Rib<'a>],\n     ) -> Res {\n         debug!(\"validate_res_from_ribs({:?})\", res);\n-        let ribs = &self.ribs[ns][rib_index + 1..];\n+        let ribs = &all_ribs[rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n-        if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n+        if let ForwardTyParamBanRibKind = all_ribs[rib_index].kind {\n             if record_used {\n                 resolve_error(self, span, ResolutionError::ForwardDeclaredTyParam);\n             }\n@@ -4195,7 +4234,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // An invalid use of a type parameter as the type of a const parameter.\n-        if let TyParamAsConstParamTy = self.ribs[ns][rib_index].kind {\n+        if let TyParamAsConstParamTy = all_ribs[rib_index].kind {\n             if record_used {\n                 resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n             }\n@@ -4288,9 +4327,11 @@ impl<'a> Resolver<'a> {\n         }\n         res\n     }\n+}\n \n+impl<'a> LateResolutionVisitor<'a, '_> {\n     fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut Resolver<'_>)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n     {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n@@ -4486,11 +4527,12 @@ impl<'a> Resolver<'a> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n             if self.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                None,\n+                parent_scope,\n                 false,\n                 module.span,\n             ).is_ok() {\n@@ -4547,10 +4589,12 @@ impl<'a> Resolver<'a> {\n                 ).is_none() {\n                     continue\n                 }\n+                let parent_scope = &self.parent_scope();\n                 if self.resolve_ident_in_module_unadjusted(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n+                    parent_scope,\n                     false,\n                     module.span,\n                 ).is_ok() {\n@@ -4581,22 +4625,26 @@ impl<'a> Resolver<'a> {\n         };\n         import_ids\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n \n-    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n+    fn resolve_visibility(\n+        &mut self, vis: &ast::Visibility, parent_scope: &ParentScope<'a>\n+    ) -> ty::Visibility {\n         match vis.node {\n             ast::VisibilityKind::Public => ty::Visibility::Public,\n             ast::VisibilityKind::Crate(..) => {\n                 ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n             }\n             ast::VisibilityKind::Inherited => {\n-                ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n+                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -4626,34 +4674,65 @@ impl<'a> Resolver<'a> {\n \n                 let segments = crate_root.into_iter()\n                     .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let res = self.smart_resolve_path_fragment(\n-                    id,\n-                    None,\n+                let expected_found_error = |this: &Self, res: Res| {\n+                    let path_str = Segment::names_to_string(&segments);\n+                    struct_span_err!(this.session, path.span, E0577,\n+                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n+                        .span_label(path.span, \"not a module\").emit();\n+                };\n+                match self.resolve_path(\n                     &segments,\n+                    Some(TypeNS),\n+                    parent_scope,\n+                    true,\n                     path.span,\n-                    PathSource::Visibility,\n                     CrateLint::SimplePath(id),\n-                ).base_res();\n-                if res == Res::Err {\n-                    ty::Visibility::Public\n-                } else {\n-                    let vis = ty::Visibility::Restricted(res.def_id());\n-                    if self.is_accessible(vis) {\n-                        vis\n-                    } else {\n-                        self.session.span_err(path.span, \"visibilities can only be restricted \\\n-                                                          to ancestor modules\");\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n+                        let res = module.res().expect(\"visibility resolved to unnamed block\");\n+                        self.record_partial_res(id, PartialRes::new(res));\n+                        if module.is_normal() {\n+                            if res == Res::Err {\n+                                ty::Visibility::Public\n+                            } else {\n+                                let vis = ty::Visibility::Restricted(res.def_id());\n+                                if self.is_accessible_from(vis, parent_scope.module) {\n+                                    vis\n+                                } else {\n+                                    let msg =\n+                                        \"visibilities can only be restricted to ancestor modules\";\n+                                    self.session.span_err(path.span, msg);\n+                                    ty::Visibility::Public\n+                                }\n+                            }\n+                        } else {\n+                            expected_found_error(self, res);\n+                            ty::Visibility::Public\n+                        }\n+                    }\n+                    PathResult::Module(..) => {\n+                        self.session.span_err(path.span, \"visibility must resolve to a module\");\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::NonModule(partial_res) => {\n+                        expected_found_error(self, partial_res.base_res());\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Failed { span, label, suggestion, .. } => {\n+                        let err = ResolutionError::FailedToResolve { label, suggestion };\n+                        resolve_error(self, span, err);\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Indeterminate => {\n+                        span_err!(self.session, path.span, E0578,\n+                                  \"cannot determine resolution for the visibility\");\n                         ty::Visibility::Public\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn is_accessible(&self, vis: ty::Visibility) -> bool {\n-        vis.is_accessible_from(self.current_module.normal_ancestor_id, self)\n-    }\n-\n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }"}, {"sha": "cc89650bc2936a596019bea739335ab5d9a9b4af", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -166,16 +166,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n \n         let invocation = self.invocations[&expn_id];\n-        self.current_module = invocation.module;\n-        self.current_module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n+        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n+        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n         let parent_def = self.definitions.invocation_parent(expn_id);\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n+            current_module: invocation.module,\n             current_legacy_scope: invocation.parent_legacy_scope,\n             expansion: expn_id,\n         };\n@@ -210,10 +210,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = self.invoc_parent_scope(invoc_id, Vec::new());\n+                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n+                                                      parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -227,8 +227,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, force)?;\n+        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n         invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n@@ -471,9 +471,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n-                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n+                                                      parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                                ty::Visibility::Public, derive.span, ExpnId::root())\n@@ -502,7 +502,7 @@ impl<'a> Resolver<'a> {\n                         ModuleOrUniformRoot::Module(root_module),\n                         ident,\n                         ns,\n-                        None,\n+                        parent_scope,\n                         record_used,\n                         path_span,\n                     );\n@@ -516,17 +516,16 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let orig_current_module = mem::replace(&mut this.current_module, module);\n+                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n-                        None,\n+                        adjusted_parent_scope,\n                         true,\n                         record_used,\n                         path_span,\n                     );\n-                    this.current_module = orig_current_module;\n                     match binding {\n                         Ok(binding) => {\n                             let misc_flags = if ptr::eq(module, this.graph_root) {\n@@ -588,6 +587,7 @@ impl<'a> Resolver<'a> {\n                             ModuleOrUniformRoot::Module(prelude),\n                             ident,\n                             ns,\n+                            parent_scope,\n                             false,\n                             path_span,\n                         ) {\n@@ -710,9 +710,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn finalize_current_module_macro_resolutions(&mut self) {\n-        let module = self.current_module;\n-\n+    pub fn finalize_current_module_macro_resolutions(&mut self, module: Module<'a>) {\n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n                                  initial_res: Option<Res>, res: Res| {\n             if let Some(initial_res) = initial_res {\n@@ -753,8 +751,9 @@ impl<'a> Resolver<'a> {\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n-            match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n-                                    true, path_span, CrateLint::No) {\n+            match self.resolve_path(\n+                &path, Some(MacroNS), &parent_scope, true, path_span, CrateLint::No\n+            ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n                     check_consistency(self, &path, path_span, kind, initial_res, res);\n@@ -887,10 +886,10 @@ impl<'a> Resolver<'a> {\n         Lrc::new(result)\n     }\n \n-    pub fn define_macro(&mut self,\n-                        item: &ast::Item,\n-                        expansion: ExpnId,\n-                        current_legacy_scope: &mut LegacyScope<'a>) {\n+    pub fn define_macro(\n+        &mut self, item: &ast::Item, parent_scope: &ParentScope<'a>,\n+    ) -> LegacyScope<'a> {\n+        let expansion = parent_scope.expansion;\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {\n                 let ext = self.compile_macro(item, self.session.edition());\n@@ -901,15 +900,15 @@ impl<'a> Resolver<'a> {\n                     self.proc_macro_stubs.insert(item.id);\n                     (self.dummy_ext(macro_kind), ident, span, false)\n                 }\n-                None => return,\n+                None => return parent_scope.legacy,\n             }\n             _ => unreachable!(),\n         };\n \n         let def_id = self.definitions.local_def_id(item.id);\n         let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n         self.macro_map.insert(def_id, ext);\n-        self.local_macro_def_scopes.insert(item.id, self.current_module);\n+        self.local_macro_def_scopes.insert(item.id, parent_scope.module);\n \n         if is_legacy {\n             let ident = ident.modern();\n@@ -921,11 +920,7 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n             };\n             let binding = (res, vis, span, expansion).to_name_binding(self.arenas);\n-            self.set_binding_parent_module(binding, self.current_module);\n-            let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: *current_legacy_scope, binding, ident\n-            });\n-            *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n+            self.set_binding_parent_module(binding, parent_scope.module);\n             self.all_macros.insert(ident.name, res);\n             if is_macro_export {\n                 let module = self.graph_root;\n@@ -935,13 +930,17 @@ impl<'a> Resolver<'a> {\n                 self.check_reserved_macro_name(ident, res);\n                 self.unused_macros.insert(item.id, span);\n             }\n+            LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent_legacy_scope: parent_scope.legacy, binding, ident\n+            }))\n         } else {\n-            let module = self.current_module;\n-            let vis = self.resolve_visibility(&item.vis);\n+            let module = parent_scope.module;\n+            let vis = self.resolve_visibility(&item.vis, parent_scope);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(item.id, span);\n             }\n             self.define(module, ident, MacroNS, (res, vis, span, expansion));\n+            parent_scope.legacy\n         }\n     }\n }"}, {"sha": "4611b81315359ceb1df1fc955eb661d60018ac13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -167,11 +167,12 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n-            module, ident, ns, None, false, record_used, path_span\n+            module, ident, ns, parent_scope, false, record_used, path_span\n         ).map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -182,7 +183,7 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n-        parent_scope: Option<&ParentScope<'a>>,\n+        parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n         record_used: bool,\n         path_span: Span,\n@@ -191,9 +192,8 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(module) => module,\n             ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n                 assert!(!restricted_shadowing);\n-                let parent_scope = self.dummy_parent_scope();\n                 let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident, ScopeSet::AbsolutePath(ns), &parent_scope,\n+                    ident, ScopeSet::AbsolutePath(ns), parent_scope,\n                     record_used, record_used, path_span,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n@@ -213,9 +213,6 @@ impl<'a> Resolver<'a> {\n             }\n             ModuleOrUniformRoot::CurrentScope => {\n                 assert!(!restricted_shadowing);\n-                let parent_scope =\n-                    parent_scope.expect(\"no parent scope for a single-segment import\");\n-\n                 if ns == TypeNS {\n                     if ident.name == kw::Crate ||\n                         ident.name == kw::DollarCrate {\n@@ -261,7 +258,8 @@ impl<'a> Resolver<'a> {\n             }\n             // `extern crate` are always usable for backwards compatibility, see issue #37020,\n             // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n-            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module) ||\n+                         binding.is_extern_crate();\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n@@ -299,7 +297,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    if !self.is_accessible(binding.vis) &&\n+                    if !self.is_accessible_from(binding.vis, parent_scope.module) &&\n                        // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                        !(self.last_import_segment && binding.is_extern_crate()) {\n                         self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n@@ -322,7 +320,7 @@ impl<'a> Resolver<'a> {\n         // Check if one of single imports can still define the name,\n         // if it can then our result is not determined and can be invalidated.\n         for single_import in &resolution.single_imports {\n-            if !self.is_accessible(single_import.vis.get()) {\n+            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n                 continue;\n             }\n             let module = unwrap_or!(single_import.imported_module.get(),\n@@ -331,7 +329,7 @@ impl<'a> Resolver<'a> {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match self.resolve_ident_in_module(module, ident, ns, Some(&single_import.parent_scope),\n+            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope,\n                                                false, path_span) {\n                 Err(Determined) => continue,\n                 Ok(binding) if !self.is_accessible_from(\n@@ -379,28 +377,33 @@ impl<'a> Resolver<'a> {\n         // Check if one of glob imports can still define the name,\n         // if it can then our \"no resolution\" result is not determined and can be invalidated.\n         for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible(glob_import.vis.get()) {\n+            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n                 continue\n             }\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n                 Some(_) => continue,\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n-            let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n+            let tmp_parent_scope;\n+            let (mut adjusted_parent_scope, mut ident) = (parent_scope, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n-                Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n+                Some(Some(def)) => {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n                 Some(None) => {}\n                 None => continue,\n             };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                adjusted_parent_scope,\n                 false,\n                 path_span,\n             );\n-            self.current_module = orig_current_module;\n \n             match result {\n                 Err(Determined) => continue,\n@@ -798,11 +801,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n-        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               Segment::names_to_string(&directive.module_path),\n-               module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n-\n-        self.current_module = directive.parent_scope.module;\n+        debug!(\n+            \"(resolving import for module) resolving import `{}::...` in `{}`\",\n+            Segment::names_to_string(&directive.module_path),\n+            module_to_string(directive.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n+        );\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n@@ -847,7 +850,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 // not define any names while resolving its module path.\n                 let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n                 let binding = this.resolve_ident_in_module(\n-                    module, source, ns, Some(&directive.parent_scope), false, directive.span\n+                    module, source, ns, &directive.parent_scope, false, directive.span\n                 );\n                 directive.vis.set(orig_vis);\n \n@@ -892,8 +895,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         directive: &'b ImportDirective<'b>\n     ) -> Option<UnresolvedImportError> {\n-        self.current_module = directive.parent_scope.module;\n-\n         let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n         let prev_ambiguity_errors_len = self.ambiguity_errors.len();\n         let path_res = self.resolve_path(&directive.module_path, None, &directive.parent_scope,\n@@ -1019,7 +1020,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n             let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n             let binding = this.resolve_ident_in_module(\n-                module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+                module, ident, ns, &directive.parent_scope, true, directive.span\n             );\n             this.last_import_segment = orig_last_import_segment;\n             this.blacklisted_binding = orig_blacklisted_binding;\n@@ -1070,7 +1071,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                 let binding = this.resolve_ident_in_module(\n-                    module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+                    module, ident, ns, &directive.parent_scope, true, directive.span\n                 );\n                 if binding.is_ok() {\n                     all_ns_failed = false;\n@@ -1340,7 +1341,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => self.current_module,\n+                Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.pseudo_vis(), scope) {"}, {"sha": "58fc74d65a54a0bc191f9407d7c2ca45f5d8997d", "filename": "src/test/ui/hygiene/privacy-early.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    fn f() {}\n+    macro f() {}\n+\n+    pub macro m() {\n+        use f as g; //~ ERROR `f` is private, and cannot be re-exported\n+        f!();\n+    }\n+}\n+\n+fn main() {\n+    foo::m!();\n+}"}, {"sha": "60e50e05fc30ec9b44fea92e82c4cc463678ca19", "filename": "src/test/ui/hygiene/privacy-early.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -0,0 +1,21 @@\n+error[E0364]: `f` is private, and cannot be re-exported\n+  --> $DIR/privacy-early.rs:10:13\n+   |\n+LL |         use f as g;\n+   |             ^^^^^^\n+...\n+LL |     foo::m!();\n+   |     ---------- in this macro invocation\n+   |\n+note: consider marking `f` as `pub` in the imported module\n+  --> $DIR/privacy-early.rs:10:13\n+   |\n+LL |         use f as g;\n+   |             ^^^^^^\n+...\n+LL |     foo::m!();\n+   |     ---------- in this macro invocation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0364`."}, {"sha": "7d48bb97b106e045a0cd322fddac2a381606a200", "filename": "src/test/ui/resolve/resolve-bad-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -4,8 +4,8 @@ trait Tr {}\n pub(in E) struct S; //~ ERROR expected module, found enum `E`\n pub(in Tr) struct Z; //~ ERROR expected module, found trait `Tr`\n pub(in std::vec) struct F; //~ ERROR visibilities can only be restricted to ancestor modules\n-pub(in nonexistent) struct G; //~ ERROR cannot find module `nonexistent` in the crate root\n-pub(in too_soon) struct H; //~ ERROR cannot find module `too_soon` in the crate root\n+pub(in nonexistent) struct G; //~ ERROR failed to resolve\n+pub(in too_soon) struct H; //~ ERROR failed to resolve\n \n // Visibilities are resolved eagerly without waiting for modules becoming fully populated.\n // Visibilities can only use ancestor modules legally which are always available in time,"}, {"sha": "a133b02335c8a2ea5ce6b1a6e4a54f8d937795c8", "filename": "src/test/ui/resolve/resolve-bad-visibility.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -1,9 +1,3 @@\n-error: visibilities can only be restricted to ancestor modules\n-  --> $DIR/resolve-bad-visibility.rs:6:8\n-   |\n-LL | pub(in std::vec) struct F;\n-   |        ^^^^^^^^\n-\n error[E0577]: expected module, found enum `E`\n   --> $DIR/resolve-bad-visibility.rs:4:8\n    |\n@@ -16,17 +10,24 @@ error[E0577]: expected module, found trait `Tr`\n LL | pub(in Tr) struct Z;\n    |        ^^ not a module\n \n-error[E0578]: cannot find module `nonexistent` in the crate root\n+error: visibilities can only be restricted to ancestor modules\n+  --> $DIR/resolve-bad-visibility.rs:6:8\n+   |\n+LL | pub(in std::vec) struct F;\n+   |        ^^^^^^^^\n+\n+error[E0433]: failed to resolve: maybe a missing `extern crate nonexistent;`?\n   --> $DIR/resolve-bad-visibility.rs:7:8\n    |\n LL | pub(in nonexistent) struct G;\n-   |        ^^^^^^^^^^^ not found in the crate root\n+   |        ^^^^^^^^^^^ maybe a missing `extern crate nonexistent;`?\n \n-error[E0578]: cannot find module `too_soon` in the crate root\n+error[E0433]: failed to resolve: maybe a missing `extern crate too_soon;`?\n   --> $DIR/resolve-bad-visibility.rs:8:8\n    |\n LL | pub(in too_soon) struct H;\n-   |        ^^^^^^^^ not found in the crate root\n+   |        ^^^^^^^^ maybe a missing `extern crate too_soon;`?\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "595eaf440c9f45c8e419fff05ec14cdd9b35346c", "filename": "src/test/ui/resolve/visibility-indeterminate.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -0,0 +1,5 @@\n+// edition:2018\n+\n+foo!(); //~ ERROR cannot find macro `foo!` in this scope\n+\n+pub(in ::bar) struct Baz {} //~ ERROR cannot determine resolution for the visibility"}, {"sha": "a259c8090b35d1336dfb310cc7460c032a80b9b8", "filename": "src/test/ui/resolve/visibility-indeterminate.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -0,0 +1,19 @@\n+error[E0578]: cannot determine resolution for the visibility\n+  --> $DIR/visibility-indeterminate.rs:5:8\n+   |\n+LL | pub(in ::bar) struct Baz {}\n+   |        ^^^^^\n+\n+error: cannot find macro `foo!` in this scope\n+  --> $DIR/visibility-indeterminate.rs:3:1\n+   |\n+LL | foo!();\n+   | ^^^\n+\n+error[E0601]: `main` function not found in crate `visibility_indeterminate`\n+   |\n+   = note: consider adding a `main` function to `$DIR/visibility-indeterminate.rs`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "c2f0711b0c8665295105b31ab2a187787762b504", "filename": "src/test/ui/span/visibility-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2e8746acc1d4fd236552a59f54b732680b4524e/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr?ref=e2e8746acc1d4fd236552a59f54b732680b4524e", "patch": "@@ -4,19 +4,17 @@ error: unexpected generic arguments in path\n LL | m!{ S<u8> }\n    |     ^^^^^\n \n+error[E0577]: expected module, found struct `S`\n+  --> $DIR/visibility-ty-params.rs:6:5\n+   |\n+LL | m!{ S<u8> }\n+   |     ^^^^^ not a module\n+\n error: unexpected generic arguments in path\n   --> $DIR/visibility-ty-params.rs:10:9\n    |\n LL |     m!{ m<> }\n    |         ^^^\n \n-error[E0577]: expected module, found struct `S`\n-  --> $DIR/visibility-ty-params.rs:6:5\n-   |\n-LL | m!{ S<u8> }\n-   |     -^^^^\n-   |     |\n-   |     help: a module with a similar name exists: `m`\n-\n error: aborting due to 3 previous errors\n "}]}