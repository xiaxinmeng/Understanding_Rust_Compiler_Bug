{"sha": "3b186511f62b0ce20e72ede0e8e13f8787155f02", "node_id": "C_kwDOAAsO6NoAKDNiMTg2NTExZjYyYjBjZTIwZTcyZWRlMGU4ZTEzZjg3ODcxNTVmMDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-20T11:32:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-20T11:32:40Z"}, "message": "Auto merge of #93816 - bjorn3:rlib_metadata_first, r=nagisa\n\nPut crate metadata first in the rlib\n\nThis should make metadata lookup faster\n\nFixes https://github.com/rust-lang/rust/issues/93806", "tree": {"sha": "43beb306dece88a6b76b50d7b35c5ae518687bd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43beb306dece88a6b76b50d7b35c5ae518687bd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b186511f62b0ce20e72ede0e8e13f8787155f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b186511f62b0ce20e72ede0e8e13f8787155f02", "html_url": "https://github.com/rust-lang/rust/commit/3b186511f62b0ce20e72ede0e8e13f8787155f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b186511f62b0ce20e72ede0e8e13f8787155f02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d7aa4763fe7f737d6add4261b9e050b36701089", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7aa4763fe7f737d6add4261b9e050b36701089", "html_url": "https://github.com/rust-lang/rust/commit/6d7aa4763fe7f737d6add4261b9e050b36701089"}, {"sha": "932559cc21a2f0746012645f130956b81480cd86", "url": "https://api.github.com/repos/rust-lang/rust/commits/932559cc21a2f0746012645f130956b81480cd86", "html_url": "https://github.com/rust-lang/rust/commit/932559cc21a2f0746012645f130956b81480cd86"}], "stats": {"total": 108, "additions": 68, "deletions": 40}, "files": [{"sha": "587453fd8e8d6be4981624ce3799c26ae000ad9c", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3b186511f62b0ce20e72ede0e8e13f8787155f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b186511f62b0ce20e72ede0e8e13f8787155f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=3b186511f62b0ce20e72ede0e8e13f8787155f02", "patch": "@@ -23,7 +23,7 @@ use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Ta\n use super::archive::{find_library, ArchiveBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n-use super::metadata::create_rmeta_file;\n+use super::metadata::{create_rmeta_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n use crate::{\n     looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n@@ -267,6 +267,28 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n \n     let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n \n+    let trailing_metadata = match flavor {\n+        RlibFlavor::Normal => {\n+            let (metadata, metadata_position) =\n+                create_rmeta_file(sess, codegen_results.metadata.raw_data());\n+            let metadata = emit_metadata(sess, &metadata, tmpdir);\n+            match metadata_position {\n+                MetadataPosition::First => {\n+                    // Most of the time metadata in rlib files is wrapped in a \"dummy\" object\n+                    // file for the target platform so the rlib can be processed entirely by\n+                    // normal linkers for the platform. Sometimes this is not possible however.\n+                    // If it is possible however, placing the metadata object first improves\n+                    // performance of getting metadata from rlibs.\n+                    ab.add_file(&metadata);\n+                    None\n+                }\n+                MetadataPosition::Last => Some(metadata),\n+            }\n+        }\n+\n+        RlibFlavor::StaticlibBase => None,\n+    };\n+\n     for m in &codegen_results.modules {\n         if let Some(obj) = m.object.as_ref() {\n             ab.add_file(obj);\n@@ -277,6 +299,16 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n+    match flavor {\n+        RlibFlavor::Normal => {}\n+        RlibFlavor::StaticlibBase => {\n+            let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n+            if let Some(obj) = obj {\n+                ab.add_file(obj);\n+            }\n+        }\n+    }\n+\n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n     // we may not be configured to actually include a static library if we're\n     // adding it here. That's because later when we consume this rlib we'll\n@@ -334,42 +366,33 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         ab.inject_dll_import_lib(&raw_dylib_name, &raw_dylib_imports, tmpdir);\n     }\n \n-    // Note that it is important that we add all of our non-object \"magical\n-    // files\" *after* all of the object files in the archive. The reason for\n-    // this is as follows:\n-    //\n-    // * When performing LTO, this archive will be modified to remove\n-    //   objects from above. The reason for this is described below.\n-    //\n-    // * When the system linker looks at an archive, it will attempt to\n-    //   determine the architecture of the archive in order to see whether its\n-    //   linkable.\n-    //\n-    //   The algorithm for this detection is: iterate over the files in the\n-    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n-    //   object file. Read architecture from the object file.\n-    //\n-    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n-    //   before all of the objects, then the architecture of this archive would\n-    //   not be correctly inferred once 'foo.o' is removed.\n-    //\n-    // Basically, all this means is that this code should not move above the\n-    // code above.\n-    match flavor {\n-        RlibFlavor::Normal => {\n-            // metadata in rlib files is wrapped in a \"dummy\" object file for\n-            // the target platform so the rlib can be processed entirely by\n-            // normal linkers for the platform.\n-            let metadata = create_rmeta_file(sess, codegen_results.metadata.raw_data());\n-            ab.add_file(&emit_metadata(sess, &metadata, tmpdir));\n-        }\n-\n-        RlibFlavor::StaticlibBase => {\n-            let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n-            if let Some(obj) = obj {\n-                ab.add_file(obj);\n-            }\n-        }\n+    if let Some(trailing_metadata) = trailing_metadata {\n+        // Note that it is important that we add all of our non-object \"magical\n+        // files\" *after* all of the object files in the archive. The reason for\n+        // this is as follows:\n+        //\n+        // * When performing LTO, this archive will be modified to remove\n+        //   objects from above. The reason for this is described below.\n+        //\n+        // * When the system linker looks at an archive, it will attempt to\n+        //   determine the architecture of the archive in order to see whether its\n+        //   linkable.\n+        //\n+        //   The algorithm for this detection is: iterate over the files in the\n+        //   archive. Skip magical SYMDEF names. Interpret the first file as an\n+        //   object file. Read architecture from the object file.\n+        //\n+        // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n+        //   before all of the objects, then the architecture of this archive would\n+        //   not be correctly inferred once 'foo.o' is removed.\n+        //\n+        // * Most of the time metadata in rlib files is wrapped in a \"dummy\" object\n+        //   file for the target platform so the rlib can be processed entirely by\n+        //   normal linkers for the platform. Sometimes this is not possible however.\n+        //\n+        // Basically, all this means is that this code should not move above the\n+        // code above.\n+        ab.add_file(&trailing_metadata);\n     }\n \n     return Ok(ab);"}, {"sha": "c52269805c46fa4963440661655461f82c9e355f", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b186511f62b0ce20e72ede0e8e13f8787155f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b186511f62b0ce20e72ede0e8e13f8787155f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=3b186511f62b0ce20e72ede0e8e13f8787155f02", "patch": "@@ -166,6 +166,11 @@ fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     Some(file)\n }\n \n+pub enum MetadataPosition {\n+    First,\n+    Last,\n+}\n+\n // For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n // creates a dylib crate type it will pass `--whole-archive` (or the\n // platform equivalent) to include all object files from an rlib into the\n@@ -198,7 +203,7 @@ fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n // * ELF - All other targets are similar to Windows in that there's a\n //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n //   automatically removed from the final output.\n-pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n+pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataPosition) {\n     let Some(mut file) = create_object_file(sess) else {\n         // This is used to handle all \"other\" targets. This includes targets\n         // in two categories:\n@@ -216,7 +221,7 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n         // WebAssembly and for targets not supported by the `object` crate\n         // yet it means that work will need to be done in the `object` crate\n         // to add a case above.\n-        return metadata.to_vec();\n+        return (metadata.to_vec(), MetadataPosition::Last);\n     };\n     let section = file.add_section(\n         file.segment_name(StandardSegment::Debug).to_vec(),\n@@ -235,7 +240,7 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n         _ => {}\n     };\n     file.append_section_data(section, metadata, 1);\n-    file.write().unwrap()\n+    (file.write().unwrap(), MetadataPosition::First)\n }\n \n // Historical note:"}]}