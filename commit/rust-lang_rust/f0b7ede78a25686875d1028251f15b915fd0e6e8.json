{"sha": "f0b7ede78a25686875d1028251f15b915fd0e6e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYjdlZGU3OGEyNTY4Njg3NWQxMDI4MjUxZjE1YjkxNWZkMGU2ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T07:54:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T07:54:48Z"}, "message": "Auto merge of #26960 - Manishearth:wrapper-types, r=steveklabnik\n\n@steveklabnik had suggested I do this.\n\nThis needs much review -- I tried reducing the informal tone but there's room for improvement.\n\n\nr? @steveklabnik", "tree": {"sha": "d80952cb4d6ae133ffdd27cc38ad527ee21311f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d80952cb4d6ae133ffdd27cc38ad527ee21311f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0b7ede78a25686875d1028251f15b915fd0e6e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b7ede78a25686875d1028251f15b915fd0e6e8", "html_url": "https://github.com/rust-lang/rust/commit/f0b7ede78a25686875d1028251f15b915fd0e6e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0b7ede78a25686875d1028251f15b915fd0e6e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f044662be44f18d163db5fec4cde09c6d4342c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f044662be44f18d163db5fec4cde09c6d4342c", "html_url": "https://github.com/rust-lang/rust/commit/e4f044662be44f18d163db5fec4cde09c6d4342c"}, {"sha": "8484aca046336416be4f5121a59c371831d9914a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8484aca046336416be4f5121a59c371831d9914a", "html_url": "https://github.com/rust-lang/rust/commit/8484aca046336416be4f5121a59c371831d9914a"}], "stats": {"total": 361, "additions": 361, "deletions": 0}, "files": [{"sha": "6204f38a37753ce603b4e830c8aae400c5b360c3", "filename": "src/doc/rust.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=f0b7ede78a25686875d1028251f15b915fd0e6e8", "patch": "@@ -221,6 +221,10 @@ a > code {\n     color: #428BCA;\n }\n \n+.section-header > a > code {\n+    color: #8D1A38;\n+}\n+\n /* Code highlighting */\n pre.rust .kw { color: #8959A8; }\n pre.rust .kw-2, pre.rust .prelude-ty { color: #4271AE; }"}, {"sha": "85f0019276eefe36cb61e3fc957eb3e0dba220a8", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f0b7ede78a25686875d1028251f15b915fd0e6e8", "patch": "@@ -16,6 +16,7 @@\n     * [Iterators](iterators.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n+    * [Choosing your Guarantees](choosing-your-guarantees.md)\n     * [FFI](ffi.md)\n     * [Borrow and AsRef](borrow-and-asref.md)\n     * [Release Channels](release-channels.md)"}, {"sha": "db28ce6f428618427dae36aeea4828a120c6475b", "filename": "src/doc/trpl/choosing-your-guarantees.md", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0b7ede78a25686875d1028251f15b915fd0e6e8/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md?ref=f0b7ede78a25686875d1028251f15b915fd0e6e8", "patch": "@@ -0,0 +1,356 @@\n+% Choosing your Guarantees\n+\n+One important feature of Rust as language is that it lets us control the costs and guarantees\n+of a program.\n+\n+There are various &ldquo;wrapper type&rdquo; abstractions in the Rust standard library which embody\n+a multitude of tradeoffs between cost, ergonomics, and guarantees. Many let one choose between\n+run time and compile time enforcement. This section will explain a few selected abstractions in\n+detail.\n+\n+Before proceeding, it is highly recommended that one reads about [ownership][ownership] and\n+[borrowing][borrowing] in Rust.\n+\n+[ownership]: ownership.html\n+[borrowing]: references-and-borrowing.html\n+\n+# Basic pointer types\n+\n+## `Box<T>`\n+\n+[`Box<T>`][box] is pointer which is &ldquo;owned&rdquo;, or a &ldquo;box&rdquo;. While it can hand\n+out references to the contained data, it is the only owner of the data. In particular, when\n+something like the following occurs:\n+\n+```rust\n+let x = Box::new(1);\n+let y = x;\n+// x no longer accessible here\n+```\n+\n+Here, the box was _moved_ into `y`. As `x` no longer owns it, the compiler will no longer allow the\n+programmer to use `x` after this. A box can similarly be moved _out_ of a function by returning it.\n+\n+When a box (that hasn't been moved) goes out of scope, destructors are run. These destructors take\n+care of deallocating the inner data.\n+\n+This is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the\n+heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be\n+allowed to share references to this by the regular borrowing rules, checked at compile time.\n+\n+[box]: ../std/boxed/struct.Box.html\n+\n+## `&T` and `&mut T` \n+\n+These are immutable and mutable references respectively. They follow the &lquo;read-write lock&rquo;\n+pattern, such that one may either have only one mutable reference to some data, or any number of\n+immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at\n+runtime. In most cases these two pointer types suffice for sharing cheap references between sections\n+of code.\n+\n+These pointers cannot be copied in such a way that they outlive the lifetime associated with them.\n+\n+## `*const T` and `*mut T`\n+\n+These are C-like raw pointers with no lifetime or ownership attached to them. They just point to\n+some location in memory with no other restrictions. The only guarantee that these provide is that\n+they cannot be dereferenced except in code marked `unsafe`.\n+\n+These are useful when building safe, low cost abstractions like `Vec<T>`, but should be avoided in\n+safe code.\n+\n+## `Rc<T>`\n+\n+This is the first wrapper we will cover that has a runtime cost.\n+\n+[`Rc<T>`][rc] is a reference counted pointer. In other words, this lets us have multiple \"owning\"\n+pointers to the same data, and the data will be dropped (destructors will be run) when all pointers\n+are out of scope.\n+\n+Internally, it contains a shared &ldquo;reference count&rdquo; (also called &ldquo;refcount&rdquo;),\n+which is incremented each time the `Rc` is cloned, and decremented each time one of the `Rc`s goes\n+out of scope. The main responsibility of `Rc<T>` is to ensure that destructors are called for shared\n+data.\n+\n+The internal data here is immutable, and if a cycle of references is created, the data will be\n+leaked. If we want data that doesn't leak when there are cycles, we need a garbage collector.\n+\n+#### Guarantees\n+\n+The main guarantee provided here is that the data will not be destroyed until all references to it\n+are out of scope.\n+\n+This should be used when we wish to dynamically allocate and share some data (read-only) between\n+various portions of yur program, where it is not certain which portion will finish using the pointer\n+last. It's a viable alternative to `&T` when `&T` is either impossible to statically check for\n+correctness, or creates extremely unergonomic code where the programmer does not wish to spend the\n+development cost of working with.\n+\n+This pointer is _not_ thread safe, and Rust will not let it be sent or shared with other threads.\n+This lets one avoid the cost of atomics in situations where they are unnecessary.\n+\n+There is a sister smart pointer to this one, `Weak<T>`. This is a non-owning, but also non-borrowed,\n+smart pointer. It is also similar to `&T`, but it is not restricted in lifetime&mdash;a `Weak<T>`\n+can be held on to forever. However, it is possible that an attempt to access the inner data may fail\n+and return `None`, since this can outlive the owned `Rc`s. This is useful for cyclic\n+data structures and other things.\n+\n+#### Cost\n+\n+As far as memory goes, `Rc<T>` is a single allocation, though it will allocate two extra words (i.e.\n+two `usize` values) as compared to a regular `Box<T>` (for \"strong\" and \"weak\" refcounts).\n+\n+`Rc<T>` has the computational cost of incrementing/decrementing the refcount whenever it is cloned\n+or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply\n+increment the inner reference count and return a copy of the `Rc<T>`.\n+\n+[rc]: ../std/rc/struct.Rc.html\n+\n+# Cell types\n+\n+&lquo;Cell&rquo;s provide interior mutability. In other words, they contain data which can be manipulated even\n+if the type cannot be obtained in a mutable form (for example, when it is behind an `&`-ptr or\n+`Rc<T>`).\n+\n+[The documentation for the `cell` module has a pretty good explanation for these][cell-mod].\n+\n+These types are _generally_ found in struct fields, but they may be found elsewhere too.\n+\n+## `Cell<T>`\n+\n+[`Cell<T>`][cell] is a type that provides zero-cost interior mutability, but only for `Copy` types.\n+Since the compiler knows that all the data owned by the contained value is on the stack, there's\n+no worry of leaking any data behind references (or worse!) by simply replacing the data.\n+\n+It is still possible to violate your own invariants using this wrapper, so be careful when using it.\n+If a field is wrapped in `Cell`, it's a nice indicator that the chunk of data is mutable and may not\n+stay the same between the time you first read it and when you intend to use it.\n+\n+```rust\n+# use std::cell::Cell;\n+let x = Cell::new(1);\n+let y = &x;\n+let z = &x;\n+x.set(2);\n+y.set(3);\n+z.set(4);\n+println!(\"{}\", x.get());\n+```\n+\n+Note that here we were able to mutate the same value from various immutable references.\n+\n+This has the same runtime cost as the following:\n+\n+```rust,ignore\n+let mut x = 1;\n+let y = &mut x;\n+let z = &mut x;\n+x = 2;\n+*y = 3;\n+*z = 4;\n+println!(\"{}\", x);\n+```\n+\n+but it has the added benefit of actually compiling successfully.\n+\n+#### Guarantees\n+\n+This relaxes the &ldquo;no aliasing with mutability&rdquo; restriction in places where it's\n+unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your\n+invariants depend on data stored within `Cell`, you should be careful.\n+\n+This is useful for mutating primitives and other `Copy` types when there is no easy way of\n+doing it in line with the static rules of `&` and `&mut`.\n+\n+`Cell` does not let you obtain interior references to the data, which makes it safe to freely\n+mutate.\n+\n+#### Cost\n+\n+There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger (`Copy`)\n+structs, it might be worthwhile to instead wrap individual fields in `Cell<T>` since each write is\n+otherwise a full copy of the struct.\n+\n+\n+## `RefCell<T>`\n+\n+[`RefCell<T>`][refcell] also provides interior mutability, but isn't restricted to `Copy` types.\n+\n+Instead, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n+like a single-threaded mutex), unlike `&T`/`&mut T` which do so at compile time. This is done by the\n+`borrow()` and `borrow_mut()` functions, which modify an internal reference count and return smart\n+pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when\n+the smart pointers go out of scope. With this system, we can dynamically ensure that there are never\n+any other borrows active when a mutable borrow is active. If the programmer attempts to make such a\n+borrow, the thread will panic.\n+\n+```rust\n+# use std::cell::RefCell;\n+let x = RefCell::new(vec![1,2,3,4]);\n+{\n+    println!(\"{:?}\", *x.borrow())\n+}\n+\n+{\n+    let mut my_ref = x.borrow_mut();\n+    my_ref.push(1);\n+}\n+```\n+\n+Similar to `Cell`, this is mainly useful for situations where it's hard or impossible to satisfy the\n+borrow checker. Generally we know that such mutations won't happen in a nested form, but it's good\n+to check.\n+\n+For large, complicated programs, it becomes useful to put some things in `RefCell`s to make things\n+simpler. For example, a lot of the maps in [the `ctxt` struct][ctxt] in the rust compiler internals\n+are inside this wrapper. These are only modified once (during creation, which is not right after\n+initialization) or a couple of times in well-separated places. However, since this struct is\n+pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps\n+impossible) and probably form a soup of `&`-ptrs which would be hard to extend. On the other hand,\n+the `RefCell` provides a cheap (not zero-cost) way of safely accessing these. In the future, if\n+someone adds some code that attempts to modify the cell when it's already borrowed, it will cause a\n+(usually deterministic) panic which can be traced back to the offending borrow.\n+\n+Similarly, in Servo's DOM there is a lot of mutation, most of which is local to a DOM type, but some\n+of which crisscrosses the DOM and modifies various things. Using `RefCell` and `Cell` to guard all\n+mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the\n+places where mutation is _actually_ happening.\n+\n+Note that `RefCell` should be avoided if a mostly simple solution is possible with `&` pointers.\n+\n+#### Guarantees\n+\n+`RefCell` relaxes the _static_ restrictions preventing aliased mutation, and replaces them with\n+_dynamic_ ones. As such the guarantees have not changed.\n+\n+#### Cost\n+\n+`RefCell` does not allocate, but it contains an additional \"borrow state\"\n+indicator (one word in size) along with the data.\n+\n+At runtime each borrow causes a modification/check of the refcount.\n+\n+[cell-mod]: ../std/cell/\n+[cell]: ../std/cell/struct.Cell.html\n+[refcell]: ../std/cell/struct.RefCell.html\n+[ctxt]: ../rustc/middle/ty/struct.ctxt.html\n+\n+# Synchronous types\n+\n+Many of the types above cannot be used in a threadsafe manner. Particularly, `Rc<T>` and\n+`RefCell<T>`, which both use non-atomic reference counts (_atomic_ reference counts are those which\n+can be incremented from multiple threads without causing a data race), cannot be used this way. This\n+makes them cheaper to use, but we need thread safe versions of these too. They exist, in the form of\n+`Arc<T>` and `Mutex<T>`/`RWLock<T>`\n+\n+Note that the non-threadsafe types _cannot_ be sent between threads, and this is checked at compile\n+time.\n+\n+There are many useful wrappers for concurrent programming in the [sync][sync] module, but only the\n+major ones will be covered below.\n+\n+[sync]: ../std/sync/index.html\n+\n+## `Arc<T>`\n+\n+[`Arc<T>`][arc] is just a version of `Rc<T>` that uses an atomic reference count (hence, \"Arc\").\n+This can be sent freely between threads.\n+\n+C++'s `shared_ptr` is similar to `Arc`, however in the case of C++ the inner data is always mutable.\n+For semantics similar to that from C++, we should use `Arc<Mutex<T>>`, `Arc<RwLock<T>>`, or\n+`Arc<UnsafeCell<T>>`[^4] (`UnsafeCell<T>` is a cell type that can be used to hold any data and has\n+no runtime cost, but accessing it requires `unsafe` blocks). The last one should only be used if we\n+are certain that the usage won't cause any memory unsafety. Remember that writing to a struct is not\n+an atomic operation, and many functions like `vec.push()` can reallocate internally and cause unsafe\n+behavior, so even monotonicity may not be enough to justify `UnsafeCell`.\n+\n+[^4]: `Arc<UnsafeCell<T>>` actually won't compile since `UnsafeCell<T>` isn't `Send` or `Sync`, but we can wrap it in a type and implement `Send`/`Sync` for it manually to get `Arc<Wrapper<T>>` where `Wrapper` is `struct Wrapper<T>(UnsafeCell<T>)`.\n+\n+#### Guarantees\n+\n+Like `Rc`, this provides the (thread safe) guarantee that the destructor for the internal data will\n+be run when the last `Arc` goes out of scope (barring any cycles).\n+\n+#### Cost\n+\n+This has the added cost of using atomics for changing the refcount (which will happen whenever it is\n+cloned or goes out of scope). When sharing data from an `Arc` in a single thread, it is preferable\n+to share `&` pointers whenever possible.\n+\n+[arc]: ../std/sync/struct.Arc.html\n+\n+## `Mutex<T>` and `RwLock<T>`\n+\n+[`Mutex<T>`][mutex] and [`RwLock<T>`][rwlock] provide mutual-exclusion via RAII guards (guards are\n+objects which maintain some state, like a lock, until their destructor is called). For both of\n+these, the mutex is opaque until we call `lock()` on it, at which point the thread will block\n+until a lock can be acquired, and then a guard will be returned. This guard can be used to access\n+the inner data (mutably), and the lock will be released when the guard goes out of scope.\n+\n+```rust,ignore\n+{\n+    let guard = mutex.lock();\n+    // guard dereferences mutably to the inner type\n+    *guard += 1;\n+} // lock released when destructor runs\n+```\n+\n+\n+`RwLock` has the added benefit of being efficient for multiple reads. It is always safe to have\n+multiple readers to shared data as long as there are no writers; and `RwLock` lets readers acquire a\n+\"read lock\". Such locks can be acquired concurrently and are kept track of via a reference count.\n+Writers must obtain a \"write lock\" which can only be obtained when all readers have gone out of\n+scope.\n+\n+#### Guarantees\n+\n+Both of these provide safe shared mutability across threads, however they are prone to deadlocks.\n+Some level of additional protocol safety can be obtained via the type system.\n+#### Costs\n+\n+These use internal atomic-like types to maintain the locks, which are pretty costly (they can block\n+all memory reads across processors till they're done). Waiting on these locks can also be slow when\n+there's a lot of concurrent access happening.\n+\n+[rwlock]: ../std/sync/struct.RwLock.html\n+[mutex]: ../std/sync/struct.Mutex.html\n+[sessions]: https://github.com/Munksgaard/rust-sessions\n+\n+# Composition\n+\n+A common gripe when reading Rust code is with types like `Rc<RefCell<Vec<T>>>` (or even more more\n+complicated compositions of such types). It's not always clear what the composition does, or why the\n+author chose one like this (and when one should be using such a composition in one's own code)\n+\n+Usually, it's a case of composing together the guarantees that you need, without paying for stuff\n+that is unnecessary.\n+\n+For example, `Rc<RefCell<T>>` is one such composition. `Rc<T>` itself can't be dereferenced mutably;\n+because `Rc<T>` provides sharing and shared mutability can lead to unsafe behavior, so we put\n+`RefCell<T>` inside to get dynamically verified shared mutability. Now we have shared mutable data,\n+but it's shared in a way that there can only be one mutator (and no readers) or multiple readers.\n+\n+Now, we can take this a step further, and have `Rc<RefCell<Vec<T>>>` or `Rc<Vec<RefCell<T>>>`. These\n+are both shareable, mutable vectors, but they're not the same.\n+\n+With the former, the `RefCell<T>` is wrapping the `Vec<T>`, so the `Vec<T>` in its entirety is\n+mutable. At the same time, there can only be one mutable borrow of the whole `Vec` at a given time.\n+This means that your code cannot simultaneously work on different elements of the vector from\n+different `Rc` handles. However, we are able to push and pop from the `Vec<T>` at will. This is\n+similar to an `&mut Vec<T>` with the borrow checking done at runtime.\n+\n+With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus,\n+we can independently borrow separate elements, but we cannot push or pop from the vector. This is\n+similar to an `&mut [T]`[^3], but, again, the borrow checking is at runtime.\n+\n+In concurrent programs, we have a similar situation with `Arc<Mutex<T>>`, which provides shared\n+mutability and ownership.\n+\n+When reading code that uses these, go in step by step and look at the guarantees/costs provided.\n+\n+When choosing a composed type, we must do the reverse; figure out which guarantees we want, and at\n+which point of the composition we need them. For example, if there is a choice between\n+`Vec<RefCell<T>>` and `RefCell<Vec<T>>`, we should figure out the tradeoffs as done above and pick\n+one.\n+\n+[^3]: `&[T]` and `&mut [T]` are _slices_; they consist of a pointer and a length and can refer to a portion of a vector or array. `&mut [T]` can have its elements mutated, however its length cannot be touched."}]}