{"sha": "61b6363cb1bb5ce895cd3927f80ec06a41c147de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYjYzNjNjYjFiYjVjZTg5NWNkMzkyN2Y4MGVjMDZhNDFjMTQ3ZGU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-20T23:16:12Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-20T23:17:18Z"}, "message": "Add more detail to the split_grouped_constructors comment", "tree": {"sha": "ecbeeb3a5f8ce0d49ff119b16568cfbcb681735c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecbeeb3a5f8ce0d49ff119b16568cfbcb681735c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61b6363cb1bb5ce895cd3927f80ec06a41c147de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61b6363cb1bb5ce895cd3927f80ec06a41c147de", "html_url": "https://github.com/rust-lang/rust/commit/61b6363cb1bb5ce895cd3927f80ec06a41c147de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61b6363cb1bb5ce895cd3927f80ec06a41c147de/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c421af995b567322d3f3fdeb1bccec02645cf25c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c421af995b567322d3f3fdeb1bccec02645cf25c", "html_url": "https://github.com/rust-lang/rust/commit/c421af995b567322d3f3fdeb1bccec02645cf25c"}], "stats": {"total": 33, "additions": 25, "deletions": 8}, "files": [{"sha": "484b8209658876eb488e40cb8d70a657f410cf26", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/61b6363cb1bb5ce895cd3927f80ec06a41c147de/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6363cb1bb5ce895cd3927f80ec06a41c147de/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=61b6363cb1bb5ce895cd3927f80ec06a41c147de", "patch": "@@ -1396,9 +1396,9 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// impractical. However, observe that for some ranges of integers, the specialisation will be\n /// identical across all values in that range (i.e. there are equivalence classes of ranges of\n /// constructors based on their `is_useful_specialised` outcome). These classes are grouped by\n-/// the patterns that apply to them (both in the matrix `P` and in the new row `p_{m + 1}`). We\n-/// can split the range whenever the patterns that apply to that range (specifically: the patterns\n-/// that *intersect* with that range) change.\n+/// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n+/// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n+/// change.\n /// Our solution, therefore, is to split the range constructor into subranges at every single point\n /// the group of intersecting patterns changes, which we can compute by converting each pattern to\n /// a range and recording its endpoints, then creating subranges between each consecutive pair of\n@@ -1407,6 +1407,21 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n /// number of rows in the matrix (i.e. the number of cases in the `match` statement), so we don't\n /// need to be worried about matching over gargantuan ranges.\n+///\n+/// Essentially, given the first column of a matrix representing ranges, looking like the following:\n+///\n+/// |------|  |----------| |-------|    ||\n+///    |-------| |-------|            |----| ||\n+///       |---------|\n+///\n+/// We truncate the ranges so that they lie inside each range constructor and then split them\n+/// up into equivalence classes so the ranges are no longer overlapping:\n+///\n+/// |--|--|||-||||--||---|||-------|  |-|||| ||\n+///\n+/// The logic for determining how to split the ranges is a little involved: we need to make sure\n+/// that we have a new range for each subrange for which a different set of rows co\u00efncides, but\n+/// essentially reduces to case analysis on the endpoints of the ranges.\n fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n@@ -1420,10 +1435,9 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n             // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n             // special-case constant ranges.\n             ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n-                // We only care about finding all the subranges within the range of the intersection\n-                // of the new pattern `p_({m + 1},1)` (here `pat`) and the constructor range.\n-                // Anything else is irrelevant, because it is guaranteed to result in `NotUseful`,\n-                // which is the default case anyway, and can be ignored.\n+                // We only care about finding all the subranges within the range of the constructor\n+                // range. Anything else is irrelevant, because it is guaranteed to result in\n+                // `NotUseful`, which is the default case anyway, and can be ignored.\n                 let ctor_range = IntRange::from_ctor(tcx, &ctor).unwrap();\n \n                 // We're going to collect all the endpoints in the new pattern so we can create\n@@ -1479,6 +1493,9 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n                 // sure we're enumerating precisely the correct ranges. Too few and the matching is\n                 // actually incorrect. Too many and our diagnostics are poorer. This involves some\n                 // case analysis.\n+                // In essence, we need to ensure that every time the set of row-ranges that are\n+                // overlapping changes (as we go through the values covered by the ranges), we split\n+                // into a new subrange.\n                 while let Some(b) = points.next() {\n                     // a < b (strictly)\n                     if let Endpoint::Both = a.1 {\n@@ -1522,7 +1539,7 @@ fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n                     let (pat_lo, pat_hi) = pat.range.into_inner();\n                     let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n                     assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n-                    Some(vec![])\n+                    vec![]\n                 })\n             }\n             _ => None,"}]}