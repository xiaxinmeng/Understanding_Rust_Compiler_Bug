{"sha": "f39a215f270bc8c958a19cc9f693720232340cbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOWEyMTVmMjcwYmM4Yzk1OGExOWNjOWY2OTM3MjAyMzIzNDBjYmM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-26T09:08:44Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:42Z"}, "message": "std::rand: add the StdRng wrapper for a blessed RNG.\n\nThis is implemented as a wrapper around another RNG. It is designed\nto allow the actual implementation to be changed without changing\nthe external API (e.g. it currently uses a 64-bit generator on 64-\nbit platforms, and a 32-bit one on 32-bit platforms; but one could\nimagine that the IsaacRng may be deprecated later, and having this\nability to switch algorithms without having to update the points of\nuse is convenient.)\n\nThis is the recommended general use RNG.", "tree": {"sha": "16a10ea85c5adecad10b77d78d66448f9bc450d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16a10ea85c5adecad10b77d78d66448f9bc450d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f39a215f270bc8c958a19cc9f693720232340cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f39a215f270bc8c958a19cc9f693720232340cbc", "html_url": "https://github.com/rust-lang/rust/commit/f39a215f270bc8c958a19cc9f693720232340cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f39a215f270bc8c958a19cc9f693720232340cbc/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "html_url": "https://github.com/rust-lang/rust/commit/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8"}], "stats": {"total": 61, "additions": 54, "deletions": 7}, "files": [{"sha": "4528174a212ba73351f3dcfa0973742193c23778", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f39a215f270bc8c958a19cc9f693720232340cbc/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39a215f270bc8c958a19cc9f693720232340cbc/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=f39a215f270bc8c958a19cc9f693720232340cbc", "patch": "@@ -643,8 +643,46 @@ pub trait Rng {\n /// available in Rust. If you require a specifically seeded `Rng` for\n /// consistency over time you should pick one algorithm and create the\n /// `Rng` yourself.\n-pub fn rng() -> IsaacRng {\n-    IsaacRng::new()\n+///\n+/// This is a very expensive operation as it has to read randomness\n+/// from the operating system and use this in an expensive seeding\n+/// operation. If one does not require high performance, `task_rng`\n+/// and/or `random` may be more appropriate.\n+pub fn rng() -> StdRng {\n+    StdRng::new()\n+}\n+\n+/// The standard RNG. This is designed to be efficient on the current\n+/// platform.\n+#[cfg(not(target_word_size=\"64\"))]\n+pub struct StdRng { priv rng: IsaacRng }\n+\n+/// The standard RNG. This is designed to be efficient on the current\n+/// platform.\n+#[cfg(target_word_size=\"64\")]\n+pub struct StdRng { priv rng: Isaac64Rng }\n+\n+impl StdRng {\n+    #[cfg(not(target_word_size=\"64\"))]\n+    fn new() -> StdRng {\n+        StdRng { rng: IsaacRng::new() }\n+    }\n+    #[cfg(target_word_size=\"64\")]\n+    fn new() -> StdRng {\n+        StdRng { rng: Isaac64Rng::new() }\n+    }\n+}\n+\n+impl Rng for StdRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        self.rng.next_u32()\n+    }\n+\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        self.rng.next_u64()\n+    }\n }\n \n /// Create a weak random number generator with a default algorithm and seed.\n@@ -728,23 +766,23 @@ pub fn seed(n: uint) -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n-local_data_key!(tls_rng_state: @@mut IsaacRng)\n+local_data_key!(tls_rng_state: @mut StdRng)\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * `task_rng().gen::<int>()`.\n  */\n #[inline]\n-pub fn task_rng() -> @mut IsaacRng {\n+pub fn task_rng() -> @mut StdRng {\n     let r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n     match r {\n         None => {\n-            let rng = @@mut IsaacRng::new();\n+            let rng = @mut StdRng::new();\n             local_data::set(tls_rng_state, rng);\n-            *rng\n+            rng\n         }\n-        Some(rng) => *rng\n+        Some(rng) => rng\n     }\n }\n \n@@ -985,6 +1023,15 @@ mod bench {\n         bh.bytes = size_of::<uint>() as u64;\n     }\n \n+    #[bench]\n+    fn rand_std(bh: &mut BenchHarness) {\n+        let mut rng = StdRng::new();\n+        do bh.iter {\n+            rng.gen::<uint>();\n+        }\n+        bh.bytes = size_of::<uint>() as u64;\n+    }\n+\n     #[bench]\n     fn rand_shuffle_100(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();"}]}