{"sha": "a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "node_id": "C_kwDOAAsO6NoAKGE5YzFhYjgyZjVmNThhODQ1OWZjNWYxZjJkMTMwMjFlODBmMjM0MjE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-07T15:05:17Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-21T06:06:55Z"}, "message": "safely `transmute<&List<Ty<'tcx>>, &List<GenericArg<'tcx>>>`", "tree": {"sha": "4b1469d06ea6e4af5f60dd210d36b0165b3b93ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b1469d06ea6e4af5f60dd210d36b0165b3b93ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "html_url": "https://github.com/rust-lang/rust/commit/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45e2c2881d11324d610815bfff097e25c412199e", "url": "https://api.github.com/repos/rust-lang/rust/commits/45e2c2881d11324d610815bfff097e25c412199e", "html_url": "https://github.com/rust-lang/rust/commit/45e2c2881d11324d610815bfff097e25c412199e"}], "stats": {"total": 95, "additions": 89, "deletions": 6}, "files": [{"sha": "925ef9a2ea486fc289a68b40df3b76c0c18314e4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "patch": "@@ -101,7 +101,6 @@ pub struct CtxtInterners<'tcx> {\n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n-    type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind>,\n@@ -129,7 +128,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n-            type_list: Default::default(),\n             substs: Default::default(),\n             region: Default::default(),\n             poly_existential_predicates: Default::default(),\n@@ -1666,6 +1664,23 @@ macro_rules! nop_lift {\n     };\n }\n \n+// Can't use the macros as we have reuse the `substs` here.\n+//\n+// See `intern_type_list` for more info.\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n+    type Lifted = &'tcx List<Ty<'tcx>>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        if self.is_empty() {\n+            return Some(List::empty());\n+        }\n+        if tcx.interners.substs.contains_pointer_to(&InternedInSet(self.as_substs())) {\n+            Some(unsafe { mem::transmute(self) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n@@ -1690,7 +1705,6 @@ nop_lift! {const_; Const<'a> => Const<'tcx>}\n nop_lift_old! {const_allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n-nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n@@ -2189,7 +2203,6 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n-    type_list: _intern_type_list(Ty<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n@@ -2611,7 +2624,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n-        if ts.is_empty() { List::empty() } else { self._intern_type_list(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            // Actually intern type lists as lists of `GenericArg`s.\n+            //\n+            // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n+            // as explained in ty_slice_as_generic_arg`. With this,\n+            // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n+            // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n+            // lists is upheld.\n+            let substs = self._intern_substs(ty::subst::ty_slice_as_generic_args(ts));\n+            substs.try_as_type_list().unwrap()\n+        }\n     }\n \n     pub fn intern_substs(self, ts: &[GenericArg<'tcx>]) -> &'tcx List<GenericArg<'tcx>> {"}, {"sha": "4e3661dda175f4ef25a86befb448ce6c55ee0858", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "patch": "@@ -61,6 +61,28 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'t\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArgKind<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        match self {\n+            // WARNING: We dedup cache the `HashStable` results for `List`\n+            // while ignoring types and freely transmute\n+            // between `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>`.\n+            // See `fn intern_type_list` for more details.\n+            //\n+            // We therefore hash types without adding a hash for their discriminant.\n+            ty::subst::GenericArgKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+            ty::subst::GenericArgKind::Const(ct) => {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                ct.hash_stable(hcx, hasher);\n+            }\n+            ty::subst::GenericArgKind::Lifetime(lt) => {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                lt.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "7085168781c7c5a21b2147ee1514296bba00ba28", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1ab82f5f58a8459fc5f1f2d13021e80f23421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a9c1ab82f5f58a8459fc5f1f2d13021e80f23421", "patch": "@@ -20,6 +20,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n use std::ops::ControlFlow;\n+use std::slice;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n@@ -40,13 +41,37 @@ const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord)]\n pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n     Const(ty::Const<'tcx>),\n }\n \n+/// This function goes from `&'a [Ty<'tcx>]` to `&'a [GenericArg<'tcx>]`\n+///\n+/// This is sound as, for types, `GenericArg` is just\n+/// `NonZeroUsize::new_unchecked(ty as *const _ as usize)`.\n+pub fn ty_slice_as_generic_args<'a, 'tcx>(ts: &'a [Ty<'tcx>]) -> &'a [GenericArg<'tcx>] {\n+    assert_eq!(TYPE_TAG, 0);\n+    // SAFETY: the whole slice is valid and immutable.\n+    // `Ty` and `GenericArg` is explained above.\n+    unsafe { slice::from_raw_parts(ts.as_ptr().cast(), ts.len()) }\n+}\n+\n+impl<'tcx> List<Ty<'tcx>> {\n+    /// Allows to freely switch betwen `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>`.\n+    ///\n+    /// As lists are interned, `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>` have\n+    /// be interned together, see `intern_type_list` for more details.\n+    #[inline]\n+    pub fn as_substs(&'tcx self) -> SubstsRef<'tcx> {\n+        assert_eq!(TYPE_TAG, 0);\n+        // SAFETY: `List<T>` is `#[repr(C)]`. `Ty` and `GenericArg` is explained above.\n+        unsafe { &*(self as *const List<Ty<'tcx>> as *const List<GenericArg<'tcx>>) }\n+    }\n+}\n+\n impl<'tcx> GenericArgKind<'tcx> {\n     #[inline]\n     fn pack(self) -> GenericArg<'tcx> {\n@@ -208,6 +233,17 @@ pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'tcx> InternalSubsts<'tcx> {\n+    /// Checks whether all elements of this list are types, if so, transmute.\n+    pub fn try_as_type_list(&'tcx self) -> Option<&'tcx List<Ty<'tcx>>> {\n+        if self.iter().all(|arg| matches!(arg.unpack(), GenericArgKind::Type(_))) {\n+            assert_eq!(TYPE_TAG, 0);\n+            // SAFETY: All elements are types, see `List<Ty<'tcx>>::as_substs`.\n+            Some(unsafe { &*(self as *const List<GenericArg<'tcx>> as *const List<Ty<'tcx>>) })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Interpret these substitutions as the substitutions of a closure type.\n     /// Closure substitutions have a particular structure controlled by the\n     /// compiler that encodes information like the signature and closure kind;"}]}