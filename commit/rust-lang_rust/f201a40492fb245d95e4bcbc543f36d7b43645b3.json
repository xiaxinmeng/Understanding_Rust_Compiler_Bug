{"sha": "f201a40492fb245d95e4bcbc543f36d7b43645b3", "node_id": "C_kwDOAAsO6NoAKGYyMDFhNDA0OTJmYjI0NWQ5NWU0YmNiYzU0M2YzNmQ3YjQzNjQ1YjM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T12:18:03Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T13:09:48Z"}, "message": "Remove ImmediateLocation in favor of PathKind::Type", "tree": {"sha": "6e09db24861af24816680831bc71d3587ea687fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e09db24861af24816680831bc71d3587ea687fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f201a40492fb245d95e4bcbc543f36d7b43645b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f201a40492fb245d95e4bcbc543f36d7b43645b3", "html_url": "https://github.com/rust-lang/rust/commit/f201a40492fb245d95e4bcbc543f36d7b43645b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f201a40492fb245d95e4bcbc543f36d7b43645b3/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b246292ca133e64f552fbc627f85f98fca01c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b246292ca133e64f552fbc627f85f98fca01c18", "html_url": "https://github.com/rust-lang/rust/commit/6b246292ca133e64f552fbc627f85f98fca01c18"}], "stats": {"total": 244, "additions": 87, "deletions": 157}, "files": [{"sha": "c540b87a46fda9b0a208025a8e600d7e9394a9dc", "filename": "crates/ide-completion/src/completions/field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=f201a40492fb245d95e4bcbc543f36d7b43645b3", "patch": "@@ -3,7 +3,7 @@\n use crate::{\n     context::{\n         IdentContext, NameContext, NameKind, NameRefContext, NameRefKind, PathCompletionCtx,\n-        PathKind,\n+        PathKind, TypeLocation,\n     },\n     CompletionContext, Completions,\n };\n@@ -18,7 +18,7 @@ pub(crate) fn complete_field_list(acc: &mut Completions, ctx: &CompletionContext\n                     is_absolute_path: false,\n                     qualifier: None,\n                     parent: None,\n-                    kind: PathKind::Type { in_tuple_struct: true, ascription: None },\n+                    kind: PathKind::Type { location: TypeLocation::TupleField },\n                     has_type_args: false,\n                     ..\n                 })),"}, {"sha": "6266bcef34e0bf6bff1957b68d33e0c8d0eb9ad0", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=f201a40492fb245d95e4bcbc543f36d7b43645b3", "patch": "@@ -9,9 +9,9 @@ use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n     context::{\n-        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind, PatternContext,\n+        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n+        PatternContext, TypeLocation,\n     },\n-    patterns::ImmediateLocation,\n     render::{render_resolution_with_import, RenderContext},\n };\n \n@@ -112,7 +112,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    let path_kind = match dbg!(ctx.nameref_ctx()) {\n+    let path_kind = match ctx.nameref_ctx() {\n         Some(NameRefContext {\n             kind:\n                 Some(NameRefKind::Path(PathCompletionCtx {\n@@ -176,8 +176,8 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Pat, ItemInNs::Types(_)) => true,\n             (PathKind::Pat, ItemInNs::Values(def)) => matches!(def, hir::ModuleDef::Const(_)),\n \n-            (PathKind::Type { .. }, ItemInNs::Types(ty)) => {\n-                if matches!(ctx.completion_location, Some(ImmediateLocation::TypeBound)) {\n+            (PathKind::Type { location }, ItemInNs::Types(ty)) => {\n+                if matches!(location, TypeLocation::TypeBound) {\n                     matches!(ty, ModuleDef::Trait(_))\n                 } else {\n                     true"}, {"sha": "9d3a1c24293d78c33a3dba563ea5a7b17d6b3d54", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=f201a40492fb245d95e4bcbc543f36d7b43645b3", "patch": "@@ -5,22 +5,21 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PathQualifierCtx, TypeAscriptionTarget},\n-    patterns::ImmediateLocation,\n+    context::{PathCompletionCtx, PathKind, PathQualifierCtx, TypeAscriptionTarget, TypeLocation},\n     render::render_type_inference,\n     CompletionContext, Completions,\n };\n \n pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_type_path\");\n \n-    let (&is_absolute_path, qualifier) = match ctx.path_context() {\n+    let (&is_absolute_path, location, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n-            kind: PathKind::Type { .. },\n+            kind: PathKind::Type { location },\n             is_absolute_path,\n             qualifier,\n             ..\n-        }) => (is_absolute_path, qualifier),\n+        }) => (is_absolute_path, location, qualifier),\n         _ => return,\n     };\n \n@@ -32,7 +31,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n             ScopeDef::ModuleDef(Function(_) | Variant(_) | Static(_)) | ScopeDef::Local(_) => false,\n             // unless its a constant in a generic arg list position\n             ScopeDef::ModuleDef(Const(_)) | ScopeDef::GenericParam(ConstParam(_)) => {\n-                ctx.expects_generic_arg()\n+                matches!(location, TypeLocation::GenericArgList(_))\n             }\n             ScopeDef::ImplSelfType(_) => {\n                 !ctx.previous_token_is(syntax::T![impl]) && !ctx.previous_token_is(syntax::T![for])\n@@ -47,14 +46,22 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         }\n     };\n \n+    let add_assoc_item = |acc: &mut Completions, item| match item {\n+        hir::AssocItem::Const(ct) if matches!(location, TypeLocation::GenericArgList(_)) => {\n+            acc.add_const(ctx, ct)\n+        }\n+        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => (),\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+    };\n+\n     match qualifier {\n         Some(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n             if *is_infer_qualifier {\n                 ctx.traits_in_scope()\n                     .0\n                     .into_iter()\n                     .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-                    .for_each(|item| add_assoc_item(acc, ctx, item));\n+                    .for_each(|item| add_assoc_item(acc, item));\n                 return;\n             }\n             let resolution = match resolution {\n@@ -98,7 +105,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                         Some(ctx.module),\n                         None,\n                         |item| {\n-                            add_assoc_item(acc, ctx, item);\n+                            add_assoc_item(acc, item);\n                             None::<()>\n                         },\n                     );\n@@ -114,7 +121,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n                     // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n                     for item in t.items(ctx.db) {\n-                        add_assoc_item(acc, ctx, item);\n+                        add_assoc_item(acc, item);\n                     }\n                 }\n                 hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n@@ -135,7 +142,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                             // We might iterate candidates of a trait multiple times here, so deduplicate\n                             // them.\n                             if seen.insert(item) {\n-                                add_assoc_item(acc, ctx, item);\n+                                add_assoc_item(acc, item);\n                             }\n                             None::<()>\n                         },\n@@ -147,7 +154,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         None if is_absolute_path => acc.add_crate_roots(ctx),\n         None => {\n             acc.add_nameref_keywords_with_colon(ctx);\n-            if let Some(ImmediateLocation::TypeBound) = &ctx.completion_location {\n+            if let TypeLocation::TypeBound = location {\n                 ctx.process_all_names(&mut |name, res| {\n                     let add_resolution = match res {\n                         ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n@@ -162,7 +169,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 });\n                 return;\n             }\n-            if let Some(ImmediateLocation::GenericArgList(arg_list)) = &ctx.completion_location {\n+            if let TypeLocation::GenericArgList(Some(arg_list)) = location {\n                 if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n                 {\n                     if path_seg.syntax().ancestors().find_map(ast::TypeBound::cast).is_some() {\n@@ -189,10 +196,10 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n }\n \n pub(crate) fn complete_inferred_type(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let pat = match dbg!(ctx.path_context()) {\n+    let pat = match ctx.path_context() {\n         Some(\n             ctx @ PathCompletionCtx {\n-                kind: PathKind::Type { ascription: Some(ascription), .. },\n+                kind: PathKind::Type { location: TypeLocation::TypeAscription(ascription), .. },\n                 ..\n             },\n         ) if ctx.is_trivial_path() => ascription,\n@@ -211,11 +218,3 @@ pub(crate) fn complete_inferred_type(acc: &mut Completions, ctx: &CompletionCont\n     acc.add(render_type_inference(ty_string, ctx));\n     None\n }\n-\n-fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n-    match item {\n-        hir::AssocItem::Const(ct) if ctx.expects_generic_arg() => acc.add_const(ctx, ct),\n-        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => (),\n-        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-    }\n-}"}, {"sha": "7421a3e98bf087485ef52d408e49671d5d25dd72", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=f201a40492fb245d95e4bcbc543f36d7b43645b3", "patch": "@@ -22,10 +22,7 @@ use syntax::{\n use text_edit::Indel;\n \n use crate::{\n-    patterns::{\n-        determine_location, is_in_loop_body, is_in_token_of_for_loop, previous_token,\n-        ImmediateLocation,\n-    },\n+    patterns::{is_in_loop_body, is_in_token_of_for_loop, previous_token},\n     CompletionConfig,\n };\n \n@@ -102,10 +99,7 @@ pub(super) enum PathKind {\n         is_func_update: Option<ast::RecordExpr>,\n     },\n     Type {\n-        in_tuple_struct: bool,\n-        /// Whether this type path is a type ascription or not\n-        /// Original file ast node\n-        ascription: Option<TypeAscriptionTarget>,\n+        location: TypeLocation,\n     },\n     Attr {\n         kind: AttrKind,\n@@ -123,6 +117,16 @@ pub(super) enum PathKind {\n     Use,\n }\n \n+/// Original file ast nodes\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum TypeLocation {\n+    TupleField,\n+    TypeAscription(TypeAscriptionTarget),\n+    GenericArgList(Option<ast::GenericArgList>),\n+    TypeBound,\n+    Other,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum TypeAscriptionTarget {\n     Let(Option<ast::Pat>),\n@@ -222,6 +226,7 @@ pub(super) enum NameKind {\n pub(super) struct NameRefContext {\n     /// NameRef syntax in the original file\n     pub(super) nameref: Option<ast::NameRef>,\n+    // FIXME: This shouldn't be an Option\n     pub(super) kind: Option<NameRefKind>,\n }\n \n@@ -311,9 +316,9 @@ pub(crate) struct CompletionContext<'a> {\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n     /// Are we completing inside a let statement with a missing semicolon?\n+    // FIXME: This should be part of PathKind::Expr\n     pub(super) incomplete_let: bool,\n \n-    pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) previous_token: Option<SyntaxToken>,\n \n     pub(super) ident_ctx: IdentContext,\n@@ -386,11 +391,6 @@ impl<'a> CompletionContext<'a> {\n         self.dot_receiver().is_some()\n     }\n \n-    // FIXME: This shouldn't exist\n-    pub(crate) fn expects_generic_arg(&self) -> bool {\n-        matches!(self.completion_location, Some(ImmediateLocation::GenericArgList(_)))\n-    }\n-\n     pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n         self.nameref_ctx().and_then(|ctx| match &ctx.kind {\n             Some(NameRefKind::Path(path)) => Some(path),\n@@ -542,7 +542,6 @@ impl<'a> CompletionContext<'a> {\n             function_def: None,\n             impl_def: None,\n             incomplete_let: false,\n-            completion_location: None,\n             previous_token: None,\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n@@ -935,8 +934,6 @@ impl<'a> CompletionContext<'a> {\n                 return Some(());\n             }\n         };\n-        self.completion_location =\n-            determine_location(&self.sema, original_file, offset, &name_like);\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n@@ -1094,7 +1091,7 @@ impl<'a> CompletionContext<'a> {\n             match parent {\n                 ast::PathSegment(segment) => segment,\n                 ast::FieldExpr(field) => {\n-                    let receiver = find_in_original_file(field.expr(), original_file);\n+                    let receiver = find_opt_node_in_file(original_file, field.expr());\n                     let receiver_is_ambiguous_float_literal = match &receiver {\n                         Some(ast::Expr::Literal(l)) => matches! {\n                             l.kind(),\n@@ -1110,7 +1107,7 @@ impl<'a> CompletionContext<'a> {\n                     return res;\n                 },\n                 ast::MethodCallExpr(method) => {\n-                    let receiver = find_in_original_file(method.receiver(), original_file);\n+                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n                     nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n                         receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n                         kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n@@ -1189,14 +1186,14 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n-        let fetch_ascription = |it: Option<SyntaxNode>| {\n+        let type_location = |it: Option<SyntaxNode>| {\n             let parent = it?;\n-            match_ast! {\n+            let res = match_ast! {\n                 match parent {\n                     ast::Const(it) => {\n-                        let name = find_in_original_file(it.name(), original_file)?;\n+                        let name = find_opt_node_in_file(original_file, it.name())?;\n                         let original = ast::Const::cast(name.syntax().parent()?)?;\n-                        Some(TypeAscriptionTarget::Const(original.body()))\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n                     },\n                     ast::RetType(it) => {\n                         if it.thin_arrow_token().is_none() {\n@@ -1207,8 +1204,8 @@ impl<'a> CompletionContext<'a> {\n                             None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n                         };\n \n-                        let parent = find_in_original_file(parent, original_file)?.syntax().parent()?;\n-                        Some(TypeAscriptionTarget::RetType(match_ast! {\n+                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n                             match parent {\n                                 ast::ClosureExpr(it) => {\n                                     it.body()\n@@ -1224,28 +1221,35 @@ impl<'a> CompletionContext<'a> {\n                         if it.colon_token().is_none() {\n                             return None;\n                         }\n-                        Some(TypeAscriptionTarget::FnParam(find_in_original_file(it.pat(), original_file)))\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n                     },\n                     ast::LetStmt(it) => {\n                         if it.colon_token().is_none() {\n                             return None;\n                         }\n-                        Some(TypeAscriptionTarget::Let(find_in_original_file(it.pat(), original_file)))\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n                     },\n-                    _ => None,\n+                    ast::TypeBound(_) => TypeLocation::TypeBound,\n+                    // is this case needed?\n+                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n+                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                    // is this case needed?\n+                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n+                    ast::TupleField(_) => TypeLocation::TupleField,\n+                    _ => return None,\n                 }\n-            }\n+            };\n+            Some(res)\n         };\n \n         // Infer the path kind\n         let kind = path.syntax().parent().and_then(|it| {\n             match_ast! {\n                 match it {\n                     ast::PathType(it) => {\n-                        let ascription = fetch_ascription(it.syntax().parent());\n+                        let location = type_location(it.syntax().parent());\n                         Some(PathKind::Type {\n-                            in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind())),\n-                            ascription,\n+                            location: location.unwrap_or(TypeLocation::Other),\n                         })\n                     },\n                     ast::PathExpr(it) => {\n@@ -1292,7 +1296,12 @@ impl<'a> CompletionContext<'a> {\n                         let parent = it.syntax().parent();\n                         match parent.as_ref().map(|it| it.kind()) {\n                             Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n-                            Some(SyntaxKind::MACRO_TYPE) => Some(PathKind::Type { in_tuple_struct: false, ascription: None }),\n+                            Some(SyntaxKind::MACRO_TYPE) => {\n+                                let location = type_location(parent.unwrap().parent());\n+                                Some(PathKind::Type {\n+                                    location: location.unwrap_or(TypeLocation::Other),\n+                                })\n+                            },\n                             Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n                             Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n                                 Some(it) => match_ast! {\n@@ -1501,15 +1510,14 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n     }\n }\n \n-fn find_in_original_file<N: AstNode>(x: Option<N>, original_file: &SyntaxNode) -> Option<N> {\n-    fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n-        let range = syntax.text_range().intersect(range)?;\n-        syntax.covering_element(range).ancestors().find_map(N::cast)\n-    }\n-    x.map(|e| e.syntax().text_range()).and_then(|r| find_node_with_range(original_file, r))\n+/// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n+fn find_opt_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: Option<N>) -> Option<N> {\n+    find_node_in_file(syntax, &node?)\n }\n \n /// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n     let syntax_range = syntax.text_range();\n     let range = node.syntax().text_range();\n@@ -1528,11 +1536,21 @@ fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> O\n         return None;\n     }\n     let range = TextRange::new(range.start(), end);\n-    // our inserted ident could cause `range` to be go outside of the original syntax, so cap it\n+    // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n     let intersection = range.intersect(syntax_range)?;\n     syntax.covering_element(intersection).ancestors().find_map(N::cast)\n }\n \n+/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n+/// for the offset introduced by the fake ident..\n+/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n+fn find_opt_node_in_file_compensated<N: AstNode>(\n+    syntax: &SyntaxNode,\n+    node: Option<N>,\n+) -> Option<N> {\n+    find_node_in_file_compensated(syntax, &node?)\n+}\n+\n fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     if let Some(qual) = path.qualifier() {\n         return Some((qual, false));"}, {"sha": "9efb42c4de75813836f739612513d53a09343118", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f201a40492fb245d95e4bcbc543f36d7b43645b3/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=f201a40492fb245d95e4bcbc543f36d7b43645b3", "patch": "@@ -4,103 +4,16 @@\n //! This means we for example expand a NameRef token to its outermost Path node, as semantically these act in the same location\n //! and the completions usually query for path specific things on the Path context instead. This simplifies some location handling.\n \n-use hir::Semantics;\n-use ide_db::RootDatabase;\n use syntax::{\n     ast::{self, HasLoopBody},\n     match_ast, AstNode, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextSize,\n+    SyntaxNode, SyntaxToken,\n };\n \n #[cfg(test)]\n use crate::tests::check_pattern_is_applicable;\n \n-/// Direct parent \"thing\" of what we are currently completing.\n-///\n-/// This may contain nodes of the fake file as well as the original, comments on the variants specify\n-/// from which file the nodes are.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum ImmediateLocation {\n-    TypeBound,\n-    // Only set from a type arg\n-    /// Original file ast node\n-    GenericArgList(ast::GenericArgList),\n-}\n-\n-pub(crate) fn determine_location(\n-    sema: &Semantics<RootDatabase>,\n-    original_file: &SyntaxNode,\n-    offset: TextSize,\n-    name_like: &ast::NameLike,\n-) -> Option<ImmediateLocation> {\n-    let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => maximize_name_ref(name_ref),\n-        ast::NameLike::Name(name) => name.syntax().clone(),\n-        ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n-    };\n-\n-    match_ast! {\n-        match node {\n-            ast::TypeBoundList(_it) => return Some(ImmediateLocation::TypeBound),\n-            _ => (),\n-        }\n-    };\n-\n-    let parent = match node.parent() {\n-        Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n-            // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n-            // This is usually fine as the node expansion code above already accounts for that with\n-            // the ancestors call, but there is one exception to this which is that when an attribute\n-            // precedes it the code above will not walk the Path to the parent MacroCall as their ranges differ.\n-            // FIXME path expr and statement have a similar problem\n-            Some(call)\n-                if call.excl_token().is_none()\n-                    && call.token_tree().is_none()\n-                    && call.semicolon_token().is_none() =>\n-            {\n-                call.syntax().parent()?\n-            }\n-            _ => parent,\n-        },\n-        // SourceFile\n-        None => return None,\n-    };\n-\n-    let res = match_ast! {\n-        match parent {\n-            ast::TypeBound(_) => ImmediateLocation::TypeBound,\n-            ast::TypeBoundList(_) => ImmediateLocation::TypeBound,\n-            ast::GenericArgList(_) => sema\n-                .find_node_at_offset_with_macros(original_file, offset)\n-                .map(ImmediateLocation::GenericArgList)?,\n-            _ => return None,\n-        }\n-    };\n-    Some(res)\n-}\n-\n-/// Maximize a nameref to its enclosing path if its the last segment of said path.\n-/// That is, when completing a [`NameRef`] we actually handle it as the path it is part of when determining\n-/// its location.\n-fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n-    if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n-        let p = segment.parent_path();\n-        if p.parent_path().is_none() {\n-            // Get rid of PathExpr, PathType, etc...\n-            let path = p\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.text_range() == p.syntax().text_range())\n-                .last();\n-            if let Some(it) = path {\n-                return it;\n-            }\n-        }\n-    }\n-    name_ref.syntax().clone()\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(previous_non_trivia_token)\n }"}]}