{"sha": "fcf1a57cea9d608190ace07f90b38164b3d9c017", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZjFhNTdjZWE5ZDYwODE5MGFjZTA3ZjkwYjM4MTY0YjNkOWMwMTc=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-23T21:43:16Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-02-02T14:08:51Z"}, "message": "Documenting libcore/char.rs", "tree": {"sha": "19c1957c05d94e5db3ca5416cf5674f519f03790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19c1957c05d94e5db3ca5416cf5674f519f03790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcf1a57cea9d608190ace07f90b38164b3d9c017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf1a57cea9d608190ace07f90b38164b3d9c017", "html_url": "https://github.com/rust-lang/rust/commit/fcf1a57cea9d608190ace07f90b38164b3d9c017", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcf1a57cea9d608190ace07f90b38164b3d9c017/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4b9674c26c1de07a2042cb68e6a062d7184cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "html_url": "https://github.com/rust-lang/rust/commit/ca4b9674c26c1de07a2042cb68e6a062d7184cef"}], "stats": {"total": 194, "additions": 174, "deletions": 20}, "files": [{"sha": "70a42900553aacdf3853ea2e13339e9c4df1cd31", "filename": "src/libcore/char.rs", "status": "modified", "additions": 174, "deletions": 20, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/fcf1a57cea9d608190ace07f90b38164b3d9c017/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf1a57cea9d608190ace07f90b38164b3d9c017/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=fcf1a57cea9d608190ace07f90b38164b3d9c017", "patch": "@@ -67,7 +67,25 @@ static MAX_THREE_B: u32 =  0x10000u32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n-/// Converts from `u32` to a `char`\n+/// Converts a `u32` to an `Option<char>`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(10084); // produces `Some(\u2764)`\n+/// assert_eq!(c, Some('\u2764'));\n+/// ```\n+///\n+/// An invalid character:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let none = char::from_u32(1114112);\n+/// assert_eq!(none, None);\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n@@ -79,8 +97,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n     }\n }\n \n-///\n-/// Converts a number to the character representing it\n+/// Converts a number to the character representing it.\n ///\n /// # Return value\n ///\n@@ -91,6 +108,15 @@ pub fn from_u32(i: u32) -> Option<char> {\n ///\n /// Panics if given an `radix` > 36.\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(4, 10);\n+///\n+/// assert_eq!(c, '4')\n+/// ```\n #[inline]\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n@@ -126,6 +152,16 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n@@ -141,16 +177,53 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(1, c.to_digit(10));\n+    ///\n+    /// assert_eq!(15, 'f'.to_digit(16));\n+    /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n-    /// Returns an iterator that yields the hexadecimal Unicode escape\n-    /// of a character, as `char`s.\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n+    ///\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}` where `NNNN` is the\n+    /// shortest hexadecimal representation of the code point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n     ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n-    /// where `NNNN` is the shortest hexadecimal representation of the code\n-    /// point.\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n@@ -166,32 +239,113 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, r\"\\\"\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-8.\n+    /// Returns the number of bytes this character would need if encoded in UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-16.\n+    /// Returns the number of bytes this character would need if encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer,\n-    /// and then returns the number of bytes written.\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n+    /// of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n-    /// and then returns the number of `u16`s written.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n+    /// number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes one byte to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }"}]}