{"sha": "9e605ef80f05fbaec22677e633971096675f2650", "node_id": "C_kwDOAAsO6NoAKDllNjA1ZWY4MGYwNWZiYWVjMjI2NzdlNjMzOTcxMDk2Njc1ZjI2NTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T08:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T08:46:42Z"}, "message": "Auto merge of #8443 - Jarcho:match_cfg_arm, r=flip1995\n\nDon't lint `match` expressions with `cfg`ed arms\n\nSomehow there are no open issues related to this for any of the affected lints. At least none that I could fine from a quick search.\n\nchangelog: Don't lint `match` expressions with `cfg`ed arms in many cases", "tree": {"sha": "afac001a52a2e6f9520ee1609a234ef54d32fc09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afac001a52a2e6f9520ee1609a234ef54d32fc09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e605ef80f05fbaec22677e633971096675f2650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e605ef80f05fbaec22677e633971096675f2650", "html_url": "https://github.com/rust-lang/rust/commit/9e605ef80f05fbaec22677e633971096675f2650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e605ef80f05fbaec22677e633971096675f2650/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ee5e25d1096f142729ea44c1286e50823762e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ee5e25d1096f142729ea44c1286e50823762e8", "html_url": "https://github.com/rust-lang/rust/commit/29ee5e25d1096f142729ea44c1286e50823762e8"}, {"sha": "78345b4d099063e8f34dc4c7bd2a31670df838f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/78345b4d099063e8f34dc4c7bd2a31670df838f7", "html_url": "https://github.com/rust-lang/rust/commit/78345b4d099063e8f34dc4c7bd2a31670df838f7"}], "stats": {"total": 470, "additions": 314, "deletions": 156}, "files": [{"sha": "2e1f7646eb400b3924ff813738c90091205e139f", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -3,49 +3,52 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{higher, is_wild};\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n \n use super::MATCH_LIKE_MATCHES_MACRO;\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         let_pat,\n         let_expr,\n         if_then,\n         if_else: Some(if_else),\n     }) = higher::IfLet::hir(cx, expr)\n     {\n-        return find_matches_sugg(\n+        find_matches_sugg(\n             cx,\n             let_expr,\n             IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n             expr,\n             true,\n         );\n     }\n+}\n \n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'tcx>],\n+) -> bool {\n+    find_matches_sugg(\n+        cx,\n+        scrutinee,\n+        arms.iter().map(|arm| {\n+            (\n+                cx.tcx.hir().attrs(arm.hir_id),\n+                Some(arm.pat),\n+                arm.body,\n+                arm.guard.as_ref(),\n+            )\n+        }),\n+        e,\n+        false,\n+    )\n }\n \n /// Lint a `match` or `if let` for replacement by `matches!`"}, {"sha": "d11dda57e6fd94c2676a4ef1a0fc2d95bc4d8feb", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -1,96 +1,94 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n use rustc_lint::LateContext;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(arm.body);\n+        h.finish()\n+    };\n \n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n+    let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+        let min_index = usize::min(lindex, rindex);\n+        let max_index = usize::max(lindex, rindex);\n \n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n+        let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            if_chain! {\n+                if let Some(a_id) = path_to_local(a);\n+                if let Some(b_id) = path_to_local(b);\n+                let entry = match local_map.entry(a_id) {\n+                    Entry::Vacant(entry) => entry,\n+                    // check if using the same bindings as before\n+                    Entry::Occupied(entry) => return *entry.get() == b_id,\n+                };\n+                // the names technically don't have to match; this makes the lint more conservative\n+                if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n+                if pat_contains_local(lhs.pat, a_id);\n+                if pat_contains_local(rhs.pat, b_id);\n+                then {\n+                    entry.insert(b_id);\n+                    true\n+                } else {\n+                    false\n                 }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+            }\n         };\n+        // Arms with a guard are ignored, those can\u2019t always be merged together\n+        // This is also the case for arms in-between each there is an arm with a guard\n+        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+            && SpanlessEq::new(cx)\n+                .expr_fallback(eq_fallback)\n+                .eq_expr(lhs.body, rhs.body)\n+            // these checks could be removed to allow unused bindings\n+            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+    };\n \n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n+    let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+    for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_SAME_ARMS,\n+            j.body.span,\n+            \"this `match` has identical arm bodies\",\n+            |diag| {\n+                diag.span_note(i.body.span, \"same as this\");\n \n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n+                // Note: this does not use `span_suggestion` on purpose:\n+                // there is no clean way\n+                // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                // makes an even more confusing error message. Also in order not to make up a\n+                // span for the whole pattern, the suggestion is only shown when there is only\n+                // one pattern. The user should know about `|` if they are already using it\u2026\n \n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+                let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n \n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n+                if let PatKind::Wild = j.pat.kind {\n+                    // if the last arm is _, then i could be integrated into _\n+                    // note that i.pat cannot be _, because that would mean that we're\n+                    // hiding all the subsequent arms, and rust won't compile\n+                    diag.span_note(\n+                        i.body.span,\n+                        &format!(\n+                            \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                            lhs\n+                        ),\n+                    );\n+                } else {\n+                    diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                        .help(\"...or consider changing the match arm bodies\");\n+                }\n+            },\n+        );\n     }\n }\n "}, {"sha": "39fe54648fbc754c37f5fba926d8ba9d45a54f45", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::{indent_of, snippet_block, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n use rustc_errors::Applicability;\n@@ -14,23 +14,6 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n         return;\n     }\n \n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n     let match_body = peel_blocks(arms[0].body);"}, {"sha": "92179eb6f0e60e5f7c8a90bdd1e6daa7b54d742c", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 122, "deletions": 22, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -1,8 +1,11 @@\n+use clippy_utils::source::{snippet_opt, walk_span_to_context};\n use clippy_utils::{meets_msrv, msrvs};\n-use rustc_hir::{Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, SpanData, SyntaxContext};\n \n mod infalliable_detructuring_match;\n mod match_as_ref;\n@@ -604,33 +607,39 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             return;\n         }\n \n-        redundant_pattern_match::check(cx, expr);\n+        if let ExprKind::Match(ex, arms, source) = expr.kind {\n+            if !contains_cfg_arm(cx, expr, ex, arms) {\n+                if source == MatchSource::Normal {\n+                    if !(meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO)\n+                        && match_like_matches::check_match(cx, expr, ex, arms))\n+                    {\n+                        match_same_arms::check(cx, arms);\n+                    }\n \n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !match_like_matches::check(cx, expr) {\n-                match_same_arms::check(cx, expr);\n+                    redundant_pattern_match::check_match(cx, expr, ex, arms);\n+                    single_match::check(cx, ex, arms, expr);\n+                    match_bool::check(cx, ex, arms, expr);\n+                    overlapping_arms::check(cx, ex, arms);\n+                    match_wild_enum::check(cx, ex, arms);\n+                    match_as_ref::check(cx, ex, arms, expr);\n+\n+                    if self.infallible_destructuring_match_linted {\n+                        self.infallible_destructuring_match_linted = false;\n+                    } else {\n+                        match_single_binding::check(cx, ex, arms, expr);\n+                    }\n+                }\n+                match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n             }\n-        } else {\n-            match_same_arms::check(cx, expr);\n-        }\n \n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            single_match::check(cx, ex, arms, expr);\n-            match_bool::check(cx, ex, arms, expr);\n-            overlapping_arms::check(cx, ex, arms);\n+            // These don't depend on a relationship between multiple arms\n             match_wild_err_arm::check(cx, ex, arms);\n-            match_wild_enum::check(cx, ex, arms);\n-            match_as_ref::check(cx, ex, arms, expr);\n             wild_in_or_pats::check(cx, arms);\n-\n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                match_single_binding::check(cx, ex, arms, expr);\n+        } else {\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n+                match_like_matches::check(cx, expr);\n             }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+            redundant_pattern_match::check(cx, expr);\n         }\n     }\n \n@@ -644,3 +653,94 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+/// Checks if there are any arms with a `#[cfg(..)]` attribute.\n+fn contains_cfg_arm(cx: &LateContext<'_>, e: &Expr<'_>, scrutinee: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    let Some(scrutinee_span) = walk_span_to_context(scrutinee.span, SyntaxContext::root()) else {\n+        // Shouldn't happen, but treat this as though a `cfg` attribute were found\n+        return true;\n+    };\n+\n+    let start = scrutinee_span.hi();\n+    let mut arm_spans = arms.iter().map(|arm| {\n+        let data = arm.span.data();\n+        (data.ctxt == SyntaxContext::root()).then(|| (data.lo, data.hi))\n+    });\n+    let end = e.span.hi();\n+\n+    // Walk through all the non-code space before each match arm. The space trailing the final arm is\n+    // handled after the `try_fold` e.g.\n+    //\n+    // match foo {\n+    // _________^-                      everything between the scrutinee and arm1\n+    //|    arm1 => (),\n+    //|---^___________^                 everything before arm2\n+    //|    #[cfg(feature = \"enabled\")]\n+    //|    arm2 => some_code(),\n+    //|---^____________________^        everything before arm3\n+    //|    // some comment about arm3\n+    //|    arm3 => some_code(),\n+    //|---^____________________^        everything after arm3\n+    //|    #[cfg(feature = \"disabled\")]\n+    //|    arm4 = some_code(),\n+    //|};\n+    //|^\n+    let found = arm_spans.try_fold(start, |start, range| {\n+        let Some((end, next_start)) = range else {\n+            // Shouldn't happen as macros can't expand to match arms, but treat this as though a `cfg` attribute were\n+            // found.\n+            return Err(());\n+        };\n+        let span = SpanData {\n+            lo: start,\n+            hi: end,\n+            ctxt: SyntaxContext::root(),\n+            parent: None,\n+        }\n+        .span();\n+        (!span_contains_cfg(cx, span)).then(|| next_start).ok_or(())\n+    });\n+    match found {\n+        Ok(start) => {\n+            let span = SpanData {\n+                lo: start,\n+                hi: end,\n+                ctxt: SyntaxContext::root(),\n+                parent: None,\n+            }\n+            .span();\n+            span_contains_cfg(cx, span)\n+        },\n+        Err(()) => true,\n+    }\n+}\n+\n+/// Checks if the given span contains a `#[cfg(..)]` attribute\n+fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n+    let Some(snip) = snippet_opt(cx, s) else {\n+        // Assume true. This would require either an invalid span, or one which crosses file boundaries.\n+        return true;\n+    };\n+    let mut pos = 0usize;\n+    let mut iter = tokenize(&snip).map(|t| {\n+        let start = pos;\n+        pos += t.len;\n+        (t.kind, start..pos)\n+    });\n+\n+    // Search for the token sequence [`#`, `[`, `cfg`]\n+    while iter.any(|(t, _)| matches!(t, TokenKind::Pound)) {\n+        let mut iter = iter.by_ref().skip_while(|(t, _)| {\n+            matches!(\n+                t,\n+                TokenKind::Whitespace | TokenKind::LineComment { .. } | TokenKind::BlockComment { .. }\n+            )\n+        });\n+        if matches!(iter.next(), Some((TokenKind::OpenBracket, _)))\n+            && matches!(iter.next(), Some((TokenKind::Ident, range)) if &snip[range.clone()] == \"cfg\")\n+        {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "c491b2775d8476ccaef59d6c41dc336763408682", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -12,13 +12,13 @@ use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{\n     intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+    Arm, Block, Expr, ExprKind, LangItem, Node, Pat, PatKind, QPath, UnOp,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n \n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         if_else,\n         let_pat,\n@@ -27,11 +27,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }) = higher::IfLet::hir(cx, expr)\n     {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-    }\n-    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-        find_sugg_for_match(cx, expr, op, arms);\n-    }\n-    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n     }\n }\n@@ -304,7 +300,7 @@ fn find_sugg_for_if_let<'tcx>(\n     );\n }\n \n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n "}, {"sha": "ddfa1e741ada439e347229fe090e7ad508a9dffe", "filename": "tests/ui/match_as_ref.fixed", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_as_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_as_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_as_ref.fixed?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -32,4 +32,12 @@ mod issue4437 {\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(ref x) if *x > 50 => None,\n+        Some(ref x) => Some(x),\n+        None => None,\n+    };\n+}"}, {"sha": "025d475ae13dba80d01d37a0c4f73689fd68d6cb", "filename": "tests/ui/match_as_ref.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_as_ref.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -41,4 +41,12 @@ mod issue4437 {\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(ref x) if *x > 50 => None,\n+        Some(ref x) => Some(x),\n+        None => None,\n+    };\n+}"}, {"sha": "bcc999a49428daf281a2317026c5ef83da37a2b5", "filename": "tests/ui/match_bool.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_bool.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -50,6 +50,14 @@ fn match_bool() {\n         11..=20 => 2,\n         _ => 3,\n     };\n+\n+    // Don't lint\n+    let _ = match test {\n+        #[cfg(feature = \"foo\")]\n+        true if option == 5 => 10,\n+        true => 0,\n+        false => 1,\n+    };\n }\n \n fn main() {}"}, {"sha": "36f233f33460720759355d78d1c0cf26623d7713", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -146,4 +146,19 @@ fn main() {\n         let _res = matches!(&val, &Some(ref _a));\n         fun(val);\n     }\n+\n+    {\n+        enum E {\n+            A,\n+            B,\n+            C,\n+        }\n+\n+        let _ = match E::A {\n+            E::B => true,\n+            #[cfg(feature = \"foo\")]\n+            E::A => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "750f69fa5088f6fa45898030bfca0d56ee486a81", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -181,4 +181,19 @@ fn main() {\n         };\n         fun(val);\n     }\n+\n+    {\n+        enum E {\n+            A,\n+            B,\n+            C,\n+        }\n+\n+        let _ = match E::A {\n+            E::B => true,\n+            #[cfg(feature = \"foo\")]\n+            E::A => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "67e1d518483c2cf6b61ca152b368506619cc9008", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -166,4 +166,12 @@ fn match_expr_like_matches_macro_priority() {\n     };\n }\n \n-fn main() {}\n+fn main() {\n+    let _ = match Some(0) {\n+        Some(0) => 0,\n+        Some(1) => 1,\n+        #[cfg(feature = \"foo\")]\n+        Some(2) => 2,\n+        _ => 1,\n+    };\n+}"}, {"sha": "b8dc8179f7d7d1c841a5df8475ebed31a52f0014", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -106,10 +106,8 @@ fn main() {\n         0 => println!(\"Array index start\"),\n         _ => println!(\"Not an array index start\"),\n     }\n-    // False negative\n+\n+    // Lint\n     let x = 1;\n-    match x {\n-        // =>\n-        _ => println!(\"Not an array index start\"),\n-    }\n+    println!(\"Not an array index start\");\n }"}, {"sha": "fe63dcd63f2bb97d5fcd69f62f3b4d74f5a0c037", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -118,7 +118,8 @@ fn main() {\n         0 => println!(\"Array index start\"),\n         _ => println!(\"Not an array index start\"),\n     }\n-    // False negative\n+\n+    // Lint\n     let x = 1;\n     match x {\n         // =>"}, {"sha": "d939291f53c40758821783da7bdbc38255ff8542", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -167,5 +167,14 @@ LL +             unwrapped\n LL ~         })\n    |\n \n-error: aborting due to 11 previous errors\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:124:5\n+   |\n+LL | /     match x {\n+LL | |         // =>\n+LL | |         _ => println!(\"Not an array index start\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"Not an array index start\");`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "dd148edf5292d0c0e130d75f4736abbbce9a8404", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e605ef80f05fbaec22677e633971096675f2650/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=9e605ef80f05fbaec22677e633971096675f2650", "patch": "@@ -234,4 +234,12 @@ macro_rules! single_match {\n \n fn main() {\n     single_match!(5);\n+\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(10) => 11,\n+        Some(x) => x,\n+        _ => 0,\n+    };\n }"}]}