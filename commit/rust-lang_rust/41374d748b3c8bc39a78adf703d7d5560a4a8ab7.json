{"sha": "41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMzc0ZDc0OGIzYzhiYzM5YTc4YWRmNzAzZDdkNTU2MGE0YThhYjc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-03T19:56:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-05T19:07:22Z"}, "message": "rustc_metadata: Move some code from `impl CrateMetadataRef` to `impl CrateMetadata`", "tree": {"sha": "e70945e1215faa721b8440ad7d2df360c1a7a2a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e70945e1215faa721b8440ad7d2df360c1a7a2a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "html_url": "https://github.com/rust-lang/rust/commit/41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41374d748b3c8bc39a78adf703d7d5560a4a8ab7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1df945a610bb6eddfe0dc5ff033722fa611ef09", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1df945a610bb6eddfe0dc5ff033722fa611ef09", "html_url": "https://github.com/rust-lang/rust/commit/c1df945a610bb6eddfe0dc5ff033722fa611ef09"}], "stats": {"total": 176, "additions": 87, "deletions": 89}, "files": [{"sha": "e60ae5b6c25ee311206613cd66109745dd8f96d1", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 87, "deletions": 89, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/41374d748b3c8bc39a78adf703d7d5560a4a8ab7/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41374d748b3c8bc39a78adf703d7d5560a4a8ab7/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "patch": "@@ -559,51 +559,6 @@ impl CrateRoot<'_> {\n     }\n }\n \n-impl CrateMetadata {\n-    crate fn new(\n-        sess: &Session,\n-        blob: MetadataBlob,\n-        root: CrateRoot<'static>,\n-        raw_proc_macros: Option<&'static [ProcMacro]>,\n-        cnum: CrateNum,\n-        cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n-        source: CrateSource,\n-        private_dep: bool,\n-        host_hash: Option<Svh>,\n-    ) -> CrateMetadata {\n-        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n-            root.def_path_table.decode((&blob, sess))\n-        });\n-        let trait_impls = root\n-            .impls\n-            .decode((&blob, sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-            .collect();\n-        let alloc_decoding_state =\n-            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n-        CrateMetadata {\n-            blob,\n-            root,\n-            def_path_table,\n-            trait_impls,\n-            raw_proc_macros,\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-            cnum,\n-            cnum_map,\n-            dependencies,\n-            dep_kind: Lock::new(dep_kind),\n-            source,\n-            private_dep,\n-            host_hash,\n-            extern_crate: Lock::new(None),\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n@@ -625,10 +580,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn local_def_id(&self, index: DefIndex) -> DefId {\n-        DefId { krate: self.cnum, index }\n-    }\n-\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -1194,18 +1145,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .collect()\n     }\n \n-    // Translate a DefId from the current compilation environment to a DefId\n-    // for an external crate.\n-    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n-        for (local, &global) in self.cnum_map.iter_enumerated() {\n-            if global == did.krate {\n-                return Some(DefId { krate: local, index: did.index });\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -1412,11 +1351,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n-    #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_table.def_path_hash(index)\n-    }\n-\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1519,33 +1453,52 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .collect()\n         })\n     }\n+}\n \n-    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n-    /// method is cached in the `dep_node_index` field.\n-    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n-        let mut dep_node_index = self.dep_node_index.load();\n-\n-        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n-            // We have not cached the DepNodeIndex for this upstream crate yet,\n-            // so use the dep-graph to find it out and cache it.\n-            // Note that multiple threads can enter this block concurrently.\n-            // That is fine because the DepNodeIndex remains constant\n-            // throughout the whole compilation session, and multiple stores\n-            // would always write the same value.\n-\n-            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n-\n-            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n-            assert!(dep_node_index != DepNodeIndex::INVALID);\n-            self.dep_node_index.store(dep_node_index);\n+impl CrateMetadata {\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root\n+            .impls\n+            .decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+            .collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n         }\n-\n-        dep_node_index\n     }\n-}\n \n-impl CrateMetadata {\n     crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n         self.dependencies.borrow()\n     }\n@@ -1618,6 +1571,51 @@ impl CrateMetadata {\n     crate fn hash(&self) -> Svh {\n         self.root.hash\n     }\n+\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId { krate: self.cnum, index }\n+    }\n+\n+    // Translate a DefId from the current compilation environment to a DefId\n+    // for an external crate.\n+    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n+        for (local, &global) in self.cnum_map.iter_enumerated() {\n+            if global == did.krate {\n+                return Some(DefId { krate: local, index: did.index });\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+        self.def_path_table.def_path_hash(index)\n+    }\n+\n+    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n+    /// method is cached in the `dep_node_index` field.\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+        let mut dep_node_index = self.dep_node_index.load();\n+\n+        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n+            // We have not cached the DepNodeIndex for this upstream crate yet,\n+            // so use the dep-graph to find it out and cache it.\n+            // Note that multiple threads can enter this block concurrently.\n+            // That is fine because the DepNodeIndex remains constant\n+            // throughout the whole compilation session, and multiple stores\n+            // would always write the same value.\n+\n+            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n+\n+            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n+            assert!(dep_node_index != DepNodeIndex::INVALID);\n+            self.dep_node_index.store(dep_node_index);\n+        }\n+\n+        dep_node_index\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}]}