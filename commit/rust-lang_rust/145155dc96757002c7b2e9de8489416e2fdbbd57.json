{"sha": "145155dc96757002c7b2e9de8489416e2fdbbd57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NTE1NWRjOTY3NTcwMDJjN2IyZTlkZTg0ODk0MTZlMmZkYmJkNTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-22T16:23:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:19Z"}, "message": "parameterize `BitVector` and `BitMatrix` by their index types", "tree": {"sha": "1f17f8184ace880aad66fb6d9d4562a1a48fe652", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f17f8184ace880aad66fb6d9d4562a1a48fe652"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/145155dc96757002c7b2e9de8489416e2fdbbd57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/145155dc96757002c7b2e9de8489416e2fdbbd57", "html_url": "https://github.com/rust-lang/rust/commit/145155dc96757002c7b2e9de8489416e2fdbbd57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/145155dc96757002c7b2e9de8489416e2fdbbd57/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a54401ebccc5497497b669a1c48fabdf7351d7b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a54401ebccc5497497b669a1c48fabdf7351d7b2", "html_url": "https://github.com/rust-lang/rust/commit/a54401ebccc5497497b669a1c48fabdf7351d7b2"}], "stats": {"total": 215, "additions": 119, "deletions": 96}, "files": [{"sha": "87ba3420eecebbad605aed0e4d6bd5b79b35fa24", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n \n use super::*;\n \n@@ -33,7 +32,7 @@ use super::*;\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector,\n+    visited: BitVector<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n }\n \n@@ -58,7 +57,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n \n     fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n         while let Some(idx) = self.worklist.pop() {\n-            if !self.visited.insert(idx.index()) {\n+            if !self.visited.insert(idx) {\n                 continue;\n             }\n \n@@ -107,7 +106,7 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector,\n+    visited: BitVector<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n@@ -123,7 +122,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         let data = &po.mir[root];\n \n         if let Some(ref term) = data.terminator {\n-            po.visited.insert(root.index());\n+            po.visited.insert(root);\n             po.visit_stack.push((root, term.successors()));\n             po.traverse_successor();\n         }\n@@ -190,8 +189,8 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n                 break;\n             };\n \n-            if self.visited.insert(bb.index()) {\n-                if let Some(ref term) = self.mir[bb].terminator {\n+            if self.visited.insert(bb) {\n+                if let Some(term) = &self.mir[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));\n                 }\n             }"}, {"sha": "fcde7f9bbc33d8c1cc3681aaf049f5256d4b373d", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -65,7 +65,7 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n     let mut has_variables = BitVector::new(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n-        has_variables.insert(decl.visibility_scope.index());\n+        has_variables.insert(decl.visibility_scope);\n     }\n \n     // Instantiate all scopes.\n@@ -79,7 +79,7 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n \n fn make_mir_scope(cx: &CodegenCx,\n                   mir: &Mir,\n-                  has_variables: &BitVector,\n+                  has_variables: &BitVector<SourceScope>,\n                   debug_context: &FunctionDebugContextData,\n                   scope: SourceScope,\n                   scopes: &mut IndexVec<SourceScope, MirDebugScope>) {\n@@ -102,7 +102,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         return;\n     };\n \n-    if !has_variables.contains(scope.index()) {\n+    if !has_variables.contains(scope) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n "}, {"sha": "e105baba8aa2e56f441123600b506068d28dc519", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n+pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -54,7 +54,7 @@ pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n     fx: &'mir FunctionCx<'a, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitVector,\n+    non_ssa_locals: BitVector<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n@@ -90,7 +90,7 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n \n     fn not_ssa(&mut self, local: mir::Local) {\n         debug!(\"marking {:?} as non-SSA\", local);\n-        self.non_ssa_locals.insert(local.index());\n+        self.non_ssa_locals.insert(local);\n     }\n \n     fn assign(&mut self, local: mir::Local, location: Location) {"}, {"sha": "312939408c62cf0f9badab6166f6570383802120", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -268,7 +268,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n                 let debug_scope = fx.scopes[decl.visibility_scope];\n                 let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo;\n \n-                if !memory_locals.contains(local.index()) && !dbg {\n+                if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n                     return LocalRef::new_operand(bx.cx, layout);\n                 }\n@@ -291,7 +291,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n-                } else if memory_locals.contains(local.index()) {\n+                } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n                 } else {\n@@ -415,7 +415,7 @@ fn create_funclets<'a, 'tcx>(\n fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                             fx: &FunctionCx<'a, 'tcx>,\n                             scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n-                            memory_locals: &BitVector)\n+                            memory_locals: &BitVector<mir::Local>)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n@@ -487,7 +487,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n         }\n \n-        if arg_scope.is_none() && !memory_locals.contains(local.index()) {\n+        if arg_scope.is_none() && !memory_locals.contains(local) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare."}, {"sha": "dec10416bcb7d81f7f95a53858d678d3fc3bb4be", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -17,16 +17,18 @@ const WORD_BITS: usize = 128;\n \n /// A very simple BitVector type.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector {\n+pub struct BitVector<C: Idx> {\n     data: Vec<Word>,\n+    marker: PhantomData<C>,\n }\n \n-impl BitVector {\n+impl<C: Idx> BitVector<C> {\n     #[inline]\n-    pub fn new(num_bits: usize) -> BitVector {\n+    pub fn new(num_bits: usize) -> BitVector<C> {\n         let num_words = words(num_bits);\n         BitVector {\n             data: vec![0; num_words],\n+            marker: PhantomData,\n         }\n     }\n \n@@ -42,14 +44,14 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn contains(&self, bit: usize) -> bool {\n+    pub fn contains(&self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n     /// Returns true if the bit has changed.\n     #[inline]\n-    pub fn insert(&mut self, bit: usize) -> bool {\n+    pub fn insert(&mut self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n@@ -60,7 +62,7 @@ impl BitVector {\n \n     /// Returns true if the bit has changed.\n     #[inline]\n-    pub fn remove(&mut self, bit: usize) -> bool {\n+    pub fn remove(&mut self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n@@ -70,7 +72,7 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn merge(&mut self, all: &BitVector) -> bool {\n+    pub fn merge(&mut self, all: &BitVector<C>) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n@@ -84,7 +86,7 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn grow(&mut self, num_bits: usize) {\n+    pub fn grow(&mut self, num_bits: C) {\n         let num_words = words(num_bits);\n         if self.data.len() < num_words {\n             self.data.resize(num_words, 0)\n@@ -93,24 +95,26 @@ impl BitVector {\n \n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitVectorIter<'a> {\n+    pub fn iter<'a>(&'a self) -> BitVectorIter<'a, C> {\n         BitVectorIter {\n             iter: self.data.iter(),\n             current: 0,\n             idx: 0,\n+            marker: PhantomData,\n         }\n     }\n }\n \n-pub struct BitVectorIter<'a> {\n+pub struct BitVectorIter<'a, C: Idx> {\n     iter: ::std::slice::Iter<'a, Word>,\n     current: Word,\n     idx: usize,\n+    marker: PhantomData<C>\n }\n \n-impl<'a> Iterator for BitVectorIter<'a> {\n-    type Item = usize;\n-    fn next(&mut self) -> Option<usize> {\n+impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n+    type Item = C;\n+    fn next(&mut self) -> Option<C> {\n         while self.current == 0 {\n             self.current = if let Some(&i) = self.iter.next() {\n                 if i == 0 {\n@@ -128,7 +132,7 @@ impl<'a> Iterator for BitVectorIter<'a> {\n         self.current >>= offset;\n         self.current >>= 1; // shift otherwise overflows for 0b1000_0000_\u2026_0000\n         self.idx += offset + 1;\n-        return Some(self.idx - 1);\n+        return Some(C::new(self.idx - 1));\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -137,8 +141,8 @@ impl<'a> Iterator for BitVectorIter<'a> {\n     }\n }\n \n-impl FromIterator<bool> for BitVector {\n-    fn from_iter<I>(iter: I) -> BitVector\n+impl<C: Idx> FromIterator<bool> for BitVector<C> {\n+    fn from_iter<I>(iter: I) -> BitVector<C>\n     where\n         I: IntoIterator<Item = bool>,\n     {\n@@ -150,10 +154,10 @@ impl FromIterator<bool> for BitVector {\n         let mut bv = BitVector::new(len);\n         for (idx, val) in iter.enumerate() {\n             if idx > len {\n-                bv.grow(idx);\n+                bv.grow(C::new(idx));\n             }\n             if val {\n-                bv.insert(idx);\n+                bv.insert(C::new(idx));\n             }\n         }\n \n@@ -165,25 +169,28 @@ impl FromIterator<bool> for BitVector {\n /// one gigantic bitvector. In other words, it is as if you have\n /// `rows` bitvectors, each of length `columns`.\n #[derive(Clone, Debug)]\n-pub struct BitMatrix {\n+pub struct BitMatrix<R: Idx, C: Idx> {\n     columns: usize,\n     vector: Vec<Word>,\n+    phantom: PhantomData<(R, C)>,\n }\n \n-impl BitMatrix {\n+impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: usize, columns: usize) -> BitMatrix {\n+    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n         let words_per_row = words(columns);\n         BitMatrix {\n             columns,\n             vector: vec![0; rows * words_per_row],\n+            phantom: PhantomData,\n         }\n     }\n \n     /// The range of bits for a given row.\n-    fn range(&self, row: usize) -> (usize, usize) {\n+    fn range(&self, row: R) -> (usize, usize) {\n+        let row = row.index();\n         let words_per_row = words(self.columns);\n         let start = row * words_per_row;\n         (start, start + words_per_row)\n@@ -193,7 +200,7 @@ impl BitMatrix {\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn add(&mut self, row: usize, column: usize) -> bool {\n+    pub fn add(&mut self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n         let vector = &mut self.vector[..];\n@@ -207,7 +214,7 @@ impl BitMatrix {\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n-    pub fn contains(&self, row: usize, column: usize) -> bool {\n+    pub fn contains(&self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n         (self.vector[start + word] & mask) != 0\n@@ -217,7 +224,7 @@ impl BitMatrix {\n     /// is an O(n) operation where `n` is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n-    pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n+    pub fn intersection(&self, a: R, b: R) -> Vec<C> {\n         let (a_start, a_end) = self.range(a);\n         let (b_start, b_end) = self.range(b);\n         let mut result = Vec::with_capacity(self.columns);\n@@ -228,7 +235,7 @@ impl BitMatrix {\n                     break;\n                 }\n                 if v & 0x1 != 0 {\n-                    result.push(base * WORD_BITS + bit);\n+                    result.push(C::new(base * WORD_BITS + bit));\n                 }\n                 v >>= 1;\n             }\n@@ -243,7 +250,7 @@ impl BitMatrix {\n     /// you have an edge `write -> read`, because in that case\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n-    pub fn merge(&mut self, read: usize, write: usize) -> bool {\n+    pub fn merge(&mut self, read: R, write: R) -> bool {\n         let (read_start, read_end) = self.range(read);\n         let (write_start, write_end) = self.range(write);\n         let vector = &mut self.vector[..];\n@@ -259,12 +266,13 @@ impl BitMatrix {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: usize) -> BitVectorIter<'a> {\n+    pub fn iter<'a>(&'a self, row: R) -> BitVectorIter<'a, C> {\n         let (start, end) = self.range(row);\n         BitVectorIter {\n             iter: self.vector[start..end].iter(),\n             current: 0,\n             idx: 0,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -278,8 +286,7 @@ where\n     C: Idx,\n {\n     columns: usize,\n-    vector: IndexVec<R, BitVector>,\n-    marker: PhantomData<C>,\n+    vector: IndexVec<R, BitVector<C>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -288,7 +295,6 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         Self {\n             columns,\n             vector: IndexVec::new(),\n-            marker: PhantomData,\n         }\n     }\n \n@@ -300,15 +306,15 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         let columns = self.columns;\n         self.vector\n             .ensure_contains_elem(row, || BitVector::new(columns));\n-        self.vector[row].insert(column.index())\n+        self.vector[row].insert(column)\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector.get(row).map_or(false, |r| r.contains(column.index()))\n+        self.vector.get(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -331,7 +337,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &BitVector) -> bool {\n+    pub fn merge_into(&mut self, into: R, from: &BitVector<C>) -> bool {\n         let columns = self.columns;\n         self.vector\n             .ensure_contains_elem(into, || BitVector::new(columns));\n@@ -346,22 +352,27 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector.get(row).into_iter().flat_map(|r| r.iter().map(|n| C::new(n)))\n+        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector)> + 'a {\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector<C>)> + 'a {\n         self.vector.iter_enumerated()\n     }\n+\n+    pub fn row(&self, row: R) -> Option<&BitVector<C>> {\n+        self.vector.get(row)\n+    }\n }\n \n #[inline]\n-fn words(elements: usize) -> usize {\n-    (elements + WORD_BITS - 1) / WORD_BITS\n+fn words<C: Idx>(elements: C) -> usize {\n+    (elements.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_mask(index: usize) -> (usize, Word) {\n+fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n+    let index = index.index();\n     let word = index / WORD_BITS;\n     let mask = 1 << (index % WORD_BITS);\n     (word, mask)"}, {"sha": "dbfc09116bbaa281bbe5c076ecc21bdf7422c80f", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -348,7 +348,7 @@ where\n {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitVector,\n+    visited: BitVector<usize>,\n     direction: Direction,\n }\n "}, {"sha": "c358f2f852e18bb3e88e1a51caf6a69b5b30b975", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -25,7 +25,13 @@ use rustc_serialize as serialize;\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn new(idx: usize) -> Self;\n+\n     fn index(self) -> usize;\n+\n+    fn increment_by(&mut self, amount: usize) {\n+        let v = self.index() + amount;\n+        *self = Self::new(v);\n+    }\n }\n \n impl Idx for usize {\n@@ -504,8 +510,8 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn swap(&mut self, a: usize, b: usize) {\n-        self.raw.swap(a, b)\n+    pub fn swap(&mut self, a: I, b: I) {\n+        self.raw.swap(a.index(), b.index())\n     }\n \n     #[inline]"}, {"sha": "a8124fb7c5b622bdbed52ca8f2434598f178fcbd", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -39,7 +39,7 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n     // are added with new elements. Perhaps better would be to ask the\n     // user for a batch of edges to minimize this effect, but I\n     // already wrote the code this way. :P -nmatsakis\n-    closure: Lock<Option<BitMatrix>>,\n+    closure: Lock<Option<BitMatrix<usize, usize>>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n@@ -354,7 +354,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     fn with_closure<OP, R>(&self, op: OP) -> R\n-        where OP: FnOnce(&BitMatrix) -> R\n+        where OP: FnOnce(&BitMatrix<usize, usize>) -> R\n     {\n         let mut closure_cell = self.closure.borrow_mut();\n         let mut closure = closure_cell.take();\n@@ -366,7 +366,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         result\n     }\n \n-    fn compute_closure(&self) -> BitMatrix {\n+    fn compute_closure(&self) -> BitMatrix<usize, usize> {\n         let mut matrix = BitMatrix::new(self.elements.len(),\n                                         self.elements.len());\n         let mut changed = true;\n@@ -396,7 +396,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n /// - Input: `[a, b, x]`. Output: `[a, x]`.\n /// - Input: `[b, a, x]`. Output: `[b, a, x]`.\n /// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n-fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n+fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n     let mut i = 0;\n     while i < candidates.len() {\n         let candidate_i = candidates[i];"}, {"sha": "4db5267cbd439390356b32513b97dcb9cdf3d4d0", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -222,12 +222,12 @@ impl<N: Idx> RegionValues<N> {\n     /// Iterates through each row and the accompanying bit set.\n     pub fn iter_enumerated<'a>(\n         &'a self\n-    ) -> impl Iterator<Item = (N, &'a BitVector)> + 'a {\n+    ) -> impl Iterator<Item = (N, &'a BitVector<RegionElementIndex>)> + 'a {\n         self.matrix.iter_enumerated()\n     }\n \n     /// Merge a row, `from`, originating in another `RegionValues` into the `into` row.\n-    pub fn merge_into(&mut self, into: N, from: &BitVector) -> bool {\n+    pub fn merge_into(&mut self, into: N, from: &BitVector<RegionElementIndex>) -> bool {\n         self.matrix.merge_into(into, from)\n     }\n "}, {"sha": "5de316a66403301ab18a43c21d08e479a17c005a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -487,7 +487,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitVector,\n+        variants: BitVector<usize>,\n     },\n \n     // test the branches of enum"}, {"sha": "3ff209c872fac72f04c6763e789fbe90efa76307", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitVector)\n+                                        variants: &mut BitVector<usize>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {"}, {"sha": "5f05783b15ccedca6a87c605a8e0facb095297f8", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -231,7 +231,7 @@ pub struct InliningMap<'tcx> {\n \n     // Contains one bit per mono item in the `targets` field. That bit\n     // is true if that mono item needs to be inlined into every CGU.\n-    inlines: BitVector,\n+    inlines: BitVector<usize>,\n }\n \n impl<'tcx> InliningMap<'tcx> {"}, {"sha": "6a9258fe2c918eb5d4ae9b1574fdb8420c819ac0", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -292,8 +292,10 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n     DerefArgVisitor.visit_mir(mir);\n }\n \n-fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n-                            mir: &mut Mir<'tcx>) -> Local {\n+fn replace_result_variable<'tcx>(\n+    ret_ty: Ty<'tcx>,\n+    mir: &mut Mir<'tcx>,\n+) -> Local {\n     let source_info = source_info(mir);\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n@@ -306,7 +308,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     };\n     let new_ret_local = Local::new(mir.local_decls.len());\n     mir.local_decls.push(new_ret);\n-    mir.local_decls.swap(0, new_ret_local.index());\n+    mir.local_decls.swap(RETURN_PLACE, new_ret_local);\n \n     RenameLocalVisitor {\n         from: RETURN_PLACE,"}, {"sha": "8a12a604ef2023156870e908ddcf9e3447019959", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -116,7 +116,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     local_qualif: IndexVec<Local, Option<Qualif>>,\n     qualif: Qualif,\n-    const_fn_arg_vars: BitVector,\n+    const_fn_arg_vars: BitVector<Local>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                         // Make sure there are no extra unassigned variables.\n                         self.qualif = Qualif::NOT_CONST;\n                         for index in mir.vars_iter() {\n-                            if !self.const_fn_arg_vars.contains(index.index()) {\n+                            if !self.const_fn_arg_vars.contains(index) {\n                                 debug!(\"unassigned variable {:?}\", index);\n                                 self.assign(&Place::Local(index), Location {\n                                     block: bb,\n@@ -1021,7 +1021,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n         // Check the allowed const fn argument forms.\n         if let (Mode::ConstFn, &Place::Local(index)) = (self.mode, dest) {\n             if self.mir.local_kind(index) == LocalKind::Var &&\n-               self.const_fn_arg_vars.insert(index.index()) &&\n+               self.const_fn_arg_vars.insert(index) &&\n                !self.tcx.sess.features_untracked().const_let {\n \n                 // Direct use of an argument is permitted."}, {"sha": "a7ef93eaec6b97c6fd814b996b692c3af7bdecc0", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -11,7 +11,6 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n \n@@ -42,9 +41,12 @@ impl MirPass for RemoveNoopLandingPads {\n }\n \n impl RemoveNoopLandingPads {\n-    fn is_nop_landing_pad(&self, bb: BasicBlock, mir: &Mir, nop_landing_pads: &BitVector)\n-                          -> bool\n-    {\n+    fn is_nop_landing_pad(\n+        &self,\n+        bb: BasicBlock,\n+        mir: &Mir,\n+        nop_landing_pads: &BitVector<BasicBlock>,\n+    ) -> bool {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n                 StatementKind::ReadForMatch(_) |\n@@ -79,8 +81,8 @@ impl RemoveNoopLandingPads {\n             TerminatorKind::SwitchInt { .. } |\n             TerminatorKind::FalseEdges { .. } |\n             TerminatorKind::FalseUnwind { .. } => {\n-                terminator.successors().all(|succ| {\n-                    nop_landing_pads.contains(succ.index())\n+                terminator.successors().all(|&succ| {\n+                    nop_landing_pads.contains(succ)\n                 })\n             },\n             TerminatorKind::GeneratorDrop |\n@@ -117,7 +119,7 @@ impl RemoveNoopLandingPads {\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n             for target in mir[bb].terminator_mut().successors_mut() {\n-                if *target != resume_block && nop_landing_pads.contains(target.index()) {\n+                if *target != resume_block && nop_landing_pads.contains(*target) {\n                     debug!(\"    folding noop jump to {:?} to resume block\", target);\n                     *target = resume_block;\n                     jumps_folded += 1;\n@@ -138,7 +140,7 @@ impl RemoveNoopLandingPads {\n \n             let is_nop_landing_pad = self.is_nop_landing_pad(bb, mir, &nop_landing_pads);\n             if is_nop_landing_pad {\n-                nop_landing_pads.insert(bb.index());\n+                nop_landing_pads.insert(bb);\n             }\n             debug!(\"    is_nop_landing_pad({:?}) = {}\", bb, is_nop_landing_pad);\n         }"}, {"sha": "6b8d5a1489388403fa25a5f42d7f25cbc5d6590b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145155dc96757002c7b2e9de8489416e2fdbbd57/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=145155dc96757002c7b2e9de8489416e2fdbbd57", "patch": "@@ -288,15 +288,15 @@ impl MirPass for SimplifyLocals {\n         let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n-        marker.locals.insert(RETURN_PLACE.index());\n+        marker.locals.insert(RETURN_PLACE);\n         for arg in mir.args_iter() {\n-            marker.locals.insert(arg.index());\n+            marker.locals.insert(arg);\n         }\n \n         // We may need to keep dead user variables live for debuginfo.\n         if tcx.sess.opts.debuginfo == FullDebugInfo {\n             for local in mir.vars_iter() {\n-                marker.locals.insert(local.index());\n+                marker.locals.insert(local);\n             }\n         }\n \n@@ -308,35 +308,38 @@ impl MirPass for SimplifyLocals {\n }\n \n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n-fn make_local_map<'tcx, I: Idx, V>(vec: &mut IndexVec<I, V>, mask: BitVector) -> Vec<usize> {\n-    let mut map: Vec<usize> = ::std::iter::repeat(!0).take(vec.len()).collect();\n-    let mut used = 0;\n+fn make_local_map<'tcx, V>(\n+    vec: &mut IndexVec<Local, V>,\n+    mask: BitVector<Local>,\n+) -> IndexVec<Local, Option<Local>> {\n+    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n+    let mut used = Local::new(0);\n     for alive_index in mask.iter() {\n-        map[alive_index] = used;\n+        map[alive_index] = Some(used);\n         if alive_index != used {\n             vec.swap(alive_index, used);\n         }\n-        used += 1;\n+        used.increment_by(1);\n     }\n-    vec.truncate(used);\n+    vec.truncate(used.index());\n     map\n }\n \n struct DeclMarker {\n-    pub locals: BitVector,\n+    pub locals: BitVector<Local>,\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n     fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n         // ignore these altogether, they get removed along with their otherwise unused decls.\n         if ctx != PlaceContext::StorageLive && ctx != PlaceContext::StorageDead {\n-            self.locals.insert(local.index());\n+            self.locals.insert(*local);\n         }\n     }\n }\n \n struct LocalUpdater {\n-    map: Vec<usize>,\n+    map: IndexVec<Local, Option<Local>>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n@@ -345,14 +348,14 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         data.statements.retain(|stmt| {\n             match stmt.kind {\n                 StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                    self.map[l.index()] != !0\n+                    self.map[l].is_some()\n                 }\n                 _ => true\n             }\n         });\n         self.super_basic_block_data(block, data);\n     }\n     fn visit_local(&mut self, l: &mut Local, _: PlaceContext<'tcx>, _: Location) {\n-        *l = Local::new(self.map[l.index()]);\n+        *l = self.map[*l].unwrap();\n     }\n }"}]}