{"sha": "e8c28e24b99f9da9bf797848902ab7763da54c5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YzI4ZTI0Yjk5ZjlkYTliZjc5Nzg0ODkwMmFiNzc2M2RhNTRjNWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-06T11:30:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-14T15:05:45Z"}, "message": "rustc_metadata: Privatize private code and remove dead code", "tree": {"sha": "1711729408b97ebf6a3f07d5a36c2910e7e10b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1711729408b97ebf6a3f07d5a36c2910e7e10b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8c28e24b99f9da9bf797848902ab7763da54c5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c28e24b99f9da9bf797848902ab7763da54c5b", "html_url": "https://github.com/rust-lang/rust/commit/e8c28e24b99f9da9bf797848902ab7763da54c5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8c28e24b99f9da9bf797848902ab7763da54c5b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b", "html_url": "https://github.com/rust-lang/rust/commit/446e5e57b667c841ba3ebb4b41b44fb98bd3af4b"}], "stats": {"total": 459, "additions": 202, "deletions": 257}, "files": [{"sha": "f33cb4e215d332a4b7edef4bc953d2d170233196", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -616,7 +616,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                &*cstore.metadata_loader,\n+                                                cstore,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "309cf8e255bef606224c5983bad430967bf079e6", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -663,16 +663,15 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n \n         if sess.binary_dep_depinfo() {\n             for cnum in compiler.cstore.crates_untracked() {\n-                let metadata = compiler.cstore.crate_data_as_rc_any(cnum);\n-                let metadata = metadata.downcast_ref::<cstore::CrateMetadata>().unwrap();\n-                if let Some((path, _)) = &metadata.source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                let source = compiler.cstore.crate_source_untracked(cnum);\n+                if let Some((path, _)) = source.dylib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rlib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rmeta {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n             }\n         }"}, {"sha": "956df7828440fa4bdb54dcfc4fb29870f5bf8bb1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -1,6 +1,6 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n+use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n@@ -14,7 +14,7 @@ use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n@@ -33,15 +33,15 @@ use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n \n-pub struct Library {\n+crate struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n     pub rmeta: Option<(PathBuf, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n pub struct CrateLoader<'a> {\n-    pub sess: &'a Session,\n+    sess: &'a Session,\n     cstore: &'a CStore,\n     local_crate_name: Symbol,\n }\n@@ -268,13 +268,12 @@ impl<'a> CrateLoader<'a> {\n             source_map_import_info: RwLock::new(vec![]),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n-            source: cstore::CrateSource {\n+            source: CrateSource {\n                 dylib,\n                 rlib,\n                 rmeta,\n             },\n             private_dep,\n-            span,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n         };"}, {"sha": "a9fa210b53c504e6999fcd098388d91cd462baa6", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -5,37 +5,29 @@ use crate::schema;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, NodeMap};\n-\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n-\n-pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n-pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LibSource, ForeignModule};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub use crate::cstore_impl::{provide, provide_extern};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub use rustc_data_structures::sync::MetadataRef;\n-use syntax_pos::Span;\n-use proc_macro::bridge::client::ProcMacro;\n-\n-pub struct MetadataBlob(pub MetadataRef);\n+crate struct MetadataBlob(pub MetadataRef);\n \n /// Holds information about a syntax_pos::SourceFile imported from another crate.\n /// See `imported_source_files()` for more information.\n-pub struct ImportedSourceFile {\n+crate struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n     /// The end of this SourceFile within the source_map of its original crate\n@@ -48,56 +40,54 @@ pub struct CrateMetadata {\n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n     /// (e.g., by the allocator)\n-    pub extern_crate: Lock<Option<ExternCrate>>,\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n \n-    pub blob: MetadataBlob,\n-    pub cnum_map: CrateNumMap,\n-    pub cnum: CrateNum,\n-    pub dependencies: Lock<Vec<CrateNum>>,\n-    pub source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    crate blob: MetadataBlob,\n+    crate cnum_map: CrateNumMap,\n+    crate cnum: CrateNum,\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n \n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    pub alloc_decoding_state: AllocDecodingState,\n+    crate alloc_decoding_state: AllocDecodingState,\n \n     // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n     // lifetime is only used behind `Lazy`, and therefore acts like an\n     // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     // is being used to decode those values.\n-    pub root: schema::CrateRoot<'static>,\n+    crate root: schema::CrateRoot<'static>,\n \n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub def_path_table: Lrc<DefPathTable>,\n+    crate def_path_table: Lrc<DefPathTable>,\n \n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n \n-    pub dep_kind: Lock<DepKind>,\n-    pub source: CrateSource,\n+    crate dep_kind: Lock<DepKind>,\n+    crate source: CrateSource,\n \n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool,\n-\n-    pub span: Span,\n+    crate private_dep: bool,\n \n-    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n \n     /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n     /// It is initialized on the first access in `get_crate_dep_node_index()`.\n     /// Do not access the value directly, as it might not have been initialized\n     /// yet.\n     /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    pub(super) dep_node_index: AtomicCell<DepNodeIndex>,\n+    crate dep_node_index: AtomicCell<DepNodeIndex>,\n }\n \n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: Lock<NodeMap<CrateNum>>,\n-    pub metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n }\n \n pub enum LoadedMacro {\n@@ -118,25 +108,25 @@ impl CStore {\n         }\n     }\n \n-    pub(super) fn alloc_new_crate_num(&self) -> CrateNum {\n+    crate fn alloc_new_crate_num(&self) -> CrateNum {\n         let mut metas = self.metas.borrow_mut();\n         let cnum = CrateNum::new(metas.len());\n         metas.push(None);\n         cnum\n     }\n \n-    pub(super) fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n         self.metas.borrow()[cnum].clone()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    pub(super) fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n+    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n         let mut metas = self.metas.borrow_mut();\n         assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n         metas[cnum] = Some(data);\n     }\n \n-    pub(super) fn iter_crate_data<I>(&self, mut i: I)\n+    crate fn iter_crate_data<I>(&self, mut i: I)\n         where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n     {\n         for (k, v) in self.metas.borrow().iter_enumerated() {\n@@ -146,16 +136,14 @@ impl CStore {\n         }\n     }\n \n-    pub(super) fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n+    crate fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub(super) fn push_dependencies_in_postorder(&self,\n-                                                 ordering: &mut Vec<CrateNum>,\n-                                                 krate: CrateNum) {\n+    crate fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n         if ordering.contains(&krate) {\n             return;\n         }\n@@ -170,7 +158,7 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    pub(super) fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+    crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (num, v) in self.metas.borrow().iter_enumerated() {\n             if let &Some(_) = v {\n@@ -180,11 +168,11 @@ impl CStore {\n         return ordering\n     }\n \n-    pub(super) fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n+    crate fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub(super) fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n+    crate fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n }"}, {"sha": "21ed22f61f17e04d050939d1faab8cd231531bb7", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -6,8 +6,7 @@ use crate::foreign_modules;\n use crate::schema;\n \n use rustc::ty::query::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, DepKind,\n-                            EncodedMetadata, NativeLibraryKind};\n+use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n use rustc::middle::dependency_format::Linkage;\n@@ -414,12 +413,6 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind {\n-        let data = self.get_crate_data(cnum);\n-        let r = *data.dep_kind.lock();\n-        r\n-    }\n-\n     pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n         self.get_crate_data(cnum).root.edition\n     }\n@@ -428,14 +421,6 @@ impl cstore::CStore {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n \n-    pub fn ctor_kind_untracked(&self, def: DefId) -> def::CtorKind {\n-        self.get_crate_data(def.krate).get_ctor_kind(def.index)\n-    }\n-\n-    pub fn item_attrs_untracked(&self, def: DefId, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        self.get_crate_data(def.krate).get_item_attrs(def.index, sess)\n-    }\n-\n     pub fn item_children_untracked(\n         &self,\n         def_id: DefId,\n@@ -493,6 +478,10 @@ impl cstore::CStore {\n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n+\n+    pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n+        self.get_crate_data(cnum).source.clone()\n+    }\n }\n \n impl CrateStore for cstore::CStore {"}, {"sha": "6969d608d76da1da75d39d75f3fdd8edda48db9a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -1,13 +1,13 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::schema::*;\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n-use rustc::middle::cstore::LinkagePreference;\n+use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -38,7 +38,7 @@ use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n-pub struct DecodeContext<'a, 'tcx> {\n+crate struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'tcx Session>,\n@@ -54,7 +54,7 @@ pub struct DecodeContext<'a, 'tcx> {\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n-pub trait Metadata<'a, 'tcx>: Copy {\n+crate trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'tcx Session> { None }\n@@ -130,15 +130,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n }\n \n impl<'a, 'tcx, T: Decodable> Lazy<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n+    crate fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(\n+    crate fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n@@ -149,11 +149,11 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    pub fn cdata(&self) -> &'a CrateMetadata {\n+    fn cdata(&self) -> &'a CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n@@ -379,15 +379,15 @@ for DecodeContext<'a, 'tcx> {\n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n impl<'tcx> MetadataBlob {\n-    pub fn is_compatible(&self) -> bool {\n+    crate fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n \n-    pub fn get_rustc_version(&self) -> String {\n+    crate fn get_rustc_version(&self) -> String {\n         Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n-    pub fn get_root(&self) -> CrateRoot<'tcx> {\n+    crate fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n@@ -396,7 +396,7 @@ impl<'tcx> MetadataBlob {\n         Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n     }\n \n-    pub fn list_crate_metadata(&self,\n+    crate fn list_crate_metadata(&self,\n                                out: &mut dyn io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -449,7 +449,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    pub fn is_proc_macro_crate(&self) -> bool {\n+    crate fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -499,7 +499,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n         self.entry(index).span.decode((self, sess))\n     }\n \n@@ -556,7 +556,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.entry(item_id).kind {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -647,23 +647,23 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n \n-    pub fn get_predicates(\n+    crate fn get_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n }\n \n-    pub fn get_predicates_defined_on(\n+    crate fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(\n+    crate fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n@@ -677,30 +677,27 @@ impl<'a, 'tcx> CrateMetadata {\n         super_predicates.decode((self, tcx))\n     }\n \n-    pub fn get_generics(&self,\n-                        item_id: DefIndex,\n-                        sess: &Session)\n-                        -> ty::Generics {\n+    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n             false => self.entry(id).stability.map(|stab| stab.decode(self)),\n         }\n     }\n \n-    pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.entry_unless_proc_macro(id)\n             .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n     }\n \n-    pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n             false => self.entry(id).visibility.decode(self),\n@@ -714,30 +711,31 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    pub fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    pub fn get_coerce_unsized_info(&self,\n-                                   id: DefIndex)\n-                                   -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+    crate fn get_coerce_unsized_info(\n+        &self,\n+        id: DefIndex,\n+    ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -746,7 +744,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -759,7 +757,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    pub fn get_diagnostic_items(\n+    crate fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -776,7 +774,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -911,20 +909,20 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.entry_unless_proc_macro(id)\n             .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n     }\n \n-    pub fn get_promoted_mir(\n+    crate fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -936,7 +934,7 @@ impl<'a, 'tcx> CrateMetadata {\n             })\n     }\n \n-    pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.entry(id).kind {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n@@ -947,7 +945,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let item = self.entry(id);\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n@@ -981,11 +979,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n         self.entry(id).variances.decode(self).collect()\n     }\n \n-    pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n@@ -994,7 +992,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n@@ -1006,8 +1004,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-\n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1022,7 +1019,11 @@ impl<'a, 'tcx> CrateMetadata {\n         Lrc::from(self.get_attributes(&item, sess))\n     }\n \n-    pub fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<ast::Name>> {\n+    crate fn get_struct_field_names(\n+        &self,\n+        id: DefIndex,\n+        sess: &Session,\n+    ) -> Vec<Spanned<ast::Name>> {\n         self.entry(id)\n             .children\n             .decode(self)\n@@ -1049,7 +1050,7 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn get_inherent_implementations_for_type(\n+    crate fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -1060,7 +1061,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       .map(|index| self.local_def_id(index)))\n     }\n \n-    pub fn get_implementations_for_trait(\n+    crate fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1091,7 +1092,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1108,7 +1109,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1117,7 +1118,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1126,7 +1127,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_dylib_dependency_formats(\n+    crate fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1140,7 +1141,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n@@ -1161,7 +1162,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(\n+    crate fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1174,15 +1175,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_rendered_const(&self, id: DefIndex) -> String {\n+    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n         match self.entry(id).kind {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> MacroDef {\n+    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n         let entry = self.entry(id);\n         match entry.kind {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n@@ -1200,7 +1201,7 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    pub fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n          match self.entry(id).kind {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n@@ -1209,7 +1210,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.entry(id).kind {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n@@ -1228,7 +1229,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,\n@@ -1242,7 +1243,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     #[inline]\n-    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+    crate fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1252,13 +1253,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    pub fn def_path(&self, id: DefIndex) -> DefPath {\n+    crate fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1287,9 +1288,10 @@ impl<'a, 'tcx> CrateMetadata {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    pub fn imported_source_files(&'a self,\n-                                 local_source_map: &source_map::SourceMap)\n-                                 -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n+    fn imported_source_files(\n+        &'a self,\n+        local_source_map: &source_map::SourceMap,\n+    ) -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n             let source_files = self.source_map_import_info.borrow();\n             if !source_files.is_empty() {"}, {"sha": "7f76a9730e198392cde7ac039bef100cc77ad373", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -60,7 +60,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n-pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n         verify_ok(tcx, &linkage);"}, {"sha": "3871eb89f7b42c42e4c49dd5bc181d04659b00f2", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -32,30 +32,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Loads a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n-    /// and do it now (don't use RTLD_LAZY on Unix).\n-    pub fn open_global_now(filename: &Path) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open_global_now(filename.as_os_str());\n-        match maybe_library {\n-            Err(err) => Err(err),\n-            Ok(handle) => Ok(DynamicLibrary { handle })\n-        }\n-    }\n-\n-    /// Returns the environment variable for this process's dynamic library\n-    /// search path\n-    pub fn envvar() -> &'static str {\n-        if cfg!(windows) {\n-            \"PATH\"\n-        } else if cfg!(target_os = \"macos\") {\n-            \"DYLD_LIBRARY_PATH\"\n-        } else if cfg!(target_os = \"haiku\") {\n-            \"LIBRARY_PATH\"\n-        } else {\n-            \"LD_LIBRARY_PATH\"\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on\n@@ -83,7 +59,7 @@ mod dl {\n     use std::ptr;\n     use std::str;\n \n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             unsafe {\n                 match filename {\n@@ -94,13 +70,6 @@ mod dl {\n         })\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| unsafe {\n-            let s = CString::new(filename.as_bytes()).unwrap();\n-            libc::dlopen(s.as_ptr(), libc::RTLD_GLOBAL | libc::RTLD_NOW) as *mut u8\n-        })\n-    }\n-\n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n         let s = CString::new(filename.as_bytes()).unwrap();\n         libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n@@ -110,8 +79,8 @@ mod dl {\n         libc::dlopen(ptr::null(), libc::RTLD_LAZY) as *mut u8\n     }\n \n-    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n-        F: FnOnce() -> T,\n+    fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n+        where F: FnOnce() -> T,\n     {\n         use std::sync::{Mutex, Once};\n         static INIT: Once = Once::new();\n@@ -139,14 +108,15 @@ mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const libc::c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const libc::c_char,\n+    ) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n         })\n     }\n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         libc::dlclose(handle as *mut libc::c_void); ()\n     }\n }\n@@ -178,11 +148,7 @@ mod dl {\n         fn FreeLibrary(handle: HMODULE) -> BOOL;\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        open(Some(filename))\n-    }\n-\n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {\n             // SEM_FAILCRITICALERRORS 0x01\n@@ -225,14 +191,15 @@ mod dl {\n         result\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const c_char,\n+    ) -> Result<*mut u8, String> {\n         let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n         ptr_result(ptr)\n     }\n \n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         FreeLibrary(handle as HMODULE);\n     }\n "}, {"sha": "3e8aa27ee2d8560b99dfa0bd7e2425f1e32118b0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -42,9 +42,9 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-pub struct EncodeContext<'tcx> {\n+struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     entries_index: Index<'tcx>,\n \n@@ -313,11 +313,12 @@ impl<'tcx> EncodeContext<'tcx> {\n     /// the `Entry` (which may point to other encoded information)\n     /// and will then record the `Lazy<Entry>` for use in the index.\n     // FIXME(eddyb) remove this.\n-    pub fn record<DATA>(&mut self,\n-                        id: DefId,\n-                        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n-                        data: DATA)\n-    {\n+    fn record<DATA>(\n+        &mut self,\n+        id: DefId,\n+        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n+        data: DATA,\n+    ) {\n         assert!(id.is_local());\n \n         let entry = op(self, data);\n@@ -1920,7 +1921,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1962,7 +1963,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n+fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.kind {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "fa1402584eda50f7ba83eead17510d5b97e0b88e", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),"}, {"sha": "037f9d35630833702ae7d8e31a2ec55bdf72e11e", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -7,7 +7,7 @@ use std::u32;\n use log::debug;\n \n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n-pub trait FixedSizeEncoding {\n+trait FixedSizeEncoding {\n     const BYTE_LEN: usize;\n \n     // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n@@ -75,25 +75,25 @@ impl FixedSizeEncoding for u32 {\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct Index<'tcx> {\n+crate struct Index<'tcx> {\n     positions: Vec<u8>,\n     _marker: PhantomData<&'tcx ()>,\n }\n \n impl Index<'tcx> {\n-    pub fn new(max_index: usize) -> Self {\n+    crate fn new(max_index: usize) -> Self {\n         Index {\n             positions: vec![0xff; max_index * 4],\n             _marker: PhantomData,\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n+    crate fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n         assert!(def_id.is_local());\n         self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n+    fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n         let array_index = item.index();\n@@ -108,7 +108,7 @@ impl Index<'tcx> {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n+    crate fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n@@ -123,7 +123,7 @@ impl Lazy<[Index<'tcx>]> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]\n-    pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+    crate fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         let bytes = &bytes[self.position..];\n         debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,"}, {"sha": "4291f3a4ae34e74358513fcd37f3cf9d931a9160", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "e89d9015d54b53aa3d3df71d01309e8a2d6ef247", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -212,12 +212,13 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataRef, MetadataBlob};\n+use crate::cstore::{MetadataBlob, CStore};\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::MetadataRef;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n@@ -245,13 +246,13 @@ use rustc_data_structures::owning_ref::OwningRef;\n use log::{debug, info, warn};\n \n #[derive(Clone)]\n-pub struct CrateMismatch {\n+crate struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n #[derive(Clone)]\n-pub struct Context<'a> {\n+crate struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n     pub crate_name: Symbol,\n@@ -272,7 +273,7 @@ pub struct Context<'a> {\n     pub metadata_loader: &'a dyn MetadataLoader,\n }\n \n-pub struct CratePaths {\n+crate struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n     pub rlib: Option<PathBuf>,\n@@ -303,15 +304,15 @@ impl CratePaths {\n }\n \n impl<'a> Context<'a> {\n-    pub fn reset(&mut self) {\n+    crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n         self.rejected_via_triple.clear();\n         self.rejected_via_kind.clear();\n         self.rejected_via_version.clear();\n         self.rejected_via_filename.clear();\n     }\n \n-    pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -320,7 +321,7 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    pub fn report_errs(self) -> ! {\n+    crate fn report_errs(self) -> ! {\n         let add = match self.root {\n             None => String::new(),\n             Some(r) => format!(\" which `{}` depends on\", r.ident),\n@@ -931,7 +932,7 @@ fn get_metadata_section_imp(target: &Target,\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          loader: &dyn MetadataLoader,\n+                          cstore: &CStore,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -942,7 +943,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, loader) {\n+    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "9e4c2685f11626f6744cf8f0b197d9de2a530145", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n@@ -21,7 +21,7 @@ pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     return collector.libs;\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,"}, {"sha": "d3539e7140121e774920b2ef31702a6989892a1a", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -21,15 +21,15 @@ use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n \n-pub fn rustc_version() -> String {\n+crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-pub const METADATA_VERSION: u8 = 4;\n+const METADATA_VERSION: u8 = 4;\n \n /// Metadata header which includes `METADATA_VERSION`.\n /// To get older versions of rustc to ignore this metadata,\n@@ -39,12 +39,12 @@ pub const METADATA_VERSION: u8 = 4;\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-pub const METADATA_HEADER: &[u8; 12] =\n+crate const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-pub trait LazyMeta {\n+crate trait LazyMeta {\n     type Meta: Copy + 'static;\n \n     /// Returns the minimum encoded size.\n@@ -98,7 +98,7 @@ impl<T> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n@@ -108,7 +108,7 @@ pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+    crate fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -118,13 +118,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n }\n \n impl<T> Lazy<T> {\n-    pub fn from_position(position: usize) -> Lazy<T> {\n+    crate fn from_position(position: usize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n impl<T> Lazy<[T]> {\n-    pub fn empty() -> Lazy<[T]> {\n+    crate fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(0, 0)\n     }\n }\n@@ -141,7 +141,7 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum LazyState {\n+crate enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n@@ -156,7 +156,7 @@ pub enum LazyState {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateRoot<'tcx> {\n+crate struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n     pub extra_filename: String,\n@@ -202,21 +202,21 @@ pub struct CrateRoot<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateDep {\n+crate struct CrateDep {\n     pub name: ast::Name,\n     pub hash: Svh,\n     pub kind: DepKind,\n     pub extra_filename: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitImpls {\n+crate struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Entry<'tcx> {\n+crate struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n@@ -237,7 +237,7 @@ pub struct Entry<'tcx> {\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum EntryKind<'tcx> {\n+crate enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -272,36 +272,36 @@ pub enum EntryKind<'tcx> {\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-pub struct ConstQualif {\n+crate struct ConstQualif {\n     pub mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct RenderedConst(pub String);\n+crate struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ModData {\n+crate struct ModData {\n     pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MacroDef {\n+crate struct MacroDef {\n     pub body: String,\n     pub legacy: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData<'tcx> {\n+crate struct FnData<'tcx> {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData<'tcx> {\n+crate struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n@@ -312,7 +312,7 @@ pub struct VariantData<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitData<'tcx> {\n+crate struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n@@ -321,12 +321,12 @@ pub struct TraitData<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitAliasData<'tcx> {\n+crate struct TraitAliasData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplData<'tcx> {\n+crate struct ImplData<'tcx> {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n@@ -341,15 +341,15 @@ pub struct ImplData<'tcx> {\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AssocContainer {\n+crate enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -359,7 +359,7 @@ impl AssocContainer {\n         }\n     }\n \n-    pub fn defaultness(&self) -> hir::Defaultness {\n+    crate fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -376,22 +376,22 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+crate struct MethodData<'tcx> {\n     pub fn_data: FnData<'tcx>,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ClosureData<'tcx> {\n+crate struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct GeneratorData<'tcx> {\n+crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-pub const TAG_VALID_SPAN: u8 = 0;\n-pub const TAG_INVALID_SPAN: u8 = 1;\n+crate const TAG_VALID_SPAN: u8 = 0;\n+crate const TAG_INVALID_SPAN: u8 = 1;"}, {"sha": "e2c666e0f8fbd45aeb23874cd265a73175a5bd1d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -104,8 +104,7 @@ impl<'a> Resolver<'a> {\n             return self.module_map[&def_id]\n         }\n \n-        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n-        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+        if let Some(&module) = self.extern_module_map.get(&def_id) {\n             return module;\n         }\n \n@@ -121,7 +120,7 @@ impl<'a> Resolver<'a> {\n         let module = self.arenas.alloc_module(ModuleData::new(\n             parent, kind, def_id, ExpnId::root(), DUMMY_SP\n         ));\n-        self.extern_module_map.insert((def_id, macros_only), module);\n+        self.extern_module_map.insert(def_id, module);\n         module\n     }\n "}, {"sha": "542afe70745d0e26673a17630dce8b6a7925f84b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c28e24b99f9da9bf797848902ab7763da54c5b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e8c28e24b99f9da9bf797848902ab7763da54c5b", "patch": "@@ -878,7 +878,7 @@ pub struct Resolver<'a> {\n     /// language items.\n     empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n+    extern_module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n \n     /// Maps glob imports to the names of items actually imported."}]}