{"sha": "f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZTdlMTdkOWU5YjhmYWViMTNjMzg4YzU2ZWYxMzU5NzhhNzdjNTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-19T23:32:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc_trans: pass OperandRef arguments to trans_intrinsic_call.", "tree": {"sha": "6a66c0821589e0534dafee7c8196687876df049d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a66c0821589e0534dafee7c8196687876df049d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "html_url": "https://github.com/rust-lang/rust/commit/f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2e7e17d9e9b8faeb13c388c56ef135978a77c58/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2d52d2132b54794a7e4bfcb4fb0aa31169af207", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d52d2132b54794a7e4bfcb4fb0aa31169af207", "html_url": "https://github.com/rust-lang/rust/commit/b2d52d2132b54794a7e4bfcb4fb0aa31169af207"}], "stats": {"total": 404, "additions": 206, "deletions": 198}, "files": [{"sha": "25729449dbca319d7107e176fb6000d4b72c717e", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 149, "deletions": 142, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/f2e7e17d9e9b8faeb13c388c56ef135978a77c58/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e7e17d9e9b8faeb13c388c56ef135978a77c58/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "patch": "@@ -13,7 +13,7 @@\n use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n-use abi::{self, Abi, FnType};\n+use abi::{Abi, FnType};\n use mir::lvalue::{LvalueRef, Alignment};\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n@@ -87,7 +87,7 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType,\n-                                      llargs: &[ValueRef],\n+                                      args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n@@ -110,21 +110,27 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n         _ if simple.is_some() => {\n-            bcx.call(simple.unwrap(), &llargs, None)\n+            bcx.call(simple.unwrap(),\n+                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                     None)\n         }\n         \"unreachable\" => {\n             return;\n         },\n         \"likely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, true)], None)\n+            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, true)], None)\n         }\n         \"unlikely\" => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n+            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n+            try_intrinsic(bcx, ccx,\n+                          args[0].immediate(),\n+                          args[1].immediate(),\n+                          args[2].immediate(),\n+                          llresult);\n             return;\n         }\n         \"breakpoint\" => {\n@@ -137,14 +143,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n-            } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n+            if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llsize\n             } else {\n-                C_usize(ccx, 0)\n+                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n@@ -153,14 +157,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                C_usize(ccx, ccx.align_of(tp_ty).abi())\n-            } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n+            if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llalign\n             } else {\n-                C_usize(ccx, 1)\n+                C_usize(ccx, ccx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n@@ -196,38 +198,44 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             C_bool(ccx, bcx.ccx.shared().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n-            let ptr = llargs[0];\n-            let offset = llargs[1];\n+            let ptr = args[0].immediate();\n+            let offset = args[1].immediate();\n             bcx.inbounds_gep(ptr, &[offset])\n         }\n         \"arith_offset\" => {\n-            let ptr = llargs[0];\n-            let offset = llargs[1];\n+            let ptr = args[0].immediate();\n+            let offset = args[1].immediate();\n             bcx.gep(ptr, &[offset])\n         }\n \n         \"copy_nonoverlapping\" => {\n-            copy_intrinsic(bcx, false, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n+            copy_intrinsic(bcx, false, false, substs.type_at(0),\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"copy\" => {\n-            copy_intrinsic(bcx, true, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n+            copy_intrinsic(bcx, true, false, substs.type_at(0),\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"write_bytes\" => {\n-            memset_intrinsic(bcx, false, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx, false, substs.type_at(0),\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n \n         \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx, false, true, substs.type_at(0),\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_copy_memory\" => {\n-            copy_intrinsic(bcx, true, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx, true, true, substs.type_at(0),\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_set_memory\" => {\n-            memset_intrinsic(bcx, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx, true, substs.type_at(0),\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n-            let mut ptr = llargs[0];\n+            let mut ptr = args[0].immediate();\n             if let Some(ty) = fn_ty.ret.cast {\n                 ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n             }\n@@ -239,18 +247,18 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = LvalueRef::new_sized(llargs[0], tp_ty, Alignment::AbiAligned);\n-            if type_is_fat_ptr(bcx.ccx, tp_ty) {\n-                bcx.volatile_store(llargs[1], dst.project_field(bcx, abi::FAT_PTR_ADDR).llval);\n-                bcx.volatile_store(llargs[2], dst.project_field(bcx, abi::FAT_PTR_EXTRA).llval);\n+            let dst = LvalueRef::new_sized(args[0].immediate(), tp_ty, Alignment::AbiAligned);\n+            if let OperandValue::Pair(a, b) = args[1].val {\n+                bcx.volatile_store(a, dst.project_field(bcx, 0).llval);\n+                bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n-                let val = if fn_ty.args[1].is_indirect() {\n-                    bcx.load(llargs[1], None)\n+                let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n+                    bcx.load(ptr, align.non_abi())\n                 } else {\n                     if type_is_zero_size(ccx, tp_ty) {\n                         return;\n                     }\n-                    from_immediate(bcx, llargs[1])\n+                    from_immediate(bcx, args[1].immediate())\n                 };\n                 let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n@@ -270,7 +278,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 \"prefetch_write_instruction\" => (1, 0),\n                 _ => bug!()\n             };\n-            bcx.call(expect, &[llargs[0], C_i32(ccx, rw), llargs[1], C_i32(ccx, cache_type)], None)\n+            bcx.call(expect, &[\n+                args[0].immediate(),\n+                C_i32(ccx, rw),\n+                args[1].immediate(),\n+                C_i32(ccx, cache_type)\n+            ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n@@ -283,22 +296,22 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         \"ctlz\" | \"cttz\" => {\n                             let y = C_bool(bcx.ccx, false);\n                             let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            bcx.call(llfn, &[llargs[0], y], None)\n+                            bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n                             let y = C_bool(bcx.ccx, true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = ccx.get_intrinsic(llvm_name);\n-                            bcx.call(llfn, &[llargs[0], y], None)\n+                            bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &llargs, None),\n+                                        &[args[0].immediate()], None),\n                         \"bswap\" => {\n                             if width == 8 {\n-                                llargs[0] // byte swap a u8/i8 is just a no-op\n+                                args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n                                 bcx.call(ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &llargs, None)\n+                                        &[args[0].immediate()], None)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n@@ -308,7 +321,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let pair = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n+                            let pair = bcx.call(llfn, &[\n+                                args[0].immediate(),\n+                                args[1].immediate()\n+                            ], None);\n                             let val = bcx.extract_value(pair, 0);\n                             let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n \n@@ -319,27 +335,27 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                             return;\n                         },\n-                        \"overflowing_add\" => bcx.add(llargs[0], llargs[1]),\n-                        \"overflowing_sub\" => bcx.sub(llargs[0], llargs[1]),\n-                        \"overflowing_mul\" => bcx.mul(llargs[0], llargs[1]),\n+                        \"overflowing_add\" => bcx.add(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_sub\" => bcx.sub(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_mul\" => bcx.mul(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_div\" =>\n                             if signed {\n-                                bcx.sdiv(llargs[0], llargs[1])\n+                                bcx.sdiv(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.udiv(llargs[0], llargs[1])\n+                                bcx.udiv(args[0].immediate(), args[1].immediate())\n                             },\n                         \"unchecked_rem\" =>\n                             if signed {\n-                                bcx.srem(llargs[0], llargs[1])\n+                                bcx.srem(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.urem(llargs[0], llargs[1])\n+                                bcx.urem(args[0].immediate(), args[1].immediate())\n                             },\n-                        \"unchecked_shl\" => bcx.shl(llargs[0], llargs[1]),\n+                        \"unchecked_shl\" => bcx.shl(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_shr\" =>\n                             if signed {\n-                                bcx.ashr(llargs[0], llargs[1])\n+                                bcx.ashr(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.lshr(llargs[0], llargs[1])\n+                                bcx.lshr(args[0].immediate(), args[1].immediate())\n                             },\n                         _ => bug!(),\n                     },\n@@ -358,11 +374,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             match float_type_width(sty) {\n                 Some(_width) =>\n                     match name {\n-                        \"fadd_fast\" => bcx.fadd_fast(llargs[0], llargs[1]),\n-                        \"fsub_fast\" => bcx.fsub_fast(llargs[0], llargs[1]),\n-                        \"fmul_fast\" => bcx.fmul_fast(llargs[0], llargs[1]),\n-                        \"fdiv_fast\" => bcx.fdiv_fast(llargs[0], llargs[1]),\n-                        \"frem_fast\" => bcx.frem_fast(llargs[0], llargs[1]),\n+                        \"fadd_fast\" => bcx.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fsub_fast\" => bcx.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fmul_fast\" => bcx.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fdiv_fast\" => bcx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        \"frem_fast\" => bcx.frem_fast(args[0].immediate(), args[1].immediate()),\n                         _ => bug!(),\n                     },\n                 None => {\n@@ -378,7 +394,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"discriminant_value\" => {\n             let val_ty = substs.type_at(0);\n-            let adt_val = LvalueRef::new_sized(llargs[0], val_ty, Alignment::AbiAligned);\n+            let adt_val = LvalueRef::new_sized(args[0].immediate(),\n+                                               val_ty,\n+                                               Alignment::AbiAligned);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     adt_val.trans_get_discr(bcx, ret_ty)\n@@ -389,19 +407,20 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.isize_ty());\n+            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty());\n             // `ptr_val % align`\n-            let offset = bcx.urem(ptr_val, llargs[1]);\n+            let align = args[1].immediate();\n+            let offset = bcx.urem(ptr_val, align);\n             let zero = C_null(bcx.ccx.isize_ty());\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { offset - align }`\n-            bcx.select(is_zero, zero, bcx.sub(offset, llargs[1]))\n+            bcx.select(is_zero, zero, bcx.sub(offset, align))\n         }\n         name if name.starts_with(\"simd_\") => {\n             match generic_simd_intrinsic(bcx, name,\n                                          callee_ty,\n-                                         &llargs,\n+                                         args,\n                                          ret_ty, llret_ty,\n                                          span) {\n                 Ok(llval) => llval,\n@@ -451,8 +470,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     let ty = substs.type_at(0);\n                     if int_type_width_signed(ty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                        let pair = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n-                            failorder, weak);\n+                        let pair = bcx.atomic_cmpxchg(\n+                            args[0].immediate(),\n+                            args[1].immediate(),\n+                            args[2].immediate(),\n+                            order,\n+                            failorder,\n+                            weak);\n                         let val = bcx.extract_value(pair, 0);\n                         let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n \n@@ -470,7 +494,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     let ty = substs.type_at(0);\n                     if int_type_width_signed(ty, ccx).is_some() {\n                         let align = ccx.align_of(ty);\n-                        bcx.atomic_load(llargs[0], order, align)\n+                        bcx.atomic_load(args[0].immediate(), order, align)\n                     } else {\n                         return invalid_monomorphization(ty);\n                     }\n@@ -480,7 +504,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     let ty = substs.type_at(0);\n                     if int_type_width_signed(ty, ccx).is_some() {\n                         let align = ccx.align_of(ty);\n-                        bcx.atomic_store(llargs[1], llargs[0], order, align);\n+                        bcx.atomic_store(args[1].immediate(), args[0].immediate(), order, align);\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -516,7 +540,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                     let ty = substs.type_at(0);\n                     if int_type_width_signed(ty, ccx).is_some() {\n-                        bcx.atomic_rmw(atom_op, llargs[0], llargs[1], order)\n+                        bcx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n                     } else {\n                         return invalid_monomorphization(ty);\n                     }\n@@ -533,13 +557,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type,\n-                          any_changes_needed: &mut bool) -> Vec<Type> {\n+            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n                     Void => vec![Type::void(ccx)],\n-                    Integer(_signed, width, llvm_width) => {\n-                        *any_changes_needed |= width != llvm_width;\n+                    Integer(_signed, _width, llvm_width) => {\n                         vec![Type::ix(ccx, llvm_width as u64)]\n                     }\n                     Float(x) => {\n@@ -550,29 +572,24 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n-                        *any_changes_needed |= llvm_elem.is_some();\n-\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n+                        let elem = one(ty_to_type(ccx, t));\n                         vec![elem.ptr_to()]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n-                        *any_changes_needed |= llvm_elem.is_some();\n-\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n+                        let elem = one(ty_to_type(ccx, t));\n                         vec![Type::vector(&elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n-                                            .map(|t| one(ty_to_type(ccx, t, any_changes_needed)))\n+                                            .map(|t| one(ty_to_type(ccx, t)))\n                                             .collect::<Vec<_>>();\n                         vec![Type::struct_(ccx, &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n-                        *any_changes_needed = true;\n                         contents.iter()\n-                                .flat_map(|t| ty_to_type(ccx, t, any_changes_needed))\n+                                .flat_map(|t| ty_to_type(ccx, t))\n                                 .collect()\n                     }\n                 }\n@@ -584,8 +601,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // cast.\n             fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n-                                          arg_type: Ty<'tcx>,\n-                                          llarg: ValueRef)\n+                                          arg: &OperandRef<'tcx>)\n                                           -> Vec<ValueRef>\n             {\n                 match *t {\n@@ -596,54 +612,44 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = LvalueRef::new_sized(llarg, arg_type, Alignment::AbiAligned);\n+                        assert!(!bcx.ccx.shared().type_needs_drop(arg.ty));\n+                        let (ptr, align) = match arg.val {\n+                            OperandValue::Ref(ptr, align) => (ptr, align),\n+                            _ => bug!()\n+                        };\n+                        let arg = LvalueRef::new_sized(ptr, arg.ty, align);\n                         (0..contents.len()).map(|i| {\n                             arg.project_field(bcx, i).load(bcx).immediate()\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n-                        vec![bcx.pointercast(llarg, llvm_elem.ptr_to())]\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        vec![bcx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n-                        vec![bcx.bitcast(llarg, Type::vector(&llvm_elem, length as u64))]\n+                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        vec![bcx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bcx.trunc(llarg, Type::ix(bcx.ccx, llvm_width as u64))]\n+                        vec![bcx.trunc(arg.immediate(), Type::ix(bcx.ccx, llvm_width as u64))]\n                     }\n-                    _ => vec![llarg],\n+                    _ => vec![arg.immediate()],\n                 }\n             }\n \n \n-            let mut any_changes_needed = false;\n             let inputs = intr.inputs.iter()\n-                                    .flat_map(|t| ty_to_type(ccx, t, &mut any_changes_needed))\n+                                    .flat_map(|t| ty_to_type(ccx, t))\n                                     .collect::<Vec<_>>();\n \n-            let mut out_changes = false;\n-            let outputs = one(ty_to_type(ccx, &intr.output, &mut out_changes));\n-            // outputting a flattened aggregate is nonsense\n-            assert!(!out_changes);\n+            let outputs = one(ty_to_type(ccx, &intr.output));\n \n-            let llargs = if !any_changes_needed {\n-                // no aggregates to flatten, so no change needed\n-                llargs.to_vec()\n-            } else {\n-                // there are some aggregates that need to be flattened\n-                // in the LLVM call, so we need to run over the types\n-                // again to find them and extract the arguments\n-                intr.inputs.iter()\n-                           .zip(llargs)\n-                           .zip(arg_tys)\n-                           .flat_map(|((t, llarg), ty)| modify_as_needed(bcx, t, ty, *llarg))\n-                           .collect()\n-            };\n+            let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n+                modify_as_needed(bcx, t, arg)\n+            }).collect();\n             assert_eq!(inputs.len(), llargs.len());\n \n             let val = match intr.definition {\n@@ -977,7 +983,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    llargs: &[ValueRef],\n+    args: &[OperandRef<'tcx>],\n     ret_ty: Ty<'tcx>,\n     llret_ty: Type,\n     span: Span\n@@ -1046,8 +1052,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  ret_ty.simd_type(tcx));\n \n         return Ok(compare_simd_types(bcx,\n-                                     llargs[0],\n-                                     llargs[1],\n+                                     args[0].immediate(),\n+                                     args[1].immediate(),\n                                      in_elem,\n                                      llret_ty,\n                                      cmp_op))\n@@ -1074,7 +1080,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n         let total_len = in_len as u128 * 2;\n \n-        let vector = llargs[2];\n+        let vector = args[2].immediate();\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n@@ -1099,20 +1105,24 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             None => return Ok(C_null(llret_ty))\n         };\n \n-        return Ok(bcx.shuffle_vector(llargs[0], llargs[1], C_vector(&indices)))\n+        return Ok(bcx.shuffle_vector(args[0].immediate(),\n+                                     args[1].immediate(),\n+                                     C_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n         require!(in_elem == arg_tys[2],\n                  \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, arg_tys[2]);\n-        return Ok(bcx.insert_element(llargs[0], llargs[2], llargs[1]))\n+        return Ok(bcx.insert_element(args[0].immediate(),\n+                                     args[2].immediate(),\n+                                     args[1].immediate()))\n     }\n     if name == \"simd_extract\" {\n         require!(ret_ty == in_elem,\n                  \"expected return type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, ret_ty);\n-        return Ok(bcx.extract_element(llargs[0], llargs[1]))\n+        return Ok(bcx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n     if name == \"simd_cast\" {\n@@ -1126,7 +1136,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // casting cares about nominal type, not just structural type\n         let out_elem = ret_ty.simd_type(tcx);\n \n-        if in_elem == out_elem { return Ok(llargs[0]); }\n+        if in_elem == out_elem { return Ok(args[0].immediate()); }\n \n         enum Style { Float, Int(/* is signed? */ bool), Unsupported }\n \n@@ -1148,34 +1158,34 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         match (in_style, out_style) {\n             (Style::Int(in_is_signed), Style::Int(_)) => {\n                 return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.trunc(llargs[0], llret_ty),\n-                    Ordering::Equal => llargs[0],\n+                    Ordering::Greater => bcx.trunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n                     Ordering::Less => if in_is_signed {\n-                        bcx.sext(llargs[0], llret_ty)\n+                        bcx.sext(args[0].immediate(), llret_ty)\n                     } else {\n-                        bcx.zext(llargs[0], llret_ty)\n+                        bcx.zext(args[0].immediate(), llret_ty)\n                     }\n                 })\n             }\n             (Style::Int(in_is_signed), Style::Float) => {\n                 return Ok(if in_is_signed {\n-                    bcx.sitofp(llargs[0], llret_ty)\n+                    bcx.sitofp(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.uitofp(llargs[0], llret_ty)\n+                    bcx.uitofp(args[0].immediate(), llret_ty)\n                 })\n             }\n             (Style::Float, Style::Int(out_is_signed)) => {\n                 return Ok(if out_is_signed {\n-                    bcx.fptosi(llargs[0], llret_ty)\n+                    bcx.fptosi(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.fptoui(llargs[0], llret_ty)\n+                    bcx.fptoui(args[0].immediate(), llret_ty)\n                 })\n             }\n             (Style::Float, Style::Float) => {\n                 return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.fptrunc(llargs[0], llret_ty),\n-                    Ordering::Equal => llargs[0],\n-                    Ordering::Less => bcx.fpext(llargs[0], llret_ty)\n+                    Ordering::Greater => bcx.fptrunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n+                    Ordering::Less => bcx.fpext(args[0].immediate(), llret_ty)\n                 })\n             }\n             _ => {/* Unsupported. Fallthrough. */}\n@@ -1187,21 +1197,18 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     }\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n-            $(\n-                if name == stringify!($name) {\n-                    match in_elem.sty {\n-                        $(\n-                            $(ty::$p(_))|* => {\n-                                return Ok(bcx.$call(llargs[0], llargs[1]))\n-                            }\n-                            )*\n-                        _ => {},\n-                    }\n-                    require!(false,\n-                             \"unsupported operation on `{}` with element `{}`\",\n-                             in_ty,\n-                             in_elem)\n-                })*\n+            $(if name == stringify!($name) {\n+                match in_elem.sty {\n+                    $($(ty::$p(_))|* => {\n+                        return Ok(bcx.$call(args[0].immediate(), args[1].immediate()))\n+                    })*\n+                    _ => {},\n+                }\n+                require!(false,\n+                            \"unsupported operation on `{}` with element `{}`\",\n+                            in_ty,\n+                            in_elem)\n+            })*\n         }\n     }\n     arith! {"}, {"sha": "da3f6559dacef125183b173906d0dee2bdc94ebd", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f2e7e17d9e9b8faeb13c388c56ef135978a77c58/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e7e17d9e9b8faeb13c388c56ef135978a77c58/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "patch": "@@ -493,74 +493,47 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     ReturnDest::Nothing\n                 };\n \n-                // Split the rust-call tupled arguments off.\n-                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n-                    let (tup, args) = args.split_last().unwrap();\n-                    (args, Some(tup))\n-                } else {\n-                    (&args[..], None)\n-                };\n-\n-                let is_shuffle = intrinsic.map_or(false, |name| {\n-                    name.starts_with(\"simd_shuffle\")\n-                });\n-                let mut idx = 0;\n-                for arg in first_args {\n-                    // The indices passed to simd_shuffle* in the\n-                    // third argument must be constant. This is\n-                    // checked by const-qualification, which also\n-                    // promotes any complex rvalues to constants.\n-                    if is_shuffle && idx == 2 {\n-                        match *arg {\n-                            mir::Operand::Consume(_) => {\n-                                span_bug!(span, \"shuffle indices must be constant\");\n-                            }\n-                            mir::Operand::Constant(ref constant) => {\n-                                let val = self.trans_constant(&bcx, constant);\n-                                llargs.push(val.llval);\n-                                idx += 1;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    let mut op = self.trans_operand(&bcx, arg);\n-\n-                    // The callee needs to own the argument memory if we pass it\n-                    // by-ref, so make a local copy of non-immediate constants.\n-                    if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n-                        let tmp = LvalueRef::alloca(&bcx, op.ty, \"const\");\n-                        self.store_operand(&bcx, tmp.llval, tmp.alignment.to_align(), op);\n-                        op.val = Ref(tmp.llval, tmp.alignment);\n-                    }\n-\n-                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n-                                        &mut idx, &mut llfn, &def);\n-                }\n-                if let Some(tup) = untuple {\n-                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n-                                                  &mut idx, &mut llfn, &def)\n-                }\n-\n                 if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n                     use intrinsic::trans_intrinsic_call;\n \n-                    let (dest, llargs) = match ret_dest {\n-                        _ if fn_ty.ret.is_indirect() => {\n-                            (llargs[0], &llargs[1..])\n-                        }\n+                    let dest = match ret_dest {\n+                        _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n+                            C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n-                        ReturnDest::Store(dst) => (dst.llval, &llargs[..]),\n+                        ReturnDest::Store(dst) => dst.llval,\n                         ReturnDest::DirectOperand(_) =>\n                             bug!(\"Cannot use direct operand with an intrinsic call\")\n                     };\n \n+                    let args: Vec<_> = args.iter().enumerate().map(|(i, arg)| {\n+                        // The indices passed to simd_shuffle* in the\n+                        // third argument must be constant. This is\n+                        // checked by const-qualification, which also\n+                        // promotes any complex rvalues to constants.\n+                        if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n+                            match *arg {\n+                                mir::Operand::Consume(_) => {\n+                                    span_bug!(span, \"shuffle indices must be constant\");\n+                                }\n+                                mir::Operand::Constant(ref constant) => {\n+                                    let val = self.trans_constant(&bcx, constant);\n+                                    return OperandRef {\n+                                        val: Immediate(val.llval),\n+                                        ty: val.ty\n+                                    };\n+                                }\n+                            }\n+                        }\n+\n+                        self.trans_operand(&bcx, arg)\n+                    }).collect();\n+\n+\n                     let callee_ty = common::instance_ty(\n                         bcx.ccx.tcx(), instance.as_ref().unwrap());\n-                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n+                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -581,6 +554,34 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return;\n                 }\n \n+                // Split the rust-call tupled arguments off.\n+                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n+                    let (tup, args) = args.split_last().unwrap();\n+                    (args, Some(tup))\n+                } else {\n+                    (&args[..], None)\n+                };\n+\n+                let mut idx = 0;\n+                for arg in first_args {\n+                    let mut op = self.trans_operand(&bcx, arg);\n+\n+                    // The callee needs to own the argument memory if we pass it\n+                    // by-ref, so make a local copy of non-immediate constants.\n+                    if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n+                        let tmp = LvalueRef::alloca(&bcx, op.ty, \"const\");\n+                        op.store(&bcx, tmp);\n+                        op.val = Ref(tmp.llval, tmp.alignment);\n+                    }\n+\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n+                                        &mut idx, &mut llfn, &def);\n+                }\n+                if let Some(tup) = untuple {\n+                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n+                                                  &mut idx, &mut llfn, &def)\n+                }\n+\n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n                     (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),"}]}