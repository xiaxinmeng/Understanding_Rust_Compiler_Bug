{"sha": "de8bc44753881aacdaf435f5ba61de3c20916761", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOGJjNDQ3NTM4ODFhYWNkYWY0MzVmNWJhNjFkZTNjMjA5MTY3NjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T09:10:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T09:10:37Z"}, "message": "Auto merge of #21961 - nick29581:hrl-syntax, r=nmatsakis\n\nCloses # 20022\r\n\r\nr? @nikomatsakis", "tree": {"sha": "31240643ba98eacb0410e7229b1f3336675a4f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31240643ba98eacb0410e7229b1f3336675a4f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de8bc44753881aacdaf435f5ba61de3c20916761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de8bc44753881aacdaf435f5ba61de3c20916761", "html_url": "https://github.com/rust-lang/rust/commit/de8bc44753881aacdaf435f5ba61de3c20916761", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de8bc44753881aacdaf435f5ba61de3c20916761/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ff00cc97e67ed6aec16aa6c30e152d6065e952", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ff00cc97e67ed6aec16aa6c30e152d6065e952", "html_url": "https://github.com/rust-lang/rust/commit/29ff00cc97e67ed6aec16aa6c30e152d6065e952"}, {"sha": "f9c577e5141dda6413efcfd036389d7d2480e528", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c577e5141dda6413efcfd036389d7d2480e528", "html_url": "https://github.com/rust-lang/rust/commit/f9c577e5141dda6413efcfd036389d7d2480e528"}], "stats": {"total": 262, "additions": 231, "deletions": 31}, "files": [{"sha": "efcc3715d3e3d97f22e3f0586fc039346b39d402", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -126,7 +126,8 @@ register_diagnostics! {\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n-    E0315 // cannot invoke closure outside of its lifetime\n+    E0315, // cannot invoke closure outside of its lifetime\n+    E0316 // nested quantification of lifetimes\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "99896535442d81363f00d01d88ea58ce0bd132e6", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -1076,7 +1076,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         trait_ref: ast::TraitRef {\n                             path: new_path,\n                             ref_id: tr.ref_id,\n-                        }\n+                        },\n+                        span: poly_tr.span,\n                     }, modifier)\n                 }\n             }"}, {"sha": "6f38dc81064209b997752ae332c8ef5fbcc6c258", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -45,15 +45,31 @@ pub enum DefRegion {\n                   /* lifetime decl */ ast::NodeId),\n }\n \n-// maps the id of each lifetime reference to the lifetime decl\n-// that it corresponds to\n+// Maps the id of each lifetime reference to the lifetime decl\n+// that it corresponds to.\n pub type NamedRegionMap = NodeMap<DefRegion>;\n \n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n     def_map: &'a DefMap,\n+    // Deep breath. Our representation for poly trait refs contains a single\n+    // binder and thus we only allow a single level of quantification. However,\n+    // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n+    // and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the de Bruijn indices\n+    // correct when representing these constraints, we should only introduce one\n+    // scope. However, we want to support both locations for the quantifier and\n+    // during lifetime resolution we want precise information (so we can't\n+    // desugar in an earlier phase).\n+\n+    // SO, if we encounter a quantifier at the outer scope, we set\n+    // trait_ref_hack to true (and introduce a scope), and then if we encounter\n+    // a quantifier at the inner scope, we error. If trait_ref_hack is false,\n+    // then we introduce the scope at the inner quantifier.\n+\n+    // I'm sorry.\n+    trait_ref_hack: bool,\n }\n \n enum ScopeChain<'a> {\n@@ -80,6 +96,7 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n         named_region_map: &mut named_region_map,\n         scope: &ROOT_SCOPE,\n         def_map: def_map,\n+        trait_ref_hack: false,\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n@@ -198,9 +215,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n+                                                                               ref bound_lifetimes,\n                                                                                .. }) => {\n-                    self.visit_ty(&**bounded_ty);\n-                    visit::walk_ty_param_bounds_helper(self, bounds);\n+                    if bound_lifetimes.len() > 0 {\n+                        self.trait_ref_hack = true;\n+                        let result = self.with(LateScope(bound_lifetimes, self.scope),\n+                                               |old_scope, this| {\n+                            this.check_lifetime_defs(old_scope, bound_lifetimes);\n+                            this.visit_ty(&**bounded_ty);\n+                            visit::walk_ty_param_bounds_helper(this, bounds);\n+                        });\n+                        self.trait_ref_hack = false;\n+                        result\n+                    } else {\n+                        self.visit_ty(&**bounded_ty);\n+                        visit::walk_ty_param_bounds_helper(self, bounds);\n+                    }\n                 }\n                 &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n@@ -222,18 +252,27 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_poly_trait_ref(&mut self, trait_ref:\n-                            &ast::PolyTraitRef,\n+    fn visit_poly_trait_ref(&mut self,\n+                            trait_ref: &ast::PolyTraitRef,\n                             _modifier: &ast::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n-            this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n-            for lifetime in &trait_ref.bound_lifetimes {\n-                this.visit_lifetime_def(lifetime);\n+        if !self.trait_ref_hack || trait_ref.bound_lifetimes.len() > 0 {\n+            if self.trait_ref_hack {\n+                println!(\"{:?}\", trait_ref.span);\n+                span_err!(self.sess, trait_ref.span, E0316,\n+                          \"nested quantification of lifetimes\");\n             }\n-            this.visit_trait_ref(&trait_ref.trait_ref)\n-        })\n+            self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+                this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n+                for lifetime in &trait_ref.bound_lifetimes {\n+                    this.visit_lifetime_def(lifetime);\n+                }\n+                this.visit_trait_ref(&trait_ref.trait_ref)\n+            })\n+        } else {\n+            self.visit_trait_ref(&trait_ref.trait_ref)\n+        }\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n@@ -251,6 +290,7 @@ impl<'a> LifetimeContext<'a> {\n             named_region_map: *named_region_map,\n             scope: &wrap_scope,\n             def_map: self.def_map,\n+            trait_ref_hack: self.trait_ref_hack,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);"}, {"sha": "95f7ff58524402f37655c6dc68c6a64d8b33c1ed", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -1478,7 +1478,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n /// compiler's representation for things like `for<'a> Fn(&'a int)`\n /// (which would be represented by the type `PolyTraitRef ==\n /// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n-/// erase, or otherwise \"discharge\" these bound reons, we change the\n+/// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "0dbb53e09b7d97f32c28bb05c563e8d65503e898", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -526,7 +526,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n {\n     let mut projections = Vec::new();\n \n-    // the trait reference introduces a binding level here, so\n+    // The trait reference introduces a binding level here, so\n     // we need to shift the `rscope`. It'd be nice if we could\n     // do away with this rscope stuff and work this knowledge\n     // into resolve_lifetimes, as we do with non-omitted"}, {"sha": "f8793f81b199642e13371c51e2456765afb8f5e7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -443,6 +443,7 @@ pub enum WherePredicate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n     pub bounded_ty: P<Ty>,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n@@ -1535,6 +1536,8 @@ pub struct PolyTraitRef {\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n+\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "6d9a2fdb9f19814092c4173be5ace28cebccb8d0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -70,7 +70,7 @@ pub trait AstBuilder {\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n-    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef;\n+    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n     fn lifetime_def(&self,\n@@ -442,15 +442,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef {\n+    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n             bound_lifetimes: Vec::new(),\n-            trait_ref: self.trait_ref(path)\n+            trait_ref: self.trait_ref(path),\n+            span: span,\n         }\n     }\n \n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.poly_trait_ref(path), ast::TraitBoundModifier::None)\n+        ast::TraitTyParamBound(self.poly_trait_ref(path.span, path), ast::TraitBoundModifier::None)\n     }\n \n     fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {"}, {"sha": "d9242417e047511fc4cd982a4869e01d86f75a48", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -443,6 +443,7 @@ impl<'a> TraitDef<'a> {\n                 ast::WherePredicate::BoundPredicate(ref wb) => {\n                     ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n                         span: self.span,\n+                        bound_lifetimes: wb.bound_lifetimes.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n                         bounds: OwnedSlice::from_vec(wb.bounds.iter().map(|b| b.clone()).collect())\n                     })"}, {"sha": "8f1d15f6da885f3d5304cc23ea892b6195d54099", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -806,10 +806,12 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     match pred {\n-        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bounded_ty,\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bound_lifetimes,\n+                                                                     bounded_ty,\n                                                                      bounds,\n                                                                      span}) => {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n                 span: fld.new_span(span)\n@@ -895,7 +897,8 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n     ast::PolyTraitRef {\n         bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref)\n+        trait_ref: fld.fold_trait_ref(p.trait_ref),\n+        span: fld.new_span(p.span),\n     }\n }\n "}, {"sha": "fd2f0685cab8386d3bf6cf59cd176547f869fdee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -1036,6 +1036,8 @@ impl<'a> Parser<'a> {\n         */\n \n         // parse <'lt>\n+        let lo = self.span.lo;\n+\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         // examine next token to decide to do\n@@ -1047,9 +1049,11 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path()\n         {\n+            let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref();\n             let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                                     trait_ref: trait_ref };\n+                                                     trait_ref: trait_ref,\n+                                                     span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds(BoundParsingMode::Bare)\n             } else {\n@@ -4070,7 +4074,8 @@ impl<'a> Parser<'a> {\n         if let Some(unbound) = unbound {\n             let mut bounds_as_vec = bounds.into_vec();\n             bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound },\n+                                                                trait_ref: unbound,\n+                                                                span: span },\n                                                  TraitBoundModifier::Maybe));\n             bounds = OwnedSlice::from_vec(bounds_as_vec);\n         };\n@@ -4223,6 +4228,16 @@ impl<'a> Parser<'a> {\n                 }\n \n                 _ => {\n+                    let bound_lifetimes = if self.eat_keyword(keywords::For) {\n+                        // Higher ranked constraint.\n+                        self.expect(&token::Lt);\n+                        let lifetime_defs = self.parse_lifetime_defs();\n+                        self.expect_gt();\n+                        lifetime_defs\n+                    } else {\n+                        vec![]\n+                    };\n+\n                     let bounded_ty = self.parse_ty();\n \n                     if self.eat(&token::Colon) {\n@@ -4233,12 +4248,13 @@ impl<'a> Parser<'a> {\n                         if bounds.len() == 0 {\n                             self.span_err(span,\n                                           \"each predicate in a `where` clause must have \\\n-                                   at least one bound in it\");\n+                                           at least one bound in it\");\n                         }\n \n                         generics.where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                                 ast::WhereBoundPredicate {\n                                     span: span,\n+                                    bound_lifetimes: bound_lifetimes,\n                                     bounded_ty: bounded_ty,\n                                     bounds: bounds,\n                         }));\n@@ -4674,8 +4690,12 @@ impl<'a> Parser<'a> {\n \n     /// Parse trait Foo { ... }\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> ItemInfo {\n+\n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n+        // This is not very accurate, but since unbound only exists to catch\n+        // obsolete syntax, the span is unlikely to ever be used.\n+        let unbound_span = self.span;\n         let unbound = self.parse_for_sized();\n \n         // Parse supertrait bounds.\n@@ -4684,7 +4704,8 @@ impl<'a> Parser<'a> {\n         if let Some(unbound) = unbound {\n             let mut bounds_as_vec = bounds.into_vec();\n             bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound },\n+                                                                trait_ref: unbound,\n+                                                                span:  unbound_span },\n                                                  TraitBoundModifier::Maybe));\n             bounds = OwnedSlice::from_vec(bounds_as_vec);\n         };\n@@ -4803,11 +4824,13 @@ impl<'a> Parser<'a> {\n \n     /// Parse for<'l> a::B<String,i32>\n     fn parse_poly_trait_ref(&mut self) -> PolyTraitRef {\n+        let lo = self.span.lo;\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         ast::PolyTraitRef {\n             bound_lifetimes: lifetime_defs,\n-            trait_ref: self.parse_trait_ref()\n+            trait_ref: self.parse_trait_ref(),\n+            span: mk_sp(lo, self.last_span.hi),\n         }\n     }\n "}, {"sha": "583095e15742738d5fdf2eeb1a42bae3462336a4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -1025,11 +1025,11 @@ impl<'a> State<'a> {\n         self.print_path(&t.path, false)\n     }\n \n-    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n-        if !t.bound_lifetimes.is_empty() {\n+    fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> IoResult<()> {\n+        if !lifetimes.is_empty() {\n             try!(word(&mut self.s, \"for<\"));\n             let mut comma = false;\n-            for lifetime_def in &t.bound_lifetimes {\n+            for lifetime_def in lifetimes {\n                 if comma {\n                     try!(self.word_space(\",\"))\n                 }\n@@ -1038,7 +1038,11 @@ impl<'a> State<'a> {\n             }\n             try!(word(&mut self.s, \">\"));\n         }\n+        Ok(())\n+    }\n \n+    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n+        try!(self.print_formal_lifetime_list(&t.bound_lifetimes));\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n@@ -2517,9 +2521,11 @@ impl<'a> State<'a> {\n             }\n \n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n+                                                                              ref bounded_ty,\n                                                                               ref bounds,\n                                                                               ..}) => {\n+                    try!(self.print_formal_lifetime_list(bound_lifetimes));\n                     try!(self.print_type(&**bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }"}, {"sha": "cd5240198b385b6ec7af3e9fb98c0c3be5b6b801", "filename": "src/test/compile-fail/where-for-self-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Fcompile-fail%2Fwhere-for-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Fcompile-fail%2Fwhere-for-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-for-self-2.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can quantify lifetimes outside a constraint (i.e., including\n+// the self type) in a where clause. Specifically, test that implementing for a\n+// specific lifetime is not enough to satisify the `for<'a> ...` constraint, which\n+// should require *all* lifetimes.\n+\n+static X: &'static u32 = &42;\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+impl Bar for &'static u32 {\n+    fn bar(&self) {}\n+}\n+\n+fn foo<T>(x: &T)\n+    where for<'a> &'a T: Bar\n+{}\n+\n+fn main() {\n+    foo(&X);\n+    //~^ error: `for<'a> Bar` is not implemented\n+}"}, {"sha": "8f447face4e51f25703e13b5d1d009d2c695e57f", "filename": "src/test/compile-fail/where-for-self.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Fcompile-fail%2Fwhere-for-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Fcompile-fail%2Fwhere-for-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-for-self.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can quantify lifetimes outside a constraint (i.e., including\n+// the self type) in a where clause. Specifically, test that we cannot nest\n+// quantification in constraints (to be clear, there is no reason this should not\n+// we're testing we don't crash or do something stupid).\n+\n+trait Bar<'a> {\n+    fn bar(&self);\n+}\n+\n+impl<'a, 'b> Bar<'b> for &'a u32 {\n+    fn bar(&self) {}\n+}\n+\n+fn foo<T>(x: &T)\n+    where for<'a> &'a T: for<'b> Bar<'b>\n+    //~^ error: nested quantification of lifetimes\n+{}\n+\n+fn main() {}"}, {"sha": "5d426793c2e36f9ad94c0821c9c2fad126068eee", "filename": "src/test/run-pass/where-for-self.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8bc44753881aacdaf435f5ba61de3c20916761/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs?ref=de8bc44753881aacdaf435f5ba61de3c20916761", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can quantify lifetimes outside a constraint (i.e., including\n+// the self type) in a where clause.\n+\n+static mut COUNT: u32 = 1;\n+\n+trait Bar<'a> {\n+    fn bar(&self);\n+}\n+\n+trait Baz<'a> {\n+    fn baz(&self);\n+}\n+\n+impl<'a, 'b> Bar<'b> for &'a u32 {\n+    fn bar(&self) {\n+        unsafe { COUNT *= 2; }\n+    }\n+}\n+\n+impl<'a, 'b> Baz<'b> for &'a u32 {\n+    fn baz(&self) {\n+        unsafe { COUNT *= 3; }\n+    }\n+}\n+\n+// Test we can use the syntax for HRL including the self type.\n+fn foo1<T>(x: &T)\n+    where for<'a, 'b> &'a T: Bar<'b>\n+{\n+    x.bar()\n+}\n+\n+// Test we can quantify multiple bounds (i.e., the precedence is sensible).\n+fn foo2<T>(x: &T)\n+    where for<'a, 'b> &'a T: Bar<'b> + Baz<'b>\n+{\n+    x.baz();\n+    x.bar()\n+}\n+\n+fn main() {\n+    let x = 42u32;\n+    foo1(&x);\n+    foo2(&x);\n+    unsafe {\n+        assert!(COUNT == 12);\n+    }\n+}\n+"}]}