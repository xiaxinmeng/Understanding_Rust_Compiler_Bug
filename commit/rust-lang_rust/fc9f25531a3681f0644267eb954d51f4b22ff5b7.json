{"sha": "fc9f25531a3681f0644267eb954d51f4b22ff5b7", "node_id": "C_kwDOAAsO6NoAKGZjOWYyNTUzMWEzNjgxZjA2NDQyNjdlYjk1NGQ1MWY0YjIyZmY1Yjc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-06T11:02:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-17T09:03:34Z"}, "message": "Report undeclared lifetimes on AST.", "tree": {"sha": "2c3c84ecfb7ffb18cb7ff7fbac61cbe7666d2000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c3c84ecfb7ffb18cb7ff7fbac61cbe7666d2000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc9f25531a3681f0644267eb954d51f4b22ff5b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9f25531a3681f0644267eb954d51f4b22ff5b7", "html_url": "https://github.com/rust-lang/rust/commit/fc9f25531a3681f0644267eb954d51f4b22ff5b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc9f25531a3681f0644267eb954d51f4b22ff5b7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cfceeabdcd185cd4bfca080d39e93abddc4977a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfceeabdcd185cd4bfca080d39e93abddc4977a", "html_url": "https://github.com/rust-lang/rust/commit/4cfceeabdcd185cd4bfca080d39e93abddc4977a"}], "stats": {"total": 1237, "additions": 837, "deletions": 400}, "files": [{"sha": "5f465124a31686d5d518f8152d294f6ee64e5782", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=fc9f25531a3681f0644267eb954d51f4b22ff5b7", "patch": "@@ -484,7 +484,7 @@ enum ParenthesizedGenericArgs {\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n #[derive(Copy, Clone, Debug)]\n-enum AnonymousLifetimeMode {\n+pub enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n     ///\n@@ -2017,16 +2017,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    hir::LifetimeName::Implicit(_)\n-                    | hir::LifetimeName::Underscore\n-                    | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::Implicit(_) | hir::LifetimeName::Underscore => {\n+                        hir::ParamName::Plain(lt.name.ident())\n+                    }\n                     hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n                         self.sess.diagnostic().span_bug(\n                             param.ident.span,\n                             \"object-lifetime-default should not occur here\",\n                         );\n                     }\n-                    hir::LifetimeName::Error => ParamName::Error,\n+                    hir::LifetimeName::Static | hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n                 let kind =\n@@ -2404,20 +2404,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n     /// return an \"error lifetime\".\n     fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n-        let (id, msg, label) = match id {\n-            Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),\n-\n-            None => (\n-                self.resolver.next_node_id(),\n-                \"`&` without an explicit lifetime name cannot be used here\",\n-                \"explicit lifetime name needed here\",\n-            ),\n-        };\n-\n-        let mut err = struct_span_err!(self.sess, span, E0637, \"{}\", msg,);\n-        err.span_label(span, label);\n-        err.emit();\n-\n+        let id = id.unwrap_or_else(|| self.resolver.next_node_id());\n         self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n     }\n "}, {"sha": "c6cebd1d3b134cc252f8036ff06dd5b6765d88c1", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 717, "deletions": 307, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=fc9f25531a3681f0644267eb954d51f4b22ff5b7", "patch": "@@ -188,6 +188,68 @@ impl<'a, R> Rib<'a, R> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum LifetimeRibKind {\n+    /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n+    Item,\n+\n+    /// This rib declares generic parameters.\n+    Generics { span: Span, kind: LifetimeBinderKind },\n+\n+    /// For **Modern** cases, create a new anonymous region parameter\n+    /// and reference that.\n+    ///\n+    /// For **Dyn Bound** cases, pass responsibility to\n+    /// `resolve_lifetime` code.\n+    ///\n+    /// For **Deprecated** cases, report an error.\n+    AnonymousCreateParameter,\n+\n+    /// Give a hard error when either `&` or `'_` is written. Used to\n+    /// rule out things like `where T: Foo<'_>`. Does not imply an\n+    /// error on default object bounds (e.g., `Box<dyn Foo>`).\n+    AnonymousReportError,\n+\n+    /// Pass responsibility to `resolve_lifetime` code for all cases.\n+    AnonymousPassThrough,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum LifetimeBinderKind {\n+    BareFnType,\n+    PolyTrait,\n+    WhereBound,\n+    Item,\n+    Function,\n+    ImplBlock,\n+}\n+\n+impl LifetimeBinderKind {\n+    fn descr(self) -> &'static str {\n+        use LifetimeBinderKind::*;\n+        match self {\n+            BareFnType => \"type\",\n+            PolyTrait => \"bound\",\n+            WhereBound => \"bound\",\n+            Item => \"item\",\n+            ImplBlock => \"impl block\",\n+            Function => \"function\",\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct LifetimeRib {\n+    kind: LifetimeRibKind,\n+    bindings: IdentMap<()>,\n+}\n+\n+impl LifetimeRib {\n+    fn new(kind: LifetimeRibKind) -> LifetimeRib {\n+        LifetimeRib { bindings: Default::default(), kind }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n crate enum AliasPossibility {\n     No,\n@@ -422,6 +484,9 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a, NodeId>>,\n \n+    /// The current set of local scopes for lifetimes.\n+    lifetime_ribs: Vec<LifetimeRib>,\n+\n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n@@ -446,7 +511,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         let prev = replace(&mut self.diagnostic_metadata.current_item, Some(item));\n         // Always report errors in items we just entered.\n         let old_ignore = replace(&mut self.in_func_body, false);\n-        self.resolve_item(item);\n+        self.with_lifetime_rib(LifetimeRibKind::Item, |this| this.resolve_item(item));\n         self.in_func_body = old_ignore;\n         self.diagnostic_metadata.current_item = prev;\n     }\n@@ -481,6 +546,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         let prev = self.diagnostic_metadata.current_trait_object;\n         let prev_ty = self.diagnostic_metadata.current_type_path;\n         match ty.kind {\n+            TyKind::Rptr(None, _) => {\n+                // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n+                // NodeId `ty.id`.\n+                let span = self.r.session.source_map().next_point(ty.span.shrink_to_lo());\n+                self.resolve_elided_lifetime(ty.id, span);\n+            }\n             TyKind::Path(ref qself, ref path) => {\n                 self.diagnostic_metadata.current_type_path = Some(ty);\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n@@ -500,36 +571,86 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             TyKind::TraitObject(ref bounds, ..) => {\n                 self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n             }\n+            TyKind::BareFn(ref bare_fn) => {\n+                let span = if bare_fn.generic_params.is_empty() {\n+                    ty.span.shrink_to_lo()\n+                } else {\n+                    ty.span\n+                };\n+                self.with_generic_param_rib(\n+                    &bare_fn.generic_params,\n+                    NormalRibKind,\n+                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::BareFnType, span },\n+                    |this| {\n+                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                            this.visit_generic_param_vec(&bare_fn.generic_params, false);\n+                            visit::walk_fn_decl(this, &bare_fn.decl);\n+                        });\n+                    },\n+                );\n+                self.diagnostic_metadata.current_trait_object = prev;\n+                return;\n+            }\n             _ => (),\n         }\n         visit::walk_ty(self, ty);\n         self.diagnostic_metadata.current_trait_object = prev;\n         self.diagnostic_metadata.current_type_path = prev_ty;\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n-        self.smart_resolve_path(\n-            tref.trait_ref.ref_id,\n-            None,\n-            &tref.trait_ref.path,\n-            PathSource::Trait(AliasPossibility::Maybe),\n+    fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, _: &'ast TraitBoundModifier) {\n+        let span =\n+            if tref.bound_generic_params.is_empty() { tref.span.shrink_to_lo() } else { tref.span };\n+        self.with_generic_param_rib(\n+            &tref.bound_generic_params,\n+            NormalRibKind,\n+            LifetimeRibKind::Generics { kind: LifetimeBinderKind::PolyTrait, span },\n+            |this| {\n+                this.visit_generic_param_vec(&tref.bound_generic_params, false);\n+                this.smart_resolve_path(\n+                    tref.trait_ref.ref_id,\n+                    None,\n+                    &tref.trait_ref.path,\n+                    PathSource::Trait(AliasPossibility::Maybe),\n+                );\n+                this.visit_trait_ref(&tref.trait_ref);\n+            },\n         );\n-        visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n-            ForeignItemKind::Fn(box Fn { ref generics, .. })\n-            | ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    visit::walk_foreign_item(this, foreign_item);\n+            ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n+                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+                    this.with_generic_param_rib(\n+                        &generics.params,\n+                        ItemRibKind(HasGenericParams::Yes),\n+                        LifetimeRibKind::Generics {\n+                            kind: LifetimeBinderKind::Item,\n+                            span: generics.span,\n+                        },\n+                        |this| visit::walk_foreign_item(this, foreign_item),\n+                    )\n+                });\n+            }\n+            ForeignItemKind::Fn(box Fn { ref generics, .. }) => {\n+                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+                    this.with_generic_param_rib(\n+                        &generics.params,\n+                        ItemRibKind(HasGenericParams::Yes),\n+                        LifetimeRibKind::Generics {\n+                            kind: LifetimeBinderKind::Function,\n+                            span: generics.span,\n+                        },\n+                        |this| visit::walk_foreign_item(this, foreign_item),\n+                    )\n                 });\n             }\n             ForeignItemKind::Static(..) => {\n-                self.with_item_rib(HasGenericParams::No, |this| {\n+                self.with_item_rib(|this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n             ForeignItemKind::MacCall(..) => {\n-                visit::walk_foreign_item(self, foreign_item);\n+                panic!(\"unexpanded macro in resolve!\")\n             }\n         }\n     }\n@@ -539,11 +660,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n-                // We don't need to deal with patterns in parameters, because\n-                // they are not possible for foreign or bodiless functions.\n-                self.visit_fn_header(&sig.header);\n-                self.visit_generics(generics);\n-                visit::walk_fn_decl(self, &sig.decl);\n+                self.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                    // We don't need to deal with patterns in parameters, because\n+                    // they are not possible for foreign or bodiless functions.\n+                    this.visit_fn_header(&sig.header);\n+                    this.visit_generics(generics);\n+                    visit::walk_fn_decl(this, &sig.decl);\n+                });\n                 return;\n             }\n             FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n@@ -561,113 +684,60 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.with_rib(ValueNS, rib_kind, |this| {\n             // Create a label rib for the function.\n             this.with_label_rib(rib_kind, |this| {\n+                let async_node_id = fn_kind.header().and_then(|h| h.asyncness.opt_return_id());\n+\n                 if let FnKind::Fn(_, _, _, _, generics, _) = fn_kind {\n                     this.visit_generics(generics);\n                 }\n \n-                // Add each argument to the rib.\n-                this.resolve_params(&declaration.inputs);\n+                if async_node_id.is_some() {\n+                    // In `async fn`, argument-position elided lifetimes\n+                    // must be transformed into fresh generic parameters so that\n+                    // they can be applied to the opaque `impl Trait` return type.\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n+                        // Add each argument to the rib.\n+                        this.resolve_params(&declaration.inputs)\n+                    });\n \n-                visit::walk_fn_ret_ty(this, &declaration.output);\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        visit::walk_fn_ret_ty(this, &declaration.output)\n+                    });\n+                } else {\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        // Add each argument to the rib.\n+                        this.resolve_params(&declaration.inputs);\n+\n+                        visit::walk_fn_ret_ty(this, &declaration.output);\n+                    });\n+                };\n \n                 // Ignore errors in function bodies if this is rustdoc\n                 // Be sure not to set this until the function signature has been resolved.\n                 let previous_state = replace(&mut this.in_func_body, true);\n                 // Resolve the function body, potentially inside the body of an async closure\n-                match fn_kind {\n-                    FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n-                    FnKind::Closure(_, body) => this.visit_expr(body),\n-                };\n+                this.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough,\n+                    |this| match fn_kind {\n+                        FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n+                        FnKind::Closure(_, body) => this.visit_expr(body),\n+                    },\n+                );\n \n                 debug!(\"(resolving function) leaving function\");\n                 this.in_func_body = previous_state;\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n     }\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        self.resolve_lifetime(lifetime)\n+    }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n-        // For type parameter defaults, we have to ban access\n-        // to following type parameters, as the InternalSubsts can only\n-        // provide previous type parameters as they're built. We\n-        // put all the parameters on the ban list and then remove\n-        // them one by one as they are processed and become available.\n-        let mut forward_ty_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n-        let mut forward_const_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                GenericParamKind::Type { .. } => {\n-                    forward_ty_ban_rib\n-                        .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    forward_const_ban_rib\n-                        .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n-                }\n-                GenericParamKind::Lifetime => {}\n-            }\n-        }\n-\n-        // rust-lang/rust#61631: The type `Self` is essentially\n-        // another type parameter. For ADTs, we consider it\n-        // well-defined only after all of the ADT type parameters have\n-        // been provided. Therefore, we do not allow use of `Self`\n-        // anywhere in ADT type parameter defaults.\n-        //\n-        // (We however cannot ban `Self` for defaults on *all* generic\n-        // lists; e.g. trait generics can usefully refer to `Self`,\n-        // such as in the case of `trait Add<Rhs = Self>`.)\n-        if self.diagnostic_metadata.current_self_item.is_some() {\n-            // (`Some` if + only if we are in ADT's generics.)\n-            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n-        }\n-\n-        for param in &generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime => self.visit_generic_param(param),\n-                GenericParamKind::Type { ref default } => {\n-                    for bound in &param.bounds {\n-                        self.visit_param_bound(bound);\n-                    }\n-\n-                    if let Some(ref ty) = default {\n-                        self.ribs[TypeNS].push(forward_ty_ban_rib);\n-                        self.ribs[ValueNS].push(forward_const_ban_rib);\n-                        self.visit_ty(ty);\n-                        forward_const_ban_rib = self.ribs[ValueNS].pop().unwrap();\n-                        forward_ty_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                    }\n-\n-                    // Allow all following defaults to refer to this type parameter.\n-                    forward_ty_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n-                }\n-                GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n-                    // Const parameters can't have param bounds.\n-                    assert!(param.bounds.is_empty());\n-\n-                    self.ribs[TypeNS].push(Rib::new(ConstParamTyRibKind));\n-                    self.ribs[ValueNS].push(Rib::new(ConstParamTyRibKind));\n-                    self.visit_ty(ty);\n-                    self.ribs[TypeNS].pop().unwrap();\n-                    self.ribs[ValueNS].pop().unwrap();\n-\n-                    if let Some(ref expr) = default {\n-                        self.ribs[TypeNS].push(forward_ty_ban_rib);\n-                        self.ribs[ValueNS].push(forward_const_ban_rib);\n-                        self.visit_anon_const(expr);\n-                        forward_const_ban_rib = self.ribs[ValueNS].pop().unwrap();\n-                        forward_ty_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                    }\n-\n-                    // Allow all following defaults to refer to this const parameter.\n-                    forward_const_ban_rib\n-                        .bindings\n-                        .remove(&Ident::with_dummy_span(param.ident.name));\n-                }\n-            }\n-        }\n+        self.visit_generic_param_vec(\n+            &generics.params,\n+            self.diagnostic_metadata.current_self_item.is_some(),\n+        );\n         for p in &generics.where_clause.predicates {\n             self.visit_where_predicate(p);\n         }\n@@ -726,11 +796,52 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n \n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n+        if let Some(ref args) = path_segment.args {\n+            match &**args {\n+                GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n+                GenericArgs::Parenthesized(..) => self\n+                    .with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        visit::walk_generic_args(this, path_span, args)\n+                    }),\n+            }\n+        }\n+    }\n+\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         debug!(\"visit_where_predicate {:?}\", p);\n         let previous_value =\n             replace(&mut self.diagnostic_metadata.current_where_predicate, Some(p));\n-        visit::walk_where_predicate(self, p);\n+        self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                ref bounded_ty,\n+                ref bounds,\n+                ref bound_generic_params,\n+                span: predicate_span,\n+                ..\n+            }) = p\n+            {\n+                let span = if bound_generic_params.is_empty() {\n+                    predicate_span.shrink_to_lo()\n+                } else {\n+                    *predicate_span\n+                };\n+                this.with_generic_param_rib(\n+                    &bound_generic_params,\n+                    NormalRibKind,\n+                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::WhereBound, span },\n+                    |this| {\n+                        this.visit_generic_param_vec(&bound_generic_params, false);\n+                        this.visit_ty(bounded_ty);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound)\n+                        }\n+                    },\n+                );\n+            } else {\n+                visit::walk_where_predicate(this, p);\n+            }\n+        });\n         self.diagnostic_metadata.current_where_predicate = previous_value;\n     }\n \n@@ -768,6 +879,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n             label_ribs: Vec::new(),\n+            lifetime_ribs: Vec::new(),\n             current_trait_ref: None,\n             diagnostic_metadata: DiagnosticMetadata::default(),\n             // errors at module scope should always be reported\n@@ -870,6 +982,191 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    fn visit_generic_param_vec(&mut self, params: &'ast Vec<GenericParam>, add_self_upper: bool) {\n+        // For type parameter defaults, we have to ban access\n+        // to following type parameters, as the InternalSubsts can only\n+        // provide previous type parameters as they're built. We\n+        // put all the parameters on the ban list and then remove\n+        // them one by one as they are processed and become available.\n+        let mut forward_ty_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n+        let mut forward_const_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n+        for param in params.iter() {\n+            match param.kind {\n+                GenericParamKind::Type { .. } => {\n+                    forward_ty_ban_rib\n+                        .bindings\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                }\n+                GenericParamKind::Const { .. } => {\n+                    forward_const_ban_rib\n+                        .bindings\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                }\n+                GenericParamKind::Lifetime => {}\n+            }\n+        }\n+\n+        // rust-lang/rust#61631: The type `Self` is essentially\n+        // another type parameter. For ADTs, we consider it\n+        // well-defined only after all of the ADT type parameters have\n+        // been provided. Therefore, we do not allow use of `Self`\n+        // anywhere in ADT type parameter defaults.\n+        //\n+        // (We however cannot ban `Self` for defaults on *all* generic\n+        // lists; e.g. trait generics can usefully refer to `Self`,\n+        // such as in the case of `trait Add<Rhs = Self>`.)\n+        if add_self_upper {\n+            // (`Some` if + only if we are in ADT's generics.)\n+            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n+        }\n+\n+        self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+            for param in params {\n+                match param.kind {\n+                    GenericParamKind::Lifetime => {\n+                        for bound in &param.bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                    }\n+                    GenericParamKind::Type { ref default } => {\n+                        for bound in &param.bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+\n+                        if let Some(ref ty) = default {\n+                            this.ribs[TypeNS].push(forward_ty_ban_rib);\n+                            this.ribs[ValueNS].push(forward_const_ban_rib);\n+                            this.visit_ty(ty);\n+                            forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n+                            forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n+                        }\n+\n+                        // Allow all following defaults to refer to this type parameter.\n+                        forward_ty_ban_rib\n+                            .bindings\n+                            .remove(&Ident::with_dummy_span(param.ident.name));\n+                    }\n+                    GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+                        // Const parameters can't have param bounds.\n+                        assert!(param.bounds.is_empty());\n+\n+                        this.ribs[TypeNS].push(Rib::new(ConstParamTyRibKind));\n+                        this.ribs[ValueNS].push(Rib::new(ConstParamTyRibKind));\n+                        this.visit_ty(ty);\n+                        this.ribs[TypeNS].pop().unwrap();\n+                        this.ribs[ValueNS].pop().unwrap();\n+\n+                        if let Some(ref expr) = default {\n+                            this.ribs[TypeNS].push(forward_ty_ban_rib);\n+                            this.ribs[ValueNS].push(forward_const_ban_rib);\n+                            this.visit_anon_const(expr);\n+                            forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n+                            forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n+                        }\n+\n+                        // Allow all following defaults to refer to this const parameter.\n+                        forward_const_ban_rib\n+                            .bindings\n+                            .remove(&Ident::with_dummy_span(param.ident.name));\n+                    }\n+                }\n+            }\n+        })\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self, work))]\n+    fn with_lifetime_rib<T>(\n+        &mut self,\n+        kind: LifetimeRibKind,\n+        work: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        self.lifetime_ribs.push(LifetimeRib::new(kind));\n+        let ret = work(self);\n+        self.lifetime_ribs.pop();\n+        ret\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        let ident = lifetime.ident;\n+\n+        if ident.name == kw::StaticLifetime {\n+            return;\n+        }\n+\n+        if ident.name == kw::UnderscoreLifetime {\n+            return self.resolve_anonymous_lifetime(lifetime, false);\n+        }\n+\n+        let mut indices = (0..self.lifetime_ribs.len()).rev();\n+        for i in &mut indices {\n+            let rib = &self.lifetime_ribs[i];\n+            let normalized_ident = ident.normalize_to_macros_2_0();\n+            if let Some(_) = rib.bindings.get_key_value(&normalized_ident) {\n+                return;\n+            }\n+\n+            if let LifetimeRibKind::Item = rib.kind {\n+                break;\n+            }\n+        }\n+\n+        let mut outer_res = None;\n+        for i in indices {\n+            let rib = &self.lifetime_ribs[i];\n+            let normalized_ident = ident.normalize_to_macros_2_0();\n+            if let Some((&outer, _)) = rib.bindings.get_key_value(&normalized_ident) {\n+                outer_res = Some(outer);\n+                break;\n+            }\n+        }\n+\n+        self.emit_undeclared_lifetime_error(lifetime, outer_res);\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_anonymous_lifetime(&mut self, lifetime: &Lifetime, elided: bool) {\n+        debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n+\n+        for i in (0..self.lifetime_ribs.len()).rev() {\n+            let rib = &mut self.lifetime_ribs[i];\n+            match rib.kind {\n+                LifetimeRibKind::AnonymousReportError => {\n+                    let (msg, note) = if elided {\n+                        (\n+                            \"`&` without an explicit lifetime name cannot be used here\",\n+                            \"explicit lifetime name needed here\",\n+                        )\n+                    } else {\n+                        (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n+                    };\n+                    rustc_errors::struct_span_err!(\n+                        self.r.session,\n+                        lifetime.ident.span,\n+                        E0637,\n+                        \"{}\",\n+                        msg,\n+                    )\n+                    .span_label(lifetime.ident.span, note)\n+                    .emit();\n+\n+                    return;\n+                }\n+                LifetimeRibKind::AnonymousCreateParameter\n+                | LifetimeRibKind::AnonymousPassThrough\n+                | LifetimeRibKind::Item => return,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_elided_lifetime(&mut self, anchor_id: NodeId, span: Span) {\n+        let id = self.r.next_node_id();\n+        let lt = Lifetime { id, ident: Ident::new(kw::UnderscoreLifetime, span) };\n+        self.resolve_anonymous_lifetime(&lt, true);\n+    }\n+\n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n     /// label and reports an error if the label is not found or is unreachable.\n     fn resolve_label(&self, mut label: Ident) -> Option<NodeId> {\n@@ -950,15 +1247,20 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_adt(&mut self, item: &'ast Item, generics: &'ast Generics) {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n-            this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                let item_def_id = this.r.local_def_id(item.id).to_def_id();\n-                this.with_self_rib(\n-                    Res::SelfTy { trait_: None, alias_to: Some((item_def_id, false)) },\n-                    |this| {\n-                        visit::walk_item(this, item);\n-                    },\n-                );\n-            });\n+            this.with_generic_param_rib(\n+                &generics.params,\n+                ItemRibKind(HasGenericParams::Yes),\n+                LifetimeRibKind::Generics { kind: LifetimeBinderKind::Item, span: generics.span },\n+                |this| {\n+                    let item_def_id = this.r.local_def_id(item.id).to_def_id();\n+                    this.with_self_rib(\n+                        Res::SelfTy { trait_: None, alias_to: Some((item_def_id, false)) },\n+                        |this| {\n+                            visit::walk_item(this, item);\n+                        },\n+                    );\n+                },\n+            );\n         });\n     }\n \n@@ -1010,11 +1312,28 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n         match item.kind {\n-            ItemKind::TyAlias(box TyAlias { ref generics, .. })\n-            | ItemKind::Fn(box Fn { ref generics, .. }) => {\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    visit::walk_item(this, item)\n-                });\n+            ItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_item(this, item),\n+                );\n+            }\n+\n+            ItemKind::Fn(box Fn { ref generics, .. }) => {\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Function,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_item(this, item),\n+                );\n             }\n \n             ItemKind::Enum(_, ref generics)\n@@ -1035,64 +1354,108 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ItemKind::Trait(box Trait { ref generics, ref bounds, ref items, .. }) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let def = this.r.local_def_id(item.id).to_def_id();\n-                    this.with_self_rib(Res::SelfTy { trait_: Some(def), alias_to: None }, |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-\n-                        let walk_assoc_item = |this: &mut Self, generics, item| {\n-                            this.with_generic_param_rib(generics, AssocItemRibKind, |this| {\n-                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n-                            });\n-                        };\n-\n-                        this.with_trait_items(items, |this| {\n-                            for item in items {\n-                                match &item.kind {\n-                                    AssocItemKind::Const(_, ty, default) => {\n-                                        this.visit_ty(ty);\n-                                        // Only impose the restrictions of `ConstRibKind` for an\n-                                        // actual constant expression in a provided default.\n-                                        if let Some(expr) = default {\n-                                            // We allow arbitrary const expressions inside of associated consts,\n-                                            // even if they are potentially not const evaluatable.\n-                                            //\n-                                            // Type parameters can already be used and as associated consts are\n-                                            // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(\n-                                                IsRepeatExpr::No,\n-                                                true,\n-                                                None,\n-                                                |this| this.visit_expr(expr),\n-                                            );\n-                                        }\n-                                    }\n-                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                        walk_assoc_item(this, generics, item);\n-                                    }\n-                                    AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n-                                        walk_assoc_item(this, generics, item);\n-                                    }\n-                                    AssocItemKind::MacCall(_) => {\n-                                        panic!(\"unexpanded macro in resolve!\")\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| {\n+                        let local_def_id = this.r.local_def_id(item.id).to_def_id();\n+                        this.with_self_rib(\n+                            Res::SelfTy { trait_: Some(local_def_id), alias_to: None },\n+                            |this| {\n+                                this.visit_generics(generics);\n+                                walk_list!(this, visit_param_bound, bounds);\n+\n+                                let walk_assoc_item =\n+                                    |this: &mut Self,\n+                                     generics: &Generics,\n+                                     kind,\n+                                     item: &'ast AssocItem| {\n+                                        this.with_generic_param_rib(\n+                                            &generics.params,\n+                                            AssocItemRibKind,\n+                                            LifetimeRibKind::Generics { span: generics.span, kind },\n+                                            |this| {\n+                                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n+                                            },\n+                                        );\n+                                    };\n+\n+                                this.with_trait_items(items, |this| {\n+                                    for item in items {\n+                                        match &item.kind {\n+                                            AssocItemKind::Const(_, ty, default) => {\n+                                                this.visit_ty(ty);\n+                                                // Only impose the restrictions of `ConstRibKind` for an\n+                                                // actual constant expression in a provided default.\n+                                                if let Some(expr) = default {\n+                                                    // We allow arbitrary const expressions inside of associated consts,\n+                                                    // even if they are potentially not const evaluatable.\n+                                                    //\n+                                                    // Type parameters can already be used and as associated consts are\n+                                                    // not used as part of the type system, this is far less surprising.\n+                                                    this.with_constant_rib(\n+                                                        IsRepeatExpr::No,\n+                                                        true,\n+                                                        None,\n+                                                        |this| this.visit_expr(expr),\n+                                                    );\n+                                                }\n+                                            }\n+                                            AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                                                walk_assoc_item(\n+                                                    this,\n+                                                    generics,\n+                                                    LifetimeBinderKind::Function,\n+                                                    item,\n+                                                );\n+                                            }\n+                                            AssocItemKind::TyAlias(box TyAlias {\n+                                                generics,\n+                                                ..\n+                                            }) => {\n+                                                walk_assoc_item(\n+                                                    this,\n+                                                    generics,\n+                                                    LifetimeBinderKind::Item,\n+                                                    item,\n+                                                );\n+                                            }\n+                                            AssocItemKind::MacCall(_) => {\n+                                                panic!(\"unexpanded macro in resolve!\")\n+                                            }\n+                                        };\n                                     }\n-                                };\n-                            }\n-                        });\n-                    });\n-                });\n+                                });\n+                            },\n+                        );\n+                    },\n+                );\n             }\n \n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let def = this.r.local_def_id(item.id).to_def_id();\n-                    this.with_self_rib(Res::SelfTy { trait_: Some(def), alias_to: None }, |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-                    });\n-                });\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| {\n+                        let local_def_id = this.r.local_def_id(item.id).to_def_id();\n+                        this.with_self_rib(\n+                            Res::SelfTy { trait_: Some(local_def_id), alias_to: None },\n+                            |this| {\n+                                this.visit_generics(generics);\n+                                walk_list!(this, visit_param_bound, bounds);\n+                            },\n+                        );\n+                    },\n+                );\n             }\n \n             ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n@@ -1102,7 +1465,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n-                self.with_item_rib(HasGenericParams::No, |this| {\n+                self.with_item_rib(|this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n                         let constant_item_kind = match item.kind {\n@@ -1138,13 +1501,19 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n-    fn with_generic_param_rib<'c, F>(&'c mut self, generics: &'c Generics, kind: RibKind<'a>, f: F)\n-    where\n+    fn with_generic_param_rib<'c, F>(\n+        &'c mut self,\n+        params: &'c Vec<GenericParam>,\n+        kind: RibKind<'a>,\n+        lifetime_kind: LifetimeRibKind,\n+        f: F,\n+    ) where\n         F: FnOnce(&mut Self),\n     {\n         debug!(\"with_generic_param_rib\");\n         let mut function_type_rib = Rib::new(kind);\n         let mut function_value_rib = Rib::new(kind);\n+        let mut function_lifetime_rib = LifetimeRib::new(lifetime_kind);\n         let mut seen_bindings = FxHashMap::default();\n \n         // We also can't shadow bindings from the parent item\n@@ -1161,43 +1530,73 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             add_bindings_for_ns(TypeNS);\n         }\n \n-        for param in &generics.params {\n-            if let GenericParamKind::Lifetime = param.kind {\n-                continue;\n-            }\n-\n+        for param in params {\n             let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n             match seen_bindings.entry(ident) {\n                 Entry::Occupied(entry) => {\n                     let span = *entry.get();\n                     let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n-                    self.report_error(param.ident.span, err);\n+                    if !matches!(param.kind, GenericParamKind::Lifetime) {\n+                        self.report_error(param.ident.span, err);\n+                    }\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(param.ident.span);\n                 }\n             }\n \n+            if param.ident.name == kw::UnderscoreLifetime {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    param.ident.span,\n+                    E0637,\n+                    \"`'_` cannot be used here\"\n+                )\n+                .span_label(param.ident.span, \"`'_` is a reserved lifetime name\")\n+                .emit();\n+                continue;\n+            }\n+\n+            if param.ident.name == kw::StaticLifetime {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    param.ident.span,\n+                    E0262,\n+                    \"invalid lifetime parameter name: `{}`\",\n+                    param.ident,\n+                )\n+                .span_label(param.ident.span, format!(\"'static is a reserved lifetime name\"))\n+                .emit();\n+                continue;\n+            }\n+\n+            let def_id = self.r.local_def_id(param.id);\n+\n             // Plain insert (no renaming).\n             let (rib, def_kind) = match param.kind {\n                 GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n                 GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n-                _ => unreachable!(),\n+                GenericParamKind::Lifetime => {\n+                    function_lifetime_rib.bindings.insert(ident, ());\n+                    continue;\n+                }\n             };\n-            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n+            let res = Res::Def(def_kind, def_id.to_def_id());\n             self.r.record_partial_res(param.id, PartialRes::new(res));\n             rib.bindings.insert(ident, res);\n         }\n \n+        self.lifetime_ribs.push(function_lifetime_rib);\n         self.ribs[ValueNS].push(function_value_rib);\n         self.ribs[TypeNS].push(function_type_rib);\n \n         f(self);\n \n         self.ribs[TypeNS].pop();\n         self.ribs[ValueNS].pop();\n+        self.lifetime_ribs.pop();\n     }\n \n     fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n@@ -1206,9 +1605,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib(&mut self, has_generic_params: HasGenericParams, f: impl FnOnce(&mut Self)) {\n-        let kind = ItemRibKind(has_generic_params);\n-        self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n+    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+        let kind = ItemRibKind(HasGenericParams::No);\n+        self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+            this.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n+        })\n     }\n \n     // HACK(min_const_generics,const_evaluatable_unchecked): We\n@@ -1319,128 +1720,137 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n+        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::ImplBlock }, |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n-                // Resolve the trait reference, if necessary.\n-                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.r.local_def_id(item_id);\n-\n-                    // Register the trait definitions from here.\n-                    if let Some(trait_id) = trait_id {\n-                        this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n-                    }\n-\n-                    let item_def_id = item_def_id.to_def_id();\n-                    let res =\n-                        Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n-                    this.with_self_rib(res, |this| {\n-                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n-                            // Resolve type arguments in the trait path.\n-                            visit::walk_trait_ref(this, trait_ref);\n+                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n+                    // Resolve the trait reference, if necessary.\n+                    this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n+                        let item_def_id = this.r.local_def_id(item_id);\n+\n+                        // Register the trait definitions from here.\n+                        if let Some(trait_id) = trait_id {\n+                            this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n                         }\n-                        // Resolve the self type.\n-                        this.visit_ty(self_type);\n-                        // Resolve the generic parameters.\n-                        this.visit_generics(generics);\n-                        // Resolve the items within the impl.\n-                        this.with_current_self_type(self_type, |this| {\n-                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n-                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                for item in impl_items {\n-                                    use crate::ResolutionError::*;\n-                                    match &item.kind {\n-                                        AssocItemKind::Const(_default, _ty, _expr) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::Const\");\n-                                            // If this is a trait impl, ensure the const\n-                                            // exists in trait\n-                                            this.check_trait_item(\n-                                                item.id,\n-                                                item.ident,\n-                                                &item.kind,\n-                                                ValueNS,\n-                                                item.span,\n-                                                |i, s, c| ConstNotMemberOfTrait(i, s, c),\n-                                            );\n-\n-                                            // We allow arbitrary const expressions inside of associated consts,\n-                                            // even if they are potentially not const evaluatable.\n-                                            //\n-                                            // Type parameters can already be used and as associated consts are\n-                                            // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(\n-                                                IsRepeatExpr::No,\n-                                                true,\n-                                                None,\n-                                                |this| {\n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::Fn\");\n-                                            // We also need a new scope for the impl item type parameters.\n-                                            this.with_generic_param_rib(\n-                                                generics,\n-                                                AssocItemRibKind,\n-                                                |this| {\n-                                                    // If this is a trait impl, ensure the method\n-                                                    // exists in trait\n-                                                    this.check_trait_item(\n-                                                        item.id,\n-                                                        item.ident,\n-                                                        &item.kind,\n-                                                        ValueNS,\n-                                                        item.span,\n-                                                        |i, s, c| MethodNotMemberOfTrait(i, s, c),\n-                                                    );\n-\n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::TyAlias(box TyAlias {\n-                                            generics, ..\n-                                        }) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n-                                            // We also need a new scope for the impl item type parameters.\n-                                            this.with_generic_param_rib(\n-                                                generics,\n-                                                AssocItemRibKind,\n-                                                |this| {\n-                                                    // If this is a trait impl, ensure the type\n-                                                    // exists in trait\n-                                                    this.check_trait_item(\n-                                                        item.id,\n-                                                        item.ident,\n-                                                        &item.kind,\n-                                                        TypeNS,\n-                                                        item.span,\n-                                                        |i, s, c| TypeNotMemberOfTrait(i, s, c),\n-                                                    );\n \n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::MacCall(_) => {\n-                                            panic!(\"unexpanded macro in resolve!\")\n-                                        }\n-                                    }\n-                                }\n-                            });\n+                        let item_def_id = item_def_id.to_def_id();\n+                        let res =\n+                            Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n+                        this.with_self_rib(res, |this| {\n+                            if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                                // Resolve type arguments in the trait path.\n+                                visit::walk_trait_ref(this, trait_ref);\n+                            }\n+                            // Resolve the self type.\n+                            this.visit_ty(self_type);\n+                            // Resolve the generic parameters.\n+                            this.visit_generics(generics);\n+\n+                            // Resolve the items within the impl.\n+                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough,\n+                                |this| {\n+                                    this.with_current_self_type(self_type, |this| {\n+                                        this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                            debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n+                                            for item in impl_items {\n+                                                use crate::ResolutionError::*;\n+                                                match &item.kind {\n+                                                    AssocItemKind::Const(_default, _ty, _expr) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::Const\");\n+                                                        // If this is a trait impl, ensure the const\n+                                                        // exists in trait\n+                                                        this.check_trait_item(\n+                                                            item.id,\n+                                                            item.ident,\n+                                                            &item.kind,\n+                                                            ValueNS,\n+                                                            item.span,\n+                                                            |i, s, c| ConstNotMemberOfTrait(i, s, c),\n+                                                        );\n+\n+                                                        // We allow arbitrary const expressions inside of associated consts,\n+                                                        // even if they are potentially not const evaluatable.\n+                                                        //\n+                                                        // Type parameters can already be used and as associated consts are\n+                                                        // not used as part of the type system, this is far less surprising.\n+                                                        this.with_constant_rib(\n+                                                            IsRepeatExpr::No,\n+                                                            true,\n+                                                            None,\n+                                                            |this| {\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::Fn\");\n+                                                        // We also need a new scope for the impl item type parameters.\n+                                                        this.with_generic_param_rib(\n+                                                            &generics.params,\n+                                                            AssocItemRibKind,\n+                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Function },\n+                                                            |this| {\n+                                                                // If this is a trait impl, ensure the method\n+                                                                // exists in trait\n+                                                                this.check_trait_item(\n+                                                                    item.id,\n+                                                                    item.ident,\n+                                                                    &item.kind,\n+                                                                    ValueNS,\n+                                                                    item.span,\n+                                                                    |i, s, c| MethodNotMemberOfTrait(i, s, c),\n+                                                                );\n+\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::TyAlias(box TyAlias {\n+                                                        generics, ..\n+                                                    }) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n+                                                        // We also need a new scope for the impl item type parameters.\n+                                                        this.with_generic_param_rib(\n+                                                            &generics.params,\n+                                                            AssocItemRibKind,\n+                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Item },\n+                                                            |this| {\n+                                                                // If this is a trait impl, ensure the type\n+                                                                // exists in trait\n+                                                                this.check_trait_item(\n+                                                                    item.id,\n+                                                                    item.ident,\n+                                                                    &item.kind,\n+                                                                    TypeNS,\n+                                                                    item.span,\n+                                                                    |i, s, c| TypeNotMemberOfTrait(i, s, c),\n+                                                                );\n+\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::MacCall(_) => {\n+                                                        panic!(\"unexpanded macro in resolve!\")\n+                                                    }\n+                                                }\n+                                            }\n+                                        });\n+                                    });\n+                                },\n+                            );\n                         });\n                     });\n                 });"}, {"sha": "51a35f8f26db37a61ac2427901f8c065fadec9fa", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 96, "deletions": 60, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=fc9f25531a3681f0644267eb954d51f4b22ff5b7", "patch": "@@ -1,6 +1,7 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n+use crate::late::{LifetimeBinderKind, LifetimeRibKind};\n use crate::path_names_to_string;\n use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n@@ -1793,83 +1794,118 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             (*ident, within_scope)\n         })\n     }\n-}\n \n-impl<'tcx> LifetimeContext<'_, 'tcx> {\n-    crate fn report_missing_lifetime_specifiers(\n+    crate fn emit_undeclared_lifetime_error(\n         &self,\n-        spans: Vec<Span>,\n-        count: usize,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            self.tcx.sess,\n-            spans,\n-            E0106,\n-            \"missing lifetime specifier{}\",\n-            pluralize!(count)\n-        )\n-    }\n+        lifetime_ref: &ast::Lifetime,\n+        outer_lifetime_ref: Option<Ident>,\n+    ) {\n+        debug_assert_ne!(lifetime_ref.ident.name, kw::UnderscoreLifetime);\n+        let mut err = if let Some(outer) = outer_lifetime_ref {\n+            let mut err = struct_span_err!(\n+                self.r.session,\n+                lifetime_ref.ident.span,\n+                E0401,\n+                \"can't use generic parameters from outer item\",\n+            );\n+            err.span_label(lifetime_ref.ident.span, \"use of generic parameter from outer item\");\n+            err.span_label(outer.span, \"lifetime parameter from outer item\");\n+            err\n+        } else {\n+            let mut err = struct_span_err!(\n+                self.r.session,\n+                lifetime_ref.ident.span,\n+                E0261,\n+                \"use of undeclared lifetime name `{}`\",\n+                lifetime_ref.ident\n+            );\n+            err.span_label(lifetime_ref.ident.span, \"undeclared lifetime\");\n+            err\n+        };\n+        let mut suggest_note = true;\n \n-    crate fn emit_undeclared_lifetime_error(&self, lifetime_ref: &hir::Lifetime) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            lifetime_ref.span,\n-            E0261,\n-            \"use of undeclared lifetime name `{}`\",\n-            lifetime_ref\n-        );\n-        err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n-        let mut suggested_spans = vec![];\n-        for missing in &self.missing_named_lifetime_spots {\n-            match missing {\n-                MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) = generics.params.iter().find(|p| {\n-                        !matches!(\n-                            p.kind,\n-                            hir::GenericParamKind::Type { synthetic: true, .. }\n-                                | hir::GenericParamKind::Lifetime {\n-                                    kind: hir::LifetimeParamKind::Elided,\n-                                }\n-                        )\n-                    }) {\n-                        (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n-                    } else {\n-                        (generics.span, format!(\"<{}>\", lifetime_ref))\n-                    };\n-                    if suggested_spans.contains(&span) {\n+        for rib in self.lifetime_ribs.iter().rev() {\n+            match rib.kind {\n+                LifetimeRibKind::Generics { span, kind } => {\n+                    if !span.can_be_used_for_suggestions() && suggest_note {\n+                        suggest_note = false; // Avoid displaying the same help multiple times.\n+                        err.span_label(\n+                            span,\n+                            &format!(\n+                                \"lifetime `{}` is missing in item created through this procedural macro\",\n+                                lifetime_ref.ident,\n+                            ),\n+                        );\n                         continue;\n                     }\n-                    suggested_spans.push(span);\n-                    if span.can_be_used_for_suggestions() {\n+\n+                    let higher_ranked = matches!(\n+                        kind,\n+                        LifetimeBinderKind::BareFnType\n+                            | LifetimeBinderKind::PolyTrait\n+                            | LifetimeBinderKind::WhereBound\n+                    );\n+                    let (span, sugg) = if span.is_empty() {\n+                        let sugg = format!(\n+                            \"{}<{}>{}\",\n+                            if higher_ranked { \"for\" } else { \"\" },\n+                            lifetime_ref.ident,\n+                            if higher_ranked { \" \" } else { \"\" },\n+                        );\n+                        (span, sugg)\n+                    } else {\n+                        let span =\n+                            self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n+                        let sugg = format!(\"{}, \", lifetime_ref.ident);\n+                        (span, sugg)\n+                    };\n+                    if higher_ranked {\n                         err.span_suggestion(\n                             span,\n-                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n+                            &format!(\n+                                \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                                kind.descr(),\n+                                lifetime_ref\n+                            ),\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.note_once(\n+                            \"for more information on higher-ranked polymorphism, visit \\\n+                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                        );\n+                    } else {\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref.ident),\n                             sugg,\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                 }\n-                MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                    err.span_suggestion(\n-                        *span,\n-                        &format!(\n-                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                            span_type.descr(),\n-                            lifetime_ref\n-                        ),\n-                        span_type.suggestion(&lifetime_ref.to_string()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.note(\n-                        \"for more information on higher-ranked polymorphism, visit \\\n-                         https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                    );\n-                }\n+                LifetimeRibKind::Item => break,\n                 _ => {}\n             }\n         }\n+\n         err.emit();\n     }\n+}\n+\n+impl<'tcx> LifetimeContext<'_, 'tcx> {\n+    crate fn report_missing_lifetime_specifiers(\n+        &self,\n+        spans: Vec<Span>,\n+        count: usize,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        struct_span_err!(\n+            self.tcx.sess,\n+            spans,\n+            E0106,\n+            \"missing lifetime specifier{}\",\n+            pluralize!(count)\n+        )\n+    }\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     crate fn report_elision_failure("}, {"sha": "72ca9918e122f25ce5466b5e1d59b6cfa0a880fa", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=fc9f25531a3681f0644267eb954d51f4b22ff5b7", "patch": "@@ -2312,7 +2312,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n-            self.emit_undeclared_lifetime_error(lifetime_ref);\n+            self.tcx.sess.delay_span_bug(\n+                lifetime_ref.span,\n+                &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n+            );\n         }\n     }\n \n@@ -3119,18 +3122,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n                 if name == kw::UnderscoreLifetime || name == kw::StaticLifetime {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        lifetime_i.span,\n-                        E0262,\n-                        \"invalid lifetime parameter name: `{}`\",\n-                        lifetime_i.name.ident(),\n-                    );\n-                    err.span_label(\n+                    self.tcx.sess.delay_span_bug(\n                         lifetime_i.span,\n-                        format!(\"{} is a reserved lifetime name\", name),\n+                        &format!(\"invalid lifetime parameter name: `{}`\", lifetime_i.name.ident()),\n                     );\n-                    err.emit();\n                 }\n             }\n "}, {"sha": "7262d150f4c2cd521ddfbc4aac7f398a238ef1c1", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f25531a3681f0644267eb954d51f4b22ff5b7/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=fc9f25531a3681f0644267eb954d51f4b22ff5b7", "patch": "@@ -11,6 +11,7 @@\n #![feature(drain_filter)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n@@ -1358,9 +1359,17 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn next_node_id(&mut self) -> NodeId {\n-        let next =\n-            self.next_node_id.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n-        mem::replace(&mut self.next_node_id, ast::NodeId::from_u32(next))\n+        let start = self.next_node_id;\n+        let next = start.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_u32(next);\n+        start\n+    }\n+\n+    pub fn next_node_ids(&mut self, count: usize) -> std::ops::Range<NodeId> {\n+        let start = self.next_node_id;\n+        let end = start.as_usize().checked_add(count).expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_usize(end);\n+        start..self.next_node_id\n     }\n \n     pub fn lint_buffer(&mut self) -> &mut LintBuffer {"}]}