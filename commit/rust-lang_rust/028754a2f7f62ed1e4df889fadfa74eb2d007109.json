{"sha": "028754a2f7f62ed1e4df889fadfa74eb2d007109", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyODc1NGEyZjdmNjJlZDFlNGRmODg5ZmFkZmE3NGViMmQwMDcxMDk=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-21T18:34:45Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-12-09T20:31:37Z"}, "message": "implement better availability probing for copy_file_range\n\npreviously any attempt to copy to an immutable file (EPERM) would disable\ncopy_file_range support for the whole process.", "tree": {"sha": "3954787535efd7161b9bed56175f2779eae23b30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3954787535efd7161b9bed56175f2779eae23b30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028754a2f7f62ed1e4df889fadfa74eb2d007109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028754a2f7f62ed1e4df889fadfa74eb2d007109", "html_url": "https://github.com/rust-lang/rust/commit/028754a2f7f62ed1e4df889fadfa74eb2d007109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028754a2f7f62ed1e4df889fadfa74eb2d007109/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16d52db7778fba1c8b6c07b06510cfd6c32ae4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16d52db7778fba1c8b6c07b06510cfd6c32ae4f", "html_url": "https://github.com/rust-lang/rust/commit/c16d52db7778fba1c8b6c07b06510cfd6c32ae4f"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "56efc93a1e2883a3105f06cb9daefb05f4429f41", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/028754a2f7f62ed1e4df889fadfa74eb2d007109/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028754a2f7f62ed1e4df889fadfa74eb2d007109/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=028754a2f7f62ed1e4df889fadfa74eb2d007109", "patch": "@@ -59,7 +59,7 @@ use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n use crate::os::unix::net::UnixStream;\n use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n use crate::sys::cvt;\n \n #[cfg(test)]\n@@ -491,6 +491,13 @@ impl CopyResult {\n     }\n }\n \n+/// Invalid file descriptor.\n+///\n+/// Valid file descriptors are guaranteed to be positive numbers (see `open()` manpage)\n+/// while negative values are used to indicate errors.\n+/// Thus -1 will never be overlap with a valid open file.\n+const INVALID_FD: RawFd = -1;\n+\n /// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n /// as the name says, it only works on regular files\n ///\n@@ -500,9 +507,13 @@ impl CopyResult {\n pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n     use crate::cmp;\n \n+    const NOT_PROBED: u8 = 0;\n+    const UNAVAILABLE: u8 = 1;\n+    const AVAILABLE: u8 = 2;\n+\n     // Kernel prior to 4.5 don't have copy_file_range\n     // We store the availability in a global to avoid unnecessary syscalls\n-    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n+    static HAS_COPY_FILE_RANGE: AtomicU8 = AtomicU8::new(NOT_PROBED);\n \n     syscall! {\n         fn copy_file_range(\n@@ -515,39 +526,39 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n         ) -> libc::ssize_t\n     }\n \n-    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n-    let mut written = 0u64;\n-    while written < max_len {\n-        let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n-            // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n-            // this allows us to copy large chunks without hitting EOVERFLOW,\n-            // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n-            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n-            let copy_result = unsafe {\n-                // We actually don't have to adjust the offsets,\n-                // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(\n-                    reader,\n-                    ptr::null_mut(),\n-                    writer,\n-                    ptr::null_mut(),\n-                    bytes_to_copy,\n-                    0,\n-                ))\n+    match HAS_COPY_FILE_RANGE.load(Ordering::Relaxed) {\n+        NOT_PROBED => {\n+            // EPERM can indicate seccomp filters or an immutable file.\n+            // To distinguish these cases we probe with invalid file descriptors which should result in EBADF if the syscall is supported\n+            // and some other error (ENOSYS or EPERM) if it's not available\n+            let result = unsafe {\n+                cvt(copy_file_range(INVALID_FD, ptr::null_mut(), INVALID_FD, ptr::null_mut(), 1, 0))\n             };\n-            if let Err(ref copy_err) = copy_result {\n-                match copy_err.raw_os_error() {\n-                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n-                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n-                    }\n-                    _ => {}\n-                }\n+\n+            if matches!(result.map_err(|e| e.raw_os_error()), Err(Some(libc::EBADF))) {\n+                HAS_COPY_FILE_RANGE.store(AVAILABLE, Ordering::Relaxed);\n+            } else {\n+                HAS_COPY_FILE_RANGE.store(UNAVAILABLE, Ordering::Relaxed);\n+                return CopyResult::Fallback(0);\n             }\n-            copy_result\n-        } else {\n-            Err(Error::from_raw_os_error(libc::ENOSYS))\n+        }\n+        UNAVAILABLE => return CopyResult::Fallback(0),\n+        _ => {}\n+    };\n+\n+    let mut written = 0u64;\n+    while written < max_len {\n+        let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n+        // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n+        // this allows us to copy large chunks without hitting EOVERFLOW,\n+        // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n+        let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n+        let copy_result = unsafe {\n+            // We actually don't have to adjust the offsets,\n+            // because copy_file_range adjusts the file offset automatically\n+            cvt(copy_file_range(reader, ptr::null_mut(), writer, ptr::null_mut(), bytes_to_copy, 0))\n         };\n+\n         match copy_result {\n             Ok(0) if written == 0 => {\n                 // fallback to work around several kernel bugs where copy_file_range will fail to\n@@ -567,11 +578,14 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n                     ) => {\n                         // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n+                        // - Kernel version is < 4.5 (ENOSYS\u00b9)\n                         // - Files are mounted on different fs (EXDEV)\n                         // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                        // - copy_file_range file is immutable or syscall is blocked by seccomp\u00b9 (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                        //\n+                        // \u00b9 these cases should be detected by the initial probe but we handle them here\n+                        //   anyway in case syscall interception changes during runtime\n                         assert_eq!(written, 0);\n                         CopyResult::Fallback(0)\n                     }"}]}