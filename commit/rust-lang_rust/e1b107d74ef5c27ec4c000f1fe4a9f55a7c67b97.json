{"sha": "e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYjEwN2Q3NGVmNWMyN2VjNGMwMDBmMWZlNGE5ZjU1YTdjNjdiOTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-07T22:31:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-08T01:39:05Z"}, "message": "rustc: Remove all exterior vectors from the AST", "tree": {"sha": "3fb5b61494d04031acf71fe90353b0db043daf28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fb5b61494d04031acf71fe90353b0db043daf28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "html_url": "https://github.com/rust-lang/rust/commit/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3958c72cd8c899bfc77a56ad859e31e13615c1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3958c72cd8c899bfc77a56ad859e31e13615c1c5", "html_url": "https://github.com/rust-lang/rust/commit/3958c72cd8c899bfc77a56ad859e31e13615c1c5"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "96f3bbb17438e44df881f670de9dabb002a1c03a", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -36,9 +36,9 @@ fn filter_item(&ast::crate_cfg cfg,\n fn fold_mod(&ast::crate_cfg cfg, &ast::_mod m,\n               fold::ast_fold fld) -> ast::_mod {\n     auto filter = bind filter_item(cfg, _);\n-    auto filtered_items = vec::filter_map(filter, m.items);\n-    ret rec(view_items=vec::map(fld.fold_view_item, m.view_items),\n-            items=vec::map(fld.fold_item, filtered_items));\n+    auto filtered_items = ivec::filter_map(filter, m.items);\n+    ret rec(view_items=ivec::map(fld.fold_view_item, m.view_items),\n+            items=ivec::map(fld.fold_item, filtered_items));\n }\n \n fn filter_native_item(&ast::crate_cfg cfg, &@ast::native_item item)\n@@ -53,10 +53,10 @@ fn filter_native_item(&ast::crate_cfg cfg, &@ast::native_item item)\n fn fold_native_mod(&ast::crate_cfg cfg, &ast::native_mod nm,\n                    fold::ast_fold fld) -> ast::native_mod {\n     auto filter = bind filter_native_item(cfg, _);\n-    auto filtered_items = vec::filter_map(filter, nm.items);\n+    auto filtered_items = ivec::filter_map(filter, nm.items);\n     ret rec(native_name=nm.native_name,\n             abi=nm.abi,\n-            view_items=vec::map(fld.fold_view_item, nm.view_items),\n+            view_items=ivec::map(fld.fold_view_item, nm.view_items),\n             items=filtered_items);\n }\n "}, {"sha": "0f93e61a4104c54d3a3d236688d97101f66a0259", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -50,14 +50,12 @@ fn fold_crate(&test_ctxt cx, &ast::crate_ c,\n \n fn add_test_module(&test_ctxt cx, &ast::_mod m) -> ast::_mod {\n     auto testmod = mk_test_module(cx);\n-    ret rec(items = m.items + [testmod]\n-            with m);\n+    ret rec(items=m.items + ~[testmod] with m);\n }\n \n fn mk_test_module(&test_ctxt cx) -> @ast::item {\n     auto mainfn = mk_main(cx);\n-    let ast::_mod testmod = rec(view_items = [],\n-                                items = [mainfn]);\n+    let ast::_mod testmod = rec(view_items=~[], items=~[mainfn]);\n     auto item_ = ast::item_mod(testmod);\n     let ast::item item = rec(ident = \"__test\",\n                              attrs = ~[],"}, {"sha": "cbb89cdda120620763c904a3c91c396b1acf7cfb", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -216,7 +216,7 @@ fn encode_tag_variant_info(&@crate_ctxt cx, &ebml::writer ebml_w,\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n         encode_type(cx, ebml_w, node_id_to_monotype(cx.tcx, variant.node.id));\n-        if (vec::len[variant_arg](variant.node.args) > 0u) {\n+        if (ivec::len[variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);"}, {"sha": "d6d9a8e098b6be3804ac1305839548658b634c81", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -382,25 +382,23 @@ fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n     visit::visit_expr(x, new_sc, v);\n }\n \n-fn follow_import(&env e, &scopes sc,\n-                 vec[ident] path, &span sp) -> option::t[def] {\n-    auto path_len = vec::len(path);\n+fn follow_import(&env e, &scopes sc, &ident[] path, &span sp)\n+        -> option::t[def] {\n+    auto path_len = ivec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     auto i = 1u;\n     while (true && option::is_some(dcur)) {\n         if (i == path_len) { break; }\n-        dcur =\n-            lookup_in_mod_strict(e, option::get(dcur),\n-                                 sp, path.(i), ns_module, outside);\n+        dcur = lookup_in_mod_strict(e, option::get(dcur),\n+                                    sp, path.(i), ns_module, outside);\n         i += 1u;\n     }\n     if (i == path_len) {\n         alt (option::get(dcur)) {\n             case (ast::def_mod(?def_id)) { ret dcur; }\n             case (ast::def_native_mod(?def_id)) { ret dcur; }\n             case (_) {\n-                e.sess.span_err(sp,\n-                                str::connect(path, \"::\") +\n+                e.sess.span_err(sp, str::connect_ivec(path, \"::\") +\n                                 \" does not name a module.\");\n                 ret none;\n             }\n@@ -457,7 +455,7 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n         }\n     }\n     e.imports.insert(defid._1, resolving(it.span));\n-    auto n_idents = vec::len(ids);\n+    auto n_idents = ivec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n     if (n_idents == 1u) {\n         auto next_sc = std::list::cdr(sc);"}, {"sha": "e6ef2324c8d63bf9eb2234516eb8469dd5d89c76", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -8529,7 +8529,7 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n                      &ast::variant variant, int index, bool is_degen,\n                      &ast::ty_param[] ty_params) {\n-    if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n+    if (std::ivec::len[ast::variant_arg](variant.node.args) == 0u) {\n         ret; // nullary constructors are just constants\n \n     }\n@@ -9043,7 +9043,7 @@ fn collect_tag_ctor(@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n     alt (i.node) {\n         case (ast::item_tag(?variants, ?tps)) {\n             for (ast::variant variant in variants) {\n-                if (vec::len[ast::variant_arg](variant.node.args) != 0u) {\n+                if (std::ivec::len(variant.node.args) != 0u) {\n                     decl_fn_and_pair(ccx, i.span,\n                                      new_pt + [variant.node.name], \"tag\", tps,\n                                      variant.node.id);"}, {"sha": "a848f7267022000ead2a8765b042b0cbc1e65d3e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -2830,8 +2830,7 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> variant_info[] {\n                         auto ctor_ty = node_id_to_monotype\n                             (cx, variant.node.id);\n                         let t[] arg_tys = ~[];\n-                        if (vec::len[ast::variant_arg](variant.node.args) >\n-                                0u) {\n+                        if (std::ivec::len(variant.node.args) > 0u) {\n                             for (arg a in ty_fn_args(cx, ctor_ty)) {\n                                 arg_tys += ~[a.ty];\n                             }"}, {"sha": "1813615d1eb515c217468ca49a9f83c6a5f13abf", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -692,7 +692,7 @@ mod collect {\n             // constructors get turned into functions.\n \n             auto result_ty;\n-            if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n+            if (ivec::len[ast::variant_arg](variant.node.args) == 0u) {\n                 result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()"}, {"sha": "5438a2392b2ad245da93689063456a9409c85b57", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -3,7 +3,6 @@\n import std::ivec;\n import std::option;\n import std::str;\n-import std::vec;\n import codemap::span;\n import codemap::filename;\n \n@@ -481,7 +480,7 @@ type anon_obj =\n         // with_obj: the original object being extended, if it exists.\n         option::t[@expr] with_obj);\n \n-type _mod = rec(vec[@view_item] view_items, vec[@item] items);\n+type _mod = rec((@view_item)[] view_items, (@item)[] items);\n \n tag native_abi {\n     native_abi_rust;\n@@ -493,21 +492,21 @@ tag native_abi {\n type native_mod =\n     rec(str native_name,\n         native_abi abi,\n-        vec[@view_item] view_items,\n-        vec[@native_item] items);\n+        (@view_item)[] view_items,\n+        (@native_item)[] items);\n \n type variant_arg = rec(@ty ty, node_id id);\n \n-type variant_ = rec(str name, vec[variant_arg] args, node_id id);\n+type variant_ = rec(str name, (variant_arg)[] args, node_id id);\n \n type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n \n tag view_item_ {\n     view_item_use(ident, (@meta_item)[], node_id);\n-    view_item_import(ident, vec[ident], node_id);\n-    view_item_import_glob(vec[ident], node_id);\n+    view_item_import(ident, ident[], node_id);\n+    view_item_import_glob(ident[], node_id);\n     view_item_export(ident, node_id);\n }\n "}, {"sha": "01e43d9a36902e9ce43b174829c3e2c1cffb4bda", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -463,15 +463,15 @@ fn noop_fold_fn(&_fn f, ast_fold fld) -> _fn {\n \n // ...nor do modules\n fn noop_fold_mod(&_mod m, ast_fold fld) -> _mod {\n-    ret rec(view_items=map(fld.fold_view_item, m.view_items),\n-            items=map(fld.fold_item, m.items));\n+    ret rec(view_items=ivec::map(fld.fold_view_item, m.view_items),\n+            items=ivec::map(fld.fold_item, m.items));\n }\n \n fn noop_fold_native_mod(&native_mod nm, ast_fold fld) -> native_mod {\n     ret rec(native_name=nm.native_name,\n             abi=nm.abi,\n-            view_items=map(fld.fold_view_item, nm.view_items),\n-            items=map(fld.fold_native_item, nm.items))\n+            view_items=ivec::map(fld.fold_view_item, nm.view_items),\n+            items=ivec::map(fld.fold_native_item, nm.items))\n }\n \n fn noop_fold_variant(&variant_ v, ast_fold fld) -> variant_ {\n@@ -480,7 +480,7 @@ fn noop_fold_variant(&variant_ v, ast_fold fld) -> variant_ {\n     }\n     auto fold_variant_arg = bind fold_variant_arg_(_,fld);\n     ret rec(name=v.name,\n-            args=map(fold_variant_arg, v.args),\n+            args=ivec::map(fold_variant_arg, v.args),\n             id=v.id);\n }\n "}, {"sha": "feaf24d62b060841eb84156160988220410ee9b2", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -25,24 +25,24 @@ type ctx =\n          ast::crate_cfg cfg);\n \n fn eval_crate_directives(ctx cx, &(@ast::crate_directive)[] cdirs,\n-                         str prefix, &mutable vec[@ast::view_item] view_items,\n-                         &mutable vec[@ast::item] items) {\n+                         str prefix, &mutable (@ast::view_item)[] view_items,\n+                         &mutable (@ast::item)[] items) {\n     for (@ast::crate_directive sub_cdir in cdirs) {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n fn eval_crate_directives_to_mod(ctx cx, &(@ast::crate_directive)[] cdirs,\n                                 str prefix) -> ast::_mod {\n-    let vec[@ast::view_item] view_items = [];\n-    let vec[@ast::item] items = [];\n+    let (@ast::view_item)[] view_items = ~[];\n+    let (@ast::item)[] items = ~[];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret rec(view_items=view_items, items=items);\n }\n \n fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n-                        &mutable vec[@ast::view_item] view_items,\n-                        &mutable vec[@ast::item] items) {\n+                        &mutable (@ast::view_item)[] view_items,\n+                        &mutable (@ast::item)[] items) {\n     alt (cdir.node) {\n         case (ast::cdir_src_mod(?id, ?file_opt, ?attrs)) {\n             auto file_path = id + \".rs\";\n@@ -68,7 +68,7 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n                  mod_attrs);\n             // Thread defids and chpos through the parsers\n             cx.chpos = p0.get_chpos();\n-            vec::push[@ast::item](items, i);\n+            items += ~[i];\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs, ?attrs)) {\n             auto path = id;\n@@ -85,11 +85,9 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n                           node=ast::item_mod(m0),\n                           span=cdir.span);\n             cx.sess.next_id += 1;\n-            vec::push[@ast::item](items, i);\n-        }\n-        case (ast::cdir_view_item(?vi)) {\n-            vec::push[@ast::view_item](view_items, vi);\n+            items += ~[i];\n         }\n+        case (ast::cdir_view_item(?vi)) { view_items += ~[vi]; }\n         case (ast::cdir_syntax(?pth)) { }\n         case (ast::cdir_auth(?pth, ?eff)) { }\n     }"}, {"sha": "75235bfb809594320c80284ea33072d554a95a08", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -1859,15 +1859,15 @@ fn parse_mod_items(&parser p, token::token term,\n         parse_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        []\n+        ~[]\n     };\n-    let vec[@ast::item] items = [];\n+    let (@ast::item)[] items = ~[];\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != term) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = ~[];\n         alt (parse_item(p, attrs)) {\n-            case (got_item(?i)) { vec::push(items, i); }\n+            case (got_item(?i)) { items += ~[i]; }\n             case (_) {\n                 p.fatal(\"expected item but found \" +\n                           token::to_str(p.get_reader(), p.peek()));\n@@ -1948,14 +1948,14 @@ fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n         parse_native_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        []\n+        ~[]\n     };\n-    let vec[@ast::native_item] items = [];\n+    let (@ast::native_item)[] items = ~[];\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != token::RBRACE) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = ~[];\n-        items += [parse_native_item(p, attrs)];\n+        items += ~[parse_native_item(p, attrs)];\n     }\n     ret rec(native_name=native_name,\n             abi=abi,\n@@ -2028,7 +2028,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n         expect(p, token::SEMI);\n         auto variant = spanned(ty.span.lo, ty.span.hi,\n                                rec(name=id,\n-                                   args=[rec(ty=ty, id=p.get_id())],\n+                                   args=~[rec(ty=ty, id=p.get_id())],\n                                    id=p.get_id()));\n         ret mk_item(p, lo, ty.span.hi, id,\n                     ast::item_tag(~[variant], ty_params), attrs);\n@@ -2041,14 +2041,14 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                 check_bad_word(p);\n                 auto vlo = p.get_lo_pos();\n                 p.bump();\n-                let vec[ast::variant_arg] args = [];\n+                let ast::variant_arg[] args = ~[];\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto arg_tys =\n                             parse_seq(token::LPAREN, token::RPAREN,\n                                       some(token::COMMA), parse_ty, p);\n                         for (@ast::ty ty in arg_tys.node) {\n-                            args += [rec(ty=ty, id=p.get_id())];\n+                            args += ~[rec(ty=ty, id=p.get_id())];\n                         }\n                     }\n                     case (_) {/* empty */ }\n@@ -2243,7 +2243,7 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n                           option::t[ast::ident] def_ident) ->\n    @ast::view_item {\n     auto lo = p.get_lo_pos();\n-    let vec[ast::ident] identifiers = [first];\n+    let ast::ident[] identifiers = ~[first];\n     let bool glob = false;\n     while (true) {\n         alt (p.peek()) {\n@@ -2255,7 +2255,7 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n             case (_) { p.fatal(\"expecting '::' or ';'\"); }\n         }\n         alt (p.peek()) {\n-            case (token::IDENT(_, _)) { identifiers += [parse_ident(p)]; }\n+            case (token::IDENT(_, _)) { identifiers += ~[parse_ident(p)]; }\n             case (\n                  //the lexer can't tell the different kinds of stars apart ) :\n                  token::BINOP(token::STAR)) {\n@@ -2278,7 +2278,7 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n                 import_decl =\n                     ast::view_item_import_glob(identifiers, p.get_id());\n             } else {\n-                auto len = vec::len(identifiers);\n+                auto len = ivec::len(identifiers);\n                 import_decl =\n                     ast::view_item_import(identifiers.(len - 1u), identifiers,\n                                           p.get_id());\n@@ -2347,15 +2347,15 @@ fn is_view_item(&parser p) -> bool {\n     ret false;\n }\n \n-fn parse_view(&parser p) -> vec[@ast::view_item] {\n-    let vec[@ast::view_item] items = [];\n-    while (is_view_item(p)) { items += [parse_view_item(p)]; }\n+fn parse_view(&parser p) -> (@ast::view_item)[] {\n+    let (@ast::view_item)[] items = ~[];\n+    while (is_view_item(p)) { items += ~[parse_view_item(p)]; }\n     ret items;\n }\n \n-fn parse_native_view(&parser p) -> vec[@ast::view_item] {\n-    let vec[@ast::view_item] items = [];\n-    while (is_view_item(p)) { items += [parse_view_item(p)]; }\n+fn parse_native_view(&parser p) -> (@ast::view_item)[] {\n+    let (@ast::view_item)[] items = ~[];\n+    while (is_view_item(p)) { items += ~[parse_view_item(p)]; }\n     ret items;\n }\n "}, {"sha": "0bcb7f57df313bd9f4ca85101c2f35f2b781329c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "patch": "@@ -465,7 +465,7 @@ fn print_item(&ps s, &@ast::item item) {\n         case (ast::item_tag(?variants, ?params)) {\n             auto newtype = ivec::len(variants) == 1u &&\n                 str::eq(item.ident, variants.(0).node.name) &&\n-                vec::len(variants.(0).node.args) == 1u;\n+                ivec::len(variants.(0).node.args) == 1u;\n             if (newtype) {\n                 ibox(s, indent_unit);\n                 word_space(s, \"tag\");\n@@ -486,13 +486,13 @@ fn print_item(&ps s, &@ast::item item) {\n                     space(s.s);\n                     maybe_print_comment(s, v.span.lo);\n                     word(s.s, v.node.name);\n-                    if (vec::len(v.node.args) > 0u) {\n+                    if (ivec::len(v.node.args) > 0u) {\n                         popen(s);\n                         fn print_variant_arg(&ps s, &ast::variant_arg arg) {\n                             print_type(s, *arg.ty);\n                         }\n-                        commasep(s, consistent, v.node.args,\n-                                 print_variant_arg);\n+                        commasep_ivec(s, consistent, v.node.args,\n+                                      print_variant_arg);\n                         pclose(s);\n                     }\n                     word(s.s, \";\");\n@@ -1161,7 +1161,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n         }\n         case (ast::view_item_import(?id, ?ids, _)) {\n             head(s, \"import\");\n-            if (!str::eq(id, ids.(vec::len(ids) - 1u))) {\n+            if (!str::eq(id, ids.(ivec::len(ids) - 1u))) {\n                 word_space(s, id);\n                 word_space(s, \"=\");\n             }"}]}