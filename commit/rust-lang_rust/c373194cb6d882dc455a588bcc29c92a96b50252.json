{"sha": "c373194cb6d882dc455a588bcc29c92a96b50252", "node_id": "C_kwDOAAsO6NoAKGMzNzMxOTRjYjZkODgyZGM0NTVhNTg4YmNjMjljOTJhOTZiNTAyNTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T19:02:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T19:02:19Z"}, "message": "Auto merge of #111260 - petrochenkov:effvisperf7, r=cjgillot\n\nrustc_privacy: Cleanups and perf improvements to `EmbargoVisitor`\n\nContinuation of https://github.com/rust-lang/rust/pull/110907.", "tree": {"sha": "194db456d8d0112c48c34e395398db579f006761", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/194db456d8d0112c48c34e395398db579f006761"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c373194cb6d882dc455a588bcc29c92a96b50252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c373194cb6d882dc455a588bcc29c92a96b50252", "html_url": "https://github.com/rust-lang/rust/commit/c373194cb6d882dc455a588bcc29c92a96b50252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c373194cb6d882dc455a588bcc29c92a96b50252/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "html_url": "https://github.com/rust-lang/rust/commit/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8"}, {"sha": "edf95b5d8cd8553740c151c090f49fffec2e7940", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf95b5d8cd8553740c151c090f49fffec2e7940", "html_url": "https://github.com/rust-lang/rust/commit/edf95b5d8cd8553740c151c090f49fffec2e7940"}], "stats": {"total": 263, "additions": 100, "deletions": 163}, "files": [{"sha": "65dfdf31e5457c5ff4d5d1716bcdae9ae9ae9b07", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 100, "deletions": 163, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/c373194cb6d882dc455a588bcc29c92a96b50252/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c373194cb6d882dc455a588bcc29c92a96b50252/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c373194cb6d882dc455a588bcc29c92a96b50252", "patch": "@@ -454,12 +454,14 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n+    /// Preliminary pass for marking all underlying types of `impl Trait`s as reachable.\n+    impl_trait_pass: bool,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    effective_vis: Option<EffectiveVisibility>,\n+    effective_vis: EffectiveVisibility,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n     level: Level,\n@@ -474,7 +476,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n     ) {\n         let nominal_vis = self.tcx.local_visibility(def_id);\n@@ -484,30 +486,27 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update_eff_vis(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         nominal_vis: Option<ty::Visibility>,\n         level: Level,\n     ) {\n-        if let Some(inherited_effective_vis) = inherited_effective_vis {\n-            let private_vis =\n-                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n-            if Some(private_vis) != nominal_vis {\n-                self.changed |= self.effective_visibilities.update(\n-                    def_id,\n-                    nominal_vis,\n-                    || private_vis,\n-                    inherited_effective_vis,\n-                    level,\n-                    self.tcx,\n-                );\n-            }\n+        let private_vis = ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n+        if Some(private_vis) != nominal_vis {\n+            self.changed |= self.effective_visibilities.update(\n+                def_id,\n+                nominal_vis,\n+                || private_vis,\n+                inherited_effective_vis,\n+                level,\n+                self.tcx,\n+            );\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -520,7 +519,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach_through_impl_trait(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -532,9 +531,13 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n \n     // We have to make sure that the items that macros might reference\n     // are reachable, since they might be exported transitively.\n-    fn update_reachability_from_macro(&mut self, local_def_id: LocalDefId, md: &MacroDef) {\n+    fn update_reachability_from_macro(\n+        &mut self,\n+        local_def_id: LocalDefId,\n+        md: &MacroDef,\n+        macro_ev: EffectiveVisibility,\n+    ) {\n         // Non-opaque macros cannot make other items more accessible than they already are.\n-\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         if attr::find_transparency(attrs, md.macro_rules).0 != Transparency::Opaque {\n@@ -554,8 +557,6 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        let macro_ev = self.get(local_def_id);\n-        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n                 self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n@@ -572,7 +573,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n             self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n@@ -586,7 +587,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n@@ -618,7 +619,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n         self.update(def_id, macro_ev, Level::Reachable);\n         match def_kind {\n@@ -700,128 +701,53 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n }\n \n impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    /// We want to visit items in the context of their containing\n-    /// module and so forth, so supply a crate for doing a deep walk.\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_ev = match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n-                    item.owner_id.def_id,\n-                    self.tcx,\n-                    &self.effective_visibilities,\n-                );\n-\n-                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n-                impl_ev\n-            }\n-            _ => self.get(item.owner_id.def_id),\n-        };\n-\n-        // Update levels of nested things.\n-        match item.kind {\n-            hir::ItemKind::Enum(ref def, _) => {\n-                for variant in def.variants {\n-                    self.update(variant.def_id, item_ev, Level::Reachable);\n-                    let variant_ev = self.get(variant.def_id);\n-                    if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n-                    }\n-                    for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_ev, Level::Reachable);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Impl(ref impl_) => {\n-                for impl_item_ref in impl_.items {\n-                    let def_id = impl_item_ref.id.owner_id.def_id;\n-                    let nominal_vis =\n-                        impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n-                    self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n-                }\n-            }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_ev, Level::Reachable);\n-                }\n-                for field in def.fields() {\n-                    self.update(field.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-            hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n-            }\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-\n-            hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::ExternCrate(..) => {}\n+        if self.impl_trait_pass\n+            && let hir::ItemKind::OpaqueTy(ref opaque) = item.kind\n+            && !opaque.in_trait {\n+            // FIXME: This is some serious pessimization intended to workaround deficiencies\n+            // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n+            // reachable if they are returned via `impl Trait`, even from private functions.\n+            let pub_ev = EffectiveVisibility::from_vis(ty::Visibility::Public);\n+            self.reach_through_impl_trait(item.owner_id.def_id, pub_ev)\n+                .generics()\n+                .predicates()\n+                .ty();\n+            return;\n         }\n \n-        // Mark all items in interfaces of reachable items as reachable.\n+        // Update levels of nested things and mark all items\n+        // in interfaces of reachable items as reachable.\n+        let item_ev = self.get(item.owner_id.def_id);\n         match item.kind {\n-            // The interface is empty.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by `visit_item`.\n-            hir::ItemKind::Mod(..) => {}\n-            // Handled in `rustc_resolve`.\n-            hir::ItemKind::Use(..) => {}\n-            // The interface is empty.\n-            hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::OpaqueTy(ref opaque) => {\n-                // HACK(jynelson): trying to infer the type of `impl trait` breaks `async-std` (and `pub async fn` in general)\n-                // Since rustdoc never needs to do codegen and doesn't care about link-time reachability,\n-                // mark this as unreachable.\n-                // See https://github.com/rust-lang/rust/issues/75100\n-                if !opaque.in_trait && !self.tcx.sess.opts.actually_rustdoc {\n-                    // FIXME: This is some serious pessimization intended to workaround deficiencies\n-                    // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n-                    // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n-                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n-                        .generics()\n-                        .predicates()\n-                        .ty();\n+            // The interface is empty, and no nested items.\n+            hir::ItemKind::Use(..)\n+            | hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::GlobalAsm(..) => {}\n+            // The interface is empty, and all nested items are processed by `visit_item`.\n+            hir::ItemKind::Mod(..) | hir::ItemKind::OpaqueTy(..) => {}\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n+                if let Some(item_ev) = item_ev {\n+                    self.update_reachability_from_macro(item.owner_id.def_id, macro_def, item_ev);\n                 }\n             }\n-            // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n+                        self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n+\n                         let tcx = self.tcx;\n                         let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n-\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -835,95 +761,94 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n-            // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = Option::<EffectiveVisibility>::of_impl(\n+                    item.owner_id.def_id,\n+                    self.tcx,\n+                    &self.effective_visibilities,\n+                ) {\n+                    self.update_eff_vis(item.owner_id.def_id, item_ev, None, Level::Direct);\n+\n                     self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n+                        let def_id = impl_item_ref.id.owner_id.def_id;\n+                        let nominal_vis =\n+                            impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n+                        self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n \n-                        if impl_item_ev.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n-                                .generics()\n-                                .predicates()\n-                                .ty();\n+                        if let Some(impl_item_ev) = self.get(def_id) {\n+                            self.reach(def_id, impl_item_ev).generics().predicates().ty();\n                         }\n                     }\n                 }\n             }\n-\n-            // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_ev = self.get(variant.def_id);\n-                    if variant_ev.is_some() {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(variant.def_id, item_ev, Level::Reachable);\n+                    }\n+\n+                    if let Some(variant_ev) = self.get(variant.def_id) {\n+                        if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n+                            self.update(ctor_def_id, variant_ev, Level::Reachable);\n+                        }\n                         for field in variant.data.fields() {\n+                            self.update(field.def_id, variant_ev, Level::Reachable);\n                             self.reach(field.def_id, variant_ev).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n                         self.reach(item.owner_id.def_id, variant_ev).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_ev = self.get(ctor_def_id);\n-                        if ctor_ev.is_some() {\n+                        if let Some(ctor_ev) = self.get(ctor_def_id) {\n                             self.reach(item.owner_id.def_id, ctor_ev).ty();\n                         }\n                     }\n                 }\n             }\n-            // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_ev.is_some() {\n+                    if let Some(foreign_item_ev) = self.get(foreign_item.id.owner_id.def_id) {\n                         self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n                             .generics()\n                             .predicates()\n                             .ty();\n                     }\n                 }\n             }\n-            // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_ev = self.get(field.def_id);\n-                        if field_ev.is_some() {\n+                        self.update(field.def_id, item_ev, Level::Reachable);\n+                        if let Some(field_ev) = self.get(field.def_id) {\n                             self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_ev = self.get(ctor_def_id);\n-                    if ctor_ev.is_some() {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(ctor_def_id, item_ev, Level::Reachable);\n+                    }\n+                    if let Some(ctor_ev) = self.get(ctor_def_id) {\n                         self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n                 }\n             }\n         }\n-\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n-        // Blocks can have public items, for example impls, but they always\n-        // start as completely private regardless of publicity of a function,\n-        // constant, type, field, etc., in which this block resides.\n-        intravisit::walk_block(self, b);\n     }\n }\n \n@@ -2205,12 +2130,24 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n+        // HACK(jynelson): trying to infer the type of `impl Trait` breaks `async-std` (and\n+        // `pub async fn` in general). Since rustdoc never needs to do codegen and doesn't\n+        // care about link-time reachability, keep them unreachable (issue #75100).\n+        impl_trait_pass: !tcx.sess.opts.actually_rustdoc,\n         changed: false,\n     };\n \n     visitor.effective_visibilities.check_invariants(tcx, true);\n+    if visitor.impl_trait_pass {\n+        // Underlying types of `impl Trait`s are marked as reachable unconditionally,\n+        // so this pass doesn't need to be a part of the fixed point iteration below.\n+        tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n+        visitor.impl_trait_pass = false;\n+        visitor.changed = false;\n+    }\n+\n     loop {\n-        tcx.hir().walk_toplevel_module(&mut visitor);\n+        tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n         if visitor.changed {\n             visitor.changed = false;\n         } else {"}]}