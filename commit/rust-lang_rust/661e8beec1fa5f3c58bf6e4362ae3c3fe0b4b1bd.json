{"sha": "661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "node_id": "C_kwDOAAsO6NoAKDY2MWU4YmVlYzFmYTVmM2M1OGJmNmU0MzYyYWUzYzNmZTBiNGIxYmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T01:20:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T01:20:01Z"}, "message": "Auto merge of #95291 - Dylan-DPC:rollup-vrb4wlw, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #94391 (Fix ice when error reporting recursion errors)\n - #94655 (Clarify which kinds of MIR are allowed during which phases.)\n - #95179 (Try to evaluate in try unify and postpone resolution of constants that contain inference variables)\n - #95270 (debuginfo: Fix debuginfo for Box<T> where T is unsized.)\n - #95276 (add diagnostic items for clippy's `trim_split_whitespace`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "87cb397401b3b8a18e4d4b2356a05d1094d54ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87cb397401b3b8a18e4d4b2356a05d1094d54ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "html_url": "https://github.com/rust-lang/rust/commit/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7941b3f1473331d2abb2b8796046adc0105c8f94", "url": "https://api.github.com/repos/rust-lang/rust/commits/7941b3f1473331d2abb2b8796046adc0105c8f94", "html_url": "https://github.com/rust-lang/rust/commit/7941b3f1473331d2abb2b8796046adc0105c8f94"}, {"sha": "3716c4275f0c6aa29bd2c87954b483e9c7a97475", "url": "https://api.github.com/repos/rust-lang/rust/commits/3716c4275f0c6aa29bd2c87954b483e9c7a97475", "html_url": "https://github.com/rust-lang/rust/commit/3716c4275f0c6aa29bd2c87954b483e9c7a97475"}], "stats": {"total": 849, "additions": 497, "deletions": 352}, "files": [{"sha": "74e194750faddffe269347358d223140586a3bfc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -166,6 +166,13 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n     pointee_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId<'tcx>,\n ) -> DINodeCreationResult<'ll> {\n+    // The debuginfo generated by this function is only valid if `ptr_type` is really just\n+    // a (fat) pointer. Make sure it is not called for e.g. `Box<T, NonZSTAllocator>`.\n+    debug_assert_eq!(\n+        cx.size_and_align_of(ptr_type),\n+        cx.size_and_align_of(cx.tcx.mk_mut_ptr(pointee_type))\n+    );\n+\n     let pointee_type_di_node = type_di_node(cx, pointee_type);\n \n     return_if_di_node_created_in_meantime!(cx, unique_type_id);\n@@ -212,7 +219,17 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n                     DIFlags::FlagZero,\n                 ),\n                 |cx, owner| {\n-                    let layout = cx.layout_of(ptr_type);\n+                    // FIXME: If this fat pointer is a `Box` then we don't want to use its\n+                    //        type layout and instead use the layout of the raw pointer inside\n+                    //        of it.\n+                    //        The proper way to handle this is to not treat Box as a pointer\n+                    //        at all and instead emit regular struct debuginfo for it. We just\n+                    //        need to make sure that we don't break existing debuginfo consumers\n+                    //        by doing that (at least not without a warning period).\n+                    let layout_type =\n+                        if ptr_type.is_box() { cx.tcx.mk_mut_ptr(pointee_type) } else { ptr_type };\n+\n+                    let layout = cx.layout_of(layout_type);\n                     let addr_field = layout.field(cx, abi::FAT_PTR_ADDR);\n                     let extra_field = layout.field(cx, abi::FAT_PTR_EXTRA);\n "}, {"sha": "faea2111d9210b204164a0aa98efe2edf239c73b", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -42,7 +42,7 @@ pub struct PromoteTemps<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::ConstPromotion)\n+        Some(MirPhase::ConstsPromoted)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "deeca78b75d99d18df33b0760a7c6d9d212aaec3", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -266,30 +266,23 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    // The deaggregator currently does not deaggreagate arrays.\n-                    // So for now, we ignore them here.\n-                    Rvalue::Aggregate(box AggregateKind::Array { .. }, _) => {}\n-                    // All other aggregates must be gone after some phases.\n-                    Rvalue::Aggregate(box kind, _) => {\n-                        if self.mir_phase > MirPhase::DropLowering\n-                            && !matches!(kind, AggregateKind::Generator(..))\n-                        {\n-                            // Generators persist until the state machine transformation, but all\n-                            // other aggregates must have been lowered.\n-                            self.fail(\n-                                location,\n-                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                            )\n-                        } else if self.mir_phase > MirPhase::GeneratorLowering {\n-                            // No more aggregates after drop and generator lowering.\n+                    Rvalue::Aggregate(agg_kind, _) => {\n+                        let disallowed = match **agg_kind {\n+                            AggregateKind::Array(..) => false,\n+                            AggregateKind::Generator(..) => {\n+                                self.mir_phase >= MirPhase::GeneratorsLowered\n+                            }\n+                            _ => self.mir_phase >= MirPhase::Deaggregated,\n+                        };\n+                        if disallowed {\n                             self.fail(\n                                 location,\n                                 format!(\"{:?} have been lowered to field assignments\", rvalue),\n                             )\n                         }\n                     }\n                     Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                        if self.mir_phase > MirPhase::DropLowering {\n+                        if self.mir_phase >= MirPhase::DropsLowered {\n                             self.fail(\n                                 location,\n                                 \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n@@ -300,15 +293,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n                         \"`AscribeUserType` should have been removed after drop lowering phase\",\n                     );\n                 }\n             }\n             StatementKind::FakeRead(..) => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n                         \"`FakeRead` should have been removed after drop lowering phase\",\n@@ -351,10 +344,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, format!(\"bad arg ({:?} != usize)\", op_cnt_ty))\n                 }\n             }\n-            StatementKind::SetDiscriminant { .. }\n-            | StatementKind::StorageLive(..)\n+            StatementKind::SetDiscriminant { .. } => {\n+                if self.mir_phase < MirPhase::DropsLowered {\n+                    self.fail(location, \"`SetDiscriminant` is not allowed until drop elaboration\");\n+                }\n+            }\n+            StatementKind::Retag(_, _) => {\n+                // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n+                // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n+                // seem to fail to set their `MirPhase` correctly.\n+            }\n+            StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n-            | StatementKind::Retag(_, _)\n             | StatementKind::Coverage(_)\n             | StatementKind::Nop => {}\n         }\n@@ -424,10 +425,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::DropAndReplace { target, unwind, .. } => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n-                        \"`DropAndReplace` is not permitted to exist after drop elaboration\",\n+                        \"`DropAndReplace` should have been removed during drop elaboration\",\n                     );\n                 }\n                 self.check_edge(location, *target, EdgeKind::Normal);\n@@ -494,7 +495,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n-                if self.mir_phase > MirPhase::GeneratorLowering {\n+                if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n                 self.check_edge(location, *resume, EdgeKind::Normal);\n@@ -503,10 +504,22 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`FalseEdge` should have been removed after drop elaboration\",\n+                    );\n+                }\n                 self.check_edge(location, *real_target, EdgeKind::Normal);\n                 self.check_edge(location, *imaginary_target, EdgeKind::Normal);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`FalseUnwind` should have been removed after drop elaboration\",\n+                    );\n+                }\n                 self.check_edge(location, *real_target, EdgeKind::Normal);\n                 if let Some(unwind) = unwind {\n                     self.check_edge(location, *unwind, EdgeKind::Unwind);\n@@ -520,12 +533,19 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.check_edge(location, *cleanup, EdgeKind::Unwind);\n                 }\n             }\n+            TerminatorKind::GeneratorDrop => {\n+                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`GeneratorDrop` should have been replaced by generator lowering\",\n+                    );\n+                }\n+            }\n             // Nothing to validate for these.\n             TerminatorKind::Resume\n             | TerminatorKind::Abort\n             | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop => {}\n+            | TerminatorKind::Unreachable => {}\n         }\n \n         self.super_terminator(terminator, location);"}, {"sha": "2886d921c705dcd42afb50279c474feb95a8c482", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -20,8 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::interpret::EvalToConstValueResult;\n+use rustc_middle::mir::interpret::{ErrorHandled, EvalToConstValueResult};\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -71,7 +70,6 @@ mod sub;\n pub mod type_variable;\n mod undo_log;\n \n-use crate::infer::canonical::OriginalQueryValues;\n pub use rustc_middle::infer::unify_key;\n \n #[must_use]\n@@ -687,15 +685,28 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// calls `tcx.try_unify_abstract_consts` after\n     /// canonicalizing the consts.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn try_unify_abstract_consts(\n         &self,\n         a: ty::Unevaluated<'tcx, ()>,\n         b: ty::Unevaluated<'tcx, ()>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n-        let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());\n-        debug!(\"canonical consts: {:?}\", &canonical.value);\n+        // Reject any attempt to unify two unevaluated constants that contain inference\n+        // variables, since inference variables in queries lead to ICEs.\n+        if a.substs.has_infer_types_or_consts()\n+            || b.substs.has_infer_types_or_consts()\n+            || param_env.has_infer_types_or_consts()\n+        {\n+            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n+            return false;\n+        }\n+\n+        let param_env_and = param_env.and((a, b));\n+        let erased = self.tcx.erase_regions(param_env_and);\n+        debug!(\"after erase_regions: {:?}\", erased);\n \n-        self.tcx.try_unify_abstract_consts(canonical.value)\n+        self.tcx.try_unify_abstract_consts(erased)\n     }\n \n     pub fn is_in_snapshot(&self) -> bool {\n@@ -1598,22 +1609,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// This handles inferences variables within both `param_env` and `substs` by\n     /// performing the operation on their respective canonical forms.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_resolve(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n         let substs = self.resolve_vars_if_possible(unevaluated.substs);\n+        debug!(?substs);\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n+            debug!(\"substs have infer types or consts: {:?}\", substs);\n             return Err(ErrorHandled::TooGeneric);\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);\n         let substs_erased = self.tcx.erase_regions(substs);\n+        debug!(?param_env_erased);\n+        debug!(?substs_erased);\n \n         let unevaluated = ty::Unevaluated {\n             def: unevaluated.def,"}, {"sha": "7e5989b4112cff868e76f7e7f6da8fcb991365ad", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -1,6 +1,7 @@\n use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n \n use crate::mir;\n+use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::InternalSubsts;\n use crate::ty::{self, TyCtxt};\n use rustc_hir::def_id::DefId;\n@@ -38,6 +39,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         ct: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n+        // Cannot resolve `Unevaluated` constants that contain inference\n+        // variables. We reject those here since `resolve_opt_const_arg`\n+        // would fail otherwise.\n+        //\n+        // When trying to evaluate constants containing inference variables,\n+        // use `Infcx::const_eval_resolve` instead.\n+        if ct.substs.has_infer_types_or_consts() {\n+            bug!(\"did not expect inference variables here\");\n+        }\n+\n         match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted: ct.promoted };"}, {"sha": "ea71cff161612ab47a033180669452b2079d2d50", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -127,32 +127,44 @@ pub trait MirPass<'tcx> {\n /// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n /// dialects forbid certain variants or values in certain phases.\n ///\n-/// Note: Each phase's validation checks all invariants of the *previous* phases' dialects. A phase\n-/// that changes the dialect documents what invariants must be upheld *after* that phase finishes.\n-///\n /// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n-    Build = 0,\n+    Built = 0,\n     // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n     // We used to have this for pre-miri MIR based const eval.\n     Const = 1,\n     /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n     /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n     /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n     /// query.\n-    ConstPromotion = 2,\n-    /// After this phase\n-    /// * the only `AggregateKind`s allowed are `Array` and `Generator`,\n-    /// * `DropAndReplace` is gone for good\n-    /// * `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop` terminator\n-    ///   means that the auto-generated drop glue will be invoked.\n-    DropLowering = 3,\n-    /// After this phase, generators are explicit state machines (no more `Yield`).\n-    /// `AggregateKind::Generator` is gone for good.\n-    GeneratorLowering = 4,\n-    Optimization = 5,\n+    ConstsPromoted = 2,\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::DropAndReplace`](terminator::TerminatorKind::DropAndReplace)\n+    /// * [`TerminatorKind::FalseUnwind`](terminator::TerminatorKind::FalseUnwind)\n+    /// * [`TerminatorKind::FalseEdge`](terminator::TerminatorKind::FalseEdge)\n+    /// * [`StatementKind::FakeRead`]\n+    /// * [`StatementKind::AscribeUserType`]\n+    /// * [`Rvalue::Ref`] with `BorrowKind::Shallow`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::Retag`]\n+    ///\n+    /// Furthermore, `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop`\n+    /// terminator means that the auto-generated drop glue will be invoked.\n+    DropsLowered = 3,\n+    /// Beginning with this phase, the following variant is disallowed:\n+    /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::SetDiscriminant`]\n+    Deaggregated = 4,\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::Yield`](terminator::TerminatorKind::Yield)\n+    /// * [`TerminatorKind::GeneratorDrop](terminator::TerminatorKind::GeneratorDrop)\n+    GeneratorsLowered = 5,\n+    Optimized = 6,\n }\n \n impl MirPhase {\n@@ -311,7 +323,7 @@ impl<'tcx> Body<'tcx> {\n         );\n \n         let mut body = Body {\n-            phase: MirPhase::Build,\n+            phase: MirPhase::Built,\n             source,\n             basic_blocks,\n             source_scopes,\n@@ -346,7 +358,7 @@ impl<'tcx> Body<'tcx> {\n     /// crate.\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n         let mut body = Body {\n-            phase: MirPhase::Build,\n+            phase: MirPhase::Built,\n             source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n             basic_blocks,\n             source_scopes: IndexVec::new(),\n@@ -1541,9 +1553,16 @@ impl Statement<'_> {\n     }\n }\n \n+/// The various kinds of statements that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n+/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n+/// causing an ICE if they are violated.\n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n+    ///\n+    /// The LHS place may not overlap with any memory accessed on the RHS.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n     /// This represents all the reading that a pattern match may do\n@@ -1761,6 +1780,19 @@ static_assert_size!(Place<'_>, 16);\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n+    /// Index into a slice/array.\n+    ///\n+    /// Note that this does not also dereference, and so it does not exactly correspond to slice\n+    /// indexing in Rust. In other words, in the below Rust code:\n+    ///\n+    /// ```rust\n+    /// let x = &[1, 2, 3, 4];\n+    /// let i = 2;\n+    /// x[i];\n+    /// ```\n+    ///\n+    /// The `x[i]` is turned into a `Deref` followed by an `Index`, not just an `Index`. The same\n+    /// thing is true of the `ConstantIndex` and `Subslice` projections below.\n     Index(V),\n \n     /// These indices are generated by slice patterns. Easiest to explain\n@@ -2223,6 +2255,11 @@ impl<'tcx> Operand<'tcx> {\n /// Rvalues\n \n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+/// The various kinds of rvalues that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n+/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n+/// causing an ICE if they are violated.\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),"}, {"sha": "cd6ff8254ad86c4cfb612faf0cd227ce2cc5b547", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -331,12 +331,12 @@ rustc_queries! {\n         }\n     }\n \n-    query try_unify_abstract_consts(key: (\n-        ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n-    )) -> bool {\n+    query try_unify_abstract_consts(key:\n+        ty::ParamEnvAnd<'tcx, (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n+    )>) -> bool {\n         desc {\n             |tcx| \"trying to unify the generic constants {} and {}\",\n-            tcx.def_path_str(key.0.def.did), tcx.def_path_str(key.1.def.did)\n+            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n         }\n     }\n "}, {"sha": "d852531bc68672075ce0453ec1ca75e4f2a3984e", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -491,7 +491,7 @@ pub enum SelectionError<'tcx> {\n     /// A given constant couldn't be evaluated.\n     NotConstEvaluatable(NotConstEvaluatable),\n     /// Exceeded the recursion depth during type projection.\n-    Overflow,\n+    Overflow(OverflowError),\n     /// Signaling that an error has already been emitted, to avoid\n     /// multiple errors being shown.\n     ErrorReporting,"}, {"sha": "5297825a92fcc225d78905463dea68a09421b9c9", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -5,6 +5,7 @@\n use self::EvaluationResult::*;\n \n use super::{SelectionError, SelectionResult};\n+use rustc_errors::ErrorGuaranteed;\n \n use crate::ty;\n \n@@ -264,14 +265,26 @@ impl EvaluationResult {\n /// Indicates that trait evaluation caused overflow and in which pass.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub enum OverflowError {\n+    Error(ErrorGuaranteed),\n     Canonical,\n     ErrorReporting,\n }\n \n+impl From<ErrorGuaranteed> for OverflowError {\n+    fn from(e: ErrorGuaranteed) -> OverflowError {\n+        OverflowError::Error(e)\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    OverflowError,\n+}\n+\n impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n     fn from(overflow_error: OverflowError) -> SelectionError<'tcx> {\n         match overflow_error {\n-            OverflowError::Canonical => SelectionError::Overflow,\n+            OverflowError::Error(e) => SelectionError::Overflow(OverflowError::Error(e)),\n+            OverflowError::Canonical => SelectionError::Overflow(OverflowError::Canonical),\n             OverflowError::ErrorReporting => SelectionError::ErrorReporting,\n         }\n     }"}, {"sha": "5d6cbcf6907069f8b0823129782bd5ee27c0f1ab", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -585,7 +585,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n         {\n-            tcx.try_unify_abstract_consts((au.shrink(), bu.shrink()))\n+            tcx.try_unify_abstract_consts(relation.param_env().and((au.shrink(), bu.shrink())))\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`"}, {"sha": "616ba819982ec981807f591f906b95e9c5c4c28e", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -6,6 +6,10 @@ use rustc_middle::ty::TyCtxt;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n+    fn phase_change(&self) -> Option<MirPhase> {\n+        Some(MirPhase::Deaggregated)\n+    }\n+\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;"}, {"sha": "f78c7a084d89acc72bfccd2bd0865082f3b5e904", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -20,7 +20,7 @@ pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::DropLowering)\n+        Some(MirPhase::DropsLowered)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "ad96bf544cbd339b41a1f95dd665cc2b5a0baa78", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -1235,7 +1235,7 @@ fn create_cases<'tcx>(\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::GeneratorLowering)\n+        Some(MirPhase::GeneratorsLowered)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "2fca498a125021460a6c7d8790bdd199fa970f8c", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -342,7 +342,7 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n             pm::run_passes(\n                 tcx,\n                 &mut body,\n-                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimization)],\n+                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimized)],\n             );\n         }\n     }\n@@ -399,7 +399,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     }\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body);\n-    assert!(body.phase == MirPhase::DropLowering);\n+    assert!(body.phase == MirPhase::Deaggregated);\n     tcx.alloc_steal_mir(body)\n }\n \n@@ -460,7 +460,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         ],\n     );\n \n-    assert!(body.phase == MirPhase::GeneratorLowering);\n+    assert!(body.phase == MirPhase::GeneratorsLowered);\n \n     // The main optimizations that we do on MIR.\n     pm::run_passes(\n@@ -497,7 +497,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &deduplicate_blocks::DeduplicateBlocks,\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n-            &marker::PhaseChange(MirPhase::Optimization),\n+            &marker::PhaseChange(MirPhase::Optimized),\n             // Dump the end result for testing and debugging purposes.\n             &dump_mir::Marker(\"PreCodegen\"),\n         ],"}, {"sha": "740a2168b41cc52865c92782309d41f5beeb2331", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -114,7 +114,7 @@ pub fn run_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn\n         }\n     }\n \n-    if validate || body.phase == MirPhase::Optimization {\n+    if validate || body.phase == MirPhase::Optimized {\n         validate_body(tcx, body, format!(\"end of phase transition to {:?}\", body.phase));\n     }\n }"}, {"sha": "5cf362bfa7e98b09df567cce192563907db1522d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -1347,6 +1347,10 @@ symbols! {\n         store,\n         str,\n         str_alloc,\n+        str_split_whitespace,\n+        str_trim,\n+        str_trim_end,\n+        str_trim_start,\n         stringify,\n         stringify_macro,\n         struct_field_attributes,"}, {"sha": "959b644becd9b4012c8036619f75498ec49043f0", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -188,6 +188,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn satisfied_from_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ct: AbstractConst<'tcx>,\n@@ -197,14 +198,17 @@ fn satisfied_from_param_env<'tcx>(\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(uv) => {\n                 if let Some(b_ct) = AbstractConst::new(tcx, uv)? {\n+                    let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+\n                     // Try to unify with each subtree in the AbstractConst to allow for\n                     // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n                     // predicate for `(N + 1) * 2`\n-                    let result =\n-                        walk_abstract_const(tcx, b_ct, |b_ct| match try_unify(tcx, ct, b_ct) {\n+                    let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n+                        match const_unify_ctxt.try_unify(ct, b_ct) {\n                             true => ControlFlow::BREAK,\n                             false => ControlFlow::CONTINUE,\n-                        });\n+                        }\n+                    });\n \n                     if let ControlFlow::Break(()) = result {\n                         debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -637,11 +641,13 @@ pub(super) fn thir_abstract_const<'tcx>(\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> bool {\n     (|| {\n         if let Some(a) = AbstractConst::new(tcx, a)? {\n             if let Some(b) = AbstractConst::new(tcx, b)? {\n-                return Ok(try_unify(tcx, a, b));\n+                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n             }\n         }\n \n@@ -689,88 +695,115 @@ where\n     recurse(tcx, ct, &mut f)\n }\n \n-/// Tries to unify two abstract constants using structural equality.\n-pub(super) fn try_unify<'tcx>(\n+struct ConstUnifyCtxt<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    mut a: AbstractConst<'tcx>,\n-    mut b: AbstractConst<'tcx>,\n-) -> bool {\n-    // We substitute generics repeatedly to allow AbstractConsts to unify where a\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n     // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n     // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    while let Node::Leaf(a_ct) = a.root(tcx) {\n-        match AbstractConst::from_const(tcx, a_ct) {\n-            Ok(Some(a_act)) => a = a_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n-        }\n-    }\n-    while let Node::Leaf(b_ct) = b.root(tcx) {\n-        match AbstractConst::from_const(tcx, b_ct) {\n-            Ok(Some(b_act)) => b = b_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n         }\n-    }\n \n-    match (a.root(tcx), b.root(tcx)) {\n-        (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-            if a_ct.ty() != b_ct.ty() {\n-                return false;\n-            }\n+        Some(abstr_const)\n+    }\n \n-            match (a_ct.val(), b_ct.val()) {\n-                // We can just unify errors with everything to reduce the amount of\n-                // emitted errors here.\n-                (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                    a_param == b_param\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n+            return true;\n+        };\n+\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n+\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n+\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n                 }\n-                (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                // means that we only allow inference variables if they are equal.\n-                (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                // We expand generic anonymous constants at the start of this function, so this\n-                // branch should only be taking when dealing with associated constants, at\n-                // which point directly comparing them seems like the desired behavior.\n-                //\n-                // FIXME(generic_const_exprs): This isn't actually the case.\n-                // We also take this branch for concrete anonymous constants and\n-                // expand generic anonymous constants with concrete substs.\n-                (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                    a_uv == b_uv\n+\n+                match (a_ct.val(), b_ct.val()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n                 }\n-                // FIXME(generic_const_exprs): We may want to either actually try\n-                // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                // this, for now we just return false here.\n-                _ => false,\n             }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n         }\n-        (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(al), b.subtree(bl))\n-                && try_unify(tcx, a.subtree(ar), b.subtree(br))\n-        }\n-        (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(av), b.subtree(bv))\n-        }\n-        (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-            if a_args.len() == b_args.len() =>\n-        {\n-            try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n-                && iter::zip(a_args, b_args)\n-                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n-        }\n-        (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_kind == b_kind) =>\n-        {\n-            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n-        }\n-        // use this over `_ => false` to make adding variants to `Node` less error prone\n-        (Node::Cast(..), _)\n-        | (Node::FunctionCall(..), _)\n-        | (Node::UnaryOp(..), _)\n-        | (Node::Binop(..), _)\n-        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "5e220173caeeac0cf5f191a9b15f33d1d425f625", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -22,6 +22,7 @@ use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{\n@@ -928,8 +929,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.delay_span_bug(span, \"`ErrorGuaranteed` without an error\");\n                 return;\n             }\n-\n-            Overflow => {\n+            // Already reported.\n+            Overflow(OverflowError::Error(_)) => {\n+                self.tcx.sess.delay_span_bug(span, \"`OverflowError` has been reported\");\n+                return;\n+            }\n+            Overflow(_) => {\n                 bug!(\"overflow should be handled before the `report_selection_error` path\");\n             }\n             SelectionError::ErrorReporting => {"}, {"sha": "1b8628344671db5a577f57a66e68bcc836ae2034", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -580,7 +580,11 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return ProcessResult::Changed(vec![]);\n                             }\n                         }"}, {"sha": "88750f272c8d3a0c7aa29e03960a8e1cb2addc44", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -862,7 +862,10 @@ pub fn provide(providers: &mut ty::query::Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        try_unify_abstract_consts: const_evaluatable::try_unify_abstract_consts,\n+        try_unify_abstract_consts: |tcx, param_env_and| {\n+            let (param_env, (a, b)) = param_env_and.into_parts();\n+            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n+        },\n         ..*providers\n     };\n }"}, {"sha": "b61e68735712bee38fae0cf0a226dc9b1e279089", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -27,6 +27,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n@@ -1139,7 +1140,9 @@ fn project<'cx, 'tcx>(\n     if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n         // This should really be an immediate error, but some existing code\n         // relies on being able to recover from this.\n-        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow));\n+        return Err(ProjectionError::TraitSelectionError(SelectionError::Overflow(\n+            OverflowError::Canonical,\n+        )));\n     }\n \n     if obligation.predicate.references_error() {"}, {"sha": "db45ee3fed7db17fb2a0842e3685631dd2d225c8", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -108,9 +108,11 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n                         )\n                     }\n                     OverflowError::ErrorReporting => EvaluationResult::EvaluatedToErr,\n+                    OverflowError::Error(_) => EvaluationResult::EvaluatedToErr,\n                 })\n             }\n             Err(OverflowError::ErrorReporting) => EvaluationResult::EvaluatedToErr,\n+            Err(OverflowError::Error(_)) => EvaluationResult::EvaluatedToErr,\n         }\n     }\n }"}, {"sha": "3e7a2252318be550f92a4f808e9b5c3ee300ed2c", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -164,8 +164,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n                 }\n                 Ok(_) => Ok(None),\n-                Err(OverflowError::Canonical) => Err(Overflow),\n+                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n                 Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n+                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n             })\n             .flat_map(Result::transpose)\n             .collect::<Result<Vec<_>, _>>()?;"}, {"sha": "6d232d86d8a4f85feaab9e60c11b0cd1adf4baa8", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -25,7 +25,7 @@ use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::Diagnostic;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n@@ -316,11 +316,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, Selection<'tcx>> {\n         let candidate = match self.select_from_obligation(obligation) {\n-            Err(SelectionError::Overflow) => {\n+            Err(SelectionError::Overflow(OverflowError::Canonical)) => {\n                 // In standard mode, overflow must have been caught and reported\n                 // earlier.\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n-                return Err(SelectionError::Overflow);\n+                return Err(SelectionError::Overflow(OverflowError::Canonical));\n             }\n             Err(SelectionError::Ambiguous(_)) => {\n                 return Ok(None);\n@@ -335,9 +335,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         match self.confirm_candidate(obligation, candidate) {\n-            Err(SelectionError::Overflow) => {\n+            Err(SelectionError::Overflow(OverflowError::Canonical)) => {\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n-                Err(SelectionError::Overflow)\n+                Err(SelectionError::Overflow(OverflowError::Canonical))\n             }\n             Err(e) => Err(e),\n             Ok(candidate) => {\n@@ -639,7 +639,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if self.infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if self.infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return Ok(EvaluatedToOk);\n                             }\n                         }\n@@ -954,7 +958,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Err(SelectionError::Ambiguous(_)) => Ok(EvaluatedToAmbig),\n             Ok(None) => Ok(EvaluatedToAmbig),\n-            Err(Overflow) => Err(OverflowError::Canonical),\n+            Err(Overflow(OverflowError::Canonical)) => Err(OverflowError::Canonical),\n             Err(ErrorReporting) => Err(OverflowError::ErrorReporting),\n             Err(..) => Ok(EvaluatedToErr),\n         }\n@@ -1113,7 +1117,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     if self.infcx.is_tainted_by_errors() {\n-                        return Err(OverflowError::ErrorReporting);\n+                        return Err(OverflowError::Error(\n+                            ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n+                        ));\n                     }\n                     self.infcx.report_overflow_error(error_obligation, true);\n                 }\n@@ -1349,7 +1355,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if let Err(Overflow) = candidate {\n+            if let Err(Overflow(OverflowError::Canonical)) = candidate {\n                 // Don't cache overflow globally; we only produce this in certain modes.\n             } else if !pred.needs_infer() {\n                 if !candidate.needs_infer() {"}, {"sha": "4ab94f39357d8942dabcf787091e51279f7bd8fd", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -243,7 +243,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n-                ) => tcx.try_unify_abstract_consts((a, b)),\n+                ) => tcx.try_unify_abstract_consts(self_param_env.and((a, b))),\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "c603420f0f8620ea7ef98e384a97e39bda3f6e6c", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -904,6 +904,7 @@ impl str {\n     #[must_use = \"this returns the split string as an iterator, \\\n                   without modifying the original\"]\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_split_whitespace\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace<'_> {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n@@ -1846,6 +1847,7 @@ impl str {\n     #[must_use = \"this returns the trimmed string as a slice, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_trim\")]\n     pub fn trim(&self) -> &str {\n         self.trim_matches(|c: char| c.is_whitespace())\n     }\n@@ -1884,6 +1886,7 @@ impl str {\n     #[must_use = \"this returns the trimmed string as a new slice, \\\n                   without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_trim_start\")]\n     pub fn trim_start(&self) -> &str {\n         self.trim_start_matches(|c: char| c.is_whitespace())\n     }\n@@ -1922,6 +1925,7 @@ impl str {\n     #[must_use = \"this returns the trimmed string as a new slice, \\\n                   without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_trim_end\")]\n     pub fn trim_end(&self) -> &str {\n         self.trim_end_matches(|c: char| c.is_whitespace())\n     }"}, {"sha": "7cb0002ca512510020aa49d8f3a2a85af530490d", "filename": "src/test/debuginfo/unsized.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fdebuginfo%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fdebuginfo%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funsized.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -16,13 +16,17 @@\n // gdbg-check:$3 = {pointer = [...], vtable = [...]}\n // gdbr-check:$3 = &unsized::Foo<dyn core::fmt::Debug> {pointer: [...], vtable: [...]}\n \n+// gdb-command:print _box\n+// gdbg-check:$4 = {pointer = [...], vtable = [...]}\n+// gdbr-check:$4 = alloc::boxed::Box<unsized::Foo<dyn core::fmt::Debug>, alloc::alloc::Global> {pointer: [...], vtable: [...]}\n+\n // gdb-command:print tuple_slice\n-// gdbg-check:$4 = {data_ptr = [...], length = 2}\n-// gdbr-check:$4 = &(i32, i32, [i32]) {data_ptr: [...], length: 2}\n+// gdbg-check:$5 = {data_ptr = [...], length = 2}\n+// gdbr-check:$5 = &(i32, i32, [i32]) {data_ptr: [...], length: 2}\n \n // gdb-command:print tuple_dyn\n-// gdbg-check:$5 = {pointer = [...], vtable = [...]}\n-// gdbr-check:$5 = &(i32, i32, dyn core::fmt::Debug) {pointer: [...], vtable: [...]}\n+// gdbg-check:$6 = {pointer = [...], vtable = [...]}\n+// gdbr-check:$6 = &(i32, i32, dyn core::fmt::Debug) {pointer: [...], vtable: [...]}\n \n // === CDB TESTS ===================================================================================\n \n@@ -42,6 +46,12 @@\n // cdb-check:    [+0x000] pointer          : 0x[...] [Type: unsized::Foo<dyn$<core::fmt::Debug> > *]\n // cdb-check:    [...] vtable           : 0x[...] [Type: unsigned [...]int[...] (*)[3]]\n \n+// cdb-command:dx _box\n+// cdb-check:\n+// cdb-check:_box             [Type: alloc::boxed::Box<unsized::Foo<dyn$<core::fmt::Debug> >,alloc::alloc::Global>]\n+// cdb-check:[+0x000] pointer          : 0x[...] [Type: unsized::Foo<dyn$<core::fmt::Debug> > *]\n+// cdb-check:[...] vtable           : 0x[...] [Type: unsigned [...]int[...] (*)[3]]\n+\n // cdb-command:dx tuple_slice\n // cdb-check:tuple_slice      [Type: ref$<tuple$<i32,i32,slice$<i32> > >]\n // cdb-check:    [+0x000] data_ptr         : 0x[...] [Type: tuple$<i32,i32,slice$<i32> > *]\n@@ -69,6 +79,7 @@ fn main() {\n     let a: &Foo<[u8]> = &foo.value;\n     let b: &Foo<Foo<[u8]>> = &foo;\n     let c: &Foo<dyn std::fmt::Debug> = &Foo { value: 7i32 };\n+    let _box: Box<Foo<dyn std::fmt::Debug>> = Box::new(Foo { value: 8i32 });\n \n     // Also check unsized tuples\n     let tuple_slice: &(i32, i32, [i32]) = &(0, 1, [2, 3]);"}, {"sha": "c59d62e576d9b95d55427b04bdd3c8d8d5173f1f", "filename": "src/test/ui/const-generics/generic_const_exprs/eval-try-unify.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -0,0 +1,26 @@\n+// build-pass\n+\n+#![feature(generic_const_exprs)]\n+//~^ WARNING the feature `generic_const_exprs` is incomplete\n+\n+trait Generic {\n+    const ASSOC: usize;\n+}\n+\n+impl Generic for u8 {\n+    const ASSOC: usize = 17;\n+}\n+impl Generic for u16 {\n+    const ASSOC: usize = 13;\n+}\n+\n+\n+fn uses_assoc_type<T: Generic, const N: usize>() -> [u8; N + T::ASSOC] {\n+    [0; N + T::ASSOC]\n+}\n+\n+fn only_generic_n<const N: usize>() -> [u8; N + 13] {\n+    uses_assoc_type::<u16, N>()\n+}\n+\n+fn main() {}"}, {"sha": "b5719b3fe1dc29df5868573b9bfff7cdab8c2055", "filename": "src/test/ui/const-generics/generic_const_exprs/eval-try-unify.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/eval-try-unify.rs:3:12\n+   |\n+LL | #![feature(generic_const_exprs)]\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "71c164ab0a5bf68dd863951b0bd51bd98f7dff4c", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -2,114 +2,115 @@\n #![allow(incomplete_features)]\n \n trait TensorDimension {\n-    const DIM : usize;\n-    const ISSCALAR : bool = Self::DIM == 0;\n-    fn is_scalar(&self) -> bool {Self::ISSCALAR}\n+    const DIM: usize;\n+    //~^ ERROR cycle detected when resolving instance\n+    // FIXME Given the current state of the compiler its expected that we cycle here,\n+    // but the cycle is still wrong.\n+    const ISSCALAR: bool = Self::DIM == 0;\n+    fn is_scalar(&self) -> bool {\n+        Self::ISSCALAR\n+    }\n }\n \n-trait TensorSize : TensorDimension {\n-    fn size(&self) -> [usize;Self::DIM];\n-    fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n-        index.iter().zip(self.size().iter()).all(|(i,s)| i < s)\n+trait TensorSize: TensorDimension {\n+    fn size(&self) -> [usize; Self::DIM];\n+    fn inbounds(&self, index: [usize; Self::DIM]) -> bool {\n+        index.iter().zip(self.size().iter()).all(|(i, s)| i < s)\n     }\n }\n \n-\n trait Broadcastable: TensorSize + Sized {\n     type Element;\n-    fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n-    fn lazy_updim<const NEWDIM : usize>(&self, size : [usize;NEWDIM] ) ->\n-       LazyUpdim<Self,{Self::DIM},NEWDIM>\n-    {\n-        assert!(NEWDIM >= Self::DIM,\n-            \"Updimmed tensor cannot have fewer indices than the initial one.\");\n-        LazyUpdim {size,reference:&self}\n+    fn bget(&self, index: [usize; Self::DIM]) -> Option<Self::Element>;\n+    fn lazy_updim<const NEWDIM: usize>(\n+        &self,\n+        size: [usize; NEWDIM],\n+    ) -> LazyUpdim<Self, { Self::DIM }, NEWDIM> {\n+        assert!(\n+            NEWDIM >= Self::DIM,\n+            \"Updimmed tensor cannot have fewer indices than the initial one.\"\n+        );\n+        LazyUpdim { size, reference: &self }\n     }\n-    fn bmap<T,F :Fn(Self::Element) -> T>(&self,foo : F) -> BMap<T,Self,F,{Self::DIM}>{\n-        BMap {reference:self,closure : foo}\n+    fn bmap<T, F: Fn(Self::Element) -> T>(&self, foo: F) -> BMap<T, Self, F, { Self::DIM }> {\n+        BMap { reference: self, closure: foo }\n     }\n }\n \n-\n-struct LazyUpdim<'a,T : Broadcastable,const OLDDIM : usize, const DIM : usize> {\n-    size : [usize;DIM],\n-    reference : &'a T\n+struct LazyUpdim<'a, T: Broadcastable, const OLDDIM: usize, const DIM: usize> {\n+    size: [usize; DIM],\n+    reference: &'a T,\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorDimension for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    const DIM : usize = DIM;\n+impl<'a, T: Broadcastable, const DIM: usize> TensorDimension for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    const DIM: usize = DIM;\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorSize for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    fn size(&self) -> [usize;DIM] {self.size}\n-    //~^ ERROR method not compatible with trait\n+impl<'a, T: Broadcastable, const DIM: usize> TensorSize for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    fn size(&self) -> [usize; DIM] {\n+        self.size\n+    }\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM>\n-{\n+impl<'a, T: Broadcastable, const DIM: usize> Broadcastable for LazyUpdim<'a, T, { T::DIM }, DIM> {\n     type Element = T::Element;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-      //~^ ERROR method not compatible with trait\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         assert!(DIM >= T::DIM);\n-        if !self.inbounds(index) {return None}\n-        //~^ ERROR unconstrained generic constant\n-        //~| ERROR mismatched types\n+        if !self.inbounds(index) {\n+            return None;\n+        }\n         let size = self.size();\n-        //~^ ERROR unconstrained generic constant\n-        let newindex : [usize;T::DIM] = Default::default();\n-        //~^ ERROR the trait bound `[usize; _]: Default` is not satisfied\n+        let newindex: [usize; T::DIM] = Default::default();\n         self.reference.bget(newindex)\n     }\n }\n \n-struct BMap<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  , const DIM: usize> {\n-    reference : &'a T,\n-    closure : F\n+struct BMap<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> {\n+    reference: &'a T,\n+    closure: F,\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R,\n-     const DIM: usize> TensorDimension for BMap<'a,R,T,F,DIM> {\n-\n-    const DIM : usize = DIM;\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorDimension\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    const DIM: usize = DIM;\n }\n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-      const DIM: usize> TensorSize for BMap<'a,R,T,F,DIM> {\n-\n-    fn size(&self) -> [usize;DIM] {self.reference.size()}\n-    //~^ ERROR unconstrained generic constant\n-    //~| ERROR mismatched types\n-    //~| ERROR method not compatible with trait\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorSize\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    fn size(&self) -> [usize; DIM] {\n+        self.reference.size()\n+    }\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-  const DIM: usize> Broadcastable for BMap<'a,R,T,F,DIM> {\n-\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> Broadcastable\n+    for BMap<'a, R, T, F, DIM>\n+{\n     type Element = R;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-      //~^ ERROR method not compatible with trait\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         self.reference.bget(index).map(&self.closure)\n-        //~^ ERROR unconstrained generic constant\n-        //~| ERROR mismatched types\n     }\n }\n \n impl<T> TensorDimension for Vec<T> {\n-    const DIM : usize = 1;\n+    const DIM: usize = 1;\n }\n impl<T> TensorSize for Vec<T> {\n-    fn size(&self) -> [usize;1] {[self.len()]}\n+    fn size(&self) -> [usize; 1] {\n+        [self.len()]\n+    }\n }\n impl<T: Clone> Broadcastable for Vec<T> {\n     type Element = T;\n-    fn bget(& self,index : [usize;1]) -> Option<T> {\n+    fn bget(&self, index: [usize; 1]) -> Option<T> {\n         self.get(index[0]).cloned()\n     }\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n-    let bv = v.lazy_updim([3,4]);\n-    let bbv = bv.bmap(|x| x*x);\n+    let v = vec![1, 2, 3];\n+    let bv = v.lazy_updim([3, 4]);\n+    let bbv = bv.bmap(|x| x * x);\n \n-    println!(\"The size of v is {:?}\",bbv.bget([0,2]).expect(\"Out of bounds.\"));\n+    println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n }"}, {"sha": "8705a39fa4bcd3397061a59f03e9bfcec0821941", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 12, "deletions": 125, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -1,130 +1,17 @@\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:44:5\n+error[E0391]: cycle detected when resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n+  --> $DIR/issue-83765.rs:5:5\n    |\n-LL |     fn size(&self) -> [usize;DIM] {self.size}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+LL |     const DIM: usize;\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:51:5\n-   |\n-LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:78:5\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:88:5\n-   |\n-LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:54:18\n-   |\n-LL |         if !self.inbounds(index) {return None}\n-   |                  ^^^^^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::inbounds`\n-  --> $DIR/issue-83765.rs:12:38\n-   |\n-LL |     fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n-   |                                      ^^^^^^^^^ required by this bound in `TensorSize::inbounds`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:54:27\n-   |\n-LL |         if !self.inbounds(index) {return None}\n-   |                           ^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:57:25\n-   |\n-LL |         let size = self.size();\n-   |                         ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::size`\n-  --> $DIR/issue-83765.rs:11:30\n-   |\n-LL |     fn size(&self) -> [usize;Self::DIM];\n-   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n-\n-error[E0277]: the trait bound `[usize; _]: Default` is not satisfied\n-  --> $DIR/issue-83765.rs:59:41\n-   |\n-LL |         let newindex : [usize;T::DIM] = Default::default();\n-   |                                         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `[usize; _]`\n-   |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n-   |\n-LL | impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM> where [usize; _]: Default\n-   |                                                                                              +++++++++++++++++++++++++\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:78:51\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |                                                   ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::size`\n-  --> $DIR/issue-83765.rs:11:30\n-   |\n-LL |     fn size(&self) -> [usize;Self::DIM];\n-   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:78:36\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n-   |\n-   = note: expected type `DIM`\n-              found type `Self::DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:90:24\n-   |\n-LL |         self.reference.bget(index).map(&self.closure)\n-   |                        ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `Broadcastable::bget`\n-  --> $DIR/issue-83765.rs:20:33\n-   |\n-LL |     fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n-   |                                 ^^^^^^^^^ required by this bound in `Broadcastable::bget`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:90:29\n-   |\n-LL |         self.reference.bget(index).map(&self.closure)\n-   |                             ^^^^^ expected `Self::DIM`, found `DIM`\n+note: ...which requires checking if `TensorDimension` fulfills its obligations...\n+  --> $DIR/issue-83765.rs:4:1\n    |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n+LL | trait TensorDimension {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n+   = note: cycle used when normalizing `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0277, E0308.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "57e6ac7cf34f52d4b63e8753bf37e8b50aece5dc", "filename": "src/test/ui/typeck/issue-90319.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.rs?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -0,0 +1,17 @@\n+struct Wrapper<T>(T);\n+\n+trait Trait {\n+    fn method(&self) {}\n+}\n+\n+impl<'a, T> Trait for Wrapper<&'a T> where Wrapper<T>: Trait {}\n+\n+fn get<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    let thing = get::<Thing>();//~ERROR cannot find type `Thing` in this scope [E0412]\n+    let wrapper = Wrapper(thing);\n+    Trait::method(&wrapper);\n+}"}, {"sha": "61549dd701e747e2721683e8e02fa3e0acf2c33a", "filename": "src/test/ui/typeck/issue-90319.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-90319.stderr?ref=661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Thing` in this scope\n+  --> $DIR/issue-90319.rs:14:23\n+   |\n+LL |     let thing = get::<Thing>();\n+   |                       ^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}]}