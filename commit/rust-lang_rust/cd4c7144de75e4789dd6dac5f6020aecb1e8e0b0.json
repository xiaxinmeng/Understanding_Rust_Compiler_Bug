{"sha": "cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNGM3MTQ0ZGU3NWU0Nzg5ZGQ2ZGFjNWY2MDIwYWVjYjFlOGUwYjA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T01:59:36Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T03:27:11Z"}, "message": "Deduplicate work between splitting and subtraction\n\nAfter splitting, subtraction becomes much simpler", "tree": {"sha": "a0710d8f34bf4d509581935bb3816ab015885467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0710d8f34bf4d509581935bb3816ab015885467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "html_url": "https://github.com/rust-lang/rust/commit/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fab669f8dbc1138509fe3a28c200cab5c54db21", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fab669f8dbc1138509fe3a28c200cab5c54db21", "html_url": "https://github.com/rust-lang/rust/commit/1fab669f8dbc1138509fe3a28c200cab5c54db21"}], "stats": {"total": 303, "additions": 87, "deletions": 216}, "files": [{"sha": "2e7b3626e8705464999b10f52bccebc1f270e624", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 87, "deletions": 216, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "patch": "@@ -608,46 +608,6 @@ impl SliceKind {\n             VarLen(prefix, suffix) => prefix + suffix <= other_len,\n         }\n     }\n-\n-    /// Returns a collection of slices that spans the values covered by `self`, subtracted by the\n-    /// values covered by `other`: i.e., `self \\ other` (in set notation).\n-    fn subtract(self, other: Self) -> SmallVec<[Self; 1]> {\n-        // Remember, `VarLen(i, j)` covers the union of `FixedLen` from `i + j` to infinity.\n-        // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-        match self {\n-            FixedLen(pos_len) => {\n-                if other.covers_length(pos_len) {\n-                    smallvec![]\n-                } else {\n-                    smallvec![self]\n-                }\n-            }\n-            VarLen(pos_prefix, pos_suffix) => {\n-                let pos_len = pos_prefix + pos_suffix;\n-                match other {\n-                    FixedLen(neg_len) => {\n-                        if neg_len < pos_len {\n-                            smallvec![self]\n-                        } else {\n-                            (pos_len..neg_len)\n-                                .map(FixedLen)\n-                                // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n-                                .chain(Some(VarLen(neg_len + 1 - pos_suffix, pos_suffix)))\n-                                .collect()\n-                        }\n-                    }\n-                    VarLen(neg_prefix, neg_suffix) => {\n-                        let neg_len = neg_prefix + neg_suffix;\n-                        if neg_len <= pos_len {\n-                            smallvec![]\n-                        } else {\n-                            (pos_len..neg_len).map(FixedLen).collect()\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n /// A constructor for array and slice patterns.\n@@ -662,7 +622,7 @@ struct Slice {\n impl Slice {\n     /// Returns what patterns this constructor covers: either fixed-length patterns or\n     /// variable-length patterns.\n-    fn pattern_kind(self) -> SliceKind {\n+    fn kind(self) -> SliceKind {\n         match self {\n             Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n                 if prefix + suffix == len =>\n@@ -673,20 +633,8 @@ impl Slice {\n         }\n     }\n \n-    /// Returns what values this constructor covers: either values of only one given length, or\n-    /// values of length above a given length.\n-    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n-    /// account a subset of the entries of the array, but still only captures values of a given\n-    /// length.\n-    fn value_kind(self) -> SliceKind {\n-        match self {\n-            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n-            _ => self.kind,\n-        }\n-    }\n-\n     fn arity(self) -> u64 {\n-        self.pattern_kind().arity()\n+        self.kind().arity()\n     }\n \n     /// The exhaustiveness-checking paper does not include any details on\n@@ -768,7 +716,7 @@ impl Slice {\n \n         for ctor in head_ctors {\n             if let Slice(slice) = ctor {\n-                match slice.pattern_kind() {\n+                match slice.kind() {\n                     FixedLen(len) => {\n                         max_fixed_len = cmp::max(max_fixed_len, len);\n                     }\n@@ -816,6 +764,11 @@ impl Slice {\n             }\n         }\n     }\n+\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(self, other: Self) -> bool {\n+        other.kind().covers_length(self.arity())\n+    }\n }\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n@@ -861,6 +814,20 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    fn as_intrange(&self) -> Option<&IntRange<'tcx>> {\n+        match self {\n+            IntRange(range) => Some(range),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_slice(&self) -> Option<Slice> {\n+        match self {\n+            Slice(slice) => Some(*slice),\n+            _ => None,\n+        }\n+    }\n+\n     fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n@@ -872,94 +839,6 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    // Returns the set of constructors covered by `self` but not by\n-    // anything in `other_ctors`.\n-    fn subtract_ctors(&self, other_ctors: &Vec<Constructor<'tcx>>) -> Vec<Constructor<'tcx>> {\n-        if other_ctors.is_empty() {\n-            return vec![self.clone()];\n-        }\n-\n-        match self {\n-            // Those constructors can only match themselves.\n-            Single | Variant(_) | Str(..) | FloatRange(..) => {\n-                if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n-            }\n-            &Slice(slice) => {\n-                let mut other_slices = other_ctors\n-                    .iter()\n-                    .filter_map(|c: &Constructor<'_>| match c {\n-                        Slice(slice) => Some(*slice),\n-                        _ => bug!(\"bad slice pattern constructor {:?}\", c),\n-                    })\n-                    .map(Slice::value_kind);\n-\n-                match slice.value_kind() {\n-                    FixedLen(self_len) => {\n-                        if other_slices.any(|other_slice| other_slice.covers_length(self_len)) {\n-                            vec![]\n-                        } else {\n-                            vec![Slice(slice)]\n-                        }\n-                    }\n-                    kind @ VarLen(..) => {\n-                        let mut remaining_slices = vec![kind];\n-\n-                        // For each used slice, subtract from the current set of slices.\n-                        for other_slice in other_slices {\n-                            remaining_slices = remaining_slices\n-                                .into_iter()\n-                                .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n-                                .collect();\n-\n-                            // If the constructors that have been considered so far already cover\n-                            // the entire range of `self`, no need to look at more constructors.\n-                            if remaining_slices.is_empty() {\n-                                break;\n-                            }\n-                        }\n-\n-                        remaining_slices\n-                            .into_iter()\n-                            .map(|kind| Slice { array_len: slice.array_len, kind })\n-                            .map(Slice)\n-                            .collect()\n-                    }\n-                }\n-            }\n-            IntRange(self_range) => {\n-                let mut remaining_ranges = vec![self_range.clone()];\n-                for other_ctor in other_ctors {\n-                    if let IntRange(other_range) = other_ctor {\n-                        if other_range == self_range {\n-                            // If the `self` range appears directly in a `match` arm, we can\n-                            // eliminate it straight away.\n-                            remaining_ranges = vec![];\n-                        } else {\n-                            // Otherwise explicitly compute the remaining ranges.\n-                            remaining_ranges = other_range.subtract_from(remaining_ranges);\n-                        }\n-\n-                        // If the ranges that have been considered so far already cover the entire\n-                        // range of values, we can return early.\n-                        if remaining_ranges.is_empty() {\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                // Convert the ranges back into constructors.\n-                remaining_ranges.into_iter().map(IntRange).collect()\n-            }\n-            // This constructor is never covered by anything else\n-            NonExhaustive => vec![NonExhaustive],\n-            // This constructor is only covered by `Single`s\n-            Unlistable if other_ctors.iter().any(|c| *c == Single) => vec![],\n-            Unlistable => vec![Unlistable],\n-            Opaque => bug!(\"found unexpected opaque ctor in all_ctors\"),\n-            Wildcard => bug!(\"found unexpected wildcard ctor in all_ctors\"),\n-        }\n-    }\n-\n     /// Some constructors (namely Wildcard, IntRange and Slice) actually stand for a set of actual\n     /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n     /// constructors, we want to be specialising for the actual underlying constructors.\n@@ -1003,13 +882,10 @@ impl<'tcx> Constructor<'tcx> {\n         // current column. We only fully construct them on-demand, because they're rarely used and\n         // can be big.\n         let missing_ctors = MissingConstructors::new(pcx);\n-\n-        if missing_ctors.is_empty() {\n+        if missing_ctors.is_empty(pcx) {\n             // All the constructors are present in the matrix, so we just go through them all.\n             // We must also split them first.\n-            // Since `all_ctors` never contains wildcards, this won't recurse more than once.\n-            let (all_ctors, _) = missing_ctors.into_inner();\n-            all_ctors.into_iter().flat_map(|ctor| ctor.split(pcx, None)).collect()\n+            missing_ctors.all_ctors\n         } else {\n             // Some constructors are missing, thus we can specialize with the wildcard constructor,\n             // which will stand for those constructors that are missing, and behaves like any of\n@@ -1021,7 +897,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// Returns whether `self` is covered by `other`, ie whether `self` is a subset of `other`. For\n     /// the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n-    fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Constructor<'tcx>) -> bool {\n+    fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n@@ -1032,14 +908,7 @@ impl<'tcx> Constructor<'tcx> {\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n \n             (IntRange(self_range), IntRange(other_range)) => {\n-                if self_range.intersection(pcx.cx.tcx, other_range).is_some() {\n-                    // Constructor splitting should ensure that all intersections we encounter\n-                    // are actually inclusions.\n-                    assert!(self_range.is_subrange(other_range));\n-                    true\n-                } else {\n-                    false\n-                }\n+                self_range.is_covered_by(pcx, other_range)\n             }\n             (\n                 FloatRange(self_from, self_to, self_end),\n@@ -1066,9 +935,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n             }\n \n-            (Slice(self_slice), Slice(other_slice)) => {\n-                other_slice.pattern_kind().covers_length(self_slice.arity())\n-            }\n+            (Slice(self_slice), Slice(other_slice)) => self_slice.is_covered_by(*other_slice),\n \n             // We are trying to inspect an opaque constant. Thus we skip the row.\n             (Opaque, _) | (_, Opaque) => false,\n@@ -1084,6 +951,39 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n+    /// assumed to be built from `matrix.head_ctors()`, and `self` is assumed to have been split.\n+    fn is_covered_by_any<'p>(\n+        &self,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        used_ctors: &[Constructor<'tcx>],\n+    ) -> bool {\n+        if used_ctors.is_empty() {\n+            return false;\n+        }\n+\n+        match self {\n+            // `used_ctors` cannot contain anything else than `Single`s.\n+            Single => !used_ctors.is_empty(),\n+            Variant(_) => used_ctors.iter().any(|c| c == self),\n+            IntRange(range) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_intrange())\n+                .any(|other| range.is_covered_by(pcx, other)),\n+            Slice(slice) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_slice())\n+                .any(|other| slice.is_covered_by(other)),\n+            // This constructor is never covered by anything else\n+            NonExhaustive => false,\n+            // This constructor is only covered by `Single`s\n+            Unlistable => used_ctors.iter().any(|c| *c == Single),\n+            Str(..) | FloatRange(..) | Opaque | Wildcard => {\n+                bug!(\"found unexpected ctor in all_ctors: {:?}\", self)\n+            }\n+        }\n+    }\n+\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n@@ -1129,7 +1029,7 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n                 _ => PatKind::Wild,\n             },\n-            Slice(slice) => match slice.pattern_kind() {\n+            Slice(slice) => match slice.kind() {\n                 FixedLen(_) => {\n                     PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n                 }\n@@ -1827,13 +1727,6 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_ctor<'a>(ctor: &'a Constructor<'tcx>) -> Option<&'a IntRange<'tcx>> {\n-        match ctor {\n-            IntRange(range) => Some(range),\n-            _ => None,\n-        }\n-    }\n-\n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n         match *ty.kind() {\n@@ -1845,35 +1738,6 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n-    /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n-    fn subtract_from(&self, ranges: Vec<IntRange<'tcx>>) -> Vec<IntRange<'tcx>> {\n-        let mut remaining_ranges = vec![];\n-        let ty = self.ty;\n-        let span = self.span;\n-        let (lo, hi) = self.boundaries();\n-        for subrange in ranges {\n-            let (subrange_lo, subrange_hi) = subrange.range.into_inner();\n-            if lo > subrange_hi || subrange_lo > hi {\n-                // The pattern doesn't intersect with the subrange at all,\n-                // so the subrange remains untouched.\n-                remaining_ranges.push(IntRange { range: subrange_lo..=subrange_hi, ty, span });\n-            } else {\n-                if lo > subrange_lo {\n-                    // The pattern intersects an upper section of the\n-                    // subrange, so a lower section will remain.\n-                    remaining_ranges.push(IntRange { range: subrange_lo..=(lo - 1), ty, span });\n-                }\n-                if hi < subrange_hi {\n-                    // The pattern intersects a lower section of the\n-                    // subrange, so an upper section will remain.\n-                    remaining_ranges.push(IntRange { range: (hi + 1)..=subrange_hi, ty, span });\n-                }\n-            }\n-        }\n-        remaining_ranges\n-    }\n-\n     fn is_subrange(&self, other: &Self) -> bool {\n         other.range.start() <= self.range.start() && self.range.end() <= other.range.end()\n     }\n@@ -2000,7 +1864,7 @@ impl<'tcx> IntRange<'tcx> {\n         let row_borders = pcx\n             .matrix\n             .head_ctors(pcx.cx)\n-            .filter_map(|ctor| IntRange::from_ctor(ctor))\n+            .filter_map(|ctor| ctor.as_intrange())\n             .filter_map(|range| {\n                 let intersection = self.intersection(pcx.cx.tcx, &range);\n                 let should_lint = self.suspicious_intersection(&range);\n@@ -2075,6 +1939,18 @@ impl<'tcx> IntRange<'tcx> {\n             );\n         }\n     }\n+\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n+        if self.intersection(pcx.cx.tcx, other).is_some() {\n+            // Constructor splitting should ensure that all intersections we encounter are actually\n+            // inclusions.\n+            assert!(self.is_subrange(other));\n+            true\n+        } else {\n+            false\n+        }\n+    }\n }\n \n /// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -2085,31 +1961,33 @@ impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n }\n \n // A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+#[derive(Debug)]\n struct MissingConstructors<'tcx> {\n-    all_ctors: Vec<Constructor<'tcx>>,\n+    all_ctors: SmallVec<[Constructor<'tcx>; 1]>,\n     used_ctors: Vec<Constructor<'tcx>>,\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n     fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n         let used_ctors: Vec<Constructor<'_>> =\n             pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n-        let all_ctors = all_constructors(pcx);\n+        // Since `all_ctors` never contains wildcards, this won't recurse further.\n+        let all_ctors =\n+            all_constructors(pcx).into_iter().flat_map(|ctor| ctor.split(pcx, None)).collect();\n \n         MissingConstructors { all_ctors, used_ctors }\n     }\n \n-    fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n-        (self.all_ctors, self.used_ctors)\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter().next().is_none()\n+    fn is_empty<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> bool {\n+        self.iter(pcx).next().is_none()\n     }\n \n     /// Iterate over all_ctors \\ used_ctors\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n-        self.all_ctors.iter().flat_map(move |req_ctor| req_ctor.subtract_ctors(&self.used_ctors))\n+    fn iter<'a, 'p>(\n+        &'a self,\n+        pcx: PatCtxt<'a, 'p, 'tcx>,\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n+        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.used_ctors))\n     }\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n@@ -2156,7 +2034,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n             // constructor, that matches everything that can be built with\n             // it. For example, if `ctor` is a `Constructor::Variant` for\n             // `Option::Some`, we get the pattern `Some(_)`.\n-            self.iter()\n+            self.iter(pcx)\n                 .map(|missing_ctor| {\n                     let fields = Fields::wildcards(pcx, &missing_ctor);\n                     missing_ctor.apply(pcx, fields)\n@@ -2166,13 +2044,6 @@ impl<'tcx> MissingConstructors<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let ctors: Vec<_> = self.iter().collect();\n-        write!(f, \"{:?}\", ctors)\n-    }\n-}\n-\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:"}]}