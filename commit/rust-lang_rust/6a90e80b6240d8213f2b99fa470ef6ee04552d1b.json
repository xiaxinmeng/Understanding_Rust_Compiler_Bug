{"sha": "6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOTBlODBiNjI0MGQ4MjEzZjJiOTlmYTQ3MGVmNmVlMDQ1NTJkMWI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-20T06:08:47Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-09T13:17:29Z"}, "message": "option: rewrite the API to use composition", "tree": {"sha": "e7ae38c849741fc9345652311dfa374f36b4be9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ae38c849741fc9345652311dfa374f36b4be9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "html_url": "https://github.com/rust-lang/rust/commit/6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f647ccc79c38c1f80dbdb697900b2ba97e293263", "url": "https://api.github.com/repos/rust-lang/rust/commits/f647ccc79c38c1f80dbdb697900b2ba97e293263", "html_url": "https://github.com/rust-lang/rust/commit/f647ccc79c38c1f80dbdb697900b2ba97e293263"}], "stats": {"total": 521, "additions": 244, "deletions": 277}, "files": [{"sha": "b5057013328d3c9c400d85e2d8c1c144158d7315", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -109,8 +109,8 @@ pub fn parse_config(args: ~[~str]) -> config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map_move(|s| Path(s)),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map_move(|s| Path(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| Path(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n@@ -123,10 +123,10 @@ pub fn parse_config(args: ~[~str]) -> config {\n             } else {\n                 None\n             },\n-        logfile: matches.opt_str(\"logfile\").map_move(|s| Path(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map_move(|s| Path(s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| Path(s)),\n+        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path(s)),\n         ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map_move(|s| Path(s)),\n+            matches.opt_str(\"ratchet-metrics\").map(|s| Path(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n         runtool: matches.opt_str(\"runtool\"),"}, {"sha": "4da8bc89ea622586cb890277a722ab662eeae5fe", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -114,7 +114,7 @@ impl<T: Send> GenericPort<T> for SyncPort<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        do self.duplex_stream.try_recv().map_move |val| {\n+        do self.duplex_stream.try_recv().map |val| {\n             self.duplex_stream.try_send(());\n             val\n         }"}, {"sha": "6668e9871f4f7eb958b8ca7648cbbd8c4cc4fc03", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -165,7 +165,7 @@ impl<T> DList<T> {\n     /// Remove the first Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_head.take().map_move |mut front_node| {\n+        do self.list_head.take().map |mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n@@ -191,7 +191,7 @@ impl<T> DList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_tail.resolve().map_move_default(None) |tail| {\n+        do self.list_tail.resolve().map_default(None) |tail| {\n             self.length -= 1;\n             self.list_tail = tail.prev;\n             match tail.prev.resolve() {\n@@ -206,25 +206,27 @@ impl<T> Deque<T> for DList<T> {\n     /// Provide a reference to the front element, or None if the list is empty\n     #[inline]\n     fn front<'a>(&'a self) -> Option<&'a T> {\n-        self.list_head.map(|head| &head.value)\n+        self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provide a mutable reference to the front element, or None if the list is empty\n     #[inline]\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.list_head.map_mut(|head| &mut head.value)\n+        self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provide a reference to the back element, or None if the list is empty\n     #[inline]\n     fn back<'a>(&'a self) -> Option<&'a T> {\n-        self.list_tail.resolve_immut().map(|tail| &tail.value)\n+        let tmp = self.list_tail.resolve_immut(); // FIXME: #3511: shouldn't need variable\n+        tmp.as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provide a mutable reference to the back element, or None if the list is empty\n     #[inline]\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.list_tail.resolve().map_mut(|tail| &mut tail.value)\n+        let mut tmp = self.list_tail.resolve(); // FIXME: #3511: shouldn't need variable\n+        tmp.as_mut().map(|tail| &mut tail.value)\n     }\n \n     /// Add an element first in the list\n@@ -238,7 +240,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map_move(|~Node{value, _}| value)\n+        self.pop_front_node().map(|~Node{value, _}| value)\n     }\n \n     /// Add an element last in the list\n@@ -252,7 +254,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map_move(|~Node{value, _}| value)\n+        self.pop_back_node().map(|~Node{value, _}| value)\n     }\n }\n \n@@ -268,7 +270,7 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_forward(&mut self) {\n-        do self.pop_back_node().map_move |tail| {\n+        do self.pop_back_node().map |tail| {\n             self.push_front_node(tail)\n         };\n     }\n@@ -278,7 +280,7 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_backward(&mut self) {\n-        do self.pop_front_node().map_move |head| {\n+        do self.pop_front_node().map |head| {\n             self.push_back_node(head)\n         };\n     }\n@@ -442,7 +444,7 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.map |head| {\n+        do self.head.as_ref().map |head| {\n             self.nelem -= 1;\n             self.head = &head.next;\n             &head.value\n@@ -461,7 +463,8 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map_move |prev| {\n+        let tmp = self.tail.resolve_immut(); // FIXME: #3511: shouldn't need variable\n+        do tmp.as_ref().map |prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &prev.value\n@@ -477,7 +480,7 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.resolve().map_move |next| {\n+        do self.head.resolve().map |next| {\n             self.nelem -= 1;\n             self.head = match next.next {\n                 Some(ref mut node) => Rawlink::some(&mut **node),\n@@ -499,7 +502,7 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map_move |prev| {\n+        do self.tail.resolve().map |prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &mut prev.value\n@@ -554,7 +557,7 @@ impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None\n         }\n-        self.head.resolve().map_move(|head| &mut head.value)\n+        self.head.resolve().map(|head| &mut head.value)\n     }\n }\n "}, {"sha": "bf3fe4b39b2770d49540fc872010742e9e021ee6", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -596,8 +596,7 @@ mod test {\n             |i| format!(\"tmp/lib-fileinput-test-next-file-{}.tmp\", i)),true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n-            let contents =\n-                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n+            let contents = vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n         }\n "}, {"sha": "ed68f3162aa569cd0940db0ebdfc0c50aa5dbe48", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -698,7 +698,7 @@ impl BigUint {\n     #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n-        let new_len = v.iter().rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n+        let new_len = v.iter().rposition(|n| *n != 0).map_default(0, |p| p + 1);\n \n         if new_len == v.len() { return BigUint { data: v }; }\n         let mut v = v;\n@@ -1417,7 +1417,7 @@ impl BigInt {\n             start = 1;\n         }\n         return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n-            .map_move(|bu| BigInt::from_biguint(sign, bu));\n+            .map(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n     /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n@@ -2507,7 +2507,7 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map_move(|n| {\n+            let ans = ans.map(|n| {\n                 let x: BigInt = FromPrimitive::from_int(n).unwrap();\n                 x\n             });"}, {"sha": "794b25c2e38e25a92bd14797ba5d7ea34c93059f", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -158,7 +158,7 @@ impl<V> SmallIntMap<V> {\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.move_iter().enumerate().filter_map(|(i, v)| {\n-            v.map_move(|v| (i, v))\n+            v.map(|v| (i, v))\n         })\n     }\n }"}, {"sha": "85975ba6347d572cf779fb58d80b9f59547c26ee", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -127,7 +127,7 @@ impl Terminal {\n         let inf = ti.unwrap();\n         let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n                  && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_move_default(0, |&n| n)\n+                     inf.numbers.find_equiv(&(\"colors\")).map_default(0, |&n| n)\n                  } else { 0 };\n \n         return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n@@ -220,7 +220,7 @@ impl Terminal {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = do cap.map_move_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+        let s = do cap.map_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n             expand(*op, [], &mut Variables::new())\n         };\n         if s.is_ok() {"}, {"sha": "09e1fae14afc7299b087ddf1539a104409910833", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -241,20 +241,20 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map_move(|s| Path(s));\n+    let logfile = logfile.map(|s| Path(s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n         matches.opt_present(\"test\");\n \n     let ratchet_metrics = matches.opt_str(\"ratchet-metrics\");\n-    let ratchet_metrics = ratchet_metrics.map_move(|s| Path(s));\n+    let ratchet_metrics = ratchet_metrics.map(|s| Path(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map_move(|s| from_str::<f64>(s).unwrap());\n+    let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n-    let save_metrics = save_metrics.map_move(|s| Path(s));\n+    let save_metrics = save_metrics.map(|s| Path(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n     let test_shard = opt_shard(test_shard);"}, {"sha": "432d854ad5469f471c1b302eeecfb6b2e2253eee", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -385,15 +385,15 @@ impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map_move |(value, _)| { value }\n+        do self.iter.next().map |(value, _)| { value }\n     }\n }\n \n impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map |&(value, _)| { value }\n+        do self.iter.next().map |(value, _)| { value }\n     }\n }\n \n@@ -686,7 +686,7 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n \n // Remove left horizontal link by rotating right\n fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n-    if node.left.map_default(false, |x| x.level == node.level) {\n+    if node.left.as_ref().map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.take_unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n         swap(node, &mut save);\n@@ -697,8 +697,8 @@ fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n-    if node.right.map_default(false,\n-      |x| x.right.map_default(false, |y| y.level == node.level)) {\n+    if node.right.as_ref().map_default(false,\n+      |x| x.right.as_ref().map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.take_unwrap();\n         swap(&mut node.right, &mut save.left); // save.left now None\n         save.level += 1;\n@@ -804,8 +804,8 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n         };\n \n         if rebalance {\n-            let left_level = save.left.map_default(0, |x| x.level);\n-            let right_level = save.right.map_default(0, |x| x.level);\n+            let left_level = save.left.as_ref().map_default(0, |x| x.level);\n+            let right_level = save.right.as_ref().map_default(0, |x| x.level);\n \n             // re-balance, if necessary\n             if left_level < save.level - 1 || right_level < save.level - 1 {"}, {"sha": "27951a241da35bd96299d3656de2f26e45afd90f", "filename": "src/librust/rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -128,7 +128,7 @@ fn rustdoc_help() {\n fn find_cmd(command_string: &str) -> Option<Command> {\n     do COMMANDS.iter().find |command| {\n         command.cmd == command_string\n-    }.map_move(|x| *x)\n+    }.map(|x| *x)\n }\n \n fn cmd_help(args: &[~str]) -> ValidUsage {"}, {"sha": "4b6d2ea50801ac68333cd4dbb75e50bdc0c23b4e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -719,7 +719,7 @@ pub fn build_session_options(binary: @str,\n         } else if matches.opt_present(\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = matches.opt_str(\"sysroot\").map_move(|m| @Path(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n     let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");"}, {"sha": "becf5059f32431a38da9229d1db1b0a41592d445", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -72,7 +72,7 @@ fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n         filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map_move |x| {\n+        do filter_view_item(cx, a).map |x| {\n             cx.fold_view_item(x)\n         }\n     }.collect();\n@@ -97,7 +97,7 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n                            .collect();\n     let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map_move |x| {\n+        do filter_view_item(cx, a).map |x| {\n             cx.fold_view_item(x)\n         }\n     }.collect();\n@@ -152,12 +152,12 @@ fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n         filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(*x))\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }.collect();\n     ast::Block {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n-        expr: b.expr.map(|x| cx.fold_expr(*x)),\n+        expr: b.expr.map(|x| cx.fold_expr(x)),\n         id: b.id,\n         rules: b.rules,\n         span: b.span,"}, {"sha": "04d8b3bee821317e470514012f367622006aeac6", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -1786,7 +1786,7 @@ impl TypeNames {\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.find_equiv(&s).map_move(|x| Type::from_ref(*x))\n+        self.named_types.find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n     // We have a depth count, because we seem to make infinite types."}, {"sha": "226c19a5d5e46ba0dd5cc89ee70f29405995bb41", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -133,7 +133,7 @@ pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n                                  emod_id: ast::NodeId)\n                        -> Option<ast::CrateNum> {\n-    cstore.extern_mod_crate_map.find(&emod_id).map_move(|x| *x)\n+    cstore.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n }\n \n #[deriving(Clone)]"}, {"sha": "cf34d129fec899f282dc912c5e28ce2058aeae56", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -200,7 +200,7 @@ fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n }\n \n fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n-    do reader::maybe_get_doc(d, tag_item_method_provided_source).map_move |doc| {\n+    do reader::maybe_get_doc(d, tag_item_method_provided_source).map |doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     }\n }\n@@ -267,7 +267,7 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n }\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    do reader::maybe_get_doc(item, tag_region_param).map_move |doc| {\n+    do reader::maybe_get_doc(item, tag_region_param).map |doc| {\n         let mut decoder = reader::Decoder(doc);\n         Decodable::decode(&mut decoder)\n     }\n@@ -400,7 +400,7 @@ pub fn get_trait_def(cdata: Cmd,\n     do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n         // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map_move |bound| {\n+        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map |bound| {\n             bounds.add(bound);\n         };\n         true\n@@ -446,7 +446,7 @@ pub fn get_impl_trait(cdata: Cmd,\n                        tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map_move |tp| {\n+    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |tp| {\n         @doc_trait_ref(tp, tcx, cdata)\n     }\n }"}, {"sha": "8464c19cb01594443bfe9f30bbfb6e4b28f359df", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -319,13 +319,13 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_deref(cmt_base, _, pk) => {\n-            do opt_loan_path(cmt_base).map_move |lp| {\n+            do opt_loan_path(cmt_base).map |lp| {\n                 @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n             }\n         }\n \n         mc::cat_interior(cmt_base, ik) => {\n-            do opt_loan_path(cmt_base).map_move |lp| {\n+            do opt_loan_path(cmt_base).map |lp| {\n                 @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n             }\n         }"}, {"sha": "2d03b0c778d67fa0f3cc11c411767e37778aaab3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -897,7 +897,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(*) is legal, but x @ Foo(y) isn't.\n-        if sub.map_move_default(false, |p| pat_contains_bindings(def_map, p)) {\n+        if sub.map_default(false, |p| pat_contains_bindings(def_map, p)) {\n             tcx.sess.span_err(\n                 p.span,\n                 \"cannot bind by-move with sub-bindings\");"}, {"sha": "c3bd9c739edba44feb3cf871074f85240b44a72e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -507,9 +507,9 @@ pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<in\n }\n \n pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n-    compare_lit_exprs(tcx, a, b).map_move(|val| val == 0)\n+    compare_lit_exprs(tcx, a, b).map(|val| val == 0)\n }\n \n pub fn lit_eq(a: &lit, b: &lit) -> Option<bool> {\n-    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map_move(|val| val == 0)\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|val| val == 0)\n }"}, {"sha": "6c15dc019ea34de95f130a61d0fce2466fb769cb", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -418,7 +418,7 @@ impl<'self> LanguageItemCollector<'self> {\n             return;    // Didn't match.\n         }\n \n-        let item_index = self.item_refs.find_equiv(&value).map_move(|x| *x);\n+        let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n         // prevent borrow checker from considering         ^~~~~~~~~~~\n         // self to be borrowed (annoying)\n "}, {"sha": "84cffc0e94c7f68555238bb9ea761d711db543a8", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -1001,7 +1001,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         match cx.tcx.items.find(&id.node) {\n             Some(ast_node) => {\n                 let s = do ast_node.with_attrs |attrs| {\n-                    do attrs.map_move |a| {\n+                    do attrs.map |a| {\n                         attr::find_stability(a.iter().map(|a| a.meta()))\n                     }\n                 };"}, {"sha": "27384a6ab4b19e07e63cd260847640a1428ea7a1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -619,7 +619,7 @@ impl Liveness {\n         match expr.node {\n           ExprPath(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n-            do moves::moved_variable_node_id_from_def(def).map_move |rdef| {\n+            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n                 self.variable(rdef, expr.span)\n             }\n           }\n@@ -635,7 +635,7 @@ impl Liveness {\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            do moves::moved_variable_node_id_from_def(def).map_move |rdef| {\n+            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n                 self.variable(rdef, span)\n             }\n           }"}, {"sha": "0ae8e01fe9d42d04420cb6a171c483497ae23b28", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -117,7 +117,7 @@ impl RegionMaps {\n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n-        self.scope_map.find(&id).map_move(|x| *x)\n+        self.scope_map.find(&id).map(|x| *x)\n     }\n \n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n@@ -613,7 +613,7 @@ impl DetermineRpCtxt {\n     /// the new variance is joined with the old variance.\n     pub fn add_rp(&mut self, id: ast::NodeId, variance: region_variance) {\n         assert!(id != 0);\n-        let old_variance = self.region_paramd_items.find(&id).map_move(|x| *x);\n+        let old_variance = self.region_paramd_items.find(&id).map(|x| *x);\n         let joined_variance = match old_variance {\n           None => variance,\n           Some(v) => join_variance(v, variance)"}, {"sha": "deeeae7bec0b41d9f99a3d8f857916ae16400599", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -3463,7 +3463,7 @@ impl Resolver {\n                   // item, it's ok\n                   match def {\n                     DefTyParam(did, _)\n-                        if self.def_map.find(&did.node).map_move(|x| *x)\n+                        if self.def_map.find(&did.node).map(|x| *x)\n                             == Some(DefTyParamBinder(item_id)) => {\n                       // ok\n                     }\n@@ -4255,15 +4255,15 @@ impl Resolver {\n                     }\n                 }\n \n-                do bounds.map |bound_vec| {\n+                do bounds.as_ref().map |bound_vec| {\n                     for bound in bound_vec.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n                 };\n             }\n \n             ty_closure(c) => {\n-                do c.bounds.map |bounds| {\n+                do c.bounds.as_ref().map |bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }"}, {"sha": "009745ff2adb8ba0a7155fe5c80da341ca615bb2", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -96,7 +96,7 @@ impl<T:Subst + 'static> Subst for @T {\n \n impl<T:Subst> Subst for Option<T> {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Option<T> {\n-        self.map(|t| t.subst(tcx, substs))\n+        self.as_ref().map(|t| t.subst(tcx, substs))\n     }\n }\n "}, {"sha": "025d1a18bd7e5b9555aff795d50c392d7d78543c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -113,7 +113,7 @@ pub struct _InsnCtxt { _x: () }\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n         do local_data::modify(task_local_insn_key) |c| {\n-            do c.map_move |mut ctx| {\n+            do c.map |mut ctx| {\n                 ctx.pop();\n                 ctx\n             }\n@@ -124,7 +124,7 @@ impl Drop for _InsnCtxt {\n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug2!(\"new InsnCtxt: {}\", s);\n     do local_data::modify(task_local_insn_key) |c| {\n-        do c.map_move |mut ctx| {\n+        do c.map |mut ctx| {\n             ctx.push(s);\n             ctx\n         }"}, {"sha": "8bdef802afb1d37024f4419d277534a7ff914282", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -161,7 +161,7 @@ fn struct_ty(ty: Type,\n              padding: Option<Type>,\n              coerce: bool) -> Type {\n     let size = ty_size(ty) * 8;\n-    let mut fields = padding.map_move_default(~[], |p| ~[p]);\n+    let mut fields = padding.map_default(~[], |p| ~[p]);\n \n     if coerce {\n         fields = vec::append(fields, coerce_to_int(size));"}, {"sha": "6edcb6e25a535ae90b2c5f2cb7a9b181fb21a92c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -634,7 +634,7 @@ impl get_node_info for ast::Block {\n \n impl get_node_info for Option<@ast::Expr> {\n     fn info(&self) -> Option<NodeInfo> {\n-        self.and_then_ref(|s| s.info())\n+        self.as_ref().and_then(|s| s.info())\n     }\n }\n \n@@ -1145,7 +1145,7 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n-    raw_vtables.map_move(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+    raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n // Apply the typaram substitutions in the FunctionContext to some"}, {"sha": "2b473d2b6e1768d342671083b4e24dd52409dae9", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -283,7 +283,7 @@ impl Drop for CrateContext {\n local_data_key!(task_local_llcx_key: @ContextRef)\n \n pub fn task_llcx() -> ContextRef {\n-    let opt = local_data::get(task_local_llcx_key, |k| k.map_move(|k| *k));\n+    let opt = local_data::get(task_local_llcx_key, |k| k.map(|k| *k));\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n }\n "}, {"sha": "f8554ea397aa75b78dc96dd6958a86bb60eeb8df", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -77,7 +77,7 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n                                abis: AbiSet) -> Option<CallConv> {\n     let arch = ccx.sess.targ_cfg.arch;\n     abis.for_arch(arch).map(|abi| {\n-        match *abi {\n+        match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n                 ccx.sess.bug(format!(\"Asked to register intrinsic fn\"));"}, {"sha": "d661e5559ba031a864810fc8f7b53f999635c6f6", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -176,7 +176,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n-                    temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n+                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n                     self_mode: mentry.self_mode,\n                 })\n             }\n@@ -356,7 +356,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n-                  temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n+                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n                   self_mode: mentry.self_mode,\n               })\n           }"}, {"sha": "753d4ab700918fce3a5e6e7ecac0dc05aec161b2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -1349,7 +1349,7 @@ pub fn fold_bare_fn_ty(fty: &BareFnTy, fldop: &fn(t) -> t) -> BareFnTy {\n fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n         substs {regions: substs.regions.clone(),\n-                self_ty: substs.self_ty.map(|t| fldop(*t)),\n+                self_ty: substs.self_ty.map(|t| fldop(t)),\n                 tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n@@ -1449,7 +1449,7 @@ pub fn fold_regions_and_ty(\n \n         substs {\n             regions: regions,\n-            self_ty: substs.self_ty.map(|t| fldt(*t)),\n+            self_ty: substs.self_ty.map(|t| fldt(t)),\n             tps: substs.tps.map(|t| fldt(*t))\n         }\n     }\n@@ -3619,7 +3619,7 @@ pub fn def_has_ty_params(def: ast::Def) -> bool {\n }\n \n pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    cx.provided_method_sources.find(&id).map_move(|x| *x)\n+    cx.provided_method_sources.find(&id).map(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n@@ -3791,7 +3791,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::DefId) -> Option<ast::DefId> {\n         Some(&ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n-                    do struct_def.ctor_id.map_move |ctor_id| {\n+                    do struct_def.ctor_id.map |ctor_id| {\n                         ast_util::local_def(ctor_id)\n                     }\n                 }"}, {"sha": "fdf0a094dc078213581c5527f5da94426f904bac", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -645,7 +645,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         in_binding_rscope(rscope,\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n-    let opt_transformed_self_ty = do opt_self_info.map_move |self_info| {\n+    let opt_transformed_self_ty = do opt_self_info.map |self_info| {\n         transform_self_ty(this, &rb, self_info)\n     };\n \n@@ -749,7 +749,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n     let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n-        let expected_arg_ty = do expected_sig.and_then_ref |e| {\n+        let expected_arg_ty = do expected_sig.as_ref().and_then |e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}"}, {"sha": "545a487ab441265ba0ca18fc0aaaa8e415097728", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -165,7 +165,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n                     // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_move_default(~\"\", |e| {\n+                                                       expected.map_default(~\"\", |e| {\n                         format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n@@ -214,7 +214,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_move_default(~\"\", |e| {\n+                                               expected.map_default(~\"\", |e| {\n                     format!(\"mismatched types: expected `{}` but found {}\",\n                          e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n@@ -519,7 +519,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n-                            expected.map_move_default(~\"\", |e| {\n+                            expected.map_default(~\"\", |e| {\n                                     format!(\"mismatched types: expected `{}` but found {}\",\n                                          e, actual)})},\n                                          Some(expected), ~\"a structure pattern\",\n@@ -566,7 +566,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                 };\n                 // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                expected.map_move_default(~\"\", |e| {\n+                expected.map_default(~\"\", |e| {\n                     format!(\"mismatched types: expected `{}` but found {}\",\n                                      e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n@@ -616,7 +616,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n-                      expected.map_move_default(~\"\", |e| {\n+                      expected.map_default(~\"\", |e| {\n                           format!(\"mismatched types: expected `{}` but found {}\",\n                                e, actual)})},\n                   Some(expected),\n@@ -675,7 +675,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_move_default(~\"\", |e| {\n+                    expected.map_default(~\"\", |e| {\n                         format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                 Some(expected),"}, {"sha": "fad766f5066d2938ddb201a3f19c8f80b060a6fe", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -440,7 +440,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 |br| ty::re_free(ty::FreeRegion {scope_id: body.id,\n                                                  bound_region: br}));\n         let opt_self_info =\n-            opt_self_info.map_move(\n+            opt_self_info.map(\n                 |si| SelfInfo {self_ty: opt_self_ty.unwrap(), .. si});\n         (isr, opt_self_info, fn_sig)\n     };\n@@ -540,7 +540,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n {\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n-    let opt_self_info = method_ty.transformed_self_ty.map_move(|ty| {\n+    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n         SelfInfo {self_ty: ty,\n                   self_id: method.self_id,\n                   span: method.explicit_self.span}\n@@ -561,7 +561,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n \n     for p in fields.iter() {\n         let (id, sp) = *p;\n-        let orig_sp = field_names.find(&id).map_move(|x| *x);\n+        let orig_sp = field_names.find(&id).map(|x| *x);\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, format!(\"Duplicate field name {} in record type declaration\",\n@@ -605,7 +605,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(_, _, _, ref ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n+        let rp = ccx.tcx.region_paramd_items.find(&it.id).map(|x| *x);\n         debug2!(\"item_impl {} with id {} rp {:?}\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for m in ms.iter() {\n@@ -2026,7 +2026,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident.name).map_move(|x| *x);\n+            let pair = class_field_map.find(&field.ident.name).map(|x| *x);\n             match pair {\n                 None => {\n                     tcx.sess.span_err(\n@@ -2110,7 +2110,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         if class_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&class_id.node).\n-                    map_move(|x| *x);\n+                    map(|x| *x);\n             match tcx.items.find(&class_id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_struct(_, ref generics),\n@@ -2198,7 +2198,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let raw_type;\n         if enum_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node).map_move(|x| *x);\n+                tcx.region_paramd_items.find(&enum_id.node).map(|x| *x);\n             match tcx.items.find(&enum_id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_enum(_, ref generics),"}, {"sha": "b4ac7aaa6d227e90f5ac3a7dfba8aa72f1d5d3e7", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -36,7 +36,7 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     debug2!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n             all_tys={:?})\",\n-           opt_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n+           opt_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n            all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n@@ -48,12 +48,12 @@ pub fn replace_bound_regions_in_fn_sig(\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n+    let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n     debug2!(\"result of replace_bound_regions_in_fn_sig: \\\n             new_self_ty={:?}, \\\n             fn_sig={}\",\n-           new_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n+           new_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n     return (isr, new_self_ty, new_fn_sig);"}, {"sha": "46805af8938a3dd1963430ba70eb8e8103191b44", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -141,7 +141,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n-        let trait_ref = substs.map_default(trait_ref, |substs| {\n+        let trait_ref = substs.as_ref().map_default(trait_ref, |substs| {\n             debug2!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n@@ -330,8 +330,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n     // XXX: this is a bad way to do this, since we do\n     // pointless allocations.\n-    let impls = tcx.trait_impls.find(&trait_ref.def_id)\n-        .map_default(@mut ~[], |x| **x);\n+    let impls = tcx.trait_impls.find(&trait_ref.def_id).map_default(@mut ~[], |x| *x);\n     // impls is the list of all impls in scope for trait_ref.\n     for im in impls.iter() {\n         // im is one specific impl of trait_ref.\n@@ -485,7 +484,7 @@ fn fixup_substs(vcx: &VtableContext,\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n-        match ty::get(*t_f).sty {\n+        match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail2!(\"t_f should be a trait\")\n         }"}, {"sha": "238bcff653737274989b1fe3bc6a6b8e7912e9ef", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -209,7 +209,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&trait_id).map_move(|x| *x);\n+    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|x| *x);\n     match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n@@ -843,7 +843,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     debug2!(\"convert: item {} with id {} rp {:?}\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n@@ -1064,7 +1064,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n       Some(&def) => return def,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n         ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n@@ -1096,7 +1096,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n       Some(&tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n       ast::item_static(ref t, _, _) => {\n         let typ = ccx.to_ty(&EmptyRscope, t);\n@@ -1133,7 +1133,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n           None => { }\n         }\n \n-        let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n+        let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let tpt = {"}, {"sha": "c93b50c76b0c86847d82251275113f009cc6a426", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -727,13 +727,13 @@ impl InferCtxt {\n                                                 err: Option<&ty::type_err>) {\n         debug2!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = do err.map_move_default(~\"\") |t_err| {\n+        let error_str = do err.map_default(~\"\") |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         };\n-        let resolved_expected = do expected_ty.map_move |e_ty| {\n+        let resolved_expected = do expected_ty.map |e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n         };\n-        if !resolved_expected.map_move_default(false, |e| { ty::type_is_error(e) }) {\n+        if !resolved_expected.map_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,\n                             format!(\"{}{}\", mk_msg(None, actual_ty), error_str)),"}, {"sha": "7cc1943a453d418491eb3d0a956226a91b0fb367", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -261,10 +261,10 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = matches.opt_str(\"out-dir\").map_move(|o| Path(o));\n-    let ofile = matches.opt_str(\"o\").map_move(|o| Path(o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path(o));\n     let cfg = build_configuration(sess);\n-    let pretty = do matches.opt_default(\"pretty\", \"normal\").map_move |a| {\n+    let pretty = do matches.opt_default(\"pretty\", \"normal\").map |a| {\n         parse_pretty(sess, a)\n     };\n     match pretty {"}, {"sha": "e0585adaa32b8a082c4639fd68aa66d3bbeed904", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -1008,7 +1008,7 @@ impl Clean<ViewItemInner> for ast::view_item_ {\n     fn clean(&self) -> ViewItemInner {\n         match self {\n             &ast::view_item_extern_mod(ref i, ref p, ref mi, ref id) =>\n-                ExternMod(i.clean(), p.map(|&(ref x, _)| x.to_owned()),  mi.clean(), *id),\n+                ExternMod(i.clean(), p.map(|(ref x, _)| x.to_owned()),  mi.clean(), *id),\n             &ast::view_item_use(ref vp) => Import(vp.clean())\n         }\n     }\n@@ -1208,5 +1208,5 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n     let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n-    dm.find(&id).map_move(|&d| ast_util::def_id_of_def(d))\n+    dm.find(&id).map(|&d| ast_util::def_id_of_def(d))\n }"}, {"sha": "4f73ce1b5dd2e84bf9d1ac377b216b1de3691321", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -134,7 +134,7 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info2!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n+    let output = matches.opt_str(\"o\").map(|s| Path(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n             html::render::run(crate, output.unwrap_or(Path(\"doc\")))"}, {"sha": "b7f13f3f6b6eff41baf0c10950e7ecb49a743ced", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -220,7 +220,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n                 }\n             }\n         }\n-        result = do blk.expr.map_move |e| {\n+        result = do blk.expr.map |e| {\n             do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n         };\n     }"}, {"sha": "8428c373de6f67e888004b6556f83d55a6b5e0e0", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -230,7 +230,7 @@ impl PkgSrc {\n \n     /// True if the given path's stem is self's pkg ID's stem\n     fn stem_matches(&self, p: &Path) -> bool {\n-        p.filestem().map_default(false, |p| { p == &self.id.short_name.as_slice() })\n+        p.filestem().map_default(false, |p| { p == self.id.short_name.as_slice() })\n     }\n \n     pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {"}, {"sha": "f0e9274144577f63d11f9c945bfd30f34e3d37bc", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -272,7 +272,7 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n-        let absolute_path = dir_to_search.push_rel(result_filename);\n+        let absolute_path = dir_to_search.push_rel(&result_filename);\n         debug2!(\"result_filename = {}\", absolute_path.to_str());\n         absolute_path\n     };"}, {"sha": "42b8ebe495355df41e69a56e64fdce6cf6987b82", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -558,7 +558,8 @@ impl CtxMethods for BuildContext {\n         let maybe_executable = built_executable_in_workspace(id, source_workspace);\n         let maybe_library = built_library_in_workspace(id, source_workspace);\n         let target_exec = target_executable_in_workspace(id, target_workspace);\n-        let target_lib = maybe_library.map(|_p| target_library_in_workspace(id, target_workspace));\n+        let target_lib = maybe_library.as_ref()\n+            .map(|_| target_library_in_workspace(id, target_workspace));\n \n         debug2!(\"target_exec = {} target_lib = {:?} \\\n                maybe_executable = {:?} maybe_library = {:?}\","}, {"sha": "6ef0b384a64397ca1e19294e8b947039a24e13ce", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -359,7 +359,7 @@ fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.to_str(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n-        os::path_exists(exec) && is_rwx(exec)\n+        os::path_exists(&exec) && is_rwx(&exec)\n     }\n }\n \n@@ -538,8 +538,8 @@ fn test_install_valid() {\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, &temp_workspace);\n     debug2!(\"lib = {:?}\", lib);\n-    assert!(lib.map_default(false, |l| os::path_exists(l)));\n-    assert!(lib.map_default(false, |l| is_rwx(l)));\n+    assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n@@ -827,8 +827,8 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\"),\n-                &tmp).map_default(false, |m| { os::path_exists(m) }));\n+    let res = built_executable_in_workspace(&PkgId::new(\"foo\"), &tmp);\n+    assert!(!res.as_ref().map_default(false, |m| { os::path_exists(m) }));\n }\n \n #[test]"}, {"sha": "8bd6b04864ba7f4de874cc6517cc6579cb919da4", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -554,5 +554,5 @@ pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n     debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.to_str(), os::path_exists(p));\n     let out = p.stat().map(|stat| stat.st_mtime);\n     debug2!(\"Date = {:?}\", out);\n-    out.map(|t| { *t as libc::time_t })\n+    out.map(|t| { t as libc::time_t })\n }"}, {"sha": "7828fa09d970d2a4315845ad232e548b40ff53e8", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -106,7 +106,7 @@ impl<T, U> Condition<T, U> {\n     /// ```\n     pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n         let h: Closure = unsafe { ::cast::transmute(h) };\n-        let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n+        let prev = local_data::get(self.key, |k| k.map(|x| *x));\n         let h = @Handler { handle: h, prev: prev };\n         Trap { cond: self, handler: h }\n     }"}, {"sha": "7816480efab243258f905237a693f21f525b3fbb", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -239,7 +239,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         let len_buckets = self.buckets.len();\n         let bucket = self.buckets[idx].take();\n \n-        let value = do bucket.map_move |bucket| {\n+        let value = do bucket.map |bucket| {\n             bucket.value\n         };\n \n@@ -480,7 +480,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map_move(|v| (*v).clone())\n+        self.find(k).map(|v| (*v).clone())\n     }\n \n     /// Like `get`, but returns a copy of the value."}, {"sha": "08298889101373d91a50d522a4073cbddfcacb88", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -617,7 +617,7 @@ pub trait Iterator<A> {\n                     Some((y, y_val))\n                 }\n             }\n-        }).map_move(|(x, _)| x)\n+        }).map(|(x, _)| x)\n     }\n \n     /// Return the element that gives the minimum value from the\n@@ -641,7 +641,7 @@ pub trait Iterator<A> {\n                     Some((y, y_val))\n                 }\n             }\n-        }).map_move(|(x, _)| x)\n+        }).map(|(x, _)| x)\n     }\n }\n \n@@ -1550,17 +1550,17 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'self,\n                     return Some(x)\n                 }\n             }\n-            match self.iter.next().map_move(|x| (self.f)(x)) {\n-                None => return self.backiter.and_then_mut_ref(|it| it.next()),\n+            match self.iter.next().map(|x| (self.f)(x)) {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n                 next => self.frontiter = next,\n             }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (flo, fhi) = self.frontiter.map_default((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.map_default((0, Some(0)), |it| it.size_hint());\n+        let (flo, fhi) = self.frontiter.as_ref().map_default((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_default((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(&b)),\n@@ -1582,8 +1582,8 @@ impl<'self,\n                     y => return y\n                 }\n             }\n-            match self.iter.next_back().map_move(|x| (self.f)(x)) {\n-                None => return self.frontiter.and_then_mut_ref(|it| it.next_back()),\n+            match self.iter.next_back().map(|x| (self.f)(x)) {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                 next => self.backiter = next,\n             }\n         }"}, {"sha": "64f02539d0f9b20d25ab549809b29d78b6eae1e1", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -355,24 +355,24 @@ mod tests {\n         set(my_key, @~\"parent data\");\n         do task::spawn {\n             // TLS shouldn't carry over.\n-            assert!(get(my_key, |k| k.map_move(|k| *k)).is_none());\n+            assert!(get(my_key, |k| k.map(|k| *k)).is_none());\n             set(my_key, @~\"child data\");\n-            assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) ==\n+            assert!(*(get(my_key, |k| k.map(|k| *k)).unwrap()) ==\n                     ~\"child data\");\n             // should be cleaned up for us\n         }\n         // Must work multiple times\n-        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|k| *k)).unwrap()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|k| *k)).unwrap()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|k| *k)).unwrap()) == ~\"parent data\");\n     }\n \n     #[test]\n     fn test_tls_overwrite() {\n         static my_key: Key<@~str> = &Key;\n         set(my_key, @~\"first data\");\n         set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"next data\");\n+        assert!(*(get(my_key, |k| k.map(|k| *k)).unwrap()) == ~\"next data\");\n     }\n \n     #[test]"}, {"sha": "cdff32a46dc7ad4f0b983fba821d4c7d99048c4d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 24, "deletions": 59, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -96,6 +96,30 @@ impl<T: ToStr> ToStr for Option<T> {\n }\n \n impl<T> Option<T> {\n+    /// Convert from `Option<T>` to `Option<&T>`\n+    #[inline]\n+    pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n+        match *self { Some(ref x) => Some(x), None => None }\n+    }\n+\n+    /// Convert from `Option<T>` to `Option<&mut T>`\n+    #[inline]\n+    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n+        match *self { Some(ref mut x) => Some(x), None => None }\n+    }\n+\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n+    #[inline]\n+    pub fn map<U>(self, f: &fn(T) -> U) -> Option<U> {\n+        match self { Some(x) => Some(f(x)), None => None }\n+    }\n+\n+    /// Applies a function to the contained value or returns a default.\n+    #[inline]\n+    pub fn map_default<U>(self, def: U, f: &fn(T) -> U) -> U {\n+        match self { None => def, Some(t) => f(t) }\n+    }\n+\n     /// Return an iterator over the possibly contained value\n     #[inline]\n     pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n@@ -149,26 +173,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns `None` if the option is `None`, otherwise calls `f` with a\n-    /// reference to the wrapped value and returns the result.\n-    #[inline]\n-    pub fn and_then_ref<'a, U>(&'a self, f: &fn(&'a T) -> Option<U>) -> Option<U> {\n-        match *self {\n-            Some(ref x) => f(x),\n-            None => None\n-        }\n-    }\n-\n-    /// Returns `None` if the option is `None`, otherwise calls `f` with a\n-    /// mutable reference to the wrapped value and returns the result.\n-    #[inline]\n-    pub fn and_then_mut_ref<'a, U>(&'a mut self, f: &fn(&'a mut T) -> Option<U>) -> Option<U> {\n-        match *self {\n-            Some(ref mut x) => f(x),\n-            None => None\n-        }\n-    }\n-\n     /// Returns the option if it contains a value, otherwise returns `optb`.\n     #[inline]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n@@ -197,45 +201,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Maps a `Some` value from one type to another by reference\n-    #[inline]\n-    pub fn map<'a, U>(&'a self, f: &fn(&'a T) -> U) -> Option<U> {\n-        match *self { Some(ref x) => Some(f(x)), None => None }\n-    }\n-\n-    /// Maps a `Some` value from one type to another by a mutable reference\n-    #[inline]\n-    pub fn map_mut<'a, U>(&'a mut self, f: &fn(&'a mut T) -> U) -> Option<U> {\n-        match *self { Some(ref mut x) => Some(f(x)), None => None }\n-    }\n-\n-    /// Applies a function to the contained value or returns a default\n-    #[inline]\n-    pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n-        match *self { None => def, Some(ref t) => f(t) }\n-    }\n-\n-    /// Maps a `Some` value from one type to another by a mutable reference,\n-    /// or returns a default value.\n-    #[inline]\n-    pub fn map_mut_default<'a, U>(&'a mut self, def: U, f: &fn(&'a mut T) -> U) -> U {\n-        match *self { Some(ref mut x) => f(x), None => def }\n-    }\n-\n-    /// As `map`, but consumes the option and gives `f` ownership to avoid\n-    /// copying.\n-    #[inline]\n-    pub fn map_move<U>(self, f: &fn(T) -> U) -> Option<U> {\n-        match self { Some(x) => Some(f(x)), None => None }\n-    }\n-\n-    /// As `map_default`, but consumes the option and gives `f`\n-    /// ownership to avoid copying.\n-    #[inline]\n-    pub fn map_move_default<U>(self, def: U, f: &fn(T) -> U) -> U {\n-        match self { None => def, Some(t) => f(t) }\n-    }\n-\n     /// Take the value out of the option, leaving a `None` in its place.\n     #[inline]\n     pub fn take(&mut self) -> Option<T> {"}, {"sha": "4de7f32248db060120fb5c4acf5a487998334cbf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -514,7 +514,7 @@ pub fn self_exe_path() -> Option<Path> {\n         }\n     }\n \n-    load_self().map_move(|path| Path(path).dir_path())\n+    load_self().map(|path| Path(path).dir_path())\n }\n \n "}, {"sha": "545c7698e73ab4c7b2c858a4943efaec62ff16c3", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -689,7 +689,7 @@ local_data_key!(TASK_RNG_KEY: @mut TaskRng)\n /// the same sequence always. If absolute consistency is required,\n /// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n pub fn task_rng() -> @mut TaskRng {\n-    let r = local_data::get(TASK_RNG_KEY, |k| k.map(|&k| *k));\n+    let r = local_data::get(TASK_RNG_KEY, |k| k.map(|k| *k));\n     match r {\n         None => {\n             let rng = @mut reseeding::ReseedingRng::new(StdRng::new(),"}, {"sha": "315de4b9af38336bb9851474ebdc43e324905b9c", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -74,7 +74,7 @@ mod imp {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = util::replace(&mut *ptr, None);\n-            val.map(|s: &~~[~str]| (**s).clone())\n+            val.as_ref().map(|s: &~~[~str]| (**s).clone())\n         })\n     }\n \n@@ -89,7 +89,7 @@ mod imp {\n     pub fn clone() -> Option<~[~str]> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).map(|s: &~~[~str]| (**s).clone())\n+            (*ptr).as_ref().map(|s: &~~[~str]| (**s).clone())\n         })\n     }\n "}, {"sha": "3e3431b32c97f0fa69bf705eb591cc7452375d78", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -165,7 +165,7 @@ impl<T> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     if do_resched {\n-                        do recvr.wake().map_move |woken_task| {\n+                        do recvr.wake().map |woken_task| {\n                             Scheduler::run_task(woken_task);\n                         };\n                     } else {\n@@ -391,7 +391,7 @@ impl<T> Drop for ChanOne<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     rtassert!((*this.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    do recvr.wake().map_move |woken_task| {\n+                    do recvr.wake().map |woken_task| {\n                         Scheduler::run_task(woken_task);\n                     };\n                 }\n@@ -501,7 +501,7 @@ impl<T> GenericPort<T> for Port<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        do self.next.take_opt().map_move_default(None) |pone| {\n+        do self.next.take_opt().map_default(None) |pone| {\n             match pone.try_recv() {\n                 Some(StreamPayload { val, next }) => {\n                     self.next.put_back(next);"}, {"sha": "f72d2e1f19bdb7304859cbe0b21bd56f69e02a65", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -203,7 +203,7 @@ impl<'self> Parser<'self> {\n                 return None;\n             }\n \n-            let octet = self.read_number(10, 3, 0x100).map(|&n| n as u8);\n+            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n             match octet {\n                 Some(d) => bs[i] = d,\n                 None => return None,\n@@ -252,7 +252,7 @@ impl<'self> Parser<'self> {\n \n                 let group = do p.read_atomically |p| {\n                     if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|&n| n as u16)\n+                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n                     } else {\n                         None\n                     }\n@@ -310,16 +310,16 @@ impl<'self> Parser<'self> {\n                 let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n                 let clos_br = |p: &mut Parser| p.read_given_char(']');\n                 p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n-                        .map(|&t| match t { (_, ip, _) => ip })\n+                        .map(|t| match t { (_, ip, _) => ip })\n             };\n             p.read_or([ipv4_p, ipv6_p])\n         };\n         let colon = |p: &mut Parser| p.read_given_char(':');\n-        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|&n| n as u16);\n+        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         // host, colon, port\n         self.read_seq_3::<IpAddr, char, u16>(ip_addr, colon, port)\n-                .map(|&t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n+                .map(|t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n     }\n }\n "}, {"sha": "c190547889dfc4fff15efceccb0f2b5c36d0f094", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -93,7 +93,7 @@ impl Process {\n             Ok((p, io)) => Some(Process{\n                 handle: p,\n                 io: io.move_iter().map(|p|\n-                    p.map_move(|p| io::PipeStream::bind(p))\n+                    p.map(|p| io::PipeStream::bind(p))\n                 ).collect()\n             }),\n             Err(ioerr) => {"}, {"sha": "b41d7541a60746f7735727dad77ee384e6022298", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -58,7 +58,7 @@ mod test {\n     fn test_io_timer_sleep_simple() {\n         do run_in_mt_newsched_task {\n             let timer = Timer::new();\n-            do timer.map_move |mut t| { t.sleep(1) };\n+            do timer.map |mut t| { t.sleep(1) };\n         }\n     }\n "}, {"sha": "6043ae318fec56d622751fd667e3331e7e902396", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -486,10 +486,10 @@ impl KillHandle {\n                     || {\n                         // Prefer to check tombstones that were there first,\n                         // being \"more fair\" at the expense of tail-recursion.\n-                        others.take().map_move_default(true, |f| f()) && {\n+                        others.take().map_default(true, |f| f()) && {\n                             let mut inner = this.take().unwrap();\n                             (!inner.any_child_failed) &&\n-                                inner.child_tombstones.take().map_move_default(true, |f| f())\n+                                inner.child_tombstones.take().map_default(true, |f| f())\n                         }\n                     }\n                 }\n@@ -508,7 +508,7 @@ impl KillHandle {\n                     let others = Cell::new(other_tombstones); // :(\n                     || {\n                         // Prefer fairness to tail-recursion, as in above case.\n-                        others.take().map_move_default(true, |f| f()) &&\n+                        others.take().map_default(true, |f| f()) &&\n                             f.take()()\n                     }\n                 }\n@@ -577,15 +577,15 @@ impl Death {\n         { use util; util::ignore(group); }\n \n         // Step 1. Decide if we need to collect child failures synchronously.\n-        do self.on_exit.take().map_move |on_exit| {\n+        do self.on_exit.take().map |on_exit| {\n             if success {\n                 // We succeeded, but our children might not. Need to wait for them.\n                 let mut inner = self.kill_handle.take_unwrap().unwrap();\n                 if inner.any_child_failed {\n                     success = false;\n                 } else {\n                     // Lockless access to tombstones protected by unwrap barrier.\n-                    success = inner.child_tombstones.take().map_move_default(true, |f| f());\n+                    success = inner.child_tombstones.take().map_default(true, |f| f());\n                 }\n             }\n             on_exit(success);\n@@ -594,12 +594,12 @@ impl Death {\n         // Step 2. Possibly alert possibly-watching parent to failure status.\n         // Note that as soon as parent_handle goes out of scope, the parent\n         // can successfully unwrap its handle and collect our reported status.\n-        do self.watching_parent.take().map_move |mut parent_handle| {\n+        do self.watching_parent.take().map |mut parent_handle| {\n             if success {\n                 // Our handle might be None if we had an exit callback, and\n                 // already unwrapped it. But 'success' being true means no\n                 // child failed, so there's nothing to do (see below case).\n-                do self.kill_handle.take().map_move |own_handle| {\n+                do self.kill_handle.take().map |own_handle| {\n                     own_handle.reparent_children_to(&mut parent_handle);\n                 };\n             } else {"}, {"sha": "0a4622bc65eefefa65621ab3d28a5cb2ad385e6a", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -538,7 +538,7 @@ impl Scheduler {\n     /// As enqueue_task, but with the possibility for the blocked task to\n     /// already have been killed.\n     pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map_move |task| {\n+        do blocked_task.wake().map |task| {\n             self.enqueue_task(task);\n         };\n     }"}, {"sha": "71ab3b571c4c6dd7dffc085687fab73ddeead292", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -485,10 +485,10 @@ mod test {\n         do run_in_newsched_task() {\n             local_data_key!(key: @~str)\n             local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n+            assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n             local_data_key!(key2: @~str)\n             local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n         }\n     }\n "}, {"sha": "176754de8f74529961bf6c571ec6496f494446a2", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -46,7 +46,7 @@ impl Process {\n                  exit_cb: uv::ExitCallback)\n                     -> Result<~[Option<UvPipeStream>], uv::UvError>\n     {\n-        let cwd = config.cwd.map_move(|s| s.to_c_str());\n+        let cwd = config.cwd.map(|s| s.to_c_str());\n \n         extern fn on_exit(p: *uvll::uv_process_t,\n                           exit_status: libc::c_int,"}, {"sha": "1de6042003cdc4e6b12a4aaa22f0c8d8fe71f3ae", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -74,7 +74,7 @@ trait HomingIO {\n                      *\n                      * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n                      */\n-                    do task.wake().map_move |mut task| {\n+                    do task.wake().map |mut task| {\n                         *ptr = Some(task.take_unwrap_home());\n                         self.home().send(PinnedTask(task));\n                     };\n@@ -97,7 +97,7 @@ trait HomingIO {\n                  *\n                  * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n                  */\n-                do task.wake().map_move |mut task| {\n+                do task.wake().map |mut task| {\n                     task.give_home(old.take());\n                     scheduler.make_handle().send(TaskFromFriend(task));\n                 };\n@@ -1672,7 +1672,7 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n                 let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     // unblock task\n-                    do task.wake().map_move |task| {\n+                    do task.wake().map |task| {\n                       // send self to sched2\n                       tasksFriendHandle.take().send(TaskFromFriend(task));\n                     };"}, {"sha": "88497bdaa82351e120ebf535a6ce8999faedf332", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -415,7 +415,7 @@ impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n                 b as uint - a as uint\n             }\n         };\n-        self.iter.next().map_move(|ch| (offset, ch))\n+        self.iter.next().map(|ch| (offset, ch))\n     }\n \n     #[inline]\n@@ -427,7 +427,7 @@ impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n-        self.iter.next_back().map_move(|ch| {\n+        self.iter.next_back().map(|ch| {\n             let offset = do self.string.as_imm_buf |a, _| {\n                 do self.iter.string.as_imm_buf |b, len| {\n                     b as uint - a as uint + len\n@@ -2260,7 +2260,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         } else {\n             self.matches_index_iter(needle)\n                 .next()\n-                .map_move(|(start, _end)| start)\n+                .map(|(start, _end)| start)\n         }\n     }\n "}, {"sha": "ce1be592d79c8c9fac8ddcd42f03184fa6a25e7f", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -142,7 +142,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             // Be careful not to allocate in this block, if we're failing we may\n             // have been failing due to a lack of memory in the first place...\n             do Local::borrow |task: &mut Task| {\n-                let n = task.name.map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n                 format_args!(|args| { task.logger.log(args) },\n                              \"task '{}' failed at '{}', {}:{}\",\n                              n, msg.as_slice(), file.as_slice(), line);"}, {"sha": "d26f8eb10248e10ecd74b6edfe027553b39674a6", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -182,7 +182,7 @@ fn check_generation(_younger: uint, _older: uint) { }\n \n #[inline] #[cfg(test)]\n fn incr_generation(ancestors: &AncestorList) -> uint {\n-    ancestors.map_default(0, |arc| access_ancestors(arc, |a| a.generation+1))\n+    ancestors.as_ref().map_default(0, |arc| access_ancestors(arc, |a| a.generation+1))\n }\n #[inline] #[cfg(not(test))]\n fn incr_generation(_ancestors: &AncestorList) -> uint { 0 }\n@@ -243,7 +243,7 @@ fn each_ancestor(list:        &mut AncestorList,\n \n         // The map defaults to None, because if ancestors is None, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n-        do ancestors.map_default((None,false)) |ancestor_arc| {\n+        do ancestors.as_ref().map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n                 // Argh, but we couldn't give it to coalesce() otherwise.\n@@ -386,7 +386,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: KillHandle,\n                            is_member: bool) -> bool {\n     let me = Cell::new(me); // :(\n     // If 'None', the group was failing. Can't enlist.\n-    do state.map_mut_default(false) |group| {\n+    do state.as_mut().map_default(false) |group| {\n         (if is_member {\n             &mut group.members\n         } else {\n@@ -400,7 +400,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: KillHandle,\n fn leave_taskgroup(state: TaskGroupInner, me: &KillHandle, is_member: bool) {\n     let me = Cell::new(me); // :(\n     // If 'None', already failing and we've already gotten a kill signal.\n-    do state.map_mut |group| {\n+    do state.as_mut().map |group| {\n         (if is_member {\n             &mut group.members\n         } else {\n@@ -414,7 +414,7 @@ fn kill_taskgroup(state: Option<TaskGroupData>, me: &KillHandle) {\n     // Might already be None, if somebody is failing simultaneously.\n     // That's ok; only one task needs to do the dirty work. (Might also\n     // see 'None' if somebody already failed and we got a kill signal.)\n-    do state.map_move |TaskGroupData { members: members, descendants: descendants }| {\n+    do state.map |TaskGroupData { members: members, descendants: descendants }| {\n         for sibling in members.move_iter() {\n             // Skip self - killing ourself won't do much good.\n             if &sibling != me {\n@@ -439,7 +439,7 @@ fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n struct RuntimeGlue;\n impl RuntimeGlue {\n     fn kill_task(mut handle: KillHandle) {\n-        do handle.kill().map_move |killed_task| {\n+        do handle.kill().map |killed_task| {\n             let killed_task = Cell::new(killed_task);\n             do Local::borrow |sched: &mut Scheduler| {\n                 sched.enqueue_task(killed_task.take());\n@@ -491,7 +491,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         // with_my_taskgroup will lazily initialize the parent's taskgroup if\n         // it doesn't yet exist. We don't want to call it in the unlinked case.\n         do RuntimeGlue::with_my_taskgroup |spawner_group| {\n-            let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n+            let ancestors = AncestorList(spawner_group.ancestors.as_ref().map(|x| x.clone()));\n             if linked {\n                 // Child is in the same group as spawner.\n                 // Child's ancestors are spawner's ancestors.\n@@ -562,7 +562,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n         // Child task runs this code.\n \n         // If child data is 'None', the enlist is vacuously successful.\n-        let enlist_success = do child_data.take().map_move_default(true) |child_data| {\n+        let enlist_success = do child_data.take().map_default(true) |child_data| {\n             let child_data = Cell::new(child_data); // :(\n             do Local::borrow |me: &mut Task| {\n                 let (child_tg, ancestors) = child_data.take();"}, {"sha": "b42d3c904d7488b283a18ff7b718e263f8deba1a", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -488,7 +488,7 @@ pub struct TrieSetIterator<'self> {\n \n impl<'self> Iterator<uint> for TrieSetIterator<'self> {\n     fn next(&mut self) -> Option<uint> {\n-        do self.iter.next().map |&(key, _)| { key }\n+        do self.iter.next().map |(key, _)| { key }\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {"}, {"sha": "7295081afba2fa8c42feb78df7c06de8868548dd", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -588,7 +588,7 @@ impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n                         id: NodeId,\n                         _: ()) {\n         self.operation.visit_id(id);\n-        struct_def.ctor_id.map(|&ctor_id| self.operation.visit_id(ctor_id));\n+        struct_def.ctor_id.map(|ctor_id| self.operation.visit_id(ctor_id));\n         visit::walk_struct_def(self, struct_def, ident, generics, id, ());\n     }\n \n@@ -783,7 +783,7 @@ pub fn new_sctable_internal() -> SCTable {\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n     local_data_key!(sctable_key: @@mut SCTable)\n-    match local_data::get(sctable_key, |k| k.map_move(|k| *k)) {\n+    match local_data::get(sctable_key, |k| k.map(|k| *k)) {\n         None => {\n             let new_table = @@mut new_sctable_internal();\n             local_data::set(sctable_key,new_table);\n@@ -820,7 +820,7 @@ pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_resolve_table() -> @mut ResolveTable {\n     local_data_key!(resolve_table_key: @@mut ResolveTable)\n-    match local_data::get(resolve_table_key, |k| k.map(|&k| *k)) {\n+    match local_data::get(resolve_table_key, |k| k.map(|k| *k)) {\n         None => {\n             let new_table = @@mut HashMap::new();\n             local_data::set(resolve_table_key,new_table);"}, {"sha": "47b31a4f76d5fe299b0fb03571fd729598be798f", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -83,7 +83,7 @@ impl AttrMetaMethods for MetaItem {\n     }\n \n     fn name_str_pair(&self) -> Option<(@str, @str)> {\n-        self.value_str().map_move(|s| (self.name(), s))\n+        self.value_str().map(|s| (self.name(), s))\n     }\n }\n "}, {"sha": "4b5ab2fbb56df0223e3930c02231079f94f2eaf4", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -198,7 +198,7 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n     let stderr = io::stderr();\n \n     if stderr.get_type() == io::Screen {\n-        let t = match local_data::get(tls_terminal, |v| v.map_move(|k| *k)) {\n+        let t = match local_data::get(tls_terminal, |v| v.map(|k| *k)) {\n             None => {\n                 let t = term::Terminal::new(stderr);\n                 let tls = @match t {\n@@ -337,7 +337,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n-        let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n+        let ss = ei.callee.span.as_ref().map_default(~\"\", |span| cm.span_to_str(*span));\n         print_diagnostic(ss, note,\n                          format!(\"in expansion of {}!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);"}, {"sha": "a64e8ff825cf34a3a080bdbbf37ee2655f939dd6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -565,7 +565,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n             ConsMapChain(ref map,_) => map\n         };\n         // strip one layer of indirection off the pointer.\n-        map.find(key).map_move(|r| {*r})\n+        map.find(key).map(|r| {*r})\n     }\n \n     // insert the binding into the top-level map"}, {"sha": "78cdc3f585ba00449564474631912a776751316e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -663,7 +663,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn expr_if(&self, span: Span,\n                cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr {\n-        let els = els.map_move(|x| self.expr_block(self.block_expr(x)));\n+        let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n "}, {"sha": "83c73e3d85f22a9b9d7b4b5be90afaee15ee164d", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -249,7 +249,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n                     Send => ast::sty_uniq,\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(*s)));\n+                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });"}, {"sha": "01d0fd80672463dff20cd45e737f9b7bd93dd526", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -582,7 +582,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             // add them to the existing pending renames:\n             for pr in new_pending_renames.iter() {pending_renames.push(*pr)}\n             // also, don't forget to expand the init:\n-            let new_init_opt = init.map(|e| fld.fold_expr(*e));\n+            let new_init_opt = init.map(|e| fld.fold_expr(e));\n             let rewritten_local =\n                 @Local {\n                     is_mutbl: is_mutbl,\n@@ -725,7 +725,7 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n             None => ()\n         }\n     }\n-    let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(*x)));\n+    let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n     Block{\n         view_items: new_view_items,\n         stmts: new_stmts,"}, {"sha": "7518816be1e9386f9685079441897161bd6b2de1", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -266,7 +266,7 @@ impl Context {\n                     }\n                 };\n                 self.verify_same(span, ty,\n-                                 self.name_types.find(&name).map(|&x| *x));\n+                                 self.name_types.find(&name).map(|&x| x));\n                 if !self.name_types.contains_key(&name) {\n                     self.name_types.insert(name, ty);\n                 }"}, {"sha": "3c601196db96999d3996f87904201b8bb8f11873", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -165,7 +165,7 @@ pub trait ast_fold {\n     fn fold_arm(&self, a: &Arm) -> Arm {\n         Arm {\n             pats: a.pats.map(|x| self.fold_pat(*x)),\n-            guard: a.guard.map_move(|x| self.fold_expr(x)),\n+            guard: a.guard.map(|x| self.fold_expr(x)),\n             body: self.fold_block(&a.body),\n         }\n     }\n@@ -176,12 +176,12 @@ pub trait ast_fold {\n             PatIdent(binding_mode, ref pth, ref sub) => {\n                 PatIdent(binding_mode,\n                          self.fold_path(pth),\n-                         sub.map_move(|x| self.fold_pat(x)))\n+                         sub.map(|x| self.fold_pat(x)))\n             }\n             PatLit(e) => PatLit(self.fold_expr(e)),\n             PatEnum(ref pth, ref pats) => {\n                 PatEnum(self.fold_path(pth),\n-                        pats.map(|pats| pats.map(|x| self.fold_pat(*x))))\n+                        pats.as_ref().map(|pats| pats.map(|x| self.fold_pat(*x))))\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n                 let pth_ = self.fold_path(pth);\n@@ -202,7 +202,7 @@ pub trait ast_fold {\n             },\n             PatVec(ref before, ref slice, ref after) => {\n                 PatVec(before.map(|x| self.fold_pat(*x)),\n-                       slice.map_move(|x| self.fold_pat(x)),\n+                       slice.map(|x| self.fold_pat(x)),\n                        after.map(|x| self.fold_pat(*x)))\n             }\n         };\n@@ -225,7 +225,7 @@ pub trait ast_fold {\n             }\n         };\n \n-        node.map_move(|node| {\n+        node.map(|node| {\n             @Spanned {\n                 node: node,\n                 span: d.span,\n@@ -313,7 +313,7 @@ pub trait ast_fold {\n                 kind = struct_variant_kind(@ast::struct_def {\n                     fields: struct_def.fields.iter()\n                         .map(|f| self.fold_struct_field(*f)).collect(),\n-                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(*c))\n+                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(c))\n                 })\n             }\n         }\n@@ -360,7 +360,7 @@ pub trait ast_fold {\n             is_mutbl: l.is_mutbl,\n             ty: self.fold_ty(&l.ty),\n             pat: self.fold_pat(l.pat),\n-            init: l.init.map_move(|e| self.fold_expr(e)),\n+            init: l.init.map(|e| self.fold_expr(e)),\n             id: self.new_id(l.id),\n             span: self.new_span(l.span),\n         }\n@@ -445,7 +445,7 @@ pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n             tt_seq(span, ref pattern, ref sep, is_optional) =>\n             tt_seq(span,\n                    @mut fold_tts(**pattern, fld),\n-                   sep.map(|tok|maybe_fold_ident(tok,fld)),\n+                   sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n                    is_optional),\n             tt_nonterminal(sp,ref ident) =>\n             tt_nonterminal(sp,fld.fold_ident(*ident))\n@@ -515,7 +515,7 @@ fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n                                -> @ast::struct_def {\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n-        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n+        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n \n@@ -577,7 +577,7 @@ fn fold_field<T:ast_fold>(f: TypeField, folder: &T) -> TypeField {\n \n fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n                                -> Option<OptVec<TyParamBound>> {\n-    do b.map |bounds| {\n+    do b.as_ref().map |bounds| {\n         do bounds.map |bound| {\n             fold_ty_param_bound(bound, folder)\n         }\n@@ -604,7 +604,7 @@ pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n     ast::Block {\n         view_items: view_items,\n         stmts: stmts,\n-        expr: b.expr.map(|x| folder.fold_expr(*x)),\n+        expr: b.expr.map(|x| folder.fold_expr(x)),\n         id: folder.new_id(b.id),\n         rules: b.rules,\n         span: folder.new_span(b.span),\n@@ -648,7 +648,7 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n         }\n         item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(fold_generics(generics, folder),\n-                      ifce.map(|p| fold_trait_ref(p, folder)),\n+                      ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n                       folder.fold_ty(ty),\n                       methods.map(|x| folder.fold_method(*x))\n             )\n@@ -764,7 +764,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n         ExprIf(cond, ref tr, fl) => {\n             ExprIf(folder.fold_expr(cond),\n                    folder.fold_block(tr),\n-                   fl.map_move(|x| folder.fold_expr(x)))\n+                   fl.map(|x| folder.fold_expr(x)))\n         }\n         ExprWhile(cond, ref body) => {\n             ExprWhile(folder.fold_expr(cond), folder.fold_block(body))\n@@ -773,11 +773,11 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n             ExprForLoop(folder.fold_pat(pat),\n                         folder.fold_expr(iter),\n                         folder.fold_block(body),\n-                        maybe_ident.map_move(|i| folder.fold_ident(i)))\n+                        maybe_ident.map(|i| folder.fold_ident(i)))\n         }\n         ExprLoop(ref body, opt_ident) => {\n             ExprLoop(folder.fold_block(body),\n-                     opt_ident.map_move(|x| folder.fold_ident(x)))\n+                     opt_ident.map(|x| folder.fold_ident(x)))\n         }\n         ExprMatch(expr, ref arms) => {\n             ExprMatch(folder.fold_expr(expr),\n@@ -814,7 +814,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n         ExprBreak(opt_ident) => ExprBreak(opt_ident),\n         ExprAgain(opt_ident) => ExprAgain(opt_ident),\n         ExprRet(ref e) => {\n-            ExprRet(e.map_move(|x| folder.fold_expr(x)))\n+            ExprRet(e.map(|x| folder.fold_expr(x)))\n         }\n         ExprInlineAsm(ref a) => {\n             ExprInlineAsm(inline_asm {\n@@ -827,7 +827,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(folder.fold_path(path),\n                        fields.map(|x| fold_field(*x)),\n-                       maybe_expr.map_move(|x| folder.fold_expr(x)))\n+                       maybe_expr.map(|x| folder.fold_expr(x)))\n         },\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n     };\n@@ -856,7 +856,7 @@ pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> Option<@Stmt> {\n         StmtMac(ref mac, semi) => Some(StmtMac(folder.fold_mac(mac), semi))\n     };\n \n-    node.map_move(|node| @Spanned {\n+    node.map(|node| @Spanned {\n         node: node,\n         span: folder.new_span(s.span),\n     })"}, {"sha": "9f1a436a4d58d6cfece6d7c8dd30295bdeea896a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -405,7 +405,7 @@ impl Parser {\n         fn tokens_to_str(p:&Parser, tokens: &[token::Token]) -> ~str {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n-            let b = i.next().map_default(~\"\", |t| p.token_to_str(*t));\n+            let b = i.next().map_default(~\"\", |t| p.token_to_str(t));\n             i.fold(b, |b,a| b + \"`, `\" + p.token_to_str(a))\n         }\n         if edible.contains(self.token) {\n@@ -470,7 +470,7 @@ impl Parser {\n     pub fn commit_stmt(&self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n         debug2!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n-        if self.last_token.map_default(false, |t|is_ident_or_path(*t)) {\n+        if self.last_token.as_ref().map_default(false, |t| is_ident_or_path(*t)) {\n             let expected = vec::append(edible.to_owned(), inedible);\n             self.check_for_erroneous_unit_struct_expecting(expected);\n         }"}, {"sha": "eae3e665b580491bdb9ba5b928db2a36f9582727", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -510,7 +510,7 @@ static RESERVED_KEYWORD_FINAL: uint = 71;\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n     local_data_key!(key: @@::parse::token::ident_interner)\n-    match local_data::get(key, |k| k.map_move(|k| *k)) {\n+    match local_data::get(key, |k| k.map(|k| *k)) {\n         Some(interner) => *interner,\n         None => {\n             let interner = mk_fresh_ident_interner();"}, {"sha": "74d5e1a6d27d92eae6d55bebb04ff9728d05c04a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a90e80b6240d8213f2b99fa470ef6ee04552d1b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6a90e80b6240d8213f2b99fa470ef6ee04552d1b", "patch": "@@ -1978,7 +1978,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, \"fn\");\n     match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n-    do opt_bounds.map |bounds| { print_bounds(s, bounds, true); };\n+    do opt_bounds.as_ref().map |bounds| { print_bounds(s, bounds, true); };\n     match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n "}]}