{"sha": "4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNGZlMTRmYWI5NmM4YjQwNzYzZjllZDViZWY1MTk0MmZkN2U1MDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-23T08:20:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-23T08:20:18Z"}, "message": "Merge #1892\n\n1892: Find usages r=matklad a=viorina\n\nFixes #1622.\n\nCo-authored-by: Ekaterina Babshukova <ekaterina.babshukova@yandex.ru>", "tree": {"sha": "cdf5a5b39600b41a9eee301b9760cde1282aeb33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdf5a5b39600b41a9eee301b9760cde1282aeb33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsA1CCRBK7hj4Ov3rIwAAdHIIAK0Ycvt6tDJ/qApEM5zyegS4\nA+gtRV9T/TM7uZyyd+DUwoduK+MHPp1ITHOOYTxSWtlmbPh8mvengBkrBeZPXS3v\nkh6kXiQegdeIp+33nS+4zQk/T77idkpiamwo+Pw5TdULkT6lc6hZyLSrKTz+2eCL\ndT/6nVF5c+Cr1CBDIlqu996k0HE6mEJdyqkGFu7PkWOj4bmv5fnyosxVAlq7MgGZ\nZP3rH8Ou9IHvxEaaMYz8H8s6UK2cGFmLnDrxCE2W+aqFZJcv+78qkBNnxE+q/oqB\nkwBFC1rd0JXjEt0y+Wfp9VzRJgWXljTguqwwWVIvaoU3GEHP9xibFPK3ozii9a0=\n=88Y4\n-----END PGP SIGNATURE-----\n", "payload": "tree cdf5a5b39600b41a9eee301b9760cde1282aeb33\nparent c15ee97fff4324981d03f65210d794664c28f0e4\nparent decfd28bd14b56befa17257694caacc57a090939\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1571818818 +0000\ncommitter GitHub <noreply@github.com> 1571818818 +0000\n\nMerge #1892\n\n1892: Find usages r=matklad a=viorina\n\nFixes #1622.\n\nCo-authored-by: Ekaterina Babshukova <ekaterina.babshukova@yandex.ru>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "html_url": "https://github.com/rust-lang/rust/commit/4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15ee97fff4324981d03f65210d794664c28f0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15ee97fff4324981d03f65210d794664c28f0e4", "html_url": "https://github.com/rust-lang/rust/commit/c15ee97fff4324981d03f65210d794664c28f0e4"}, {"sha": "decfd28bd14b56befa17257694caacc57a090939", "url": "https://api.github.com/repos/rust-lang/rust/commits/decfd28bd14b56befa17257694caacc57a090939", "html_url": "https://github.com/rust-lang/rust/commit/decfd28bd14b56befa17257694caacc57a090939"}], "stats": {"total": 1524, "additions": 1075, "deletions": 449}, "files": [{"sha": "634480e5fb82287509392b22b4c3059c52312714", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -1025,6 +1025,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_assists 0.1.0\",\n  \"ra_cfg 0.1.0\","}, {"sha": "a137aeb9098266ecc09a1eb929bd745349f7e8ad", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -181,7 +181,6 @@ impl Module {\n     ) -> Option<Self> {\n         let decl_id = match src.ast {\n             ModuleSource::Module(ref module) => {\n-                assert!(!module.has_semi());\n                 let ast_id_map = db.ast_id_map(src.file_id);\n                 let item_id = ast_id_map.ast_id(module).with_file_id(src.file_id);\n                 Some(item_id)"}, {"sha": "f9bf0c686a30f203f64cf80e614f74f74b51c73d", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -19,6 +19,7 @@ rustc-hash = \"1.0\"\n unicase = \"2.2.0\"\n superslice = \"1.0.0\"\n rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n+once_cell = \"1.2.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "1f3fa6c57becfad02ff35d142a2041f214bfd8f5", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n use crate::{\n     db::RootDatabase,\n     display::ShortLabel,\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -54,13 +54,11 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-\n-    match classify_name_ref(db, &analyzer, name_ref) {\n+    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+    match name_kind {\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n-        Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n+        Some(Field(field)) => return Exact(NavigationTarget::from_field(db, field)),\n         Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n-        Some(Method(func)) => return Exact(NavigationTarget::from_def_source(db, func)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n@@ -70,7 +68,7 @@ pub(crate) fn reference_definition(\n                 return Exact(NavigationTarget::from_adt_def(db, def_id));\n             }\n         }\n-        Some(Pat(pat)) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n+        Some(Pat((_, pat))) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n         Some(SelfParam(par)) => return Exact(NavigationTarget::from_self_param(file_id, par)),\n         Some(GenericParam(_)) => {\n             // FIXME: go to the generic param def"}, {"sha": "ba328efa14012e1485b289510f50486554e4a87d", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n \n@@ -99,17 +99,14 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     let mut range = None;\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-\n         let mut no_fallback = false;\n-\n-        match classify_name_ref(db, &analyzer, &name_ref) {\n-            Some(Method(it)) => res.extend(from_def_source(db, it)),\n+        let name_kind = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind);\n+        match name_kind {\n             Some(Macro(it)) => {\n                 let src = it.source(db);\n                 res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));\n             }\n-            Some(FieldAccess(it)) => {\n+            Some(Field(it)) => {\n                 let src = it.source(db);\n                 if let hir::FieldSource::Named(it) = src.ast {\n                     res.extend(hover_text(it.doc_comment_text(), it.short_label()));"}, {"sha": "19669a7f021c954fddd26e89a8b601e4edfdc35c", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -19,7 +19,6 @@ mod feature_flags;\n mod status;\n mod completion;\n mod runnables;\n-mod name_ref_kind;\n mod goto_definition;\n mod goto_type_definition;\n mod extend_selection;"}, {"sha": "149585971e9974641b68a78d6523afcd3ea4f197", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c15ee97fff4324981d03f65210d794664c28f0e4/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c15ee97fff4324981d03f65210d794664c28f0e4/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=c15ee97fff4324981d03f65210d794664c28f0e4", "patch": "@@ -1,98 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use hir::Either;\n-use ra_syntax::{ast, AstNode, AstPtr};\n-use test_utils::tested_by;\n-\n-use crate::db::RootDatabase;\n-\n-pub enum NameRefKind {\n-    Method(hir::Function),\n-    Macro(hir::MacroDef),\n-    FieldAccess(hir::StructField),\n-    AssocItem(hir::AssocItem),\n-    Def(hir::ModuleDef),\n-    SelfType(hir::Ty),\n-    Pat(AstPtr<ast::BindPat>),\n-    SelfParam(AstPtr<ast::SelfParam>),\n-    GenericParam(u32),\n-}\n-\n-pub(crate) fn classify_name_ref(\n-    db: &RootDatabase,\n-    analyzer: &hir::SourceAnalyzer,\n-    name_ref: &ast::NameRef,\n-) -> Option<NameRefKind> {\n-    use NameRefKind::*;\n-\n-    // Check if it is a method\n-    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n-        tested_by!(goto_definition_works_for_methods);\n-        if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(Method(func));\n-        }\n-    }\n-\n-    // It could be a macro call\n-    if let Some(macro_call) = name_ref\n-        .syntax()\n-        .parent()\n-        .and_then(|node| node.parent())\n-        .and_then(|node| node.parent())\n-        .and_then(ast::MacroCall::cast)\n-    {\n-        tested_by!(goto_definition_works_for_macros);\n-        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n-            return Some(Macro(mac));\n-        }\n-    }\n-\n-    // It could also be a field access\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n-        tested_by!(goto_definition_works_for_fields);\n-        if let Some(field) = analyzer.resolve_field(&field_expr) {\n-            return Some(FieldAccess(field));\n-        };\n-    }\n-\n-    // It could also be a named field\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::RecordField::cast) {\n-        tested_by!(goto_definition_works_for_record_fields);\n-\n-        let record_lit = field_expr.syntax().ancestors().find_map(ast::RecordLit::cast);\n-\n-        if let Some(ty) = record_lit.and_then(|lit| analyzer.type_of(db, &lit.into())) {\n-            if let Some((hir::Adt::Struct(s), _)) = ty.as_adt() {\n-                let hir_path = hir::Path::from_name_ref(name_ref);\n-                let hir_name = hir_path.as_ident().unwrap();\n-\n-                if let Some(field) = s.field(db, hir_name) {\n-                    return Some(FieldAccess(field));\n-                }\n-            }\n-        }\n-    }\n-\n-    // General case, a path or a local:\n-    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = analyzer.resolve_path(db, &path) {\n-            return match resolved {\n-                hir::PathResolution::Def(def) => Some(Def(def)),\n-                hir::PathResolution::LocalBinding(Either::A(pat)) => Some(Pat(pat)),\n-                hir::PathResolution::LocalBinding(Either::B(par)) => Some(SelfParam(par)),\n-                hir::PathResolution::GenericParam(par) => {\n-                    // FIXME: get generic param def\n-                    Some(GenericParam(par))\n-                }\n-                hir::PathResolution::Macro(def) => Some(Macro(def)),\n-                hir::PathResolution::SelfType(impl_block) => {\n-                    let ty = impl_block.target_ty(db);\n-                    Some(SelfType(ty))\n-                }\n-                hir::PathResolution::AssocItem(assoc) => Some(AssocItem(assoc)),\n-            };\n-        }\n-    }\n-\n-    None\n-}"}, {"sha": "f35d835acf1bcc6bed7bb197e0ca2313ba1d3965", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 195, "deletions": 325, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -1,13 +1,29 @@\n-//! FIXME: write short doc here\n-\n-use hir::{Either, ModuleSource};\n+//! This module implements a reference search.\n+//! First, the element at the cursor position must be either an `ast::Name`\n+//! or `ast::NameRef`. If it's a `ast::NameRef`, at the classification step we\n+//! try to resolve the direct tree parent of this element, otherwise we\n+//! already have a definition and just need to get its HIR together with\n+//! some information that is needed for futher steps of searching.\n+//! After that, we collect files that might contain references and look\n+//! for text occurrences of the identifier. If there's an `ast::NameRef`\n+//! at the index that the match starts at and its tree parent is\n+//! resolved to the search element definition, we get a reference.\n+\n+mod classify;\n+mod name_definition;\n+mod rename;\n+mod search_scope;\n+\n+use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode};\n-use relative_path::{RelativePath, RelativePathBuf};\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode, TextUnit};\n+\n+use crate::{db::RootDatabase, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n-use crate::{\n-    db::RootDatabase, FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo,\n-    SourceChange, SourceFileEdit, TextRange,\n+pub(crate) use self::{\n+    classify::{classify_name, classify_name_ref},\n+    name_definition::{NameDefinition, NameKind},\n+    rename::rename,\n };\n \n #[derive(Debug, Clone)]\n@@ -52,161 +68,82 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n-    let RangeInfo { range, info: (binding, analyzer) } = find_binding(db, &parse.tree(), position)?;\n-    let declaration = NavigationTarget::from_bind_pat(position.file_id, &binding);\n-\n-    let references = analyzer\n-        .find_all_refs(&binding)\n-        .into_iter()\n-        .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n-        .collect::<Vec<_>>();\n-\n-    return Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }));\n-\n-    fn find_binding<'a>(\n-        db: &RootDatabase,\n-        source_file: &SourceFile,\n-        position: FilePosition,\n-    ) -> Option<RangeInfo<(ast::BindPat, hir::SourceAnalyzer)>> {\n-        let syntax = source_file.syntax();\n-        if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-            let range = binding.syntax().text_range();\n-            let analyzer = hir::SourceAnalyzer::new(db, position.file_id, binding.syntax(), None);\n-            return Some(RangeInfo::new(range, (binding, analyzer)));\n-        };\n-        let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n-        let range = name_ref.syntax().text_range();\n-        let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let resolved = analyzer.resolve_local_name(&name_ref)?;\n-        if let Either::A(ptr) = resolved.ptr() {\n-            if let ast::Pat::BindPat(binding) = ptr.to_node(source_file.syntax()) {\n-                return Some(RangeInfo::new(range, (binding, analyzer)));\n-            }\n-        }\n-        None\n-    }\n-}\n+    let syntax = parse.tree().syntax().clone();\n+    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n+\n+    let declaration = match def.kind {\n+        NameKind::Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n+        NameKind::Field(field) => NavigationTarget::from_field(db, field),\n+        NameKind::AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n+        NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n+        NameKind::SelfType(ref ty) => match ty.as_adt() {\n+            Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n+            None => return None,\n+        },\n+        NameKind::Pat((_, pat)) => NavigationTarget::from_pat(db, position.file_id, pat),\n+        NameKind::SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n+        NameKind::GenericParam(_) => return None,\n+    };\n \n-pub(crate) fn rename(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n-    let parse = db.parse(position.file_id);\n-    if let Some((ast_name, ast_module)) =\n-        find_name_and_module_at_offset(parse.tree().syntax(), position)\n-    {\n-        let range = ast_name.syntax().text_range();\n-        rename_mod(db, &ast_name, &ast_module, position, new_name)\n-            .map(|info| RangeInfo::new(range, info))\n-    } else {\n-        rename_reference(db, position, new_name)\n-    }\n+    let references = process_definition(db, def, name);\n+\n+    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n }\n \n-fn find_name_and_module_at_offset(\n+fn find_name<'a>(\n+    db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<(ast::Name, ast::Module)> {\n-    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n-    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n-    Some((ast_name, ast_module))\n-}\n-\n-fn source_edit_from_file_id_range(\n-    file_id: FileId,\n-    range: TextRange,\n-    new_name: &str,\n-) -> SourceFileEdit {\n-    SourceFileEdit {\n-        file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(range, new_name.into());\n-            builder.finish()\n-        },\n+) -> Option<RangeInfo<(String, NameDefinition)>> {\n+    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+        let def = classify_name(db, position.file_id, &name)?;\n+        let range = name.syntax().text_range();\n+        return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n     }\n+    let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n+    let def = classify_name_ref(db, position.file_id, &name_ref)?;\n+    let range = name_ref.syntax().text_range();\n+    Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n \n-fn rename_mod(\n-    db: &RootDatabase,\n-    ast_name: &ast::Name,\n-    ast_module: &ast::Module,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<SourceChange> {\n-    let mut source_file_edits = Vec::new();\n-    let mut file_system_edits = Vec::new();\n-    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n-    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n-        let src = module.definition_source(db);\n-        let file_id = src.file_id.original_file(db);\n-        match src.ast {\n-            ModuleSource::SourceFile(..) => {\n-                let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n-                // mod is defined in path/to/dir/mod.rs\n-                let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n-                    mod_path\n-                        .parent()\n-                        .and_then(|p| p.parent())\n-                        .or_else(|| Some(RelativePath::new(\"\")))\n-                        .map(|p| p.join(new_name).join(\"mod.rs\"))\n-                } else {\n-                    Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n-                };\n-                if let Some(path) = dst_path {\n-                    let move_file = FileSystemEdit::MoveFile {\n-                        src: file_id,\n-                        dst_source_root: db.file_source_root(position.file_id),\n-                        dst_path: path,\n-                    };\n-                    file_system_edits.push(move_file);\n+fn process_definition(db: &RootDatabase, def: NameDefinition, name: String) -> Vec<FileRange> {\n+    let pat = name.as_str();\n+    let scope = def.search_scope(db);\n+    let mut refs = vec![];\n+\n+    for (file_id, search_range) in scope {\n+        let text = db.file_text(file_id);\n+        let parse = Lazy::new(|| SourceFile::parse(&text));\n+\n+        for (idx, _) in text.match_indices(pat) {\n+            let offset = TextUnit::from_usize(idx);\n+\n+            if let Some(name_ref) =\n+                find_node_at_offset::<ast::NameRef>(parse.tree().syntax(), offset)\n+            {\n+                let range = name_ref.syntax().text_range();\n+                if let Some(search_range) = search_range {\n+                    if !range.is_subrange(&search_range) {\n+                        continue;\n+                    }\n+                }\n+                if let Some(d) = classify_name_ref(db, file_id, &name_ref) {\n+                    if d == def {\n+                        refs.push(FileRange { file_id, range });\n+                    }\n                 }\n             }\n-            ModuleSource::Module(..) => {}\n         }\n     }\n-\n-    let edit = SourceFileEdit {\n-        file_id: position.file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(ast_name.syntax().text_range(), new_name.into());\n-            builder.finish()\n-        },\n-    };\n-    source_file_edits.push(edit);\n-\n-    Some(SourceChange::from_edits(\"rename\", source_file_edits, file_system_edits))\n-}\n-\n-fn rename_reference(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n-    let RangeInfo { range, info: refs } = find_all_refs(db, position)?;\n-\n-    let edit = refs\n-        .into_iter()\n-        .map(|range| source_edit_from_file_id_range(range.file_id, range.range, new_name))\n-        .collect::<Vec<_>>();\n-\n-    if edit.is_empty() {\n-        return None;\n-    }\n-\n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"rename\", edit)))\n+    refs\n }\n \n #[cfg(test)]\n mod tests {\n     use crate::{\n-        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n+        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position,\n         ReferenceSearchResult,\n     };\n-    use insta::assert_debug_snapshot;\n-    use test_utils::assert_eq_text;\n \n     #[test]\n     fn test_find_all_refs_for_local() {\n@@ -249,211 +186,144 @@ mod tests {\n         assert_eq!(refs.len(), 2);\n     }\n \n-    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n-        let (analysis, position) = single_file_with_position(text);\n-        analysis.find_all_refs(position).unwrap().unwrap()\n-    }\n-\n     #[test]\n-    fn test_rename_for_local() {\n-        test_rename(\n-            r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#,\n-            \"k\",\n-            r#\"\n-    fn main() {\n-        let mut k = 1;\n-        let j = 1;\n-        k = k + j;\n+    fn test_find_all_refs_field_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo {\n+                pub spam<|>: u32,\n+            }\n \n-        {\n-            k = 0;\n-        }\n+            fn main(s: Foo) {\n+                let f = s.spam;\n+            }\n+        \"#;\n \n-        k = 5;\n-    }\"#,\n-        );\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n     }\n \n     #[test]\n-    fn test_rename_for_param_inside() {\n-        test_rename(\n-            r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#,\n-            \"j\",\n-            r#\"\n-    fn foo(j : u32) -> u32 {\n-        j\n-    }\"#,\n-        );\n-    }\n+    fn test_find_all_refs_impl_item_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn f<|>(&self) {  }\n+            }\n+        \"#;\n \n-    #[test]\n-    fn test_rename_refs_for_fn_param() {\n-        test_rename(\n-            r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-            \"new_name\",\n-            r#\"\n-    fn foo(new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-        );\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n     }\n \n     #[test]\n-    fn test_rename_for_mut_param() {\n-        test_rename(\n-            r#\"\n-    fn foo(mut i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-            \"new_name\",\n-            r#\"\n-    fn foo(mut new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-        );\n+    fn test_find_all_refs_enum_var_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            enum Foo {\n+                A,\n+                B<|>,\n+                C,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n     }\n \n     #[test]\n-    fn test_rename_mod() {\n-        let (analysis, position) = analysis_and_position(\n-            \"\n+    fn test_find_all_refs_two_modules() {\n+        let code = r#\"\n             //- /lib.rs\n-            mod bar;\n+            pub mod foo;\n+            pub mod bar;\n+\n+            fn f() {\n+                let i = foo::Foo { n: 5 };\n+            }\n+\n+            //- /foo.rs\n+            use crate::bar;\n+\n+            pub struct Foo {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = bar::Bar { n: 5 };\n+            }\n \n             //- /bar.rs\n+            use crate::foo;\n+\n+            pub struct Bar {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = foo::Foo<|> { n: 5 };\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos).unwrap().unwrap();\n+        assert_eq!(refs.len(), 3);\n+    }\n+\n+    // `mod foo;` is not in the results because `foo` is an `ast::Name`.\n+    // So, there are two references: the first one is a definition of the `foo` module,\n+    // which is the whole `foo.rs`, and the second one is in `use foo::Foo`.\n+    #[test]\n+    fn test_find_all_refs_decl_module() {\n+        let code = r#\"\n+            //- /lib.rs\n             mod foo<|>;\n \n-            //- /bar/foo.rs\n-            // emtpy\n-            \",\n-        );\n-        let new_name = \"foo2\";\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        assert_debug_snapshot!(&source_change,\n-@r###\"\n-        Some(\n-            RangeInfo {\n-                range: [4; 7),\n-                info: SourceChange {\n-                    label: \"rename\",\n-                    source_file_edits: [\n-                        SourceFileEdit {\n-                            file_id: FileId(\n-                                2,\n-                            ),\n-                            edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: [4; 7),\n-                                        insert: \"foo2\",\n-                                    },\n-                                ],\n-                            },\n-                        },\n-                    ],\n-                    file_system_edits: [\n-                        MoveFile {\n-                            src: FileId(\n-                                3,\n-                            ),\n-                            dst_source_root: SourceRootId(\n-                                0,\n-                            ),\n-                            dst_path: \"bar/foo2.rs\",\n-                        },\n-                    ],\n-                    cursor_position: None,\n-                },\n-            },\n-        )\n-        \"###);\n+            use foo::Foo;\n+\n+            fn f() {\n+                let i = Foo { n: 5 };\n+            }\n+\n+            //- /foo.rs\n+            pub struct Foo {\n+                pub n: u32,\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos).unwrap().unwrap();\n+        assert_eq!(refs.len(), 2);\n     }\n \n     #[test]\n-    fn test_rename_mod_in_dir() {\n-        let (analysis, position) = analysis_and_position(\n-            \"\n+    fn test_find_all_refs_super_mod_vis() {\n+        let code = r#\"\n             //- /lib.rs\n-            mod fo<|>o;\n-            //- /foo/mod.rs\n-            // emtpy\n-            \",\n-        );\n-        let new_name = \"foo2\";\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        assert_debug_snapshot!(&source_change,\n-        @r###\"\n-        Some(\n-            RangeInfo {\n-                range: [4; 7),\n-                info: SourceChange {\n-                    label: \"rename\",\n-                    source_file_edits: [\n-                        SourceFileEdit {\n-                            file_id: FileId(\n-                                1,\n-                            ),\n-                            edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: [4; 7),\n-                                        insert: \"foo2\",\n-                                    },\n-                                ],\n-                            },\n-                        },\n-                    ],\n-                    file_system_edits: [\n-                        MoveFile {\n-                            src: FileId(\n-                                2,\n-                            ),\n-                            dst_source_root: SourceRootId(\n-                                0,\n-                            ),\n-                            dst_path: \"foo2/mod.rs\",\n-                        },\n-                    ],\n-                    cursor_position: None,\n-                },\n-            },\n-        )\n-        \"###\n-               );\n+            mod foo;\n+\n+            //- /foo.rs\n+            mod some;\n+            use some::Foo;\n+\n+            fn f() {\n+                let i = Foo { n: 5 };\n+            }\n+\n+            //- /foo/some.rs\n+            pub(super) struct Foo<|> {\n+                pub n: u32,\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos).unwrap().unwrap();\n+        assert_eq!(refs.len(), 3);\n     }\n \n-    fn test_rename(text: &str, new_name: &str, expected: &str) {\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n         let (analysis, position) = single_file_with_position(text);\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n-        let mut file_id: Option<FileId> = None;\n-        if let Some(change) = source_change {\n-            for edit in change.info.source_file_edits {\n-                file_id = Some(edit.file_id);\n-                for atom in edit.edit.as_atoms() {\n-                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n-                }\n-            }\n-        }\n-        let result =\n-            text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()).unwrap());\n-        assert_eq_text!(expected, &*result);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n     }\n }"}, {"sha": "c8daff9b1bd91a45c71d29c0468495fd2e27f0a1", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -0,0 +1,179 @@\n+//! Functions that are used to classify an element from its definition or reference.\n+\n+use hir::{Either, FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n+use ra_db::FileId;\n+use ra_syntax::{ast, match_ast, AstNode, AstPtr};\n+use test_utils::tested_by;\n+\n+use super::{\n+    name_definition::{from_assoc_item, from_module_def, from_pat, from_struct_field},\n+    NameDefinition, NameKind,\n+};\n+use crate::db::RootDatabase;\n+\n+pub(crate) fn classify_name(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name: &ast::Name,\n+) -> Option<NameDefinition> {\n+    let parent = name.syntax().parent()?;\n+    let file_id = file_id.into();\n+\n+    // FIXME: add ast::MacroCall(it)\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                from_pat(db, file_id, AstPtr::new(&it))\n+            },\n+            ast::RecordFieldDef(it) => {\n+                let ast = hir::FieldSource::Named(it);\n+                let src = hir::Source { file_id, ast };\n+                let field = hir::StructField::from_source(db, src)?;\n+                Some(from_struct_field(db, field))\n+            },\n+            ast::Module(it) => {\n+                let def = {\n+                    if !it.has_semi() {\n+                        let ast = hir::ModuleSource::Module(it);\n+                        let src = hir::Source { file_id, ast };\n+                        hir::Module::from_definition(db, src)\n+                    } else {\n+                        let src = hir::Source { file_id, ast: it };\n+                        hir::Module::from_declaration(db, src)\n+                    }\n+                }?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::StructDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Struct::from_source(db, src)?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Enum::from_source(db, src)?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Trait::from_source(db, src)?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Static::from_source(db, src)?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::EnumVariant::from_source(db, src)?;\n+                Some(from_module_def(db, def.into(), None))\n+            },\n+            ast::FnDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Function::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into(), None))\n+                }\n+            },\n+            ast::ConstDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Const::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into(), None))\n+                }\n+            },\n+            ast::TypeAliasDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::TypeAlias::from_source(db, src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(db, def.into()))\n+                } else {\n+                    Some(from_module_def(db, def.into(), None))\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn classify_name_ref(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name_ref: &ast::NameRef,\n+) -> Option<NameDefinition> {\n+    use PathResolution::*;\n+\n+    let parent = name_ref.syntax().parent()?;\n+    let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+\n+    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_methods);\n+        if let Some(func) = analyzer.resolve_method_call(&method_call) {\n+            return Some(from_assoc_item(db, func.into()));\n+        }\n+    }\n+\n+    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_fields);\n+        if let Some(field) = analyzer.resolve_field(&field_expr) {\n+            return Some(from_struct_field(db, field));\n+        }\n+    }\n+\n+    if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_record_fields);\n+        if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n+            let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n+            let hir_path = Path::from_name_ref(name_ref);\n+            let hir_name = hir_path.as_ident()?;\n+            let field = variant_def.field(db, hir_name)?;\n+            return Some(from_struct_field(db, field));\n+        }\n+    }\n+\n+    let ast = ModuleSource::from_child_node(db, file_id, &parent);\n+    let file_id = file_id.into();\n+    // FIXME: find correct container and visibility for each case\n+    let container = Module::from_definition(db, Source { file_id, ast })?;\n+    let visibility = None;\n+\n+    if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n+        tested_by!(goto_definition_works_for_macros);\n+        if let Some(macro_def) = analyzer.resolve_macro_call(db, &macro_call) {\n+            let kind = NameKind::Macro(macro_def);\n+            return Some(NameDefinition { kind, container, visibility });\n+        }\n+    }\n+\n+    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let resolved = analyzer.resolve_path(db, &path)?;\n+    match resolved {\n+        Def(def) => Some(from_module_def(db, def, Some(container))),\n+        AssocItem(item) => Some(from_assoc_item(db, item)),\n+        LocalBinding(Either::A(pat)) => from_pat(db, file_id, pat),\n+        LocalBinding(Either::B(par)) => {\n+            let kind = NameKind::SelfParam(par);\n+            Some(NameDefinition { kind, container, visibility })\n+        }\n+        GenericParam(par) => {\n+            // FIXME: get generic param def\n+            let kind = NameKind::GenericParam(par);\n+            Some(NameDefinition { kind, container, visibility })\n+        }\n+        Macro(def) => {\n+            let kind = NameKind::Macro(def);\n+            Some(NameDefinition { kind, container, visibility })\n+        }\n+        SelfType(impl_block) => {\n+            let ty = impl_block.target_ty(db);\n+            let kind = NameKind::SelfType(ty);\n+            let container = impl_block.module();\n+            Some(NameDefinition { kind, container, visibility })\n+        }\n+    }\n+}"}, {"sha": "4580bc789955da96c43839125d787956d46a4ca9", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -0,0 +1,113 @@\n+//! `NameDefinition` keeps information about the element we want to search references for.\n+//! The element is represented by `NameKind`. It's located inside some `container` and\n+//! has a `visibility`, which defines a search scope.\n+//! Note that the reference search is possible for not all of the classified items.\n+\n+use hir::{\n+    db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,\n+    Module, ModuleDef, StructField, Ty, VariantDef,\n+};\n+use ra_syntax::{ast, ast::VisibilityOwner, match_ast, AstNode, AstPtr};\n+\n+use crate::db::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    Field(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(Ty),\n+    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n+    SelfParam(AstPtr<ast::SelfParam>),\n+    GenericParam(u32),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct NameDefinition {\n+    pub visibility: Option<ast::Visibility>,\n+    pub container: Module,\n+    pub kind: NameKind,\n+}\n+\n+pub(super) fn from_pat(\n+    db: &RootDatabase,\n+    file_id: HirFileId,\n+    pat: AstPtr<ast::BindPat>,\n+) -> Option<NameDefinition> {\n+    let root = db.parse_or_expand(file_id)?;\n+    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n+        match_ast! {\n+            match node {\n+                ast::FnDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Function::from_source(db, src)?.into())\n+                },\n+                ast::ConstDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Const::from_source(db, src)?.into())\n+                },\n+                ast::StaticDef(it) => {\n+                    let src = hir::Source { file_id, ast: it };\n+                    Some(hir::Static::from_source(db, src)?.into())\n+                },\n+                _ => None,\n+            }\n+        }\n+    })?;\n+    let kind = NameKind::Pat((def, pat));\n+    let container = def.module(db);\n+    Some(NameDefinition { kind, container, visibility: None })\n+}\n+\n+pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n+    let container = item.module(db);\n+    let visibility = match item {\n+        AssocItem::Function(f) => f.source(db).ast.visibility(),\n+        AssocItem::Const(c) => c.source(db).ast.visibility(),\n+        AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n+    };\n+    let kind = NameKind::AssocItem(item);\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+    let kind = NameKind::Field(field);\n+    let parent = field.parent_def(db);\n+    let container = parent.module(db);\n+    let visibility = match parent {\n+        VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub(super) fn from_module_def(\n+    db: &RootDatabase,\n+    def: ModuleDef,\n+    module: Option<Module>,\n+) -> NameDefinition {\n+    let kind = NameKind::Def(def);\n+    let (container, visibility) = match def {\n+        ModuleDef::Module(it) => {\n+            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+            let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n+            (container, visibility)\n+        }\n+        ModuleDef::EnumVariant(it) => {\n+            let container = it.module(db);\n+            let visibility = it.source(db).ast.parent_enum().visibility();\n+            (container, visibility)\n+        }\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}"}, {"sha": "0e2e088e0a9303379d74507dcc39d40edd70f546", "filename": "crates/ra_ide_api/src/references/rename.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -0,0 +1,469 @@\n+//! FIXME: write short doc here\n+\n+use hir::ModuleSource;\n+use ra_db::{SourceDatabase, SourceDatabaseExt};\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n+use relative_path::{RelativePath, RelativePathBuf};\n+\n+use crate::{\n+    db::RootDatabase, FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange,\n+    SourceFileEdit, TextRange,\n+};\n+\n+use super::find_all_refs;\n+\n+pub(crate) fn rename(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let parse = db.parse(position.file_id);\n+    if let Some((ast_name, ast_module)) =\n+        find_name_and_module_at_offset(parse.tree().syntax(), position)\n+    {\n+        let range = ast_name.syntax().text_range();\n+        rename_mod(db, &ast_name, &ast_module, position, new_name)\n+            .map(|info| RangeInfo::new(range, info))\n+    } else {\n+        rename_reference(db, position, new_name)\n+    }\n+}\n+\n+fn find_name_and_module_at_offset(\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+) -> Option<(ast::Name, ast::Module)> {\n+    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n+    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n+    Some((ast_name, ast_module))\n+}\n+\n+fn source_edit_from_file_id_range(\n+    file_id: FileId,\n+    range: TextRange,\n+    new_name: &str,\n+) -> SourceFileEdit {\n+    SourceFileEdit {\n+        file_id,\n+        edit: {\n+            let mut builder = ra_text_edit::TextEditBuilder::default();\n+            builder.replace(range, new_name.into());\n+            builder.finish()\n+        },\n+    }\n+}\n+\n+fn rename_mod(\n+    db: &RootDatabase,\n+    ast_name: &ast::Name,\n+    ast_module: &ast::Module,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<SourceChange> {\n+    let mut source_file_edits = Vec::new();\n+    let mut file_system_edits = Vec::new();\n+    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n+    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n+        let src = module.definition_source(db);\n+        let file_id = src.file_id.original_file(db);\n+        match src.ast {\n+            ModuleSource::SourceFile(..) => {\n+                let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n+                // mod is defined in path/to/dir/mod.rs\n+                let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n+                    mod_path\n+                        .parent()\n+                        .and_then(|p| p.parent())\n+                        .or_else(|| Some(RelativePath::new(\"\")))\n+                        .map(|p| p.join(new_name).join(\"mod.rs\"))\n+                } else {\n+                    Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n+                };\n+                if let Some(path) = dst_path {\n+                    let move_file = FileSystemEdit::MoveFile {\n+                        src: file_id,\n+                        dst_source_root: db.file_source_root(position.file_id),\n+                        dst_path: path,\n+                    };\n+                    file_system_edits.push(move_file);\n+                }\n+            }\n+            ModuleSource::Module(..) => {}\n+        }\n+    }\n+\n+    let edit = SourceFileEdit {\n+        file_id: position.file_id,\n+        edit: {\n+            let mut builder = ra_text_edit::TextEditBuilder::default();\n+            builder.replace(ast_name.syntax().text_range(), new_name.into());\n+            builder.finish()\n+        },\n+    };\n+    source_file_edits.push(edit);\n+\n+    Some(SourceChange::from_edits(\"rename\", source_file_edits, file_system_edits))\n+}\n+\n+fn rename_reference(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let RangeInfo { range, info: refs } = find_all_refs(db, position)?;\n+\n+    let edit = refs\n+        .into_iter()\n+        .map(|range| source_edit_from_file_id_range(range.file_id, range.range, new_name))\n+        .collect::<Vec<_>>();\n+\n+    if edit.is_empty() {\n+        return None;\n+    }\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"rename\", edit)))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n+        ReferenceSearchResult,\n+    };\n+    use insta::assert_debug_snapshot;\n+    use test_utils::assert_eq_text;\n+\n+    #[test]\n+    fn test_find_all_refs_for_local() {\n+        let code = r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 5);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_param_inside() {\n+        let code = r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_fn_param() {\n+        let code = r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_field_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo {\n+                pub spam<|>: u32,\n+            }\n+\n+            fn main(s: Foo) {\n+                let f = s.spam;\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_impl_item_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn f<|>(&self) {  }\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_enum_var_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            enum Foo {\n+                A,\n+                B<|>,\n+                C,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_modules() {\n+        let code = r#\"\n+            //- /lib.rs\n+            pub mod foo;\n+            pub mod bar;\n+\n+            fn f() {\n+                let i = foo::Foo { n: 5 };\n+            }\n+\n+            //- /foo.rs\n+            use crate::bar;\n+\n+            pub struct Foo {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = bar::Bar { n: 5 };\n+            }\n+\n+            //- /bar.rs\n+            use crate::foo;\n+\n+            pub struct Bar {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = foo::Foo<|> { n: 5 };\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos).unwrap().unwrap();\n+        assert_eq!(refs.len(), 3);\n+    }\n+\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n+    }\n+\n+    #[test]\n+    fn test_rename_for_local() {\n+        test_rename(\n+            r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#,\n+            \"k\",\n+            r#\"\n+    fn main() {\n+        let mut k = 1;\n+        let j = 1;\n+        k = k + j;\n+\n+        {\n+            k = 0;\n+        }\n+\n+        k = 5;\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_param_inside() {\n+        test_rename(\n+            r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#,\n+            \"j\",\n+            r#\"\n+    fn foo(j : u32) -> u32 {\n+        j\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_refs_for_fn_param() {\n+        test_rename(\n+            r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#,\n+            \"new_name\",\n+            r#\"\n+    fn foo(new_name : u32) -> u32 {\n+        new_name\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_mut_param() {\n+        test_rename(\n+            r#\"\n+    fn foo(mut i<|> : u32) -> u32 {\n+        i\n+    }\"#,\n+            \"new_name\",\n+            r#\"\n+    fn foo(mut new_name : u32) -> u32 {\n+        new_name\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_mod() {\n+        let (analysis, position) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod bar;\n+\n+            //- /bar.rs\n+            mod foo<|>;\n+\n+            //- /bar/foo.rs\n+            // emtpy\n+            \",\n+        );\n+        let new_name = \"foo2\";\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        assert_debug_snapshot!(&source_change,\n+@r###\"\n+        Some(\n+            RangeInfo {\n+                range: [4; 7),\n+                info: SourceChange {\n+                    label: \"rename\",\n+                    source_file_edits: [\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                2,\n+                            ),\n+                            edit: TextEdit {\n+                                atoms: [\n+                                    AtomTextEdit {\n+                                        delete: [4; 7),\n+                                        insert: \"foo2\",\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                    ],\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                3,\n+                            ),\n+                            dst_source_root: SourceRootId(\n+                                0,\n+                            ),\n+                            dst_path: \"bar/foo2.rs\",\n+                        },\n+                    ],\n+                    cursor_position: None,\n+                },\n+            },\n+        )\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn test_rename_mod_in_dir() {\n+        let (analysis, position) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod fo<|>o;\n+            //- /foo/mod.rs\n+            // emtpy\n+            \",\n+        );\n+        let new_name = \"foo2\";\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        assert_debug_snapshot!(&source_change,\n+        @r###\"\n+        Some(\n+            RangeInfo {\n+                range: [4; 7),\n+                info: SourceChange {\n+                    label: \"rename\",\n+                    source_file_edits: [\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                1,\n+                            ),\n+                            edit: TextEdit {\n+                                atoms: [\n+                                    AtomTextEdit {\n+                                        delete: [4; 7),\n+                                        insert: \"foo2\",\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                    ],\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                2,\n+                            ),\n+                            dst_source_root: SourceRootId(\n+                                0,\n+                            ),\n+                            dst_path: \"foo2/mod.rs\",\n+                        },\n+                    ],\n+                    cursor_position: None,\n+                },\n+            },\n+        )\n+        \"###\n+               );\n+    }\n+\n+    fn test_rename(text: &str, new_name: &str, expected: &str) {\n+        let (analysis, position) = single_file_with_position(text);\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n+        let mut file_id: Option<FileId> = None;\n+        if let Some(change) = source_change {\n+            for edit in change.info.source_file_edits {\n+                file_id = Some(edit.file_id);\n+                for atom in edit.edit.as_atoms() {\n+                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n+                }\n+            }\n+        }\n+        let result =\n+            text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()).unwrap());\n+        assert_eq_text!(expected, &*result);\n+    }\n+}"}, {"sha": "5cb69b8fcd12d98884d18a1059918c63f840d91d", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -0,0 +1,92 @@\n+//! Generally, `search_scope` returns files that might contain references for the element.\n+//! For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n+//! In some cases, the location of the references is known to within a `TextRange`,\n+//! e.g. for things like local variables.\n+\n+use hir::{DefWithBody, HasSource, ModuleSource};\n+use ra_db::{FileId, SourceDatabase, SourceDatabaseExt};\n+use ra_syntax::{AstNode, TextRange};\n+use rustc_hash::FxHashSet;\n+\n+use crate::db::RootDatabase;\n+\n+use super::{NameDefinition, NameKind};\n+\n+impl NameDefinition {\n+    pub(crate) fn search_scope(&self, db: &RootDatabase) -> FxHashSet<(FileId, Option<TextRange>)> {\n+        let module_src = self.container.definition_source(db);\n+        let file_id = module_src.file_id.original_file(db);\n+\n+        if let NameKind::Pat((def, _)) = self.kind {\n+            let mut res = FxHashSet::default();\n+            let range = match def {\n+                DefWithBody::Function(f) => f.source(db).ast.syntax().text_range(),\n+                DefWithBody::Const(c) => c.source(db).ast.syntax().text_range(),\n+                DefWithBody::Static(s) => s.source(db).ast.syntax().text_range(),\n+            };\n+            res.insert((file_id, Some(range)));\n+            return res;\n+        }\n+\n+        let vis =\n+            self.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or(\"\".to_string());\n+\n+        if vis.as_str() == \"pub(super)\" {\n+            if let Some(parent_module) = self.container.parent(db) {\n+                let mut files = FxHashSet::default();\n+                let parent_src = parent_module.definition_source(db);\n+                let file_id = parent_src.file_id.original_file(db);\n+\n+                match parent_src.ast {\n+                    ModuleSource::Module(m) => {\n+                        let range = Some(m.syntax().text_range());\n+                        files.insert((file_id, range));\n+                    }\n+                    ModuleSource::SourceFile(_) => {\n+                        files.insert((file_id, None));\n+                        files.extend(parent_module.children(db).map(|m| {\n+                            let src = m.definition_source(db);\n+                            (src.file_id.original_file(db), None)\n+                        }));\n+                    }\n+                }\n+                return files;\n+            }\n+        }\n+\n+        if vis.as_str() != \"\" {\n+            let source_root_id = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root_id);\n+            let mut files =\n+                source_root.walk().map(|id| (id.into(), None)).collect::<FxHashSet<_>>();\n+\n+            // FIXME: add \"pub(in path)\"\n+\n+            if vis.as_str() == \"pub(crate)\" {\n+                return files;\n+            }\n+            if vis.as_str() == \"pub\" {\n+                let krate = self.container.krate(db).unwrap();\n+                let crate_graph = db.crate_graph();\n+                for crate_id in crate_graph.iter() {\n+                    let mut crate_deps = crate_graph.dependencies(crate_id);\n+                    if crate_deps.any(|dep| dep.crate_id() == krate.crate_id()) {\n+                        let root_file = crate_graph.crate_root(crate_id);\n+                        let source_root_id = db.file_source_root(root_file);\n+                        let source_root = db.source_root(source_root_id);\n+                        files.extend(source_root.walk().map(|id| (id.into(), None)));\n+                    }\n+                }\n+                return files;\n+            }\n+        }\n+\n+        let mut res = FxHashSet::default();\n+        let range = match module_src.ast {\n+            ModuleSource::Module(m) => Some(m.syntax().text_range()),\n+            ModuleSource::SourceFile(_) => None,\n+        };\n+        res.insert((file_id, range));\n+        res\n+    }\n+}"}, {"sha": "33f3cacebeef135929482d0f1715f66202c424b1", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FileId,\n };\n \n@@ -101,12 +101,10 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                     continue;\n                 }\n                 if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n-                    // FIXME: try to reuse the SourceAnalyzers\n-                    let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                    match classify_name_ref(db, &analyzer, &name_ref) {\n-                        Some(Method(_)) => \"function\",\n+                    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+                    match name_kind {\n                         Some(Macro(_)) => \"macro\",\n-                        Some(FieldAccess(_)) => \"field\",\n+                        Some(Field(_)) => \"field\",\n                         Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n                         Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n                         Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\",\n@@ -120,7 +118,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         Some(Def(hir::ModuleDef::TypeAlias(_))) => \"type\",\n                         Some(Def(hir::ModuleDef::BuiltinType(_))) => \"type\",\n                         Some(SelfType(_)) => \"type\",\n-                        Some(Pat(ptr)) => {\n+                        Some(Pat((_, ptr))) => {\n                             let pat = ptr.to_node(&root);\n                             if let Some(name) = pat.name() {\n                                 let text = name.text();\n@@ -130,6 +128,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                                     Some(calc_binding_hash(file_id, &text, *shadow_count))\n                             }\n \n+                            let analyzer =\n+                                hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n                             if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n                                 \"variable.mut\"\n                             } else {"}, {"sha": "3070828654b0c64253f173f8db9dadf7d1de5626", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4fe14fab96c8b40763f9ed5bef51942fd7e504/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=4f4fe14fab96c8b40763f9ed5bef51942fd7e504", "patch": "@@ -481,7 +481,6 @@ pub fn handle_references(\n     params: req::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let position = params.text_document_position.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n \n     let refs = match world.analysis().find_all_refs(position)? {\n         None => return Ok(None),\n@@ -490,13 +489,19 @@ pub fn handle_references(\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|r| to_location(r.file_id, r.range, &world, &line_index).ok())\n+            .filter_map(|r| {\n+                let line_index = world.analysis().file_line_index(r.file_id).ok()?;\n+                to_location(r.file_id, r.range, &world, &line_index).ok()\n+            })\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|r| to_location(r.file_id, r.range, &world, &line_index).ok())\n+            .filter_map(|r| {\n+                let line_index = world.analysis().file_line_index(r.file_id).ok()?;\n+                to_location(r.file_id, r.range, &world, &line_index).ok()\n+            })\n             .collect()\n     };\n \n@@ -746,6 +751,7 @@ pub fn handle_document_highlight(\n \n     Ok(Some(\n         refs.into_iter()\n+            .filter(|r| r.file_id == file_id)\n             .map(|r| DocumentHighlight { range: r.range.conv_with(&line_index), kind: None })\n             .collect(),\n     ))"}]}