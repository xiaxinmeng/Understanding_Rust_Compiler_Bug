{"sha": "8213e184477c19eba75840e9310266a6529de20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTNlMTg0NDc3YzE5ZWJhNzU4NDBlOTMxMDI2NmE2NTI5ZGUyMGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-25T02:13:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T18:47:41Z"}, "message": "rustc: Simplify crate loading constraints\n\nThe previous code passed around a {name,version} pair everywhere, but this is\nbetter expressed as a CrateId. This patch changes these paths to store and pass\naround crate ids instead of these pairs of name/version. This also prepares the\ncode to change the type of hash that is stored in crates.", "tree": {"sha": "f505c6cb68389a8b3660ab2d7972edd2987b77cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f505c6cb68389a8b3660ab2d7972edd2987b77cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8213e184477c19eba75840e9310266a6529de20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8213e184477c19eba75840e9310266a6529de20a", "html_url": "https://github.com/rust-lang/rust/commit/8213e184477c19eba75840e9310266a6529de20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8213e184477c19eba75840e9310266a6529de20a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1be3d182e361697117bf79fadca7697f8b5aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1be3d182e361697117bf79fadca7697f8b5aec", "html_url": "https://github.com/rust-lang/rust/commit/9b1be3d182e361697117bf79fadca7697f8b5aec"}], "stats": {"total": 400, "additions": 160, "deletions": 240}, "files": [{"sha": "62f1dcedab458434ad3ac4e7bcda01326d81da9c", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -70,12 +70,12 @@ pub static tag_crate_deps: uint = 0x18;\n pub static tag_crate_dep: uint = 0x19;\n \n pub static tag_crate_hash: uint = 0x1a;\n+pub static tag_crate_crateid: uint = 0x1b;\n \n-pub static tag_parent_item: uint = 0x1b;\n+pub static tag_parent_item: uint = 0x1c;\n \n-pub static tag_crate_dep_name: uint = 0x1c;\n-pub static tag_crate_dep_hash: uint = 0x1d;\n-pub static tag_crate_dep_vers: uint = 0x1e;\n+pub static tag_crate_dep_crateid: uint = 0x1d;\n+pub static tag_crate_dep_hash: uint = 0x1e;\n \n pub static tag_mod_impl: uint = 0x1f;\n "}, {"sha": "1108917cdb1d51b1d58561e7583037490fec17ae", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 94, "deletions": 134, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -79,7 +79,7 @@ struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n     hash: ~str,\n-    crateid: CrateId,\n+    crate_id: CrateId,\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n@@ -95,10 +95,10 @@ fn warn_if_multiple_versions(e: &mut Env,\n                              diag: @SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n-        let name = crate_cache[crate_cache.len() - 1].crateid.name.clone();\n+        let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();\n \n         let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == entry.crateid.name);\n+            name == entry.crate_id.name);\n \n         assert!(!matches.is_empty());\n \n@@ -107,7 +107,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n                 format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n-                loader::note_crateid_attr(diag, &match_.crateid);\n+                loader::note_crateid_attr(diag, &match_.crate_id);\n             }\n         }\n \n@@ -146,14 +146,9 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n         return;\n     }\n \n-    match extract_crate_info(i) {\n+    match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e,\n-                                     None,\n-                                     info.ident.clone(),\n-                                     info.name.clone(),\n-                                     info.version.clone(),\n-                                     ~\"\",\n+            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, \"\",\n                                      i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -163,38 +158,33 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n struct CrateInfo {\n     ident: ~str,\n-    name: ~str,\n-    version: ~str,\n+    crate_id: CrateId,\n     id: ast::NodeId,\n }\n \n-fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n+fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n         ast::ViewItemExternMod(ident, ref path_opt, id) => {\n             let ident = token::get_ident(ident);\n             debug!(\"resolving extern crate stmt. ident: {:?} path_opt: {:?}\",\n                    ident, path_opt);\n-            let (name, version) = match *path_opt {\n+            let crate_id = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let crateid: Option<CrateId> = from_str(path_str.get());\n                     match crateid {\n-                        None => (~\"\", ~\"\"),\n-                        Some(crateid) => {\n-                            let version = match crateid.version {\n-                                None => ~\"\",\n-                                Some(ref ver) => ver.to_str(),\n-                            };\n-                            (crateid.name.to_str(), version)\n+                        None => {\n+                            e.sess.span_err(i.span, \"malformed crate id\");\n+                            return None\n                         }\n+                        Some(id) => id\n                     }\n                 }\n-                None => (ident.get().to_str(), ~\"\"),\n+                None => from_str(ident.get().to_str()).unwrap()\n             };\n             Some(CrateInfo {\n-                  ident: ident.get().to_str(),\n-                  name: name,\n-                  version: version,\n-                  id: id,\n+                ident: ident.get().to_str(),\n+                crate_id: crate_id,\n+                id: id,\n             })\n         }\n         _ => None\n@@ -285,100 +275,93 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, name: &str, version: &str, hash: &str) -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, crate_id: &CrateId,\n+                  hash: &str) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n-        let crateid_version = match c.crateid.version {\n-            None => ~\"0.0\",\n-            Some(ref ver) => ver.to_str(),\n-        };\n-        if (name.is_empty() || name == c.crateid.name) &&\n-            (version.is_empty() || version == crateid_version) &&\n-            (hash.is_empty() || hash == c.hash) {\n-            return Some(c.cnum);\n+        if crate_id.matches(&c.crate_id) &&\n+           (hash.is_empty() || hash == c.hash.as_slice()) {\n+            return Some(c.cnum)\n         }\n     }\n     None\n }\n \n fn resolve_crate(e: &mut Env,\n-                 root_ident: Option<~str>,\n-                 ident: ~str,\n-                 name: ~str,\n-                 version: ~str,\n-                 hash: ~str,\n+                 root_ident: Option<&str>,\n+                 ident: &str,\n+                 crate_id: &CrateId,\n+                 hash: &str,\n                  span: Span)\n               -> ast::CrateNum {\n-    match existing_match(e, name, version, hash) {\n-      None => {\n-        let load_ctxt = loader::Context {\n-            sess: e.sess,\n-            span: span,\n-            ident: ident,\n-            name: name,\n-            version: version,\n-            hash: hash,\n-            os: e.os,\n-            intr: e.intr\n-        };\n-        let loader::Library {\n-            dylib, rlib, metadata\n-        } = load_ctxt.load_library_crate(root_ident.clone());\n-\n-        let attrs = decoder::get_crate_attributes(metadata.as_slice());\n-        let crateid = attr::find_crateid(attrs).unwrap();\n-        let hash = decoder::get_crate_hash(metadata.as_slice());\n-\n-        // Claim this crate number and cache it\n-        let cnum = e.next_crate_num;\n-        {\n-            let mut crate_cache = e.crate_cache.borrow_mut();\n-            crate_cache.get().push(cache_entry {\n-                cnum: cnum,\n+    match existing_match(e, crate_id, hash) {\n+        None => {\n+            let load_ctxt = loader::Context {\n+                sess: e.sess,\n                 span: span,\n+                ident: ident,\n+                crate_id: crate_id,\n                 hash: hash,\n-                crateid: crateid,\n-            });\n-        }\n-        e.next_crate_num += 1;\n-\n-        // Maintain a reference to the top most crate.\n-        let root_crate = match root_ident {\n-            Some(c) => c,\n-            None => load_ctxt.ident.clone()\n-        };\n+                os: e.os,\n+                intr: e.intr\n+            };\n+            let loader::Library {\n+                dylib, rlib, metadata\n+            } = load_ctxt.load_library_crate(root_ident);\n+\n+            let crate_id = decoder::get_crate_id(metadata.as_slice());\n+            let hash = decoder::get_crate_hash(metadata.as_slice());\n+\n+            // Claim this crate number and cache it\n+            let cnum = e.next_crate_num;\n+            {\n+                let mut crate_cache = e.crate_cache.borrow_mut();\n+                crate_cache.get().push(cache_entry {\n+                    cnum: cnum,\n+                    span: span,\n+                    hash: hash,\n+                    crate_id: crate_id,\n+                });\n+            }\n+            e.next_crate_num += 1;\n \n-        // Now resolve the crates referenced by this crate\n-        let cnum_map = resolve_crate_deps(e,\n-                                          Some(root_crate),\n-                                          metadata.as_slice(),\n-                                          span);\n+            // Maintain a reference to the top most crate.\n+            let root_crate = match root_ident {\n+                Some(c) => c,\n+                None => load_ctxt.ident.clone()\n+            };\n \n-        let cmeta = @cstore::crate_metadata {\n-            name: load_ctxt.name,\n-            data: metadata,\n-            cnum_map: cnum_map,\n-            cnum: cnum\n-        };\n+            // Now resolve the crates referenced by this crate\n+            let cnum_map = resolve_crate_deps(e,\n+            Some(root_crate),\n+            metadata.as_slice(),\n+            span);\n+\n+            let cmeta = @cstore::crate_metadata {\n+                name: load_ctxt.crate_id.name.to_owned(),\n+                data: metadata,\n+                cnum_map: cnum_map,\n+                cnum: cnum\n+            };\n \n-        let cstore = e.sess.cstore;\n-        cstore.set_crate_data(cnum, cmeta);\n-        cstore.add_used_crate_source(cstore::CrateSource {\n-            dylib: dylib,\n-            rlib: rlib,\n-            cnum: cnum,\n-        });\n-        return cnum;\n-      }\n-      Some(cnum) => {\n-        return cnum;\n-      }\n+            let cstore = e.sess.cstore;\n+            cstore.set_crate_data(cnum, cmeta);\n+            cstore.add_used_crate_source(cstore::CrateSource {\n+                dylib: dylib,\n+                rlib: rlib,\n+                cnum: cnum,\n+            });\n+            return cnum;\n+        }\n+        Some(cnum) => {\n+            return cnum;\n+        }\n     }\n }\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: &mut Env,\n-                      root_ident: Option<~str>,\n+                      root_ident: Option<&str>,\n                       cdata: &[u8], span : Span)\n                    -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n@@ -388,31 +371,13 @@ fn resolve_crate_deps(e: &mut Env,\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname_str = token::get_ident(dep.name);\n-        debug!(\"resolving dep crate {} ver: {} hash: {}\",\n-               cname_str, dep.vers, dep.hash);\n-        match existing_match(e,\n-                             cname_str.get(),\n-                             dep.vers,\n-                             dep.hash) {\n-          Some(local_cnum) => {\n-            debug!(\"already have it\");\n-            // We've already seen this crate\n-            cnum_map.insert(extrn_cnum, local_cnum);\n-          }\n-          None => {\n-            debug!(\"need to load it\");\n-            // This is a new one so we've got to load it\n-            let local_cnum = resolve_crate(e,\n-                                           root_ident.clone(),\n-                                           cname_str.get().to_str(),\n-                                           cname_str.get().to_str(),\n-                                           dep.vers.clone(),\n-                                           dep.hash.clone(),\n-                                           span);\n-            cnum_map.insert(extrn_cnum, local_cnum);\n-          }\n-        }\n+        debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n+        let local_cnum = resolve_crate(e, root_ident,\n+                                       dep.crate_id.name.as_slice(),\n+                                       &dep.crate_id,\n+                                       dep.hash,\n+                                       span);\n+        cnum_map.insert(extrn_cnum, local_cnum);\n     }\n     return @RefCell::new(cnum_map);\n }\n@@ -439,14 +404,9 @@ impl Loader {\n \n impl CrateLoader for Loader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n-        let info = extract_crate_info(krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env,\n-                                 None,\n-                                 info.ident.clone(),\n-                                 info.name.clone(),\n-                                 info.version.clone(),\n-                                 ~\"\",\n-                                 krate.span);\n+        let info = extract_crate_info(&self.env, krate).unwrap();\n+        let cnum = resolve_crate(&mut self.env, None, info.ident,\n+                                 &info.crate_id, \"\", krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "12461ddbe7154bea7c430598dc9fe3035fe547f5", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -21,6 +21,7 @@ use collections::HashMap;\n use extra::c_vec::CVec;\n use syntax::ast;\n use syntax::parse::token::IdentInterner;\n+use syntax::crateid::CrateId;\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -96,9 +97,9 @@ impl CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> ~str {\n+    pub fn get_crate_id(&self, cnum: ast::CrateNum) -> CrateId {\n         let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_vers(cdata.data())\n+        decoder::get_crate_id(cdata.data())\n     }\n \n     pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n@@ -191,41 +192,6 @@ impl CStore {\n         let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n         extern_mod_crate_map.get().find(&emod_id).map(|x| *x)\n     }\n-\n-    // returns hashes of crates directly used by this crate. Hashes are sorted by\n-    // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-    pub fn get_dep_hashes(&self) -> ~[~str] {\n-        let mut result = ~[];\n-\n-        let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n-        for (_, &cnum) in extern_mod_crate_map.get().iter() {\n-            let cdata = self.get_crate_data(cnum);\n-            let hash = decoder::get_crate_hash(cdata.data());\n-            let vers = decoder::get_crate_vers(cdata.data());\n-            debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n-            result.push(crate_hash {\n-                name: cdata.name.clone(),\n-                vers: vers,\n-                hash: hash\n-            });\n-        }\n-\n-        result.sort();\n-\n-        debug!(\"sorted:\");\n-        for x in result.iter() {\n-            debug!(\"  hash[{}]: {}\", x.name, x.hash);\n-        }\n-\n-        result.move_iter().map(|crate_hash { hash, ..}| hash).collect()\n-    }\n-}\n-\n-#[deriving(Clone, TotalEq, TotalOrd)]\n-struct crate_hash {\n-    name: ~str,\n-    vers: ~str,\n-    hash: ~str,\n }\n \n impl crate_metadata {"}, {"sha": "f365ddef94f541799d38ad13f7c2c4a4b9fcea2d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -17,7 +17,6 @@ use metadata::common::*;\n use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n@@ -44,6 +43,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::crateid::CrateId;\n \n type Cmd = @crate_metadata;\n \n@@ -1108,9 +1108,8 @@ pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n #[deriving(Clone)]\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n-    name: ast::Ident,\n-    vers: ~str,\n-    hash: ~str\n+    crate_id: CrateId,\n+    hash: ~str,\n }\n \n pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n@@ -1123,10 +1122,13 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n         d.as_str_slice().to_str()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n-        deps.push(CrateDep {cnum: crate_num,\n-                  name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n-                  vers: docstr(depdoc, tag_crate_dep_vers),\n-                  hash: docstr(depdoc, tag_crate_dep_hash)});\n+        let crate_id = from_str(docstr(depdoc, tag_crate_dep_crateid)).unwrap();\n+        let hash = docstr(depdoc, tag_crate_dep_hash);\n+        deps.push(CrateDep {\n+            cnum: crate_num,\n+            crate_id: crate_id,\n+            hash: hash,\n+        });\n         crate_num += 1;\n         true\n     });\n@@ -1135,17 +1137,9 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n \n fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n-\n-    let r = get_crate_deps(data);\n-    for dep in r.iter() {\n-        try!(write!(out,\n-                      \"{} {}-{}-{}\\n\",\n-                      dep.cnum,\n-                      token::get_ident(dep.name),\n-                      dep.hash,\n-                      dep.vers));\n+    for dep in get_crate_deps(data).iter() {\n+        try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.crate_id, dep.hash));\n     }\n-\n     try!(write!(out, \"\\n\"));\n     Ok(())\n }\n@@ -1156,12 +1150,10 @@ pub fn get_crate_hash(data: &[u8]) -> ~str {\n     hashdoc.as_str_slice().to_str()\n }\n \n-pub fn get_crate_vers(data: &[u8]) -> ~str {\n-    let attrs = decoder::get_crate_attributes(data);\n-    match attr::find_crateid(attrs) {\n-        None => ~\"0.0\",\n-        Some(crateid) => crateid.version_or_default().to_str(),\n-    }\n+pub fn get_crate_id(data: &[u8]) -> CrateId {\n+    let cratedoc = reader::Doc(data);\n+    let hashdoc = reader::get_doc(cratedoc, tag_crate_crateid);\n+    from_str(hashdoc.as_str_slice()).unwrap()\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {"}, {"sha": "976c1ee92d3de34f25d075cd85cf936427e21c09", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -40,6 +40,7 @@ use syntax::ast_util::*;\n use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n+use syntax::crateid::CrateId;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n@@ -1510,8 +1511,7 @@ fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n         cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {\n                 cnum: key,\n-                name: token::str_to_ident(val.name),\n-                vers: decoder::get_crate_vers(val.data()),\n+                crate_id: decoder::get_crate_id(val.data()),\n                 hash: decoder::get_crate_hash(val.data())\n             };\n             deps.push(dep);\n@@ -1729,12 +1729,8 @@ fn encode_misc_info(ecx: &EncodeContext,\n fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n                     dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_name);\n-    let s = token::get_ident(dep.name);\n-    ebml_w.writer.write(s.get().as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(dep.vers.as_bytes());\n+    ebml_w.start_tag(tag_crate_dep_crateid);\n+    ebml_w.writer.write(dep.crate_id.to_str().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n     ebml_w.writer.write(dep.hash.as_bytes());\n@@ -1748,6 +1744,12 @@ fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n     ebml_w.end_tag();\n }\n \n+fn encode_crate_id(ebml_w: &mut writer::Encoder, crate_id: &CrateId) {\n+    ebml_w.start_tag(tag_crate_crateid);\n+    ebml_w.writer.write(crate_id.to_str().as_bytes());\n+    ebml_w.end_tag();\n+}\n+\n // NB: Increment this as you change the metadata encoding version.\n pub static metadata_encoding_version : &'static [u8] =\n     &[0x72, //'r' as u8,\n@@ -1806,6 +1808,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n     let mut ebml_w = writer::Encoder(wr);\n \n+    encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n     let mut i = ebml_w.writer.tell().unwrap();"}, {"sha": "faef2412e78025484966584cea4def9be2ce343e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -44,13 +44,12 @@ pub enum Os {\n     OsFreebsd\n }\n \n-pub struct Context {\n+pub struct Context<'a> {\n     sess: Session,\n     span: Span,\n-    ident: ~str,\n-    name: ~str,\n-    version: ~str,\n-    hash: ~str,\n+    ident: &'a str,\n+    crate_id: &'a CrateId,\n+    hash: &'a str,\n     os: Os,\n     intr: @IdentInterner\n }\n@@ -79,8 +78,8 @@ fn realpath(p: &Path) -> Path {\n     }\n }\n \n-impl Context {\n-    pub fn load_library_crate(&self, root_ident: Option<~str>) -> Library {\n+impl<'a> Context<'a> {\n+    pub fn load_library_crate(&self, root_ident: Option<&str>) -> Library {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n@@ -101,8 +100,8 @@ impl Context {\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.name);\n-        let rlib_prefix = format!(\"lib{}-\", self.name);\n+        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.crate_id.name);\n+        let rlib_prefix = format!(\"lib{}-\", self.crate_id.name);\n \n         let mut candidates = HashMap::new();\n \n@@ -196,7 +195,8 @@ impl Context {\n             1 => Some(libraries[0]),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\", self.name));\n+                    format!(\"multiple matching crates for `{}`\",\n+                            self.crate_id.name));\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n@@ -243,11 +243,12 @@ impl Context {\n         debug!(\"matching -- {}, hash: {}\", file, hash);\n         let vers = match parts.next() { Some(v) => v, None => return None };\n         debug!(\"matching -- {}, vers: {}\", file, vers);\n-        if !self.version.is_empty() && self.version.as_slice() != vers {\n-            return None\n+        match self.crate_id.version {\n+            Some(ref version) if version.as_slice() != vers => return None,\n+            Some(..) | None => {}\n         }\n         debug!(\"matching -- {}, vers ok (requested {})\", file,\n-               self.version);\n+               self.crate_id.version);\n         // hashes in filenames are prefixes of the \"true hash\"\n         if self.hash.is_empty() || self.hash.starts_with(hash) {\n             debug!(\"matching -- {}, hash ok (requested {})\", file, self.hash);\n@@ -275,7 +276,7 @@ impl Context {\n         if m.len() > 1 {\n             self.sess.span_err(self.span,\n                                format!(\"multiple {} candidates for `{}` \\\n-                                        found\", flavor, self.name));\n+                                        found\", flavor, self.crate_id.name));\n             for (i, path) in m.iter().enumerate() {\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate \\#{}: {}\", i + 1,\n@@ -289,8 +290,7 @@ impl Context {\n             info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n             match get_metadata_section(self.os, &lib) {\n                 Some(blob) => {\n-                    if crate_matches(blob.as_slice(), self.name,\n-                                     self.version, self.hash) {\n+                    if crate_matches(blob.as_slice(), self.crate_id, self.hash){\n                         *slot = Some(blob);\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -323,23 +323,13 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n \n-fn crate_matches(crate_data: &[u8],\n-                 name: &str,\n-                 version: &str,\n-                 hash: &str) -> bool {\n-    let attrs = decoder::get_crate_attributes(crate_data);\n-    match attr::find_crateid(attrs) {\n-        None => false,\n-        Some(crateid) => {\n-            if !hash.is_empty() {\n-                let chash = decoder::get_crate_hash(crate_data);\n-                if chash.as_slice() != hash { return false; }\n-            }\n-            name == crateid.name &&\n-                (version.is_empty() ||\n-                 crateid.version_or_default() == version)\n-        }\n+fn crate_matches(crate_data: &[u8], crate_id: &CrateId, hash: &str) -> bool {\n+    let other_id = decoder::get_crate_id(crate_data);\n+    if !crate_id.matches(&other_id) { return false }\n+    if hash != \"\" && hash != decoder::get_crate_hash(crate_data).as_slice() {\n+        return false\n     }\n+    return true;\n }\n \n impl ArchiveMetadata {"}, {"sha": "553dbe2ae6e36ae407a6a8420e5a8eaa12dacaa5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -2488,7 +2488,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n         let cdata = cstore.get_crate_data(i);\n         let nm = symname(format!(\"_rust_crate_map_{}\", cdata.name),\n                          cstore.get_crate_hash(i),\n-                         cstore.get_crate_vers(i));\n+                         cstore.get_crate_id(i).version_or_default());\n         let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)"}, {"sha": "b5f02fb7e644106b0e37ab7cb37fd307988575fd", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8213e184477c19eba75840e9310266a6529de20a/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8213e184477c19eba75840e9310266a6529de20a/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=8213e184477c19eba75840e9310266a6529de20a", "patch": "@@ -107,6 +107,15 @@ impl CrateId {\n     pub fn short_name_with_version(&self) -> ~str {\n         format!(\"{}-{}\", self.name, self.version_or_default())\n     }\n+\n+    pub fn matches(&self, other: &CrateId) -> bool {\n+        // FIXME: why does this not match on `path`?\n+        if self.name != other.name { return false }\n+        match (&self.version, &other.version) {\n+            (&Some(ref v1), &Some(ref v2)) => v1 == v2,\n+            _ => true,\n+        }\n+    }\n }\n \n #[test]"}]}