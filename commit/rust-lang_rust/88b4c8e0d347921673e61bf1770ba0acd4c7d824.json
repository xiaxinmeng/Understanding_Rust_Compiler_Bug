{"sha": "88b4c8e0d347921673e61bf1770ba0acd4c7d824", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjRjOGUwZDM0NzkyMTY3M2U2MWJmMTc3MGJhMGFjZDRjN2Q4MjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:34Z"}, "message": "rollup merge of #20465: nikomatsakis/assoc-types-regions-20303\n\nTreat associated types the same as type parameters when it comes to region bounding. Fixes #20303.\n\nStrictly speaking, this is a [breaking-change] (if you are using\nassociated types). You are no longer free to wantonly violate the type\nsystem rules by closing associated types into objects without any form\nof region bound. Instead you should add region bounds like `T::X :\n'a`, just as you would with a normal type parameter.\n\nr? @aturon", "tree": {"sha": "2449fa32baf1d70eb9a025d1ab2e6bddae36a7a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2449fa32baf1d70eb9a025d1ab2e6bddae36a7a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b4c8e0d347921673e61bf1770ba0acd4c7d824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b4c8e0d347921673e61bf1770ba0acd4c7d824", "html_url": "https://github.com/rust-lang/rust/commit/88b4c8e0d347921673e61bf1770ba0acd4c7d824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b4c8e0d347921673e61bf1770ba0acd4c7d824/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "059566b01960f3f630316cc50989e8c57e5e696e", "url": "https://api.github.com/repos/rust-lang/rust/commits/059566b01960f3f630316cc50989e8c57e5e696e", "html_url": "https://github.com/rust-lang/rust/commit/059566b01960f3f630316cc50989e8c57e5e696e"}, {"sha": "5caf847b3f16ca08ad1203614455b20aa07f4f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caf847b3f16ca08ad1203614455b20aa07f4f0c", "html_url": "https://github.com/rust-lang/rust/commit/5caf847b3f16ca08ad1203614455b20aa07f4f0c"}], "stats": {"total": 439, "additions": 330, "deletions": 109}, "files": [{"sha": "e58ff53b00cb9f91c3e644f39075e4a70a9d9166", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -66,7 +66,8 @@ use super::region_inference::RegionResolutionError;\n use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::SupSupConflict;\n-use super::region_inference::ParamBoundFailure;\n+use super::region_inference::GenericBoundFailure;\n+use super::region_inference::GenericKind;\n use super::region_inference::ProcessedErrors;\n use super::region_inference::SameRegions;\n \n@@ -120,11 +121,11 @@ pub trait ErrorReporting<'tcx> {\n                                sub: Region,\n                                sup: Region);\n \n-    fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin<'tcx>,\n-                                  param_ty: ty::ParamTy,\n-                                  sub: Region,\n-                                  sups: Vec<Region>);\n+    fn report_generic_bound_failure(&self,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    kind: GenericKind<'tcx>,\n+                                    sub: Region,\n+                                    sups: Vec<Region>);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n@@ -175,8 +176,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n \n-                ParamBoundFailure(origin, param_ty, sub, sups) => {\n-                    self.report_param_bound_failure(origin, param_ty, sub, sups);\n+                GenericBoundFailure(kind, param_ty, sub, sups) => {\n+                    self.report_generic_bound_failure(kind, param_ty, sub, sups);\n                 }\n \n                 SubSupConflict(var_origin,\n@@ -421,63 +422,65 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                      found.user_string(self.tcx)))\n     }\n \n-    fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin<'tcx>,\n-                                  param_ty: ty::ParamTy,\n-                                  sub: Region,\n-                                  _sups: Vec<Region>) {\n-\n+    fn report_generic_bound_failure(&self,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    bound_kind: GenericKind<'tcx>,\n+                                    sub: Region,\n+                                    _sups: Vec<Region>)\n+    {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n         // where the error was detected. But that span is not readily\n         // accessible.\n \n+        let labeled_user_string = match bound_kind {\n+            GenericKind::Param(ref p) =>\n+                format!(\"the parameter type `{}`\", p.user_string(self.tcx)),\n+            GenericKind::Projection(ref p) =>\n+                format!(\"the associated type `{}`\", p.user_string(self.tcx)),\n+        };\n+\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        param_ty.user_string(self.tcx),\n+                        bound_kind.user_string(self.tcx),\n                         sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx))[]);\n             }\n \n             _ => {\n                 // If not, be less specific.\n                 self.tcx.sess.span_err(\n                     origin.span(),\n                     format!(\n-                        \"the parameter type `{}` may not live long enough\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        \"{} may not live long enough\",\n+                        labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n-                        \"consider adding an explicit lifetime bound to `{}`\",\n-                        param_ty.user_string(self.tcx))[]);\n+                        \"consider adding an explicit lifetime bound for `{}`\",\n+                        bound_kind.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"the parameter type `{}` must be valid for \",\n-                            param_ty.user_string(self.tcx))[],\n+                    format!(\"{} must be valid for \", labeled_user_string)[],\n                     sub,\n                     \"...\");\n             }"}, {"sha": "c2db81d311483b5e72d57be2921e26f39ce176bd", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -20,6 +20,7 @@ pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n+pub use self::region_inference::GenericKind;\n \n use middle::subst;\n use middle::subst::Substs;\n@@ -382,19 +383,6 @@ pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     cx.region_vars.commit(snapshot);\n }\n \n-pub fn verify_param_bound<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                    origin: SubregionOrigin<'tcx>,\n-                                    param_ty: ty::ParamTy,\n-                                    a: ty::Region,\n-                                    bs: Vec<ty::Region>) {\n-    debug!(\"verify_param_bound({}, {} <: {})\",\n-           param_ty.repr(cx.tcx),\n-           a.repr(cx.tcx),\n-           bs.repr(cx.tcx));\n-\n-    cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n-}\n-\n pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n@@ -1070,6 +1058,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             value,\n             |br, _| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n+\n+    /// See `verify_generic_bound` method in `region_inference`\n+    pub fn verify_generic_bound(&self,\n+                                origin: SubregionOrigin<'tcx>,\n+                                kind: GenericKind<'tcx>,\n+                                a: ty::Region,\n+                                bs: Vec<ty::Region>) {\n+        debug!(\"verify_generic_bound({}, {} <: {})\",\n+               kind.repr(self.tcx),\n+               a.repr(self.tcx),\n+               bs.repr(self.tcx));\n+\n+        self.region_vars.verify_generic_bound(origin, kind, a, bs);\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "23e96dafa611bf9074fb6116e77540cad52ce795", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -22,15 +22,15 @@ use super::cres;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use middle::region;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n@@ -61,12 +61,18 @@ pub enum Verify<'tcx> {\n     // `b` are inference variables.\n     VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n \n-    // VerifyParamBound(T, _, R, RS): The parameter type `T` must\n-    // outlive the region `R`. `T` is known to outlive `RS`. Therefore\n-    // verify that `R <= RS[i]` for some `i`. Inference variables may\n-    // be involved (but this verification step doesn't influence\n-    // inference).\n-    VerifyParamBound(ty::ParamTy, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+    // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+    // associated type) must outlive the region `R`. `T` is known to\n+    // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+    // `i`. Inference variables may be involved (but this verification\n+    // step doesn't influence inference).\n+    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+}\n+\n+#[deriving(Clone, Show, PartialEq, Eq)]\n+pub enum GenericKind<'tcx> {\n+    Param(ty::ParamTy),\n+    Projection(ty::ProjectionTy<'tcx>),\n }\n \n #[derive(Copy, PartialEq, Eq, Hash)]\n@@ -98,12 +104,12 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n-    /// `ParamBoundFailure(p, s, a, bs)\n+    /// `GenericBoundFailure(p, s, a, bs)\n     ///\n-    /// The parameter type `p` must be known to outlive the lifetime\n+    /// The parameter/assocated-type `p` must be known to outlive the lifetime\n     /// `a`, but it is only known to outlive `bs` (and none of the\n     /// regions in `bs` outlive `a`).\n-    ParamBoundFailure(SubregionOrigin<'tcx>, ty::ParamTy, Region, Vec<Region>),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region, Vec<Region>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -489,12 +495,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn verify_param_bound(&self,\n-                              origin: SubregionOrigin<'tcx>,\n-                              param_ty: ty::ParamTy,\n-                              sub: Region,\n-                              sups: Vec<Region>) {\n-        self.add_verify(VerifyParamBound(param_ty, origin, sub, sups));\n+    /// See `Verify::VerifyGenericBound`\n+    pub fn verify_generic_bound(&self,\n+                                origin: SubregionOrigin<'tcx>,\n+                                kind: GenericKind<'tcx>,\n+                                sub: Region,\n+                                sups: Vec<Region>) {\n+        self.add_verify(VerifyGenericBound(kind, origin, sub, sups));\n     }\n \n     pub fn lub_regions(&self,\n@@ -660,7 +667,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            VerifyParamBound(_, _, a, ref bs) => {\n+                            VerifyGenericBound(_, _, a, ref bs) => {\n                                 for &b in bs.iter() {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n@@ -1211,7 +1218,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n-                VerifyParamBound(ref param_ty, ref origin, sub, ref sups) => {\n+                VerifyGenericBound(ref kind, ref origin, sub, ref sups) => {\n                     let sub = normalize(values, sub);\n                     if sups.iter()\n                            .map(|&sup| normalize(values, sup))\n@@ -1223,8 +1230,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     let sups = sups.iter().map(|&sup| normalize(values, sup))\n                                           .collect();\n                     errors.push(\n-                        ParamBoundFailure(\n-                            (*origin).clone(), *param_ty, sub, sups));\n+                        GenericBoundFailure(\n+                            (*origin).clone(), kind.clone(), sub, sups));\n                 }\n             }\n         }\n@@ -1584,8 +1591,8 @@ impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n             VerifyRegSubReg(_, ref a, ref b) => {\n                 format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n             }\n-            VerifyParamBound(_, ref p, ref a, ref bs) => {\n-                format!(\"VerifyParamBound({}, {}, {})\",\n+            VerifyGenericBound(_, ref p, ref a, ref bs) => {\n+                format!(\"VerifyGenericBound({}, {}, {})\",\n                         p.repr(tcx), a.repr(tcx), bs.repr(tcx))\n             }\n         }\n@@ -1624,3 +1631,32 @@ impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n                 self.origin.repr(tcx))\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for GenericKind<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            GenericKind::Param(ref p) => p.repr(tcx),\n+            GenericKind::Projection(ref p) => p.repr(tcx),\n+        }\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for GenericKind<'tcx> {\n+    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            GenericKind::Param(ref p) => p.user_string(tcx),\n+            GenericKind::Projection(ref p) => p.user_string(tcx),\n+        }\n+    }\n+}\n+\n+impl<'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            GenericKind::Param(ref p) =>\n+                p.to_ty(tcx),\n+            GenericKind::Projection(ref p) =>\n+                ty::mk_projection(tcx, p.trait_ref.clone(), p.item_name),\n+        }\n+    }\n+}"}, {"sha": "65f7ad296db519855ac5cd625d79f7b11c972db7", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -643,11 +643,12 @@ fn confirm_candidate<'cx,'tcx>(\n             match impl_ty {\n                 Some(ty) => (ty, impl_vtable.nested.to_vec()),\n                 None => {\n-                    selcx.tcx().sess.span_bug(\n-                        obligation.cause.span,\n-                        format!(\"impl `{}` did not contain projection for `{}`\",\n-                                impl_vtable.repr(selcx.tcx()),\n-                                obligation.repr(selcx.tcx())).as_slice());\n+                    // This means that the impl is missing a\n+                    // definition for the associated type. This error\n+                    // ought to be reported by the type checker method\n+                    // `check_impl_items_against_trait`, so here we\n+                    // just return ty_err.\n+                    (selcx.tcx().types.err, vec!())\n                 }\n             }\n         }"}, {"sha": "b7397b5f9ee61468097c5b0c7b40b3b1b7896095", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -92,7 +92,7 @@ use middle::region::CodeExtent;\n use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty::{self, Ty, MethodCall};\n-use middle::infer;\n+use middle::infer::{mod, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n \n@@ -164,7 +164,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n-    region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n+    region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_param_pairs: Vec::new() }\n+              region_bound_pairs: Vec::new() }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -286,12 +286,12 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             }\n         };\n \n-        let len = self.region_param_pairs.len();\n+        let len = self.region_bound_pairs.len();\n         self.relate_free_regions(fn_sig[], body.id);\n         link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n-        self.region_param_pairs.truncate(len);\n+        self.region_bound_pairs.truncate(len);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -357,11 +357,11 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    regionmanip::RegionSubParamConstraint(_, r_a, p_b) => {\n-                        debug!(\"RegionSubParamConstraint: {} <= {}\",\n-                               r_a.repr(tcx), p_b.repr(tcx));\n+                    regionmanip::RegionSubGenericConstraint(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGenericConstraint: {} <= {}\",\n+                               r_a.repr(tcx), generic_b.repr(tcx));\n \n-                        self.region_param_pairs.push((r_a, p_b));\n+                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n                 }\n             }\n@@ -1427,31 +1427,31 @@ fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 rcx.fcx.mk_subr(o1, r_a, r_b);\n             }\n-            regionmanip::RegionSubParamConstraint(None, r_a, param_b) => {\n-                param_must_outlive(rcx, origin.clone(), r_a, param_b);\n+            regionmanip::RegionSubGenericConstraint(None, r_a, ref generic_b) => {\n+                generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n             }\n-            regionmanip::RegionSubParamConstraint(Some(ty), r_a, param_b) => {\n+            regionmanip::RegionSubGenericConstraint(Some(ty), r_a, ref generic_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                param_must_outlive(rcx, o1, r_a, param_b);\n+                generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n         }\n     }\n }\n \n-fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                origin: infer::SubregionOrigin<'tcx>,\n-                                region: ty::Region,\n-                                param_ty: ty::ParamTy) {\n+fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                  origin: infer::SubregionOrigin<'tcx>,\n+                                  region: ty::Region,\n+                                  generic: &GenericKind<'tcx>) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n-    debug!(\"param_must_outlive(region={}, param_ty={})\",\n+    debug!(\"param_must_outlive(region={}, generic={})\",\n            region.repr(rcx.tcx()),\n-           param_ty.repr(rcx.tcx()));\n+           generic.repr(rcx.tcx()));\n \n     // To start, collect bounds from user:\n     let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n-                                   param_ty.to_ty(rcx.tcx()),\n+                                   generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n     // Add in the default bound of fn body that applies to all in\n@@ -1467,22 +1467,21 @@ fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     //     fn foo<'a, A>(x: &'a A) { x.bar() }\n     //\n     // The problem is that the type of `x` is `&'a A`. To be\n-    // well-formed, then, A must be lower-bounded by `'a`, but we\n+    // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in rcx.region_param_pairs.iter() {\n-        debug!(\"param_ty={} p={}\",\n-               param_ty.repr(rcx.tcx()),\n+    for &(ref r, ref p) in rcx.region_bound_pairs.iter() {\n+        debug!(\"generic={} p={}\",\n+               generic.repr(rcx.tcx()),\n                p.repr(rcx.tcx()));\n-        if param_ty == *p {\n+        if generic == p {\n             param_bounds.push(*r);\n         }\n     }\n \n-    // Inform region inference that this parameter type must be\n-    // properly bounded.\n-    infer::verify_param_bound(rcx.fcx.infcx(),\n-                              origin,\n-                              param_ty,\n-                              region,\n-                              param_bounds);\n+    // Inform region inference that this generic must be properly\n+    // bounded.\n+    rcx.fcx.infcx().verify_generic_bound(origin,\n+                                         generic.clone(),\n+                                         region,\n+                                         param_bounds);\n }"}, {"sha": "7ca21bdf5b83f7eaacac5c1114a9107cb9e25801", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -12,6 +12,7 @@\n \n pub use self::WfConstraint::*;\n \n+use middle::infer::GenericKind;\n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder};\n@@ -24,7 +25,7 @@ use util::ppaux::Repr;\n \n pub enum WfConstraint<'tcx> {\n     RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubParamConstraint(Option<Ty<'tcx>>, ty::Region, ty::ParamTy),\n+    RegionSubGenericConstraint(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n }\n \n struct Wf<'a, 'tcx: 'a> {\n@@ -121,8 +122,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::ty_projection(ref data) => {\n                 // `<T as TraitRef<..>>::Name`\n \n-                // FIXME(#20303) -- gain ability to require that ty_projection : in-scope region,\n-                // like a type parameter\n+                self.push_projection_constraint_from_top(data);\n \n                 // this seems like a minimal requirement:\n                 let trait_def = ty::lookup_trait_def(self.tcx, data.trait_ref.def_id);\n@@ -211,12 +211,21 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         self.push_param_constraint(region, opt_ty, param_ty);\n     }\n \n+    /// Pushes a constraint that `projection_ty` must outlive the top region on the stack.\n+    fn push_projection_constraint_from_top(&mut self,\n+                                           projection_ty: &ty::ProjectionTy<'tcx>) {\n+        let &(region, opt_ty) = self.stack.last().unwrap();\n+        self.out.push(RegionSubGenericConstraint(\n+            opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n+    }\n+\n     /// Pushes a constraint that `region <= param_ty`, due to `opt_ty`\n     fn push_param_constraint(&mut self,\n                              region: ty::Region,\n                              opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n-        self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n+        self.out.push(RegionSubGenericConstraint(\n+            opt_ty, region, GenericKind::Param(param_ty)));\n     }\n \n     fn accumulate_from_adt(&mut self,\n@@ -373,16 +382,16 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n }\n \n impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            RegionSubRegionConstraint(_, r_a, r_b) => {\n+            RegionSubRegionConstraint(_, ref r_a, ref r_b) => {\n                 format!(\"RegionSubRegionConstraint({}, {})\",\n                         r_a.repr(tcx),\n                         r_b.repr(tcx))\n             }\n \n-            RegionSubParamConstraint(_, r, p) => {\n-                format!(\"RegionSubParamConstraint({}, {})\",\n+            RegionSubGenericConstraint(_, ref r, ref p) => {\n+                format!(\"RegionSubGenericConstraint({}, {})\",\n                         r.repr(tcx),\n                         p.repr(tcx))\n             }"}, {"sha": "8afd86195ff53f91dcc84d5d515e08f3b411b82c", "filename": "src/test/compile-fail/associated-types-invalid-trait-ref-issue-18865.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we report an error if the trait ref in an qualified type\n+// uses invalid type arguments.\n+\n+#![feature(associated_types)]\n+\n+trait Foo<T> {\n+    type Bar;\n+    fn get_bar(&self) -> Self::Bar;\n+}\n+\n+fn f<T:Foo<int>>(t: &T) {\n+    let u: <T as Foo<uint>>::Bar = t.get_bar();\n+    //~^ ERROR the trait `Foo<uint>` is not implemented for the type `T`\n+}\n+\n+fn main() { }"}, {"sha": "764b79c4cc649b6f82a50803732100757f6b9e18", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when an impl is missing an associated type (and that we report\n+// a useful error, of course).\n+\n+#![feature(associated_types)]\n+\n+trait Trait {\n+    type Type;\n+}\n+\n+impl Trait for int {}  //~ ERROR missing: `Type`\n+\n+fn main() {}\n+"}, {"sha": "84664078d56296930bb5b15c0b0f459442ae3126", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait X {}\n+\n+trait Iter {\n+    type Item: X;\n+\n+    fn into_item(self) -> Self::Item;\n+    fn as_item(&self) -> &Self::Item;\n+}\n+\n+fn bad1<T: Iter>(v: T) -> Box<X+'static>\n+{\n+    let item = v.into_item();\n+    box item //~ ERROR associated type `<T as Iter>::Item` may not live long enough\n+}\n+\n+fn bad2<T: Iter>(v: T) -> Box<X+'static>\n+    where Box<T::Item> : X\n+{\n+    let item = box v.into_item();\n+    box item //~ ERROR associated type `<T as Iter>::Item` may not live long enough\n+}\n+\n+fn bad3<'a, T: Iter>(v: T) -> Box<X+'a>\n+{\n+    let item = v.into_item();\n+    box item //~ ERROR associated type `<T as Iter>::Item` may not live long enough\n+}\n+\n+fn bad4<'a, T: Iter>(v: T) -> Box<X+'a>\n+    where Box<T::Item> : X\n+{\n+    let item = box v.into_item();\n+    box item //~ ERROR associated type `<T as Iter>::Item` may not live long enough\n+}\n+\n+fn ok1<'a, T: Iter>(v: T) -> Box<X+'a>\n+    where T::Item : 'a\n+{\n+    let item = v.into_item();\n+    box item // OK, T::Item : 'a is declared\n+}\n+\n+fn ok2<'a, T: Iter>(v: &T, w: &'a T::Item) -> Box<X+'a>\n+    where T::Item : Clone\n+{\n+    let item = Clone::clone(w);\n+    box item // OK, T::Item : 'a is implied\n+}\n+\n+fn ok3<'a, T: Iter>(v: &'a T) -> Box<X+'a>\n+    where T::Item : Clone + 'a\n+{\n+    let item = Clone::clone(v.as_item());\n+    box item // OK, T::Item : 'a was declared\n+}\n+\n+fn meh1<'a, T: Iter>(v: &'a T) -> Box<X+'a>\n+    where T::Item : Clone\n+{\n+    // This case is kind of interesting. It's the same as `ok3` but\n+    // without the explicit declaration. In principle, it seems like\n+    // we ought to be able to infer that `T::Item : 'a` because we\n+    // invoked `v.as_self()` which yielded a value of type `&'a\n+    // T::Item`. But we're not that smart at present.\n+\n+    let item = Clone::clone(v.as_item());\n+    box item //~ ERROR associated type `<T as Iter>::Item` may not live\n+}\n+\n+fn main() {}\n+"}, {"sha": "3e91d090c3140ca1923a19daca39e2ea0945578c", "filename": "src/test/compile-fail/regions-close-param-into-object.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b4c8e0d347921673e61bf1770ba0acd4c7d824/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs?ref=88b4c8e0d347921673e61bf1770ba0acd4c7d824", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+trait X {}\n+\n+fn p1<T>(v: T) -> Box<X+'static>\n+    where T : X\n+{\n+    box v //~ ERROR parameter type `T` may not live long enough\n+}\n+\n+fn p2<T>(v: Box<T>) -> Box<X+'static>\n+    where Box<T> : X\n+{\n+    box v //~ ERROR parameter type `T` may not live long enough\n+}\n+\n+fn p3<'a,T>(v: T) -> Box<X+'a>\n+    where T : X\n+{\n+    box v //~ ERROR parameter type `T` may not live long enough\n+}\n+\n+fn p4<'a,T>(v: Box<T>) -> Box<X+'a>\n+    where Box<T> : X\n+{\n+    box v //~ ERROR parameter type `T` may not live long enough\n+}\n+\n+fn main() {}\n+"}]}