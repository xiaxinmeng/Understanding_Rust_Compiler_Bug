{"sha": "d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "node_id": "C_kwDOAAsO6NoAKGQxMjNmZmM2Yzc1NGIyNWNjNjhhNjdmZmFiMGI1Yzc3MDdlYWM2ZTU", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-02-28T10:00:36Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-02-28T10:24:00Z"}, "message": "Check `clone_or_copy_needed` in `unnecessary_filter_map::check`", "tree": {"sha": "780936189225e9619017c74964dda955ef3f5d86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780936189225e9619017c74964dda955ef3f5d86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "html_url": "https://github.com/rust-lang/rust/commit/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd32522c077d7ced0ce3386b00b9896680dbdb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd32522c077d7ced0ce3386b00b9896680dbdb2", "html_url": "https://github.com/rust-lang/rust/commit/cfd32522c077d7ced0ce3386b00b9896680dbdb2"}], "stats": {"total": 185, "additions": 95, "deletions": 90}, "files": [{"sha": "108e143f33737d631231061bf56b6ba53c83898d", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "patch": "@@ -1,4 +1,6 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n@@ -20,6 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n@@ -28,10 +31,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n+        let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n             \"map\"\n-        } else if !found_mapping && !mutates_arg {\n-            let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n+        } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n                 ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && in_ty == subst.type_at(0) => {\n                     \"filter\""}, {"sha": "7a39557ad5757971a1bdcfddc31697232184f29e", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 3, "deletions": 88, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "patch": "@@ -1,14 +1,12 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n-use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_hir::{def_id::DefId, Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n use rustc_span::{sym, Symbol};\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -100,89 +98,6 @@ pub fn check_for_loop_iter(\n     false\n }\n \n-/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n-/// `CloneOrCopyVisitor`.\n-fn clone_or_copy_needed<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'tcx>,\n-    body: &'tcx Expr<'tcx>,\n-) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n-    let mut visitor = CloneOrCopyVisitor {\n-        cx,\n-        binding_hir_ids: pat_bindings(pat),\n-        clone_or_copy_needed: false,\n-        addr_of_exprs: Vec::new(),\n-    };\n-    visitor.visit_expr(body);\n-    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n-}\n-\n-/// Returns a vector of all `HirId`s bound by the pattern.\n-fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n-    let mut collector = usage::ParamBindingIdCollector {\n-        binding_hir_ids: Vec::new(),\n-    };\n-    collector.visit_pat(pat);\n-    collector.binding_hir_ids\n-}\n-\n-/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n-/// operations performed on `binding_hir_ids` are:\n-/// * to take non-mutable references to them\n-/// * to use them as non-mutable `&self` in method calls\n-/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n-/// when `CloneOrCopyVisitor` is done visiting.\n-struct CloneOrCopyVisitor<'cx, 'tcx> {\n-    cx: &'cx LateContext<'tcx>,\n-    binding_hir_ids: Vec<HirId>,\n-    clone_or_copy_needed: bool,\n-    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        walk_expr(self, expr);\n-        if self.is_binding(expr) {\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.kind {\n-                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n-                        self.addr_of_exprs.push(parent);\n-                        return;\n-                    },\n-                    ExprKind::MethodCall(_, args, _) => {\n-                        if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n-                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n-                            let method_ty = self.cx.tcx.type_of(method_def_id);\n-                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n-                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n-                            then {\n-                                return;\n-                            }\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-            self.clone_or_copy_needed = true;\n-        }\n-    }\n-}\n-\n-impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n-    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n-        self.binding_hir_ids\n-            .iter()\n-            .any(|hir_id| path_to_local_id(expr, *hir_id))\n-    }\n-}\n-\n /// Returns true if the named method is `IntoIterator::into_iter`.\n pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n     cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)"}, {"sha": "3015531e8439327c1337e21e89acb6367fb437fa", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "patch": "@@ -1,10 +1,14 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, path_to_local_id, usage};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, Mutability, Pat};\n use rustc_lint::LateContext;\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n \n@@ -79,3 +83,86 @@ pub(super) fn get_hint_if_single_char_arg(\n         }\n     }\n }\n+\n+/// The core logic of `check_for_loop_iter` in `unnecessary_iter_cloned.rs`, this function wraps a\n+/// use of `CloneOrCopyVisitor`.\n+pub(super) fn clone_or_copy_needed<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}"}]}