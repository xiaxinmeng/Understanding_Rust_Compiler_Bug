{"sha": "12882a8392eb98e870628ffbab4e123b83466adf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODgyYTgzOTJlYjk4ZTg3MDYyOGZmYmFiNGUxMjNiODM0NjZhZGY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-13T22:28:34Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-20T12:34:44Z"}, "message": "Remove usage of global variable \"inlined_types\"", "tree": {"sha": "f6fa65269abda82cf2acd3cae5a0d70f82c1b469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6fa65269abda82cf2acd3cae5a0d70f82c1b469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12882a8392eb98e870628ffbab4e123b83466adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12882a8392eb98e870628ffbab4e123b83466adf", "html_url": "https://github.com/rust-lang/rust/commit/12882a8392eb98e870628ffbab4e123b83466adf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12882a8392eb98e870628ffbab4e123b83466adf/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b117d75461282617d13b66b0b64425fe0efb9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b117d75461282617d13b66b0b64425fe0efb9ff", "html_url": "https://github.com/rust-lang/rust/commit/1b117d75461282617d13b66b0b64425fe0efb9ff"}], "stats": {"total": 75, "additions": 50, "deletions": 25}, "files": [{"sha": "eb8a8956436d90b7b6508feefa214262433bac73", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/12882a8392eb98e870628ffbab4e123b83466adf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12882a8392eb98e870628ffbab4e123b83466adf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=12882a8392eb98e870628ffbab4e123b83466adf", "patch": "@@ -992,13 +992,11 @@ themePicker.onblur = handleThemeButtonsBlur;\n             writeln!(v, \"{}\", *implementor).unwrap();\n         }\n         v.push_str(\n-            r\"\n-            if (window.register_implementors) {\n-                window.register_implementors(implementors);\n-            } else {\n-                window.pending_implementors = implementors;\n-            }\n-        \",\n+            \"if (window.register_implementors) {\\\n+                 window.register_implementors(implementors);\\\n+             } else {\\\n+                 window.pending_implementors = implementors;\\\n+             }\",\n         );\n         v.push_str(\"})()\");\n         cx.shared.fs.write(&mydst, &v)?;\n@@ -2353,6 +2351,7 @@ fn render_implementor(\n     implementor: &Impl,\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<&str, (DefId, bool)>,\n+    aliases: &[String],\n ) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2375,6 +2374,7 @@ fn render_implementor(\n         Some(use_absolute),\n         false,\n         false,\n+        aliases,\n     );\n }\n \n@@ -2396,6 +2396,7 @@ fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item\n                 None,\n                 false,\n                 true,\n+                &[],\n             );\n             buffer.into_inner()\n         })\n@@ -2597,8 +2598,6 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n-    let mut synthetic_types = Vec::new();\n-\n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n@@ -2649,6 +2648,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     None,\n                     true,\n                     false,\n+                    &[],\n                 );\n             }\n             write_loading_content(w, \"\");\n@@ -2661,7 +2661,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n             \"<div class='item-list' id='implementors-list'>\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups);\n+            render_implementor(cx, implementor, w, &implementor_dups, &[]);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2673,9 +2673,13 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                 \"<div class='item-list' id='synthetic-implementors-list'>\",\n             );\n             for implementor in synthetic {\n-                synthetic_types\n-                    .extend(collect_paths_for_type(implementor.inner_impl().for_.clone()));\n-                render_implementor(cx, implementor, w, &implementor_dups);\n+                render_implementor(\n+                    cx,\n+                    implementor,\n+                    w,\n+                    &implementor_dups,\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n+                );\n             }\n             write_loading_content(w, \"</div>\");\n         }\n@@ -2700,17 +2704,12 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n             write_loading_content(w, \"</div>\");\n         }\n     }\n-    write!(\n-        w,\n-        r#\"<script type=\"text/javascript\">window.inlined_types=new Set({});</script>\"#,\n-        serde_json::to_string(&synthetic_types).unwrap(),\n-    );\n \n     write!(\n         w,\n-        r#\"<script type=\"text/javascript\" async\n-                         src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n-                 </script>\"#,\n+        \"<script type=\\\"text/javascript\\\" \\\n+                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n+         </script>\",\n         root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n@@ -3392,6 +3391,7 @@ fn render_assoc_items(\n                 None,\n                 false,\n                 true,\n+                &[],\n             );\n         }\n     }\n@@ -3602,6 +3602,9 @@ fn render_impl(\n     use_absolute: Option<bool>,\n     is_on_foreign_type: bool,\n     show_default_items: bool,\n+    // This argument is used to reference same type with different pathes to avoid duplication\n+    // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n+    aliases: &[String],\n ) {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n@@ -3614,8 +3617,13 @@ fn render_impl(\n             }\n             None => \"impl\".to_string(),\n         });\n+        let aliases = if aliases.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" aliases=\\\"{}\\\"\", aliases.join(\",\"))\n+        };\n         if let Some(use_absolute) = use_absolute {\n-            write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>\", id);\n+            write!(w, \"<h3 id='{}' class='impl'{}><code class='in-band'>\", id, aliases);\n             fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n@@ -3637,8 +3645,9 @@ fn render_impl(\n         } else {\n             write!(\n                 w,\n-                \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n+                \"<h3 id='{}' class='impl'{}><code class='in-band'>{}</code>\",\n                 id,\n+                aliases,\n                 i.inner_impl().print()\n             );\n         }"}, {"sha": "ec881d25dd2bf8650e9fcb04d43c70dbe0335987", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12882a8392eb98e870628ffbab4e123b83466adf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/12882a8392eb98e870628ffbab4e123b83466adf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=12882a8392eb98e870628ffbab4e123b83466adf", "patch": "@@ -1895,6 +1895,22 @@ function getSearchElement() {\n         var implementors = document.getElementById(\"implementors-list\");\n         var synthetic_implementors = document.getElementById(\"synthetic-implementors-list\");\n \n+        // This `inlined_types` variable is used to avoid having the same implementation showing\n+        // up twice. For example \"String\" in the \"Sync\" doc page.\n+        //\n+        // By the way, this is only used by and useful for traits implemented automatically (like\n+        // \"Send\" and \"Sync\").\n+        var inlined_types = new Set();\n+        onEachLazy(synthetic_implementors.getElementsByClassName(\"impl\"), function(el) {\n+            var aliases = el.getAttribute(\"aliases\");\n+            if (!aliases) {\n+                return;\n+            }\n+            aliases.split(\",\").forEach(function(alias) {\n+                inlined_types.add(alias);\n+            });\n+        });\n+\n         var libs = Object.getOwnPropertyNames(imp);\n         var llength = libs.length;\n         for (var i = 0; i < llength; ++i) {\n@@ -1911,10 +1927,10 @@ function getSearchElement() {\n                 if (struct.synthetic) {\n                     var stlength = struct.types.length;\n                     for (var k = 0; k < stlength; k++) {\n-                        if (window.inlined_types.has(struct.types[k])) {\n+                        if (inlined_types.has(struct.types[k])) {\n                             continue struct_loop;\n                         }\n-                        window.inlined_types.add(struct.types[k]);\n+                        inlined_types.add(struct.types[k]);\n                     }\n                 }\n "}]}