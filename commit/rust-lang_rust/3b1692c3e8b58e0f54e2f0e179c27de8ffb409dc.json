{"sha": "3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMTY5MmMzZThiNThlMGY1NGUyZjBlMTc5YzI3ZGU4ZmZiNDA5ZGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-09T12:53:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-09T12:53:49Z"}, "message": "Merge #8443 #8446\n\n8443: Rewrite `#[derive]` removal code to be based on AST r=jonas-schievink a=jonas-schievink\n\nWe now remove any `#[derive]` before and including the one we want to expand, in the `macro_arg` query.\r\n\r\nThe same infra will be needed by attribute macros (except we only remove the attribute we're expanding, not any preceding ones).\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/8434 (doesn't implement the cfg-expansion yet, because that's more difficult)\n\n8446: Undo path resolution hack for extern prelude r=jonas-schievink a=jonas-schievink\n\nReverts the change made in https://github.com/rust-analyzer/rust-analyzer/pull/7959\r\n\r\nWe don't populate the extern prelude for block DefMaps anymore,\r\nso this is unnecessary\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "138e167b7c95a312286601a1ba7e675aaab0281e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/138e167b7c95a312286601a1ba7e675aaab0281e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcE5dCRBK7hj4Ov3rIwAAdHIIAArHfVO8VwaR29MOMw0Fz3lA\nHbSPBvgtubD/0Z9lYVME3pOJ6QcTv5+LnZ2rKMK0cvgAl7DZffqyc0lH2r1q4KfR\nufI1U4FM8MDVMRf4A86EX/IXPILViybNI6Ba3by+vz/QKfrGAAbXuk4kWvPkNyQJ\nXWQX1muHrJyB/9EmKk7BHSjIxyZS46/L3/QfK7CLZXiLB7/51YId0xZFV5Qtrmif\nHT1ujU/bUNHNtuqgfW9ZO3Dj1ehSz4u8LcIynYag836Uvoe6ho0vBtv6ElQ+2Uih\nzQVNtAFsDnU/1+C09iFXc8GUjMyMZIc1PIxTGsT43jNUGUHBdHIOjnmxO3g3bCI=\n=cmao\n-----END PGP SIGNATURE-----\n", "payload": "tree 138e167b7c95a312286601a1ba7e675aaab0281e\nparent 972e1f4b8ca3118e358ba7bb91d4c0cfd4fc10ca\nparent d6187de4cd34a1288c7820c5477b81b1e9b692a9\nparent 4ea5f690bc2692699208999f46a85a9872cbfc73\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617972829 +0000\ncommitter GitHub <noreply@github.com> 1617972829 +0000\n\nMerge #8443 #8446\n\n8443: Rewrite `#[derive]` removal code to be based on AST r=jonas-schievink a=jonas-schievink\n\nWe now remove any `#[derive]` before and including the one we want to expand, in the `macro_arg` query.\r\n\r\nThe same infra will be needed by attribute macros (except we only remove the attribute we're expanding, not any preceding ones).\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/8434 (doesn't implement the cfg-expansion yet, because that's more difficult)\n\n8446: Undo path resolution hack for extern prelude r=jonas-schievink a=jonas-schievink\n\nReverts the change made in https://github.com/rust-analyzer/rust-analyzer/pull/7959\r\n\r\nWe don't populate the extern prelude for block DefMaps anymore,\r\nso this is unnecessary\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "html_url": "https://github.com/rust-lang/rust/commit/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "972e1f4b8ca3118e358ba7bb91d4c0cfd4fc10ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/972e1f4b8ca3118e358ba7bb91d4c0cfd4fc10ca", "html_url": "https://github.com/rust-lang/rust/commit/972e1f4b8ca3118e358ba7bb91d4c0cfd4fc10ca"}, {"sha": "d6187de4cd34a1288c7820c5477b81b1e9b692a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6187de4cd34a1288c7820c5477b81b1e9b692a9", "html_url": "https://github.com/rust-lang/rust/commit/d6187de4cd34a1288c7820c5477b81b1e9b692a9"}, {"sha": "4ea5f690bc2692699208999f46a85a9872cbfc73", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ea5f690bc2692699208999f46a85a9872cbfc73", "html_url": "https://github.com/rust-lang/rust/commit/4ea5f690bc2692699208999f46a85a9872cbfc73"}], "stats": {"total": 292, "additions": 149, "deletions": 143}, "files": [{"sha": "dd99c8d15a890fa2bbae41d8a70313ab9167e3c1", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -9,7 +9,7 @@ use std::{\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n+use hir_expand::{hygiene::Hygiene, name::AsName, AstId, AttrId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n use mbe::ast_to_token_tree;\n@@ -98,13 +98,16 @@ impl RawAttrs {\n     pub(crate) fn new(owner: &dyn ast::AttrsOwner, hygiene: &Hygiene) -> Self {\n         let entries = collect_attrs(owner)\n             .enumerate()\n-            .flat_map(|(i, attr)| match attr {\n-                Either::Left(attr) => Attr::from_src(attr, hygiene, i as u32),\n-                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n-                    index: i as u32,\n-                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n-                }),\n+            .flat_map(|(i, attr)| {\n+                let index = AttrId(i as u32);\n+                match attr {\n+                    Either::Left(attr) => Attr::from_src(attr, hygiene, index),\n+                    Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                        id: index,\n+                        input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                        path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n+                    }),\n+                }\n             })\n             .collect::<Arc<_>>();\n \n@@ -161,7 +164,7 @@ impl RawAttrs {\n                 let cfg = parts.next().unwrap();\n                 let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n                 let cfg = CfgExpr::parse(&cfg);\n-                let index = attr.index;\n+                let index = attr.id;\n                 let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n                     let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n                     let attr = ast::Attr::parse(&format!(\"#[{}]\", tree)).ok()?;\n@@ -468,7 +471,7 @@ impl AttrsWithOwner {\n     ) -> Option<(Documentation, DocsRangeMap)> {\n         // FIXME: code duplication in `docs` above\n         let docs = self.by_key(\"doc\").attrs().flat_map(|attr| match attr.input.as_ref()? {\n-            AttrInput::Literal(s) => Some((s, attr.index)),\n+            AttrInput::Literal(s) => Some((s, attr.id)),\n             AttrInput::TokenTree(_) => None,\n         });\n         let indent = docs\n@@ -560,8 +563,8 @@ impl AttrSourceMap {\n     /// the attribute represented by `Attr`.\n     pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {\n         self.attrs\n-            .get(attr.index as usize)\n-            .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {}\", attr.index))\n+            .get(attr.id.0 as usize)\n+            .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {:?}\", attr.id))\n             .as_ref()\n     }\n }\n@@ -572,7 +575,7 @@ pub struct DocsRangeMap {\n     // (docstring-line-range, attr_index, attr-string-range)\n     // a mapping from the text range of a line of the [`Documentation`] to the attribute index and\n     // the original (untrimmed) syntax doc line\n-    mapping: Vec<(TextRange, u32, TextRange)>,\n+    mapping: Vec<(TextRange, AttrId, TextRange)>,\n }\n \n impl DocsRangeMap {\n@@ -585,7 +588,7 @@ impl DocsRangeMap {\n \n         let relative_range = range - line_docs_range.start();\n \n-        let &InFile { file_id, value: ref source } = &self.source[idx as usize];\n+        let &InFile { file_id, value: ref source } = &self.source[idx.0 as usize];\n         match source {\n             Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n             // as well as for whats done in syntax highlight doc injection\n@@ -606,7 +609,7 @@ impl DocsRangeMap {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n-    index: u32,\n+    pub(crate) id: AttrId,\n     pub(crate) path: Interned<ModPath>,\n     pub(crate) input: Option<AttrInput>,\n }\n@@ -620,7 +623,7 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    fn from_src(ast: ast::Attr, hygiene: &Hygiene, index: u32) -> Option<Attr> {\n+    fn from_src(ast: ast::Attr, hygiene: &Hygiene, id: AttrId) -> Option<Attr> {\n         let path = Interned::new(ModPath::from_src(ast.path()?, hygiene)?);\n         let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n             let value = match lit.kind() {\n@@ -633,7 +636,7 @@ impl Attr {\n         } else {\n             None\n         };\n-        Some(Attr { index, path, input })\n+        Some(Attr { id, path, input })\n     }\n \n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths"}, {"sha": "d69116d51523a11a5bcb3f61806b3b11b0b561cb", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -62,7 +62,7 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n-    AstId, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    AstId, AttrId, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use la_arena::Idx;\n use nameres::DefMap;\n@@ -699,6 +699,7 @@ fn macro_call_as_call_id(\n \n fn derive_macro_as_call_id(\n     item_attr: &AstIdWithPath<ast::Item>,\n+    derive_attr: AttrId,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n@@ -712,6 +713,7 @@ fn derive_macro_as_call_id(\n             MacroCallKind::Derive {\n                 ast_id: item_attr.ast_id,\n                 derive_name: last_segment.to_string(),\n+                derive_attr,\n             },\n         )\n         .into();"}, {"sha": "9e181751cbcfc91dd1ffd5b1e928f8202dc30ce8", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -617,7 +617,7 @@ mod diagnostics {\n                             let node = ast_id.to_node(db.upcast());\n                             (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)), None)\n                         }\n-                        MacroCallKind::Derive { ast_id, derive_name } => {\n+                        MacroCallKind::Derive { ast_id, derive_name, .. } => {\n                             let node = ast_id.to_node(db.upcast());\n \n                             // Compute the precise location of the macro name's token in the derive"}, {"sha": "d13d7be278b5edc12fd3ae07785fd276dfda04d7", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -13,7 +13,7 @@ use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    AttrId, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -216,7 +216,7 @@ struct MacroDirective {\n #[derive(Clone, Debug, Eq, PartialEq)]\n enum MacroDirectiveKind {\n     FnLike { ast_id: AstIdWithPath<ast::MacroCall> },\n-    Derive { ast_id: AstIdWithPath<ast::Item> },\n+    Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n }\n \n struct DefData<'a> {\n@@ -831,10 +831,14 @@ impl DefCollector<'_> {\n                         Err(UnresolvedMacro) | Ok(Err(_)) => {}\n                     }\n                 }\n-                MacroDirectiveKind::Derive { ast_id } => {\n-                    match derive_macro_as_call_id(ast_id, self.db, self.def_map.krate, |path| {\n-                        self.resolve_derive_macro(directive.module_id, &path)\n-                    }) {\n+                MacroDirectiveKind::Derive { ast_id, derive_attr } => {\n+                    match derive_macro_as_call_id(\n+                        ast_id,\n+                        *derive_attr,\n+                        self.db,\n+                        self.def_map.krate,\n+                        |path| self.resolve_derive_macro(directive.module_id, &path),\n+                    ) {\n                         Ok(call_id) => {\n                             resolved.push((directive.module_id, call_id, directive.depth));\n                             res = ReachedFixedPoint::No;\n@@ -1368,7 +1372,7 @@ impl ModCollector<'_, '_> {\n                         self.def_collector.unexpanded_macros.push(MacroDirective {\n                             module_id: self.module_id,\n                             depth: self.macro_depth + 1,\n-                            kind: MacroDirectiveKind::Derive { ast_id },\n+                            kind: MacroDirectiveKind::Derive { ast_id, derive_attr: derive.id },\n                         });\n                     }\n                 }"}, {"sha": "a9cf651d2a07d4b9cf75bf1af99d6e64b281b7f7", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -384,15 +384,10 @@ impl DefMap {\n                 }\n             }\n         };\n-        // Give precedence to names in outer `DefMap`s over the extern prelude; only check prelude\n-        // from the crate DefMap.\n-        let from_extern_prelude = match self.block {\n-            Some(_) => PerNs::none(),\n-            None => self\n-                .extern_prelude\n-                .get(name)\n-                .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public)),\n-        };\n+        let from_extern_prelude = self\n+            .extern_prelude\n+            .get(name)\n+            .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public));\n \n         let from_prelude = self.resolve_in_prelude(db, name);\n "}, {"sha": "537c0302866a2ab8bb8200f319e537338442da81", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -269,7 +269,7 @@ mod tests {\n     use expect_test::{expect, Expect};\n     use name::AsName;\n \n-    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n+    use crate::{test_db::TestDB, AstId, AttrId, MacroCallId, MacroCallKind, MacroCallLoc};\n \n     use super::*;\n \n@@ -317,7 +317,11 @@ $0\n                 local_inner: false,\n             },\n             krate: CrateId(0),\n-            kind: MacroCallKind::Derive { ast_id, derive_name: name.to_string() },\n+            kind: MacroCallKind::Derive {\n+                ast_id,\n+                derive_name: name.to_string(),\n+                derive_attr: AttrId(0),\n+            },\n         };\n \n         let id: MacroCallId = db.intern_macro(loc).into();"}, {"sha": "95dc127440c47bb071c66f23ac827a5ed16f863b", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -14,9 +14,9 @@ use syntax::{\n };\n \n use crate::{\n-    ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n-    EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc,\n-    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    ast_id_map::AstIdMap, hygiene::HygieneFrame, input::process_macro_input, BuiltinDeriveExpander,\n+    BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId,\n+    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -191,6 +191,7 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n+    let arg = process_macro_input(db, arg, id);\n     Some(arg.green())\n }\n "}, {"sha": "d1f22aba4fc9fe08fe5afc578347911f64c65aa5", "filename": "crates/hir_expand/src/input.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Finput.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -0,0 +1,95 @@\n+//! Macro input conditioning.\n+\n+use syntax::{\n+    ast::{self, AttrsOwner},\n+    AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    db::AstDatabase,\n+    name::{name, AsName},\n+    AttrId, LazyMacroId, MacroCallKind, MacroCallLoc,\n+};\n+\n+pub(crate) fn process_macro_input(\n+    db: &dyn AstDatabase,\n+    node: SyntaxNode,\n+    id: LazyMacroId,\n+) -> SyntaxNode {\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+\n+    match loc.kind {\n+        MacroCallKind::FnLike { .. } => node,\n+        MacroCallKind::Derive { derive_attr, .. } => {\n+            let item = match ast::Item::cast(node.clone()) {\n+                Some(item) => item,\n+                None => return node,\n+            };\n+\n+            remove_derives_up_to(item, derive_attr).syntax().clone()\n+        }\n+    }\n+}\n+\n+/// Removes `#[derive]` attributes from `item`, up to `attr`.\n+fn remove_derives_up_to(item: ast::Item, attr: AttrId) -> ast::Item {\n+    let item = item.clone_for_update();\n+    let idx = attr.0 as usize;\n+    for attr in item.attrs().take(idx + 1) {\n+        if let Some(name) =\n+            attr.path().and_then(|path| path.as_single_segment()).and_then(|seg| seg.name_ref())\n+        {\n+            if name.as_name() == name![derive] {\n+                attr.syntax().detach();\n+            }\n+        }\n+    }\n+    item\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::fixture::WithFixture;\n+    use base_db::SourceDatabase;\n+    use expect_test::{expect, Expect};\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n+\n+    fn test_remove_derives_up_to(attr: AttrId, ra_fixture: &str, expect: Expect) {\n+        let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+        let parsed = db.parse(file_id);\n+\n+        let mut items: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(ast::Item::cast).collect();\n+        assert_eq!(items.len(), 1);\n+\n+        let item = remove_derives_up_to(items.pop().unwrap(), attr);\n+        expect.assert_eq(&item.to_string());\n+    }\n+\n+    #[test]\n+    fn remove_derive() {\n+        test_remove_derives_up_to(\n+            AttrId(2),\n+            r#\"\n+#[allow(unused)]\n+#[derive(Copy)]\n+#[derive(Hello)]\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\n+        \"#,\n+            expect![[r#\"\n+#[allow(unused)]\n+\n+\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\"#]],\n+        );\n+    }\n+}"}, {"sha": "7349fdfe4f073e58e4273e04a9594dabc34af252", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -14,6 +14,7 @@ pub mod builtin_macro;\n pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n+mod input;\n \n use either::Either;\n pub use mbe::{ExpandError, ExpandResult};\n@@ -291,9 +292,12 @@ pub struct MacroCallLoc {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n     FnLike { ast_id: AstId<ast::MacroCall> },\n-    Derive { ast_id: AstId<ast::Item>, derive_name: String },\n+    Derive { ast_id: AstId<ast::Item>, derive_name: String, derive_attr: AttrId },\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AttrId(pub u32);\n+\n impl MacroCallKind {\n     fn file_id(&self) -> HirFileId {\n         match self {"}, {"sha": "d5643393ae2fc564e20633561001e628ea22e777", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=3b1692c3e8b58e0f54e2f0e179c27de8ffb409dc", "patch": "@@ -2,7 +2,6 @@\n \n use crate::db::AstDatabase;\n use base_db::{CrateId, ProcMacroId};\n-use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -44,9 +43,6 @@ impl ProcMacroExpander {\n                     .clone()\n                     .ok_or_else(|| err!(\"No derive macro found.\"))?;\n \n-                let tt = remove_derive_attrs(tt)\n-                    .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n-\n                 // Proc macros have access to the environment variables of the invoking crate.\n                 let env = &krate_graph[calling_crate].env;\n \n@@ -56,101 +52,3 @@ impl ProcMacroExpander {\n         }\n     }\n }\n-\n-fn eat_punct(cursor: &mut Cursor, c: char) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = cursor.token_tree() {\n-        if punct.char == c {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_subtree(cursor: &mut Cursor, kind: tt::DelimiterKind) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) = cursor.token_tree() {\n-        if Some(kind) == subtree.delimiter_kind() {\n-            *cursor = cursor.bump_subtree();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_ident(cursor: &mut Cursor, t: &str) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) = cursor.token_tree() {\n-        if t == ident.text.as_str() {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n-    let buffer = TokenBuffer::from_tokens(&tt.token_trees);\n-    let mut p = buffer.begin();\n-    let mut result = tt::Subtree::default();\n-\n-    while !p.eof() {\n-        let curr = p;\n-\n-        if eat_punct(&mut p, '#') {\n-            eat_punct(&mut p, '!');\n-            let parent = p;\n-            if eat_subtree(&mut p, tt::DelimiterKind::Bracket) {\n-                if eat_ident(&mut p, \"derive\") {\n-                    p = parent.bump();\n-                    continue;\n-                }\n-            }\n-        }\n-\n-        result.token_trees.push(curr.token_tree()?.cloned());\n-        p = curr.bump();\n-    }\n-\n-    Some(result)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn test_remove_derive_attrs() {\n-        let tt = mbe::parse_to_token_tree(\n-            r#\"\n-    #[allow(unused)]\n-    #[derive(Copy)]\n-    #[derive(Hello)]\n-    struct A {\n-        bar: u32\n-    }\n-\"#,\n-        )\n-        .unwrap()\n-        .0;\n-        let result = format!(\"{:#?}\", remove_derive_attrs(&tt).unwrap());\n-\n-        assert_eq_text!(\n-            r#\"\n-SUBTREE $\n-  PUNCH   # [alone] 0\n-  SUBTREE [] 1\n-    IDENT   allow 2\n-    SUBTREE () 3\n-      IDENT   unused 4\n-  IDENT   struct 15\n-  IDENT   A 16\n-  SUBTREE {} 17\n-    IDENT   bar 18\n-    PUNCH   : [alone] 19\n-    IDENT   u32 20\n-\"#\n-            .trim(),\n-            &result\n-        );\n-    }\n-}"}]}