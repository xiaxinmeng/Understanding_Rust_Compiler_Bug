{"sha": "57e521e0e5d3dc7deb389697e516aaae12e37613", "node_id": "C_kwDOAAsO6NoAKDU3ZTUyMWUwZTVkM2RjN2RlYjM4OTY5N2U1MTZhYWFlMTJlMzc2MTM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-22T06:15:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-22T06:15:44Z"}, "message": "Rollup merge of #100694 - finalchild:ast-passes-diag, r=TaKO8Ki\n\nMigrate rustc_ast_passes diagnostics to `SessionDiagnostic` and translatable messages (first part)\n\nDoing a full migration of the `rustc_ast_passes` crate.\nMaking a draft here since there's not yet a tracking issue for the migrations going on.\n\n`@rustbot` label +A-translation", "tree": {"sha": "2a2135658c0122766f31700ab2aeedf9c2574bf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2135658c0122766f31700ab2aeedf9c2574bf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e521e0e5d3dc7deb389697e516aaae12e37613", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAx8QCRBK7hj4Ov3rIwAAQfQIAHh5SVW/6VTKBPYZZ3bkNALp\nGRN+QyuUCFF0+XTIzQnT96p6AODuAiSVlPk1HXRzSbFo+aZfvobElCeZE/NGg9ln\nE+FSK3J9mjqbiDO06b7FxcRukKzxygYs9KguN15/9cn1uVOVjl4loBvhKeVWVWYm\ne9WoUxmGPBdnHTrb/Tk+DkvP8A8S914N4Xg0xVYKyec7IX8mq+73H09hjib3KDEJ\nX/b8Yuu0ZTz64UtDDUXHIjTTYOBgP9CBL8NzTrrxu2YRpqYjl9ZNH0ERqvq/TVaQ\nU5Sh/3MJ2ztAW3vGtjqJUrhc8KKWmTocAqdC6vqRTBSzVgdwZ3TIzdEUqqATA5Y=\n=idFN\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a2135658c0122766f31700ab2aeedf9c2574bf6\nparent 3842117ef22287decfec9113a4b0180250cfbe79\nparent 09d495cc15e3ef3e80fc36f0c217c08c5bfb34de\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661148944 +0530\ncommitter GitHub <noreply@github.com> 1661148944 +0530\n\nRollup merge of #100694 - finalchild:ast-passes-diag, r=TaKO8Ki\n\nMigrate rustc_ast_passes diagnostics to `SessionDiagnostic` and translatable messages (first part)\n\nDoing a full migration of the `rustc_ast_passes` crate.\nMaking a draft here since there's not yet a tracking issue for the migrations going on.\n\n`@rustbot` label +A-translation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e521e0e5d3dc7deb389697e516aaae12e37613", "html_url": "https://github.com/rust-lang/rust/commit/57e521e0e5d3dc7deb389697e516aaae12e37613", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e521e0e5d3dc7deb389697e516aaae12e37613/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3842117ef22287decfec9113a4b0180250cfbe79", "url": "https://api.github.com/repos/rust-lang/rust/commits/3842117ef22287decfec9113a4b0180250cfbe79", "html_url": "https://github.com/rust-lang/rust/commit/3842117ef22287decfec9113a4b0180250cfbe79"}, {"sha": "09d495cc15e3ef3e80fc36f0c217c08c5bfb34de", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d495cc15e3ef3e80fc36f0c217c08c5bfb34de", "html_url": "https://github.com/rust-lang/rust/commit/09d495cc15e3ef3e80fc36f0c217c08c5bfb34de"}], "stats": {"total": 693, "additions": 490, "deletions": 203}, "files": [{"sha": "cb245ce0ff828ef01c6b0cea39b7beec89a5fc85", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -3595,6 +3595,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n+ \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "37eff9207c128688b02768b9bddfac6c9b360719", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -11,6 +11,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "b337e5328c5df6af4c75ae61acfd3739ca616360", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 80, "deletions": 168, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::{error_code, fluent, pluralize, struct_span_err, Applicability};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -27,6 +27,8 @@ use rustc_target::spec::abi;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n \n+use crate::errors::*;\n+\n const MORE_EXTERN: &str =\n     \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n \n@@ -117,23 +119,7 @@ impl<'a> AstValidator<'a> {\n \n     /// Emits an error banning the `let` expression provided in the given location.\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n-        let err = \"`let` expressions are not supported here\";\n-        let mut diag = self.session.struct_span_err(expr.span, err);\n-        diag.note(\"only supported directly in conditions of `if` and `while` expressions\");\n-        match forbidden_let_reason {\n-            ForbiddenLetReason::GenericForbidden => {}\n-            ForbiddenLetReason::NotSupportedOr(span) => {\n-                diag.span_note(span, \"`||` operators are not supported in let chain expressions\");\n-            }\n-            ForbiddenLetReason::NotSupportedParentheses(span) => {\n-                diag.span_note(\n-                    span,\n-                    \"`let`s wrapped in parentheses are not supported in a context with let \\\n-                    chains\",\n-                );\n-            }\n-        }\n-        diag.emit();\n+        self.session.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n     }\n \n     fn check_gat_where(\n@@ -163,7 +149,7 @@ impl<'a> AstValidator<'a> {\n                 DEPRECATED_WHERE_CLAUSE_LOCATION,\n                 id,\n                 where_clauses.0.1,\n-                \"where clause not allowed here\",\n+                fluent::ast_passes::deprecated_where_clause_location,\n                 BuiltinLintDiagnostics::DeprecatedWhereclauseLocation(\n                     where_clauses.1.1.shrink_to_hi(),\n                     suggestion,\n@@ -193,10 +179,7 @@ impl<'a> AstValidator<'a> {\n             AssocConstraintKind::Equality { .. } => {}\n             AssocConstraintKind::Bound { .. } => {\n                 if self.is_assoc_ty_bound_banned {\n-                    self.err_handler().span_err(\n-                        constraint.span,\n-                        \"associated type bounds are not allowed within structs, enums, or unions\",\n-                    );\n+                    self.session.emit_err(ForbiddenAssocConstraint { span: constraint.span });\n                 }\n             }\n         }\n@@ -268,31 +251,26 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n+            self.session.emit_err(KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.err_handler()\n-                .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n+            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        let mut err =\n-            struct_span_err!(self.session, vis.span, E0449, \"unnecessary visibility qualifier\");\n-        if vis.kind.is_pub() {\n-            err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n-        }\n-        if let Some(note) = note {\n-            err.note(note);\n-        }\n-        err.emit();\n+        self.session.emit_err(InvalidVisibility {\n+            span: vis.span,\n+            implied: if vis.kind.is_pub() { Some(vis.span) } else { None },\n+            note,\n+        });\n     }\n \n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n@@ -309,29 +287,13 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_async(&self, fn_span: Span, asyncness: Async) {\n         if let Async::Yes { span, .. } = asyncness {\n-            struct_span_err!(\n-                self.session,\n-                fn_span,\n-                E0706,\n-                \"functions in traits cannot be declared `async`\"\n-            )\n-            .span_label(span, \"`async` because of this\")\n-            .note(\"`async` trait functions are not currently supported\")\n-            .note(\"consider using the `async-trait` crate: https://crates.io/crates/async-trait\")\n-            .emit();\n+            self.session.emit_err(TraitFnAsync { fn_span, span });\n         }\n     }\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            struct_span_err!(\n-                self.session,\n-                span,\n-                E0379,\n-                \"functions in traits cannot be declared const\"\n-            )\n-            .span_label(span, \"functions in traits cannot be const\")\n-            .emit();\n+            self.session.emit_err(TraitFnConst { span });\n         }\n     }\n \n@@ -344,19 +306,15 @@ impl<'a> AstValidator<'a> {\n                 GenericParamKind::Lifetime { .. } => {\n                     if !param.bounds.is_empty() {\n                         let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.err_handler()\n-                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n+                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n                     }\n                     None\n                 }\n                 _ => Some(param.ident.span),\n             })\n             .collect();\n         if !non_lt_param_spans.is_empty() {\n-            self.err_handler().span_err(\n-                non_lt_param_spans,\n-                \"only lifetime parameters can be used in this context\",\n-            );\n+            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n         }\n     }\n \n@@ -373,30 +331,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.err_handler().span_fatal(\n-                span,\n-                &format!(\"function can not have more than {} arguments\", max_num_args),\n-            );\n+            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.err_handler().span_err(\n-                        *span,\n-                        \"C-variadic function must be declared with at least one named argument\",\n-                    );\n+                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.err_handler().span_err(\n-                            *span,\n-                            \"`...` must be the last argument of a C-variadic function\",\n-                        );\n+                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -423,82 +372,38 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.err_handler()\n-                        .struct_span_err(\n-                            attr.span,\n-                            \"documentation comments cannot be applied to function parameters\",\n-                        )\n-                        .span_label(attr.span, \"doc comments are not allowed here\")\n-                        .emit();\n+                    self.session.emit_err(FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.err_handler().span_err(\n-                        attr.span,\n-                        \"allow, cfg, cfg_attr, deny, expect, \\\n-                forbid, and warn are the only allowed built-in attributes in function parameters\",\n-                    );\n+                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        param.span,\n-                        \"`self` parameter is only allowed in associated functions\",\n-                    )\n-                    .span_label(param.span, \"not semantically valid as function parameter\")\n-                    .note(\"associated functions are those in `impl` or `trait` definitions\")\n-                    .emit();\n+                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.err_handler()\n-                .struct_span_err(span, \"`default` is only allowed on items in trait impls\")\n-                .span_label(def_span, \"`default` because of this\")\n-                .emit();\n+            self.session.emit_err(ForbiddenDefault { span, def_span });\n         }\n     }\n \n-    fn error_item_without_body(&self, sp: Span, ctx: &str, msg: &str, sugg: &str) {\n-        self.error_item_without_body_with_help(sp, ctx, msg, sugg, |_| ());\n-    }\n-\n-    fn error_item_without_body_with_help(\n-        &self,\n-        sp: Span,\n-        ctx: &str,\n-        msg: &str,\n-        sugg: &str,\n-        help: impl FnOnce(&mut Diagnostic),\n-    ) {\n+    /// If `sp` ends with a semicolon, returns it as a `Span`\n+    /// Otherwise, returns `sp.shrink_to_hi()`\n+    fn ending_semi_or_hi(&self, sp: Span) -> Span {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n-        let replace_span = if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n+\n+        if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n             end\n         } else {\n             sp.shrink_to_hi()\n-        };\n-        let mut err = self.err_handler().struct_span_err(sp, msg);\n-        err.span_suggestion(\n-            replace_span,\n-            &format!(\"provide a definition for the {}\", ctx),\n-            sugg,\n-            Applicability::HasPlaceholders,\n-        );\n-        help(&mut err);\n-        err.emit();\n-    }\n-\n-    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n-        if body.is_none() {\n-            let msg = format!(\"associated {} in `impl` without body\", ctx);\n-            self.error_item_without_body(sp, ctx, &msg, sugg);\n         }\n     }\n \n@@ -1168,7 +1073,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual impl items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n@@ -1191,37 +1096,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_defaultness(item.span, defaultness);\n \n                 if body.is_none() {\n-                    let msg = \"free function without a body\";\n-                    let ext = sig.header.ext;\n-\n-                    let f = |e: &mut Diagnostic| {\n-                        if let Extern::Implicit(start_span) | Extern::Explicit(_, start_span) = &ext\n-                        {\n-                            let start_suggestion = if let Extern::Explicit(abi, _) = ext {\n-                                format!(\"extern \\\"{}\\\" {{\", abi.symbol_unescaped)\n-                            } else {\n-                                \"extern {\".to_owned()\n-                            };\n-\n-                            let end_suggestion = \" }\".to_owned();\n-                            let end_span = item.span.shrink_to_hi();\n-\n-                            e\n-                            .multipart_suggestion(\n-                                \"if you meant to declare an externally defined function, use an `extern` block\",\n-                                vec![(*start_span, start_suggestion), (end_span, end_suggestion)],\n-                                Applicability::MaybeIncorrect,\n-                             );\n-                        }\n-                    };\n-\n-                    self.error_item_without_body_with_help(\n-                        item.span,\n-                        \"function\",\n-                        msg,\n-                        \" { <body> }\",\n-                        f,\n-                    );\n+                    self.session.emit_err(FnWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                        extern_block_suggestion: match sig.header.ext {\n+                            Extern::None => None,\n+                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: None,\n+                            }),\n+                            Extern::Explicit(abi, start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: Some(abi.symbol_unescaped),\n+                            }),\n+                        },\n+                    });\n                 }\n \n                 self.visit_vis(&item.vis);\n@@ -1236,7 +1127,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual foreign items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n@@ -1327,12 +1218,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);\n-                let msg = \"free constant item without body\";\n-                self.error_item_without_body(item.span, \"constant\", msg, \" = <expr>;\");\n+                self.session.emit_err(ConstWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::Static(.., None) => {\n-                let msg = \"free static item without body\";\n-                self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n+                self.session.emit_err(StaticWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::TyAlias(box TyAlias {\n                 defaultness,\n@@ -1343,8 +1238,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }) => {\n                 self.check_defaultness(item.span, defaultness);\n                 if ty.is_none() {\n-                    let msg = \"free type alias without body\";\n-                    self.error_item_without_body(item.span, \"type\", msg, \" = <type>;\");\n+                    self.session.emit_err(TyAliasWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                    });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n@@ -1648,10 +1545,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if ctxt == AssocCtxt::Impl {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n-                    self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocConstWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n-                    self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocFnWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::TyAlias(box TyAlias {\n                     generics,\n@@ -1661,7 +1568,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ty,\n                     ..\n                 }) => {\n-                    self.check_impl_item_provided(item.span, ty, \"type\", \" = <type>;\");\n+                    if ty.is_none() {\n+                        self.session.emit_err(AssocTypeWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                     self.check_type_no_bounds(bounds, \"`impl`s\");\n                     if ty.is_some() {\n                         self.check_gat_where(\n@@ -1876,7 +1788,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n \n /// Used to forbid `let` expressions in certain syntactic locations.\n #[derive(Clone, Copy)]\n-enum ForbiddenLetReason {\n+pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator"}, {"sha": "16ba14e9092168fda7ddcc2d768f1d9dbb176dff", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -0,0 +1,248 @@\n+//! Errors emitted by ast_passes.\n+\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::ast_validation::ForbiddenLetReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_let)]\n+#[note]\n+pub struct ForbiddenLet {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub(crate) reason: ForbiddenLetReason,\n+}\n+\n+impl AddSubdiagnostic for ForbiddenLetReason {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::GenericForbidden => {}\n+            Self::NotSupportedOr(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_or);\n+            }\n+            Self::NotSupportedParentheses(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_parentheses);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_assoc_constraint)]\n+pub struct ForbiddenAssocConstraint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::keyword_lifetime)]\n+pub struct KeywordLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_label)]\n+pub struct InvalidLabel {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n+pub struct InvalidVisibility {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes::implied)]\n+    pub implied: Option<Span>,\n+    #[subdiagnostic]\n+    pub note: Option<InvalidVisibilityNote>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidVisibilityNote {\n+    #[note(ast_passes::individual_impl_items)]\n+    IndividualImplItems,\n+    #[note(ast_passes::individual_foreign_items)]\n+    IndividualForeignItems,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_async, code = \"E0706\")]\n+#[note]\n+#[note(ast_passes::note2)]\n+pub struct TraitFnAsync {\n+    #[primary_span]\n+    pub fn_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n+pub struct TraitFnConst {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_lifetime_bound)]\n+pub struct ForbiddenLifetimeBound {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_non_lifetime_param)]\n+pub struct ForbiddenNonLifetimeParam {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_too_many)]\n+pub struct FnParamTooMany {\n+    #[primary_span]\n+    pub span: Span,\n+    pub max_num_args: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_only)]\n+pub struct FnParamCVarArgsOnly {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_not_last)]\n+pub struct FnParamCVarArgsNotLast {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_doc_comment)]\n+pub struct FnParamDocComment {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_attr)]\n+pub struct FnParamForbiddenAttr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_self)]\n+#[note]\n+pub struct FnParamForbiddenSelf {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_default)]\n+pub struct ForbiddenDefault {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub def_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_const_without_body)]\n+pub struct AssocConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_fn_without_body)]\n+pub struct AssocFnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_type_without_body)]\n+pub struct AssocTypeWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::const_without_body)]\n+pub struct ConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::static_without_body)]\n+pub struct StaticWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::ty_alias_without_body)]\n+pub struct TyAliasWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_without_body)]\n+pub struct FnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+    #[subdiagnostic]\n+    pub extern_block_suggestion: Option<ExternBlockSuggestion>,\n+}\n+\n+pub struct ExternBlockSuggestion {\n+    pub start_span: Span,\n+    pub end_span: Span,\n+    pub abi: Option<Symbol>,\n+}\n+\n+impl AddSubdiagnostic for ExternBlockSuggestion {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        let start_suggestion = if let Some(abi) = self.abi {\n+            format!(\"extern \\\"{}\\\" {{\", abi)\n+        } else {\n+            \"extern {\".to_owned()\n+        };\n+        let end_suggestion = \" }\".to_owned();\n+\n+        diag.multipart_suggestion(\n+            fluent::ast_passes::extern_block_suggestion,\n+            vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "6a8262989850cb23d6417bba225117c062d45547", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -12,6 +12,7 @@\n #![recursion_limit = \"256\"]\n \n pub mod ast_validation;\n+mod errors;\n pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;"}, {"sha": "fd517c1e1213682b6227395cc3e80b1d484a9a43", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -1176,7 +1176,7 @@ fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>)\n \n         cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n             span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n-            msg: msg.clone(),\n+            msg: msg.into(),\n             node_id: ast::CRATE_NODE_ID,\n             lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n             diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {"}, {"sha": "db91a886c725e4ab9a0ebf0c52dd2df426fe28b5", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -0,0 +1,93 @@\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n+\n+ast_passes_forbidden_assoc_constraint =\n+    associated type bounds are not allowed within structs, enums, or unions\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_invalid_visibility =\n+    unnecessary visibility qualifier\n+    .implied = `pub` not permitted here because it's implied\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n+\n+ast_passes_trait_fn_async =\n+    functions in traits cannot be declared `async`\n+    .label = `async` because of this\n+    .note = `async` trait functions are not currently supported\n+    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n+\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n+\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n+\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n+\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n+\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n+\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n+\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n+\n+ast_passes_assoc_const_without_body =\n+    associated constant in `impl` without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_assoc_fn_without_body =\n+    associated function in `impl` without body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_assoc_type_without_body =\n+    associated type in `impl` without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_const_without_body =\n+    free constant item without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n+\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n+    .extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "3569c7f0630649d36721b26478892c5f4579aebc", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -32,6 +32,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    ast_passes => \"../locales/en-US/ast_passes.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\","}, {"sha": "cdb5b3c4284a8d37afc0dd2f6bb7b4f8c3006937", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -45,7 +45,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n                 lint_id.lint,\n                 Some(span),\n                 |lint| {\n-                    lint.build(&msg).emit();\n+                    lint.build(msg).emit();\n                 },\n                 diagnostic,\n             );"}, {"sha": "9e7cbba9511b206a85a76a6150a4af9bf483dc6c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -9,7 +9,7 @@ pub use self::Level::*;\n use rustc_ast::node_id::{NodeId, NodeMap};\n use rustc_ast::{AttrId, Attribute};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n-use rustc_error_messages::MultiSpan;\n+use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n use rustc_hir::HirId;\n use rustc_span::edition::Edition;\n@@ -491,7 +491,7 @@ pub struct BufferedEarlyLint {\n     pub span: MultiSpan,\n \n     /// The lint message.\n-    pub msg: String,\n+    pub msg: DiagnosticMessage,\n \n     /// The `NodeId` of the AST node that generated the lint.\n     pub node_id: NodeId,\n@@ -520,11 +520,11 @@ impl LintBuffer {\n         lint: &'static Lint,\n         node_id: NodeId,\n         span: MultiSpan,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         let lint_id = LintId::of(lint);\n-        let msg = msg.to_string();\n+        let msg = msg.into();\n         self.add_early_lint(BufferedEarlyLint { lint_id, node_id, span, msg, diagnostic });\n     }\n \n@@ -537,7 +537,7 @@ impl LintBuffer {\n         lint: &'static Lint,\n         id: NodeId,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) {\n         self.add_lint(lint, id, sp.into(), msg, BuiltinLintDiagnostics::Normal)\n     }\n@@ -547,7 +547,7 @@ impl LintBuffer {\n         lint: &'static Lint,\n         id: NodeId,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         self.add_lint(lint, id, sp.into(), msg, diagnostic)"}, {"sha": "ad9ecd39b9e85a29989670027afba4cdeed1bf97", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -235,35 +235,40 @@ pub(crate) trait HasFieldMap {\n         // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n         // the next call to `it.next()` retrieves the next character.\n         while let Some(c) = it.next() {\n-            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                let mut eat_argument = || -> Option<String> {\n-                    let mut result = String::new();\n-                    // Format specifiers look like:\n-                    //\n-                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n-                    //\n-                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n-                    while let Some(c) = it.next() {\n-                        result.push(c);\n-                        let next = *it.peek().unwrap_or(&'\\0');\n-                        if next == '}' {\n-                            break;\n-                        } else if next == ':' {\n-                            // Eat the ':' character.\n-                            assert_eq!(it.next().unwrap(), ':');\n-                            break;\n-                        }\n-                    }\n-                    // Eat until (and including) the matching '}'\n-                    while it.next()? != '}' {\n-                        continue;\n+            if c != '{' {\n+                continue;\n+            }\n+            if *it.peek().unwrap_or(&'\\0') == '{' {\n+                assert_eq!(it.next().unwrap(), '{');\n+                continue;\n+            }\n+            let mut eat_argument = || -> Option<String> {\n+                let mut result = String::new();\n+                // Format specifiers look like:\n+                //\n+                //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                //\n+                // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                while let Some(c) = it.next() {\n+                    result.push(c);\n+                    let next = *it.peek().unwrap_or(&'\\0');\n+                    if next == '}' {\n+                        break;\n+                    } else if next == ':' {\n+                        // Eat the ':' character.\n+                        assert_eq!(it.next().unwrap(), ':');\n+                        break;\n                     }\n-                    Some(result)\n-                };\n-\n-                if let Some(referenced_field) = eat_argument() {\n-                    referenced_fields.insert(referenced_field);\n                 }\n+                // Eat until (and including) the matching '}'\n+                while it.next()? != '}' {\n+                    continue;\n+                }\n+                Some(result)\n+            };\n+\n+            if let Some(referenced_field) = eat_argument() {\n+                referenced_fields.insert(referenced_field);\n             }\n         }\n "}, {"sha": "17866dc6bddcbf2cbb89adf7d1a4df188efa4abe", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -360,6 +360,17 @@ impl ParseSess {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_fatal<'a>(\n+        &'a self,\n+        fatal: impl SessionDiagnostic<'a, !>,\n+    ) -> DiagnosticBuilder<'a, !> {\n+        fatal.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_fatal<'a>(&'a self, fatal: impl SessionDiagnostic<'a, !>) -> ! {\n+        self.create_fatal(fatal).emit()\n+    }\n+\n     #[rustc_lint_diagnostics]\n     pub fn struct_err(\n         &self,\n@@ -373,6 +384,11 @@ impl ParseSess {\n         self.span_diagnostic.struct_warn(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n+        self.span_diagnostic.struct_fatal(msg)\n+    }\n+\n     #[rustc_lint_diagnostics]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,"}, {"sha": "4972ae2014d506e3ce200d4baa5a7f4f20a917bf", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e521e0e5d3dc7deb389697e516aaae12e37613/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=57e521e0e5d3dc7deb389697e516aaae12e37613", "patch": "@@ -482,6 +482,15 @@ impl Session {\n     pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }\n+    pub fn create_fatal<'a>(\n+        &'a self,\n+        fatal: impl SessionDiagnostic<'a, !>,\n+    ) -> DiagnosticBuilder<'a, !> {\n+        self.parse_sess.create_fatal(fatal)\n+    }\n+    pub fn emit_fatal<'a>(&'a self, fatal: impl SessionDiagnostic<'a, !>) -> ! {\n+        self.parse_sess.emit_fatal(fatal)\n+    }\n     #[inline]\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()"}]}