{"sha": "7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMDYwNTVkNjBjM2QyYTJkNzVkZTgyNjRhYzlmNjI2Zjk3ZWJjZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-21T07:04:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-21T07:04:34Z"}, "message": "Auto merge of #45381 - bjorn3:move_collector_out_of_trans, r=nikomatsakis\n\nMove collector to rustc_trans_utils", "tree": {"sha": "da822447cb67f7ce34323de0237a5cfa27a2a284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da822447cb67f7ce34323de0237a5cfa27a2a284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "html_url": "https://github.com/rust-lang/rust/commit/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc03782b93f210a23ed792800b08c1ebad0a8820", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc03782b93f210a23ed792800b08c1ebad0a8820", "html_url": "https://github.com/rust-lang/rust/commit/cc03782b93f210a23ed792800b08c1ebad0a8820"}, {"sha": "906523efea60f4d58d6ce58bc61589d4ff3d7b4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/906523efea60f4d58d6ce58bc61589d4ff3d7b4e", "html_url": "https://github.com/rust-lang/rust/commit/906523efea60f4d58d6ce58bc61589d4ff3d7b4e"}], "stats": {"total": 1025, "additions": 565, "deletions": 460}, "files": [{"sha": "0989c430df0e448a17b879100817901795760d4a", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -1787,6 +1787,7 @@ dependencies = [\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "0ebfe4daad18fcd9db9c1a7b69b327c01519e8e0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -98,7 +98,7 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use monomorphize::Instance;\n-use trans_item::{TransItemExt, InstantiationMode};\n+use trans_item::{BaseTransItemExt, InstantiationMode};\n \n use rustc::middle::weak_lang_items;\n use rustc::middle::trans::TransItem;"}, {"sha": "547b1f7b2bf9610202c19501771dddb4d9e68e77", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -70,7 +70,7 @@ use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n-use trans_item::{TransItem, TransItemExt, DefPathBasedNames};\n+use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -93,6 +93,7 @@ use syntax::ast;\n use mir::lvalue::Alignment;\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+pub use rustc_trans_utils::trans_item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n@@ -618,33 +619,6 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n-    use rustc::middle::trans::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Some(Appending),\n-        \"available_externally\" => Some(AvailableExternally),\n-        \"common\" => Some(Common),\n-        \"extern_weak\" => Some(ExternalWeak),\n-        \"external\" => Some(External),\n-        \"internal\" => Some(Internal),\n-        \"linkonce\" => Some(LinkOnceAny),\n-        \"linkonce_odr\" => Some(LinkOnceODR),\n-        \"private\" => Some(Private),\n-        \"weak\" => Some(WeakAny),\n-        \"weak_odr\" => Some(WeakODR),\n-        _ => None,\n-    }\n-}\n-\n pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {"}, {"sha": "e3856cabcf910c77b3123462928f5040d34f150d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -36,7 +36,6 @@ use libc::{c_uint, c_char};\n use std::iter;\n \n use syntax::abi::Abi;\n-use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -552,22 +551,6 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn requests_inline<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: &ty::Instance<'tcx>\n-) -> bool {\n-    if is_inline_instance(tcx, instance) {\n-        return true\n-    }\n-    if let ty::InstanceDef::DropGlue(..) = instance.def {\n-        // Drop glue wants to be instantiated at every translation\n-        // unit, but without an #[inline] hint. We should make this\n-        // available to normal end-users.\n-        return true\n-    }\n-    attr::requests_inline(&instance.def.attrs(tcx)[..])\n-}\n-\n pub fn is_inline_instance<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: &ty::Instance<'tcx>"}, {"sha": "88ec3a65d35771b3fe66dd941bd7f9c5e04c8170", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -83,6 +83,9 @@ use rustc::ty::maps::Providers;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n+use rustc_trans_utils::collector;\n+use rustc_trans_utils::monomorphize;\n+\n mod diagnostics;\n \n pub mod back {\n@@ -124,7 +127,6 @@ mod cabi_x86;\n mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n-mod collector;\n mod common;\n mod consts;\n mod context;\n@@ -137,7 +139,6 @@ mod machine;\n mod metadata;\n mod meth;\n mod mir;\n-mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n mod time_graph;"}, {"sha": "6980ba8a52505f9ccfa0f3366095c5b4c1f0e2c8", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -114,7 +114,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::{TransItem, TransItemExt, InstantiationMode};\n+use trans_item::{TransItem, BaseTransItemExt, TransItemExt, InstantiationMode};\n \n pub use rustc::middle::trans::CodegenUnit;\n "}, {"sha": "db1af8cdefbe93596f439d808d1da31bc0853cf4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 7, "deletions": 410, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -24,50 +24,21 @@ use declare;\n use llvm;\n use monomorphize::Instance;\n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n use rustc::middle::trans::{Linkage, Visibility};\n-use rustc::session::config::OptLevel;\n-use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n-use syntax::attr::{self, InlineAttr};\n+use syntax::attr;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n use type_of;\n-use std::fmt::{self, Write};\n-use std::iter;\n+use std::fmt;\n \n pub use rustc::middle::trans::TransItem;\n \n-/// Describes how a translation item will be instantiated in object files.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum InstantiationMode {\n-    /// There will be exactly one instance of the given TransItem. It will have\n-    /// external linkage so that it can be linked to from other codegen units.\n-    GloballyShared {\n-        /// In some compilation scenarios we may decide to take functions that\n-        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n-        /// to avoid translating them a bunch of times. In this situation,\n-        /// however, our local copy may conflict with other crates also\n-        /// inlining the same function.\n-        ///\n-        /// This flag indicates that this situation is occuring, and informs\n-        /// symbol name calculation that some extra mangling is needed to\n-        /// avoid conflicts. Note that this may eventually go away entirely if\n-        /// ThinLTO enables us to *always* have a globally shared instance of a\n-        /// function within one crate's compilation.\n-        may_conflict: bool,\n-    },\n-\n-    /// Each codegen unit containing a reference to the given TransItem will\n-    /// have its own private copy of the function (with internal linkage).\n-    LocalCopy,\n-}\n-\n-pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n-    fn as_trans_item(&self) -> &TransItem<'tcx>;\n+pub use rustc_trans_utils::trans_item::*;\n+pub use rustc_trans_utils::trans_item::TransItemExt as BaseTransItemExt;\n \n+pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n     fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n@@ -165,53 +136,6 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n         }.map(|node_id| tcx.hir.span(node_id))\n     }\n \n-    fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> InstantiationMode {\n-        let inline_in_all_cgus =\n-            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n-                tcx.sess.opts.optimize != OptLevel::No\n-            });\n-\n-        match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => {\n-                // If this function isn't inlined or otherwise has explicit\n-                // linkage, then we'll be creating a globally shared version.\n-                if self.explicit_linkage(tcx).is_some() ||\n-                    !common::requests_inline(tcx, instance)\n-                {\n-                    return InstantiationMode::GloballyShared  { may_conflict: false }\n-                }\n-\n-                // At this point we don't have explicit linkage and we're an\n-                // inlined function. If we're inlining into all CGUs then we'll\n-                // be creating a local copy per CGU\n-                if inline_in_all_cgus {\n-                    return InstantiationMode::LocalCopy\n-                }\n-\n-                // Finally, if this is `#[inline(always)]` we're sure to respect\n-                // that with an inline copy per CGU, but otherwise we'll be\n-                // creating one copy of this `#[inline]` function which may\n-                // conflict with upstream crates as it could be an exported\n-                // symbol.\n-                let attrs = instance.def.attrs(tcx);\n-                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n-                    InlineAttr::Always => InstantiationMode::LocalCopy,\n-                    _ => {\n-                        InstantiationMode::GloballyShared  { may_conflict: true }\n-                    }\n-                }\n-            }\n-            TransItem::Static(..) => {\n-                InstantiationMode::GloballyShared { may_conflict: false }\n-            }\n-            TransItem::GlobalAsm(..) => {\n-                InstantiationMode::GloballyShared { may_conflict: false }\n-            }\n-        }\n-    }\n-\n     fn is_generic_fn(&self) -> bool {\n         match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => {\n@@ -222,97 +146,6 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n-        let def_id = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => instance.def_id(),\n-            TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n-            TransItem::GlobalAsm(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = base::linkage_by_name(&name.as_str()) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.hir.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns whether this instance is instantiable - whether it has no unsatisfied\n-    /// predicates.\n-    ///\n-    /// In order to translate an item, all of its predicates must hold, because\n-    /// otherwise the item does not make sense. Type-checking ensures that\n-    /// the predicates of every item that is *used by* a valid item *do*\n-    /// hold, so we can rely on that.\n-    ///\n-    /// However, we translate collector roots (reachable items) and functions\n-    /// in vtables when they are seen, even if they are not used, and so they\n-    /// might not be instantiable. For example, a programmer can define this\n-    /// public function:\n-    ///\n-    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n-    ///         <&mut () as Clone>::clone(&s);\n-    ///     }\n-    ///\n-    /// That function can't be translated, because the method `<&mut () as Clone>::clone`\n-    /// does not exist. Luckily for us, that function can't ever be used,\n-    /// because that would require for `&'a mut (): Clone` to hold, so we\n-    /// can just not emit any code, or even a linker reference for it.\n-    ///\n-    /// Similarly, if a vtable method has such a signature, and therefore can't\n-    /// be used, we can just not emit it and have a placeholder (a null pointer,\n-    /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        debug!(\"is_instantiable({:?})\", self);\n-        let (def_id, substs) = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n-            // global asm never has predicates\n-            TransItem::GlobalAsm(..) => return true\n-        };\n-\n-        let predicates = tcx.predicates_of(def_id).predicates.subst(tcx, substs);\n-        traits::normalize_and_test_predicates(tcx, predicates)\n-    }\n-\n-    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.hir;\n-\n-        return match *self.as_trans_item() {\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-            TransItem::GlobalAsm(..) => {\n-                \"global_asm\".to_string()\n-            }\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            let printer = DefPathBasedNames::new(tcx, false, false);\n-            printer.push_instance_as_string(instance, &mut result);\n-            result\n-        }\n-    }\n-\n     fn to_raw_string(&self) -> String {\n         match *self.as_trans_item() {\n             TransItem::Fn(instance) => {\n@@ -330,11 +163,7 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     }\n }\n \n-impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {\n-    fn as_trans_item(&self) -> &TransItem<'tcx> {\n-        self\n-    }\n-}\n+impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {}\n \n fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               node_id: ast::NodeId,\n@@ -402,235 +231,3 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.instances().borrow_mut().insert(instance, lldecl);\n }\n \n-//=-----------------------------------------------------------------------------\n-// TransItem String Keys\n-//=-----------------------------------------------------------------------------\n-\n-// The code below allows for producing a unique string key for a trans item.\n-// These keys are used by the handwritten auto-tests, so they need to be\n-// predictable and human-readable.\n-//\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n-\n-/// Same as `unique_type_name()` but with the result pushed onto the given\n-/// `output` parameter.\n-pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    omit_disambiguators: bool,\n-    omit_local_crate_name: bool,\n-}\n-\n-impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               omit_disambiguators: bool,\n-               omit_local_crate_name: bool)\n-               -> Self {\n-        DefPathBasedNames {\n-            tcx,\n-            omit_disambiguators,\n-            omit_local_crate_name,\n-        }\n-    }\n-\n-    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n-        match t.sty {\n-            ty::TyBool              => output.push_str(\"bool\"),\n-            ty::TyChar              => output.push_str(\"char\"),\n-            ty::TyStr               => output.push_str(\"str\"),\n-            ty::TyNever             => output.push_str(\"!\"),\n-            ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-            ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-            ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-            ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-            ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n-            ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-            ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-            ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-            ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-            ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n-            ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-            ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-            ty::TyAdt(adt_def, substs) => {\n-                self.push_def_path(adt_def.did, output);\n-                self.push_type_params(substs, iter::empty(), output);\n-            },\n-            ty::TyTuple(component_types, _) => {\n-                output.push('(');\n-                for &component_type in component_types {\n-                    self.push_type_name(component_type, output);\n-                    output.push_str(\", \");\n-                }\n-                if !component_types.is_empty() {\n-                    output.pop();\n-                    output.pop();\n-                }\n-                output.push(')');\n-            },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-                output.push('*');\n-                match mutbl {\n-                    hir::MutImmutable => output.push_str(\"const \"),\n-                    hir::MutMutable => output.push_str(\"mut \"),\n-                }\n-\n-                self.push_type_name(inner_type, output);\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-                output.push('&');\n-                if mutbl == hir::MutMutable {\n-                    output.push_str(\"mut \");\n-                }\n-\n-                self.push_type_name(inner_type, output);\n-            },\n-            ty::TyArray(inner_type, len) => {\n-                output.push('[');\n-                self.push_type_name(inner_type, output);\n-                write!(output, \"; {}\",\n-                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n-                output.push(']');\n-            },\n-            ty::TySlice(inner_type) => {\n-                output.push('[');\n-                self.push_type_name(inner_type, output);\n-                output.push(']');\n-            },\n-            ty::TyDynamic(ref trait_data, ..) => {\n-                if let Some(principal) = trait_data.principal() {\n-                    self.push_def_path(principal.def_id(), output);\n-                    self.push_type_params(principal.skip_binder().substs,\n-                        trait_data.projection_bounds(),\n-                        output);\n-                }\n-            },\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => {\n-                let sig = t.fn_sig(self.tcx);\n-                if sig.unsafety() == hir::Unsafety::Unsafe {\n-                    output.push_str(\"unsafe \");\n-                }\n-\n-                let abi = sig.abi();\n-                if abi != ::abi::Abi::Rust {\n-                    output.push_str(\"extern \\\"\");\n-                    output.push_str(abi.name());\n-                    output.push_str(\"\\\" \");\n-                }\n-\n-                output.push_str(\"fn(\");\n-\n-                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n-\n-                if !sig.inputs().is_empty() {\n-                    for &parameter_type in sig.inputs() {\n-                        self.push_type_name(parameter_type, output);\n-                        output.push_str(\", \");\n-                    }\n-                    output.pop();\n-                    output.pop();\n-                }\n-\n-                if sig.variadic {\n-                    if !sig.inputs().is_empty() {\n-                        output.push_str(\", ...\");\n-                    } else {\n-                        output.push_str(\"...\");\n-                    }\n-                }\n-\n-                output.push(')');\n-\n-                if !sig.output().is_nil() {\n-                    output.push_str(\" -> \");\n-                    self.push_type_name(sig.output(), output);\n-                }\n-            },\n-            ty::TyGenerator(def_id, ref closure_substs, _) |\n-            ty::TyClosure(def_id, ref closure_substs) => {\n-                self.push_def_path(def_id, output);\n-                let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n-                let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n-                self.push_type_params(substs, iter::empty(), output);\n-            }\n-            ty::TyError |\n-            ty::TyInfer(_) |\n-            ty::TyProjection(..) |\n-            ty::TyParam(_) |\n-            ty::TyAnon(..) => {\n-                bug!(\"DefPathBasedNames: Trying to create type name for \\\n-                                         unexpected type: {:?}\", t);\n-            }\n-        }\n-    }\n-\n-    pub fn push_def_path(&self,\n-                         def_id: DefId,\n-                         output: &mut String) {\n-        let def_path = self.tcx.def_path(def_id);\n-\n-        // some_crate::\n-        if !(self.omit_local_crate_name && def_id.is_local()) {\n-            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n-            output.push_str(\"::\");\n-        }\n-\n-        // foo::bar::ItemName::\n-        for part in self.tcx.def_path(def_id).data {\n-            if self.omit_disambiguators {\n-                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n-            } else {\n-                write!(output, \"{}[{}]::\",\n-                       part.data.as_interned_str(),\n-                       part.disambiguator).unwrap();\n-            }\n-        }\n-\n-        // remove final \"::\"\n-        output.pop();\n-        output.pop();\n-    }\n-\n-    fn push_type_params<I>(&self,\n-                            substs: &Substs<'tcx>,\n-                            projections: I,\n-                            output: &mut String)\n-        where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>>\n-    {\n-        let mut projections = projections.peekable();\n-        if substs.types().next().is_none() && projections.peek().is_none() {\n-            return;\n-        }\n-\n-        output.push('<');\n-\n-        for type_parameter in substs.types() {\n-            self.push_type_name(type_parameter, output);\n-            output.push_str(\", \");\n-        }\n-\n-        for projection in projections {\n-            let projection = projection.skip_binder();\n-            let name = &self.tcx.associated_item(projection.item_def_id).name.as_str();\n-            output.push_str(name);\n-            output.push_str(\"=\");\n-            self.push_type_name(projection.ty, output);\n-            output.push_str(\", \");\n-        }\n-\n-        output.pop();\n-        output.pop();\n-\n-        output.push('>');\n-    }\n-\n-    pub fn push_instance_as_string(&self,\n-                                   instance: Instance<'tcx>,\n-                                   output: &mut String) {\n-        self.push_def_path(instance.def_id(), output);\n-        self.push_type_params(instance.substs, iter::empty(), output);\n-    }\n-}"}, {"sha": "7d9d7cea9335da6b38a69edbe4f962f6a5535c41", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -19,3 +19,4 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "c87d86262efdd7ece7721b91b3cced3b693d53ef", "filename": "src/librustc_trans_utils/collector.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcollector.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -195,6 +195,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n+use rustc::middle::trans::TransItem;\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n@@ -206,7 +207,7 @@ use common::{def_ty, instance_ty, type_is_sized};\n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, TransItemExt, DefPathBasedNames, InstantiationMode};\n+use trans_item::{TransItemExt, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n ", "previous_filename": "src/librustc_trans/collector.rs"}, {"sha": "634e37220e2f175d4fa89ac06c83accd6c575894", "filename": "src/librustc_trans_utils/common.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcommon.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types, non_snake_case)]\n+\n+//! Code that is useful in various trans modules.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n+\n+use syntax::attr;\n+use syntax_pos::DUMMY_SP;\n+\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+}\n+\n+pub fn requests_inline<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n+) -> bool {\n+    if is_inline_instance(tcx, instance) {\n+        return true\n+    }\n+    if let ty::InstanceDef::DropGlue(..) = instance.def {\n+        // Drop glue wants to be instantiated at every translation\n+        // unit, but without an #[inline] hint. We should make this\n+        // available to normal end-users.\n+        return true\n+    }\n+    attr::requests_inline(&instance.def.attrs(tcx)[..])\n+}\n+\n+pub fn is_inline_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n+) -> bool {\n+    let def_id = match instance.def {\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n+        _ => return true\n+    };\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::StructCtor |\n+        DefPathData::EnumVariant(..) |\n+        DefPathData::ClosureExpr => true,\n+        _ => false\n+    }\n+}\n+\n+/// Given a DefId and some Substs, produces the monomorphic item type.\n+pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        def_id: DefId,\n+                        substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx>\n+{\n+    let ty = tcx.type_of(def_id);\n+    tcx.trans_apply_param_substs(substs, &ty)\n+}\n+\n+/// Return the substituted type of an instance.\n+pub fn instance_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             instance: &ty::Instance<'tcx>)\n+                             -> Ty<'tcx>\n+{\n+    let ty = instance.def.def_ty(tcx);\n+    tcx.trans_apply_param_substs(instance.substs, &ty)\n+}"}, {"sha": "bc8f8d5a6da2dc6a0642f70b4c2f0ff8e86c7a18", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -38,6 +38,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n+extern crate rustc_data_structures;\n extern crate syntax;\n extern crate syntax_pos;\n \n@@ -49,7 +50,11 @@ use rustc::util::nodemap::NodeSet;\n \n use syntax::attr;\n \n+mod common;\n pub mod link;\n+pub mod collector;\n+pub mod trans_item;\n+pub mod monomorphize;\n pub mod trans_crate;\n \n /// check for the #[rustc_error] annotation, which forces an"}, {"sha": "471be439a8f3bb41df43d7d241ffb0bf2a13c5a2", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "previous_filename": "src/librustc_trans/monomorphize.rs"}, {"sha": "0ada39d7d27116114cd4b67acf2055cdd486066f", "filename": "src/librustc_trans_utils/trans_item.rs", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f06055d60c3d2a2d75de8264ac9f626f97ebcdd/src%2Flibrustc_trans_utils%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_item.rs?ref=7f06055d60c3d2a2d75de8264ac9f626f97ebcdd", "patch": "@@ -0,0 +1,464 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Walks the crate looking for items/impl-items/trait-items that have\n+//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! generates an error giving, respectively, the symbol name or\n+//! item-path. This is used for unit testing the code that generates\n+//! paths etc in all kinds of annoying scenarios.\n+\n+use common;\n+use monomorphize::Instance;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::trans::Linkage;\n+use rustc::session::config::OptLevel;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs};\n+use syntax::ast;\n+use syntax::attr::{self, InlineAttr};\n+use std::fmt::{self, Write};\n+use std::iter;\n+\n+pub use rustc::middle::trans::TransItem;\n+\n+pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n+    use rustc::middle::trans::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but whitelist them anyway and trust that\n+    // the user knows what s/he's doing. Who knows, unanticipated use cases\n+    // may pop up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Some(Appending),\n+        \"available_externally\" => Some(AvailableExternally),\n+        \"common\" => Some(Common),\n+        \"extern_weak\" => Some(ExternalWeak),\n+        \"external\" => Some(External),\n+        \"internal\" => Some(Internal),\n+        \"linkonce\" => Some(LinkOnceAny),\n+        \"linkonce_odr\" => Some(LinkOnceODR),\n+        \"private\" => Some(Private),\n+        \"weak\" => Some(WeakAny),\n+        \"weak_odr\" => Some(WeakODR),\n+        _ => None,\n+    }\n+}\n+\n+/// Describes how a translation item will be instantiated in object files.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum InstantiationMode {\n+    /// There will be exactly one instance of the given TransItem. It will have\n+    /// external linkage so that it can be linked to from other codegen units.\n+    GloballyShared {\n+        /// In some compilation scenarios we may decide to take functions that\n+        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n+        /// to avoid translating them a bunch of times. In this situation,\n+        /// however, our local copy may conflict with other crates also\n+        /// inlining the same function.\n+        ///\n+        /// This flag indicates that this situation is occuring, and informs\n+        /// symbol name calculation that some extra mangling is needed to\n+        /// avoid conflicts. Note that this may eventually go away entirely if\n+        /// ThinLTO enables us to *always* have a globally shared instance of a\n+        /// function within one crate's compilation.\n+        may_conflict: bool,\n+    },\n+\n+    /// Each codegen unit containing a reference to the given TransItem will\n+    /// have its own private copy of the function (with internal linkage).\n+    LocalCopy,\n+}\n+\n+pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n+    fn as_trans_item(&self) -> &TransItem<'tcx>;\n+\n+    fn instantiation_mode(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> InstantiationMode {\n+        let inline_in_all_cgus =\n+            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n+                tcx.sess.opts.optimize != OptLevel::No\n+            });\n+\n+        match *self.as_trans_item() {\n+            TransItem::Fn(ref instance) => {\n+                // If this function isn't inlined or otherwise has explicit\n+                // linkage, then we'll be creating a globally shared version.\n+                if self.explicit_linkage(tcx).is_some() ||\n+                    !common::requests_inline(tcx, instance)\n+                {\n+                    return InstantiationMode::GloballyShared  { may_conflict: false }\n+                }\n+\n+                // At this point we don't have explicit linkage and we're an\n+                // inlined function. If we're inlining into all CGUs then we'll\n+                // be creating a local copy per CGU\n+                if inline_in_all_cgus {\n+                    return InstantiationMode::LocalCopy\n+                }\n+\n+                // Finally, if this is `#[inline(always)]` we're sure to respect\n+                // that with an inline copy per CGU, but otherwise we'll be\n+                // creating one copy of this `#[inline]` function which may\n+                // conflict with upstream crates as it could be an exported\n+                // symbol.\n+                let attrs = instance.def.attrs(tcx);\n+                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n+                    InlineAttr::Always => InstantiationMode::LocalCopy,\n+                    _ => {\n+                        InstantiationMode::GloballyShared  { may_conflict: true }\n+                    }\n+                }\n+            }\n+            TransItem::Static(..) => {\n+                InstantiationMode::GloballyShared { may_conflict: false }\n+            }\n+            TransItem::GlobalAsm(..) => {\n+                InstantiationMode::GloballyShared { may_conflict: false }\n+            }\n+        }\n+    }\n+\n+    fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+        let def_id = match *self.as_trans_item() {\n+            TransItem::Fn(ref instance) => instance.def_id(),\n+            TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n+            TransItem::GlobalAsm(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = linkage_by_name(&name.as_str()) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.hir.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns whether this instance is instantiable - whether it has no unsatisfied\n+    /// predicates.\n+    ///\n+    /// In order to translate an item, all of its predicates must hold, because\n+    /// otherwise the item does not make sense. Type-checking ensures that\n+    /// the predicates of every item that is *used by* a valid item *do*\n+    /// hold, so we can rely on that.\n+    ///\n+    /// However, we translate collector roots (reachable items) and functions\n+    /// in vtables when they are seen, even if they are not used, and so they\n+    /// might not be instantiable. For example, a programmer can define this\n+    /// public function:\n+    ///\n+    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n+    ///         <&mut () as Clone>::clone(&s);\n+    ///     }\n+    ///\n+    /// That function can't be translated, because the method `<&mut () as Clone>::clone`\n+    /// does not exist. Luckily for us, that function can't ever be used,\n+    /// because that would require for `&'a mut (): Clone` to hold, so we\n+    /// can just not emit any code, or even a linker reference for it.\n+    ///\n+    /// Similarly, if a vtable method has such a signature, and therefore can't\n+    /// be used, we can just not emit it and have a placeholder (a null pointer,\n+    /// which will never be accessed) in its place.\n+    fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        debug!(\"is_instantiable({:?})\", self);\n+        let (def_id, substs) = match *self.as_trans_item() {\n+            TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n+            TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+            // global asm never has predicates\n+            TransItem::GlobalAsm(..) => return true\n+        };\n+\n+        let predicates = tcx.predicates_of(def_id).predicates.subst(tcx, substs);\n+        traits::normalize_and_test_predicates(tcx, predicates)\n+    }\n+\n+    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.hir;\n+\n+        return match *self.as_trans_item() {\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+            TransItem::GlobalAsm(..) => {\n+                \"global_asm\".to_string()\n+            }\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            let printer = DefPathBasedNames::new(tcx, false, false);\n+            printer.push_instance_as_string(instance, &mut result);\n+            result\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {\n+    fn as_trans_item(&self) -> &TransItem<'tcx> {\n+        self\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// TransItem String Keys\n+//=-----------------------------------------------------------------------------\n+\n+// The code below allows for producing a unique string key for a trans item.\n+// These keys are used by the handwritten auto-tests, so they need to be\n+// predictable and human-readable.\n+//\n+// Note: A lot of this could looks very similar to what's already in the\n+//       ppaux module. It would be good to refactor things so we only have one\n+//       parameterizable implementation for printing types.\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    omit_disambiguators: bool,\n+    omit_local_crate_name: bool,\n+}\n+\n+impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               omit_disambiguators: bool,\n+               omit_local_crate_name: bool)\n+               -> Self {\n+        DefPathBasedNames {\n+            tcx,\n+            omit_disambiguators,\n+            omit_local_crate_name,\n+        }\n+    }\n+\n+    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n+        match t.sty {\n+            ty::TyBool              => output.push_str(\"bool\"),\n+            ty::TyChar              => output.push_str(\"char\"),\n+            ty::TyStr               => output.push_str(\"str\"),\n+            ty::TyNever             => output.push_str(\"!\"),\n+            ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+            ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+            ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+            ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+            ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n+            ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+            ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+            ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+            ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+            ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n+            ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+            ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::TyAdt(adt_def, substs) => {\n+                self.push_def_path(adt_def.did, output);\n+                self.push_type_params(substs, iter::empty(), output);\n+            },\n+            ty::TyTuple(component_types, _) => {\n+                output.push('(');\n+                for &component_type in component_types {\n+                    self.push_type_name(component_type, output);\n+                    output.push_str(\", \");\n+                }\n+                if !component_types.is_empty() {\n+                    output.pop();\n+                    output.pop();\n+                }\n+                output.push(')');\n+            },\n+            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+                output.push('*');\n+                match mutbl {\n+                    hir::MutImmutable => output.push_str(\"const \"),\n+                    hir::MutMutable => output.push_str(\"mut \"),\n+                }\n+\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+                output.push('&');\n+                if mutbl == hir::MutMutable {\n+                    output.push_str(\"mut \");\n+                }\n+\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyArray(inner_type, len) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                write!(output, \"; {}\",\n+                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n+                output.push(']');\n+            },\n+            ty::TySlice(inner_type) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                output.push(']');\n+            },\n+            ty::TyDynamic(ref trait_data, ..) => {\n+                if let Some(principal) = trait_data.principal() {\n+                    self.push_def_path(principal.def_id(), output);\n+                    self.push_type_params(principal.skip_binder().substs,\n+                        trait_data.projection_bounds(),\n+                        output);\n+                }\n+            },\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let sig = t.fn_sig(self.tcx);\n+                if sig.unsafety() == hir::Unsafety::Unsafe {\n+                    output.push_str(\"unsafe \");\n+                }\n+\n+                let abi = sig.abi();\n+                if abi != ::syntax::abi::Abi::Rust {\n+                    output.push_str(\"extern \\\"\");\n+                    output.push_str(abi.name());\n+                    output.push_str(\"\\\" \");\n+                }\n+\n+                output.push_str(\"fn(\");\n+\n+                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n+\n+                if !sig.inputs().is_empty() {\n+                    for &parameter_type in sig.inputs() {\n+                        self.push_type_name(parameter_type, output);\n+                        output.push_str(\", \");\n+                    }\n+                    output.pop();\n+                    output.pop();\n+                }\n+\n+                if sig.variadic {\n+                    if !sig.inputs().is_empty() {\n+                        output.push_str(\", ...\");\n+                    } else {\n+                        output.push_str(\"...\");\n+                    }\n+                }\n+\n+                output.push(')');\n+\n+                if !sig.output().is_nil() {\n+                    output.push_str(\" -> \");\n+                    self.push_type_name(sig.output(), output);\n+                }\n+            },\n+            ty::TyGenerator(def_id, ref closure_substs, _) |\n+            ty::TyClosure(def_id, ref closure_substs) => {\n+                self.push_def_path(def_id, output);\n+                let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n+                let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n+                self.push_type_params(substs, iter::empty(), output);\n+            }\n+            ty::TyError |\n+            ty::TyInfer(_) |\n+            ty::TyProjection(..) |\n+            ty::TyParam(_) |\n+            ty::TyAnon(..) => {\n+                bug!(\"DefPathBasedNames: Trying to create type name for \\\n+                                         unexpected type: {:?}\", t);\n+            }\n+        }\n+    }\n+\n+    pub fn push_def_path(&self,\n+                         def_id: DefId,\n+                         output: &mut String) {\n+        let def_path = self.tcx.def_path(def_id);\n+\n+        // some_crate::\n+        if !(self.omit_local_crate_name && def_id.is_local()) {\n+            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n+            output.push_str(\"::\");\n+        }\n+\n+        // foo::bar::ItemName::\n+        for part in self.tcx.def_path(def_id).data {\n+            if self.omit_disambiguators {\n+                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+            } else {\n+                write!(output, \"{}[{}]::\",\n+                       part.data.as_interned_str(),\n+                       part.disambiguator).unwrap();\n+            }\n+        }\n+\n+        // remove final \"::\"\n+        output.pop();\n+        output.pop();\n+    }\n+\n+    fn push_type_params<I>(&self,\n+                            substs: &Substs<'tcx>,\n+                            projections: I,\n+                            output: &mut String)\n+        where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>>\n+    {\n+        let mut projections = projections.peekable();\n+        if substs.types().next().is_none() && projections.peek().is_none() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for type_parameter in substs.types() {\n+            self.push_type_name(type_parameter, output);\n+            output.push_str(\", \");\n+        }\n+\n+        for projection in projections {\n+            let projection = projection.skip_binder();\n+            let name = &self.tcx.associated_item(projection.item_def_id).name.as_str();\n+            output.push_str(name);\n+            output.push_str(\"=\");\n+            self.push_type_name(projection.ty, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+\n+    pub fn push_instance_as_string(&self,\n+                                   instance: Instance<'tcx>,\n+                                   output: &mut String) {\n+        self.push_def_path(instance.def_id(), output);\n+        self.push_type_params(instance.substs, iter::empty(), output);\n+    }\n+}"}]}