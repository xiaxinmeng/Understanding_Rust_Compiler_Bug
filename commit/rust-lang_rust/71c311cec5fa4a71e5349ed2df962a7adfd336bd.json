{"sha": "71c311cec5fa4a71e5349ed2df962a7adfd336bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYzMxMWNlYzVmYTRhNzFlNTM0OWVkMmRmOTYyYTdhZGZkMzM2YmQ=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-23T02:42:09Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-23T02:42:09Z"}, "message": "Uncomment tests and fix binarysort segmentation fault", "tree": {"sha": "71011e15464b7ebbd9ad4a30cb8f0d00a23d09ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71011e15464b7ebbd9ad4a30cb8f0d00a23d09ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71c311cec5fa4a71e5349ed2df962a7adfd336bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71c311cec5fa4a71e5349ed2df962a7adfd336bd", "html_url": "https://github.com/rust-lang/rust/commit/71c311cec5fa4a71e5349ed2df962a7adfd336bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71c311cec5fa4a71e5349ed2df962a7adfd336bd/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc0f2c6bb26ba38d3487a396fa8625e938af6820", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc0f2c6bb26ba38d3487a396fa8625e938af6820", "html_url": "https://github.com/rust-lang/rust/commit/cc0f2c6bb26ba38d3487a396fa8625e938af6820"}], "stats": {"total": 167, "additions": 72, "deletions": 95}, "files": [{"sha": "97ae0054cce329f7c1d003c8af109e6bf3328976", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 72, "deletions": 95, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/71c311cec5fa4a71e5349ed2df962a7adfd336bd/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c311cec5fa4a71e5349ed2df962a7adfd336bd/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=71c311cec5fa4a71e5349ed2df962a7adfd336bd", "patch": "@@ -172,16 +172,16 @@ pub fn tim_sort<T: Ord>(array: &[mut T]) {\n         return;\n     }\n \n+    let ms = &MergeState();\n+    ms.array = array;\n+    let min_run = min_run_length(size);\n+\n     if size < MIN_MERGE {\n         let init_run_len = count_run_ascending(array);\n-        binarysort(array, init_run_len);\n+        ms.binarysort(array, init_run_len);\n         return;\n     }\n \n-    let ms = &MergeState();\n-    ms.array = array;\n-    let min_run = min_run_length(size);\n-\n     let mut idx = 0;\n     let mut remaining = size;\n     loop {\n@@ -191,7 +191,7 @@ pub fn tim_sort<T: Ord>(array: &[mut T]) {\n         if run_len < min_run {\n             let force = if remaining <= min_run {remaining} else {min_run};\n             let slice = vec::mut_view(arr, 0, force);\n-            binarysort(slice, run_len);\n+            ms.binarysort(slice, run_len);\n             run_len = force;\n         }\n \n@@ -206,47 +206,7 @@ pub fn tim_sort<T: Ord>(array: &[mut T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n-    let size = array.len();\n-    let mut start = start;\n-    assert start <= size;\n-\n-    if start == 0 { start += 1; }\n-\n-    let mut pivot = ~[];\n-    vec::reserve(&mut pivot, 1);\n-    unsafe { vec::raw::set_len(&mut pivot, 1); };\n-\n-    while start < size {\n-        unsafe {\n-            let tmp_view = vec::mut_view(array, start, start+1);\n-            vec::raw::memmove(pivot, tmp_view, 1);\n-        }\n-        let mut left = 0;\n-        let mut right = start;\n-        assert left <= right;\n-\n-        while left < right {\n-            let mid = (left + right) >> 1;\n-            if pivot[0] < array[mid] {\n-                right = mid;\n-            } else {\n-                left = mid+1;\n-            }\n-        }\n-        assert left == right;\n-        let mut n = start-left;\n-\n-        unsafe {\n-            move_vec(array, left+1, array, left, n);\n-        }\n-        array[left] <-> pivot[0];\n-        start += 1;\n-    }\n-    unsafe { vec::raw::set_len(&mut pivot, 0); } // Forget the boxed element\n-}\n-\n-/// Reverse the order of elements in a slice, in place\n+// Reverse the order of elements in a slice, in place\n fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n@@ -395,6 +355,7 @@ struct MergeState<T> {\n     mut min_gallop: uint,\n     mut tmp: ~[T],\n     mut last_hi: bool,\n+    mut last_bsort: bool,\n     mut mergePt: uint,\n     mut tmpPt: uint,\n     mut array: &[mut T],\n@@ -404,7 +365,9 @@ struct MergeState<T> {\n         unsafe {\n             let size = self.tmp.len();\n             // Move tmp back into invalid part of array\n-            if self.last_hi && size > 0 {\n+            if self.last_bsort {\n+\n+            } else if self.last_hi && size > 0 {\n                 self.mergePt -= self.tmpPt;\n                 move_vec(self.array, self.mergePt, self.tmp, 0, self.tmpPt);\n             } else if !self.last_hi && size-self.tmpPt > 0 {\n@@ -421,8 +384,9 @@ fn MergeState<T>() -> MergeState<T> {\n     vec::reserve(&mut tmp, INITIAL_TMP_STORAGE);\n     MergeState {\n         min_gallop: MIN_GALLOP,\n-        tmp: tmp,\n+        tmp: move tmp,\n         last_hi: false,\n+        last_bsort: false,\n         mergePt: 0,\n         tmpPt: 0,\n         array: &[mut],\n@@ -431,6 +395,45 @@ fn MergeState<T>() -> MergeState<T> {\n }\n \n impl<T: Ord> &MergeState<T> {\n+    fn binarysort(array: &[mut T], start: uint) {\n+        let size = array.len();\n+        let mut start = start;\n+        assert start <= size;\n+\n+        if start == 0 { start += 1; }\n+\n+        self.last_bsort = true;\n+        unsafe { vec::raw::set_len(&mut self.tmp, 1); };\n+\n+        while start < size {\n+            unsafe {\n+                move_vec(self.tmp, 0, array, start, 1);\n+            }\n+            let mut left = 0;\n+            let mut right = start;\n+            assert left <= right;\n+\n+            while left < right {\n+                let mid = (left + right) >> 1;\n+                if self.tmp[0] < array[mid] {\n+                    right = mid;\n+                } else {\n+                    left = mid+1;\n+                }\n+            }\n+            assert left == right;\n+            let mut n = start-left;\n+\n+            unsafe {\n+                move_vec(array, left+1, array, left, n);\n+            }\n+            array[left] <-> self.tmp[0];\n+            start += 1;\n+        }\n+        unsafe { vec::raw::set_len(&mut self.tmp, 0); } // Forget the boxed element\n+        self.last_bsort = false;\n+    }\n+\n     fn push_run(run_base: uint, run_len: uint) {\n         let tmp = RunState{base: run_base, len: run_len};\n         self.runs.push(tmp);\n@@ -958,7 +961,7 @@ mod tests {\n         // tjc: funny that we have to use parens\n         pure fn ile(x: &(&static/str), y: &(&static/str)) -> bool\n         {\n-            unsafe            // to_lower is not pure...\n+            unsafe // to_lower is not pure...\n             {\n                 let x = x.to_lower();\n                 let y = y.to_lower();\n@@ -977,7 +980,6 @@ mod tests {\n \n #[cfg(test)]\n mod test_tim_sort {\n-    // #[legacy_exports];\n     struct CVal {\n         val: ~float,\n     }\n@@ -1043,51 +1045,27 @@ mod test_tim_sort {\n         tim_sort(arr);\n         fail ~\"Guarantee the fail\";\n     }\n-\n-    struct DVal { val: ~uint }\n-    impl DVal: Ord {\n-        pure fn lt(_x: &DVal) -> bool { true }\n-        pure fn le(_x: &DVal) -> bool { true }\n-        pure fn gt(_x: &DVal) -> bool { true }\n-        pure fn ge(_x: &DVal) -> bool { true }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_bad_Ord_impl() {\n-        let rng = rand::Rng();\n-        let mut arr = do vec::from_fn(500) |_i| {\n-            let randVal = rng.gen_uint();\n-            DVal { val: ~randVal }\n-        };\n-\n-        tim_sort(arr);\n-        fail ~\"Guarantee the fail\";\n-    }\n }\n \n-/*\n #[cfg(test)]\n mod big_tests {\n \n     #[test]\n-    fn sorts_test() {\n+    fn test_unique() {\n         let low = 5;\n         let high = 10;\n-\n-        //pure fn le(a: &~float, b: &~float) -> bool { *a <= *b }\n-\n-        //let s1 = fn(arr: &[mut ~float]) { tim_sort(arr); };\n-        //let s2 = fn(arr: &[mut ~float]) { quick_sort(arr, le); };\n-        //let s3 = fn(arr: &[mut ~float]) { quick_sort3(arr); };\n-        //let s4 = fn(arr: &[mut ~float]) { let rs = merge_sort(arr, le);\n-        //                        for rs.eachi |i, v| {arr[i] = *v}};\n-\n-\n-        // Run tabulate_unique and tabulate_managed\n-        // with the other sorts at some point\n         tabulate_unique(low, high);\n+    }\n+\n+    #[test]\n+    fn test_managed() {\n+        let low = 5;\n+        let high = 10;\n         tabulate_managed(low, high);\n+    }\n+\n+    #[test]\n+    fn test_linear() {\n         tabulate_linear();\n     }\n \n@@ -1096,14 +1074,14 @@ mod big_tests {\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n         };\n-        vec::to_mut(res)\n+        vec::to_mut(move res)\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n         let mut two = copy one;\n         vec::reverse(two);\n-        vec::append(two, one)\n+        vec::append(move two, one)\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n@@ -1122,7 +1100,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 ~rng.gen_float()\n             };\n-            let arr = vec::to_mut(arr);\n+            let arr = vec::to_mut(move arr);\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1163,7 +1141,7 @@ mod big_tests {\n             let arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { arr };\n+            } else { move arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr);\n \n@@ -1195,7 +1173,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 @rng.gen_float()\n             };\n-            let arr = vec::to_mut(arr);\n+            let arr = vec::to_mut(move arr);\n \n             tim_sort(arr); // *sort\n             isSorted(arr, 1);\n@@ -1236,7 +1214,7 @@ mod big_tests {\n             let arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { arr };\n+            } else { move arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr, n/4+1);\n \n@@ -1247,7 +1225,7 @@ mod big_tests {\n             let half = n / 2;\n             let mut arr = makeRange(half).map(|i| @(*i as float));\n             tim_sort(arr); // !sort\n-            isSorted(arr, 2);\n+            isSorted(arr, 1);\n         }\n     }\n \n@@ -1294,7 +1272,7 @@ mod big_tests {\n             let mut arr = do vec::from_fn(n) |i| {\n                 LVal { val: i, key: key }\n             };\n-            //tim_sort(arr);\n+            tim_sort(arr);\n             isSorted(arr);\n         }\n \n@@ -1305,7 +1283,6 @@ mod big_tests {\n         assert n == dropped;\n     }\n }\n-*/\n \n // Local Variables:\n // mode: rust;"}]}