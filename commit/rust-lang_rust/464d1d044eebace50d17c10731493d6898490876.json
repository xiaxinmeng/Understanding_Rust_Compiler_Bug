{"sha": "464d1d044eebace50d17c10731493d6898490876", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NGQxZDA0NGVlYmFjZTUwZDE3YzEwNzMxNDkzZDY4OTg0OTA4NzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T15:26:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T15:26:41Z"}, "message": "auto merge of #11405 : huonw/rust/moredocs, r=huonw\n\nVarious documentation changes, change the 'borrowed pointer' terminology to 'reference', fix a problem with 'make dist' on windows.", "tree": {"sha": "886787e27d87335fc126fcfb4becedea1b0b5d4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/886787e27d87335fc126fcfb4becedea1b0b5d4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/464d1d044eebace50d17c10731493d6898490876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/464d1d044eebace50d17c10731493d6898490876", "html_url": "https://github.com/rust-lang/rust/commit/464d1d044eebace50d17c10731493d6898490876", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/464d1d044eebace50d17c10731493d6898490876/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fda71f26301d153ca8d9489281d382af79792d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda71f26301d153ca8d9489281d382af79792d63", "html_url": "https://github.com/rust-lang/rust/commit/fda71f26301d153ca8d9489281d382af79792d63"}, {"sha": "9dc44c7d861de4db93620589507e3ce935677392", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc44c7d861de4db93620589507e3ce935677392", "html_url": "https://github.com/rust-lang/rust/commit/9dc44c7d861de4db93620589507e3ce935677392"}], "stats": {"total": 623, "additions": 337, "deletions": 286}, "files": [{"sha": "c2a562967d6a21b959af676850bc65e77df4c559", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -410,6 +410,7 @@ export CFG_SRC_DIR\n export CFG_BUILD_DIR\n export CFG_VERSION\n export CFG_VERSION_WIN\n+export CFG_RELEASE\n export CFG_BUILD\n export CFG_LLVM_ROOT\n export CFG_ENABLE_MINGW_CROSS"}, {"sha": "54473d82285216aeee8118c503bfb3fa498d2d01", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/configure", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -806,6 +806,7 @@ do\n     make_dir $h/test/doc-guide-container\n     make_dir $h/test/doc-guide-tasks\n     make_dir $h/test/doc-guide-conditions\n+    make_dir $h/test/doc-complement-cheatsheet\n     make_dir $h/test/doc-rust\n done\n "}, {"sha": "4c106a357e689928f34bc45849bc344a7fc5c7ed", "filename": "doc/complement-cheatsheet.md", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcomplement-cheatsheet.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -6,113 +6,116 @@\n \n Use [`ToStr`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToStr.html).\n \n-```rust\n+~~~\n let x: int = 42;\n let y: ~str = x.to_str();\n-```\n+~~~\n \n **String to int**\n \n Use [`FromStr`](http://static.rust-lang.org/doc/master/std/from_str/trait.FromStr.html), and its helper function, [`from_str`](http://static.rust-lang.org/doc/master/std/from_str/fn.from_str.html).\n \n-```rust\n+~~~\n let x: Option<int> = from_str(\"42\");\n let y: int = x.unwrap();\n-```\n+~~~\n \n **Int to string, in non-base-10**\n \n Use [`ToStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.ToStrRadix.html).\n \n-```rust\n+~~~\n use std::num::ToStrRadix;\n \n let x: int = 42;\n let y: ~str = x.to_str_radix(16);\n-```\n+~~~\n \n **String to int, in non-base-10**\n \n Use [`FromStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.FromStrRadix.html), and its helper function, [`from_str_radix`](http://static.rust-lang.org/doc/master/std/num/fn.from_str_radix.html).\n \n-```rust\n+~~~\n use std::num::from_str_radix;\n \n-let x: Option<int> = from_str_radix(\"deadbeef\", 16);\n-let y: int = x.unwrap();\n-```\n+let x: Option<i64> = from_str_radix(\"deadbeef\", 16);\n+let y: i64 = x.unwrap();\n+~~~\n \n # File operations\n \n ## How do I read from a file?\n \n Use [`File::open`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html#method.open) to create a [`File`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html) struct, which implements the [`Reader`](http://static.rust-lang.org/doc/master/std/io/trait.Reader.html) trait.\n \n-```rust\n+~~~ {.xfail-test}\n use std::path::Path;\n use std::io::fs::File;\n \n let path : Path   = Path::new(\"Doc-FAQ-Cheatsheet.md\");\n let on_error      = || fail!(\"open of {:?} failed\", path);\n let reader : File = File::open(&path).unwrap_or_else(on_error);\n-```\n+~~~\n \n ## How do I iterate over the lines in a file?\n \n Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer.html#method.lines) method on a [`BufferedReader`](http://static.rust-lang.org/doc/master/std/io/buffered/struct.BufferedReader.html).\n \n-```rust\n+~~~\n use std::io::buffered::BufferedReader;\n+# use std::io::mem::MemReader;\n+\n+# let reader = MemReader::new(~[]);\n \n let mut reader = BufferedReader::new(reader);\n for line in reader.lines() {\n     print!(\"line: {}\", line);\n }\n-```\n+~~~\n \n # String operations\n \n ## How do I search for a substring?\n \n Use the [`find_str`](http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html#tymethod.find_str) method.\n \n-```rust\n+~~~\n let str = \"Hello, this is some random string\";\n let index: Option<uint> = str.find_str(\"rand\");\n-```\n+~~~\n \n # Containers\n \n ## How do I get the length of a vector?\n \n The [`Container`](http://static.rust-lang.org/doc/master/std/container/trait.Container.html) trait provides the `len` method.\n \n-```rust\n+~~~\n let u: ~[u32] = ~[0, 1, 2];\n let v: &[u32] = &[0, 1, 2, 3];\n let w: [u32, .. 5] = [0, 1, 2, 3, 4];\n \n println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len()); // 3, 4, 5\n-```\n+~~~\n \n ## How do I iterate over a vector?\n \n Use the [`iter`](http://static.rust-lang.org/doc/master/std/vec/trait.ImmutableVector.html#tymethod.iter) method.\n \n-```rust\n+~~~\n let values: ~[int] = ~[1, 2, 3, 4, 5];\n for value in values.iter() {  // value: &int\n     println!(\"{}\", *value);\n }\n-```\n+~~~\n \n (See also [`mut_iter`](http://static.rust-lang.org/doc/master/std/vec/trait.MutableVector.html#tymethod.mut_iter) which yields `&mut int` and [`move_iter`](http://static.rust-lang.org/doc/master/std/vec/trait.OwnedVector.html#tymethod.move_iter) which yields `int` while consuming the `values` vector.)\n \n # Type system\n \n ## How do I store a function in a struct?\n \n-```rust\n+~~~\n struct Foo {\n     myfunc: fn(int, uint) -> i32\n }\n@@ -131,24 +134,27 @@ fn main() {\n     println!(\"{}\", (f.myfunc)(1, 2));\n     println!(\"{}\", (g.myfunc)(3, 4));\n }\n-```\n+~~~\n \n Note that the parenthesis surrounding `f.myfunc` are necessary: they are how Rust disambiguates field lookup and method call. The `'a` on `FooClosure` is the lifetime of the closure's environment pointer.\n \n ## How do I express phantom types?\n \n [Phantom types](http://www.haskell.org/haskellwiki/Phantom_type) are those that cannot be constructed at compile time. To express these in Rust, zero-variant `enum`s can be used:\n \n-```rust\n+~~~\n enum Open {}\n enum Closed {}\n-```\n+~~~\n \n Phantom types are useful for enforcing state at compile time. For example:\n \n-```rust\n+~~~\n struct Door<State>(~str);\n \n+struct Open;\n+struct Closed;\n+\n fn close(Door(name): Door<Open>) -> Door<Closed> {\n     Door::<Closed>(name)\n }\n@@ -157,40 +163,45 @@ fn open(Door(name): Door<Closed>) -> Door<Open> {\n     Door::<Open>(name)\n }\n \n-let _ = close(Door::<Open>(~\"front\"));   // ok\n+let _ = close(Door::<Open>(~\"front\"));\n+~~~\n+\n+Attempting to close a closed door is prevented statically:\n+\n+~~~ {.xfail-test}\n let _ = close(Door::<Closed>(~\"front\")); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n-```\n+~~~\n \n # FFI (Foreign Function Interface)\n \n ## C function signature conversions\n \n-Description           | C signature                                  | Equivalent Rust signature\n-----------------------|----------------------------------------------|------------------------------------------\n-no parameters         | `void foo(void);`                            | `fn foo();`\n-return value          | `int foo(void);`                             | `fn foo() -> c_int;`\n-function parameters   | `void foo(int x, int y);`                    | `fn foo(x: int, y: int);`\n-in-out pointers       | `void foo(const int* in_ptr, int* out_ptr);` | `fn foo(in_ptr: *c_int, out_ptr: *mut c_int);`\n+Description            C signature                                    Equivalent Rust signature\n+---------------------- ---------------------------------------------- ------------------------------------------\n+no parameters          `void foo(void);`                              `fn foo();`\n+return value           `int foo(void);`                               `fn foo() -> c_int;`\n+function parameters    `void foo(int x, int y);`                      `fn foo(x: int, y: int);`\n+in-out pointers        `void foo(const int* in_ptr, int* out_ptr);`   `fn foo(in_ptr: *c_int, out_ptr: *mut c_int);`\n \n Note: The Rust signatures should be wrapped in an `extern \"ABI\" { ... }` block.\n \n ### Representing opaque handles\n \n You might see things like this in C APIs:\n \n-```c\n+~~~ {.notrust}\n typedef struct Window Window;\n Window* createWindow(int width, int height);\n-```\n+~~~\n \n You can use a zero-element `enum` ([phantom type](#how-do-i-express-phantom-types)) to represent the opaque object handle. The FFI would look like this:\n \n-```rust\n+~~~ {.xfail-test}\n enum Window {}\n extern \"C\" {\n     fn createWindow(width: c_int, height: c_int) -> *Window;\n }\n-```\n+~~~\n \n Using a phantom type ensures that the handles cannot be (safely) constructed in client code.\n \n@@ -200,4 +211,4 @@ For small examples, have full type annotations, as much as is reasonable, to kee\n \n Similar documents for other programming languages:\n \n-  * [http://pleac.sourceforge.net/](http://pleac.sourceforge.net)  \n+  * [http://pleac.sourceforge.net/](http://pleac.sourceforge.net)"}, {"sha": "6a96a7728deb9a3fa7d4aef73b71d78d3ade3736", "filename": "doc/complement-lang-faq.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcomplement-lang-faq.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -218,13 +218,13 @@ They start small (ideally in the hundreds of bytes) and expand dynamically by ca\n * Managed boxes may not be shared between tasks\n * Owned boxes may be transferred (moved) between tasks\n \n-## What is the difference between a borrowed pointer (`&`) and managed and owned boxes?\n+## What is the difference between a reference (`&`) and managed and owned boxes?\n \n-* Borrowed pointers point to the interior of a stack _or_ heap allocation\n-* Borrowed pointers can only be formed when it will provably be outlived by the referent\n-* Borrowed pointers to managed box pointers keep the managed boxes alive\n-* Borrowed pointers to owned boxes prevent their ownership from being transferred\n-* Borrowed pointers employ region-based alias analysis to ensure correctness\n+* References point to the interior of a stack _or_ heap allocation\n+* References can only be formed when it will provably be outlived by the referent\n+* References to managed box pointers keep the managed boxes alive\n+* References to owned boxes prevent their ownership from being transferred\n+* References employ region-based alias analysis to ensure correctness\n \n ## Why aren't function signatures inferred? Why only local slots?\n "}, {"sha": "2b5b9bbd5fe989f09690c0971e64994d091f7fc1", "filename": "doc/guide-conditions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-conditions.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Condition and Error-handling Guide\n+% The Rust Condition and Error-handling Guide\n \n # Introduction\n "}, {"sha": "ed350763fa39da0567d82f290ef5ad82c2b851fd", "filename": "doc/guide-container.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-container.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Containers and Iterators Guide\n+% The Rust Containers and Iterators Guide\n \n # Containers\n "}, {"sha": "43ba0c5d4433447301030ed2486ec410579a2e89", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Foreign Function Interface Guide\n+% The Rust Foreign Function Interface Guide\n \n # Introduction\n \n@@ -417,7 +417,7 @@ However, there are currently no guarantees about the layout of an `enum`.\n \n Rust's owned and managed boxes use non-nullable pointers as handles which point to the contained\n object. However, they should not be manually created because they are managed by internal\n-allocators. Borrowed pointers can safely be assumed to be non-nullable pointers directly to the\n+allocators. References can safely be assumed to be non-nullable pointers directly to the\n type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so\n prefer using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions\n about them."}, {"sha": "ad1fed54c97262b9ed9a589c5cc9ad690008e50a", "filename": "doc/guide-lifetimes.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-lifetimes.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,31 +1,31 @@\n-% Rust Borrowed Pointers Guide\n+% The Rust References and Lifetimes Guide\n \n # Introduction\n \n-Borrowed pointers are one of the more flexible and powerful tools available in\n-Rust. A borrowed pointer can point anywhere: into the managed or exchange\n+References are one of the more flexible and powerful tools available in\n+Rust. A reference can point anywhere: into the managed or exchange\n heap, into the stack, and even into the interior of another data structure. A\n-borrowed pointer is as flexible as a C pointer or C++ reference. However,\n+reference is as flexible as a C pointer or C++ reference. However,\n unlike C and C++ compilers, the Rust compiler includes special static checks\n-that ensure that programs use borrowed pointers safely. Another advantage of\n-borrowed pointers is that they are invisible to the garbage collector, so\n-working with borrowed pointers helps reduce the overhead of automatic memory\n+that ensure that programs use references safely. Another advantage of\n+references is that they are invisible to the garbage collector, so\n+working with references helps reduce the overhead of automatic memory\n management.\n \n-Despite their complete safety, a borrowed pointer's representation at runtime\n+Despite their complete safety, a reference's representation at runtime\n is the same as that of an ordinary pointer in a C program. They introduce zero\n overhead. The compiler does all safety checks at compile time.\n \n-Although borrowed pointers have rather elaborate theoretical\n+Although references have rather elaborate theoretical\n underpinnings (region pointers), the core concepts will be familiar to\n anyone who has worked with C or C++. Therefore, the best way to explain\n how they are used\u2014and their limitations\u2014is probably just to work\n through several examples.\n \n # By example\n \n-Borrowed pointers are called *borrowed* because they are only valid for\n-a limited duration. Borrowed pointers never claim any kind of ownership\n+References, sometimes known as *borrowed pointers*, are only valid for\n+a limited duration. References never claim any kind of ownership\n over the data that they point to: instead, they are used for cases\n where you would like to use data for a short time.\n \n@@ -55,7 +55,7 @@ define it this way, calling the function will cause the points to be\n copied. For points, this is probably not so bad, but often copies are\n expensive. Worse, if the data type contains mutable fields, copying can change\n the semantics of your program in unexpected ways. So we'd like to define a\n-function that takes the points by pointer. We can use borrowed pointers to do\n+function that takes the points by pointer. We can use references to do\n this:\n \n ~~~\n@@ -89,7 +89,7 @@ name for the same data.\n \n In contrast, we can pass the boxes `managed_box` and `owned_box` to\n `compute_distance` directly. The compiler automatically converts a box like\n-`@Point` or `~Point` to a borrowed pointer like `&Point`. This is another form\n+`@Point` or `~Point` to a reference like `&Point`. This is another form\n of borrowing: in this case, the caller lends the contents of the managed or\n owned box to the callee.\n \n@@ -100,7 +100,7 @@ addition, the compiler will reject any code that might cause the borrowed\n value to be freed or overwrite its component fields with values of different\n types (I'll get into what kinds of actions those are shortly). This rule\n should make intuitive sense: you must wait for a borrower to return the value\n-that you lent it (that is, wait for the borrowed pointer to go out of scope)\n+that you lent it (that is, wait for the reference to go out of scope)\n before you can make full use of it again.\n \n # Other uses for the & operator\n@@ -114,7 +114,7 @@ let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n \n This declaration means that code can only pass `Point` by value to other\n functions. As a consequence, we had to explicitly take the address of\n-`on_the_stack` to get a borrowed pointer. Sometimes however it is more\n+`on_the_stack` to get a reference. Sometimes however it is more\n convenient to move the & operator into the definition of `on_the_stack`:\n \n ~~~\n@@ -180,7 +180,7 @@ as well as from the managed box, and then compute the distance between them.\n \n We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n and owned. Up till this point, we\u2019ve glossed over issues of\n-safety. As stated in the introduction, at runtime a borrowed pointer\n+safety. As stated in the introduction, at runtime a reference\n is simply a pointer, nothing more. Therefore, avoiding C's problems\n with dangling pointers requires a compile-time safety check.\n \n@@ -195,7 +195,7 @@ broader scope than the pointer itself), the compiler reports an\n error. We'll be discussing lifetimes more in the examples to come, and\n a more thorough introduction is also available.\n \n-When the `&` operator creates a borrowed pointer, the compiler must\n+When the `&` operator creates a reference, the compiler must\n ensure that the pointer remains valid for its entire\n lifetime. Sometimes this is relatively easy, such as when taking the\n address of a local variable or a field that is stored on the stack:\n@@ -209,7 +209,7 @@ fn example1() {\n }                      // -+\n ~~~\n \n-Here, the lifetime of the borrowed pointer `y` is simply L, the\n+Here, the lifetime of the reference `y` is simply L, the\n remainder of the function body. The compiler need not do any other\n work to prove that code will not free `x.f`. This is true even if the\n code mutates `x`.\n@@ -384,7 +384,7 @@ enum Shape {\n ~~~\n \n Now we might write a function to compute the area of a shape. This\n-function takes a borrowed pointer to a shape, to avoid the need for\n+function takes a reference to a shape, to avoid the need for\n copying.\n \n ~~~\n@@ -466,19 +466,19 @@ same rules as the ones we saw for borrowing the interior of a owned\n box: it must be able to guarantee that the `enum` will not be\n overwritten for the duration of the borrow.  In fact, the compiler\n would accept the example we gave earlier. The example is safe because\n-the shape pointer has type `&Shape`, which means \"borrowed pointer to\n+the shape pointer has type `&Shape`, which means \"reference to\n immutable memory containing a `shape`\". If, however, the type of that\n pointer were `&mut Shape`, then the ref binding would be ill-typed.\n Just as with owned boxes, the compiler will permit `ref` bindings\n into data owned by the stack frame even if the data are mutable,\n but otherwise it requires that the data reside in immutable memory.\n \n-# Returning borrowed pointers\n+# Returning references\n \n-So far, all of the examples we have looked at, use borrowed pointers in a\n+So far, all of the examples we have looked at, use references in a\n \u201cdownward\u201d direction. That is, a method or code block creates a\n-borrowed pointer, then uses it within the same scope. It is also\n-possible to return borrowed pointers as the result of a function, but\n+reference, then uses it within the same scope. It is also\n+possible to return references as the result of a function, but\n as we'll see, doing so requires some explicit annotation.\n \n For example, we could write a subroutine like this:\n@@ -496,7 +496,7 @@ explicitly. So in effect, this function declares that it takes a\n pointer with lifetime `r` and returns a pointer with that same\n lifetime.\n \n-In general, it is only possible to return borrowed pointers if they\n+In general, it is only possible to return references if they\n are derived from a parameter to the procedure. In that case, the\n pointer result will always have the same lifetime as one of the\n parameters; named lifetimes indicate which parameter that\n@@ -532,10 +532,10 @@ fn get_x_sh(p: @Point) -> &f64 {\n ~~~\n \n Here, the function `get_x_sh()` takes a managed box as input and\n-returns a borrowed pointer. As before, the lifetime of the borrowed\n-pointer that will be returned is a parameter (specified by the\n-caller). That means that `get_x_sh()` promises to return a borrowed\n-pointer that is valid for as long as the caller would like: this is\n+returns a reference. As before, the lifetime of the reference\n+that will be returned is a parameter (specified by the\n+caller). That means that `get_x_sh()` promises to return a reference\n+that is valid for as long as the caller would like: this is\n subtly different from the first example, which promised to return a\n pointer that was valid for as long as its pointer argument was valid.\n \n@@ -551,10 +551,10 @@ valid at all once it returns, as the parameter `p` may or may not be\n live in the caller. Therefore, the compiler will report an error here.\n \n In general, if you borrow a managed (or owned) box to create a\n-borrowed pointer, the pointer will only be valid within the function\n-and cannot be returned. This is why the typical way to return borrowed\n-pointers is to take borrowed pointers as input (the only other case in\n-which it can be legal to return a borrowed pointer is if the pointer\n+reference, it will only be valid within the function\n+and cannot be returned. This is why the typical way to return references\n+is to take references as input (the only other case in\n+which it can be legal to return a reference is if it\n points at a static constant).\n \n # Named lifetimes\n@@ -577,7 +577,7 @@ fn select<'r, T>(shape: &'r Shape, threshold: f64,\n }\n ~~~\n \n-This function takes three borrowed pointers and assigns each the same\n+This function takes three references and assigns each the same\n lifetime `r`.  In practice, this means that, in the caller, the\n lifetime `r` will be the *intersection of the lifetime of the three\n region parameters*. This may be overly conservative, as in this\n@@ -657,7 +657,7 @@ This is equivalent to the previous definition.\n \n # Conclusion\n \n-So there you have it: a (relatively) brief tour of the borrowed pointer\n+So there you have it: a (relatively) brief tour of the lifetime\n system. For more details, we refer to the (yet to be written) reference\n-document on borrowed pointers, which will explain the full notation\n+document on references, which will explain the full notation\n and give more examples."}, {"sha": "b8ebca206d561849b5605e76709b602738274c8a", "filename": "doc/guide-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-macros.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Macros Guide\n+% The Rust Macros Guide\n \n # Introduction\n "}, {"sha": "57a0b773d433ac3434dfd70dc74920e5e672ca27", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -3,7 +3,7 @@\n Rust's pointers are one of its more unique and compelling features. Pointers\n are also one of the more confusing topics for newcomers to Rust. They can also\n be confusing for people coming from other languages that support pointers, such\n-as C++. This tutorial will help you understand this important topic.\n+as C++. This guide will help you understand this important topic.\n \n # You don't actually need pointers\n \n@@ -13,16 +13,15 @@ that emphasizes safety. Pointers, as the joke goes, are very pointy: it's easy\n to accidentally stab yourself. Therefore, Rust is made in a way such that you\n don't need them very often.\n \n-\"But tutorial!\" you may cry. \"My co-worker wrote a function that looks like\n-this:\n+\"But guide!\" you may cry. \"My co-worker wrote a function that looks like this:\n \n ~~~rust\n fn succ(x: &int) -> int { *x + 1 }\n ~~~\n \n So I wrote this code to try it out:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     let number = 5;\n     let succ_number = succ(number);\n@@ -74,7 +73,7 @@ However.\n Here are the use-cases for pointers. I've prefixed them with the name of the\n pointer that satisfies that use-case:\n \n-1. Owned: ~Trait must be a pointer, becuase you don't know the size of the\n+1. Owned: ~Trait must be a pointer, because you don't know the size of the\n object, so indirection is mandatory.\n 2. Owned: You need a recursive data structure. These can be infinite sized, so\n indirection is mandatory.\n@@ -86,18 +85,18 @@ common, such as C++, please read \"A note...\" below.\n or impossible. This is only often useful when a program is very large or very\n complicated. Using a managed pointer will activate Rust's garbage collection\n mechanism.\n-5: Borrowed: You're writing a function, and you need a pointer, but you don't\n-care about its ownership. If you make the argument a borrowed pointer, callers\n+5. Reference: You're writing a function, and you need a pointer, but you don't\n+care about its ownership. If you make the argument a reference, callers\n can send in whatever kind they want.\n \n-Five exceptions. That's it. Otherwise, you shouldn't need them. Be skeptical\n+Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n of pointers in Rust: use them for a deliberate purpose, not just to make the\n compiler happy.\n \n ## A note for those proficient in pointers\n \n If you're coming to Rust from a language like C or C++, you may be used to\n-passing things by reference, or passing things by pointer. In some langauges,\n+passing things by reference, or passing things by pointer. In some languages,\n like Java, you can't even have objects without a pointer to them. Therefore, if\n you were writing this Rust code:\n \n@@ -151,7 +150,7 @@ fn main() {\n }\n ~~~\n \n-But won't this be inefficent? Well, that's a complicated question, but it's\n+But won't this be inefficient? Well, that's a complicated question, but it's\n important to know that Rust, like C and C++, store aggregate data types\n 'unboxed,' whereas languages like Java and Ruby store these types as 'boxed.'\n For smaller structs, this way will be more efficient. For larger ones, it may\n@@ -174,7 +173,7 @@ These two properties make for three use cases.\n \n ## References to Traits\n \n-Traits must be referenced through a pointer, becuase the struct that implements\n+Traits must be referenced through a pointer, because the struct that implements\n the trait may be a different size than a different struct that implements the\n trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n \n@@ -200,7 +199,7 @@ This prints:\n Cons(1, ~Cons(2, ~Cons(3, ~Nil)))\n ~~~\n \n-The inner lists _must_ be an owned pointer, becuase we can't know how many\n+The inner lists _must_ be an owned pointer, because we can't know how many\n elements are in the list. Without knowing the length, we don't know the size,\n and therefore require the indirection that pointers offer.\n \n@@ -250,13 +249,19 @@ struct.\n \n # Managed Pointers\n \n+> **Note**: the `@` form of managed pointers is deprecated and behind a\n+> feature gate (it requires a `#[feature(managed_pointers)];` attribute on\n+> the crate root; remember the semicolon!). There are replacements, currently \n+> there is `std::rc::Rc` and `std::gc::Gc` for shared ownership via reference\n+> counting and garbage collection respectively.\n+\n Managed pointers, notated by an `@`, are used when having a single owner for\n some data isn't convenient or possible. This generally happens when your\n program is very large and complicated.\n \n For example, let's say you're using an owned pointer, and you want to do this:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n struct Point {\n     x: int,\n     y: int,\n@@ -310,14 +315,14 @@ managed pointers:\n 1. They activate Rust's garbage collector. Other pointer types don't share this\n drawback.\n 2. You cannot pass this data to another task. Shared ownership across\n-concurrency boundaries is the source of endless pain in other langauges, so\n+concurrency boundaries is the source of endless pain in other languages, so\n Rust does not let you do this.\n \n-# Borrowed Pointers\n+# References\n \n-Borrowed pointers are the third major kind of pointer Rust supports. They are\n+References are the third major kind of pointer Rust supports. They are\n simultaneously the simplest and the most complicated kind. Let me explain:\n-they're called 'borrowed' pointers because they claim no ownership over the\n+references are considered 'borrowed' because they claim no ownership over the\n data they're pointing to. They're just borrowing it for a while. So in that\n sense, they're simple: just keep whatever ownership the data already has. For\n example:\n@@ -346,41 +351,41 @@ fn main() {\n ~~~\n \n This prints `5.83095189`. You can see that the `compute_distance` function\n-takes in two borrowed pointers, but we give it a managed and unique pointer. Of\n+takes in two references, but we give it a managed and unique pointer. Of\n course, if this were a real program, we wouldn't have any of these pointers,\n they're just there to demonstrate the concepts.\n \n-So how is this hard? Well, because we're igorning ownership, the compiler needs\n+So how is this hard? Well, because we're ignoring ownership, the compiler needs\n to take great care to make sure that everything is safe. Despite their complete\n-safety, a borrowed pointer's representation at runtime is the same as that of\n+safety, a reference's representation at runtime is the same as that of\n an ordinary pointer in a C program. They introduce zero overhead. The compiler\n does all safety checks at compile time. \n \n This theory is called 'region pointers,' and involve a concept called\n 'lifetimes'. Here's the simple explanation: would you expect this code to\n compile?\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     println(x.to_str());\n     let x = 5;\n }\n ~~~\n \n-Probably not. That's becuase you know that the name `x` is valid from where\n+Probably not. That's because you know that the name `x` is valid from where\n it's declared to when it goes out of scope. In this case, that's the end of\n the `main` function. So you know this code will cause an error. We call this\n duration a 'lifetime'. Let's try a more complex example:\n \n ~~~rust\n fn main() {\n     let mut x = ~5;\n-    if(*x < 10) {\n+    if *x < 10 {\n         let y = &x;\n         println!(\"Oh no: {:?}\", y);\n         return;\n     }\n-    *x = *x - 1;\n+    *x -= 1;\n     println!(\"Oh no: {:?}\", x);\n }\n ~~~\n@@ -389,17 +394,17 @@ Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however\n is able to determine that that pointer will go out of scope without `x` being\n mutated, and therefore, lets us pass. This wouldn't work:\n \n-~~~rust {.xfail-test}\n+~~~rust{.xfail-test}\n fn main() {\n     let mut x = ~5;\n-    if(*x < 10) {\n+    if *x < 10 {\n         let y = &x;\n-        *x = *x - 1;\n+        *x -= 1;\n \n         println!(\"Oh no: {:?}\", y);\n         return;\n     }\n-    *x = *x - 1;\n+    *x -= 1;\n     println!(\"Oh no: {:?}\", x);\n }\n ~~~\n@@ -408,21 +413,21 @@ It gives this error:\n \n ~~~ {.notrust}\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n-test.rs:5         *x = *x - 1;\n+test.rs:5         *x -= 1;\n                   ^~\n test.rs:4:16: 4:18 note: borrow of `*x` occurs here\n test.rs:4         let y = &x;\n                           ^~\n ~~~\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n-hard for a computer, too! There is an entire [tutorial devoted to borrowed\n-pointers and lifetimes](tutorial-lifetimes.html) that goes into lifetimes in\n+hard for a computer, too! There is an entire [guide devoted to references\n+and lifetimes](guide-lifetimes.html) that goes into lifetimes in\n great detail, so if you want the full details, check that out.\n \n # Returning Pointers\n \n-We've talked a lot about funtions that accept various kinds of pointers, but\n+We've talked a lot about functions that accept various kinds of pointers, but\n what about returning them? Here's the rule of thumb: only return a unique or\n managed pointer if you were given one in the first place.\n \n@@ -469,8 +474,9 @@ fn main() {\n You may think that this gives us terrible performance: return a value and then\n immediately box it up?!?! Isn't that the worst of both worlds? Rust is smarter\n than that. There is no copy in this code. `main` allocates enough room for the\n-`@int`, passes it into `foo` as `x`, and then `foo` writes the value into the\n-new box. This writes the return value directly into the allocated box.\n+`@int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes \n+the value straight into that pointer. This writes the return value directly into\n+the allocated box.\n \n This is important enough that it bears repeating: pointers are not for optimizing\n returning values from your code. Allow the caller to choose how they want to\n@@ -479,4 +485,4 @@ use your output.\n \n # Related Resources\n \n-* [Lifetimes tutorial](tutorial-lifetimes.html)\n+* [Lifetimes guide](guide-lifetimes.html)"}, {"sha": "a8265cc5b7a68fa50b01895e1bd751d1d5ae7634", "filename": "doc/guide-rustpkg.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-rustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-rustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-rustpkg.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Packaging Guide\n+% The Rust Packaging Guide\n \n # Introduction\n "}, {"sha": "57ed788aa2aea15043c2e77b6a0baf24a36498e4", "filename": "doc/guide-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-tasks.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Tasks and Communication Guide\n+% The Rust Tasks and Communication Guide\n \n # Introduction\n "}, {"sha": "b56cea12273f434a0f23113b455ecb766516d1e6", "filename": "doc/guide-testing.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-testing.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,10 +1,10 @@\n-% Rust Testing Guide\n+% The Rust Testing Guide\n \n # Quick start\n \n To create test functions, add a `#[test]` attribute like this:\n \n-```rust\n+~~~\n fn return_two() -> int {\n     2\n }\n@@ -14,17 +14,17 @@ fn return_two_test() {\n     let x = return_two();\n     assert!(x == 2);\n }\n-```\n+~~~\n \n To run these tests, use `rustc --test`:\n \n-```\n+~~~ {.notrust}\n $ rustc --test foo.rs; ./foo\n running 1 test\n test return_two_test ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-```\n+~~~\n \n `rustc foo.rs` will *not* compile the tests, since `#[test]` implies\n `#[cfg(test)]`. The `--test` flag to `rustc` implies `--cfg test`.\n@@ -35,12 +35,12 @@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n Rust has built in support for simple unit testing. Functions can be\n marked as unit tests using the 'test' attribute.\n \n-```rust\n+~~~\n #[test]\n fn return_none_if_empty() {\n     // ... test code ...\n }\n-```\n+~~~\n \n A test function's signature must have no arguments and no return\n value. To run the tests in a crate, it must be compiled with the\n@@ -54,15 +54,15 @@ then the test fails.\n When compiling a crate with the '--test' flag '--cfg test' is also\n implied, so that tests can be conditionally compiled.\n \n-```rust\n+~~~\n #[cfg(test)]\n mod tests {\n     #[test]\n     fn return_none_if_empty() {\n       // ... test code ...\n     }\n }\n-```\n+~~~\n \n Additionally #[test] items behave as if they also have the\n #[cfg(test)] attribute, and will not be compiled when the --test flag\n@@ -79,14 +79,14 @@ Tests that are intended to fail can be annotated with the\n task to fail then the test will be counted as successful; otherwise it\n will be counted as a failure. For example:\n \n-```rust\n+~~~\n #[test]\n #[should_fail]\n fn test_out_of_bounds_failure() {\n     let v: [int] = [];\n     v[0];\n }\n-```\n+~~~\n \n A test runner built with the '--test' flag supports a limited set of\n arguments to control which tests are run: the first free argument\n@@ -126,7 +126,7 @@ amount.\n \n For example:\n \n-```rust\n+~~~\n extern mod extra;\n use std::vec;\n \n@@ -141,7 +141,7 @@ fn initialise_a_vector(b: &mut extra::test::BenchHarness) {\n     b.iter(|| {vec::from_elem(1024, 0u64);} );\n     b.bytes = 1024 * 8;\n }\n-```\n+~~~\n \n The benchmark runner will calibrate measurement of the benchmark\n function to run the `iter` block \"enough\" times to get a reliable\n@@ -168,7 +168,7 @@ test-runner. Benchmarks are compiled-in but not executed by default.\n \n ### Typical test run\n \n-```\n+~~~ {.notrust}\n > mytests\n \n running 30 tests\n@@ -178,11 +178,11 @@ running driver::tests::mytest2 ... ignored\n running driver::tests::mytest30 ... ok\n \n result: ok. 28 passed; 0 failed; 2 ignored\n-```\n+~~~ {.notrust}\n \n ### Test run with failures\n \n-```\n+~~~ {.notrust}\n > mytests\n \n running 30 tests\n@@ -192,23 +192,23 @@ running driver::tests::mytest2 ... ignored\n running driver::tests::mytest30 ... FAILED\n \n result: FAILED. 27 passed; 1 failed; 2 ignored\n-```\n+~~~\n \n ### Running ignored tests\n \n-```\n+~~~ {.notrust}\n > mytests --ignored\n \n running 2 tests\n running driver::tests::mytest2 ... failed\n running driver::tests::mytest10 ... ok\n \n result: FAILED. 1 passed; 1 failed; 0 ignored\n-```\n+~~~\n \n ### Running a subset of tests\n \n-```\n+~~~ {.notrust}\n > mytests mytest1\n \n running 11 tests\n@@ -218,19 +218,19 @@ running driver::tests::mytest10 ... ignored\n running driver::tests::mytest19 ... ok\n \n result: ok. 11 passed; 0 failed; 1 ignored\n-```\n+~~~\n \n ### Running benchmarks\n \n-```\n+~~~ {.notrust}\n > mytests --bench\n \n running 2 tests\n test bench_sum_1024_ints ... bench: 709 ns/iter (+/- 82)\n test initialise_a_vector ... bench: 424 ns/iter (+/- 99) = 19320 MB/s\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured\n-```\n+~~~\n \n ## Saving and ratcheting metrics\n "}, {"sha": "5ee7fccc48cb76cd6d96a653ad5a5c8e095c94df", "filename": "doc/index.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Findex.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -12,7 +12,7 @@\n # Guides\n \n [Pointers](guide-pointers.html)  \n-[Lifetimes](guide-lifetimes.html)  \n+[References and Lifetimes](guide-lifetimes.html)  \n [Containers and Iterators](guide-container.html)  \n [Tasks and Communication](guide-tasks.html)  \n [Foreign Function Interface](guide-ffi.html)  \n@@ -24,7 +24,11 @@\n # Libraries\n \n [std](std/index.html)  \n-[extra](index.html)  \n+[extra](extra/index.html)  \n+[green](green/index.html)  \n+[native](native/index.html)  \n+[syntax](syntax/index.html)  \n+[rustc](rustc/index.html)  \n \n # Tooling\n "}, {"sha": "0024bb71116579c1827c9089d1a5d8c14cf48655", "filename": "doc/rust.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,4 +1,4 @@\n-% Rust Reference Manual\n+% The Rust Reference Manual\n \n # Introduction\n \n@@ -1215,7 +1215,7 @@ A static item must have a _constant expression_ giving its definition.\n \n Static items must be explicitly typed.\n The type may be ```bool```, ```char```, a number, or a type derived from those primitive types.\n-The derived types are borrowed pointers with the `'static` lifetime,\n+The derived types are references with the `'static` lifetime,\n fixed-size arrays, tuples, and structs.\n \n ~~~~\n@@ -1841,7 +1841,7 @@ A complete list of the built-in language items follows:\n `owned`\n   : Are uniquely owned.\n `durable`\n-  : Contain borrowed pointers.\n+  : Contain references.\n `drop`\n   : Have finalizers.\n `add`\n@@ -1898,11 +1898,11 @@ A complete list of the built-in language items follows:\n `free`\n   : Free memory that was allocated on the managed heap.\n `borrow_as_imm`\n-  : Create an immutable borrowed pointer to a mutable value.\n+  : Create an immutable reference to a mutable value.\n `return_to_mut`\n-  : Release a borrowed pointer created with `return_to_mut`\n+  : Release a reference created with `return_to_mut`\n `check_not_borrowed`\n-  : Fail if a value has existing borrowed pointers to it.\n+  : Fail if a value has existing references to it.\n `strdup_uniq`\n   : Return a new unique string\n     containing a copy of the contents of a unique string.\n@@ -2199,7 +2199,7 @@ When an lvalue is evaluated in an _lvalue context_, it denotes a memory location\n when evaluated in an _rvalue context_, it denotes the value held _in_ that memory location.\n \n When an rvalue is used in lvalue context, a temporary un-named lvalue is created and used instead.\n-A temporary's lifetime equals the largest lifetime of any borrowed pointer that points to it.\n+A temporary's lifetime equals the largest lifetime of any reference that points to it.\n \n #### Moved and copied types\n \n@@ -2403,8 +2403,8 @@ before the expression they apply to.\n   :  [Boxing](#pointer-types) operators. Allocate a box to hold the value they are applied to,\n      and store the value in it. `@` creates a managed box, whereas `~` creates an owned box.\n `&`\n-  : Borrow operator. Returns a borrowed pointer, pointing to its operand.\n-    The operand of a borrowed pointer is statically proven to outlive the resulting pointer.\n+  : Borrow operator. Returns a reference, pointing to its operand.\n+    The operand of a borrow is statically proven to outlive the resulting pointer.\n     If the borrow-checker cannot prove this, it is a compilation error.\n \n ### Binary operator expressions\n@@ -2894,9 +2894,9 @@ match x {\n Patterns that bind variables\n default to binding to a copy or move of the matched value\n (depending on the matched value's type).\n-This can be changed to bind to a borrowed pointer by\n+This can be changed to bind to a reference by\n using the ```ref``` keyword,\n-or to a mutable borrowed pointer using ```ref mut```.\n+or to a mutable reference using ```ref mut```.\n \n A pattern that's just an identifier,\n like `Nil` in the previous answer,\n@@ -3172,18 +3172,18 @@ Owning pointers (`~`)\n     it involves allocating a new owned box and copying the contents of the old box into the new box.\n     Releasing an owning pointer immediately releases its corresponding owned box.\n \n-Borrowed pointers (`&`)\n+References (`&`)\n   : These point to memory _owned by some other value_.\n-    Borrowed pointers arise by (automatic) conversion from owning pointers, managed pointers,\n+    References arise by (automatic) conversion from owning pointers, managed pointers,\n     or by applying the borrowing operator `&` to some other value,\n     including [lvalues, rvalues or temporaries](#lvalues-rvalues-and-temporaries).\n-    Borrowed pointers are written `&content`, or in some cases `&'f content` for some lifetime-variable `f`,\n-    for example `&int` means a borrowed pointer to an integer.\n-    Copying a borrowed pointer is a \"shallow\" operation:\n+    References are written `&content`, or in some cases `&'f content` for some lifetime-variable `f`,\n+    for example `&int` means a reference to an integer.\n+    Copying a reference is a \"shallow\" operation:\n     it involves only copying the pointer itself.\n-    Releasing a borrowed pointer typically has no effect on the value it points to,\n+    Releasing a reference typically has no effect on the value it points to,\n     with the exception of temporary values,\n-    which are released when the last borrowed pointer to them is released.\n+    which are released when the last reference to them is released.\n \n Raw pointers (`*`)\n   : Raw pointers are pointers without safety or liveness guarantees.\n@@ -3338,7 +3338,7 @@ The kinds are:\n     This kind includes scalars and immutable references,\n     as well as structural types containing other `Pod` types.\n `'static`\n-  : Types of this kind do not contain any borrowed pointers;\n+  : Types of this kind do not contain any references;\n     this can be a useful guarantee for code\n     that breaks borrowing assumptions\n     using [`unsafe` operations](#unsafe-functions).\n@@ -3417,14 +3417,14 @@ frame they are allocated within.\n ### Memory ownership\n \n A task owns all memory it can *safely* reach through local variables,\n-as well as managed, owning and borrowed pointers.\n+as well as managed, owned boxes and references.\n \n When a task sends a value that has the `Send` trait to another task,\n it loses ownership of the value sent and can no longer refer to it.\n This is statically guaranteed by the combined use of \"move semantics\",\n and the compiler-checked _meaning_ of the `Send` trait:\n it is only instantiated for (transitively) sendable kinds of data constructor and pointers,\n-never including managed or borrowed pointers.\n+never including managed boxes or references.\n \n When a stack frame is exited, its local allocations are all released, and its\n references to boxes (both managed and owned) are dropped.\n@@ -3569,7 +3569,7 @@ These include:\n   - simple locks and semaphores\n \n When such facilities carry values, the values are restricted to the [`Send` type-kind](#type-kinds).\n-Restricting communication interfaces to this kind ensures that no borrowed or managed pointers move between tasks.\n+Restricting communication interfaces to this kind ensures that no references or managed pointers move between tasks.\n Thus access to an entire data structure can be mediated through its owning \"root\" value;\n no further locking or copying is required to avoid data races within the substructure of such a value.\n "}, {"sha": "bb1ce35d8736c8452d4d219f4324ccbb87e42c3e", "filename": "doc/tutorial.md", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1341,11 +1341,12 @@ let mut y = ~5; // mutable\n *y += 2; // the * operator is needed to access the contained value\n ~~~~\n \n-# Borrowed pointers\n+# References\n \n-Rust's borrowed pointers are a general purpose reference type. In contrast with\n+In contrast with\n owned boxes, where the holder of an owned box is the owner of the pointed-to\n-memory, borrowed pointers never imply ownership. A pointer can be borrowed to\n+memory, references never imply ownership - they are \"borrowed\".\n+A reference can be borrowed to\n any object, and the compiler verifies that it cannot outlive the lifetime of\n the object.\n \n@@ -1377,7 +1378,7 @@ to define a function that takes two arguments of type point\u2014that is,\n it takes the points by value. But this will cause the points to be\n copied when we call the function. For points, this is probably not so\n bad, but often copies are expensive. So we\u2019d like to define a function\n-that takes the points by pointer. We can use borrowed pointers to do this:\n+that takes the points by pointer. We can use references to do this:\n \n ~~~\n # struct Point { x: f64, y: f64 }\n@@ -1410,7 +1411,7 @@ route to the same data.\n \n In the case of the boxes `managed_box` and `owned_box`, however, no\n explicit action is necessary. The compiler will automatically convert\n-a box like `@point` or `~point` to a borrowed pointer like\n+a box like `@point` or `~point` to a reference like\n `&point`. This is another form of borrowing; in this case, the\n contents of the managed/owned box are being lent out.\n \n@@ -1420,11 +1421,11 @@ have been lent out, you cannot send that variable to another task, nor\n will you be permitted to take actions that might cause the borrowed\n value to be freed or to change its type. This rule should make\n intuitive sense: you must wait for a borrowed value to be returned\n-(that is, for the borrowed pointer to go out of scope) before you can\n+(that is, for the reference to go out of scope) before you can\n make full use of it again.\n \n-For a more in-depth explanation of borrowed pointers and lifetimes, read the\n-[lifetimes and borrowed pointer tutorial][lifetimes].\n+For a more in-depth explanation of references and lifetimes, read the\n+[references and lifetimes guide][lifetimes].\n \n ## Freezing\n \n@@ -1622,8 +1623,7 @@ defined in [`std::vec`] and [`std::str`].\n \n # Ownership escape hatches\n \n-Ownership can cleanly describe tree-like data structures, and borrowed pointers provide non-owning\n-references. However, more flexibility is often desired and Rust provides ways to escape from strict\n+Ownership can cleanly describe tree-like data structures, and references provide non-owning pointers. However, more flexibility is often desired and Rust provides ways to escape from strict\n single parent ownership.\n \n The standard library provides the `std::rc::Rc` pointer type to express *shared ownership* over a\n@@ -1880,7 +1880,7 @@ A caller must in turn have a compatible pointer type to call the method.\n #     Rectangle(Point, Point)\n # }\n impl Shape {\n-    fn draw_borrowed(&self) { ... }\n+    fn draw_reference(&self) { ... }\n     fn draw_managed(@self) { ... }\n     fn draw_owned(~self) { ... }\n     fn draw_value(self) { ... }\n@@ -1890,13 +1890,13 @@ let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n \n (@s).draw_managed();\n (~s).draw_owned();\n-(&s).draw_borrowed();\n+(&s).draw_reference();\n s.draw_value();\n ~~~\n \n-Methods typically take a borrowed pointer self type,\n+Methods typically take a reference self type,\n so the compiler will go to great lengths to convert a callee\n-to a borrowed pointer.\n+to a reference.\n \n ~~~\n # fn draw_circle(p: Point, f: f64) { }\n@@ -1907,27 +1907,27 @@ to a borrowed pointer.\n #     Rectangle(Point, Point)\n # }\n # impl Shape {\n-#    fn draw_borrowed(&self) { ... }\n+#    fn draw_reference(&self) { ... }\n #    fn draw_managed(@self) { ... }\n #    fn draw_owned(~self) { ... }\n #    fn draw_value(self) { ... }\n # }\n # let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n // As with typical function arguments, managed and owned pointers\n-// are automatically converted to borrowed pointers\n+// are automatically converted to references\n \n-(@s).draw_borrowed();\n-(~s).draw_borrowed();\n+(@s).draw_reference();\n+(~s).draw_reference();\n \n // Unlike typical function arguments, the self value will\n // automatically be referenced ...\n-s.draw_borrowed();\n+s.draw_reference();\n \n // ... and dereferenced\n-(& &s).draw_borrowed();\n+(& &s).draw_reference();\n \n // ... and dereferenced and borrowed\n-(&@~s).draw_borrowed();\n+(&@~s).draw_reference();\n ~~~\n \n Implementations may also define standalone (sometimes called \"static\")\n@@ -2095,7 +2095,7 @@ and may not be overridden:\n \n * `Send` - Sendable types.\n Types are sendable\n-unless they contain managed boxes, managed closures, or borrowed pointers.\n+unless they contain managed boxes, managed closures, or references.\n \n * `Freeze` - Constant (immutable) types.\n These are types that do not contain anything intrinsically mutable.\n@@ -2104,7 +2104,7 @@ Intrinsically mutable values include `Cell` in the standard library.\n * `'static` - Non-borrowed types.\n These are types that do not contain any data whose lifetime is bound to\n a particular stack frame. These are types that do not contain any\n-borrowed pointers, or types where the only contained borrowed pointers\n+references, or types where the only contained references\n have the `'static` lifetime.\n \n > ***Note:*** These two traits were referred to as 'kinds' in earlier\n@@ -2439,7 +2439,7 @@ order to be packaged up in a trait object of that storage class.\n \n * The contents of owned traits (`~Trait`) must fulfill the `Send` bound.\n * The contents of managed traits (`@Trait`) must fulfill the `'static` bound.\n-* The contents of borrowed traits (`&Trait`) are not constrained by any bound.\n+* The contents of reference traits (`&Trait`) are not constrained by any bound.\n \n Consequently, the trait objects themselves automatically fulfill their\n respective kind bounds. However, this default behavior can be overridden by"}, {"sha": "d50f9878bd162d05d942b6ba40fd504487738074", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -22,6 +22,7 @@ TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n # Markdown files under doc/ that should have their code extracted and run\n DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-lifetimes \\\n                  guide-tasks guide-conditions guide-container guide-pointers \\\n+                 complement-cheatsheet \\\n                  rust\n \n ######################################################################"}, {"sha": "1c46055fff72eb9f7b98e0175692ae52b45bf000", "filename": "src/etc/pkg/rust.iss", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Fetc%2Fpkg%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Fetc%2Fpkg%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Frust.iss?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,5 +1,6 @@\n #define CFG_VERSION GetEnv(\"CFG_VERSION\")\n #define CFG_VERSION_WIN GetEnv(\"CFG_VERSION_WIN\")\n+#define CFG_RELEASE GetEnv(\"CFG_RELEASE\")\n \n [Setup]\n \n@@ -19,7 +20,7 @@ DisableStartupPrompt=true\n \n OutputDir=.\\\n SourceDir=.\\\n-OutputBaseFilename=rust-{#CFG_VERSION}-install\n+OutputBaseFilename=rust-{#CFG_RELEASE}-install\n DefaultDirName={pf32}\\Rust\n \n Compression=lzma2/ultra"}, {"sha": "c6c876aff79356ba80163cf34d9996e82ddbed26", "filename": "src/libextra/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -60,8 +60,8 @@ impl<A> Future<A> {\n \n     pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n-        * Executes the future's closure and then returns a borrowed\n-        * pointer to the result.  The borrowed pointer lasts as long as\n+        * Executes the future's closure and then returns a reference\n+        * to the result.  The reference lasts as long as\n         * the future.\n         */\n         match self.state {"}, {"sha": "12566ac85515f314bbda1d12ade07812368e530f", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -431,7 +431,7 @@ struct RWLockInner {\n     // (or reader/downgrader) race.\n     // By the way, if we didn't care about the assert in the read unlock path,\n     // we could instead store the mode flag in write_downgrade's stack frame,\n-    // and have the downgrade tokens store a borrowed pointer to it.\n+    // and have the downgrade tokens store a reference to it.\n     read_mode:  bool,\n     // The only way the count flag is ever accessed is with xadd. Since it is\n     // a read-modify-write operation, multiple xadds on different cores will"}, {"sha": "d7e94c6d48eba08b41e45d14d5e50967efe9404e", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -21,6 +21,9 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n // NB this does *not* include globs, please keep it that way.\n #[feature(macro_rules)];"}, {"sha": "80eb8c00cfdf788361967dc726d651da5886f4a1", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -18,6 +18,9 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "5aacef182fa360137b66ece91c89c7f58c132888", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -8,11 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+The Rust compiler.\n+\n+# Note\n+\n+This API is completely unstable and subject to change.\n+\n+*/\n+\n #[crate_id = \"rustc#0.9\"];\n #[comment = \"The Rust compiler\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"dylib\"];\n #[crate_type = \"rlib\"];\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[feature(macro_rules, globs, struct_variant, managed_boxes)];\n "}, {"sha": "3ffb678d1be8dadac144f55eeb0f7bbdaba6d067", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -44,7 +44,7 @@ referent).\n It then uses the dataflow module to propagate which of those borrows\n may be in scope at each point in the procedure. A loan is considered\n to come into scope at the expression that caused it and to go out of\n-scope when the lifetime of the resulting borrowed pointer expires.\n+scope when the lifetime of the resulting reference expires.\n \n Once the in-scope loans are known for each point in the program, the\n borrow checker walks the IR again in a second pass called\n@@ -146,14 +146,14 @@ result of the borrow `&mut (*x).f` in the example above:\n \n The loan states that the expression `(*x).f` has been loaned as\n mutable for the lifetime `'a`. Because the loan is mutable, that means\n-that the value `(*x).f` may be mutated via the newly created borrowed\n-pointer (and *only* via that pointer). This is reflected in the\n+that the value `(*x).f` may be mutated via the newly created reference\n+(and *only* via that pointer). This is reflected in the\n restrictions `RS` that accompany the loan.\n \n The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n the lender may not mutate nor freeze `(*x).f`. Mutation is illegal\n-because `(*x).f` is only supposed to be mutated via the new borrowed\n-pointer, not by mutating the original path `(*x).f`. Freezing is\n+because `(*x).f` is only supposed to be mutated via the new reference,\n+not by mutating the original path `(*x).f`. Freezing is\n illegal because the path now has an `&mut` alias; so even if we the\n lender were to consider `(*x).f` to be immutable, it might be mutated\n via this alias. Both of these restrictions are temporary. They will be\n@@ -164,8 +164,8 @@ The second restriction on `*x` is interesting because it does not\n apply to the path that was lent (`(*x).f`) but rather to a prefix of\n the borrowed path. This is due to the rules of inherited mutability:\n if the user were to assign to (or freeze) `*x`, they would indirectly\n-overwrite (or freeze) `(*x).f`, and thus invalidate the borrowed\n-pointer that was created. In general it holds that when a path is\n+overwrite (or freeze) `(*x).f`, and thus invalidate the reference\n+that was created. In general it holds that when a path is\n lent, restrictions are issued for all the owning prefixes of that\n path. In this case, the path `*x` owns the path `(*x).f` and,\n because `x` is an owned pointer, the path `x` owns the path `*x`.\n@@ -241,7 +241,7 @@ lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n of the resulting pointer. Given those, `gather_loans` applies three\n validity tests:\n \n-1. `MUTABILITY(LV, MQ)`: The mutability of the borrowed pointer is\n+1. `MUTABILITY(LV, MQ)`: The mutability of the reference is\n compatible with the mutability of `LV` (i.e., not borrowing immutable\n data as mutable).\n \n@@ -380,9 +380,9 @@ of its owner:\n       TYPE(LV) = ~Ty\n       LIFETIME(LV, LT, MQ)\n \n-### Checking lifetime for derefs of borrowed pointers\n+### Checking lifetime for derefs of references\n \n-Borrowed pointers have a lifetime `LT'` associated with them.  The\n+References have a lifetime `LT'` associated with them.  The\n data they point at has been guaranteed to be valid for at least this\n lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n of the borrow is shorter than the lifetime `LT'` of the pointer\n@@ -412,7 +412,7 @@ value is not mutated or moved. Note that lvalues are either\n (ultimately) owned by a local variable, in which case we can check\n whether that local variable is ever moved in its scope, or they are\n owned by the referent of an (immutable, due to condition 2) managed or\n-borrowed pointer, in which case moves are not permitted because the\n+references, in which case moves are not permitted because the\n location is aliasable.\n \n If the conditions of `L-Deref-Managed-Imm-User-Root` are not met, then"}, {"sha": "b03c5b887807acaf9f5f7416ebb69fa2203c95b1", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -662,7 +662,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         //!         &mut v.counter\n         //!     }\n         //!\n-        //! In this case, the borrowed pointer (`'a`) outlives the\n+        //! In this case, the reference (`'a`) outlives the\n         //! variable `v` that hosts it. Note that this doesn't come up\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan."}, {"sha": "1cf019ce9cc0137cfdbe914a767cd150dde1b9aa", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -719,7 +719,7 @@ impl BorrowckCtxt {\n             err_out_of_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n                     self.tcx,\n-                    \"borrowed pointer must be valid for \",\n+                    \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n                 note_and_explain_region("}, {"sha": "1ca5faf91769c312876a0a147dea1870073d3645", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -192,7 +192,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           ExprAddrOf(..) => {\n                 sess.span_err(\n                     e.span,\n-                    \"borrowed pointers in constants may only refer to \\\n+                    \"references in constants may only refer to \\\n                      immutable values\");\n           },\n           ExprVstore(_, ExprVstoreUniq) |"}, {"sha": "4d0c9de82c1e9b0de640045906518d56501b66b0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -33,7 +33,7 @@ use syntax::visit::Visitor;\n //  send: Things that can be sent on channels or included in spawned closures.\n //  freeze: Things thare are deeply immutable. They are guaranteed never to\n //    change, and can be safely shared without copying between tasks.\n-//  'static: Things that do not contain borrowed pointers.\n+//  'static: Things that do not contain references.\n //\n // Send includes scalar types as well as classes and unique types containing\n // only sendable types.\n@@ -487,12 +487,11 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(..) => {\n-            tcx.sess.span_err(sp, \"value may contain borrowed \\\n-                                   pointers; add `'static` bound\");\n+            tcx.sess.span_err(sp, \"value may contain references; \\\n+                                   add `'static` bound\");\n           }\n           _ => {\n-            tcx.sess.span_err(sp, \"value may contain borrowed \\\n-                                   pointers\");\n+            tcx.sess.span_err(sp, \"value may contain references\");\n           }\n         }\n         false\n@@ -502,28 +501,28 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n }\n \n /// This is rather subtle.  When we are casting a value to a instantiated\n-/// trait like `a as trait<'r>`, regionck already ensures that any borrowed\n-/// pointers that appear in the type of `a` are bounded by `'r` (ed.: rem\n+/// trait like `a as trait<'r>`, regionck already ensures that any references\n+/// that appear in the type of `a` are bounded by `'r` (ed.: rem\n /// FIXME(#5723)).  However, it is possible that there are *type parameters*\n-/// in the type of `a`, and those *type parameters* may have borrowed pointers\n+/// in the type of `a`, and those *type parameters* may have references\n /// within them.  We have to guarantee that the regions which appear in those\n /// type parameters are not obscured.\n ///\n /// Therefore, we ensure that one of three conditions holds:\n ///\n /// (1) The trait instance cannot escape the current fn.  This is\n /// guaranteed if the region bound `&r` is some scope within the fn\n-/// itself.  This case is safe because whatever borrowed pointers are\n+/// itself.  This case is safe because whatever references are\n /// found within the type parameter, they must enclose the fn body\n /// itself.\n ///\n /// (2) The type parameter appears in the type of the trait.  For\n /// example, if the type parameter is `T` and the trait type is\n-/// `deque<T>`, then whatever borrowed ptrs may appear in `T` also\n+/// `deque<T>`, then whatever references may appear in `T` also\n /// appear in `deque<T>`.\n ///\n /// (3) The type parameter is sendable (and therefore does not contain\n-/// borrowed ptrs).\n+/// references).\n ///\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n@@ -573,7 +572,7 @@ pub fn check_cast_for_escaping_regions(\n             // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source_span,\n-            //         format!(\"source contains borrowed pointer with lifetime \\\n+            //         format!(\"source contains reference with lifetime \\\n             //               not found in the target type `{}`\",\n             //              ty_to_str(cx.tcx, target_ty)));\n             //     note_and_explain_region("}, {"sha": "0d45a87f3f995dcaff84a4efec46dd698eeaf7ae", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -612,7 +612,7 @@ impl VisitContext {\n         self.use_receiver(receiver_expr);\n \n         // for overloaded operatrs, we are always passing in a\n-        // borrowed pointer, so it's always read mode:\n+        // reference, so it's always read mode:\n         for arg_expr in arg_exprs.iter() {\n             self.use_expr(*arg_expr, Read);\n         }"}, {"sha": "a4acc33fe96939cec91a6aac6372997e54b016ab", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1752,7 +1752,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n  * think of them as kind of an \"anti-kind\".  They track the kinds of values\n  * and thinks that are contained in types.  Having a larger contents for\n  * a type tends to rule that type *out* from various kinds.  For example,\n- * a type that contains a borrowed pointer is not sendable.\n+ * a type that contains a reference is not sendable.\n  *\n  * The reason we compute type contents and not kinds is that it is\n  * easier for me (nmatsakis) to think about what is contained within\n@@ -2188,7 +2188,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                          mutbl: ast::Mutability)\n                          -> TypeContents {\n         /*!\n-         * Type contents due to containing a borrowed pointer\n+         * Type contents due to containing a reference\n          * with the region `region` and borrow kind `bk`\n          */\n "}, {"sha": "a5f0ca57f4c8c660c625b8b5a7053dd3b28de476", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -789,10 +789,10 @@ fn constrain_regions_in_type(\n pub mod guarantor {\n     /*!\n      * The routines in this module are aiming to deal with the case\n-     * where a the contents of a borrowed pointer are re-borrowed.\n-     * Imagine you have a borrowed pointer `b` with lifetime L1 and\n+     * where a the contents of a reference are re-borrowed.\n+     * Imagine you have a reference `b` with lifetime L1 and\n      * you have an expression `&*b`.  The result of this borrow will\n-     * be another borrowed pointer with lifetime L2 (which is an\n+     * be another reference with lifetime L2 (which is an\n      * inference variable).  The borrow checker is going to enforce\n      * the constraint that L2 < L1, because otherwise you are\n      * re-borrowing data for a lifetime larger than the original loan.\n@@ -815,15 +815,15 @@ pub mod guarantor {\n      * a borrow.\n      *\n      * The key point here is that when you are borrowing a value that\n-     * is \"guaranteed\" by a borrowed pointer, you must link the\n-     * lifetime of that borrowed pointer (L1, here) to the lifetime of\n+     * is \"guaranteed\" by a reference, you must link the\n+     * lifetime of that reference (L1, here) to the lifetime of\n      * the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n-     * borrowed pointer? I mean any data that is reached by first\n-     * dereferencing a borrowed pointer and then either traversing\n+     * reference? I mean any data that is reached by first\n+     * dereferencing a reference and then either traversing\n      * interior offsets or owned pointers.  We say that the guarantor\n-     * of such data it the region of the borrowed pointer that was\n+     * of such data it the region of the reference that was\n      * traversed.  This is essentially the same as the ownership\n-     * relation, except that a borrowed pointer never owns its\n+     * relation, except that a reference never owns its\n      * contents.\n      *\n      * NB: I really wanted to use the `mem_categorization` code here\n@@ -953,7 +953,7 @@ pub mod guarantor {\n         guarantor: Option<ty::Region>) {\n         /*!\n          *\n-         * Links the lifetime of the borrowed pointer resulting from a borrow\n+         * Links the lifetime of the reference resulting from a borrow\n          * to the lifetime of its guarantor (if any).\n          */\n \n@@ -1134,7 +1134,7 @@ pub mod guarantor {\n                     Some(ty::AutoBorrowFn(r)) |\n                     Some(ty::AutoBorrowObj(r, _)) => {\n                         // If there is an autoref, then the result of this\n-                        // expression will be some sort of borrowed pointer.\n+                        // expression will be some sort of reference.\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = BorrowedPointer(r);\n                         debug!(\"autoref, cat={:?}\", expr_ct.cat);"}, {"sha": "cc145e9a52ce514e0f8dac37d623e9a913f5ddb4", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -146,7 +146,7 @@ pub fn relate_free_regions(\n      * for each function just before we check the body of that\n      * function, looking for types where you have a borrowed\n      * pointer to other borrowed data (e.g., `&'a &'b [uint]`.\n-     * We do not allow borrowed pointers to outlive the things they\n+     * We do not allow references to outlive the things they\n      * point at, so we can assume that `'a <= 'b`.\n      *\n      * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`"}, {"sha": "89a9e5414970f8b8c9e64620842c3656591acb76", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -20,8 +20,8 @@ but not in representation (so actual subtyping is inappropriate).\n \n ## Reborrowing\n \n-Note that if we are expecting a borrowed pointer, we will *reborrow*\n-even if the argument provided was already a borrowed pointer.  This is\n+Note that if we are expecting a reference, we will *reborrow*\n+even if the argument provided was already a reference.  This is\n useful for freezing mut/const things (that is, when the expected is &T\n but you have &const T or &mut T) and also for avoiding the linearity\n of mut things (when the expected is &mut T and you have &mut T).  See\n@@ -451,7 +451,7 @@ impl Coerce {\n         let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n         if_ok!(self.subtype(a_unsafe, b));\n \n-        // although borrowed ptrs and unsafe ptrs have the same\n+        // although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here\n         Ok(Some(@AutoDerefRef(AutoDerefRef {"}, {"sha": "d1bf998e989365f4bd1d138ebf8b29e6a9d5ebb1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -226,11 +226,11 @@ impl ErrorReporting for InferCtxt {\n             infer::Reborrow(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    \"lifetime of borrowed pointer outlines \\\n+                    \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    \"...the borrowed pointer is valid for \",\n+                    \"...the reference is valid for \",\n                     sub,\n                     \"...\");\n                 note_and_explain_region(\n@@ -351,7 +351,7 @@ impl ErrorReporting for InferCtxt {\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    \"borrowed pointer is not valid \\\n+                    \"reference is not valid \\\n                      at the time of borrow\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -362,7 +362,7 @@ impl ErrorReporting for InferCtxt {\n             infer::AutoBorrow(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    \"automatically borrowed pointer is not valid \\\n+                    \"automatically reference is not valid \\\n                      at the time of borrow\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -532,7 +532,7 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::Reborrow(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that borrowed pointer does not outlive \\\n+                    \"...so that reference does not outlive \\\n                     borrowed content\");\n             }\n             infer::InfStackClosure(span) => {\n@@ -586,13 +586,13 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that borrowed pointer is valid \\\n+                    \"...so that reference is valid \\\n                      at the time of borrow\");\n             }\n             infer::AutoBorrow(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that automatically borrowed pointer is valid \\\n+                    \"...so that automatically reference is valid \\\n                      at the time of borrow\");\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {"}, {"sha": "e2a9a6a8333306cf266ae6e4dd092513d729f31a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -157,7 +157,7 @@ pub enum SubregionOrigin {\n     // Invocation of closure must be within its lifetime\n     InvokeClosure(Span),\n \n-    // Dereference of borrowed pointer must be within its lifetime\n+    // Dereference of reference must be within its lifetime\n     DerefPointer(Span),\n \n     // Closure bound must not outlive captured free variables\n@@ -170,7 +170,7 @@ pub enum SubregionOrigin {\n     // relating `'a` to `'b`\n     RelateObjectBound(Span),\n \n-    // Creating a pointer `b` to contents of another borrowed pointer\n+    // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n     // (&'a &'b T) where a >= b"}, {"sha": "6cc4dcd3b0cae13b647001280543ab9ffa6aa18f", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -226,12 +226,12 @@ corresponds to the *actual execution of the function `add()`*, after\n all arguments have been evaluated. There is a corresponding lifetime\n `'b_call` for the execution of `inc()`. If we wanted to be precise\n about it, the lifetime of the two borrows should be `'a_call` and\n-`'b_call` respectively, since the borrowed pointers that were created\n+`'b_call` respectively, since the references that were created\n will not be dereferenced except during the execution itself.\n \n However, this model by itself is not sound. The reason is that\n-while the two borrowed pointers that are created will never be used\n-simultaneously, it is still true that the first borrowed pointer is\n+while the two references that are created will never be used\n+simultaneously, it is still true that the first reference is\n *created* before the second argument is evaluated, and so even though\n it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n@@ -257,7 +257,7 @@ invalidating the first argument.\n So, for now, we exclude the `call` lifetimes from our model.\n Eventually I would like to include them, but we will have to make the\n borrow checker handle this situation correctly. In particular, if\n-there is a borrowed pointer created whose lifetime does not enclose\n+there is a reference created whose lifetime does not enclose\n the borrow expression, we must issue sufficient restrictions to ensure\n that the pointee remains valid.\n "}, {"sha": "bb74c3b95513f0b24f175e881af343dc935d67f0", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -19,7 +19,7 @@ use syntax::opt_vec::OptVec;\n \n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of of\n-/// this borrowed pointer has been omitted. When converting this\n+/// this reference has been omitted. When converting this\n /// type, the generic functions in astconv will invoke `anon_regions`\n /// on the provided region-scope to decide how to translate this\n /// omitted region."}, {"sha": "66df4334adcb9dbf4aeca0af6212033537836804", "filename": "src/libstd/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Borrowed pointer utilities\n+//! Utilities for references\n \n #[cfg(not(test))]\n use prelude::*;"}, {"sha": "eec7d28e134bb0274690bf3aaf23819301a1e940", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -64,7 +64,7 @@ pub unsafe fn transmute<L, G>(thing: L) -> G {\n #[inline]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n-/// Coerce a borrowed pointer to have an arbitrary associated region.\n+/// Coerce a reference to have an arbitrary associated region.\n #[inline]\n pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n     transmute(ptr)\n@@ -82,7 +82,7 @@ pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n     transmute(ptr)\n }\n \n-/// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n+/// Coerce a mutable reference to have an arbitrary associated region.\n #[inline]\n pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {\n     transmute(ptr)"}, {"sha": "e5e79b4386a566217765f21079276a4c16aa4a56", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -59,7 +59,7 @@ impl<T> Clone for @T {\n }\n \n impl<'a, T> Clone for &'a T {\n-    /// Return a shallow copy of the borrowed pointer.\n+    /// Return a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }\n }"}, {"sha": "112a380c24397982d17612d0d05a6236d1e19f80", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -18,7 +18,7 @@\n //! `std` includes modules corresponding to each of the integer types,\n //! each of the floating point types, the `bool` type, tuples, characters,\n //! strings (`str`), vectors (`vec`), managed boxes (`managed`), owned\n-//! boxes (`owned`), and unsafe and borrowed pointers (`ptr`, `borrowed`).\n+//! boxes (`owned`), and unsafe pointers and references (`ptr`, `borrowed`).\n //! Additionally, `std` provides pervasive types (`option` and `result`),\n //! task creation and communication primitives (`task`, `comm`), platform\n //! abstractions (`os` and `path`), basic I/O abstractions (`io`), common"}, {"sha": "3cb7fcd953319d45b32579d36c9585cb5ca30e4e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -71,7 +71,7 @@ traits from other modules. Some notable examples:\n ## Iteration\n \n The method `iter()` returns an iteration value for a vector or a vector slice.\n-The iterator yields borrowed pointers to the vector's elements, so if the element\n+The iterator yields references to the vector's elements, so if the element\n type of the vector is `int`, the element type of the iterator is `&int`.\n \n ```rust"}, {"sha": "8864c678b952ae4fc4b7d0bb036666cf1df19f98", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -371,7 +371,7 @@ pub enum Pat_ {\n     PatTup(~[@Pat]),\n     PatBox(@Pat),\n     PatUniq(@Pat),\n-    PatRegion(@Pat), // borrowed pointer pattern\n+    PatRegion(@Pat), // reference pattern\n     PatLit(@Expr),\n     PatRange(@Expr, @Expr),\n     // [a, b, ..i, y, z] is represented as"}, {"sha": "234551ccb016838d7de0e6f5e2749344ee9e4964", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -26,7 +26,7 @@ Supported features (fairly exhaustive):\n   requires an explicit `Eq` bound at the\n   moment. (`TraitDef.additional_bounds`)\n \n-Unsupported: FIXME #6257: calling methods on borrowed pointer fields,\n+Unsupported: FIXME #6257: calling methods on reference fields,\n e.g. deriving TotalEq/TotalOrd/Clone don't work on `struct A(&int)`,\n because of how the auto-dereferencing happens.\n "}, {"sha": "5128cdd54ccd309df45cc4e78bdce4e0a443ac4b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -8,15 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! This module contains the Rust parser. It maps source text\n- *  to token trees and to ASTs. It contains code for expanding\n- *  macros.\n- */\n+/*!\n+\n+The Rust parser and macro expander.\n+\n+# Note\n+\n+This API is completely unstable and subject to change.\n+\n+*/\n \n #[crate_id = \"syntax#0.9\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"dylib\"];\n #[crate_type = \"rlib\"];\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[feature(macro_rules, globs, managed_boxes)];\n "}, {"sha": "fdc54f1f140a6c9483a7b43dd8db7c24436b35d9", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -83,7 +83,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n }\n \n // A StrInterner differs from Interner<String> in that it accepts\n-// borrowed pointers rather than @ ones, resulting in less allocation.\n+// references rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n     priv map: @RefCell<HashMap<@str, Name>>,\n     priv vect: @RefCell<~[@str]>,"}, {"sha": "160f73f4a58ac8f51b0a53fd23a390507f0dfbb4", "filename": "src/test/compile-fail/box-static-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbox-static-bound.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -1,7 +1,7 @@\n #[feature(managed_boxes)];\n \n fn f<T>(x: T) -> @T {\n-    @x  //~ ERROR value may contain borrowed pointers\n+    @x  //~ ERROR value may contain references\n }\n \n fn g<T:'static>(x: T) -> @T {"}, {"sha": "d1541f23c70c88f693ef5085e899cf7969f2fe70", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Testing that we can't store a borrowed pointer it task-local storage\n+// Testing that we can't store a reference it task-local storage\n \n use std::local_data;\n "}, {"sha": "e996a0468e4e295ffbffc21a84a30ad71eaff1bc", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -23,8 +23,8 @@ impl<T:Clone> foo for T {\n }\n \n fn to_foo<T:Clone>(t: T) {\n-    // This version is ok because, although T may contain borrowed\n-    // pointers, it never escapes the fn body.  We know this because\n+    // This version is ok because, although T may contain references\n+    // it never escapes the fn body.  We know this because\n     // the type of foo includes a region which will be resolved to\n     // the fn body itself.\n     let v = &3;\n@@ -34,15 +34,15 @@ fn to_foo<T:Clone>(t: T) {\n }\n \n fn to_foo_2<T:Clone>(t: T) -> @foo {\n-    // Not OK---T may contain borrowed ptrs and it is going to escape\n+    // Not OK---T may contain references and it is going to escape\n     // as part of the returned foo value\n     struct F<T> { f: T }\n-    @F {f:t} as @foo //~ ERROR value may contain borrowed pointers; add `'static` bound\n+    @F {f:t} as @foo //~ ERROR value may contain references; add `'static` bound\n }\n \n fn to_foo_3<T:Clone + 'static>(t: T) -> @foo {\n     // OK---T may escape as part of the returned foo value, but it is\n-    // owned and hence does not contain borrowed ptrs\n+    // owned and hence does not contain references\n     struct F<T> { f: T }\n     @F {f:t} as @foo\n }"}, {"sha": "87e9769d97e4bc2d3abe417216c91152845ce254", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -14,9 +14,9 @@ trait foo { fn foo(&self); }\n \n fn to_foo<T:Clone + foo>(t: T) -> @foo {\n     @t as @foo\n-    //~^ ERROR value may contain borrowed pointers; add `'static` bound\n+    //~^ ERROR value may contain references; add `'static` bound\n     //~^^ ERROR cannot pack type\n-    //~^^^ ERROR value may contain borrowed pointers\n+    //~^^^ ERROR value may contain references\n }\n \n fn to_foo2<T:Clone + foo + 'static>(t: T) -> @foo {"}, {"sha": "1b6be3f387b39326c1aee9119875e4bfdab464fa", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test #5723\n \n-// Test that you cannot escape a borrowed pointer\n+// Test that you cannot escape a reference\n // into a trait.\n \n struct ctxt { v: uint }\n@@ -29,7 +29,7 @@ fn make_gc() -> @get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n     return @hc as @get_ctxt;\n-    //^~ ERROR source contains borrowed pointer\n+    //^~ ERROR source contains reference\n }\n \n fn main() {"}, {"sha": "3c78ed32e5199036af3d16ddf7bc284cb8c92fe6", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -175,10 +175,10 @@ fn main() {\n     // managed box\n     let @aa = @(34, 35);\n \n-    // borrowed pointer\n+    // reference\n     let &bb = &(36, 37);\n \n-    // contained borrowed pointer\n+    // contained reference\n     let (&cc, _) = (&38, 39);\n \n     // unique pointer"}, {"sha": "57ae7ad015f59fcc0f7228d1d5b5afd4433c604d", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -51,7 +51,7 @@ struct AsciiArt {\n     priv lines: ~[~[char]],\n \n     // This struct can be quite large so we'll disable copying: developers need\n-    // to either pass these structs around via borrowed pointers or move them.\n+    // to either pass these structs around via references or move them.\n }\n \n impl Drop for AsciiArt {"}, {"sha": "0a2af3e70c512e3c50b4aadc68ccb173a38fdce5", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464d1d044eebace50d17c10731493d6898490876/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=464d1d044eebace50d17c10731493d6898490876", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n /*\n-# ICE when returning struct with borrowed pointer to trait\n+# ICE when returning struct with reference to trait\n \n-A function which takes a borrowed pointer to a trait and returns a\n-struct with that borrowed pointer results in an ICE.\n+A function which takes a reference to a trait and returns a\n+struct with that reference results in an ICE.\n \n-This does not occur with concrete types, only with borrowed pointers\n+This does not occur with concrete types, only with references\n to traits.\n */\n "}]}