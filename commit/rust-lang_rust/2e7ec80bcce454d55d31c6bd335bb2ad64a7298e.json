{"sha": "2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlN2VjODBiY2NlNDU0ZDU1ZDMxYzZiZDMzNWJiMmFkNjRhNzI5OGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-19T00:20:45Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-19T20:40:48Z"}, "message": "librustc: Enforce privacy for static methods.\n\nThis starts moving a bunch of privacy checks into the privacy\nchecking phase and out of resolve.", "tree": {"sha": "02bbd5d40bbf7873fd32c87ea81f5e0012502a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02bbd5d40bbf7873fd32c87ea81f5e0012502a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "html_url": "https://github.com/rust-lang/rust/commit/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14ec73cd2d15a2454113011835557ccf447f14d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14ec73cd2d15a2454113011835557ccf447f14d", "html_url": "https://github.com/rust-lang/rust/commit/a14ec73cd2d15a2454113011835557ccf447f14d"}], "stats": {"total": 412, "additions": 306, "deletions": 106}, "files": [{"sha": "92e2ec51306e20cd862bc837fefc561e2ddf804c", "filename": "src/libcore/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fenv.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -44,4 +44,4 @@ pub fn get() -> &Environment {\n \n extern {\n     fn rust_get_rt_env() -> &Environment;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b5e7d4f3aa2153843c123406a5a0a91b1ed97adc", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -37,8 +37,7 @@ pub impl StackSegment {\n pub struct StackPool(());\n \n impl StackPool {\n-\n-    static fn new() -> StackPool { StackPool(()) }\n+    static pub fn new() -> StackPool { StackPool(()) }\n \n     fn take_segment(&self, min_size: uint) -> StackSegment {\n         StackSegment::new(min_size)"}, {"sha": "760812252bc73761a77ea3d4b9753503615b7f8b", "filename": "src/libcore/task/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibcore%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Frt.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -30,7 +30,7 @@ pub type rust_task = libc::c_void;\n #[allow(non_camel_case_types)] // runtime type\n pub type rust_closure = libc::c_void;\n \n-extern {\n+pub extern {\n     #[rust_stack]\n     fn rust_task_yield(task: *rust_task) -> bool;\n "}, {"sha": "f120d83e3248529af6d740af6d48739b78969fc7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -146,6 +146,7 @@ fn item_family(item: ebml::Doc) -> Family {\n \n fn item_visibility(item: ebml::Doc) -> ast::visibility {\n     let visibility = reader::get_doc(item, tag_items_data_item_visibility);\n+    debug!(\"item visibility for %?\", item_family(item));\n     match reader::doc_as_u8(visibility) as char {\n         'y' => ast::public,\n         'n' => ast::private,"}, {"sha": "f93504aafcb7d7fa2c6a2e3550659c0cb0dc38e0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -881,6 +881,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'r');\n+                encode_visibility(ebml_w, ast::public);\n                 ebml_w.end_tag();\n               }\n               provided(m) => {\n@@ -896,6 +897,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n+                encode_visibility(ebml_w, m.vis);\n                 ebml_w.end_tag();\n               }\n             }\n@@ -930,6 +932,11 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             let mut m_path = vec::append(~[], path); // :-(\n             m_path += [ast_map::path_name(item.ident)];\n             encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n+\n+            // For now, use the item visibility until trait methods can have\n+            // real visibility in the AST.\n+            encode_visibility(ebml_w, item.vis);\n+\n             ebml_w.end_tag();\n         }\n \n@@ -1018,7 +1025,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n                 match ecx.tcx.items.get(&ni.id) {\n-                    ast_map::node_foreign_item(_, abi, pt) => {\n+                    ast_map::node_foreign_item(_, abi, _, pt) => {\n                         encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                                      index, /*bad*/copy *pt,\n                                                      abi);"}, {"sha": "adc1a7ce3f43b91a3dd411fd042aa21983d505c8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 257, "deletions": 88, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -22,15 +22,19 @@ use middle::typeck::{method_super};\n use middle::typeck::{method_static, method_trait};\n \n use core::util::ignore;\n-use syntax::ast::{def_variant, expr_field, expr_method_call, expr_struct};\n-use syntax::ast::{expr_unary, ident, item_struct, item_enum, item_impl};\n-use syntax::ast::{item_trait, local_crate, node_id, pat_struct, private};\n-use syntax::ast::{provided, public, required};\n+use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n+use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n+use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n+use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n+use syntax::ast::{item_trait, local_crate, node_id, pat_struct, path};\n+use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n use syntax::ast;\n-use syntax::ast_map::{node_item, node_method};\n+use syntax::ast_map::{node_foreign_item, node_item, node_method};\n+use syntax::ast_map::{node_trait_method};\n use syntax::ast_map;\n use syntax::ast_util::{Private, Public, is_local};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::visit;\n \n@@ -39,18 +43,37 @@ pub fn check_crate(tcx: ty::ctxt,\n                    crate: @ast::crate) {\n     let privileged_items = @mut ~[];\n \n-    // Adds structs that are privileged to this scope.\n-    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n-        let mut count = 0;\n-        for items.each |item| {\n-            match item.node {\n-                item_struct(*) | item_trait(*) | item_impl(*)\n-                | item_enum(*) => {\n-                    privileged_items.push(item.id);\n-                    count += 1;\n+    // Adds an item to its scope.\n+    let add_privileged_item: @fn(@ast::item, &mut uint) = |item, count| {\n+        match item.node {\n+            item_struct(*) | item_trait(*) | item_enum(*) |\n+            item_fn(*) => {\n+                privileged_items.push(item.id);\n+                *count += 1;\n+            }\n+            item_impl(_, _, _, ref methods) => {\n+                for methods.each |method| {\n+                    privileged_items.push(method.id);\n+                    *count += 1;\n+                }\n+                privileged_items.push(item.id);\n+                *count += 1;\n+            }\n+            item_foreign_mod(ref foreign_mod) => {\n+                for foreign_mod.items.each |foreign_item| {\n+                    privileged_items.push(foreign_item.id);\n+                    *count += 1;\n                 }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n+    };\n+\n+    // Adds items that are privileged to this scope.\n+    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n+        let mut count = 0;\n+        for items.each |&item| {\n+            add_privileged_item(item, &mut count);\n         }\n         count\n     };\n@@ -84,6 +107,128 @@ pub fn check_crate(tcx: ty::ctxt,\n         }\n     };\n \n+    // Returns the ID of the container (impl or trait) that a crate-local\n+    // method belongs to.\n+    let local_method_container_id:\n+            @fn(span: span, method_id: node_id) -> def_id =\n+            |span, method_id| {\n+        match tcx.items.find(&method_id) {\n+            Some(node_method(_, impl_id, _)) => impl_id,\n+            Some(node_trait_method(_, trait_id, _)) => trait_id,\n+            Some(_) => {\n+                tcx.sess.span_bug(span,\n+                                  fmt!(\"method was a %s?!\",\n+                                       ast_map::node_id_to_str(\n+                                            tcx.items,\n+                                            method_id,\n+                                            tcx.sess.parse_sess.interner)));\n+            }\n+            None => {\n+                tcx.sess.span_bug(span, ~\"method not found in \\\n+                                          AST map?!\");\n+            }\n+        }\n+    };\n+\n+    // Returns true if a crate-local method is private and false otherwise.\n+    let method_is_private: @fn(span: span, method_id: node_id) -> bool =\n+            |span, method_id| {\n+        let check = |vis: visibility, container_id: def_id| {\n+            let mut is_private = false;\n+            if vis == private {\n+                is_private = true;\n+            } else if vis == public {\n+                is_private = false;\n+            } else {\n+                // Look up the enclosing impl.\n+                if container_id.crate != local_crate {\n+                    tcx.sess.span_bug(span,\n+                                      ~\"local method isn't in local \\\n+                                        impl?!\");\n+                }\n+\n+                match tcx.items.find(&container_id.node) {\n+                    Some(node_item(item, _)) => {\n+                        match item.node {\n+                            item_impl(_, None, _, _)\n+                                    if item.vis != public => {\n+                                is_private = true;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    Some(_) => {\n+                        tcx.sess.span_bug(span, ~\"impl wasn't an item?!\");\n+                    }\n+                    None => {\n+                        tcx.sess.span_bug(span, ~\"impl wasn't in AST map?!\");\n+                    }\n+                }\n+            }\n+\n+            is_private\n+        };\n+\n+        match tcx.items.find(&method_id) {\n+            Some(node_method(method, impl_id, _)) => {\n+                check(method.vis, impl_id)\n+            }\n+            Some(node_trait_method(trait_method, trait_id, _)) => {\n+                match *trait_method {\n+                    required(_) => check(public, trait_id),\n+                    provided(method) => check(method.vis, trait_id),\n+                }\n+            }\n+            Some(_) => {\n+                tcx.sess.span_bug(span,\n+                                  fmt!(\"method_is_private: method was a %s?!\",\n+                                       ast_map::node_id_to_str(\n+                                            tcx.items,\n+                                            method_id,\n+                                            tcx.sess.parse_sess.interner)));\n+            }\n+            None => {\n+                tcx.sess.span_bug(span, ~\"method not found in \\\n+                                          AST map?!\");\n+            }\n+        }\n+    };\n+\n+    // Returns true if the given local item is private and false otherwise.\n+    let local_item_is_private: @fn(span: span, item_id: node_id) -> bool =\n+            |span, item_id| {\n+        let mut f: &fn(node_id) -> bool = |_| false;\n+        f = |item_id| {\n+            match tcx.items.find(&item_id) {\n+                Some(node_item(item, _)) => item.vis != public,\n+                Some(node_foreign_item(_, _, vis, _)) => vis != public,\n+                Some(node_method(method, impl_did, _)) => {\n+                    match method.vis {\n+                        private => true,\n+                        public => false,\n+                        inherited => f(impl_did.node)\n+                    }\n+                }\n+                Some(node_trait_method(_, trait_did, _)) => f(trait_did.node),\n+                Some(_) => {\n+                    tcx.sess.span_bug(span,\n+                                      fmt!(\"local_item_is_private: item was \\\n+                                            a %s?!\",\n+                                           ast_map::node_id_to_str(\n+                                                tcx.items,\n+                                                item_id,\n+                                                tcx.sess\n+                                                   .parse_sess\n+                                                   .interner)));\n+                }\n+                None => {\n+                    tcx.sess.span_bug(span, ~\"item not found in AST map?!\");\n+                }\n+            }\n+        };\n+        f(item_id)\n+    };\n+\n     // Checks that a private field is in scope.\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n@@ -99,86 +244,76 @@ pub fn check_crate(tcx: ty::ctxt,\n         }\n     };\n \n+    // Given the ID of a method, checks to ensure it's in scope.\n+    let check_method_common: @fn(span: span,\n+                                 method_id: def_id,\n+                                 name: &ident) =\n+            |span, method_id, name| {\n+        if method_id.crate == local_crate {\n+            let is_private = method_is_private(span, method_id.node);\n+            let container_id = local_method_container_id(span,\n+                                                         method_id.node);\n+            if is_private &&\n+                    (container_id.crate != local_crate ||\n+                     !privileged_items.contains(&(container_id.node))) {\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"method `%s` is private\",\n+                                       *tcx.sess\n+                                           .parse_sess\n+                                           .interner\n+                                           .get(*name)));\n+            }\n+        } else {\n+            let visibility =\n+                csearch::get_method_visibility(tcx.sess.cstore,\n+                                               method_id);\n+            if visibility != public {\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"method `%s` is private\",\n+                                       *tcx.sess.parse_sess.interner\n+                                           .get(*name)));\n+            }\n+        }\n+    };\n+\n+    // Checks that a private path is in scope.\n+    let check_path: @fn(span: span, def: def, path: @path) =\n+            |span, def, path| {\n+        debug!(\"checking path\");\n+        match def {\n+            def_static_method(method_id, _, _) => {\n+                debug!(\"found static method def, checking it\");\n+                check_method_common(span, method_id, path.idents.last())\n+            }\n+            def_fn(def_id, _) => {\n+                if def_id.crate == local_crate {\n+                    if local_item_is_private(span, def_id.node) &&\n+                            !privileged_items.contains(&def_id.node) {\n+                        tcx.sess.span_err(span,\n+                                          fmt!(\"function `%s` is private\",\n+                                               *tcx.sess\n+                                                   .parse_sess\n+                                                   .interner\n+                                                   .get(copy *path\n+                                                             .idents\n+                                                             .last())));\n+                    }\n+                } else {\n+                    // XXX: Check privacy in external crates.\n+                }\n+            }\n+            _ => {}\n+        }\n+    };\n+\n     // Checks that a private method is in scope.\n     let check_method: @fn(span: span,\n                           origin: &method_origin,\n                           ident: ast::ident) =\n             |span, origin, ident| {\n         match *origin {\n             method_static(method_id) => {\n-                if method_id.crate == local_crate {\n-                    match tcx.items.find(&method_id.node) {\n-                        Some(node_method(method, impl_id, _)) => {\n-                            let mut is_private = false;\n-                            if method.vis == private {\n-                                is_private = true;\n-                            } else if method.vis == public {\n-                                is_private = false;\n-                            } else {\n-                                // Look up the enclosing impl.\n-                                if impl_id.crate != local_crate {\n-                                    tcx.sess.span_bug(span,\n-                                                      ~\"local method isn't \\\n-                                                        in local impl?!\");\n-                                }\n-\n-                                match tcx.items.find(&impl_id.node) {\n-                                    Some(node_item(item, _)) => {\n-                                        match item.node {\n-                                            item_impl(_, None, _, _)\n-                                                    if item.vis != public => {\n-                                                is_private = true;\n-                                            }\n-                                            _ => {}\n-                                        }\n-                                    }\n-                                    Some(_) => {\n-                                        tcx.sess.span_bug(span,\n-                                                          ~\"impl wasn't an \\\n-                                                            item?!\");\n-                                    }\n-                                    None => {\n-                                        tcx.sess.span_bug(span,\n-                                                          ~\"impl wasn't in \\\n-                                                            AST map?!\");\n-                                    }\n-                                }\n-                            }\n-\n-                            if is_private &&\n-                                    (impl_id.crate != local_crate ||\n-                                     !privileged_items\n-                                     .contains(&(impl_id.node))) {\n-                                tcx.sess.span_err(span,\n-                                                  fmt!(\"method `%s` is \\\n-                                                        private\",\n-                                                       *tcx.sess\n-                                                           .parse_sess\n-                                                           .interner\n-                                                           .get(method\n-                                                                .ident)));\n-                            }\n-                        }\n-                        Some(_) => {\n-                            tcx.sess.span_bug(span, ~\"method wasn't \\\n-                                                      actually a method?!\");\n-                        }\n-                        None => {\n-                            tcx.sess.span_bug(span, ~\"method not found in \\\n-                                                      AST map?!\");\n-                        }\n-                    }\n-                } else {\n-                    let visibility =\n-                        csearch::get_method_visibility(tcx.sess.cstore,\n-                                                       method_id);\n-                    if visibility != public {\n-                        tcx.sess.span_err(span,\n-                                          fmt!(\"method `%s` is private\",\n-                                               *tcx.sess.parse_sess.interner\n-                                                   .get(ident)));\n-                    }\n-                }\n+                check_method_common(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -257,6 +392,37 @@ pub fn check_crate(tcx: ty::ctxt,\n                 ignore(privileged_items.pop());\n             }\n         },\n+        visit_item: |item, method_map, visitor| {\n+            // Do not check privacy inside items with the resolve_unexported\n+            // attribute. This is used for the test runner.\n+            if !attr::contains_name(attr::attr_metas(/*bad*/copy item.attrs),\n+                                    ~\"!resolve_unexported\") {\n+                visit::visit_item(item, method_map, visitor);\n+            }\n+        },\n+        visit_block: |block, method_map, visitor| {\n+            // Gather up all the privileged items.\n+            let mut n_added = 0;\n+            for block.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    stmt_decl(decl, _) => {\n+                        match decl.node {\n+                            decl_item(item) => {\n+                                add_privileged_item(item, &mut n_added);\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            visit::visit_block(block, method_map, visitor);\n+\n+            for n_added.times {\n+                ignore(privileged_items.pop());\n+            }\n+        },\n         visit_expr: |expr, method_map: &method_map, visitor| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n@@ -310,6 +476,9 @@ pub fn check_crate(tcx: ty::ctxt,\n                         _ => {}\n                     }\n                 }\n+                expr_path(path) => {\n+                    check_path(expr.span, tcx.def_map.get(&expr.id), path);\n+                }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {"}, {"sha": "55cf1ae23b8fc7a8c2e2e322f2ffb40f4387e4c4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -2428,7 +2428,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             exprt = true;\n             register_method(ccx, id, pth, m)\n           }\n-          ast_map::node_foreign_item(ni, _, pth) => {\n+          ast_map::node_foreign_item(ni, _, _, pth) => {\n             exprt = true;\n             match ni.node {\n                 ast::foreign_item_fn(*) => {"}, {"sha": "14336a203ced4eea84e89e5cfc431e2bc09e24b2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -266,6 +266,7 @@ pub fn trans_fn_ref_with_vtables(\n         match map_node {\n             ast_map::node_foreign_item(_,\n                                        ast::foreign_abi_rust_intrinsic,\n+                                       _,\n                                        _) => {\n                 must_monomorphise = true;\n             }"}, {"sha": "dadd51b324847ed68ad435c6153b93de93b89b57", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -1083,7 +1083,7 @@ fn abi_of_foreign_fn(ccx: @CrateContext, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n       None => match ccx.tcx.items.get(&i.id) {\n-        ast_map::node_foreign_item(_, abi, _) => abi,\n+        ast_map::node_foreign_item(_, abi, _, _) => abi,\n         // ??\n         _ => fail!(~\"abi_of_foreign_fn: not foreign\")\n       },"}, {"sha": "feddbabdcad3fbf9b0952923f69d77f2674c8597", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -94,7 +94,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n-      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, pt)\n+      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, _, pt)\n       => (pt, i.ident, i.span),\n       ast_map::node_foreign_item(*) => {\n         // Foreign externs don't have to be monomorphized.\n@@ -181,7 +181,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_item(*) => {\n           ccx.tcx.sess.bug(~\"Can't monomorphize this kind of item\")\n       }\n-      ast_map::node_foreign_item(i, _, _) => {\n+      ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n           foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(),\n                                 ref_id);"}, {"sha": "2adf9926f2d4d4e4ed7d6c8b0bd5ecefd82185f5", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -76,7 +76,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     match n {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n       ast_map::node_method(_, impl_id, _) => traverse_def_id(cx, impl_id),\n-      ast_map::node_foreign_item(item, _, _) => {\n+      ast_map::node_foreign_item(item, _, _, _) => {\n         cx.rmap.insert(item.id, ());\n       }\n       ast_map::node_variant(ref v, _, _) => {"}, {"sha": "77e10b2fbda64c5dc17e7068dbcd12f1e38ede3a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -118,7 +118,9 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n       }\n       ast_map::node_foreign_item(i@@foreign_item { node: foreign_item_fn(*),\n                                                    _ },\n-                                 abi, _) => {\n+                                 abi,\n+                                 _,\n+                                 _) => {\n         if abi == foreign_abi_rust_intrinsic {\n             let flags = match *cx.ccx.sess.str_of(i.ident) {\n                 ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |"}, {"sha": "9520da7a5d271925c7f156860db00c37ea1f6ab3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -3762,7 +3762,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::append_one(/*bad*/copy *path, item_elt)\n           }\n \n-          ast_map::node_foreign_item(nitem, _, path) => {\n+          ast_map::node_foreign_item(nitem, _, _, path) => {\n             vec::append_one(/*bad*/copy *path,\n                             ast_map::path_name(nitem.ident))\n           }"}, {"sha": "dacc9553cd24f232e9b026b030a21c2d946d5404", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -139,7 +139,7 @@ impl AstConv for CrateCtxt {\n               Some(ast_map::node_item(item, _)) => {\n                 ty_of_item(self, item)\n               }\n-              Some(ast_map::node_foreign_item(foreign_item, _, _)) => {\n+              Some(ast_map::node_foreign_item(foreign_item, _, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item)\n               }\n               ref x => {"}, {"sha": "0bf2f50e63fc57c24db308bd7c7c786ef4cea5bb", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -116,7 +116,7 @@ fn parse_item_attrs<T:Owned>(\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n-          ast_map::node_foreign_item(item, _, _) => copy item.attrs,\n+          ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n           _ => fail!(~\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)"}, {"sha": "638274d0bb8ee62c8944530065045bc42be97dee", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -74,7 +74,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n           ast_map::node_foreign_item(@ast::foreign_item {\n             ident: ident,\n             node: ast::foreign_item_fn(ref decl, _, ref tys), _\n-          }, _, _) => {\n+          }, _, _, _) => {\n             Some(pprust::fun_to_str(decl, ident, None, tys,\n                                     extract::interner()))\n           }"}, {"sha": "9371055556ef54256cb8f7722150f8b38d6caeca", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -87,7 +87,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n \n pub enum ast_node {\n     node_item(@item, @path),\n-    node_foreign_item(@foreign_item, foreign_abi, @path),\n+    node_foreign_item(@foreign_item, foreign_abi, visibility, @path),\n     node_trait_method(@trait_method, def_id /* trait did */,\n                       @path /* path to the trait */),\n     node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n@@ -170,7 +170,9 @@ pub fn map_decoded_item(diag: @span_handler,\n     match ii {\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n-        cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n+        cx.map.insert(i.id, node_foreign_item(i,\n+                                              foreign_abi_rust_intrinsic,\n+                                              i.vis,    // Wrong but OK\n                                               @path));\n       }\n       ii_method(impl_did, m) => {\n@@ -277,10 +279,18 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n                 Right(abi) => abi\n             };\n             for nm.items.each |nitem| {\n+                // Compute the visibility for this native item.\n+                let visibility = match nitem.vis {\n+                    public => public,\n+                    private => private,\n+                    inherited => i.vis\n+                };\n+\n                 cx.map.insert(nitem.id,\n                     node_foreign_item(\n                         *nitem,\n                         abi,\n+                        visibility,\n                         // FIXME (#2543)\n                         if nm.sort == ast::named {\n                             extend(cx, i.ident)\n@@ -380,7 +390,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         };\n         fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n       }\n-      Some(node_foreign_item(item, abi, path)) => {\n+      Some(node_foreign_item(item, abi, _, path)) => {\n         fmt!(\"foreign item %s with abi %? (id=%?)\",\n              path_ident_to_str(*path, item.ident, itr), abi, id)\n       }"}, {"sha": "d9b4112b1bd86ea87ab4a3eaf5db661e8fd0bbaf", "filename": "src/test/compile-fail/static-method-privacy.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7ec80bcce454d55d31c6bd335bb2ad64a7298e/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs?ref=2e7ec80bcce454d55d31c6bd335bb2ad64a7298e", "patch": "@@ -0,0 +1,11 @@\n+mod a {\n+    pub struct S;\n+    impl S {\n+        static fn new() -> S { S }\n+    }\n+}\n+\n+fn main() {\n+    let _ = a::S::new();    //~ ERROR function `new` is private\n+}\n+"}]}