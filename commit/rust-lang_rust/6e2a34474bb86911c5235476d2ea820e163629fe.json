{"sha": "6e2a34474bb86911c5235476d2ea820e163629fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMmEzNDQ3NGJiODY5MTFjNTIzNTQ3NmQyZWE4MjBlMTYzNjI5ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T18:03:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T18:03:25Z"}, "message": "Auto merge of #83114 - cjgillot:hop, r=eddyb\n\nMove HIR parenting information out of hir_owner\n\nSplit out of #82681.\n\nThe parent of a HIR node and its content are currently bundled together, but are rarely used together.\nThis PR separates both information in two distinct queries for HIR owners.\nThis reduces incremental invalidation for HIR items that appear within a function body when this body (and the local ids) changes.", "tree": {"sha": "caef57b361268262255d0d3dec39ee03179d604f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caef57b361268262255d0d3dec39ee03179d604f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2a34474bb86911c5235476d2ea820e163629fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2a34474bb86911c5235476d2ea820e163629fe", "html_url": "https://github.com/rust-lang/rust/commit/6e2a34474bb86911c5235476d2ea820e163629fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2a34474bb86911c5235476d2ea820e163629fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f304a5d7908d9dd55dda3baadd3cf564d907369", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f304a5d7908d9dd55dda3baadd3cf564d907369", "html_url": "https://github.com/rust-lang/rust/commit/5f304a5d7908d9dd55dda3baadd3cf564d907369"}, {"sha": "d794cb0d4fb795fc67e4e1e34c590d10e7189e76", "url": "https://api.github.com/repos/rust-lang/rust/commits/d794cb0d4fb795fc67e4e1e34c590d10e7189e76", "html_url": "https://github.com/rust-lang/rust/commit/d794cb0d4fb795fc67e4e1e34c590d10e7189e76"}], "stats": {"total": 562, "additions": 289, "deletions": 273}, "files": [{"sha": "bf70a41fd79e093d597b283d36b4682f2cbe3223", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -338,7 +338,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut generic_args = vec![];\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n-                let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let parent_def_id = self.current_hir_id_owner.0;\n                 let node_id = self.resolver.next_node_id();\n \n                 // Add a definition for the in-band const def."}, {"sha": "e7c566e586cbd53772599a9efc63560c501bfc75", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -165,7 +165,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n-    current_hir_id_owner: Vec<(LocalDefId, u32)>,\n+    current_hir_id_owner: (LocalDefId, u32),\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n@@ -321,7 +321,7 @@ pub fn lower_crate<'a, 'hir>(\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n         current_module: CRATE_DEF_ID,\n-        current_hir_id_owner: vec![(CRATE_DEF_ID, 0)],\n+        current_hir_id_owner: (CRATE_DEF_ID, 0),\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n@@ -594,9 +594,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_id = self.resolver.local_def_id(owner);\n-        self.current_hir_id_owner.push((def_id, counter));\n+        let old_owner = std::mem::replace(&mut self.current_hir_id_owner, (def_id, counter));\n         let ret = f(self);\n-        let (new_def_id, new_counter) = self.current_hir_id_owner.pop().unwrap();\n+        let (new_def_id, new_counter) =\n+            std::mem::replace(&mut self.current_hir_id_owner, old_owner);\n \n         debug_assert!(def_id == new_def_id);\n         debug_assert!(new_counter >= counter);\n@@ -614,8 +615,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n-            let &mut (owner, ref mut local_id_counter) =\n-                this.current_hir_id_owner.last_mut().unwrap();\n+            let &mut (owner, ref mut local_id_counter) = &mut this.current_hir_id_owner;\n             let local_id = *local_id_counter;\n             *local_id_counter += 1;\n             hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n@@ -868,10 +868,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // wouldn't have been added yet.\n                     let generics = this.lower_generics_mut(\n                         generics,\n-                        ImplTraitContext::Universal(\n-                            &mut params,\n-                            this.current_hir_id_owner.last().unwrap().0,\n-                        ),\n+                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner.0),\n                     );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n@@ -1077,7 +1074,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n-                let mut parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let mut parent_def_id = self.current_hir_id_owner.0;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1198,7 +1195,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Construct a AnonConst where the expr is the \"ty\"'s path.\n \n-                            let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                            let parent_def_id = self.current_hir_id_owner.0;\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n@@ -1814,10 +1811,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n                     this.lower_ty_direct(\n                         &param.ty,\n-                        ImplTraitContext::Universal(\n-                            ibty,\n-                            this.current_hir_id_owner.last().unwrap().0,\n-                        ),\n+                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner.0),\n                     )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())"}, {"sha": "d5697513eef1ea017515dcc1d5dd3b59d6048345", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -91,7 +91,7 @@ macro_rules! arena_types {\n             [] predicates: rustc_middle::ty::PredicateInner<$tcx>,\n \n             // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>,\n+            [few] indexed_hir: rustc_middle::hir::IndexedHir<$tcx>,\n             [few] hir_definitions: rustc_hir::definitions::Definitions,\n             [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n             [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,"}, {"sha": "719bbf04c95bd434bd525e6e1d8b6b64dbea0b9b", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 46, "deletions": 93, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -1,22 +1,20 @@\n use crate::arena::Arena;\n-use crate::hir::map::{Entry, HirOwnerData, Map};\n-use crate::hir::{Owner, OwnerNodes, ParentedNode};\n+use crate::hir::map::{HirOwnerData, Map};\n+use crate::hir::{IndexedHir, Owner, OwnerNodes, ParentedNode};\n use crate::ich::StableHashingContext;\n-use crate::middle::cstore::CrateStore;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n-use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{self, DefPathHash};\n+use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_session::{CrateDisambiguator, Session};\n+use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::iter::repeat;\n \n@@ -31,6 +29,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     source_map: &'a SourceMap,\n \n     map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    parenting: FxHashMap<LocalDefId, HirId>,\n \n     /// The parent of this node\n     parent_node: hir::HirId,\n@@ -40,10 +39,6 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     definitions: &'a definitions::Definitions,\n \n     hcx: StableHashingContext<'a>,\n-\n-    // We are collecting HIR hashes here so we can compute the\n-    // crate hash from them later on.\n-    hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n \n fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V) {\n@@ -58,34 +53,20 @@ fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V\n \n fn hash_body(\n     hcx: &mut StableHashingContext<'_>,\n-    def_path_hash: DefPathHash,\n     item_like: impl for<'a> HashStable<StableHashingContext<'a>>,\n-    hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n ) -> Fingerprint {\n-    let hash = {\n-        let mut stable_hasher = StableHasher::new();\n-        hcx.while_hashing_hir_bodies(true, |hcx| {\n-            item_like.hash_stable(hcx, &mut stable_hasher);\n-        });\n-        stable_hasher.finish()\n-    };\n-    hir_body_nodes.push((def_path_hash, hash));\n-    hash\n+    let mut stable_hasher = StableHasher::new();\n+    hcx.while_hashing_hir_bodies(true, |hcx| {\n+        item_like.hash_stable(hcx, &mut stable_hasher);\n+    });\n+    stable_hasher.finish()\n }\n \n-fn upstream_crates(cstore: &dyn CrateStore) -> Vec<(Symbol, Fingerprint, Svh)> {\n-    let mut upstream_crates: Vec<_> = cstore\n-        .crates_untracked()\n-        .iter()\n-        .map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum);\n-            let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n-            let hash = cstore.crate_hash_untracked(cnum);\n-            (name, disambiguator, hash)\n-        })\n-        .collect();\n-    upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name.as_str(), dis));\n-    upstream_crates\n+/// Represents an entry and its parent `HirId`.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Entry<'hir> {\n+    parent: HirId,\n+    node: Node<'hir>,\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n@@ -96,11 +77,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         definitions: &'a definitions::Definitions,\n         mut hcx: StableHashingContext<'a>,\n     ) -> NodeCollector<'a, 'hir> {\n-        let root_mod_def_path_hash =\n-            definitions.def_path_hash(LocalDefId { local_def_index: CRATE_DEF_INDEX });\n-\n-        let mut hir_body_nodes = Vec::new();\n-\n         let hash = {\n             let Crate {\n                 ref item,\n@@ -120,7 +96,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 attrs: _,\n             } = *krate;\n \n-            hash_body(&mut hcx, root_mod_def_path_hash, item, &mut hir_body_nodes)\n+            hash_body(&mut hcx, item)\n         };\n \n         let mut collector = NodeCollector {\n@@ -131,10 +107,10 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n             definitions,\n             hcx,\n-            hir_body_nodes,\n             map: (0..definitions.def_index_count())\n                 .map(|_| HirOwnerData { signature: None, with_bodies: None })\n                 .collect(),\n+            parenting: FxHashMap::default(),\n         };\n         collector.insert_entry(\n             hir::CRATE_HIR_ID,\n@@ -145,55 +121,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector\n     }\n \n-    pub(super) fn finalize_and_compute_crate_hash(\n-        mut self,\n-        crate_disambiguator: CrateDisambiguator,\n-        cstore: &dyn CrateStore,\n-        commandline_args_hash: u64,\n-    ) -> (IndexVec<LocalDefId, HirOwnerData<'hir>>, Svh) {\n+    pub(super) fn finalize_and_compute_crate_hash(mut self) -> IndexedHir<'hir> {\n         // Insert bodies into the map\n         for (id, body) in self.krate.bodies.iter() {\n             let bodies = &mut self.map[id.hir_id.owner].with_bodies.as_mut().unwrap().bodies;\n             assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n         }\n-\n-        self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n-\n-        let node_hashes = self.hir_body_nodes.iter().fold(\n-            Fingerprint::ZERO,\n-            |combined_fingerprint, &(def_path_hash, fingerprint)| {\n-                combined_fingerprint.combine(def_path_hash.0.combine(fingerprint))\n-            },\n-        );\n-\n-        let upstream_crates = upstream_crates(cstore);\n-\n-        // We hash the final, remapped names of all local source files so we\n-        // don't have to include the path prefix remapping commandline args.\n-        // If we included the full mapping in the SVH, we could only have\n-        // reproducible builds by compiling from the same directory. So we just\n-        // hash the result of the mapping instead of the mapping itself.\n-        let mut source_file_names: Vec<_> = self\n-            .source_map\n-            .files()\n-            .iter()\n-            .filter(|source_file| source_file.cnum == LOCAL_CRATE)\n-            .map(|source_file| source_file.name_hash)\n-            .collect();\n-\n-        source_file_names.sort_unstable();\n-\n-        let crate_hash_input = (\n-            ((node_hashes, upstream_crates), source_file_names),\n-            (commandline_args_hash, crate_disambiguator.to_fingerprint()),\n-        );\n-\n-        let mut stable_hasher = StableHasher::new();\n-        crate_hash_input.hash_stable(&mut self.hcx, &mut stable_hasher);\n-        let crate_hash: Fingerprint = stable_hasher.finish();\n-\n-        let svh = Svh::new(crate_hash.to_smaller_hash());\n-        (self.map, svh)\n+        IndexedHir { map: self.map, parenting: self.parenting }\n     }\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>, hash: Fingerprint) {\n@@ -218,8 +152,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             nodes.hash = hash;\n \n             debug_assert!(data.signature.is_none());\n-            data.signature =\n-                Some(self.arena.alloc(Owner { parent: entry.parent, node: entry.node }));\n+            data.signature = Some(self.arena.alloc(Owner { node: entry.node }));\n \n             let dk_parent = self.definitions.def_key(id.owner).parent;\n             if let Some(dk_parent) = dk_parent {\n@@ -231,6 +164,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                         id.owner, dk_parent, entry.parent,\n                     )\n                 }\n+\n+                debug_assert_eq!(self.parenting.get(&id.owner), Some(&entry.parent));\n             }\n         } else {\n             assert_eq!(entry.parent.owner, id.owner);\n@@ -294,15 +229,28 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         f: F,\n     ) {\n         let prev_owner = self.current_dep_node_owner;\n-\n-        let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n-\n-        let hash = hash_body(&mut self.hcx, def_path_hash, item_like, &mut self.hir_body_nodes);\n+        let hash = hash_body(&mut self.hcx, item_like);\n \n         self.current_dep_node_owner = dep_node_owner;\n         f(self, hash);\n         self.current_dep_node_owner = prev_owner;\n     }\n+\n+    fn insert_nested(&mut self, item: LocalDefId) {\n+        #[cfg(debug_assertions)]\n+        {\n+            let dk_parent = self.definitions.def_key(item).parent.unwrap();\n+            let dk_parent = LocalDefId { local_def_index: dk_parent };\n+            let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n+            debug_assert_eq!(\n+                dk_parent.owner, self.parent_node.owner,\n+                \"Different parents for {:?}\",\n+                item\n+            )\n+        }\n+\n+        assert_eq!(self.parenting.insert(item, self.parent_node), None);\n+    }\n }\n \n impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n@@ -318,18 +266,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n+        self.insert_nested(item.def_id);\n         self.visit_item(self.krate.item(item));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n+        self.insert_nested(item_id.def_id);\n         self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n+        self.insert_nested(item_id.def_id);\n         self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n+        self.insert_nested(foreign_id.def_id);\n         self.visit_foreign_item(self.krate.foreign_item(foreign_id));\n     }\n \n@@ -517,6 +469,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             self.definitions.local_def_id_to_hir_id(LocalDefId { local_def_index })\n         });\n         self.with_parent(parent, |this| {\n+            this.insert_nested(macro_def.def_id);\n             this.with_dep_node_owner(macro_def.def_id, macro_def, |this, hash| {\n                 this.insert_with_hash(\n                     macro_def.span,"}, {"sha": "73f3b550c3721f32ca5efb7c00d596eb4c28acad", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 189, "deletions": 132, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -1,8 +1,11 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{Owner, OwnerNodes};\n+use crate::hir::{HirOwnerData, IndexedHir};\n+use crate::middle::cstore::CrateStore;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -11,7 +14,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::*;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::Idx;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -21,22 +24,6 @@ use rustc_target::spec::abi::Abi;\n pub mod blocks;\n mod collector;\n \n-/// Represents an entry and its parent `HirId`.\n-#[derive(Copy, Clone, Debug)]\n-pub struct Entry<'hir> {\n-    parent: HirId,\n-    node: Node<'hir>,\n-}\n-\n-impl<'hir> Entry<'hir> {\n-    fn parent_node(self) -> Option<HirId> {\n-        match self.node {\n-            Node::Crate(_) => None,\n-            _ => Some(self.parent),\n-        }\n-    }\n-}\n-\n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n         Node::Item(Item { kind: ItemKind::Fn(sig, _, _), .. })\n@@ -86,20 +73,6 @@ fn is_body_owner<'hir>(node: Node<'hir>, hir_id: HirId) -> bool {\n     }\n }\n \n-#[derive(Debug)]\n-pub(super) struct HirOwnerData<'hir> {\n-    pub(super) signature: Option<&'hir Owner<'hir>>,\n-    pub(super) with_bodies: Option<&'hir mut OwnerNodes<'hir>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct IndexedHir<'hir> {\n-    /// The SVH of the local crate.\n-    pub crate_hash: Svh,\n-\n-    pub(super) map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n-}\n-\n #[derive(Copy, Clone)]\n pub struct Map<'hir> {\n     pub(super) tcx: TyCtxt<'hir>,\n@@ -129,10 +102,48 @@ impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n             }\n \n             self.current_id = parent_id;\n-            if let Some(entry) = self.map.find_entry(parent_id) {\n-                return Some((parent_id, entry.node));\n+            if let Some(node) = self.map.find(parent_id) {\n+                return Some((parent_id, node));\n+            }\n+            // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n+/// An iterator that walks up the ancestor tree of a given `HirId`.\n+/// Constructed using `tcx.hir().parent_owner_iter(hir_id)`.\n+pub struct ParentOwnerIterator<'map, 'hir> {\n+    current_id: HirId,\n+    map: &'map Map<'hir>,\n+}\n+\n+impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n+    type Item = (HirId, Node<'hir>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id.local_id.index() != 0 {\n+            self.current_id.local_id = ItemLocalId::new(0);\n+            if let Some(node) = self.map.find(self.current_id) {\n+                return Some((self.current_id, node));\n+            }\n+        }\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop {\n+            // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.def_key(self.current_id.owner).parent;\n+\n+            let parent_id = parent_id.map_or(CRATE_HIR_ID.owner, |local_def_index| {\n+                let def_id = LocalDefId { local_def_index };\n+                self.map.local_def_id_to_hir_id(def_id).owner\n+            });\n+            self.current_id = HirId::make_owner(parent_id);\n+\n+            // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n+            if let Some(node) = self.map.find(self.current_id) {\n+                return Some((self.current_id, node));\n             }\n-            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n         }\n     }\n }\n@@ -165,7 +176,7 @@ impl<'hir> Map<'hir> {\n             bug!(\n                 \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n                 hir_id,\n-                self.find_entry(hir_id)\n+                self.find(hir_id)\n             )\n         })\n     }\n@@ -272,27 +283,60 @@ impl<'hir> Map<'hir> {\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n-    fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n+    pub fn find_parent_node(&self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n-            let owner = self.tcx.hir_owner(id.owner);\n-            owner.map(|owner| Entry { parent: owner.parent, node: owner.node })\n+            Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n-            let owner = self.tcx.hir_owner_nodes(id.owner);\n-            owner.and_then(|owner| {\n-                let node = owner.nodes[id.local_id].as_ref();\n-                // FIXME(eddyb) use a single generic type instead of having both\n-                // `Entry` and `ParentedNode`, which are effectively the same.\n-                // Alternatively, rewrite code using `Entry` to use `ParentedNode`.\n-                node.map(|node| Entry {\n-                    parent: HirId { owner: id.owner, local_id: node.parent },\n-                    node: node.node,\n-                })\n-            })\n+            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let node = owner.nodes[id.local_id].as_ref()?;\n+            let hir_id = HirId { owner: id.owner, local_id: node.parent };\n+            Some(hir_id)\n+        }\n+    }\n+\n+    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n+        self.find_parent_node(hir_id).unwrap_or(CRATE_HIR_ID)\n+    }\n+\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n+    pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n+        if id.local_id == ItemLocalId::from_u32(0) {\n+            let owner = self.tcx.hir_owner(id.owner)?;\n+            Some(owner.node)\n+        } else {\n+            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let node = owner.nodes[id.local_id].as_ref()?;\n+            Some(node.node)\n         }\n     }\n \n-    fn get_entry(&self, id: HirId) -> Entry<'hir> {\n-        self.find_entry(id).unwrap()\n+    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n+    pub fn get(&self, id: HirId) -> Node<'hir> {\n+        self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n+    }\n+\n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n+    }\n+\n+    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n+        self.get_if_local(id).and_then(|node| match &node {\n+            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n+            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n+            Node::Item(Item {\n+                kind:\n+                    ItemKind::Fn(_, generics, _)\n+                    | ItemKind::TyAlias(_, generics)\n+                    | ItemKind::Enum(_, generics)\n+                    | ItemKind::Struct(_, generics)\n+                    | ItemKind::Union(_, generics)\n+                    | ItemKind::Trait(_, _, generics, ..)\n+                    | ItemKind::TraitAlias(generics, _)\n+                    | ItemKind::Impl(Impl { generics, .. }),\n+                ..\n+            }) => Some(generics),\n+            _ => None,\n+        })\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n@@ -457,7 +501,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.local_def_id_to_hir_id(module);\n-        match self.get_entry(hir_id).node {\n+        match self.get(hir_id) {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n             Node::Crate(item) => (&item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n@@ -496,60 +540,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: HirId) -> Node<'hir> {\n-        self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n-    }\n-\n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n-    }\n-\n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        self.get_if_local(id).and_then(|node| match &node {\n-            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n-            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n-            Node::Item(Item {\n-                kind:\n-                    ItemKind::Fn(_, generics, _)\n-                    | ItemKind::TyAlias(_, generics)\n-                    | ItemKind::Enum(_, generics)\n-                    | ItemKind::Struct(_, generics)\n-                    | ItemKind::Union(_, generics)\n-                    | ItemKind::Trait(_, _, generics, ..)\n-                    | ItemKind::TraitAlias(generics, _)\n-                    | ItemKind::Impl(Impl { generics, .. }),\n-                ..\n-            }) => Some(generics),\n-            _ => None,\n-        })\n-    }\n-\n-    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find_entry(hir_id).map(|entry| entry.node)\n-    }\n-\n-    /// Similar to `get_parent`; returns the parent HIR Id, or just `hir_id` if there\n-    /// is no parent. Note that the parent may be `CRATE_HIR_ID`, which is not itself\n-    /// present in the map, so passing the return value of `get_parent_node` to\n-    /// `get` may in fact panic.\n-    /// This function returns the immediate parent in the HIR, whereas `get_parent`\n-    /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the HIR -- some kinds of nodes are not in the map and these will\n-    /// never appear as the parent node. Thus, you can always walk the parent nodes\n-    /// from a node to the root of the HIR (unless you get back the same ID here,\n-    /// which can happen if the ID is not in the map itself or is just weird).\n-    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n-        self.get_entry(hir_id).parent_node().unwrap_or(hir_id)\n-    }\n-\n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n     /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n     pub fn parent_iter(&self, current_id: HirId) -> ParentHirIterator<'_, 'hir> {\n         ParentHirIterator { current_id, map: self }\n     }\n \n+    /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n+    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    pub fn parent_owner_iter(&self, current_id: HirId) -> ParentOwnerIterator<'_, 'hir> {\n+        ParentOwnerIterator { current_id, map: self }\n+    }\n+\n     /// Checks if the node is left-hand side of an assignment.\n     pub fn is_lhs(&self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n@@ -570,7 +572,7 @@ impl<'hir> Map<'hir> {\n     /// Whether `hir_id` corresponds to a `mod` or a crate.\n     pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n         matches!(\n-            self.get_entry(hir_id).node,\n+            self.get(hir_id),\n             Node::Item(Item { kind: ItemKind::Mod(_), .. }) | Node::Crate(..)\n         )\n     }\n@@ -600,8 +602,8 @@ impl<'hir> Map<'hir> {\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n-        if let Some(entry) = self.find_entry(id) {\n-            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n+        if let Some(node) = self.find(id) {\n+            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = node {\n                 // When dealing with `return` statements, we don't care about climbing only tail\n                 // expressions.\n                 ignore_tail = true;\n@@ -638,23 +640,23 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_iter(hir_id) {\n-            match node {\n-                Node::Crate(_)\n-                | Node::Item(_)\n-                | Node::ForeignItem(_)\n-                | Node::TraitItem(_)\n-                | Node::ImplItem(_) => return hir_id,\n-                _ => {}\n+        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n+            if let Node::Crate(_)\n+            | Node::Item(_)\n+            | Node::ForeignItem(_)\n+            | Node::TraitItem(_)\n+            | Node::ImplItem(_) = node\n+            {\n+                return hir_id;\n             }\n         }\n-        hir_id\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_iter(hir_id) {\n+        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n             if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n@@ -728,12 +730,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(entry) = self.find_entry(parent) {\n-            if let Entry {\n-                node: Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }),\n-                ..\n-            } = entry\n-            {\n+        if let Some(node) = self.find(parent) {\n+            if let Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node {\n                 return *abi;\n             }\n         }\n@@ -827,7 +825,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n-        let span = match self.find_entry(hir_id)?.node {\n+        let span = match self.find(hir_id)? {\n             Node::Param(param) => param.span,\n             Node::Item(item) => match &item.kind {\n                 ItemKind::Fn(sig, _, _) => sig.span,\n@@ -876,7 +874,7 @@ impl<'hir> Map<'hir> {\n     /// Like `hir.span()`, but includes the body of function items\n     /// (instead of just the function header)\n     pub fn span_with_body(&self, hir_id: HirId) -> Span {\n-        match self.find_entry(hir_id).map(|entry| entry.node) {\n+        match self.find(hir_id) {\n             Some(Node::TraitItem(item)) => item.span,\n             Some(Node::ImplItem(impl_item)) => impl_item.span,\n             Some(Node::Item(item)) => item.span,\n@@ -935,19 +933,78 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n \n     let _prof_timer = tcx.sess.prof.generic_activity(\"build_hir_map\");\n \n-    let (map, crate_hash) = {\n-        let hcx = tcx.create_stable_hashing_context();\n+    let hcx = tcx.create_stable_hashing_context();\n+    let mut collector =\n+        NodeCollector::root(tcx.sess, &**tcx.arena, tcx.untracked_crate, &tcx.definitions, hcx);\n+    intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n \n-        let mut collector =\n-            NodeCollector::root(tcx.sess, &**tcx.arena, tcx.untracked_crate, &tcx.definitions, hcx);\n-        intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n+    let map = collector.finalize_and_compute_crate_hash();\n+    tcx.arena.alloc(map)\n+}\n \n-        let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n-        let cmdline_args = tcx.sess.opts.dep_tracking_hash(true);\n-        collector.finalize_and_compute_crate_hash(crate_disambiguator, &*tcx.cstore, cmdline_args)\n-    };\n+pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n+    let mut hir_body_nodes: Vec<_> = tcx\n+        .index_hir(crate_num)\n+        .map\n+        .iter_enumerated()\n+        .filter_map(|(def_id, hod)| {\n+            let def_path_hash = tcx.definitions.def_path_hash(def_id);\n+            let hash = hod.with_bodies.as_ref()?.hash;\n+            Some((def_path_hash, hash))\n+        })\n+        .collect();\n+    hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n-    tcx.arena.alloc(IndexedHir { crate_hash, map })\n+    let node_hashes = hir_body_nodes.iter().fold(\n+        Fingerprint::ZERO,\n+        |combined_fingerprint, &(def_path_hash, fingerprint)| {\n+            combined_fingerprint.combine(def_path_hash.0.combine(fingerprint))\n+        },\n+    );\n+\n+    let upstream_crates = upstream_crates(&*tcx.cstore);\n+\n+    // We hash the final, remapped names of all local source files so we\n+    // don't have to include the path prefix remapping commandline args.\n+    // If we included the full mapping in the SVH, we could only have\n+    // reproducible builds by compiling from the same directory. So we just\n+    // hash the result of the mapping instead of the mapping itself.\n+    let mut source_file_names: Vec<_> = tcx\n+        .sess\n+        .source_map()\n+        .files()\n+        .iter()\n+        .filter(|source_file| source_file.cnum == LOCAL_CRATE)\n+        .map(|source_file| source_file.name_hash)\n+        .collect();\n+\n+    source_file_names.sort_unstable();\n+\n+    let mut hcx = tcx.create_stable_hashing_context();\n+    let mut stable_hasher = StableHasher::new();\n+    node_hashes.hash_stable(&mut hcx, &mut stable_hasher);\n+    upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n+    source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n+    tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n+    tcx.sess.local_crate_disambiguator().to_fingerprint().hash_stable(&mut hcx, &mut stable_hasher);\n+\n+    let crate_hash: Fingerprint = stable_hasher.finish();\n+    Svh::new(crate_hash.to_smaller_hash())\n+}\n+\n+fn upstream_crates(cstore: &dyn CrateStore) -> Vec<(Symbol, Fingerprint, Svh)> {\n+    let mut upstream_crates: Vec<_> = cstore\n+        .crates_untracked()\n+        .iter()\n+        .map(|&cnum| {\n+            let name = cstore.crate_name_untracked(cnum);\n+            let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n+            let hash = cstore.crate_hash_untracked(cnum);\n+            (name, disambiguator, hash)\n+        })\n+        .collect();\n+    upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name.as_str(), dis));\n+    upstream_crates\n }\n \n fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {"}, {"sha": "565664778e56570975a2c05ac77d6eaa6107bb2a", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -19,19 +19,27 @@ use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;\n use std::collections::BTreeMap;\n \n+#[derive(Debug)]\n+struct HirOwnerData<'hir> {\n+    signature: Option<&'hir Owner<'hir>>,\n+    with_bodies: Option<&'hir mut OwnerNodes<'hir>>,\n+}\n+\n+#[derive(Debug)]\n+pub struct IndexedHir<'hir> {\n+    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    parenting: FxHashMap<LocalDefId, HirId>,\n+}\n+\n #[derive(Debug)]\n pub struct Owner<'tcx> {\n-    parent: HirId,\n     node: Node<'tcx>,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Owner { parent, node } = self;\n-        hcx.while_hashing_hir_bodies(false, |hcx| {\n-            parent.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n-        });\n+        let Owner { node } = self;\n+        hcx.while_hashing_hir_bodies(false, |hcx| node.hash_stable(hcx, hasher));\n     }\n }\n \n@@ -117,9 +125,14 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n+    providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.hir_owner_parent = |tcx, id| {\n+        let index = tcx.index_hir(LOCAL_CRATE);\n+        index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)\n+    };\n     providers.hir_attrs = |tcx, id| AttributeMap { map: &tcx.untracked_crate.attrs, prefix: id };\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {"}, {"sha": "3ffc3641b62aad465b8cd754613ce9c3564f060e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -28,7 +28,7 @@ rustc_queries! {\n \n     /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query index_hir(_: CrateNum) -> &'tcx map::IndexedHir<'tcx> {\n+    query index_hir(_: CrateNum) -> &'tcx crate::hir::IndexedHir<'tcx> {\n         eval_always\n         no_hash\n         desc { \"index HIR\" }\n@@ -52,6 +52,15 @@ rustc_queries! {\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n+    /// Gives access to the HIR node's parent for the HIR owner `key`.\n+    ///\n+    /// This can be conveniently accessed by methods on `tcx.hir()`.\n+    /// Avoid calling this query directly.\n+    query hir_owner_parent(key: LocalDefId) -> hir::HirId {\n+        eval_always\n+        desc { |tcx| \"HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+    }\n+\n     /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`."}, {"sha": "81230e32f56bd926cfecbc86a61682721a9f4bdd", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -1,6 +1,5 @@\n use crate::dep_graph;\n use crate::hir::exports::Export;\n-use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;"}, {"sha": "144c7281b67c1a2e996e10d0b5af652f166a7cb8", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::hir::map as hir_map;\n@@ -400,10 +399,6 @@ fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n     tcx.crate_name\n }\n \n-fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    tcx.index_hir(crate_num).crate_hash\n-}\n-\n fn instance_def_size_estimate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance_def: ty::InstanceDef<'tcx>,\n@@ -551,7 +546,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         trait_of_item,\n         crate_disambiguator,\n         original_crate_name,\n-        crate_hash,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,"}, {"sha": "70ce81bd473df65d7c5c4972862f0f072ead7577", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,associated_item_def_ids\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,associated_item_def_ids\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -85,7 +85,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail2\", except=\"associated_item,hir_owner,hir_owner_nodes\")]\n@@ -100,7 +100,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_dirty(cfg=\"cfail2\", except=\"type_of,predicates_of,promoted_mir\")]\n@@ -135,7 +135,7 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,associated_item_def_ids\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,associated_item_def_ids\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail2\")]\n@@ -468,7 +468,7 @@ impl Bar<u32> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n     #[rustc_clean(cfg=\"cfail2\", except=\"fn_sig,optimized_mir,typeck\")]"}, {"sha": "d874be060c26a080c8d74fa0bb943450ac31cce0", "filename": "src/test/incremental/hashes/type_defs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -24,7 +24,7 @@\n type ChangePrimitiveType = i32;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangePrimitiveType = i64;\n \n@@ -35,7 +35,7 @@ type ChangePrimitiveType = i64;\n type ChangeMutability = &'static i32;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangeMutability = &'static mut i32;\n \n@@ -60,7 +60,7 @@ struct Struct2;\n type ChangeTypeStruct = Struct1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangeTypeStruct = Struct2;\n \n@@ -71,7 +71,7 @@ type ChangeTypeStruct = Struct2;\n type ChangeTypeTuple = (u32, u64);\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangeTypeTuple = (u32, i64);\n \n@@ -91,7 +91,7 @@ enum Enum2 {\n type ChangeTypeEnum = Enum1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangeTypeEnum = Enum2;\n \n@@ -102,7 +102,7 @@ type ChangeTypeEnum = Enum2;\n type AddTupleField = (i32, i64);\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type AddTupleField = (i32, i64, i16);\n \n@@ -113,7 +113,7 @@ type AddTupleField = (i32, i64, i16);\n type ChangeNestedTupleField = (i32, (i64, i16));\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n #[rustc_clean(cfg=\"cfail3\")]\n type ChangeNestedTupleField = (i32, (i64, i8));\n "}, {"sha": "8df54467e5e5c20e006c495ef6b2521491bea55c", "filename": "src/test/incremental/ich_nested_items.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a34474bb86911c5235476d2ea820e163629fe/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_nested_items.rs?ref=6e2a34474bb86911c5235476d2ea820e163629fe", "patch": "@@ -14,10 +14,7 @@ pub fn foo() {\n     #[cfg(cfail1)]\n     pub fn baz() {} // order is different...\n \n-    // FIXME: Make \"hir_owner\" use `rustc_clean` here. Currently \"hir_owner\" includes a reference to\n-    // the parent node, which is the statement holding this item. Changing the position of\n-    // `bar` in `foo` will update that reference and make `hir_owner(bar)` dirty.\n-    #[rustc_dirty(label = \"hir_owner\", cfg = \"cfail2\")]\n+    #[rustc_clean(label = \"hir_owner\", cfg = \"cfail2\")]\n     #[rustc_clean(label = \"hir_owner_nodes\", cfg = \"cfail2\")]\n     pub fn bar() {} // but that doesn't matter.\n "}]}