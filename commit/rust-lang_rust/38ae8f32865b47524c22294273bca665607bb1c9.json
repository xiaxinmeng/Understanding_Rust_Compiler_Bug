{"sha": "38ae8f32865b47524c22294273bca665607bb1c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YWU4ZjMyODY1YjQ3NTI0YzIyMjk0MjczYmNhNjY1NjA3YmIxYzk=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-04-24T10:53:18Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-05-08T08:59:08Z"}, "message": "Simplify the `tcx.alloc_map` API", "tree": {"sha": "92f4ec3085c2a1307d526580531bed5616b3f3c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92f4ec3085c2a1307d526580531bed5616b3f3c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38ae8f32865b47524c22294273bca665607bb1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38ae8f32865b47524c22294273bca665607bb1c9", "html_url": "https://github.com/rust-lang/rust/commit/38ae8f32865b47524c22294273bca665607bb1c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38ae8f32865b47524c22294273bca665607bb1c9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29630cea47506125fb0b94318104b1b93a59b052", "url": "https://api.github.com/repos/rust-lang/rust/commits/29630cea47506125fb0b94318104b1b93a59b052", "html_url": "https://github.com/rust-lang/rust/commit/29630cea47506125fb0b94318104b1b93a59b052"}], "stats": {"total": 154, "additions": 71, "deletions": 83}, "files": [{"sha": "b39a851475b02b425d30344951069c363894795f", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -244,8 +244,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n             Scalar::Ptr(ptr) => {\n-                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                let base_addr = match alloc_kind {\n+                let base_addr = match self.tcx.get_global_alloc(ptr.alloc_id) {\n                     Some(GlobalAlloc::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {"}, {"sha": "937c7457c63bb29e874cdd1de751f0528b3b127f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n                 let a = Scalar::from(Pointer::new(\n-                    bx.tcx().alloc_map.lock().create_memory_alloc(data),\n+                    bx.tcx().create_memory_alloc(data),\n                     Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend("}, {"sha": "377c8661cbd4169771bfb5dd18870d004f16f47f", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -136,8 +136,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let alloc_kind = tcx.alloc_map.lock().get(*self);\n-            alloc_kind.hash_stable(hcx, hasher);\n+            tcx.get_global_alloc(*self).hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "f2a24c0e2291041bc071d9eff2e757ad106173dd", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -197,9 +197,7 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for given alloc ID\");\n-    match alloc {\n+    match tcx.get_global_alloc(alloc_id).expect(\"no value for given alloc ID\") {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             AllocDiscriminant::Alloc.encode(encoder)?;\n@@ -294,7 +292,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n+                            let alloc_id = decoder.tcx().reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -338,23 +336,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n+                    let alloc_id = decoder.tcx().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n+                    let alloc_id = decoder.tcx().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n             }\n@@ -400,12 +398,6 @@ impl<'tcx> AllocMap<'tcx> {\n     pub fn new() -> Self {\n         AllocMap { alloc_map: Default::default(), dedup: Default::default(), next_id: AllocId(0) }\n     }\n-\n-    /// Obtains a new allocation ID that can be referenced but does not\n-    /// yet have an allocation backing it.\n-    ///\n-    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n-    /// an `AllocId` from a query.\n     pub fn reserve(&mut self) -> AllocId {\n         let next = self.next_id;\n         self.next_id.0 = self.next_id.0.checked_add(1).expect(\n@@ -415,34 +407,46 @@ impl<'tcx> AllocMap<'tcx> {\n         );\n         next\n     }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Obtains a new allocation ID that can be referenced but does not\n+    /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n+    /// an `AllocId` from a query.\n+    pub fn reserve_alloc_id(&self) -> AllocId {\n+        self.alloc_map.lock().reserve()\n+    }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n-    fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+    fn reserve_and_set_dedup(&self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+        let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n             GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n             GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n         }\n-        if let Some(&alloc_id) = self.dedup.get(&alloc) {\n+        if let Some(&alloc_id) = alloc_map.dedup.get(&alloc) {\n             return alloc_id;\n         }\n-        let id = self.reserve();\n+        let id = alloc_map.reserve();\n         debug!(\"creating alloc {:?} with id {}\", alloc, id);\n-        self.alloc_map.insert(id, alloc.clone());\n-        self.dedup.insert(alloc, id);\n+        alloc_map.alloc_map.insert(id, alloc.clone());\n+        alloc_map.dedup.insert(alloc, id);\n         id\n     }\n \n     /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n-    pub fn create_static_alloc(&mut self, static_id: DefId) -> AllocId {\n+    pub fn create_static_alloc(&self, static_id: DefId) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n     /// Generates an `AllocId` for a function.  Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n+    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n         // duplicated across crates.\n@@ -456,8 +460,9 @@ impl<'tcx> AllocMap<'tcx> {\n         });\n         if is_generic {\n             // Get a fresh ID.\n-            let id = self.reserve();\n-            self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n+            let mut alloc_map = self.alloc_map.lock();\n+            let id = alloc_map.reserve();\n+            alloc_map.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n             // Deduplicate.\n@@ -470,8 +475,8 @@ impl<'tcx> AllocMap<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(&mut self, mem: &'tcx Allocation) -> AllocId {\n-        let id = self.reserve();\n+    pub fn create_memory_alloc(&self, mem: &'tcx Allocation) -> AllocId {\n+        let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n     }\n@@ -482,38 +487,38 @@ impl<'tcx> AllocMap<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n-        self.alloc_map.get(&id).cloned()\n+    pub fn get_global_alloc(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+        self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n     /// Panics if the `AllocId` does not refer to an `Allocation`\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n-        match self.get(id) {\n+        match self.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation ID {} to point to memory\", id),\n         }\n     }\n \n     /// Panics if the `AllocId` does not refer to a function\n     pub fn unwrap_fn(&self, id: AllocId) -> Instance<'tcx> {\n-        match self.get(id) {\n+        match self.get_global_alloc(id) {\n             Some(GlobalAlloc::Function(instance)) => instance,\n             _ => bug!(\"expected allocation ID {} to point to a function\", id),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n+    pub fn set_alloc_id_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n+    fn set_alloc_id_same_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }\n "}, {"sha": "15ab3b7c757fce5020606dd804a39f7e03faabf0", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -2410,7 +2410,7 @@ pub struct Constant<'tcx> {\n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.val.try_to_scalar() {\n-            Some(Scalar::Ptr(ptr)) => match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+            Some(Scalar::Ptr(ptr)) => match tcx.get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Static(def_id)) => Some(def_id),\n                 Some(_) => None,\n                 None => {"}, {"sha": "7554c36c467ebb44f3240132aa9906214cd826fd", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -975,7 +975,7 @@ pub struct GlobalCtxt<'tcx> {\n     allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n     /// Stores memory for globals (statics/consts).\n-    pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n+    pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: ShardedHashMap<&'tcx Layout, ()>,\n \n@@ -1013,7 +1013,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n-        self.alloc_map.lock().create_memory_alloc(alloc)\n+        self.create_memory_alloc(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {"}, {"sha": "5100156868275aef445d60f54c5e2882efd7b97d", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -956,8 +956,6 @@ pub trait PrettyPrinter<'tcx>:\n             ) => {\n                 let byte_str = self\n                     .tcx()\n-                    .alloc_map\n-                    .lock()\n                     .unwrap_memory(ptr.alloc_id)\n                     .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n@@ -1021,10 +1019,7 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n-                let instance = {\n-                    let alloc_map = self.tcx().alloc_map.lock();\n-                    alloc_map.unwrap_fn(ptr.alloc_id)\n-                };\n+                let instance = self.tcx().unwrap_fn(ptr.alloc_id);\n                 self = self.typed_value(\n                     |this| this.print_value_path(instance.def_id(), instance.substs),\n                     |this| this.print_type(ty),"}, {"sha": "34e4f0b04630abab2cebe2b4c8e2aefe99c3f4f2", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -549,9 +549,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     if a_val == b_val {\n                         Ok(ConstValue::Scalar(a_val))\n                     } else if let ty::FnPtr(_) = a.ty.kind {\n-                        let alloc_map = tcx.alloc_map.lock();\n-                        let a_instance = alloc_map.unwrap_fn(a_val.assert_ptr().alloc_id);\n-                        let b_instance = alloc_map.unwrap_fn(b_val.assert_ptr().alloc_id);\n+                        let a_instance = tcx.unwrap_fn(a_val.assert_ptr().alloc_id);\n+                        let b_instance = tcx.unwrap_fn(b_val.assert_ptr().alloc_id);\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {"}, {"sha": "9627c03d92868bb52f1b1b2ed665e7bb281dd170", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -130,7 +130,7 @@ pub(super) fn op_to_const<'tcx>(\n \n     let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n         Scalar::Ptr(ptr) => {\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            let alloc = ecx.tcx.unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n         Scalar::Raw { data, .. } => {\n@@ -154,9 +154,7 @@ pub(super) fn op_to_const<'tcx>(\n             },\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.not_undef().unwrap() {\n-                    Scalar::Ptr(ptr) => {\n-                        (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                    }\n+                    Scalar::Ptr(ptr) => (ecx.tcx.unwrap_memory(ptr.alloc_id), ptr.offset.bytes()),\n                     Scalar::Raw { .. } => (\n                         ecx.tcx\n                             .intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n@@ -202,10 +200,7 @@ fn validate_and_turn_into_const<'tcx>(\n         // whether they become immediates.\n         if is_static || cid.promoted.is_some() {\n             let ptr = mplace.ptr.assert_ptr();\n-            Ok(ConstValue::ByRef {\n-                alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                offset: ptr.offset,\n-            })\n+            Ok(ConstValue::ByRef { alloc: ecx.tcx.unwrap_memory(ptr.alloc_id), offset: ptr.offset })\n         } else {\n             Ok(op_to_const(&ecx, mplace.into()))\n         }"}, {"sha": "1c44101595d4f26f3c835d3c4fb59f1b09697ad1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -91,7 +91,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n             // to validation to error. The `delay_span_bug` ensures that we don't forget such\n             // a check in validation.\n-            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    tcx.set_alloc_id_memory(alloc_id, alloc);\n     Ok(None)\n }\n \n@@ -389,7 +389,7 @@ where\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n-            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            tcx.set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n                 if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n@@ -398,7 +398,7 @@ where\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n             throw_ub_format!(\"encountered dangling pointer in final constant\")\n-        } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+        } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n             // as dangling by local memory.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);"}, {"sha": "5d7a826c52374e191166d7f47cd9f4492c4db42f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -153,10 +153,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n     ) -> Pointer<M::PointerTag> {\n         let id = match fn_val {\n-            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Instance(instance) => self.tcx.create_fn_alloc(instance),\n             FnVal::Other(extra) => {\n                 // FIXME(RalfJung): Should we have a cache here?\n-                let id = self.tcx.alloc_map.lock().reserve();\n+                let id = self.tcx.reserve_alloc_id();\n                 let old = self.extra_fn_ptr_map.insert(id, extra);\n                 assert!(old.is_none());\n                 id\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().reserve();\n+        let id = self.tcx.reserve_alloc_id();\n         debug_assert_ne!(\n             Some(kind),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating global memory -- always an error\n-                return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                return Err(match self.tcx.get_global_alloc(ptr.alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n                     Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n                         err_ub_format!(\"deallocating static memory\")\n@@ -429,8 +429,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        let (alloc, def_id) = match alloc {\n+        let (alloc, def_id) = match tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -468,7 +467,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     })?;\n                 // Make sure we use the ID of the resolved memory, not the lazy one!\n                 let id = raw_const.alloc_id;\n-                let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+                let allocation = tcx.unwrap_memory(id);\n \n                 (allocation, Some(def_id))\n             }\n@@ -591,8 +590,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);\n@@ -627,7 +625,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n-            match self.tcx.alloc_map.lock().get(id) {\n+            match self.tcx.get_global_alloc(id) {\n                 Some(GlobalAlloc::Function(instance)) => Some(FnVal::Instance(instance)),\n                 _ => None,\n             }\n@@ -695,7 +693,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 None => {\n                     // global alloc\n-                    match self.tcx.alloc_map.lock().get(id) {\n+                    match self.tcx.get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             eprint!(\" (unchanged global, \");\n                             write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);"}, {"sha": "59c84f70cfd82b5eafe531120d0e035f04f1e45c", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -549,7 +549,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n-                let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n+                let id = self.tcx.create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n@@ -560,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n                 let ptr = Pointer::new(\n-                    self.tcx.alloc_map.lock().create_memory_alloc(data),\n+                    self.tcx.create_memory_alloc(data),\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice("}, {"sha": "005e628f9c941726e900d1f232ded3506bec4cec", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -1101,7 +1101,7 @@ where\n         raw: RawConst<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n-        assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        assert!(self.tcx.get_global_alloc(raw.alloc_id).is_some());\n         let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))"}, {"sha": "8faa079551bdba3dab3239954225be54f36e3d5a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -416,7 +416,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n-                let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     // See const_eval::machine::MemoryExtra::can_access_statics for why\n                     // this check is so important."}, {"sha": "f1630f1bd9fb430fade4d567df7a32d23e7e9a13", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -1136,8 +1136,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n-    let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n-    match alloc_kind {\n+    match tcx.get_global_alloc(alloc_id) {\n         Some(GlobalAlloc::Static(def_id)) => {\n             let instance = Instance::mono(tcx, def_id);\n             if should_monomorphize_locally(tcx, &instance) {"}, {"sha": "03a4df919ba2dab1296bc0e5a216c3b7f1983dcf", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -586,8 +586,7 @@ pub fn write_allocations<'tcx>(\n                 write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,"}, {"sha": "8d572465d62c19f7fe8a3025ac7694bb69a7b69b", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -740,7 +740,7 @@ fn convert_path_expr<'a, 'tcx>(\n         // a constant reference (or constant raw pointer for `static mut`) in MIR\n         Res::Def(DefKind::Static, id) => {\n             let ty = cx.tcx.static_ptr_ty(id);\n-            let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n+            let ptr = cx.tcx.create_static_alloc(id);\n             let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n             ExprKind::Deref {\n                 arg: Expr {"}, {"sha": "e5573767b66d53a1ad1a0cd60b81598334e79af0", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae8f32865b47524c22294273bca665607bb1c9/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=38ae8f32865b47524c22294273bca665607bb1c9", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(p), x, y) if x == y => {\n                 match p {\n                     Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                        let alloc = self.tcx.unwrap_memory(p.alloc_id);\n                         ConstValue::ByRef { alloc, offset: p.offset }\n                     }\n                     Scalar::Raw { .. } => {\n@@ -305,7 +305,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n                 ConstValue::Slice {\n-                    data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                    data: self.tcx.unwrap_memory(p.alloc_id),\n                     start: p.offset.bytes().try_into().unwrap(),\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }"}]}