{"sha": "3dca3393fa6459da14151b22f403b3f3b8dada55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkY2EzMzkzZmE2NDU5ZGExNDE1MWIyMmY0MDNiM2YzYjhkYWRhNTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T14:15:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T22:30:08Z"}, "message": "switch over to using new serialize/deserialize code", "tree": {"sha": "b853d8f9c95ea3fdc062ff294cc536689dd54d89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b853d8f9c95ea3fdc062ff294cc536689dd54d89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dca3393fa6459da14151b22f403b3f3b8dada55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dca3393fa6459da14151b22f403b3f3b8dada55", "html_url": "https://github.com/rust-lang/rust/commit/3dca3393fa6459da14151b22f403b3f3b8dada55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dca3393fa6459da14151b22f403b3f3b8dada55/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f69e9ff643921bfe81f2d772042eae3f5acabaef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69e9ff643921bfe81f2d772042eae3f5acabaef", "html_url": "https://github.com/rust-lang/rust/commit/f69e9ff643921bfe81f2d772042eae3f5acabaef"}], "stats": {"total": 422, "additions": 278, "deletions": 144}, "files": [{"sha": "92ad024619ecedb611dd4d6ba73ec46cb18bf2fa", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 148, "deletions": 20, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -13,14 +13,19 @@ import std::serialization::serializer;\n import std::serialization::deserializer;\n import std::serialization::serializer_helpers;\n import std::serialization::deserializer_helpers;\n+import std::prettyprint::serializer;\n import std::smallintmap::map;\n import middle::trans::common::maps;\n import middle::{ty, typeck, last_use, ast_map};\n-import middle::typeck::method_origin;\n-import middle::typeck::vtable_res;\n-import middle::typeck::vtable_origin;\n+import middle::typeck::{method_origin,\n+                        serialize_method_origin,\n+                        deserialize_method_origin,\n+                        vtable_res,\n+                        vtable_origin};\n import driver::session::session;\n-import middle::freevars::freevar_entry;\n+import middle::freevars::{freevar_entry,\n+                          serialize_freevar_entry,\n+                          deserialize_freevar_entry};\n import c = common;\n import e = encoder;\n \n@@ -302,13 +307,13 @@ impl of tr for span {\n \n impl serializer_helpers<S: serializer> for S {\n     fn emit_def_id(did: ast::def_id) {\n-        astencode_gen::serialize_syntax_ast_def_id(self, did)\n+        ast::serialize_def_id(self, did)\n     }\n }\n \n impl deserializer_helpers<D: deserializer> for D {\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n-        let did = astencode_gen::deserialize_syntax_ast_def_id(self);\n+        let did = ast::deserialize_def_id(self);\n         did.tr(xcx)\n     }\n }\n@@ -330,7 +335,7 @@ impl deserializer_helpers<D: deserializer> for D {\n \n fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_tree as uint) {||\n-        astencode_gen::serialize_syntax_ast_inlined_item(ebml_w, item)\n+        ast::serialize_inlined_item(ebml_w, item)\n     }\n }\n \n@@ -375,7 +380,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree];\n     let d = ebml::ebml_deserializer(chi_doc);\n-    astencode_gen::deserialize_syntax_ast_inlined_item(d)\n+    ast::deserialize_inlined_item(d)\n }\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n@@ -400,12 +405,12 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // Encoding and decoding of ast::def\n \n fn encode_def(ebml_w: ebml::writer, def: ast::def) {\n-    astencode_gen::serialize_syntax_ast_def(ebml_w, def)\n+    ast::serialize_def(ebml_w, def)\n }\n \n fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n     let dsr = ebml::ebml_deserializer(doc);\n-    let def = astencode_gen::deserialize_syntax_ast_def(dsr);\n+    let def = ast::deserialize_def(dsr);\n     def.tr(xcx)\n }\n \n@@ -448,13 +453,12 @@ impl of tr for ast::def {\n // Encoding and decoding of freevar information\n \n fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n-    astencode_gen::serialize_middle_freevars_freevar_entry(ebml_w, fv)\n+    serialize_freevar_entry(ebml_w, fv)\n }\n \n impl helper for ebml::ebml_deserializer {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n-        let fv =\n-            astencode_gen::deserialize_middle_freevars_freevar_entry(self);\n+        let fv = deserialize_freevar_entry(self);\n         fv.tr(xcx)\n     }\n }\n@@ -469,16 +473,16 @@ impl of tr for freevar_entry {\n // Encoding and decoding of method_origin\n \n fn encode_method_origin(ebml_w: ebml::writer, mo: method_origin) {\n-    astencode_gen::serialize_middle_typeck_method_origin(ebml_w, mo)\n+    serialize_method_origin(ebml_w, mo)\n }\n \n impl helper for ebml::ebml_deserializer {\n     fn read_method_origin(xcx: extended_decode_ctxt) -> method_origin {\n-        let fv = astencode_gen::deserialize_middle_typeck_method_origin(self);\n+        let fv = deserialize_method_origin(self);\n         fv.tr(xcx)\n     }\n     fn read_is_last_use(xcx: extended_decode_ctxt) -> last_use::is_last_use {\n-        let lu = astencode_gen::deserialize_middle_last_use_is_last_use(self);\n+        let lu = last_use::deserialize_is_last_use(self);\n         lu.tr(xcx)\n     }\n }\n@@ -692,7 +696,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         ebml_w.tag(c::tag_table_def) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-                astencode_gen::serialize_syntax_ast_def(ebml_w, def)\n+                ast::serialize_def(ebml_w, def)\n             }\n         }\n     }\n@@ -774,7 +778,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-               astencode_gen::serialize_middle_last_use_is_last_use(ebml_w, m)\n+                last_use::serialize_is_last_use(ebml_w, m)\n             }\n         }\n     }\n@@ -786,8 +790,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         ebml_w.tag(c::tag_table_method_map) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-                astencode_gen::\n-                    serialize_middle_typeck_method_origin(ebml_w, mo)\n+                serialize_method_origin(ebml_w, mo)\n             }\n         }\n     }\n@@ -901,3 +904,128 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n         #debug[\">< Side table doc loaded\"];\n     }\n }\n+\n+// ______________________________________________________________________\n+// Testing of astencode_gen\n+\n+#[cfg(test)]\n+fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n+    ebml_w.wr_tag(c::tag_tree as uint) {||\n+        ast::serialize_item(ebml_w, *item);\n+    }\n+}\n+\n+#[cfg(test)]\n+fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n+    let chi_doc = par_doc[c::tag_tree];\n+    let d = ebml::ebml_deserializer(chi_doc);\n+    @ast::deserialize_item(d)\n+}\n+\n+#[cfg(test)]\n+fn new_parse_sess() -> parser::parse_sess {\n+    let cm = codemap::new_codemap();\n+    let handler = diagnostic::mk_handler(option::none);\n+    let sess = @{\n+        cm: cm,\n+        mutable next_id: 1,\n+        span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n+        mutable chpos: 0u,\n+        mutable byte_pos: 0u\n+    };\n+    ret sess;\n+}\n+\n+#[cfg(test)]\n+iface fake_ext_ctxt {\n+    fn session() -> fake_session;\n+}\n+\n+#[cfg(test)]\n+type fake_options = {cfg: ast::crate_cfg};\n+\n+#[cfg(test)]\n+type fake_session = {opts: @fake_options,\n+                     parse_sess: parser::parse_sess};\n+\n+#[cfg(test)]\n+impl of fake_ext_ctxt for fake_session {\n+    fn session() -> fake_session {self}\n+}\n+\n+#[cfg(test)]\n+fn mk_ctxt() -> fake_ext_ctxt {\n+    let opts : fake_options = {cfg: []};\n+    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+}\n+\n+#[cfg(test)]\n+fn roundtrip(in_item: @ast::item) {\n+    #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n+    let mbuf = io::mem_buffer();\n+    let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n+    encode_item_ast(ebml_w, in_item);\n+    let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n+    let out_item = decode_item_ast(ebml_doc);\n+    #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n+\n+    let exp_str =\n+        io::with_str_writer {|w| ast::serialize_item(w, *in_item) };\n+    let out_str =\n+        io::with_str_writer {|w| ast::serialize_item(w, *out_item) };\n+\n+    #debug[\"expected string: %s\", exp_str];\n+    #debug[\"actual string  : %s\", out_str];\n+\n+    assert exp_str == out_str;\n+}\n+\n+#[test]\n+fn test_basic() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo() {}\n+    });\n+}\n+\n+#[test]\n+fn test_smalltalk() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n+    });\n+}\n+\n+#[test]\n+fn test_more() {\n+    let ext_cx = mk_ctxt();\n+    roundtrip(#ast(item){\n+        fn foo(x: uint, y: uint) -> uint {\n+            let z = x + y;\n+            ret z;\n+        }\n+    });\n+}\n+\n+#[test]\n+fn test_simplification() {\n+    let ext_cx = mk_ctxt();\n+    let item_in = ast::ii_item(#ast(item) {\n+        fn new_int_alist<B: copy>() -> alist<int, B> {\n+            fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+            ret {eq_fn: eq_int, mut data: []};\n+        }\n+    });\n+    let item_out = simplify_ast(item_in);\n+    let item_exp = ast::ii_item(#ast(item) {\n+        fn new_int_alist<B: copy>() -> alist<int, B> {\n+            ret {eq_fn: eq_int, mut data: []};\n+        }\n+    });\n+    alt (item_out, item_exp) {\n+      (ast::ii_item(item_out), ast::ii_item(item_exp)) {\n+        assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n+      }\n+      _ { fail; }\n+    }\n+}"}, {"sha": "f6dd7d991026b19821e22b5fc14d84f193863863", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -5,18 +5,20 @@ import syntax::print::pprust::path_to_str;\n import std::map::*;\n import option::*;\n import syntax::{ast, ast_util, visit};\n+import syntax::ast::{serialize_span, deserialize_span};\n import middle::resolve;\n import syntax::codemap::span;\n \n export annotate_freevars;\n export freevar_map;\n export freevar_info;\n-export freevar_entry;\n+export freevar_entry, serialize_freevar_entry, deserialize_freevar_entry;\n export get_freevars;\n export has_freevars;\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n+#[auto_serialize]\n type freevar_entry = {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)"}, {"sha": "cca276f9a7399bf8070a3730467a9581c2195638", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -25,6 +25,7 @@ import std::map::hashmap;\n // (by `break` or conditionals), and for handling loops.\n \n // Marks expr_paths that are last uses.\n+#[auto_serialize]\n enum is_last_use {\n     is_last_use,\n     has_last_use,"}, {"sha": "1e092a6eb78c87fb0f4d61a0c011e326ed786532", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -14,13 +14,17 @@ import middle::ty::{node_id_to_type, arg, block_ty,\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::map::{hashmap, int_hash};\n+import std::serialization::{serialize_uint, deserialize_uint};\n import syntax::print::pprust::*;\n \n export check_crate;\n-export method_map, method_origin, method_static, method_param, method_iface;\n-export vtable_map, vtable_res, vtable_origin, vtable_static, vtable_param,\n-       vtable_iface;\n+export method_map;\n+export method_origin, serialize_method_origin, deserialize_method_origin;\n+export vtable_map;\n+export vtable_res;\n+export vtable_origin;\n \n+#[auto_serialize]\n enum method_origin {\n     method_static(ast::def_id),\n     // iface id, method num, param num, bound num\n@@ -37,6 +41,7 @@ enum vtable_origin {\n     vtable_param(uint, uint),\n     vtable_iface(ast::def_id, [ty::t]),\n }\n+\n type vtable_map = hashmap<ast::node_id, vtable_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;"}, {"sha": "43b0d5e03913c283bf49fce79509bad7532f7e8e", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -26,45 +26,45 @@ fn deserialize_span<D>(_d: D) -> span {\n     ast_util::dummy_sp()\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type spanned<T> = {node: T, span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ident = str;\n \n // Functions may or may not have names.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type fn_ident = option<ident>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type path_ = {global: bool, idents: [ident], types: [@ty]};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type path = spanned<path_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type crate_num = int;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type node_id = int;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type def_id = {crate: crate_num, node: node_id};\n \n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum ty_param_bound {\n     bound_copy,\n     bound_send,\n     bound_iface(@ty),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum def {\n     def_fn(def_id, purity),\n     def_self(node_id),\n@@ -119,30 +119,30 @@ enum crate_directive_ {\n \n type crate_directive = spanned<crate_directive_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type meta_item = spanned<meta_item_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum meta_item_ {\n     meta_word(ident),\n     meta_list(ident, [@meta_item]),\n     meta_name_value(ident, lit),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type blk = spanned<blk_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option<@expr>,\n              id: node_id, rules: blk_check_mode};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type pat = {id: node_id, node: pat_, span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type field_pat = {ident: ident, pat: @pat};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -162,10 +162,10 @@ enum pat_ {\n     pat_range(@expr, @expr),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum proto {\n     proto_bare,    // native fn\n     proto_any,     // fn\n@@ -181,7 +181,7 @@ pure fn is_blockish(p: ast::proto) -> bool {\n     }\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum binop {\n     add,\n     subtract,\n@@ -204,7 +204,7 @@ enum binop {\n     gt,\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -213,23 +213,23 @@ enum unop {\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum inferable<T> {\n     expl(T), infer(node_id)\n }\n \n // \"resolved\" mode: the real modes.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n // inferable mode.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mode = inferable<rmode>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type stmt = spanned<stmt_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -240,48 +240,48 @@ enum stmt_ {\n     stmt_semi(@expr, node_id),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum init_op { init_assign, init_move, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type initializer = {op: init_op, expr: @expr};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type local_ =  // FIXME: should really be a refinement on pat\n     {is_mutbl: bool, ty: @ty, pat: @pat,\n      init: option<initializer>, id: node_id};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type local = spanned<local_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type decl = spanned<decl_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum decl_ { decl_local([@local]), decl_item(@item), }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type arm = {pats: [@pat], guard: option<@expr>, body: blk};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type field = spanned<field_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum blk_check_mode { default_blk, unchecked_blk, unsafe_blk, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum expr_check_mode { claimed_expr, checked_expr, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type expr = {id: node_id, node: expr_, span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum alt_mode { alt_check, alt_exhaustive, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum expr_ {\n     expr_vec([@expr], mutability),\n     expr_rec([field], option<@expr>),\n@@ -337,14 +337,14 @@ enum expr_ {\n     expr_mac(mac),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type capture_item = {\n     id: int,\n     name: ident, // Currently, can only capture a local var.\n     span: span\n };\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type capture_clause = {\n     copies: [@capture_item],\n     moves: [@capture_item]\n@@ -359,19 +359,19 @@ enum blk_sort {\n }\n */\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mac = spanned<mac_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mac_arg = option<@expr>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mac_body_ = {span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mac_body = option<mac_body_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body),\n     mac_embed_type(@ty),\n@@ -382,10 +382,10 @@ enum mac_ {\n     mac_var(uint)\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type lit = spanned<lit_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum lit_ {\n     lit_str(str),\n     lit_int(i64, int_ty),\n@@ -397,33 +397,33 @@ enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type mt = {ty: @ty, mutbl: mutability};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_field_ = {ident: ident, mt: mt};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_field = spanned<ty_field_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_method = {ident: ident, attrs: [attribute],\n                   decl: fn_decl, tps: [ty_param], span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -432,17 +432,17 @@ enum prim_ty {\n     ty_bool,\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type region = {id: node_id, node: region_};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum region_ {\n     re_inferred,\n     re_named(ident),\n     re_self\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -472,121 +472,121 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum constr_arg_general_<T> { carg_base, carg_ident(T), carg_lit(@lit), }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type fn_constr_arg = constr_arg_general_<uint>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_constr_arg = sp_constr_arg<@path>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type constr_arg = spanned<fn_constr_arg>;\n \n // Constrained types' args are parameterized by paths, since\n // we refer to paths directly and not by indices.\n // The implicit root of such path, in the constraint-list for a\n // constrained type, is * (referring to the base record)\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type constr_general_<ARG, ID> =\n     {path: @path, args: [@spanned<constr_arg_general_<ARG>>], id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type constr_general<ARG> = spanned<constr_general_<ARG, node_id>>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type constr_ = constr_general_<uint, node_id>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type constr = spanned<constr_general_<uint, node_id>>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_constr_ = constr_general_<@path, node_id>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type ty_constr = spanned<ty_constr_>;\n \n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n  corresponding to these. */\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type fn_decl =\n     {inputs: [arg],\n      output: @ty,\n      purity: purity,\n      cf: ret_style,\n      constraints: [@constr]};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n     impure_fn, // declared with \"fn\"\n     crust_fn, // declared with \"crust fn\"\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type method = {ident: ident, attrs: [attribute],\n                tps: [ty_param], decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type _mod = {view_items: [@view_item], items: [@item]};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum native_abi {\n     native_abi_rust_intrinsic,\n     native_abi_cdecl,\n     native_abi_stdcall,\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type native_mod =\n     {view_items: [@view_item],\n      items: [@native_item]};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type variant_arg = {ty: @ty, id: node_id};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n                  id: node_id, disr_expr: option<@expr>};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type variant = spanned<variant_>;\n \n // FIXME: May want to just use path here, which would allow things like\n // 'import ::foo'\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type simple_path = [ident];\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type path_list_ident_ = {name: ident, id: node_id};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type path_list_ident = spanned<path_list_ident_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type view_path = spanned<view_path_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -603,34 +603,34 @@ enum view_path_ {\n     view_path_list(@simple_path, [path_list_ident], node_id)\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type view_item = spanned<view_item_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum view_item_ {\n     view_item_use(ident, [@meta_item], node_id),\n     view_item_import([@view_path]),\n     view_item_export([@view_path])\n }\n \n // Meta-data associated with an item\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type attribute = spanned<attribute_>;\n \n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum attr_style { attr_outer, attr_inner, }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type attribute_ = {style: attr_style, value: meta_item};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, [ty_param], blk),\n@@ -650,13 +650,13 @@ enum item_ {\n               @ty /* self */, [@method]),\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type class_item_ = {privacy: privacy, decl: class_member};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type class_item = spanned<class_item_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum class_member {\n     instance_var(ident, @ty, class_mutability, node_id),\n     class_method(@item) // FIXME: methods aren't allowed to be\n@@ -665,37 +665,37 @@ enum class_member {\n     // item to separate out things with type params?\n }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum class_mutability { class_mutable, class_immutable }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum privacy { priv, pub }\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type class_ctor = spanned<class_ctor_>;\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type class_ctor_ = {id: node_id,\n                     dec: fn_decl,\n                     body: blk};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n type native_item =\n     {ident: ident,\n      attrs: [attribute],\n      node: native_item_,\n      id: node_id,\n      span: span};\n \n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum native_item_ {\n     native_item_fn(fn_decl, [ty_param]),\n }\n \n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-/*#[auto_serialize]*/\n+#[auto_serialize]\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method)"}, {"sha": "0a3e42aee344e0a40acd3990d100611b2366bf62", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -117,13 +117,14 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                   meta_name_value(fld.fold_ident(id), s)\n                 }\n               },\n-          span: mi.span};\n+          span: fld.new_span(mi.span)};\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: attribute, fmi: fn@(&&@meta_item) -> @meta_item) ->\n+fn fold_attribute_(at: attribute, fld: ast_fold) ->\n    attribute {\n-    ret {node: {style: at.node.style, value: *fmi(@at.node.value)},\n-         span: at.span};\n+    ret {node: {style: at.node.style,\n+                value: *fold_meta_item_(@at.node.value, fld)},\n+         span: fld.new_span(at.span)};\n }\n //used in noop_fold_native_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n@@ -148,7 +149,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                mac_aq(_,_) { /* fixme */ m.node }\n                mac_var(_) { /* fixme */ m.node }\n              },\n-         span: m.span};\n+         span: fld.new_span(m.span)};\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n@@ -178,7 +179,7 @@ fn fold_ty_params(tps: [ty_param], fld: ast_fold) -> [ty_param] {\n \n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n+    let fold_attribute = bind fold_attribute_(_, fld);\n \n     ret {directives: vec::map(c.directives, fld.fold_crate_directive),\n          module: fld.fold_mod(c.module),\n@@ -208,8 +209,7 @@ fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n \n fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n     let fold_arg = bind fold_arg_(_, fld);\n-    let fold_meta_item = bind fold_meta_item_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n+    let fold_attribute = bind fold_attribute_(_, fld);\n \n     ret @{ident: fld.fold_ident(ni.ident),\n           attrs: vec::map(ni.attrs, fold_attribute),\n@@ -231,8 +231,7 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n }\n \n fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n-    let fold_meta_item = bind fold_meta_item_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n+    let fold_attribute = bind fold_attribute_(_, fld);\n \n     ret @{ident: fld.fold_ident(i.ident),\n           attrs: vec::map(i.attrs, fold_attribute),\n@@ -252,7 +251,7 @@ fn noop_fold_class_item(&&ci: @class_item, fld: ast_fold)\n         }\n         class_method(i) { class_method(fld.fold_item(i)) }\n          }},\n-       span: ci.span}\n+       span: fld.new_span(ci.span)}\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n@@ -374,7 +373,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                  {mutbl: field.node.mutbl,\n                   ident: fld.fold_ident(field.node.ident),\n                   expr: fld.fold_expr(field.node.expr)},\n-             span: field.span};\n+             span: fld.new_span(field.span)};\n     }\n     let fold_field = bind fold_field_(_, fld);\n \n@@ -519,8 +518,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n     let args = vec::map(v.args, fold_variant_arg);\n \n-    let fold_meta_item = bind fold_meta_item_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n+    let fold_attribute = bind fold_attribute_(_, fld);\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n     let de = alt v.disr_expr {"}]}