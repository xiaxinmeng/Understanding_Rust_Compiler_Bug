{"sha": "9b47586a47888f24f8f5565731db44480cce7e28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDc1ODZhNDc4ODhmMjRmOGY1NTY1NzMxZGI0NDQ4MGNjZTdlMjg=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-30T17:43:04Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-19T09:06:21Z"}, "message": "update coercion docs", "tree": {"sha": "b5980e6fcd60a107e060426f3f7e963880fff418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5980e6fcd60a107e060426f3f7e963880fff418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b47586a47888f24f8f5565731db44480cce7e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b47586a47888f24f8f5565731db44480cce7e28", "html_url": "https://github.com/rust-lang/rust/commit/9b47586a47888f24f8f5565731db44480cce7e28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b47586a47888f24f8f5565731db44480cce7e28/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b5007e4b7c4ee9a3d0356e54f91ef3def094a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5007e4b7c4ee9a3d0356e54f91ef3def094a0a", "html_url": "https://github.com/rust-lang/rust/commit/0b5007e4b7c4ee9a3d0356e54f91ef3def094a0a"}], "stats": {"total": 49, "additions": 18, "deletions": 31}, "files": [{"sha": "aac4466b6abab7284399f5f33ecf63a98abaa9df", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9b47586a47888f24f8f5565731db44480cce7e28/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b47586a47888f24f8f5565731db44480cce7e28/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9b47586a47888f24f8f5565731db44480cce7e28", "patch": "@@ -10,45 +10,30 @@\n //!\n //! Note that if we are expecting a reference, we will *reborrow*\n //! even if the argument provided was already a reference. This is\n-//! useful for freezing mut/const things (that is, when the expected is &T\n-//! but you have &const T or &mut T) and also for avoiding the linearity\n+//! useful for freezing mut things (that is, when the expected type is &T\n+//! but you have &mut T) and also for avoiding the linearity\n //! of mut things (when the expected is &mut T and you have &mut T). See\n-//! the various `src/test/ui/coerce-reborrow-*.rs` tests for\n+//! the various `src/test/ui/coerce/*.rs` tests for\n //! examples of where this is useful.\n //!\n //! ## Subtle note\n //!\n-//! When deciding what type coercions to consider, we do not attempt to\n-//! resolve any type variables we may encounter. This is because `b`\n-//! represents the expected type \"as the user wrote it\", meaning that if\n-//! the user defined a generic function like\n+//! When infering the generic arguments of functions, the argument\n+//! order is relevant, which can lead to the following edge case:\n //!\n-//!    fn foo<A>(a: A, b: A) { ... }\n+//! ```rust\n+//! fn foo<T>(a: T, b: T) {\n+//!     // ...\n+//! }\n //!\n-//! and then we wrote `foo(&1, @2)`, we will not auto-borrow\n-//! either argument. In older code we went to some lengths to\n-//! resolve the `b` variable, which could mean that we'd\n-//! auto-borrow later arguments but not earlier ones, which\n-//! seems very confusing.\n+//! foo(&7i32, &mut 7i32);\n+//! // This compiles, as we first infer `T` to be `&i32`,\n+//! // and then coerce `&mut 7i32` to `&7i32`.\n //!\n-//! ## Subtler note\n-//!\n-//! However, right now, if the user manually specifies the\n-//! values for the type variables, as so:\n-//!\n-//!    foo::<&int>(@1, @2)\n-//!\n-//! then we *will* auto-borrow, because we can't distinguish this from a\n-//! function that declared `&int`. This is inconsistent but it's easiest\n-//! at the moment. The right thing to do, I think, is to consider the\n-//! *unsubstituted* type when deciding whether to auto-borrow, but the\n-//! *substituted* type when considering the bounds and so forth. But most\n-//! of our methods don't give access to the unsubstituted type, and\n-//! rightly so because they'd be error-prone. So maybe the thing to do is\n-//! to actually determine the kind of coercions that should occur\n-//! separately and pass them in. Or maybe it's ok as is. Anyway, it's\n-//! sort of a minor point so I've opted to leave it for later -- after all,\n-//! we may want to adjust precisely when coercions occur.\n+//! foo(&mut 7i32, &7i32);\n+//! // This does not compile, as we first infer `T` to be `&mut i32`\n+//! // and are then unable to coerce `&7i32` to `&mut i32`.\n+//! ```\n \n use crate::astconv::AstConv;\n use crate::check::{FnCtxt, Needs};\n@@ -96,6 +81,8 @@ impl<'a, 'tcx> Deref for Coerce<'a, 'tcx> {\n \n type CoerceResult<'tcx> = InferResult<'tcx, (Vec<Adjustment<'tcx>>, Ty<'tcx>)>;\n \n+/// Coercing a mutable reference to an immutable works, while\n+/// coercing `&T` to `&mut T` should be forbidden.\n fn coerce_mutbls<'tcx>(\n     from_mutbl: hir::Mutability,\n     to_mutbl: hir::Mutability,"}]}