{"sha": "b8169a6da07f123cda26b5903e3d6032dd00efb9", "node_id": "C_kwDOAAsO6NoAKGI4MTY5YTZkYTA3ZjEyM2NkYTI2YjU5MDNlM2Q2MDMyZGQwMGVmYjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-02T21:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-02T21:08:08Z"}, "message": "Auto merge of #97802 - Enselic:add-no_ignore_sigkill-feature, r=joshtriplett\n\nSupport `#[unix_sigpipe = \"inherit|sig_dfl\"]` on `fn main()` to prevent ignoring `SIGPIPE`\n\nWhen enabled, programs don't have to explicitly handle `ErrorKind::BrokenPipe` any longer. Currently, the program\n\n```rust\nfn main() { loop { println!(\"hello world\"); } }\n```\n\nwill print an error if used with a short-lived pipe, e.g.\n\n    % ./main | head -n 1\n    hello world\n    thread 'main' panicked at 'failed printing to stdout: Broken pipe (os error 32)', library/std/src/io/stdio.rs:1016:9\n    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\nby enabling `#[unix_sigpipe = \"sig_dfl\"]` like this\n\n```rust\n#![feature(unix_sigpipe)]\n#[unix_sigpipe = \"sig_dfl\"]\nfn main() { loop { println!(\"hello world\"); } }\n```\n\nthere is no error, because `SIGPIPE` will not be ignored and thus the program will be killed appropriately:\n\n    % ./main | head -n 1\n    hello world\n\nThe current libstd behaviour of ignoring `SIGPIPE` before `fn main()` can be explicitly requested by using `#[unix_sigpipe = \"sig_ign\"]`.\n\nWith `#[unix_sigpipe = \"inherit\"]`, no change at all is made to `SIGPIPE`, which typically means the behaviour will be the same as `#[unix_sigpipe = \"sig_dfl\"]`.\n\nSee https://github.com/rust-lang/rust/issues/62569 and referenced issues for discussions regarding the `SIGPIPE` problem itself\n\nSee the [this](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Proposal.3A.20First.20step.20towards.20solving.20the.20SIGPIPE.20problem) Zulip topic for more discussions, including about this PR.\n\nTracking issue: https://github.com/rust-lang/rust/issues/97889", "tree": {"sha": "3be34c6a03cda97ef2ce1d2bef6da41f87845669", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3be34c6a03cda97ef2ce1d2bef6da41f87845669"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8169a6da07f123cda26b5903e3d6032dd00efb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8169a6da07f123cda26b5903e3d6032dd00efb9", "html_url": "https://github.com/rust-lang/rust/commit/b8169a6da07f123cda26b5903e3d6032dd00efb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8169a6da07f123cda26b5903e3d6032dd00efb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb2016a7ea703f4ffbb9dd4ad7ad25ee4b549f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb2016a7ea703f4ffbb9dd4ad7ad25ee4b549f5", "html_url": "https://github.com/rust-lang/rust/commit/bfb2016a7ea703f4ffbb9dd4ad7ad25ee4b549f5"}, {"sha": "4b3aa91b03c3dbfd05becbd890b4b06574092aab", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3aa91b03c3dbfd05becbd890b4b06574092aab", "html_url": "https://github.com/rust-lang/rust/commit/4b3aa91b03c3dbfd05becbd890b4b06574092aab"}], "stats": {"total": 15, "additions": 9, "deletions": 6}, "files": [{"sha": "3c024a84d9091f1fb3bf1533443d4ed5bed5a27d", "filename": "src/main_shim.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8169a6da07f123cda26b5903e3d6032dd00efb9/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8169a6da07f123cda26b5903e3d6032dd00efb9/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=b8169a6da07f123cda26b5903e3d6032dd00efb9", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir::LangItem;\n use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::AssocKind;\n-use rustc_session::config::EntryFnType;\n+use rustc_session::config::{sigpipe, EntryFnType};\n use rustc_span::symbol::Ident;\n \n use crate::prelude::*;\n@@ -15,12 +15,12 @@ pub(crate) fn maybe_create_entry_wrapper(\n     is_jit: bool,\n     is_primary_cgu: bool,\n ) {\n-    let (main_def_id, is_main_fn) = match tcx.entry_fn(()) {\n+    let (main_def_id, (is_main_fn, sigpipe)) = match tcx.entry_fn(()) {\n         Some((def_id, entry_ty)) => (\n             def_id,\n             match entry_ty {\n-                EntryFnType::Main => true,\n-                EntryFnType::Start => false,\n+                EntryFnType::Main { sigpipe } => (true, sigpipe),\n+                EntryFnType::Start => (false, sigpipe::DEFAULT),\n             },\n         ),\n         None => return,\n@@ -35,7 +35,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn);\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn, sigpipe);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n@@ -44,6 +44,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         rust_main_def_id: DefId,\n         ignore_lang_start_wrapper: bool,\n         is_main_fn: bool,\n+        sigpipe: u8,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -83,6 +84,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.switch_to_block(block);\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n+            let arg_sigpipe = bcx.ins().iconst(types::I8, sigpipe as i64);\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n@@ -143,7 +145,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                let call_inst = bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv]);\n+                let call_inst =\n+                    bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv, arg_sigpipe]);\n                 bcx.inst_results(call_inst)[0]\n             } else {\n                 // using user-defined start fn"}]}