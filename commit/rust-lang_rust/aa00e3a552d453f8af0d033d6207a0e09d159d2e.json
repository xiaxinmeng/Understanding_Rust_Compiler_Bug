{"sha": "aa00e3a552d453f8af0d033d6207a0e09d159d2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDBlM2E1NTJkNDUzZjhhZjBkMDMzZDYyMDdhMGUwOWQxNTlkMmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-12T18:19:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-12T18:23:26Z"}, "message": "re-introduce a cache for ast-ty-to-ty\n\nIt turns out that `ast_ty_to_ty` is supposed to be updating the `def`\nafter it finishes, but at some point in the past it stopped doing\nso. This was never noticed because of the `ast_ty_to_ty_cache`, but that\ncache was recently removed. This PR fixes the code to update the def\nproperly, but apparently that is not quite enough to make the operation\nidempotent, so for now we reintroduce the cache too.\n\nFixes #33425.", "tree": {"sha": "0a19e17062d44baf5da8f0f8c434e7fff53896e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a19e17062d44baf5da8f0f8c434e7fff53896e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa00e3a552d453f8af0d033d6207a0e09d159d2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa00e3a552d453f8af0d033d6207a0e09d159d2e", "html_url": "https://github.com/rust-lang/rust/commit/aa00e3a552d453f8af0d033d6207a0e09d159d2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa00e3a552d453f8af0d033d6207a0e09d159d2e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88defe71806ad190588e168e513bc1098f7c9fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88defe71806ad190588e168e513bc1098f7c9fb", "html_url": "https://github.com/rust-lang/rust/commit/e88defe71806ad190588e168e513bc1098f7c9fb"}], "stats": {"total": 125, "additions": 98, "deletions": 27}, "files": [{"sha": "9cec3a517949635dd0c44897cfbad6d09220ef8f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -2544,6 +2544,8 @@ impl<'a> Resolver<'a> {\n     /// returned value. See `hir::def::PathResolution` for more info.\n     fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n                     -> Result<PathResolution, bool /* true if an error was reported */ > {\n+        debug!(\"resolve_path(id={:?} path={:?}, path_depth={:?})\", id, path, path_depth);\n+\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n "}, {"sha": "c8e247fb9181c7a3e733c0fbd6a556f26e13106c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -64,10 +64,10 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n              ElisionFailureInfo, ElidedLifetime};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::{NodeMap, FnvHashSet};\n \n use rustc_const_math::ConstInt;\n-\n+use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n@@ -81,6 +81,9 @@ use rustc_back::slice;\n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n+    /// A cache used for the result of `ast_ty_to_ty_cache`\n+    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n+\n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n     /// type parameters defined on the item.\n@@ -1416,13 +1419,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                       rscope: &RegionScope,\n                       span: Span,\n                       param_mode: PathParamMode,\n-                      def: &Def,\n+                      def: Def,\n                       opt_self_ty: Option<Ty<'tcx>>,\n                       base_segments: &[hir::PathSegment])\n                       -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        match *def {\n+        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, base_segments={:?})\",\n+               def, opt_self_ty, base_segments);\n+\n+        match def {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n@@ -1515,20 +1521,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                       rscope: &RegionScope,\n                                       span: Span,\n                                       param_mode: PathParamMode,\n-                                      def: &Def,\n+                                      mut def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_segments: &[hir::PathSegment],\n                                       assoc_segments: &[hir::PathSegment])\n-                                      -> Ty<'tcx> {\n+                                      -> (Ty<'tcx>, Def) {\n+        debug!(\"finish_resolving_def_to_ty(def={:?}, \\\n+                base_segments={:?}, \\\n+                assoc_segments={:?})\",\n+               def,\n+               base_segments,\n+               assoc_segments);\n         let mut ty = self.base_def_to_ty(rscope,\n                                          span,\n                                          param_mode,\n                                          def,\n                                          opt_self_ty,\n                                          base_segments);\n-        let mut def = *def;\n+        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", ty);\n         // If any associated type segments remain, attempt to resolve them.\n         for segment in assoc_segments {\n+            debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n             if ty.sty == ty::TyError {\n                 break;\n             }\n@@ -1540,7 +1553,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             ty = a_ty;\n             def = a_def;\n         }\n-        ty\n+        (ty, def)\n     }\n \n     /// Parses the programmer's textual representation of a type into our\n@@ -1551,7 +1564,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let tcx = self.tcx();\n \n-        match ast_ty.node {\n+        let cache = self.ast_ty_to_ty_cache();\n+        match cache.borrow().get(&ast_ty.id) {\n+            Some(ty) => { return ty; }\n+            None => { }\n+        }\n+\n+        let result_ty = match ast_ty.node {\n             hir::TyVec(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n             }\n@@ -1599,6 +1618,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n             hir::TyPath(ref maybe_qself, ref path) => {\n+                debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n                     d\n                 } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n@@ -1615,13 +1635,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(rscope, &qself.ty)\n                 });\n-                let ty = self.finish_resolving_def_to_ty(rscope,\n-                                                         ast_ty.span,\n-                                                         PathParamMode::Explicit,\n-                                                         &def,\n-                                                         opt_self_ty,\n-                                                         &path.segments[..base_ty_end],\n-                                                         &path.segments[base_ty_end..]);\n+                let (ty, _def) = self.finish_resolving_def_to_ty(rscope,\n+                                                                 ast_ty.span,\n+                                                                 PathParamMode::Explicit,\n+                                                                 def,\n+                                                                 opt_self_ty,\n+                                                                 &path.segments[..base_ty_end],\n+                                                                 &path.segments[base_ty_end..]);\n \n                 if path_res.depth != 0 && ty.sty != ty::TyError {\n                     // Write back the new resolution.\n@@ -1675,7 +1695,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, None, None, ast_ty.span)\n             }\n-        }\n+        };\n+\n+        cache.borrow_mut().insert(ast_ty.id, result_ty);\n+\n+        result_ty\n     }\n \n     pub fn ty_of_arg(&self,"}, {"sha": "6dfad749982b6e1886ce2b2869de28b2b1ce9a2a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -346,6 +346,8 @@ impl UnsafetyState {\n \n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+\n     body_id: ast::NodeId,\n \n     // This flag is set to true if, during the writeback phase, we encounter\n@@ -1262,6 +1264,10 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n+    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>> {\n+        &self.ast_ty_to_ty_cache\n+    }\n+\n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n@@ -1434,6 +1440,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n+            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             body_id: body_id,\n             writeback_errors: Cell::new(false),\n             err_count_on_creation: inh.tcx.sess.err_count(),\n@@ -3845,15 +3852,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if path_res.depth == 0 {\n             Some((opt_self_ty, &path.segments, path_res.base_def))\n         } else {\n-            let mut def = path_res.base_def;\n+            let def = path_res.base_def;\n             let ty_segments = path.segments.split_last().unwrap().1;\n             let base_ty_end = path.segments.len() - path_res.depth;\n-            let ty = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                         PathParamMode::Optional,\n-                                                         &mut def,\n-                                                         opt_self_ty,\n-                                                         &ty_segments[..base_ty_end],\n-                                                         &ty_segments[base_ty_end..]);\n+            let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n+                                                                 PathParamMode::Optional,\n+                                                                 def,\n+                                                                 opt_self_ty,\n+                                                                 &ty_segments[..base_ty_end],\n+                                                                 &ty_segments[base_ty_end..]);\n             let item_segment = path.segments.last().unwrap();\n             let item_name = item_segment.identifier.name;\n             let def = match self.resolve_ufcs(span, item_name, ty, node_id) {"}, {"sha": "f9a22e2a577b426b91f472f3dd7a8c5f8e18b299", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -78,11 +78,12 @@ use rscope::*;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{NodeMap, FnvHashMap};\n use {CrateCtxt, write_ty_to_tcx};\n \n use rustc_const_math::ConstInt;\n \n+use std::cell::RefCell;\n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n@@ -146,7 +147,10 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx>\n \n impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     fn icx(&'a self, param_bounds: &'a GetTypeParameterBounds<'tcx>) -> ItemCtxt<'a,'tcx> {\n-        ItemCtxt { ccx: self, param_bounds: param_bounds }\n+        ItemCtxt {\n+            ccx: self,\n+            param_bounds: param_bounds,\n+        }\n     }\n \n     fn cycle_check<F,R>(&self,\n@@ -298,6 +302,10 @@ impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.ccx.tcx }\n \n+    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>> {\n+        &self.ccx.ast_ty_to_ty_cache\n+    }\n+\n     fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {"}, {"sha": "f41da95c1353700432ac6246b82b5eed3b569826", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -116,6 +116,7 @@ use syntax::ast;\n use syntax::abi::Abi;\n \n use std::cell::RefCell;\n+use util::nodemap::NodeMap;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -136,7 +137,9 @@ pub struct TypeAndSubsts<'tcx> {\n }\n \n pub struct CrateCtxt<'a, 'tcx: 'a> {\n-    // A mapping from method call sites to traits that have that method.\n+    ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+\n+    /// A mapping from method call sites to traits that have that method.\n     pub trait_map: hir::TraitMap,\n \n     /// A vector of every trait accessible in the whole crate\n@@ -334,6 +337,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> CompileResult {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n+        ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n         trait_map: trait_map,\n         all_traits: RefCell::new(None),\n         stack: RefCell::new(Vec::new()),"}, {"sha": "18803d15719e88cdce7fd764457d67e878fe0d42", "filename": "src/test/run-pass/associated-types-in-bound-type-arg.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Ftest%2Frun-pass%2Fassociated-types-in-bound-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00e3a552d453f8af0d033d6207a0e09d159d2e/src%2Ftest%2Frun-pass%2Fassociated-types-in-bound-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-in-bound-type-arg.rs?ref=aa00e3a552d453f8af0d033d6207a0e09d159d2e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test the case where we resolve `C::Result` and the trait bound\n+// itself includes a `Self::Item` shorthand.\n+//\n+// Regression test for issue #33425.\n+\n+trait ParallelIterator {\n+    type Item;\n+    fn drive_unindexed<C>(self, consumer: C) -> C::Result\n+        where C: Consumer<Self::Item>;\n+}\n+\n+pub trait Consumer<ITEM> {\n+    type Result;\n+}\n+\n+fn main() { }"}]}