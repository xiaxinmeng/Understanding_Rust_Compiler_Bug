{"sha": "3f58828fdc3d1eb114c47bf1331a9bb638eab246", "node_id": "C_kwDOAAsO6NoAKDNmNTg4MjhmZGMzZDFlYjExNGM0N2JmMTMzMWE5YmI2MzhlYWIyNDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-14T02:49:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-14T02:49:21Z"}, "message": "Auto merge of #94773 - cjgillot:lifetime-fresh-did, r=oli-obk\n\nIdentify anonymous lifetimes by their DefId in HIR.\n\n`ParamName::Fresh` currently identifies anonymous lifetimes by an `usize` index computed from the number of lifetimes in scope. This makes the behaviour of lowering dependent on the contents of the surrounding item in unpredictable ways.\n\nThis PR replaces this index by the `LocalDefId` of the synthetized generic lifetime parameter. This makes obvious which parameter the lifetime corresponds to.", "tree": {"sha": "d3edf6858e89f8feadd843c88f32c47c42b4d8ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3edf6858e89f8feadd843c88f32c47c42b4d8ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f58828fdc3d1eb114c47bf1331a9bb638eab246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f58828fdc3d1eb114c47bf1331a9bb638eab246", "html_url": "https://github.com/rust-lang/rust/commit/3f58828fdc3d1eb114c47bf1331a9bb638eab246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f58828fdc3d1eb114c47bf1331a9bb638eab246/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737ef08ea066cbdc9f4b93373b1a1a108e6691ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/737ef08ea066cbdc9f4b93373b1a1a108e6691ab", "html_url": "https://github.com/rust-lang/rust/commit/737ef08ea066cbdc9f4b93373b1a1a108e6691ab"}, {"sha": "c8c691ff88713d6c4012ec5978d51cbe11300a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c691ff88713d6c4012ec5978d51cbe11300a94", "html_url": "https://github.com/rust-lang/rust/commit/c8c691ff88713d6c4012ec5978d51cbe11300a94"}], "stats": {"total": 187, "additions": 109, "deletions": 78}, "files": [{"sha": "73fdc74b6f075dfced2bd728efb1d6b6b1087eea", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=3f58828fdc3d1eb114c47bf1331a9bb638eab246", "patch": "@@ -95,6 +95,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        debug!(in_scope_lifetimes = ?self.lctx.in_scope_lifetimes);\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n             AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n@@ -118,35 +119,42 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n         parent_hir_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n-        let old_len = self.in_scope_lifetimes.len();\n-\n         let parent_generics = match self.owners[parent_hir_id].unwrap().node().expect_item().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n         };\n-        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n-            _ => None,\n-        });\n-        self.in_scope_lifetimes.extend(lt_def_names);\n+        let lt_def_names = parent_generics\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {\n+                    Some(param.name.normalize_to_macros_2_0())\n+                }\n+                _ => None,\n+            })\n+            .collect();\n+        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, lt_def_names);\n+        debug!(in_scope_lifetimes = ?self.in_scope_lifetimes);\n \n         let res = f(self);\n \n-        self.in_scope_lifetimes.truncate(old_len);\n+        self.in_scope_lifetimes = old_in_scope_lifetimes;\n         res\n     }\n \n     // Clears (and restores) the `in_scope_lifetimes` field. Used when\n     // visiting nested items, which never inherit in-scope lifetimes\n     // from their surrounding environment.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n     fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+        debug!(?old_in_scope_lifetimes);\n \n         // this vector is only used when walking over impl headers,\n         // input types, and the like, and should not be non-empty in"}, {"sha": "9d973e29999afaa81f3d4c1c0cb3035a4805c747", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 91, "deletions": 68, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3f58828fdc3d1eb114c47bf1331a9bb638eab246", "patch": "@@ -129,20 +129,16 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n     anonymous_lifetime_mode: AnonymousLifetimeMode,\n \n-    /// Used to create lifetime definitions from in-band lifetime usages.\n-    /// e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n-    /// When a named lifetime is encountered in a function or impl header and\n-    /// has not been defined\n-    /// (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n+    /// Used to create lifetime definitions for anonymous lifetimes.\n+    /// When an anonymous lifetime is encountered in a function or impl header and\n+    /// requires to create a fresh lifetime parameter, it is added\n     /// to this list. The results of this list are then added to the list of\n     /// lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: Vec<(Span, ParamName)>,\n+    lifetimes_to_define: Vec<(Span, NodeId)>,\n \n-    /// `true` if in-band lifetimes are being collected. This is used to\n-    /// indicate whether or not we're in a place where new lifetimes will result\n-    /// in in-band lifetime definitions, such a function or an impl header,\n-    /// including implicit lifetimes from `impl_header_lifetime_elision`.\n-    is_collecting_anonymous_lifetimes: bool,\n+    /// If anonymous lifetimes are being collected, this field holds the parent\n+    /// `LocalDefId` to create the fresh lifetime parameters' `LocalDefId`.\n+    is_collecting_anonymous_lifetimes: Option<LocalDefId>,\n \n     /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n     /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n@@ -375,7 +371,7 @@ pub fn lower_crate<'a, 'hir>(\n         task_context: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n-        is_collecting_anonymous_lifetimes: false,\n+        is_collecting_anonymous_lifetimes: None,\n         in_scope_lifetimes: Vec::new(),\n         allow_try_trait: Some([sym::try_trait_v2][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n@@ -720,9 +716,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n+        parent_def_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n-    ) -> (Vec<(Span, ParamName)>, T) {\n-        let was_collecting = std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, true);\n+    ) -> (Vec<(Span, NodeId)>, T) {\n+        let was_collecting =\n+            std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n         let len = self.lifetimes_to_define.len();\n \n         let res = f(self);\n@@ -733,49 +731,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n-    fn lifetime_to_generic_param(\n+    fn fresh_lifetime_to_generic_param(\n         &mut self,\n         span: Span,\n-        hir_name: ParamName,\n-        parent_def_id: LocalDefId,\n+        node_id: NodeId,\n     ) -> hir::GenericParam<'hir> {\n-        let node_id = self.resolver.next_node_id();\n-\n-        // Get the name we'll use to make the def-path. Note\n-        // that collisions are ok here and this shouldn't\n-        // really show up for end-user.\n-        let (str_name, kind) = match hir_name {\n-            ParamName::Plain(ident) => (ident.name, hir::LifetimeParamKind::Explicit),\n-            ParamName::Fresh(_) => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Elided),\n-            ParamName::Error => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Error),\n-        };\n-\n-        // Add a definition for the in-band lifetime def.\n-        self.resolver.create_def(\n-            parent_def_id,\n-            node_id,\n-            DefPathData::LifetimeNs(str_name),\n-            ExpnId::root(),\n-            span.with_parent(None),\n-        );\n-\n+        let hir_id = self.lower_node_id(node_id);\n+        let def_id = self.resolver.local_def_id(node_id);\n         hir::GenericParam {\n-            hir_id: self.lower_node_id(node_id),\n-            name: hir_name,\n+            hir_id,\n+            name: hir::ParamName::Fresh(def_id),\n             bounds: &[],\n             span: self.lower_span(span),\n             pure_wrt_drop: false,\n-            kind: hir::GenericParamKind::Lifetime { kind },\n+            kind: hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided },\n         }\n     }\n \n     /// When we have either an elided or `'_` lifetime in an impl\n     /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_anonymous_lifetime(&mut self, span: Span) -> ParamName {\n-        assert!(self.is_collecting_anonymous_lifetimes);\n-        let index = self.lifetimes_to_define.len() + self.in_scope_lifetimes.len();\n-        let hir_name = ParamName::Fresh(index);\n-        self.lifetimes_to_define.push((span, hir_name));\n+        let Some(parent_def_id) = self.is_collecting_anonymous_lifetimes else { panic!() };\n+\n+        let node_id = self.resolver.next_node_id();\n+\n+        // Add a definition for the in-band lifetime def.\n+        let param_def_id = self.resolver.create_def(\n+            parent_def_id,\n+            node_id,\n+            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+            ExpnId::root(),\n+            span.with_parent(None),\n+        );\n+\n+        let hir_name = ParamName::Fresh(param_def_id);\n+        self.lifetimes_to_define.push((span, node_id));\n         hir_name\n     }\n \n@@ -817,7 +807,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n         let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n-            .collect_in_band_defs(|this| {\n+            .collect_in_band_defs(parent_def_id, |this| {\n                 this.with_anonymous_lifetime_mode(anonymous_lifetime_mode, |this| {\n                     this.with_in_scope_lifetime_defs(&generics.params, |this| {\n                         let mut impl_trait_defs = Vec::new();\n@@ -844,9 +834,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         lowered_generics.params.extend(\n             lifetimes_to_define\n                 .into_iter()\n-                .map(|(span, hir_name)| {\n-                    self.lifetime_to_generic_param(span, hir_name, parent_def_id)\n-                })\n+                .map(|(span, node_id)| self.fresh_lifetime_to_generic_param(span, node_id))\n                 .chain(impl_trait_defs),\n         );\n \n@@ -1763,15 +1751,53 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .in_scope_lifetimes\n             .iter()\n             .cloned()\n-            .map(|name| (name.ident().span, name, hir::LifetimeName::Param(name)))\n-            .chain(\n-                self.lifetimes_to_define\n-                    .iter()\n-                    .map(|&(span, name)| (span, name, hir::LifetimeName::Param(name))),\n-            )\n+            .map(|name| (name.ident().span, hir::LifetimeName::Param(name)))\n+            .chain(self.lifetimes_to_define.iter().map(|&(span, node_id)| {\n+                let def_id = self.resolver.local_def_id(node_id);\n+                let name = hir::ParamName::Fresh(def_id);\n+                (span, hir::LifetimeName::Param(name))\n+            }))\n             .collect();\n \n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            let mut generic_params: Vec<_> = lifetime_params\n+                .iter()\n+                .map(|&(span, name)| {\n+                    // We can only get lifetime names from the outside.\n+                    let hir::LifetimeName::Param(hir_name) = name else { panic!() };\n+\n+                    let node_id = this.resolver.next_node_id();\n+\n+                    // Add a definition for the in-band lifetime def.\n+                    let def_id = this.resolver.create_def(\n+                        opaque_ty_def_id,\n+                        node_id,\n+                        DefPathData::LifetimeNs(hir_name.ident().name),\n+                        ExpnId::root(),\n+                        span.with_parent(None),\n+                    );\n+\n+                    let (kind, name) = match hir_name {\n+                        ParamName::Plain(ident) => {\n+                            (hir::LifetimeParamKind::Explicit, hir::ParamName::Plain(ident))\n+                        }\n+                        ParamName::Fresh(_) => {\n+                            (hir::LifetimeParamKind::Elided, hir::ParamName::Fresh(def_id))\n+                        }\n+                        ParamName::Error => (hir::LifetimeParamKind::Error, hir::ParamName::Error),\n+                    };\n+\n+                    hir::GenericParam {\n+                        hir_id: this.lower_node_id(node_id),\n+                        name,\n+                        bounds: &[],\n+                        span: this.lower_span(span),\n+                        pure_wrt_drop: false,\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n+                    }\n+                })\n+                .collect();\n+\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -1782,25 +1808,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // hence the elision takes place at the fn site.\n             let (lifetimes_to_define, future_bound) =\n                 this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.collect_in_band_defs(|this| {\n+                    this.collect_in_band_defs(opaque_ty_def_id, |this| {\n                         this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n                     })\n                 });\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n             debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n \n-            lifetime_params.extend(\n-                // Output lifetime like `'_`:\n-                lifetimes_to_define\n-                    .into_iter()\n-                    .map(|(span, name)| (span, name, hir::LifetimeName::Implicit(false))),\n-            );\n+            // Output lifetime like `'_`:\n+            for (span, node_id) in lifetimes_to_define {\n+                let param = this.fresh_lifetime_to_generic_param(span, node_id);\n+                lifetime_params.push((span, hir::LifetimeName::Implicit(false)));\n+                generic_params.push(param);\n+            }\n+            let generic_params = this.arena.alloc_from_iter(generic_params);\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n-\n-            let generic_params =\n-                this.arena.alloc_from_iter(lifetime_params.iter().map(|&(span, hir_name, _)| {\n-                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_id)\n-                }));\n+            debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1833,7 +1856,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n         let generic_args =\n-            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, _, name)| {\n+            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, name)| {\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span: self.lower_span(span),\n@@ -1969,7 +1992,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_anonymous_lifetimes;\n-                self.is_collecting_anonymous_lifetimes = false;\n+                self.is_collecting_anonymous_lifetimes = None;\n \n                 let lt = self\n                     .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {"}, {"sha": "64ce196e4407bd727693d6717a776b11d2110a91", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f58828fdc3d1eb114c47bf1331a9bb638eab246/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3f58828fdc3d1eb114c47bf1331a9bb638eab246", "patch": "@@ -59,7 +59,7 @@ pub enum ParamName {\n     ///\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n-    Fresh(usize),\n+    Fresh(LocalDefId),\n \n     /// Indicates an illegal name was given and an error has been\n     /// reported (so we should squelch other derived errors). Occurs\n@@ -3303,7 +3303,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Expr<'static>, 56);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n-    rustc_data_structures::static_assert_size!(super::Ty<'static>, 80);\n+    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n \n     rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);"}]}