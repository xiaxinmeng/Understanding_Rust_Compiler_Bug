{"sha": "78124a2b32d61a3ab1cc5798828195970438262b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MTI0YTJiMzJkNjFhM2FiMWNjNTc5ODgyODE5NTk3MDQzODI2MmI=", "commit": {"author": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-05-04T14:08:21Z"}, "committer": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-05-13T13:18:31Z"}, "message": "Fix fast path of float parsing on x87\n\nThe fast path of the float parser relies on the rounding to happen\nexactly and directly to the correct number of bits. On x87, instead,\ndouble rounding would occour as the FPU stack defaults to 80 bits of\nprecision.\n\nThis can be fixed by setting the precision of the FPU stack before\nperforming the int to float conversion. This can be achieved by\nchanging the value of the x87 control word. This is a somewhat common\noperation that is in fact performed whenever a float needs to be\ntruncated to an integer, but it is undesirable to add its overhead for\ncode that does not rely on x87 for computations (i.e. on non-x86\narchitectures, or x86 architectures which perform FPU computations on\nusing SSE).\n\nFixes `num::dec2flt::fast_path_correct` (on x87).", "tree": {"sha": "7a4b4a8f796de72bb3afe2c48a77d4d3d9adaef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4b4a8f796de72bb3afe2c48a77d4d3d9adaef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78124a2b32d61a3ab1cc5798828195970438262b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78124a2b32d61a3ab1cc5798828195970438262b", "html_url": "https://github.com/rust-lang/rust/commit/78124a2b32d61a3ab1cc5798828195970438262b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78124a2b32d61a3ab1cc5798828195970438262b/comments", "author": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a581c82bdc2c13a398b091878d7353bc3d097d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/a581c82bdc2c13a398b091878d7353bc3d097d59", "html_url": "https://github.com/rust-lang/rust/commit/a581c82bdc2c13a398b091878d7353bc3d097d59"}], "stats": {"total": 49, "additions": 42, "deletions": 7}, "files": [{"sha": "a054e41b2084aa06abfa9736f0043e02aa31f39b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78124a2b32d61a3ab1cc5798828195970438262b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78124a2b32d61a3ab1cc5798828195970438262b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=78124a2b32d61a3ab1cc5798828195970438262b", "patch": "@@ -61,7 +61,9 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(allow_internal_unstable)]\n+#![feature(asm)]\n #![feature(associated_type_defaults)]\n+#![feature(cfg_target_feature)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "d64ad449e9abfdc2590de6fb94c39db89e70ae3b", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/78124a2b32d61a3ab1cc5798828195970438262b/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78124a2b32d61a3ab1cc5798828195970438262b/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=78124a2b32d61a3ab1cc5798828195970438262b", "patch": "@@ -32,19 +32,49 @@ fn power_of_ten(e: i16) -> Fp {\n     Fp { f: sig, e: exp }\n }\n \n+#[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n+mod fpu_precision {\n+    pub fn set_precision<T>() { }\n+}\n+\n+#[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n+mod fpu_precision {\n+    use mem::size_of;\n+    use ops::Drop;\n+\n+    pub struct FPUControlWord(u16);\n+\n+    fn set_cw(cw: u16) {\n+        unsafe { asm!(\"fldcw $0\" :: \"m\" (cw)) :: \"volatile\" }\n+    }\n+\n+    pub fn set_precision<T>() -> FPUControlWord {\n+        let cw = 0u16;\n+        let cw_precision = match size_of::<T>() {\n+            4 => 0x0000, // 32 bits\n+            8 => 0x0200, // 64 bits\n+            _ => 0x0300, // default, 80 bits\n+        };\n+        unsafe { asm!(\"fnstcw $0\" : \"=*m\" (&cw)) ::: \"volatile\" }\n+        set_cw((cw & 0xFCFF) | cw_precision);\n+        FPUControlWord(cw)\n+    }\n+\n+    impl Drop for FPUControlWord {\n+        fn drop(&mut self) {\n+            set_cw(self.0)\n+        }\n+    }\n+}\n+\n /// The fast path of Bellerophon using machine-sized integers and floats.\n ///\n /// This is extracted into a separate function so that it can be attempted before constructing\n /// a bignum.\n ///\n /// The fast path crucially depends on arithmetic being correctly rounded, so on x86\n-/// without SSE or SSE2 it will be **wrong** (as in, off by one ULP occasionally), because the x87\n-/// FPU stack will round to 80 bit first before rounding to 64/32 bit. However, as such hardware\n-/// is extremely rare nowadays and in fact all in-tree target triples assume an SSE2-capable\n-/// microarchitecture, there is little incentive to deal with that. There's a test that will fail\n-/// when SSE or SSE2 is disabled, so people building their own non-SSE copy will get a heads up.\n-///\n-/// FIXME: It would nevertheless be nice if we had a good way to detect and deal with x87.\n+/// without SSE or SSE2 it requires the precision of the x87 FPU stack to be changed\n+/// so that it directly rounds to 64/32 bit.\n pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n     let num_digits = integral.len() + fractional.len();\n     // log_10(f64::max_sig) ~ 15.95. We compare the exact value to max_sig near the end,\n@@ -60,6 +90,9 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n     if f > T::max_sig() {\n         return None;\n     }\n+\n+    let _cw = fpu_precision::set_precision::<T>();\n+\n     // The case e < 0 cannot be folded into the other branch. Negative powers result in\n     // a repeating fractional part in binary, which are rounded, which causes real\n     // (and occasioally quite significant!) errors in the final result."}]}