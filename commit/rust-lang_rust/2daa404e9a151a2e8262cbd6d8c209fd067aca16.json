{"sha": "2daa404e9a151a2e8262cbd6d8c209fd067aca16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYWE0MDRlOWExNTFhMmU4MjYyY2JkNmQ4YzIwOWZkMDY3YWNhMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-02T18:28:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-02T18:28:11Z"}, "message": "Auto merge of #65009 - Centril:rollup-06g05xj, r=Centril\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #64581 (Fix unreachable_code warnings for try{} block ok-wrapped expressions)\n - #64850 (Remove inlines from DepNode code)\n - #64914 (regression test for 64453 borrow check error.)\n - #64922 (Use PlaceBuilder to avoid a lot of slice -> vec -> slice convertions)\n - #64948 (Improve sidebar styling to make its integration easier)\n - #64961 (Make comment about dummy type a bit more clear)\n - #64967 (Don't mark borrows of zero-sized arrays as indirectly mutable)\n - #64973 (Fix typo while setting `compile-flags` in test)\n - #64980 (Enable support for `IndirectlyMutableLocals` in `rustc_peek` )\n - #64989 (Fix ICE #64964)\n - #64991 ([const-prop] Correctly handle locals that can't be propagated)\n - #64995 (Remove rustdoc warning)\n - #64997 (rustc book: nitpick SLP vectorization)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "555e94cb61f496a34f931489a93b895bc7b2167e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/555e94cb61f496a34f931489a93b895bc7b2167e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2daa404e9a151a2e8262cbd6d8c209fd067aca16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2daa404e9a151a2e8262cbd6d8c209fd067aca16", "html_url": "https://github.com/rust-lang/rust/commit/2daa404e9a151a2e8262cbd6d8c209fd067aca16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2daa404e9a151a2e8262cbd6d8c209fd067aca16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2023ac599c38a59f86552089e6791c5a73412d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2023ac599c38a59f86552089e6791c5a73412d3", "html_url": "https://github.com/rust-lang/rust/commit/f2023ac599c38a59f86552089e6791c5a73412d3"}, {"sha": "b961f962d0049f168bab668fff3ad903436701f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b961f962d0049f168bab668fff3ad903436701f4", "html_url": "https://github.com/rust-lang/rust/commit/b961f962d0049f168bab668fff3ad903436701f4"}], "stats": {"total": 1014, "additions": 756, "deletions": 258}, "files": [{"sha": "e73fd43f19a5120406856ad365dcc8750e364e53", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -105,7 +105,7 @@ flag will turn that behavior off.\n \n ## no-vectorize-slp\n \n-By default, `rustc` will attempt to vectorize loops using [superword-level\n+By default, `rustc` will attempt to vectorize code using [superword-level\n parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n flag will turn that behavior off.\n "}, {"sha": "0686bec0621f450c4e02f95fef3b51cda870adaf", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -114,7 +114,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepKind {\n             #[allow(unreachable_code)]\n-            #[inline]\n             pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n                 match *self {\n                     $(\n@@ -150,7 +149,6 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -199,7 +197,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n-            #[inline(always)]\n             pub fn new<'tcx>(tcx: TyCtxt<'tcx>,\n                                        dep: DepConstructor<'tcx>)\n                                        -> DepNode\n@@ -219,14 +216,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        arg.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            arg.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -242,14 +241,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            tupled_args.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -267,7 +268,6 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n@@ -281,7 +281,6 @@ macro_rules! define_dep_nodes {\n             /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n                 debug_assert!(!kind.has_params());\n                 DepNode {\n@@ -300,7 +299,6 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            #[inline]\n             pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n@@ -386,14 +384,12 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }"}, {"sha": "db5b197c5d67355c4d01fc1a96399121ca472879", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -392,32 +392,49 @@ impl LoweringContext<'_> {\n         )\n     }\n \n+    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n+    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n+    /// and save the block id to use it as a break target for desugaring of the `?` operator.\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n         self.with_catch_scope(body.id, |this| {\n-            let unstable_span = this.mark_span_with_reason(\n+            let mut block = this.lower_block(body, true).into_inner();\n+\n+            let try_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n                 body.span,\n                 this.allow_try_trait.clone(),\n             );\n-            let mut block = this.lower_block(body, true).into_inner();\n-            let tail = block.expr.take().map_or_else(\n-                || this.expr_unit(this.sess.source_map().end_point(unstable_span)),\n+\n+            // Final expression of the block (if present) or `()` with span at the end of block\n+            let tail_expr = block.expr.take().map_or_else(\n+                || this.expr_unit(this.sess.source_map().end_point(try_span)),\n                 |x: P<hir::Expr>| x.into_inner(),\n             );\n-            block.expr = Some(this.wrap_in_try_constructor(sym::from_ok, tail, unstable_span));\n+\n+            let ok_wrapped_span = this.mark_span_with_reason(\n+                DesugaringKind::TryBlock,\n+                tail_expr.span,\n+                None\n+            );\n+\n+            // `::std::ops::Try::from_ok($tail_expr)`\n+            block.expr = Some(this.wrap_in_try_constructor(\n+                sym::from_ok, try_span, tail_expr, ok_wrapped_span));\n+\n             hir::ExprKind::Block(P(block), None)\n         })\n     }\n \n     fn wrap_in_try_constructor(\n         &mut self,\n         method: Symbol,\n-        e: hir::Expr,\n-        unstable_span: Span,\n+        method_span: Span,\n+        expr: hir::Expr,\n+        overall_span: Span,\n     ) -> P<hir::Expr> {\n         let path = &[sym::ops, sym::Try, method];\n-        let from_err = P(self.expr_std_path(unstable_span, path, None, ThinVec::new()));\n-        P(self.expr_call(e.span, from_err, hir_vec![e]))\n+        let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+        P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -1244,7 +1261,7 @@ impl LoweringContext<'_> {\n                 self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n             };\n             let from_err_expr =\n-                self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n+                self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().map(|x| *x);\n             let ret_expr = if let Some(catch_node) = catch_scope {"}, {"sha": "9b4d88a5a09671cb283c93f200cc5f1ffc658adb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -861,7 +861,7 @@ pub struct Block {\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n     /// break out of this block early.\n-    /// Used by `'label: {}` blocks and by `catch` statements.\n+    /// Used by `'label: {}` blocks and by `try {}` blocks.\n     pub targeted_by_break: bool,\n }\n "}, {"sha": "42d45c5dfd3c46080fcab8da83573f9931254a48", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -317,6 +317,12 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n     pub scope_span: Option<Span>,\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GeneratorInteriorTypeCause<'tcx> {\n+        ty, span, scope_span\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The HirId::owner all ItemLocalIds in this table are relative to."}, {"sha": "d2dc07374ed0051800147ce500cf3c10a22bb558", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -600,7 +600,8 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n extern {\n-    /// A dummy type used to force `List` to by unsized without requiring fat pointers.\n+    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n+    /// pointers.\n     type OpaqueListContents;\n }\n "}, {"sha": "60fe37e26e9ad3a1886a5486f2ed5fedb9df51a2", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 114, "deletions": 30, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -6,13 +6,79 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Variance};\n+use rustc::ty::{CanonicalUserTypeAnnotation, Ty, Variance};\n \n use rustc_index::vec::Idx;\n \n+/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n+/// place by pushing more and more projections onto the end, and then convert the final set into a\n+/// place using the `into_place` method.\n+///\n+/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n+/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n+#[derive(Clone)]\n+struct PlaceBuilder<'tcx> {\n+    base: PlaceBase<'tcx>,\n+    projection: Vec<PlaceElem<'tcx>>,\n+}\n+\n+impl PlaceBuilder<'tcx> {\n+    fn into_place(self) -> Place<'tcx> {\n+        Place {\n+            base: self.base,\n+            projection: self.projection.into_boxed_slice(),\n+        }\n+    }\n+\n+    fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n+        self.project(PlaceElem::Field(f, ty))\n+    }\n+\n+    fn deref(self) -> Self {\n+        self.project(PlaceElem::Deref)\n+    }\n+\n+    fn index(self, index: Local) -> Self {\n+        self.project(PlaceElem::Index(index))\n+    }\n+\n+    fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+        self.projection.push(elem);\n+        self\n+    }\n+}\n+\n+impl From<Local> for PlaceBuilder<'tcx> {\n+    fn from(local: Local) -> Self {\n+        Self {\n+            base: local.into(),\n+            projection: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase<'tcx>) -> Self {\n+        Self {\n+            base,\n+            projection: Vec::new(),\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n-    pub fn as_place<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let place_builder = unpack!(block = self.as_place_builder(block, expr));\n+        block.and(place_builder.into_place())\n+    }\n+\n+    /// This is used when constructing a compound `Place`, so that we can avoid creating\n+    /// intermediate `Place` values until we know the full set of projections.\n+    fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -25,7 +91,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    pub fn as_read_only_place<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    pub fn as_read_only_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n+        block.and(place_builder.into_place())\n+    }\n+\n+    /// This is used when constructing a compound `Place`, so that we can avoid creating\n+    /// intermediate `Place` values until we know the full set of projections.\n+    /// Mutability note: The caller of this method promises only to read from the resulting\n+    /// place. The place itself may or may not be mutable:\n+    /// * If this expr is a place expr like a.b, then we will return that place.\n+    /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n+    fn as_read_only_place_builder<M>(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: M,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -38,7 +122,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n         mutability: Mutability,\n-    ) -> BlockAnd<Place<'tcx>> {\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         debug!(\n             \"expr_as_place(block={:?}, expr={:?}, mutability={:?})\",\n             block, expr, mutability\n@@ -54,25 +138,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 value,\n             } => this.in_scope((region_scope, source_info), lint_level, |this| {\n                 if mutability == Mutability::Not {\n-                    this.as_read_only_place(block, value)\n+                    this.as_read_only_place_builder(block, value)\n                 } else {\n-                    this.as_place(block, value)\n+                    this.as_place_builder(block, value)\n                 }\n             }),\n             ExprKind::Field { lhs, name } => {\n-                let place = unpack!(block = this.as_place(block, lhs));\n-                let place = place.field(name, expr.ty);\n-                block.and(place)\n+                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n+                block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place = unpack!(block = this.as_place(block, arg));\n-                let place = place.deref();\n-                block.and(place)\n+                let place_builder = unpack!(block = this.as_place_builder(block, arg));\n+                block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n-                let slice = unpack!(block = this.as_place(block, lhs));\n+                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n                 // Making this a *fresh* temporary also means we do not have to worry about\n                 // the index changing later: Nothing will ever change this temporary.\n                 // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n@@ -83,6 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Mutability::Not,\n                 ));\n \n+                let slice = place_builder.clone().into_place();\n                 // bounds check:\n                 let (len, lt) = (\n                     this.temp(usize_ty.clone(), expr_span),\n@@ -92,7 +175,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block,\n                     source_info, // len = len(slice)\n                     &len,\n-                    Rvalue::Len(slice.clone()),\n+                    Rvalue::Len(slice),\n                 );\n                 this.cfg.push_assign(\n                     block,\n@@ -110,30 +193,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     index: Operand::Copy(Place::from(idx)),\n                 };\n                 let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n-                success.and(slice.index(idx))\n+                success.and(place_builder.index(idx))\n             }\n-            ExprKind::SelfRef => block.and(Place::from(Local::new(1))),\n+            ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n-                let place = if this.is_bound_var_in_guard(id) {\n+                let place_builder = if this.is_bound_var_in_guard(id) {\n                     let index = this.var_local_id(id, RefWithinGuard);\n-                    Place::from(index).deref()\n+                    PlaceBuilder::from(index).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n-                    Place::from(index)\n+                    PlaceBuilder::from(index)\n                 };\n-                block.and(place)\n+                block.and(place_builder)\n             }\n-            ExprKind::StaticRef { id } => block.and(Place {\n-                base: PlaceBase::Static(Box::new(Static {\n+            ExprKind::StaticRef { id } => block.and(PlaceBuilder::from(\n+                PlaceBase::Static(Box::new(Static {\n                     ty: expr.ty,\n                     kind: StaticKind::Static,\n                     def_id: id,\n-                })),\n-                projection: box [],\n-            }),\n+                }))\n+            )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let place = unpack!(block = this.as_place(block, source));\n+                let place_builder = unpack!(block = this.as_place_builder(block, source));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n                         CanonicalUserTypeAnnotation {\n@@ -142,21 +224,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         }\n                     );\n+\n+                    let place = place_builder.clone().into_place();\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 box(\n-                                    place.clone(),\n+                                    place,\n                                     UserTypeProjection { base: annotation_index, projs: vec![], }\n                                 ),\n                                 Variance::Invariant,\n                             ),\n                         },\n                     );\n                 }\n-                block.and(place)\n+                block.and(place_builder)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n                 let source = this.hir.mirror(source);\n@@ -185,7 +269,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         },\n                     );\n                 }\n-                block.and(Place::from(temp))\n+                block.and(PlaceBuilder::from(temp))\n             }\n \n             ExprKind::Array { .. }\n@@ -221,7 +305,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 let temp =\n                     unpack!(block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n-                block.and(Place::from(temp))\n+                block.and(PlaceBuilder::from(temp))\n             }\n         }\n     }"}, {"sha": "990425c3252e0ecab664b93cc2903ef9a04cec57", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -97,28 +97,44 @@ struct TransferFunction<'a, 'mir, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n+impl<'tcx> TransferFunction<'_, '_, 'tcx> {\n+    /// Returns `true` if this borrow would allow mutation of the `borrowed_place`.\n+    fn borrow_allows_mutation(\n+        &self,\n+        kind: mir::BorrowKind,\n+        borrowed_place: &mir::Place<'tcx>,\n+    ) -> bool {\n+        let borrowed_ty = borrowed_place.ty(self.body, self.tcx).ty;\n+\n+        // Zero-sized types cannot be mutated, since there is nothing inside to mutate.\n+        //\n+        // FIXME: For now, we only exempt arrays of length zero. We need to carefully\n+        // consider the effects before extending this to all ZSTs.\n+        if let ty::Array(_, len) = borrowed_ty.kind {\n+            if len.try_eval_usize(self.tcx, self.param_env) == Some(0) {\n+                return false;\n+            }\n+        }\n+\n+        match kind {\n+            mir::BorrowKind::Mut { .. } => true,\n+\n+            | mir::BorrowKind::Shared\n+            | mir::BorrowKind::Shallow\n+            | mir::BorrowKind::Unique\n+            => !borrowed_ty.is_freeze(self.tcx, self.param_env, DUMMY_SP),\n+        }\n+    }\n+}\n+\n impl<'tcx> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx> {\n     fn visit_rvalue(\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n         if let mir::Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let is_mut = match kind {\n-                mir::BorrowKind::Mut { .. } => true,\n-\n-                | mir::BorrowKind::Shared\n-                | mir::BorrowKind::Shallow\n-                | mir::BorrowKind::Unique\n-                => {\n-                    !borrowed_place\n-                        .ty(self.body, self.tcx)\n-                        .ty\n-                        .is_freeze(self.tcx, self.param_env, DUMMY_SP)\n-                }\n-            };\n-\n-            if is_mut {\n+            if self.borrow_allows_mutation(kind, borrowed_place) {\n                 match borrowed_place.base {\n                     mir::PlaceBase::Local(borrowed_local) if !borrowed_place.is_indirect()\n                         => self.trans.gen(borrowed_local),"}, {"sha": "2d7b215b13c45d97e4497993294b7257403a3b6a", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -137,7 +137,7 @@ pub fn compute_indirectly_mutable_locals<'mir, 'tcx>(\n         item.tcx,\n         item.body,\n         item.def_id,\n-        &[],\n+        &item.tcx.get_attrs(item.def_id),\n         &dead_unwinds,\n         old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n         |_, local| old_dataflow::DebugFormatted::new(&local),"}, {"sha": "49ac1de8fef64fe59b1cd1974f76965f3a06327d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -335,34 +335,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n-        let l = &self.ecx.frame().locals[local];\n-\n-        // If the local is `Unitialized` or `Dead` then we haven't propagated a value into it.\n-        //\n-        // `InterpCx::access_local()` mostly takes care of this for us however, for ZSTs,\n-        // it will synthesize a value for us. In doing so, that will cause the\n-        // `get_const(l).is_empty()` assert right before we call `set_const()` in `visit_statement`\n-        // to fail.\n-        if let LocalValue::Uninitialized | LocalValue::Dead = l.value {\n-            return None;\n-        }\n-\n         self.ecx.access_local(self.ecx.frame(), local, None).ok()\n     }\n \n-    fn set_const(&mut self, local: Local, c: Const<'tcx>) {\n-        let frame = self.ecx.frame_mut();\n-\n-        if let Some(layout) = frame.locals[local].layout.get() {\n-            debug_assert_eq!(c.layout, layout);\n-        }\n-\n-        frame.locals[local] = LocalState {\n-            value: LocalValue::Live(*c),\n-            layout: Cell::new(Some(c.layout)),\n-        };\n-    }\n-\n     fn remove_const(&mut self, local: Local) {\n         self.ecx.frame_mut().locals[local] = LocalState {\n             value: LocalValue::Uninitialized,\n@@ -735,10 +710,8 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                                          place) {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {\n-                            trace!(\"storing {:?} to {:?}\", value, local);\n-                            assert!(self.get_const(local).is_none() ||\n-                                    self.get_const(local) == Some(value));\n-                            self.set_const(local, value);\n+                            trace!(\"stored {:?} to {:?}\", value, local);\n+                            assert_eq!(self.get_const(local), Some(value));\n \n                             if self.should_const_prop() {\n                                 self.replace_with_const(\n@@ -747,6 +720,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                     statement.source_info,\n                                 );\n                             }\n+                        } else {\n+                            trace!(\"can't propagate {:?} to {:?}\", value, local);\n+                            self.remove_const(local);\n                         }\n                     }\n                 }"}, {"sha": "6edd28a4259a5ed59c62957c39fd06d641b6540e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 184, "deletions": 130, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -3,19 +3,21 @@ use syntax::ast;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Body, Location};\n+use rustc::mir::{self, Body, Location, Local};\n use rustc_index::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::BitDenotation;\n use crate::dataflow::DataflowResults;\n+use crate::dataflow::DataflowResultsCursor;\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces\n };\n+use crate::dataflow::IndirectlyMutableLocals;\n use crate::dataflow::move_paths::{MovePathIndex, LookupResult};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n \n@@ -50,6 +52,10 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n                         DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n+        let flow_indirectly_mut =\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        IndirectlyMutableLocals::new(tcx, body, param_env),\n+                        |_, i| DebugFormatted::new(&i));\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n@@ -60,6 +66,9 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n+        }\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n@@ -88,151 +97,196 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(\n     def_id: DefId,\n     _attributes: &[ast::Attribute],\n     results: &DataflowResults<'tcx, O>,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n+) where O: RustcPeekAt<'tcx> {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n-    // FIXME: this is not DRY. Figure out way to abstract this and\n-    // `dataflow::build_sets`. (But note it is doing non-standard\n-    // stuff, so such generalization may not be realistic.)\n \n-    for bb in body.basic_blocks().indices() {\n-        each_block(tcx, body, results, bb);\n-    }\n-}\n+    let mut cursor = DataflowResultsCursor::new(results, body);\n \n-fn each_block<'tcx, O>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    results: &DataflowResults<'tcx, O>,\n-    bb: mir::BasicBlock,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n-    let move_data = results.0.operator.move_data();\n-    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n-\n-    let (args, span) = match is_rustc_peek(tcx, terminator) {\n-        Some(args_and_span) => args_and_span,\n-        None => return,\n-    };\n-    assert!(args.len() == 1);\n-    let peek_arg_place = match args[0] {\n-        mir::Operand::Copy(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) |\n-        mir::Operand::Move(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) => Some(place),\n-        _ => None,\n-    };\n-\n-    let peek_arg_place = match peek_arg_place {\n-        Some(arg) => arg,\n-        None => {\n-            tcx.sess.diagnostic().span_err(\n-                span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n-            return;\n-        }\n-    };\n-\n-    let mut on_entry = results.0.sets.entry_set_for(bb.index()).to_owned();\n-    let mut trans = results.0.sets.trans_for(bb.index()).clone();\n-\n-    // Emulate effect of all statements in the block up to (but not\n-    // including) the borrow within `peek_arg_place`. Do *not* include\n-    // call to `peek_arg_place` itself (since we are peeking the state\n-    // of the argument at time immediate preceding Call to\n-    // `rustc_peek`).\n-\n-    for (j, stmt) in statements.iter().enumerate() {\n-        debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n-        let (place, rvalue) = match stmt.kind {\n-            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                (place, rvalue)\n+    let peek_calls = body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .filter_map(|(bb, block_data)| {\n+                PeekCall::from_terminator(tcx, block_data.terminator())\n+                    .map(|call| (bb, block_data, call))\n+            });\n+\n+    for (bb, block_data, call) in peek_calls {\n+        // Look for a sequence like the following to indicate that we should be peeking at `_1`:\n+        //    _2 = &_1;\n+        //    rustc_peek(_2);\n+        //\n+        //    /* or */\n+        //\n+        //    _2 = _1;\n+        //    rustc_peek(_2);\n+        let (statement_index, peek_rval) = block_data\n+            .statements\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, stmt)| value_assigned_to_local(stmt, call.arg).map(|rval| (i, rval)))\n+            .next()\n+            .expect(\"call to rustc_peek should be preceded by \\\n+                    assignment to temporary holding its argument\");\n+\n+        match (call.kind, peek_rval) {\n+            | (PeekCallKind::ByRef, mir::Rvalue::Ref(_, _, place))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Move(place)))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Copy(place)))\n+            => {\n+                let loc = Location { block: bb, statement_index };\n+                cursor.seek(loc);\n+                let state = cursor.get();\n+                results.operator().peek_at(tcx, place, state, call);\n             }\n-            mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::Retag { .. } |\n-            mir::StatementKind::AscribeUserType(..) |\n-            mir::StatementKind::Nop => continue,\n-            mir::StatementKind::SetDiscriminant{ .. } =>\n-                span_bug!(stmt.source_info.span,\n-                          \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n-        };\n \n-        if place == peek_arg_place {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n-                // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_place.as_ref()) {\n-                    LookupResult::Exact(peek_mpi) => {\n-                        let bit_state = on_entry.contains(peek_mpi);\n-                        debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                               place, peeking_at_place, bit_state);\n-                        if !bit_state {\n-                            tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n-                        }\n-                    }\n-                    LookupResult::Parent(..) => {\n-                        tcx.sess.span_err(span, \"rustc_peek: argument untracked\");\n-                    }\n-                }\n-                return;\n-            } else {\n-                // Our search should have been over, but the input\n-                // does not match expectations of `rustc_peek` for\n-                // this sanity_check.\n+            _ => {\n                 let msg = \"rustc_peek: argument expression \\\n-                           must be immediate borrow of form `&expr`\";\n-                tcx.sess.span_err(span, msg);\n+                           must be either `place` or `&place`\";\n+                tcx.sess.span_err(call.span, msg);\n             }\n         }\n+    }\n+}\n \n-        let lhs_mpi = move_data.rev_lookup.find(place.as_ref());\n-\n-        debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n-               place, lhs_mpi, stmt);\n-        // reset GEN and KILL sets before emulating their effect.\n-        trans.clear();\n-        results.0.operator.before_statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        results.0.operator.statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        trans.apply(&mut on_entry);\n+/// If `stmt` is an assignment where the LHS is the given local (with no projections), returns the\n+/// RHS of the assignment.\n+fn value_assigned_to_local<'a, 'tcx>(\n+    stmt: &'a mir::Statement<'tcx>,\n+    local: Local,\n+) -> Option<&'a mir::Rvalue<'tcx>> {\n+    if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n+        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n+            if local == *l {\n+                return Some(&*rvalue);\n+            }\n+        }\n     }\n \n-    results.0.operator.before_terminator_effect(\n-        &mut trans,\n-        Location { block: bb, statement_index: statements.len() });\n+    None\n+}\n \n-    tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n-                                      anticipated pattern; note that \\\n-                                      rustc_peek expects input of \\\n-                                      form `&expr`\"));\n+#[derive(Clone, Copy, Debug)]\n+enum PeekCallKind {\n+    ByVal,\n+    ByRef,\n }\n \n-fn is_rustc_peek<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    terminator: &'a Option<mir::Terminator<'tcx>>,\n-) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n-    if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n-            if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.literal.ty.kind {\n-                    let abi = tcx.fn_sig(def_id).abi();\n-                    let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic && name == sym::rustc_peek {\n-                        return Some((args, source_info.span));\n+impl PeekCallKind {\n+    fn from_arg_ty(arg: Ty<'_>) -> Self {\n+        match arg.kind {\n+            ty::Ref(_, _, _) => PeekCallKind::ByRef,\n+            _ => PeekCallKind::ByVal,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct PeekCall {\n+    arg: Local,\n+    kind: PeekCallKind,\n+    span: Span,\n+}\n+\n+impl PeekCall {\n+    fn from_terminator<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> Option<Self> {\n+        use mir::{Operand, Place, PlaceBase};\n+\n+        let span = terminator.source_info.span;\n+        if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+            &terminator.kind\n+        {\n+            if let ty::FnDef(def_id, substs) = func.literal.ty.kind {\n+                let sig = tcx.fn_sig(def_id);\n+                let name = tcx.item_name(def_id);\n+                if sig.abi() != Abi::RustIntrinsic || name != sym::rustc_peek {\n+                    return None;\n+                }\n+\n+                assert_eq!(args.len(), 1);\n+                let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n+                let arg = match args[0] {\n+                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    => local,\n+\n+                    _ => {\n+                        tcx.sess.diagnostic().span_err(\n+                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                        return None;\n                     }\n+                };\n+\n+                return Some(PeekCall {\n+                    arg,\n+                    kind,\n+                    span,\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub trait RustcPeekAt<'tcx>: BitDenotation<'tcx> {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    );\n+}\n+\n+impl<'tcx, O> RustcPeekAt<'tcx> for O\n+    where O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n+{\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    ) {\n+        match self.move_data().rev_lookup.find(place.as_ref()) {\n+            LookupResult::Exact(peek_mpi) => {\n+                let bit_state = flow_state.contains(peek_mpi);\n+                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                       call.arg, place, bit_state);\n+                if !bit_state {\n+                    tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n                 }\n             }\n+\n+            LookupResult::Parent(..) => {\n+                tcx.sess.span_err(call.span, \"rustc_peek: argument untracked\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Local>,\n+        call: PeekCall,\n+    ) {\n+        warn!(\"peek_at: place={:?}\", place);\n+        let local = match place {\n+            mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } => *l,\n+            _ => {\n+                tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+                return;\n+            }\n+        };\n+\n+        if !flow_state.contains(local) {\n+            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n         }\n     }\n-    return None;\n }"}, {"sha": "7a6fe9560fbfff4a6ed5fb4d182090df8ec73133", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -18,6 +18,7 @@ use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n \n use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use syntax_pos::hygiene::DesugaringKind;\n use syntax::ast;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::source_map::Span;\n@@ -150,8 +151,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\",\n                expr, expected);\n \n+        // True if `expr` is a `Try::from_ok(())` that is a result of desugaring a try block\n+        // without the final expr (e.g. `try { return; }`). We don't want to generate an\n+        // unreachable_code lint for it since warnings for autogenerated code are confusing.\n+        let is_try_block_generated_unit_expr = match expr.kind {\n+            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) =>\n+                args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock),\n+\n+            _ => false,\n+        };\n+\n         // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+        if !is_try_block_generated_unit_expr {\n+            self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+        }\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.get();\n@@ -164,6 +177,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n             ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n+            // If `expr` is a result of desugaring the try block and is an ok-wrapped\n+            // diverging expression (e.g. it arose from desugaring of `try { return }`),\n+            // we skip issuing a warning because it is autogenerated code.\n+            ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {},\n             ExprKind::Call(ref callee, _) =>\n                 self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n             ExprKind::MethodCall(_, ref span, _) =>"}, {"sha": "940537a5f48afac66848305f4c2fd66975ead5bb", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -123,13 +123,6 @@ pub fn resolve_interior<'a, 'tcx>(\n     // Sort types by insertion order\n     types.sort_by_key(|t| t.1);\n \n-    // Store the generator types and spans into the tables for this generator.\n-    let interior_types = types.iter().cloned().map(|t| t.0).collect::<Vec<_>>();\n-    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = interior_types;\n-\n-    // Extract type components\n-    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| (t.0).ty));\n-\n     // The types in the generator interior contain lifetimes local to the generator itself,\n     // which should not be exposed outside of the generator. Therefore, we replace these\n     // lifetimes with existentially-bound lifetimes, which reflect the exact value of the\n@@ -139,18 +132,25 @@ pub fn resolve_interior<'a, 'tcx>(\n     // if a Sync generator contains an &'\u03b1 T, we need to check whether &'\u03b1 T: Sync),\n     // so knowledge of the exact relationships between them isn't particularly important.\n \n-    debug!(\"types in generator {:?}, span = {:?}\", type_list, body.value.span);\n+    debug!(\"types in generator {:?}, span = {:?}\", types, body.value.span);\n \n     // Replace all regions inside the generator interior with late bound regions\n     // Note that each region slot in the types gets a new fresh late bound region,\n     // which means that none of the regions inside relate to any other, even if\n     // typeck had previously found constraints that would cause them to be related.\n     let mut counter = 0;\n-    let type_list = fcx.tcx.fold_regions(&type_list, &mut false, |_, current_depth| {\n+    let types = fcx.tcx.fold_regions(&types, &mut false, |_, current_depth| {\n         counter += 1;\n         fcx.tcx.mk_region(ty::ReLateBound(current_depth, ty::BrAnon(counter)))\n     });\n \n+    // Store the generator types and spans into the tables for this generator.\n+    let interior_types = types.iter().map(|t| t.0.clone()).collect::<Vec<_>>();\n+    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = interior_types;\n+\n+    // Extract type components\n+    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| (t.0).ty));\n+\n     let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n \n     debug!(\"types in generator after region replacement {:?}, span = {:?}\","}, {"sha": "3ab474d16b864ec441c5e132f31f35826a5a0018", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -473,7 +473,7 @@ pub enum Diverges {\n     WarnedAlways\n }\n \n-// Convenience impls for combinig `Diverges`.\n+// Convenience impls for combining `Diverges`.\n \n impl ops::BitAnd for Diverges {\n     type Output = Self;"}, {"sha": "64c858238dbce6c57632112a071dca176851222f", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -183,7 +183,7 @@ nav.sub {\n \tposition: fixed;\n \tleft: 0;\n \ttop: 0;\n-\theight: 100vh;\n+\tbottom: 0;\n \toverflow: auto;\n }\n \n@@ -573,7 +573,7 @@ h4 > code, h3 > code, .invisible > code {\n \tmargin-top: 0;\n }\n \n-nav {\n+nav:not(.sidebar) {\n \tborder-bottom: 1px solid;\n \tpadding-bottom: 10px;\n \tmargin-bottom: 10px;"}, {"sha": "c3116dbe7a242a720a83d97f83b28011a4eeecf1", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -129,7 +129,7 @@ pre {\n pre.rust .comment { color: #8d8d8b; }\n pre.rust .doccomment { color: #8ca375; }\n \n-nav {\n+nav:not(.sidebar) {\n \tborder-bottom-color: #4e4e4e;\n }\n nav.main .current {"}, {"sha": "e2bf9f9d2f23a2ba7fb4a695192b3b4eba3e1d4c", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -129,7 +129,7 @@ pre {\n pre.rust .comment { color: #8E908C; }\n pre.rust .doccomment { color: #4D4D4C; }\n \n-nav {\n+nav:not(.sidebar) {\n \tborder-bottom-color: #e0e0e0;\n }\n nav.main .current {"}, {"sha": "82c47e6dbb75879ec01f1537ccc26dcefcc994c8", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -597,6 +597,7 @@ symbols! {\n         rustc_peek_definite_init,\n         rustc_peek_maybe_init,\n         rustc_peek_maybe_uninit,\n+        rustc_peek_indirectly_mutable,\n         rustc_private,\n         rustc_proc_macro_decls,\n         rustc_promotable,"}, {"sha": "8b76080fc68c61718d6e3e69c59a07e9691d8df2", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -1109,7 +1109,7 @@ pub enum RunStrategy {\n     InProcess,\n \n     /// Spawns a subprocess to run the test, and sends the result back over the\n-    /// supplied channel. Requires argv[0] to exist and point to the binary\n+    /// supplied channel. Requires `argv[0]` to exist and point to the binary\n     /// that's currently running.\n     SpawnPrimary,\n }"}, {"sha": "11f6cb6af9cc6b2688446535696c27236aaee4d9", "filename": "src/test/ui/async-await/issues/issue-64964.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64964.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+// compile-flags: -Z query-dep-graph\n+// edition:2018\n+\n+// Regression test for ICE related to `await`ing in a method + incr. comp. (#64964)\n+\n+struct Body;\n+impl Body {\n+    async fn next(&mut self) {\n+        async {}.await\n+    }\n+}\n+\n+// Another reproduction: `await`ing with a variable from for-loop.\n+\n+async fn bar() {\n+    for x in 0..10 {\n+        async { Some(x) }.await.unwrap();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d8ab6b6e25f6f84c1960522049ab3f708302c6a8", "filename": "src/test/ui/borrowck/issue-64453.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,24 @@\n+struct Project;\n+struct Value;\n+\n+static settings_dir: String = format!(\"\");\n+//~^ ERROR [E0019]\n+//~| ERROR [E0015]\n+//~| ERROR [E0015]\n+\n+fn from_string(_: String) -> Value {\n+    Value\n+}\n+fn set_editor(_: Value) {}\n+\n+fn main() {\n+    let settings_data = from_string(settings_dir);\n+    //~^ ERROR cannot move out of static item `settings_dir` [E0507]\n+    let args: i32 = 0;\n+\n+    match args {\n+        ref x if x == &0 => set_editor(settings_data),\n+        ref x if x == &1 => set_editor(settings_data),\n+        _ => unimplemented!(),\n+    }\n+}"}, {"sha": "6987417fe192e30404766061780f9361d5ff00c4", "filename": "src/test/ui/borrowck/issue-64453.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,34 @@\n+error[E0507]: cannot move out of static item `settings_dir`\n+  --> $DIR/issue-64453.rs:15:37\n+   |\n+LL |     let settings_data = from_string(settings_dir);\n+   |                                     ^^^^^^^^^^^^ move occurs because `settings_dir` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/issue-64453.rs:4:31\n+   |\n+LL | static settings_dir: String = format!(\"\");\n+   |                               ^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-64453.rs:4:31\n+   |\n+LL | static settings_dir: String = format!(\"\");\n+   |                               ^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-64453.rs:4:31\n+   |\n+LL | static settings_dir: String = format!(\"\");\n+   |                               ^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0015, E0019, E0507.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "21360a1c471f652b54fe67d8cb14ccdea97cf7d4", "filename": "src/test/ui/consts/const-eval/generic-slice.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,31 @@\n+// Several variants of #64945.\n+\n+// This struct is not important, we just use it to put `T` and `'a` in scope for our associated\n+// consts.\n+struct Generic<'a, T>(std::marker::PhantomData<&'a T>);\n+\n+impl<'a, T: 'static> Generic<'a, T> {\n+    const EMPTY_SLICE: &'a [T] = {\n+        let x: &'a [T] = &[];\n+        x\n+    };\n+\n+    const EMPTY_SLICE_REF: &'a &'static [T] = {\n+        let x: &'static [T] = &[];\n+        &x\n+        //~^ ERROR `x` does not live long enough\n+    };\n+}\n+\n+static mut INTERIOR_MUT_AND_DROP: &'static [std::cell::RefCell<Vec<i32>>] = {\n+    let x: &[_] = &[];\n+    x\n+};\n+\n+static mut INTERIOR_MUT_AND_DROP_REF: &'static &'static [std::cell::RefCell<Vec<i32>>] = {\n+    let x: &[_] = &[];\n+    &x\n+    //~^ ERROR `x` does not live long enough\n+};\n+\n+fn main() {}"}, {"sha": "c38088df4d8e62637d790d5f101f803beaa15ec3", "filename": "src/test/ui/consts/const-eval/generic-slice.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fgeneric-slice.stderr?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,30 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/generic-slice.rs:15:9\n+   |\n+LL | impl<'a, T: 'static> Generic<'a, T> {\n+   |      -- lifetime `'a` defined here\n+...\n+LL |         &x\n+   |         ^^\n+   |         |\n+   |         borrowed value does not live long enough\n+   |         using this value as a constant requires that `x` is borrowed for `'a`\n+LL |\n+LL |     };\n+   |     - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/generic-slice.rs:27:5\n+   |\n+LL |     &x\n+   |     ^^\n+   |     |\n+   |     borrowed value does not live long enough\n+   |     using this value as a static requires that `x` is borrowed for `'static`\n+LL |\n+LL | };\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "ede5081c8a5c299f28eddcc9015dd2340c4b1e1a", "filename": "src/test/ui/consts/const-eval/issue-64970.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+fn main() {\n+    foo(10);\n+}\n+\n+fn foo(mut n: i32) {\n+    if false {\n+        n = 0i32;\n+    }\n+\n+    if n > 0i32 {\n+        1i32 / n;\n+    }\n+}"}, {"sha": "2c44b68cbd1d1921213f1cf1533f0d05dd5e5b89", "filename": "src/test/ui/consts/const-eval/issue-64970.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-64970.stderr?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,8 @@\n+warning: unused arithmetic operation that must be used\n+  --> $DIR/issue-64970.rs:13:9\n+   |\n+LL |         1i32 / n;\n+   |         ^^^^^^^^\n+   |\n+   = note: `#[warn(unused_must_use)]` on by default\n+"}, {"sha": "1ce05ba390d76aee7401a08636191c2b982881b4", "filename": "src/test/ui/issues/issue-23477.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fissues%2Fissue-23477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fissues%2Fissue-23477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23477.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -1,5 +1,5 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-// compiler-flags: -g\n+// build-pass\n+// compile-flags: -g\n \n pub struct Dst {\n     pub a: (),"}, {"sha": "804b70d26527a05ea8970a49834c2f8f740ecde1", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,42 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n+\n+use std::cell::UnsafeCell;\n+use std::intrinsics::rustc_peek;\n+\n+#[repr(C)]\n+struct PartialInteriorMut {\n+    zst: [i32; 0],\n+    cell: UnsafeCell<i32>,\n+}\n+\n+#[rustc_mir(rustc_peek_indirectly_mutable,stop_after_dataflow)]\n+#[rustc_mir(borrowck_graphviz_postflow=\"indirect.dot\")]\n+const BOO: i32 = {\n+    let x = PartialInteriorMut {\n+        zst: [],\n+        cell: UnsafeCell::new(0),\n+    };\n+\n+    let p_zst: *const _ = &x.zst ; // Doesn't cause `x` to get marked as indirectly mutable.\n+\n+    let rmut_cell = unsafe {\n+        // Take advantage of the fact that `zst` and `cell` are at the same location in memory.\n+        // This trick would work with any size type if miri implemented `ptr::offset`.\n+        let p_cell = p_zst as *const UnsafeCell<i32>;\n+\n+        let pmut_cell = (*p_cell).get();\n+        &mut *pmut_cell\n+    };\n+\n+    *rmut_cell = 42;  // Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!\n+    let val = *rmut_cell;\n+    unsafe { rustc_peek(x) }; //~ ERROR rustc_peek: bit not set\n+\n+    val\n+};\n+\n+fn main() {\n+    println!(\"{}\", BOO);\n+}"}, {"sha": "16bd17813134a8e9d5f2a6ccd3d4f49ae15b8885", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,10 @@\n+error: rustc_peek: bit not set\n+  --> $DIR/indirect-mutation-offset.rs:35:14\n+   |\n+LL |     unsafe { rustc_peek(x) };\n+   |              ^^^^^^^^^^^^^\n+\n+error: stop_after_dataflow ended compilation\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5a9f662d229b297a49d6586a84714347d97d66ca", "filename": "src/test/ui/try-block/try-block-unreachable-code-lint.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.rs?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,76 @@\n+// Test unreachable_code lint for `try {}` block ok-wrapping. See issues #54165, #63324.\n+\n+// compile-flags: --edition 2018\n+// check-pass\n+#![feature(try_blocks)]\n+#![warn(unreachable_code)]\n+\n+fn err() -> Result<u32, ()> {\n+    Err(())\n+}\n+\n+// In the following cases unreachable code is autogenerated and should not be reported.\n+\n+fn test_ok_wrapped_divergent_expr_1() {\n+    let res: Result<u32, ()> = try {\n+        loop {\n+            err()?;\n+        }\n+    };\n+    println!(\"res: {:?}\", res);\n+}\n+\n+fn test_ok_wrapped_divergent_expr_2() {\n+    let _: Result<u32, ()> = try {\n+        return\n+    };\n+}\n+\n+fn test_autogenerated_unit_after_divergent_expr() {\n+    let _: Result<(), ()> = try {\n+        return;\n+    };\n+}\n+\n+// In the following cases unreachable code should be reported.\n+\n+fn test_try_block_after_divergent_stmt() {\n+    let _: Result<u32, ()> = {\n+        return;\n+\n+        try {\n+            loop {\n+                err()?;\n+            }\n+        }\n+        // ~^^^^^ WARNING unreachable expression\n+    };\n+}\n+\n+fn test_wrapped_divergent_expr() {\n+    let _: Result<u32, ()> = {\n+        Err(return)\n+        // ~^ WARNING unreachable call\n+    };\n+}\n+\n+fn test_expr_after_divergent_stmt_in_try_block() {\n+    let res: Result<u32, ()> = try {\n+        loop {\n+            err()?;\n+        }\n+\n+        42\n+        // ~^ WARNING unreachable expression\n+    };\n+    println!(\"res: {:?}\", res);\n+}\n+\n+fn main() {\n+    test_ok_wrapped_divergent_expr_1();\n+    test_ok_wrapped_divergent_expr_2();\n+    test_autogenerated_unit_after_divergent_expr();\n+    test_try_block_after_divergent_stmt();\n+    test_wrapped_divergent_expr();\n+    test_expr_after_divergent_stmt_in_try_block();\n+}"}, {"sha": "54fed04d400e936055e506bb843c2643ddd85c17", "filename": "src/test/ui/try-block/try-block-unreachable-code-lint.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2daa404e9a151a2e8262cbd6d8c209fd067aca16/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unreachable-code-lint.stderr?ref=2daa404e9a151a2e8262cbd6d8c209fd067aca16", "patch": "@@ -0,0 +1,38 @@\n+warning: unreachable expression\n+  --> $DIR/try-block-unreachable-code-lint.rs:41:9\n+   |\n+LL |           return;\n+   |           ------ any code following this expression is unreachable\n+LL | \n+LL | /         try {\n+LL | |             loop {\n+LL | |                 err()?;\n+LL | |             }\n+LL | |         }\n+   | |_________^ unreachable expression\n+   |\n+note: lint level defined here\n+  --> $DIR/try-block-unreachable-code-lint.rs:6:9\n+   |\n+LL | #![warn(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: unreachable call\n+  --> $DIR/try-block-unreachable-code-lint.rs:52:9\n+   |\n+LL |         Err(return)\n+   |         ^^^ ------ any code following this expression is unreachable\n+   |         |\n+   |         unreachable call\n+\n+warning: unreachable expression\n+  --> $DIR/try-block-unreachable-code-lint.rs:63:9\n+   |\n+LL | /         loop {\n+LL | |             err()?;\n+LL | |         }\n+   | |_________- any code following this expression is unreachable\n+LL | \n+LL |           42\n+   |           ^^ unreachable expression\n+"}]}