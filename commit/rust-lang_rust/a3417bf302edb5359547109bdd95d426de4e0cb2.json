{"sha": "a3417bf302edb5359547109bdd95d426de4e0cb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNDE3YmYzMDJlZGI1MzU5NTQ3MTA5YmRkOTVkNDI2ZGU0ZTBjYjI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-01T13:23:21Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-01T15:04:46Z"}, "message": "incr.comp.: Use a more efficient encoding for the on-disk dependency graph.", "tree": {"sha": "c196aee3b6eb6742cbf23c152a8afe5ae1f77c9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c196aee3b6eb6742cbf23c152a8afe5ae1f77c9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3417bf302edb5359547109bdd95d426de4e0cb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3417bf302edb5359547109bdd95d426de4e0cb2", "html_url": "https://github.com/rust-lang/rust/commit/a3417bf302edb5359547109bdd95d426de4e0cb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3417bf302edb5359547109bdd95d426de4e0cb2/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cbb8b58e8a5573190c93c9c94e0b003b1cfc6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbb8b58e8a5573190c93c9c94e0b003b1cfc6ef", "html_url": "https://github.com/rust-lang/rust/commit/0cbb8b58e8a5573190c93c9c94e0b003b1cfc6ef"}], "stats": {"total": 168, "additions": 110, "deletions": 58}, "files": [{"sha": "682a7051a1e95e45883d5827cee3e27b94e1bace", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=a3417bf302edb5359547109bdd95d426de4e0cb2", "patch": "@@ -17,11 +17,20 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHash;\n use std::sync::Arc;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n /// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n-    pub edges: Vec<SerializedEdgeSet>,\n+    /// The set of all DepNodes in the graph\n+    pub nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>>,\n+    /// For each DepNode, stores the list of edges originating from that\n+    /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n+    /// which holds the actual DepNodeIndices of the target nodes.\n+    pub edge_list_indices: Vec<(u32, u32)>,\n+    /// A flattened list of all edge targets in the graph. Edge sources are\n+    /// implicit in edge_list_indices.\n+    pub edge_list_data: Vec<DepNodeIndex>,\n \n     /// These are output nodes that have no incoming edges. We track\n     /// these separately so that when we reload all edges, we don't\n@@ -50,12 +59,30 @@ pub struct SerializedDepGraph {\n     pub hashes: Vec<SerializedHash>,\n }\n \n-/// Represents a set of \"reduced\" dependency edge. We group the\n-/// outgoing edges from a single source together.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct SerializedEdgeSet {\n-    pub source: DepNode<DefPathHash>,\n-    pub targets: Vec<DepNode<DefPathHash>>\n+/// The index of a DepNode in the SerializedDepGraph::nodes array.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct DepNodeIndex(pub u32);\n+\n+impl DepNodeIndex {\n+    #[inline]\n+    pub fn new(idx: usize) -> DepNodeIndex {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        DepNodeIndex(idx as u32)\n+    }\n+}\n+\n+impl Idx for DepNodeIndex {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        DepNodeIndex(idx as u32)\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n }\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "b30a1f4d3254fbfbd157850460895bc5f918a866", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=a3417bf302edb5359547109bdd95d426de4e0cb2", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n+use std::default::Default;\n use std::path::{Path};\n use std::sync::Arc;\n \n@@ -161,10 +162,23 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let serialized_dep_graph = SerializedDepGraph::decode(&mut dep_graph_decoder)?;\n \n-    let edge_map: FxHashMap<_, _> = serialized_dep_graph.edges\n-                                                        .into_iter()\n-                                                        .map(|s| (s.source, s.targets))\n-                                                        .collect();\n+    let edge_map: FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>> = {\n+        let capacity = serialized_dep_graph.edge_list_data.len();\n+        let mut edge_map = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n+\n+        for (node_index, source) in serialized_dep_graph.nodes.iter().enumerate() {\n+            let (start, end) = serialized_dep_graph.edge_list_indices[node_index];\n+            let targets =\n+                (&serialized_dep_graph.edge_list_data[start as usize .. end as usize])\n+                .into_iter()\n+                .map(|&node_index| serialized_dep_graph.nodes[node_index].clone())\n+                .collect();\n+\n+            edge_map.insert(source.clone(), targets);\n+        }\n+\n+        edge_map\n+    };\n \n     // Compute the set of nodes from the old graph where some input\n     // has changed or been removed. These are \"raw\" source nodes,"}, {"sha": "6d717d6f409d5706f4b3d90928d32e1061de95a1", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3417bf302edb5359547109bdd95d426de4e0cb2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=a3417bf302edb5359547109bdd95d426de4e0cb2", "patch": "@@ -11,11 +11,14 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n+use rustc::hir::map::DefPathHash;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::graph;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::io::{self, Cursor, Write};\n@@ -175,65 +178,73 @@ pub fn encode_dep_graph(tcx: TyCtxt,\n         dep_node.map_def(|&def_id| Some(tcx.def_path_hash(def_id))).unwrap()\n     };\n \n-    // Create a flat list of (Input, WorkProduct) edges for\n-    // serialization.\n-    let mut edges = FxHashMap();\n-    for edge in preds.reduced_graph.all_edges() {\n-        let source = *preds.reduced_graph.node_data(edge.source());\n-        let target = *preds.reduced_graph.node_data(edge.target());\n-        match *target {\n-            DepNode::MetaData(ref def_id) => {\n-                // Metadata *targets* are always local metadata nodes. We have\n-                // already handled those in `encode_metadata_hashes`.\n-                assert!(def_id.is_local());\n-                continue;\n-            }\n-            _ => (),\n-        }\n-        debug!(\"serialize edge: {:?} -> {:?}\", source, target);\n-        let source = to_hash_based_node(source);\n-        let target = to_hash_based_node(target);\n-        edges.entry(source).or_insert(vec![]).push(target);\n-    }\n+    // NB: We rely on this Vec being indexable by reduced_graph's NodeIndex.\n+    let nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>> = preds\n+        .reduced_graph\n+        .all_nodes()\n+        .iter()\n+        .map(|node| to_hash_based_node(node.data))\n+        .collect();\n \n-    if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-        for (dep_node, hash) in &preds.hashes {\n-            println!(\"HIR hash for {:?} is {}\", dep_node, hash);\n+    let mut edge_list_indices = Vec::with_capacity(nodes.len());\n+    let mut edge_list_data = Vec::with_capacity(preds.reduced_graph.len_edges());\n+\n+    for node_index in 0 .. nodes.len() {\n+        let start = edge_list_data.len() as u32;\n+\n+        for target in preds.reduced_graph.successor_nodes(graph::NodeIndex(node_index)) {\n+            edge_list_data.push(DepNodeIndex::new(target.node_id()));\n         }\n+\n+        let end = edge_list_data.len() as u32;\n+        debug_assert_eq!(node_index, edge_list_indices.len());\n+        edge_list_indices.push((start, end));\n     }\n \n-    // Create the serialized dep-graph.\n-    let bootstrap_outputs = preds.bootstrap_outputs\n-                                 .iter()\n-                                 .map(|n| to_hash_based_node(n))\n-                                 .collect();\n-    let edges = edges.into_iter()\n-                     .map(|(k, v)| SerializedEdgeSet { source: k, targets: v })\n-                     .collect();\n+    // Let's make we had no overflow there.\n+    assert!(edge_list_data.len() <= ::std::u32::MAX as usize);\n+    // Check that we have a consistent number of edges.\n+    assert_eq!(edge_list_data.len(), preds.reduced_graph.len_edges());\n+\n+    let bootstrap_outputs = preds\n+        .bootstrap_outputs\n+        .iter()\n+        .map(|n| to_hash_based_node(n))\n+        .collect();\n+\n+    let hashes = preds\n+        .hashes\n+        .iter()\n+        .map(|(&dep_node, &hash)| {\n+            SerializedHash {\n+                dep_node: to_hash_based_node(dep_node),\n+                hash: hash,\n+            }\n+        })\n+        .collect();\n+\n     let graph = SerializedDepGraph {\n+        nodes,\n+        edge_list_indices,\n+        edge_list_data,\n         bootstrap_outputs,\n-        edges,\n-        hashes: preds.hashes\n-            .iter()\n-            .map(|(&dep_node, &hash)| {\n-                SerializedHash {\n-                    dep_node: to_hash_based_node(dep_node),\n-                    hash: hash,\n-                }\n-            })\n-            .collect(),\n+        hashes,\n     };\n \n+    // Encode the graph data.\n+    graph.encode(encoder)?;\n+\n     if tcx.sess.opts.debugging_opts.incremental_info {\n-        println!(\"incremental: {} nodes in reduced dep-graph\", preds.reduced_graph.len_nodes());\n-        println!(\"incremental: {} edges in serialized dep-graph\", graph.edges.len());\n+        println!(\"incremental: {} nodes in reduced dep-graph\", graph.nodes.len());\n+        println!(\"incremental: {} edges in serialized dep-graph\", graph.edge_list_data.len());\n         println!(\"incremental: {} hashes in serialized dep-graph\", graph.hashes.len());\n     }\n \n-    debug!(\"graph = {:#?}\", graph);\n-\n-    // Encode the graph data.\n-    graph.encode(encoder)?;\n+    if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+        for (dep_node, hash) in &preds.hashes {\n+            println!(\"ICH for {:?} is {}\", dep_node, hash);\n+        }\n+    }\n \n     Ok(())\n }"}]}