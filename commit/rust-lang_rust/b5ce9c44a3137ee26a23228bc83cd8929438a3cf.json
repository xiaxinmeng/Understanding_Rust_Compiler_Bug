{"sha": "b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1Y2U5YzQ0YTMxMzdlZTI2YTIzMjI4YmM4M2NkODkyOTQzOGEzY2Y=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-17T20:31:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-17T20:31:32Z"}, "message": "Rollup merge of #84150 - jsha:defer-search-js, r=GuillaumeGomez\n\nrustdoc: move some search code into search.js\n\nThis reduces main.s from 3094 lines to 1587. Also it saves some bytes\nof download in the case where search isn't used.\n\nThere were a fair number of variables that needed to be accessible in\nboth main.js and search.js, but I didn't want to put too many symbols in\nthe global namespace, so I consolidated much of the search-related\nstate and functions into a new object `window.searchState`.\n\nDemo at https://hoffman-andrews.com/rust/move-search/std/?search=foo", "tree": {"sha": "03195c4874a78d8e385b2228306fa0b405e2491e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03195c4874a78d8e385b2228306fa0b405e2491e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJge0WkCRBK7hj4Ov3rIwAAc4oIADf0Pz/rMN33fLS5D9q5zYVR\n0GDRomkMXt1jTXE7+9BHGCxFOuifBvLkYbo+0jfpg9jKMMMkqixj5HIp4x8W9ZVu\n/2SF6JmAAf+AbaaIxXOK6amlpnIVOLj3AyOjchCzdP/3b4r/cilXqnp98Pc3zKPc\nijXZUYfqcoaGgEPLROI0k3/o4WE4k/TEH6p8ynrmlzKE6QIFqR8SNsdFwti4ZUHB\nTfdGvPinUPy4eO9OkTjzeZx7dbhbk1aNtAIGHcXufcrACcLrfpnz06bMU6nzuUcW\nkBE33VZmC/P7OwSeIPEuPeJfNPvmp5jOjvx2ilrnkjaWGKzBcGUnbX8wZMNmahM=\n=3HwX\n-----END PGP SIGNATURE-----\n", "payload": "tree 03195c4874a78d8e385b2228306fa0b405e2491e\nparent 5dae27a8da16f352f82e93df691e7875bd360ea7\nparent 6f1f3eb516a433f4b32ab7298409015555b1cef6\nauthor Dylan DPC <dylan.dpc@gmail.com> 1618691492 +0200\ncommitter GitHub <noreply@github.com> 1618691492 +0200\n\nRollup merge of #84150 - jsha:defer-search-js, r=GuillaumeGomez\n\nrustdoc: move some search code into search.js\n\nThis reduces main.s from 3094 lines to 1587. Also it saves some bytes\nof download in the case where search isn't used.\n\nThere were a fair number of variables that needed to be accessible in\nboth main.js and search.js, but I didn't want to put too many symbols in\nthe global namespace, so I consolidated much of the search-related\nstate and functions into a new object `window.searchState`.\n\nDemo at https://hoffman-andrews.com/rust/move-search/std/?search=foo\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "html_url": "https://github.com/rust-lang/rust/commit/b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dae27a8da16f352f82e93df691e7875bd360ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dae27a8da16f352f82e93df691e7875bd360ea7", "html_url": "https://github.com/rust-lang/rust/commit/5dae27a8da16f352f82e93df691e7875bd360ea7"}, {"sha": "6f1f3eb516a433f4b32ab7298409015555b1cef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1f3eb516a433f4b32ab7298409015555b1cef6", "html_url": "https://github.com/rust-lang/rust/commit/6f1f3eb516a433f4b32ab7298409015555b1cef6"}], "stats": {"total": 3375, "additions": 1682, "deletions": 1693}, "files": [{"sha": "dc67a63d333991643b6b815f0ebc70f3c91a8703", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -113,7 +113,8 @@ crate fn render<T: Print, S: Print>(\n     <section class=\\\"footer\\\"></section>\\\n     {after_content}\\\n     <div id=\\\"rustdoc-vars\\\" data-root-path=\\\"{root_path}\\\" data-current-crate=\\\"{krate}\\\" \\\n-       data-search-js=\\\"{root_path}search-index{suffix}.js\\\"></div>\n+       data-search-index-js=\\\"{root_path}search-index{suffix}.js\\\" \\\n+       data-search-js=\\\"{static_root_path}search{suffix}.js\\\"></div>\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n     {extra_scripts}\\\n </body>\\"}, {"sha": "78bcd40af7538070e94dbbc2db9916d9e5066608", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -222,6 +222,7 @@ pub(super) fn write_shared(\n             &format!(\" = {}\", serde_json::to_string(&themes).unwrap()),\n         ),\n     )?;\n+    write_minify(\"search.js\", static_files::SEARCH_JS)?;\n     write_minify(\"settings.js\", static_files::SETTINGS_JS)?;\n     if cx.shared.include_sources {\n         write_minify(\"source-script.js\", static_files::sidebar::SOURCE_SCRIPT)?;\n@@ -409,7 +410,7 @@ pub(super) fn write_shared(\n     write_crate(\"search-index.js\", &|| {\n         let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n         v.push_str(&all_indexes.join(\",\\\\\\n\"));\n-        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n+        v.push_str(\"\\\\\\n}');\\nif (window.initSearch) {window.initSearch(searchIndex)};\");\n         Ok(v.into_bytes())\n     })?;\n "}, {"sha": "f017fd846b1db69b7c263dec7321072a9b1046ad", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 157, "deletions": 1685, "changes": 1842, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n // Local js definitions:\n /* global addClass, getSettingValue, hasClass */\n /* global onEach, onEachLazy, hasOwnProperty, removeClass, updateLocalStorage */\n@@ -44,6 +43,7 @@ if (!DOMTokenList.prototype.remove) {\n         window.rootPath = rustdocVars.attributes[\"data-root-path\"].value;\n         window.currentCrate = rustdocVars.attributes[\"data-current-crate\"].value;\n         window.searchJS = rustdocVars.attributes[\"data-search-js\"].value;\n+        window.searchIndexJS = rustdocVars.attributes[\"data-search-index-js\"].value;\n     }\n     var sidebarVars = document.getElementById(\"sidebar-vars\");\n     if (sidebarVars) {\n@@ -77,14 +77,6 @@ function getVirtualKey(ev) {\n     return String.fromCharCode(c);\n }\n \n-function getSearchInput() {\n-    return document.getElementsByClassName(\"search-input\")[0];\n-}\n-\n-function getSearchElement() {\n-    return document.getElementById(\"search\");\n-}\n-\n var THEME_PICKER_ELEMENT_ID = \"theme-picker\";\n var THEMES_ELEMENT_ID = \"theme-choices\";\n \n@@ -101,16 +93,6 @@ function getNakedUrl() {\n     return window.location.href.split(\"?\")[0].split(\"#\")[0];\n }\n \n-// Sets the focus on the search bar at the top of the page\n-function focusSearchBar() {\n-    getSearchInput().focus();\n-}\n-\n-// Removes the focus from the search bar.\n-function defocusSearchBar() {\n-    getSearchInput().blur();\n-}\n-\n function showThemeButtonState() {\n     var themePicker = getThemePickerElement();\n     var themeChoices = getThemesElement();\n@@ -173,67 +155,154 @@ function hideThemeButtonState() {\n (function() {\n     \"use strict\";\n \n-    // This mapping table should match the discriminants of\n-    // `rustdoc::html::item_type::ItemType` type in Rust.\n-    var itemTypes = [\"mod\",\n-                     \"externcrate\",\n-                     \"import\",\n-                     \"struct\",\n-                     \"enum\",\n-                     \"fn\",\n-                     \"type\",\n-                     \"static\",\n-                     \"trait\",\n-                     \"impl\",\n-                     \"tymethod\",\n-                     \"method\",\n-                     \"structfield\",\n-                     \"variant\",\n-                     \"macro\",\n-                     \"primitive\",\n-                     \"associatedtype\",\n-                     \"constant\",\n-                     \"associatedconstant\",\n-                     \"union\",\n-                     \"foreigntype\",\n-                     \"keyword\",\n-                     \"existential\",\n-                     \"attr\",\n-                     \"derive\",\n-                     \"traitalias\"];\n+    window.searchState = {\n+      loadingText: \"Loading search results...\",\n+      input: document.getElementsByClassName(\"search-input\")[0],\n+      outputElement: function() {\n+        return document.getElementById(\"search\");\n+      },\n+      title: null,\n+      titleBeforeSearch: document.title,\n+      timeout: null,\n+      // On the search screen, so you remain on the last tab you opened.\n+      //\n+      // 0 for \"In Names\"\n+      // 1 for \"In Parameters\"\n+      // 2 for \"In Return Types\"\n+      currentTab: 0,\n+      mouseMovedAfterSearch: true,\n+      clearInputTimeout: function() {\n+        if (searchState.timeout !== null) {\n+            clearTimeout(searchState.timeout);\n+            searchState.timeout = null;\n+        }\n+      },\n+      // Sets the focus on the search bar at the top of the page\n+      focus: function() {\n+          searchState.input.focus();\n+      },\n+      // Removes the focus from the search bar.\n+      defocus: function() {\n+          searchState.input.blur();\n+      },\n+      showResults: function(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = searchState.outputElement();\n+        }\n+        addClass(main, \"hidden\");\n+        removeClass(search, \"hidden\");\n+        searchState.mouseMovedAfterSearch = false;\n+        document.title = searchState.title;\n+      },\n+      hideResults: function(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = searchState.outputElement();\n+        }\n+        addClass(search, \"hidden\");\n+        removeClass(main, \"hidden\");\n+        document.title = searchState.titleBeforeSearch;\n+        // We also remove the query parameter from the URL.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            history.replaceState(\"\", window.currentCrate + \" - Rust\",\n+                getNakedUrl() + window.location.hash);\n+        }\n+      },\n+      getQueryStringParams: function() {\n+        var params = {};\n+        window.location.search.substring(1).split(\"&\").\n+            map(function(s) {\n+                var pair = s.split(\"=\");\n+                params[decodeURIComponent(pair[0])] =\n+                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n+            });\n+        return params;\n+      },\n+      putBackSearch: function(search_input) {\n+        var search = searchState.outputElement();\n+        if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n+            searchState.showResults(search);\n+            if (searchState.browserSupportsHistoryApi()) {\n+                var extra = \"?search=\" + encodeURIComponent(search_input.value);\n+                history.replaceState(search_input.value, \"\",\n+                    getNakedUrl() + extra + window.location.hash);\n+            }\n+            document.title = searchState.title;\n+        }\n+      },\n+      browserSupportsHistoryApi: function() {\n+          return window.history && typeof window.history.pushState === \"function\";\n+      },\n+      setup: function() {\n+        var search_input = searchState.input;\n+        if (!searchState.input) {\n+            return;\n+        }\n+        function loadScript(url) {\n+            var script = document.createElement('script');\n+            script.src = url;\n+            document.head.append(script);\n+        }\n \n-    var disableShortcuts = getSettingValue(\"disable-shortcuts\") === \"true\";\n-    var search_input = getSearchInput();\n-    var searchTimeout = null;\n-    var toggleAllDocsId = \"toggle-all-docs\";\n+        var searchLoaded = false;\n+        function loadSearch() {\n+            if (!searchLoaded) {\n+                searchLoaded = true;\n+                loadScript(window.searchJS);\n+                loadScript(window.searchIndexJS);\n+            }\n+        }\n \n-    // On the search screen, so you remain on the last tab you opened.\n-    //\n-    // 0 for \"In Names\"\n-    // 1 for \"In Parameters\"\n-    // 2 for \"In Return Types\"\n-    var currentTab = 0;\n+        search_input.addEventListener(\"focus\", function() {\n+            searchState.putBackSearch(this);\n+            search_input.origPlaceholder = searchState.input.placeholder;\n+            search_input.placeholder = \"Type your search here.\";\n+            loadSearch();\n+        });\n+        search_input.addEventListener(\"blur\", function() {\n+            search_input.placeholder = searchState.input.origPlaceholder;\n+        });\n \n-    var mouseMovedAfterSearch = true;\n+        document.addEventListener(\"mousemove\", function() {\n+          searchState.mouseMovedAfterSearch = true;\n+        });\n \n-    var titleBeforeSearch = document.title;\n-    var searchTitle = null;\n+        search_input.removeAttribute('disabled');\n \n-    function removeEmptyStringsFromArray(x) {\n-        for (var i = 0, len = x.length; i < len; ++i) {\n-            if (x[i] === \"\") {\n-                x.splice(i, 1);\n-                i -= 1;\n-            }\n+        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n+        searchState.addCrateDropdown(window.ALL_CRATES);\n+        var params = searchState.getQueryStringParams();\n+        if (params.search !== undefined) {\n+            var search = searchState.outputElement();\n+            search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">\" +\n+               searchState.loadingText + \"</h3>\";\n+            searchState.showResults(search);\n+            loadSearch();\n         }\n-    }\n+      },\n+      addCrateDropdown: function(crates) {\n+        var elem = document.getElementById(\"crate-search\");\n \n-    function clearInputTimeout() {\n-        if (searchTimeout !== null) {\n-            clearTimeout(searchTimeout);\n-            searchTimeout = null;\n+        if (!elem) {\n+            return;\n         }\n-    }\n+        var savedCrate = getSettingValue(\"saved-filter-crate\");\n+        for (var i = 0, len = crates.length; i < len; ++i) {\n+            var option = document.createElement(\"option\");\n+            option.value = crates[i];\n+            option.innerText = crates[i];\n+            elem.appendChild(option);\n+            // Set the crate filter from saved storage, if the current page has the saved crate\n+            // filter.\n+            //\n+            // If not, ignore the crate filter -- we want to support filtering for crates on sites\n+            // like doc.rust-lang.org where the crates may differ from page to page while on the\n+            // same domain.\n+            if (crates[i] === savedCrate) {\n+                elem.value = savedCrate;\n+            }\n+        }\n+      },\n+    };\n \n     function getPageId() {\n         if (window.location.hash) {\n@@ -276,65 +345,23 @@ function hideThemeButtonState() {\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n     }\n \n-    function showSearchResults(search) {\n-        if (search === null || typeof search === 'undefined') {\n-            search = getSearchElement();\n-        }\n-        addClass(main, \"hidden\");\n-        removeClass(search, \"hidden\");\n-        mouseMovedAfterSearch = false;\n-        document.title = searchTitle;\n-    }\n-\n-    function hideSearchResults(search) {\n-        if (search === null || typeof search === 'undefined') {\n-            search = getSearchElement();\n-        }\n-        addClass(search, \"hidden\");\n-        removeClass(main, \"hidden\");\n-        document.title = titleBeforeSearch;\n-        // We also remove the query parameter from the URL.\n-        if (browserSupportsHistoryApi()) {\n-            history.replaceState(\"\", window.currentCrate + \" - Rust\",\n-                getNakedUrl() + window.location.hash);\n-        }\n-    }\n-\n-    // used for special search precedence\n-    var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n-    var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n-\n-    function getQueryStringParams() {\n-        var params = {};\n-        window.location.search.substring(1).split(\"&\").\n-            map(function(s) {\n-                var pair = s.split(\"=\");\n-                params[decodeURIComponent(pair[0])] =\n-                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n-            });\n-        return params;\n-    }\n-\n-    function browserSupportsHistoryApi() {\n-        return window.history && typeof window.history.pushState === \"function\";\n-    }\n-\n     function isHidden(elem) {\n         return elem.offsetHeight === 0;\n     }\n \n+    var toggleAllDocsId = \"toggle-all-docs\";\n     var main = document.getElementById(\"main\");\n     var savedHash = \"\";\n \n     function handleHashes(ev) {\n         var elem;\n-        var search = getSearchElement();\n+        var search = searchState.outputElement();\n         if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n             // This block occurs when clicking on an element in the navbar while\n             // in a search.\n-            hideSearchResults(search);\n+            searchState.hideResults(search);\n             var hash = ev.newURL.slice(ev.newURL.indexOf(\"#\") + 1);\n-            if (browserSupportsHistoryApi()) {\n+            if (searchState.browserSupportsHistoryApi()) {\n                 // `window.location.search`` contains all the query parameters, not just `search`.\n                 history.replaceState(hash, \"\",\n                     getNakedUrl() + window.location.search + \"#\" + hash);\n@@ -475,18 +502,19 @@ function hideThemeButtonState() {\n \n     function handleEscape(ev) {\n         var help = getHelpElement(false);\n-        var search = getSearchElement();\n+        var search = searchState.outputElement();\n         if (hasClass(help, \"hidden\") === false) {\n             displayHelp(false, ev, help);\n         } else if (hasClass(search, \"hidden\") === false) {\n-            clearInputTimeout();\n+            searchState.clearInputTimeout();\n             ev.preventDefault();\n-            hideSearchResults(search);\n+            searchState.hideResults(search);\n         }\n-        defocusSearchBar();\n+        searchState.defocus();\n         hideThemeButtonState();\n     }\n \n+    var disableShortcuts = getSettingValue(\"disable-shortcuts\") === \"true\";\n     function handleShortcut(ev) {\n         // Don't interfere with browser shortcuts\n         if (ev.ctrlKey || ev.altKey || ev.metaKey || disableShortcuts === true) {\n@@ -509,7 +537,7 @@ function hideThemeButtonState() {\n             case \"S\":\n                 displayHelp(false, ev);\n                 ev.preventDefault();\n-                focusSearchBar();\n+                searchState.focus();\n                 break;\n \n             case \"+\":\n@@ -596,15 +624,13 @@ function hideThemeButtonState() {\n     document.addEventListener(\"keypress\", handleShortcut);\n     document.addEventListener(\"keydown\", handleShortcut);\n \n-    document.addEventListener(\"mousemove\", function() { mouseMovedAfterSearch = true; });\n-\n     var handleSourceHighlight = (function() {\n         var prev_line_id = 0;\n \n         var set_fragment = function(name) {\n             var x = window.scrollX,\n                 y = window.scrollY;\n-            if (browserSupportsHistoryApi()) {\n+            if (searchState.browserSupportsHistoryApi()) {\n                 history.replaceState(null, null, \"#\" + name);\n                 highlightSourceLines();\n             } else {\n@@ -686,1444 +712,6 @@ function hideThemeButtonState() {\n         }\n     }());\n \n-    /**\n-     * A function to compute the Levenshtein distance between two strings\n-     * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n-     * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n-     * This code is an unmodified version of the code written by Marco de Wit\n-     * and was found at http://stackoverflow.com/a/18514751/745719\n-     */\n-    var levenshtein_row2 = [];\n-    function levenshtein(s1, s2) {\n-        if (s1 === s2) {\n-            return 0;\n-        }\n-        var s1_len = s1.length, s2_len = s2.length;\n-        if (s1_len && s2_len) {\n-            var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n-            while (i1 < s1_len) {\n-                row[i1] = ++i1;\n-            }\n-            while (i2 < s2_len) {\n-                c2 = s2.charCodeAt(i2);\n-                a = i2;\n-                ++i2;\n-                b = i2;\n-                for (i1 = 0; i1 < s1_len; ++i1) {\n-                    c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n-                    a = row[i1];\n-                    b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n-                    row[i1] = b;\n-                }\n-            }\n-            return b;\n-        }\n-        return s1_len + s2_len;\n-    }\n-\n-    window.initSearch = function(rawSearchIndex) {\n-        var MAX_LEV_DISTANCE = 3;\n-        var MAX_RESULTS = 200;\n-        var GENERICS_DATA = 1;\n-        var NAME = 0;\n-        var INPUTS_DATA = 0;\n-        var OUTPUT_DATA = 1;\n-        var NO_TYPE_FILTER = -1;\n-        var currentResults, index, searchIndex;\n-        var ALIASES = {};\n-        var params = getQueryStringParams();\n-\n-        // Populate search bar with query string search term when provided,\n-        // but only if the input bar is empty. This avoid the obnoxious issue\n-        // where you start trying to do a search, and the index loads, and\n-        // suddenly your search is gone!\n-        if (search_input.value === \"\") {\n-            search_input.value = params.search || \"\";\n-        }\n-\n-        /**\n-         * Executes the query and builds an index of results\n-         * @param  {[Object]} query      [The user query]\n-         * @param  {[type]} searchWords  [The list of search words to query\n-         *                                against]\n-         * @param  {[type]} filterCrates [Crate to search in if defined]\n-         * @return {[type]}              [A search index of results]\n-         */\n-        function execQuery(query, searchWords, filterCrates) {\n-            function itemTypeFromName(typename) {\n-                for (var i = 0, len = itemTypes.length; i < len; ++i) {\n-                    if (itemTypes[i] === typename) {\n-                        return i;\n-                    }\n-                }\n-                return NO_TYPE_FILTER;\n-            }\n-\n-            var valLower = query.query.toLowerCase(),\n-                val = valLower,\n-                typeFilter = itemTypeFromName(query.type),\n-                results = {}, results_in_args = {}, results_returned = {},\n-                split = valLower.split(\"::\");\n-\n-            removeEmptyStringsFromArray(split);\n-\n-            function transformResults(results, isType) {\n-                var out = [];\n-                for (var i = 0, len = results.length; i < len; ++i) {\n-                    if (results[i].id > -1) {\n-                        var obj = searchIndex[results[i].id];\n-                        obj.lev = results[i].lev;\n-                        if (isType !== true || obj.type) {\n-                            var res = buildHrefAndPath(obj);\n-                            obj.displayPath = pathSplitter(res[0]);\n-                            obj.fullPath = obj.displayPath + obj.name;\n-                            // To be sure than it some items aren't considered as duplicate.\n-                            obj.fullPath += \"|\" + obj.ty;\n-                            obj.href = res[1];\n-                            out.push(obj);\n-                            if (out.length >= MAX_RESULTS) {\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-                return out;\n-            }\n-\n-            function sortResults(results, isType) {\n-                var ar = [];\n-                for (var entry in results) {\n-                    if (hasOwnProperty(results, entry)) {\n-                        ar.push(results[entry]);\n-                    }\n-                }\n-                results = ar;\n-                var i, len, result;\n-                for (i = 0, len = results.length; i < len; ++i) {\n-                    result = results[i];\n-                    result.word = searchWords[result.id];\n-                    result.item = searchIndex[result.id] || {};\n-                }\n-                // if there are no results then return to default and fail\n-                if (results.length === 0) {\n-                    return [];\n-                }\n-\n-                results.sort(function(aaa, bbb) {\n-                    var a, b;\n-\n-                    // sort by exact match with regard to the last word (mismatch goes later)\n-                    a = (aaa.word !== val);\n-                    b = (bbb.word !== val);\n-                    if (a !== b) { return a - b; }\n-\n-                    // Sort by non levenshtein results and then levenshtein results by the distance\n-                    // (less changes required to match means higher rankings)\n-                    a = (aaa.lev);\n-                    b = (bbb.lev);\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by crate (non-current crate goes later)\n-                    a = (aaa.item.crate !== window.currentCrate);\n-                    b = (bbb.item.crate !== window.currentCrate);\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by item name length (longer goes later)\n-                    a = aaa.word.length;\n-                    b = bbb.word.length;\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by item name (lexicographically larger goes later)\n-                    a = aaa.word;\n-                    b = bbb.word;\n-                    if (a !== b) { return (a > b ? +1 : -1); }\n-\n-                    // sort by index of keyword in item name (no literal occurrence goes later)\n-                    a = (aaa.index < 0);\n-                    b = (bbb.index < 0);\n-                    if (a !== b) { return a - b; }\n-                    // (later literal occurrence, if any, goes later)\n-                    a = aaa.index;\n-                    b = bbb.index;\n-                    if (a !== b) { return a - b; }\n-\n-                    // special precedence for primitive and keyword pages\n-                    if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n-                        (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n-                        return -1;\n-                    }\n-                    if ((bbb.item.ty === TY_PRIMITIVE && aaa.item.ty !== TY_PRIMITIVE) ||\n-                        (bbb.item.ty === TY_KEYWORD && aaa.item.ty !== TY_KEYWORD)) {\n-                        return 1;\n-                    }\n-\n-                    // sort by description (no description goes later)\n-                    a = (aaa.item.desc === \"\");\n-                    b = (bbb.item.desc === \"\");\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by type (later occurrence in `itemTypes` goes later)\n-                    a = aaa.item.ty;\n-                    b = bbb.item.ty;\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by path (lexicographically larger goes later)\n-                    a = aaa.item.path;\n-                    b = bbb.item.path;\n-                    if (a !== b) { return (a > b ? +1 : -1); }\n-\n-                    // que sera, sera\n-                    return 0;\n-                });\n-\n-                for (i = 0, len = results.length; i < len; ++i) {\n-                    var result = results[i];\n-\n-                    // this validation does not make sense when searching by types\n-                    if (result.dontValidate) {\n-                        continue;\n-                    }\n-                    var name = result.item.name.toLowerCase(),\n-                        path = result.item.path.toLowerCase(),\n-                        parent = result.item.parent;\n-\n-                    if (isType !== true &&\n-                        validateResult(name, path, split, parent) === false)\n-                    {\n-                        result.id = -1;\n-                    }\n-                }\n-                return transformResults(results);\n-            }\n-\n-            function extractGenerics(val) {\n-                val = val.toLowerCase();\n-                if (val.indexOf(\"<\") !== -1) {\n-                    var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n-                    return {\n-                        name: val.substring(0, val.indexOf(\"<\")),\n-                        generics: values.split(/\\s*,\\s*/),\n-                    };\n-                }\n-                return {\n-                    name: val,\n-                    generics: [],\n-                };\n-            }\n-\n-            function getObjectNameFromId(id) {\n-                if (typeof id === \"number\") {\n-                    return searchIndex[id].name;\n-                }\n-                return id;\n-            }\n-\n-            function checkGenerics(obj, val) {\n-                // The names match, but we need to be sure that all generics kinda\n-                // match as well.\n-                var tmp_lev, elem_name;\n-                if (val.generics.length > 0) {\n-                    if (obj.length > GENERICS_DATA &&\n-                          obj[GENERICS_DATA].length >= val.generics.length) {\n-                        var elems = Object.create(null);\n-                        var elength = object[GENERICS_DATA].length;\n-                        for (var x = 0; x < elength; ++x) {\n-                            elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n-                        }\n-                        var total = 0;\n-                        var done = 0;\n-                        // We need to find the type that matches the most to remove it in order\n-                        // to move forward.\n-                        var vlength = val.generics.length;\n-                        for (x = 0; x < vlength; ++x) {\n-                            var lev = MAX_LEV_DISTANCE + 1;\n-                            var firstGeneric = getObjectNameFromId(val.generics[x]);\n-                            var match = null;\n-                            if (elems[firstGeneric]) {\n-                                match = firstGeneric;\n-                                lev = 0;\n-                            } else {\n-                                for (elem_name in elems) {\n-                                    tmp_lev = levenshtein(elem_name, firstGeneric);\n-                                    if (tmp_lev < lev) {\n-                                        lev = tmp_lev;\n-                                        match = elem_name;\n-                                    }\n-                                }\n-                            }\n-                            if (match !== null) {\n-                                elems[match] -= 1;\n-                                if (elems[match] == 0) {\n-                                    delete elems[match];\n-                                }\n-                                total += lev;\n-                                done += 1;\n-                            } else {\n-                                return MAX_LEV_DISTANCE + 1;\n-                            }\n-                        }\n-                        return Math.ceil(total / done);\n-                    }\n-                }\n-                return MAX_LEV_DISTANCE + 1;\n-            }\n-\n-            // Check for type name and type generics (if any).\n-            function checkType(obj, val, literalSearch) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-                var len, x, firstGeneric;\n-                if (obj[NAME] === val.name) {\n-                    if (literalSearch === true) {\n-                        if (val.generics && val.generics.length !== 0) {\n-                            if (obj.length > GENERICS_DATA &&\n-                                  obj[GENERICS_DATA].length >= val.generics.length) {\n-                                var elems = Object.create(null);\n-                                len = obj[GENERICS_DATA].length;\n-                                for (x = 0; x < len; ++x) {\n-                                    elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n-                                }\n-\n-                                var allFound = true;\n-                                len = val.generics.length;\n-                                for (x = 0; x < len; ++x) {\n-                                    firstGeneric = getObjectNameFromId(val.generics[x]);\n-                                    if (elems[firstGeneric]) {\n-                                        elems[firstGeneric] -= 1;\n-                                    } else {\n-                                        allFound = false;\n-                                        break;\n-                                    }\n-                                }\n-                                if (allFound === true) {\n-                                    return true;\n-                                }\n-                            } else {\n-                                return false;\n-                            }\n-                        }\n-                        return true;\n-                    }\n-                    // If the type has generics but don't match, then it won't return at this point.\n-                    // Otherwise, `checkGenerics` will return 0 and it'll return.\n-                    if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n-                        var tmp_lev = checkGenerics(obj, val);\n-                        if (tmp_lev <= MAX_LEV_DISTANCE) {\n-                            return tmp_lev;\n-                        }\n-                    } else {\n-                        return 0;\n-                    }\n-                }\n-                // Names didn't match so let's check if one of the generic types could.\n-                if (literalSearch === true) {\n-                     if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                        return obj[GENERICS_DATA].some(\n-                            function(name) {\n-                                return name === val.name;\n-                            });\n-                    }\n-                    return false;\n-                }\n-                lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n-                if (lev_distance <= MAX_LEV_DISTANCE) {\n-                    // The generics didn't match but the name kinda did so we give it\n-                    // a levenshtein distance value that isn't *this* good so it goes\n-                    // into the search results but not too high.\n-                    lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n-                } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                    // We can check if the type we're looking for is inside the generics!\n-                    var olength = obj[GENERICS_DATA].length;\n-                    for (x = 0; x < olength; ++x) {\n-                        lev_distance = Math.min(levenshtein(obj[GENERICS_DATA][x], val.name),\n-                                                lev_distance);\n-                    }\n-                }\n-                // Now whatever happens, the returned distance is \"less good\" so we should mark it\n-                // as such, and so we add 1 to the distance to make it \"less good\".\n-                return lev_distance + 1;\n-            }\n-\n-            function findArg(obj, val, literalSearch, typeFilter) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-\n-                if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n-                    var length = obj.type[INPUTS_DATA].length;\n-                    for (var i = 0; i < length; i++) {\n-                        var tmp = obj.type[INPUTS_DATA][i];\n-                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n-                            continue;\n-                        }\n-                        tmp = checkType(tmp, val, literalSearch);\n-                        if (literalSearch === true) {\n-                            if (tmp === true) {\n-                                return true;\n-                            }\n-                            continue;\n-                        }\n-                        lev_distance = Math.min(tmp, lev_distance);\n-                        if (lev_distance === 0) {\n-                            return 0;\n-                        }\n-                    }\n-                }\n-                return literalSearch === true ? false : lev_distance;\n-            }\n-\n-            function checkReturned(obj, val, literalSearch, typeFilter) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-\n-                if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                    var ret = obj.type[OUTPUT_DATA];\n-                    if (typeof ret[0] === \"string\") {\n-                        ret = [ret];\n-                    }\n-                    for (var x = 0, len = ret.length; x < len; ++x) {\n-                        var tmp = ret[x];\n-                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n-                            continue;\n-                        }\n-                        tmp = checkType(tmp, val, literalSearch);\n-                        if (literalSearch === true) {\n-                            if (tmp === true) {\n-                                return true;\n-                            }\n-                            continue;\n-                        }\n-                        lev_distance = Math.min(tmp, lev_distance);\n-                        if (lev_distance === 0) {\n-                            return 0;\n-                        }\n-                    }\n-                }\n-                return literalSearch === true ? false : lev_distance;\n-            }\n-\n-            function checkPath(contains, lastElem, ty) {\n-                if (contains.length === 0) {\n-                    return 0;\n-                }\n-                var ret_lev = MAX_LEV_DISTANCE + 1;\n-                var path = ty.path.split(\"::\");\n-\n-                if (ty.parent && ty.parent.name) {\n-                    path.push(ty.parent.name.toLowerCase());\n-                }\n-\n-                var length = path.length;\n-                var clength = contains.length;\n-                if (clength > length) {\n-                    return MAX_LEV_DISTANCE + 1;\n-                }\n-                for (var i = 0; i < length; ++i) {\n-                    if (i + clength > length) {\n-                        break;\n-                    }\n-                    var lev_total = 0;\n-                    var aborted = false;\n-                    for (var x = 0; x < clength; ++x) {\n-                        var lev = levenshtein(path[i + x], contains[x]);\n-                        if (lev > MAX_LEV_DISTANCE) {\n-                            aborted = true;\n-                            break;\n-                        }\n-                        lev_total += lev;\n-                    }\n-                    if (aborted === false) {\n-                        ret_lev = Math.min(ret_lev, Math.round(lev_total / clength));\n-                    }\n-                }\n-                return ret_lev;\n-            }\n-\n-            function typePassesFilter(filter, type) {\n-                // No filter\n-                if (filter <= NO_TYPE_FILTER) return true;\n-\n-                // Exact match\n-                if (filter === type) return true;\n-\n-                // Match related items\n-                var name = itemTypes[type];\n-                switch (itemTypes[filter]) {\n-                    case \"constant\":\n-                        return name === \"associatedconstant\";\n-                    case \"fn\":\n-                        return name === \"method\" || name === \"tymethod\";\n-                    case \"type\":\n-                        return name === \"primitive\" || name === \"associatedtype\";\n-                    case \"trait\":\n-                        return name === \"traitalias\";\n-                }\n-\n-                // No match\n-                return false;\n-            }\n-\n-            function createAliasFromItem(item) {\n-                return {\n-                    crate: item.crate,\n-                    name: item.name,\n-                    path: item.path,\n-                    desc: item.desc,\n-                    ty: item.ty,\n-                    parent: item.parent,\n-                    type: item.type,\n-                    is_alias: true,\n-                };\n-            }\n-\n-            function handleAliases(ret, query, filterCrates) {\n-                // We separate aliases and crate aliases because we want to have current crate\n-                // aliases to be before the others in the displayed results.\n-                var aliases = [];\n-                var crateAliases = [];\n-                if (filterCrates !== undefined) {\n-                    if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n-                        var query_aliases = ALIASES[filterCrates][query.search];\n-                        var len = query_aliases.length;\n-                        for (var i = 0; i < len; ++i) {\n-                            aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n-                        }\n-                    }\n-                } else {\n-                    Object.keys(ALIASES).forEach(function(crate) {\n-                        if (ALIASES[crate][query.search]) {\n-                            var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                            var query_aliases = ALIASES[crate][query.search];\n-                            var len = query_aliases.length;\n-                            for (var i = 0; i < len; ++i) {\n-                                pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n-                            }\n-                        }\n-                    });\n-                }\n-\n-                var sortFunc = function(aaa, bbb) {\n-                    if (aaa.path < bbb.path) {\n-                        return 1;\n-                    } else if (aaa.path === bbb.path) {\n-                        return 0;\n-                    }\n-                    return -1;\n-                };\n-                crateAliases.sort(sortFunc);\n-                aliases.sort(sortFunc);\n-\n-                var pushFunc = function(alias) {\n-                    alias.alias = query.raw;\n-                    var res = buildHrefAndPath(alias);\n-                    alias.displayPath = pathSplitter(res[0]);\n-                    alias.fullPath = alias.displayPath + alias.name;\n-                    alias.href = res[1];\n-\n-                    ret.others.unshift(alias);\n-                    if (ret.others.length > MAX_RESULTS) {\n-                        ret.others.pop();\n-                    }\n-                };\n-                onEach(aliases, pushFunc);\n-                onEach(crateAliases, pushFunc);\n-            }\n-\n-            // quoted values mean literal search\n-            var nSearchWords = searchWords.length;\n-            var i, it;\n-            var ty;\n-            var fullId;\n-            var returned;\n-            var in_args;\n-            var len;\n-            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n-                val.charAt(val.length - 1) === val.charAt(0))\n-            {\n-                val = extractGenerics(val.substr(1, val.length - 2));\n-                for (i = 0; i < nSearchWords; ++i) {\n-                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n-                        continue;\n-                    }\n-                    in_args = findArg(searchIndex[i], val, true, typeFilter);\n-                    returned = checkReturned(searchIndex[i], val, true, typeFilter);\n-                    ty = searchIndex[i];\n-                    fullId = ty.id;\n-\n-                    if (searchWords[i] === val.name\n-                        && typePassesFilter(typeFilter, searchIndex[i].ty)\n-                        && results[fullId] === undefined) {\n-                        results[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                    if (in_args === true && results_in_args[fullId] === undefined) {\n-                        results_in_args[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                    if (returned === true && results_returned[fullId] === undefined) {\n-                        results_returned[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                }\n-                query.inputs = [val];\n-                query.output = val;\n-                query.search = val;\n-            // searching by type\n-            } else if (val.search(\"->\") > -1) {\n-                var trimmer = function(s) { return s.trim(); };\n-                var parts = val.split(\"->\").map(trimmer);\n-                var input = parts[0];\n-                // sort inputs so that order does not matter\n-                var inputs = input.split(\",\").map(trimmer).sort();\n-                for (i = 0, len = inputs.length; i < len; ++i) {\n-                    inputs[i] = extractGenerics(inputs[i]);\n-                }\n-                var output = extractGenerics(parts[1]);\n-\n-                for (i = 0; i < nSearchWords; ++i) {\n-                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n-                        continue;\n-                    }\n-                    var type = searchIndex[i].type;\n-                    ty = searchIndex[i];\n-                    if (!type) {\n-                        continue;\n-                    }\n-                    fullId = ty.id;\n-\n-                    returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n-                    if (output.name === \"*\" || returned === true) {\n-                        in_args = false;\n-                        var is_module = false;\n-\n-                        if (input === \"*\") {\n-                            is_module = true;\n-                        } else {\n-                            var allFound = true;\n-                            for (it = 0, len = inputs.length; allFound === true && it < len; it++) {\n-                                allFound = checkType(type, inputs[it], true);\n-                            }\n-                            in_args = allFound;\n-                        }\n-                        if (in_args === true) {\n-                            results_in_args[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                        if (returned === true) {\n-                            results_returned[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                        if (is_module === true) {\n-                            results[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                    }\n-                }\n-                query.inputs = inputs.map(function(input) {\n-                    return input.name;\n-                });\n-                query.output = output.name;\n-            } else {\n-                query.inputs = [val];\n-                query.output = val;\n-                query.search = val;\n-                // gather matching search results up to a certain maximum\n-                val = val.replace(/\\_/g, \"\");\n-\n-                var valGenerics = extractGenerics(val);\n-\n-                var paths = valLower.split(\"::\");\n-                removeEmptyStringsFromArray(paths);\n-                val = paths[paths.length - 1];\n-                var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n-\n-                var lev, j;\n-                for (j = 0; j < nSearchWords; ++j) {\n-                    ty = searchIndex[j];\n-                    if (!ty || (filterCrates !== undefined && ty.crate !== filterCrates)) {\n-                        continue;\n-                    }\n-                    var lev_add = 0;\n-                    if (paths.length > 1) {\n-                        lev = checkPath(contains, paths[paths.length - 1], ty);\n-                        if (lev > MAX_LEV_DISTANCE) {\n-                            continue;\n-                        } else if (lev > 0) {\n-                            lev_add = lev / 10;\n-                        }\n-                    }\n-\n-                    returned = MAX_LEV_DISTANCE + 1;\n-                    in_args = MAX_LEV_DISTANCE + 1;\n-                    var index = -1;\n-                    // we want lev results to go lower than others\n-                    lev = MAX_LEV_DISTANCE + 1;\n-                    fullId = ty.id;\n-\n-                    if (searchWords[j].indexOf(split[i]) > -1 ||\n-                        searchWords[j].indexOf(val) > -1 ||\n-                        ty.normalizedName.indexOf(val) > -1)\n-                    {\n-                        // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n-                            index = ty.normalizedName.indexOf(val);\n-                        }\n-                    }\n-                    if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            lev = MAX_LEV_DISTANCE + 1;\n-                        } else {\n-                            lev += 1;\n-                        }\n-                    }\n-                    in_args = findArg(ty, valGenerics, false, typeFilter);\n-                    returned = checkReturned(ty, valGenerics, false, typeFilter);\n-\n-                    lev += lev_add;\n-                    if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n-                        if (val.length < 6) {\n-                            lev -= 1;\n-                        } else {\n-                            lev = 0;\n-                        }\n-                    }\n-                    if (in_args <= MAX_LEV_DISTANCE) {\n-                        if (results_in_args[fullId] === undefined) {\n-                            results_in_args[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: in_args,\n-                            };\n-                        }\n-                        results_in_args[fullId].lev =\n-                            Math.min(results_in_args[fullId].lev, in_args);\n-                    }\n-                    if (returned <= MAX_LEV_DISTANCE) {\n-                        if (results_returned[fullId] === undefined) {\n-                            results_returned[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: returned,\n-                            };\n-                        }\n-                        results_returned[fullId].lev =\n-                            Math.min(results_returned[fullId].lev, returned);\n-                    }\n-                    if (index !== -1 || lev <= MAX_LEV_DISTANCE) {\n-                        if (index !== -1 && paths.length < 2) {\n-                            lev = 0;\n-                        }\n-                        if (results[fullId] === undefined) {\n-                            results[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: lev,\n-                            };\n-                        }\n-                        results[fullId].lev = Math.min(results[fullId].lev, lev);\n-                    }\n-                }\n-            }\n-\n-            var ret = {\n-                \"in_args\": sortResults(results_in_args, true),\n-                \"returned\": sortResults(results_returned, true),\n-                \"others\": sortResults(results),\n-            };\n-            handleAliases(ret, query, filterCrates);\n-            return ret;\n-        }\n-\n-        /**\n-         * Validate performs the following boolean logic. For example:\n-         * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n-         * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n-         * (name || path )\n-         *\n-         * This could be written functionally, but I wanted to minimise\n-         * functions on stack.\n-         *\n-         * @param  {[string]} name   [The name of the result]\n-         * @param  {[string]} path   [The path of the result]\n-         * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n-         * @param  {[object]} parent [The parent of the result]\n-         * @return {[boolean]}       [Whether the result is valid or not]\n-         */\n-        function validateResult(name, path, keys, parent) {\n-            for (var i = 0, len = keys.length; i < len; ++i) {\n-                // each check is for validation so we negate the conditions and invalidate\n-                if (!(\n-                    // check for an exact name match\n-                    name.indexOf(keys[i]) > -1 ||\n-                    // then an exact path match\n-                    path.indexOf(keys[i]) > -1 ||\n-                    // next if there is a parent, check for exact parent match\n-                    (parent !== undefined && parent.name !== undefined &&\n-                        parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n-                    // lastly check to see if the name was a levenshtein match\n-                    levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        function getQuery(raw) {\n-            var matches, type, query;\n-            query = raw;\n-\n-            matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n-            if (matches) {\n-                type = matches[1].replace(/^const$/, \"constant\");\n-                query = query.substring(matches[0].length);\n-            }\n-\n-            return {\n-                raw: raw,\n-                query: query,\n-                type: type,\n-                id: query + type\n-            };\n-        }\n-\n-        function initSearchNav() {\n-            var hoverTimeout;\n-\n-            var click_func = function(e) {\n-                var el = e.target;\n-                // to retrieve the real \"owner\" of the event.\n-                while (el.tagName !== \"TR\") {\n-                    el = el.parentNode;\n-                }\n-                var dst = e.target.getElementsByTagName(\"a\");\n-                if (dst.length < 1) {\n-                    return;\n-                }\n-                dst = dst[0];\n-                if (window.location.pathname === dst.pathname) {\n-                    hideSearchResults();\n-                    document.location.href = dst.href;\n-                }\n-            };\n-            var mouseover_func = function(e) {\n-                if (mouseMovedAfterSearch) {\n-                    var el = e.target;\n-                    // to retrieve the real \"owner\" of the event.\n-                    while (el.tagName !== \"TR\") {\n-                        el = el.parentNode;\n-                    }\n-                    clearTimeout(hoverTimeout);\n-                    hoverTimeout = setTimeout(function() {\n-                        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                                removeClass(i_e, \"highlighted\");\n-                            });\n-                        });\n-                        addClass(el, \"highlighted\");\n-                    }, 20);\n-                }\n-            };\n-            onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                    i_e.onclick = click_func;\n-                    i_e.onmouseover = mouseover_func;\n-                });\n-            });\n-\n-            search_input.onkeydown = function(e) {\n-                // \"actives\" references the currently highlighted item in each search tab.\n-                // Each array in \"actives\" represents a tab.\n-                var actives = [[], [], []];\n-                // \"current\" is used to know which tab we're looking into.\n-                var current = 0;\n-                onEachLazy(document.getElementById(\"results\").childNodes, function(e) {\n-                    onEachLazy(e.getElementsByClassName(\"highlighted\"), function(h_e) {\n-                        actives[current].push(h_e);\n-                    });\n-                    current += 1;\n-                });\n-\n-                if (e.which === 38) { // up\n-                    if (e.ctrlKey) { // Going through result tabs.\n-                        printTab(currentTab > 0 ? currentTab - 1 : 2);\n-                    } else {\n-                        if (!actives[currentTab].length ||\n-                            !actives[currentTab][0].previousElementSibling) {\n-                            return;\n-                        }\n-                        addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n-                        removeClass(actives[currentTab][0], \"highlighted\");\n-                    }\n-                    e.preventDefault();\n-                } else if (e.which === 40) { // down\n-                    if (e.ctrlKey) { // Going through result tabs.\n-                        printTab(currentTab > 1 ? 0 : currentTab + 1);\n-                    } else if (!actives[currentTab].length) {\n-                        var results = document.getElementById(\"results\").childNodes;\n-                        if (results.length > 0) {\n-                            var res = results[currentTab].getElementsByClassName(\"result\");\n-                            if (res.length > 0) {\n-                                addClass(res[0], \"highlighted\");\n-                            }\n-                        }\n-                    } else if (actives[currentTab][0].nextElementSibling) {\n-                        addClass(actives[currentTab][0].nextElementSibling, \"highlighted\");\n-                        removeClass(actives[currentTab][0], \"highlighted\");\n-                    }\n-                    e.preventDefault();\n-                } else if (e.which === 13) { // return\n-                    if (actives[currentTab].length) {\n-                        document.location.href =\n-                            actives[currentTab][0].getElementsByTagName(\"a\")[0].href;\n-                    }\n-                } else if (e.which === 16) { // shift\n-                    // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n-                } else if (actives[currentTab].length > 0) {\n-                    removeClass(actives[currentTab][0], \"highlighted\");\n-                }\n-            };\n-        }\n-\n-        function buildHrefAndPath(item) {\n-            var displayPath;\n-            var href;\n-            var type = itemTypes[item.ty];\n-            var name = item.name;\n-            var path = item.path;\n-\n-            if (type === \"mod\") {\n-                displayPath = path + \"::\";\n-                href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n-                       name + \"/index.html\";\n-            } else if (type === \"primitive\" || type === \"keyword\") {\n-                displayPath = \"\";\n-                href = window.rootPath + path.replace(/::/g, \"/\") +\n-                       \"/\" + type + \".\" + name + \".html\";\n-            } else if (type === \"externcrate\") {\n-                displayPath = \"\";\n-                href = window.rootPath + name + \"/index.html\";\n-            } else if (item.parent !== undefined) {\n-                var myparent = item.parent;\n-                var anchor = \"#\" + type + \".\" + name;\n-                var parentType = itemTypes[myparent.ty];\n-                var pageType = parentType;\n-                var pageName = myparent.name;\n-\n-                if (parentType === \"primitive\") {\n-                    displayPath = myparent.name + \"::\";\n-                } else if (type === \"structfield\" && parentType === \"variant\") {\n-                    // Structfields belonging to variants are special: the\n-                    // final path element is the enum name.\n-                    var enumNameIdx = item.path.lastIndexOf(\"::\");\n-                    var enumName = item.path.substr(enumNameIdx + 2);\n-                    path = item.path.substr(0, enumNameIdx);\n-                    displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n-                    anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n-                    pageType = \"enum\";\n-                    pageName = enumName;\n-                } else {\n-                    displayPath = path + \"::\" + myparent.name + \"::\";\n-                }\n-                href = window.rootPath + path.replace(/::/g, \"/\") +\n-                       \"/\" + pageType +\n-                       \".\" + pageName +\n-                       \".html\" + anchor;\n-            } else {\n-                displayPath = item.path + \"::\";\n-                href = window.rootPath + item.path.replace(/::/g, \"/\") +\n-                       \"/\" + type + \".\" + name + \".html\";\n-            }\n-            return [displayPath, href];\n-        }\n-\n-        function escape(content) {\n-            var h1 = document.createElement(\"h1\");\n-            h1.textContent = content;\n-            return h1.innerHTML;\n-        }\n-\n-        function pathSplitter(path) {\n-            var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n-            if (tmp.endsWith(\"<span>\")) {\n-                return tmp.slice(0, tmp.length - 6);\n-            }\n-            return tmp;\n-        }\n-\n-        function addTab(array, query, display) {\n-            var extraStyle = \"\";\n-            if (display === false) {\n-                extraStyle = \" style=\\\"display: none;\\\"\";\n-            }\n-\n-            var output = \"\";\n-            var duplicates = {};\n-            var length = 0;\n-            if (array.length > 0) {\n-                output = \"<table class=\\\"search-results\\\"\" + extraStyle + \">\";\n-\n-                array.forEach(function(item) {\n-                    var name, type;\n-\n-                    name = item.name;\n-                    type = itemTypes[item.ty];\n-\n-                    if (item.is_alias !== true) {\n-                        if (duplicates[item.fullPath]) {\n-                            return;\n-                        }\n-                        duplicates[item.fullPath] = true;\n-                    }\n-                    length += 1;\n-\n-                    output += \"<tr class=\\\"\" + type + \" result\\\"><td>\" +\n-                              \"<a href=\\\"\" + item.href + \"\\\">\" +\n-                              (item.is_alias === true ?\n-                               (\"<span class=\\\"alias\\\"><b>\" + item.alias + \" </b></span><span \" +\n-                                  \"class=\\\"grey\\\"><i>&nbsp;- see&nbsp;</i></span>\") : \"\") +\n-                              item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" +\n-                              name + \"</span></a></td><td>\" +\n-                              \"<a href=\\\"\" + item.href + \"\\\">\" +\n-                              \"<span class=\\\"desc\\\">\" + item.desc +\n-                              \"&nbsp;</span></a></td></tr>\";\n-                });\n-                output += \"</table>\";\n-            } else {\n-                output = \"<div class=\\\"search-failed\\\"\" + extraStyle + \">No results :(<br/>\" +\n-                    \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n-                    encodeURIComponent(\"rust \" + query.query) +\n-                    \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n-                    \"Or try looking in one of these:<ul><li>The <a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n-                    \" for technical details about the language.</li><li><a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/rust-by-example/index.html\\\">Rust By \" +\n-                    \"Example</a> for expository code examples.</a></li><li>The <a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/book/index.html\\\">Rust Book</a> for \" +\n-                    \"introductions to language features and the language itself.</li><li><a \" +\n-                    \"href=\\\"https://docs.rs\\\">Docs.rs</a> for documentation of crates released on\" +\n-                    \" <a href=\\\"https://crates.io/\\\">crates.io</a>.</li></ul></div>\";\n-            }\n-            return [output, length];\n-        }\n-\n-        function makeTabHeader(tabNb, text, nbElems) {\n-            if (currentTab === tabNb) {\n-                return \"<button class=\\\"selected\\\">\" + text +\n-                       \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n-            }\n-            return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n-        }\n-\n-        function showResults(results) {\n-            var search = getSearchElement();\n-            if (results.others.length === 1\n-                && getSettingValue(\"go-to-only-result\") === \"true\"\n-                // By default, the search DOM element is \"empty\" (meaning it has no children not\n-                // text content). Once a search has been run, it won't be empty, even if you press\n-                // ESC or empty the search input (which also \"cancels\" the search).\n-                && (!search.firstChild || search.firstChild.innerText !== getSearchLoadingText()))\n-            {\n-                var elem = document.createElement(\"a\");\n-                elem.href = results.others[0].href;\n-                elem.style.display = \"none\";\n-                // For firefox, we need the element to be in the DOM so it can be clicked.\n-                document.body.appendChild(elem);\n-                elem.click();\n-                return;\n-            }\n-            var query = getQuery(search_input.value);\n-\n-            currentResults = query.id;\n-\n-            var ret_others = addTab(results.others, query);\n-            var ret_in_args = addTab(results.in_args, query, false);\n-            var ret_returned = addTab(results.returned, query, false);\n-\n-            // Navigate to the relevant tab if the current tab is empty, like in case users search\n-            // for \"-> String\". If they had selected another tab previously, they have to click on\n-            // it again.\n-            if ((currentTab === 0 && ret_others[1] === 0) ||\n-                    (currentTab === 1 && ret_in_args[1] === 0) ||\n-                    (currentTab === 2 && ret_returned[1] === 0)) {\n-                if (ret_others[1] !== 0) {\n-                    currentTab = 0;\n-                } else if (ret_in_args[1] !== 0) {\n-                    currentTab = 1;\n-                } else if (ret_returned[1] !== 0) {\n-                    currentTab = 2;\n-                }\n-            }\n-\n-            var output = \"<h1>Results for \" + escape(query.query) +\n-                (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n-                \"<div id=\\\"titles\\\">\" +\n-                makeTabHeader(0, \"In Names\", ret_others[1]) +\n-                makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n-                makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n-                \"</div><div id=\\\"results\\\">\" +\n-                ret_others[0] + ret_in_args[0] + ret_returned[0] + \"</div>\";\n-\n-            search.innerHTML = output;\n-            showSearchResults(search);\n-            initSearchNav();\n-            var elems = document.getElementById(\"titles\").childNodes;\n-            elems[0].onclick = function() { printTab(0); };\n-            elems[1].onclick = function() { printTab(1); };\n-            elems[2].onclick = function() { printTab(2); };\n-            printTab(currentTab);\n-        }\n-\n-        function execSearch(query, searchWords, filterCrates) {\n-            function getSmallest(arrays, positions, notDuplicates) {\n-                var start = null;\n-\n-                for (var it = 0, len = positions.length; it < len; ++it) {\n-                    if (arrays[it].length > positions[it] &&\n-                        (start === null || start > arrays[it][positions[it]].lev) &&\n-                        !notDuplicates[arrays[it][positions[it]].fullPath]) {\n-                        start = arrays[it][positions[it]].lev;\n-                    }\n-                }\n-                return start;\n-            }\n-\n-            function mergeArrays(arrays) {\n-                var ret = [];\n-                var positions = [];\n-                var notDuplicates = {};\n-\n-                for (var x = 0, arrays_len = arrays.length; x < arrays_len; ++x) {\n-                    positions.push(0);\n-                }\n-                while (ret.length < MAX_RESULTS) {\n-                    var smallest = getSmallest(arrays, positions, notDuplicates);\n-\n-                    if (smallest === null) {\n-                        break;\n-                    }\n-                    for (x = 0; x < arrays_len && ret.length < MAX_RESULTS; ++x) {\n-                        if (arrays[x].length > positions[x] &&\n-                                arrays[x][positions[x]].lev === smallest &&\n-                                !notDuplicates[arrays[x][positions[x]].fullPath]) {\n-                            ret.push(arrays[x][positions[x]]);\n-                            notDuplicates[arrays[x][positions[x]].fullPath] = true;\n-                            positions[x] += 1;\n-                        }\n-                    }\n-                }\n-                return ret;\n-            }\n-\n-            var queries = query.raw.split(\",\");\n-            var results = {\n-                \"in_args\": [],\n-                \"returned\": [],\n-                \"others\": [],\n-            };\n-\n-            for (var i = 0, len = queries.length; i < len; ++i) {\n-                query = queries[i].trim();\n-                if (query.length !== 0) {\n-                    var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n-\n-                    results.in_args.push(tmp.in_args);\n-                    results.returned.push(tmp.returned);\n-                    results.others.push(tmp.others);\n-                }\n-            }\n-            if (queries.length > 1) {\n-                return {\n-                    \"in_args\": mergeArrays(results.in_args),\n-                    \"returned\": mergeArrays(results.returned),\n-                    \"others\": mergeArrays(results.others),\n-                };\n-            }\n-            return {\n-                \"in_args\": results.in_args[0],\n-                \"returned\": results.returned[0],\n-                \"others\": results.others[0],\n-            };\n-        }\n-\n-        function getFilterCrates() {\n-            var elem = document.getElementById(\"crate-search\");\n-\n-            if (elem && elem.value !== \"All crates\" && hasOwnProperty(rawSearchIndex, elem.value)) {\n-                return elem.value;\n-            }\n-            return undefined;\n-        }\n-\n-        function search(e, forced) {\n-            var params = getQueryStringParams();\n-            var query = getQuery(search_input.value.trim());\n-\n-            if (e) {\n-                e.preventDefault();\n-            }\n-\n-            if (query.query.length === 0) {\n-                return;\n-            }\n-            if (forced !== true && query.id === currentResults) {\n-                if (query.query.length > 0) {\n-                    putBackSearch(search_input);\n-                }\n-                return;\n-            }\n-\n-            // Update document title to maintain a meaningful browser history\n-            searchTitle = \"Results for \" + query.query + \" - Rust\";\n-\n-            // Because searching is incremental by character, only the most\n-            // recent search query is added to the browser history.\n-            if (browserSupportsHistoryApi()) {\n-                var newURL = getNakedUrl() + \"?search=\" + encodeURIComponent(query.raw) +\n-                    window.location.hash;\n-                if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", newURL);\n-                } else {\n-                    history.replaceState(query, \"\", newURL);\n-                }\n-            }\n-\n-            var filterCrates = getFilterCrates();\n-            showResults(execSearch(query, index, filterCrates));\n-        }\n-\n-        function buildIndex(rawSearchIndex) {\n-            searchIndex = [];\n-            var searchWords = [];\n-            var i, word;\n-            var currentIndex = 0;\n-            var id = 0;\n-\n-            for (var crate in rawSearchIndex) {\n-                if (!hasOwnProperty(rawSearchIndex, crate)) { continue; }\n-\n-                var crateSize = 0;\n-\n-                searchWords.push(crate);\n-                var normalizedName = crate.indexOf(\"_\") === -1\n-                    ? crate\n-                    : crate.replace(/_/g, \"\");\n-                // This object should have exactly the same set of fields as the \"row\"\n-                // object defined below. Your JavaScript runtime will thank you.\n-                // https://mathiasbynens.be/notes/shapes-ics\n-                var crateRow = {\n-                    crate: crate,\n-                    ty: 1, // == ExternCrate\n-                    name: crate,\n-                    path: \"\",\n-                    desc: rawSearchIndex[crate].doc,\n-                    parent: undefined,\n-                    type: null,\n-                    id: id,\n-                    normalizedName: normalizedName,\n-                };\n-                id += 1;\n-                searchIndex.push(crateRow);\n-                currentIndex += 1;\n-\n-                // an array of (Number) item types\n-                var itemTypes = rawSearchIndex[crate].t;\n-                // an array of (String) item names\n-                var itemNames = rawSearchIndex[crate].n;\n-                // an array of (String) full paths (or empty string for previous path)\n-                var itemPaths = rawSearchIndex[crate].q;\n-                // an array of (String) descriptions\n-                var itemDescs = rawSearchIndex[crate].d;\n-                // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n-                var itemParentIdxs = rawSearchIndex[crate].i;\n-                // an array of (Object | null) the type of the function, if any\n-                var itemFunctionSearchTypes = rawSearchIndex[crate].f;\n-                // an array of [(Number) item type,\n-                //              (String) name]\n-                var paths = rawSearchIndex[crate].p;\n-                // a array of [(String) alias name\n-                //             [Number] index to items]\n-                var aliases = rawSearchIndex[crate].a;\n-\n-                // convert `rawPaths` entries into object form\n-                var len = paths.length;\n-                for (i = 0; i < len; ++i) {\n-                    paths[i] = {ty: paths[i][0], name: paths[i][1]};\n-                }\n-\n-                // convert `item*` into an object form, and construct word indices.\n-                //\n-                // before any analysis is performed lets gather the search terms to\n-                // search against apart from the rest of the data.  This is a quick\n-                // operation that is cached for the life of the page state so that\n-                // all other search operations have access to this cached data for\n-                // faster analysis operations\n-                len = itemTypes.length;\n-                var lastPath = \"\";\n-                for (i = 0; i < len; ++i) {\n-                    // This object should have exactly the same set of fields as the \"crateRow\"\n-                    // object defined above.\n-                    if (typeof itemNames[i] === \"string\") {\n-                        word = itemNames[i].toLowerCase();\n-                        searchWords.push(word);\n-                    } else {\n-                        word = \"\";\n-                        searchWords.push(\"\");\n-                    }\n-                    var normalizedName = word.indexOf(\"_\") === -1\n-                        ? word\n-                        : word.replace(/_/g, \"\");\n-                    var row = {\n-                        crate: crate,\n-                        ty: itemTypes[i],\n-                        name: itemNames[i],\n-                        path: itemPaths[i] ? itemPaths[i] : lastPath,\n-                        desc: itemDescs[i],\n-                        parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n-                        type: itemFunctionSearchTypes[i],\n-                        id: id,\n-                        normalizedName: normalizedName,\n-                    };\n-                    id += 1;\n-                    searchIndex.push(row);\n-                    lastPath = row.path;\n-                    crateSize += 1;\n-                }\n-\n-                if (aliases) {\n-                    ALIASES[crate] = {};\n-                    var j, local_aliases;\n-                    for (var alias_name in aliases) {\n-                        if (!aliases.hasOwnProperty(alias_name)) { continue; }\n-\n-                        if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n-                            ALIASES[crate][alias_name] = [];\n-                        }\n-                        local_aliases = aliases[alias_name];\n-                        for (j = 0, len = local_aliases.length; j < len; ++j) {\n-                            ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n-                        }\n-                    }\n-                }\n-                currentIndex += crateSize;\n-            }\n-            return searchWords;\n-        }\n-\n-        function registerSearchEvents() {\n-            var searchAfter500ms = function() {\n-                clearInputTimeout();\n-                if (search_input.value.length === 0) {\n-                    if (browserSupportsHistoryApi()) {\n-                        history.replaceState(\"\", window.currentCrate + \" - Rust\",\n-                            getNakedUrl() + window.location.hash);\n-                    }\n-                    hideSearchResults();\n-                } else {\n-                    searchTimeout = setTimeout(search, 500);\n-                }\n-            };\n-            search_input.onkeyup = searchAfter500ms;\n-            search_input.oninput = searchAfter500ms;\n-            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n-                e.preventDefault();\n-                clearInputTimeout();\n-                search();\n-            };\n-            search_input.onchange = function(e) {\n-                if (e.target !== document.activeElement) {\n-                    // To prevent doing anything when it's from a blur event.\n-                    return;\n-                }\n-                // Do NOT e.preventDefault() here. It will prevent pasting.\n-                clearInputTimeout();\n-                // zero-timeout necessary here because at the time of event handler execution the\n-                // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n-                // change, though.\n-                setTimeout(search, 0);\n-            };\n-            search_input.onpaste = search_input.onchange;\n-\n-            var selectCrate = document.getElementById(\"crate-search\");\n-            if (selectCrate) {\n-                selectCrate.onchange = function() {\n-                    updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n-                    search(undefined, true);\n-                };\n-            }\n-\n-            // Push and pop states are used to add search results to the browser\n-            // history.\n-            if (browserSupportsHistoryApi()) {\n-                // Store the previous <title> so we can revert back to it later.\n-                var previousTitle = document.title;\n-\n-                window.addEventListener(\"popstate\", function(e) {\n-                    var params = getQueryStringParams();\n-                    // Revert to the previous title manually since the History\n-                    // API ignores the title parameter.\n-                    document.title = previousTitle;\n-                    // When browsing forward to search results the previous\n-                    // search will be repeated, so the currentResults are\n-                    // cleared to ensure the search is successful.\n-                    currentResults = null;\n-                    // Synchronize search bar with query string state and\n-                    // perform the search. This will empty the bar if there's\n-                    // nothing there, which lets you really go back to a\n-                    // previous state with nothing in the bar.\n-                    if (params.search && params.search.length > 0) {\n-                        search_input.value = params.search;\n-                        // Some browsers fire \"onpopstate\" for every page load\n-                        // (Chrome), while others fire the event only when actually\n-                        // popping a state (Firefox), which is why search() is\n-                        // called both here and at the end of the startSearch()\n-                        // function.\n-                        search(e);\n-                    } else {\n-                        search_input.value = \"\";\n-                        // When browsing back from search results the main page\n-                        // visibility must be reset.\n-                        hideSearchResults();\n-                    }\n-                });\n-            }\n-\n-            // This is required in firefox to avoid this problem: Navigating to a search result\n-            // with the keyboard, hitting enter, and then hitting back would take you back to\n-            // the doc page, rather than the search that should overlay it.\n-            // This was an interaction between the back-forward cache and our handlers\n-            // that try to sync state between the URL and the search input. To work around it,\n-            // do a small amount of re-init on page show.\n-            window.onpageshow = function(){\n-                var qSearch = getQueryStringParams().search;\n-                if (search_input.value === \"\" && qSearch) {\n-                    search_input.value = qSearch;\n-                }\n-                search();\n-            };\n-        }\n-\n-        index = buildIndex(rawSearchIndex);\n-        registerSearchEvents();\n-        // If there's a search term in the URL, execute the search now.\n-        if (getQueryStringParams().search) {\n-            search();\n-        }\n-    };\n-\n     function addSidebarCrates(crates) {\n         // Draw a convenient sidebar of known crates if we have a listing\n         if (window.rootPath === \"../\" || window.rootPath === \"./\") {\n@@ -2216,6 +804,9 @@ function hideThemeButtonState() {\n         block(\"foreigntype\", \"Foreign Types\");\n         block(\"keyword\", \"Keywords\");\n         block(\"traitalias\", \"Trait Aliases\");\n+\n+        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n+        addSidebarCrates(window.ALL_CRATES);\n     };\n \n     window.register_implementors = function(imp) {\n@@ -2813,60 +1404,6 @@ function hideThemeButtonState() {\n         };\n     });\n \n-    // In the search display, allows to switch between tabs.\n-    function printTab(nb) {\n-        if (nb === 0 || nb === 1 || nb === 2) {\n-            currentTab = nb;\n-        }\n-        var nb_copy = nb;\n-        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n-            if (nb_copy === 0) {\n-                addClass(elem, \"selected\");\n-            } else {\n-                removeClass(elem, \"selected\");\n-            }\n-            nb_copy -= 1;\n-        });\n-        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n-            if (nb === 0) {\n-                elem.style.display = \"\";\n-            } else {\n-                elem.style.display = \"none\";\n-            }\n-            nb -= 1;\n-        });\n-    }\n-\n-    function putBackSearch(search_input) {\n-        var search = getSearchElement();\n-        if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n-            showSearchResults(search);\n-            if (browserSupportsHistoryApi()) {\n-                var extra = \"?search=\" + encodeURIComponent(search_input.value);\n-                history.replaceState(search_input.value, \"\",\n-                    getNakedUrl() + extra + window.location.hash);\n-            }\n-            document.title = searchTitle;\n-        }\n-    }\n-\n-    function getSearchLoadingText() {\n-        return \"Loading search results...\";\n-    }\n-\n-    if (search_input) {\n-        search_input.onfocus = function() {\n-            putBackSearch(this);\n-        };\n-    }\n-\n-    var params = getQueryStringParams();\n-    if (params && params.search) {\n-        var search = getSearchElement();\n-        search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">\" + getSearchLoadingText() + \"</h3>\";\n-        showSearchResults(search);\n-    }\n-\n     var sidebar_menu = document.getElementsByClassName(\"sidebar-menu\")[0];\n     if (sidebar_menu) {\n         sidebar_menu.onclick = function() {\n@@ -2899,30 +1436,6 @@ function hideThemeButtonState() {\n         });\n     }\n \n-    function addSearchOptions(crates) {\n-        var elem = document.getElementById(\"crate-search\");\n-\n-        if (!elem) {\n-            return;\n-        }\n-        var savedCrate = getSettingValue(\"saved-filter-crate\");\n-        for (var i = 0, len = crates.length; i < len; ++i) {\n-            var option = document.createElement(\"option\");\n-            option.value = crates[i];\n-            option.innerText = crates[i];\n-            elem.appendChild(option);\n-            // Set the crate filter from saved storage, if the current page has the saved crate\n-            // filter.\n-            //\n-            // If not, ignore the crate filter -- we want to support filtering for crates on sites\n-            // like doc.rust-lang.org where the crates may differ from page to page while on the\n-            // same domain.\n-            if (crates[i] === savedCrate) {\n-                elem.value = savedCrate;\n-            }\n-        }\n-    };\n-\n     function buildHelperPopup() {\n         var popup = document.createElement(\"aside\");\n         addClass(popup, \"hidden\");\n@@ -2980,55 +1493,14 @@ function hideThemeButtonState() {\n         container.appendChild(div_infos);\n \n         popup.appendChild(container);\n-        insertAfter(popup, getSearchElement());\n+        insertAfter(popup, searchState.outputElement());\n         // So that it's only built once and then it'll do nothing when called!\n         buildHelperPopup = function() {};\n     }\n \n-    function loadScript(url) {\n-        var script = document.createElement('script');\n-        script.src = url;\n-        document.head.append(script);\n-    }\n-\n-    function setupSearchLoader() {\n-        var searchLoaded = false;\n-        function loadSearch() {\n-            if (!searchLoaded) {\n-                searchLoaded = true;\n-                loadScript(window.searchJS);\n-            }\n-        }\n-\n-        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n-        addSearchOptions(window.ALL_CRATES);\n-        addSidebarCrates(window.ALL_CRATES);\n-\n-        search_input.addEventListener(\"focus\", function() {\n-            search_input.origPlaceholder = search_input.placeholder;\n-            search_input.placeholder = \"Type your search here.\";\n-            loadSearch();\n-        });\n-        search_input.addEventListener(\"blur\", function() {\n-            search_input.placeholder = search_input.origPlaceholder;\n-        });\n-        search_input.removeAttribute('disabled');\n-\n-        var crateSearchDropDown = document.getElementById(\"crate-search\");\n-        // `crateSearchDropDown` can be null in case there is only crate because in that case, the\n-        // crate filter dropdown is removed.\n-        if (crateSearchDropDown) {\n-            crateSearchDropDown.addEventListener(\"focus\", loadSearch);\n-        }\n-        var params = getQueryStringParams();\n-        if (params.search !== undefined) {\n-            loadSearch();\n-        }\n-    }\n-\n     onHashChange(null);\n     window.onhashchange = onHashChange;\n-    setupSearchLoader();\n+    searchState.setup();\n }());\n \n function copy_path(but) {"}, {"sha": "538c811c710971b2d840a631ba06a36026d41ace", "filename": "src/librustdoc/html/static/search.js", "status": "added", "additions": 1512, "deletions": 0, "changes": 1512, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -0,0 +1,1512 @@\n+(function() {\n+// This mapping table should match the discriminants of\n+// `rustdoc::html::item_type::ItemType` type in Rust.\n+var itemTypes = [\"mod\",\n+                    \"externcrate\",\n+                    \"import\",\n+                    \"struct\",\n+                    \"enum\",\n+                    \"fn\",\n+                    \"type\",\n+                    \"static\",\n+                    \"trait\",\n+                    \"impl\",\n+                    \"tymethod\",\n+                    \"method\",\n+                    \"structfield\",\n+                    \"variant\",\n+                    \"macro\",\n+                    \"primitive\",\n+                    \"associatedtype\",\n+                    \"constant\",\n+                    \"associatedconstant\",\n+                    \"union\",\n+                    \"foreigntype\",\n+                    \"keyword\",\n+                    \"existential\",\n+                    \"attr\",\n+                    \"derive\",\n+                    \"traitalias\"];\n+\n+// used for special search precedence\n+var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n+var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n+\n+// In the search display, allows to switch between tabs.\n+function printTab(nb) {\n+    if (nb === 0 || nb === 1 || nb === 2) {\n+        searchState.currentTab = nb;\n+    }\n+    var nb_copy = nb;\n+    onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n+        if (nb_copy === 0) {\n+            addClass(elem, \"selected\");\n+        } else {\n+            removeClass(elem, \"selected\");\n+        }\n+        nb_copy -= 1;\n+    });\n+    onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n+        if (nb === 0) {\n+            elem.style.display = \"\";\n+        } else {\n+            elem.style.display = \"none\";\n+        }\n+        nb -= 1;\n+    });\n+}\n+\n+function removeEmptyStringsFromArray(x) {\n+    for (var i = 0, len = x.length; i < len; ++i) {\n+        if (x[i] === \"\") {\n+            x.splice(i, 1);\n+            i -= 1;\n+        }\n+    }\n+}\n+\n+/**\n+ * A function to compute the Levenshtein distance between two strings\n+ * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n+ * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n+ * This code is an unmodified version of the code written by Marco de Wit\n+ * and was found at http://stackoverflow.com/a/18514751/745719\n+ */\n+var levenshtein_row2 = [];\n+function levenshtein(s1, s2) {\n+    if (s1 === s2) {\n+        return 0;\n+    }\n+    var s1_len = s1.length, s2_len = s2.length;\n+    if (s1_len && s2_len) {\n+        var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n+        while (i1 < s1_len) {\n+            row[i1] = ++i1;\n+        }\n+        while (i2 < s2_len) {\n+            c2 = s2.charCodeAt(i2);\n+            a = i2;\n+            ++i2;\n+            b = i2;\n+            for (i1 = 0; i1 < s1_len; ++i1) {\n+                c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n+                a = row[i1];\n+                b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n+                row[i1] = b;\n+            }\n+        }\n+        return b;\n+    }\n+    return s1_len + s2_len;\n+}\n+\n+window.initSearch = function(rawSearchIndex) {\n+    var MAX_LEV_DISTANCE = 3;\n+    var MAX_RESULTS = 200;\n+    var GENERICS_DATA = 1;\n+    var NAME = 0;\n+    var INPUTS_DATA = 0;\n+    var OUTPUT_DATA = 1;\n+    var NO_TYPE_FILTER = -1;\n+    var currentResults, index, searchIndex;\n+    var ALIASES = {};\n+    var params = searchState.getQueryStringParams();\n+\n+    // Populate search bar with query string search term when provided,\n+    // but only if the input bar is empty. This avoid the obnoxious issue\n+    // where you start trying to do a search, and the index loads, and\n+    // suddenly your search is gone!\n+    if (searchState.input.value === \"\") {\n+        searchState.input.value = params.search || \"\";\n+    }\n+\n+    /**\n+     * Executes the query and builds an index of results\n+     * @param  {[Object]} query      [The user query]\n+     * @param  {[type]} searchWords  [The list of search words to query\n+     *                                against]\n+     * @param  {[type]} filterCrates [Crate to search in if defined]\n+     * @return {[type]}              [A search index of results]\n+     */\n+    function execQuery(query, searchWords, filterCrates) {\n+        function itemTypeFromName(typename) {\n+            for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+                if (itemTypes[i] === typename) {\n+                    return i;\n+                }\n+            }\n+            return NO_TYPE_FILTER;\n+        }\n+\n+        var valLower = query.query.toLowerCase(),\n+            val = valLower,\n+            typeFilter = itemTypeFromName(query.type),\n+            results = {}, results_in_args = {}, results_returned = {},\n+            split = valLower.split(\"::\");\n+\n+        removeEmptyStringsFromArray(split);\n+\n+        function transformResults(results, isType) {\n+            var out = [];\n+            for (var i = 0, len = results.length; i < len; ++i) {\n+                if (results[i].id > -1) {\n+                    var obj = searchIndex[results[i].id];\n+                    obj.lev = results[i].lev;\n+                    if (isType !== true || obj.type) {\n+                        var res = buildHrefAndPath(obj);\n+                        obj.displayPath = pathSplitter(res[0]);\n+                        obj.fullPath = obj.displayPath + obj.name;\n+                        // To be sure than it some items aren't considered as duplicate.\n+                        obj.fullPath += \"|\" + obj.ty;\n+                        obj.href = res[1];\n+                        out.push(obj);\n+                        if (out.length >= MAX_RESULTS) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            return out;\n+        }\n+\n+        function sortResults(results, isType) {\n+            var ar = [];\n+            for (var entry in results) {\n+                if (hasOwnProperty(results, entry)) {\n+                    ar.push(results[entry]);\n+                }\n+            }\n+            results = ar;\n+            var i, len, result;\n+            for (i = 0, len = results.length; i < len; ++i) {\n+                result = results[i];\n+                result.word = searchWords[result.id];\n+                result.item = searchIndex[result.id] || {};\n+            }\n+            // if there are no results then return to default and fail\n+            if (results.length === 0) {\n+                return [];\n+            }\n+\n+            results.sort(function(aaa, bbb) {\n+                var a, b;\n+\n+                // sort by exact match with regard to the last word (mismatch goes later)\n+                a = (aaa.word !== val);\n+                b = (bbb.word !== val);\n+                if (a !== b) { return a - b; }\n+\n+                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // (less changes required to match means higher rankings)\n+                a = (aaa.lev);\n+                b = (bbb.lev);\n+                if (a !== b) { return a - b; }\n+\n+                // sort by crate (non-current crate goes later)\n+                a = (aaa.item.crate !== window.currentCrate);\n+                b = (bbb.item.crate !== window.currentCrate);\n+                if (a !== b) { return a - b; }\n+\n+                // sort by item name length (longer goes later)\n+                a = aaa.word.length;\n+                b = bbb.word.length;\n+                if (a !== b) { return a - b; }\n+\n+                // sort by item name (lexicographically larger goes later)\n+                a = aaa.word;\n+                b = bbb.word;\n+                if (a !== b) { return (a > b ? +1 : -1); }\n+\n+                // sort by index of keyword in item name (no literal occurrence goes later)\n+                a = (aaa.index < 0);\n+                b = (bbb.index < 0);\n+                if (a !== b) { return a - b; }\n+                // (later literal occurrence, if any, goes later)\n+                a = aaa.index;\n+                b = bbb.index;\n+                if (a !== b) { return a - b; }\n+\n+                // special precedence for primitive and keyword pages\n+                if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n+                    (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n+                    return -1;\n+                }\n+                if ((bbb.item.ty === TY_PRIMITIVE && aaa.item.ty !== TY_PRIMITIVE) ||\n+                    (bbb.item.ty === TY_KEYWORD && aaa.item.ty !== TY_KEYWORD)) {\n+                    return 1;\n+                }\n+\n+                // sort by description (no description goes later)\n+                a = (aaa.item.desc === \"\");\n+                b = (bbb.item.desc === \"\");\n+                if (a !== b) { return a - b; }\n+\n+                // sort by type (later occurrence in `itemTypes` goes later)\n+                a = aaa.item.ty;\n+                b = bbb.item.ty;\n+                if (a !== b) { return a - b; }\n+\n+                // sort by path (lexicographically larger goes later)\n+                a = aaa.item.path;\n+                b = bbb.item.path;\n+                if (a !== b) { return (a > b ? +1 : -1); }\n+\n+                // que sera, sera\n+                return 0;\n+            });\n+\n+            for (i = 0, len = results.length; i < len; ++i) {\n+                var result = results[i];\n+\n+                // this validation does not make sense when searching by types\n+                if (result.dontValidate) {\n+                    continue;\n+                }\n+                var name = result.item.name.toLowerCase(),\n+                    path = result.item.path.toLowerCase(),\n+                    parent = result.item.parent;\n+\n+                if (isType !== true &&\n+                    validateResult(name, path, split, parent) === false)\n+                {\n+                    result.id = -1;\n+                }\n+            }\n+            return transformResults(results);\n+        }\n+\n+        function extractGenerics(val) {\n+            val = val.toLowerCase();\n+            if (val.indexOf(\"<\") !== -1) {\n+                var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n+                return {\n+                    name: val.substring(0, val.indexOf(\"<\")),\n+                    generics: values.split(/\\s*,\\s*/),\n+                };\n+            }\n+            return {\n+                name: val,\n+                generics: [],\n+            };\n+        }\n+\n+        function getObjectNameFromId(id) {\n+            if (typeof id === \"number\") {\n+                return searchIndex[id].name;\n+            }\n+            return id;\n+        }\n+\n+        function checkGenerics(obj, val) {\n+            // The names match, but we need to be sure that all generics kinda\n+            // match as well.\n+            var tmp_lev, elem_name;\n+            if (val.generics.length > 0) {\n+                if (obj.length > GENERICS_DATA &&\n+                      obj[GENERICS_DATA].length >= val.generics.length) {\n+                    var elems = Object.create(null);\n+                    var elength = object[GENERICS_DATA].length;\n+                    for (var x = 0; x < elength; ++x) {\n+                        elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n+                    }\n+                    var total = 0;\n+                    var done = 0;\n+                    // We need to find the type that matches the most to remove it in order\n+                    // to move forward.\n+                    var vlength = val.generics.length;\n+                    for (x = 0; x < vlength; ++x) {\n+                        var lev = MAX_LEV_DISTANCE + 1;\n+                        var firstGeneric = getObjectNameFromId(val.generics[x]);\n+                        var match = null;\n+                        if (elems[firstGeneric]) {\n+                            match = firstGeneric;\n+                            lev = 0;\n+                        } else {\n+                            for (elem_name in elems) {\n+                                tmp_lev = levenshtein(elem_name, firstGeneric);\n+                                if (tmp_lev < lev) {\n+                                    lev = tmp_lev;\n+                                    match = elem_name;\n+                                }\n+                            }\n+                        }\n+                        if (match !== null) {\n+                            elems[match] -= 1;\n+                            if (elems[match] == 0) {\n+                                delete elems[match];\n+                            }\n+                            total += lev;\n+                            done += 1;\n+                        } else {\n+                            return MAX_LEV_DISTANCE + 1;\n+                        }\n+                    }\n+                    return Math.ceil(total / done);\n+                }\n+            }\n+            return MAX_LEV_DISTANCE + 1;\n+        }\n+\n+        // Check for type name and type generics (if any).\n+        function checkType(obj, val, literalSearch) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+            var len, x, firstGeneric;\n+            if (obj[NAME] === val.name) {\n+                if (literalSearch === true) {\n+                    if (val.generics && val.generics.length !== 0) {\n+                        if (obj.length > GENERICS_DATA &&\n+                              obj[GENERICS_DATA].length >= val.generics.length) {\n+                            var elems = Object.create(null);\n+                            len = obj[GENERICS_DATA].length;\n+                            for (x = 0; x < len; ++x) {\n+                                elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n+                            }\n+\n+                            var allFound = true;\n+                            len = val.generics.length;\n+                            for (x = 0; x < len; ++x) {\n+                                firstGeneric = getObjectNameFromId(val.generics[x]);\n+                                if (elems[firstGeneric]) {\n+                                    elems[firstGeneric] -= 1;\n+                                } else {\n+                                    allFound = false;\n+                                    break;\n+                                }\n+                            }\n+                            if (allFound === true) {\n+                                return true;\n+                            }\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    return true;\n+                }\n+                // If the type has generics but don't match, then it won't return at this point.\n+                // Otherwise, `checkGenerics` will return 0 and it'll return.\n+                if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n+                    var tmp_lev = checkGenerics(obj, val);\n+                    if (tmp_lev <= MAX_LEV_DISTANCE) {\n+                        return tmp_lev;\n+                    }\n+                } else {\n+                    return 0;\n+                }\n+            }\n+            // Names didn't match so let's check if one of the generic types could.\n+            if (literalSearch === true) {\n+                 if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n+                    return obj[GENERICS_DATA].some(\n+                        function(name) {\n+                            return name === val.name;\n+                        });\n+                }\n+                return false;\n+            }\n+            lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n+            if (lev_distance <= MAX_LEV_DISTANCE) {\n+                // The generics didn't match but the name kinda did so we give it\n+                // a levenshtein distance value that isn't *this* good so it goes\n+                // into the search results but not too high.\n+                lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n+            } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n+                // We can check if the type we're looking for is inside the generics!\n+                var olength = obj[GENERICS_DATA].length;\n+                for (x = 0; x < olength; ++x) {\n+                    lev_distance = Math.min(levenshtein(obj[GENERICS_DATA][x], val.name),\n+                                            lev_distance);\n+                }\n+            }\n+            // Now whatever happens, the returned distance is \"less good\" so we should mark it\n+            // as such, and so we add 1 to the distance to make it \"less good\".\n+            return lev_distance + 1;\n+        }\n+\n+        function findArg(obj, val, literalSearch, typeFilter) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n+            if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n+                var length = obj.type[INPUTS_DATA].length;\n+                for (var i = 0; i < length; i++) {\n+                    var tmp = obj.type[INPUTS_DATA][i];\n+                    if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                        continue;\n+                    }\n+                    tmp = checkType(tmp, val, literalSearch);\n+                    if (literalSearch === true) {\n+                        if (tmp === true) {\n+                            return true;\n+                        }\n+                        continue;\n+                    }\n+                    lev_distance = Math.min(tmp, lev_distance);\n+                    if (lev_distance === 0) {\n+                        return 0;\n+                    }\n+                }\n+            }\n+            return literalSearch === true ? false : lev_distance;\n+        }\n+\n+        function checkReturned(obj, val, literalSearch, typeFilter) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n+            if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n+                var ret = obj.type[OUTPUT_DATA];\n+                if (typeof ret[0] === \"string\") {\n+                    ret = [ret];\n+                }\n+                for (var x = 0, len = ret.length; x < len; ++x) {\n+                    var tmp = ret[x];\n+                    if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                        continue;\n+                    }\n+                    tmp = checkType(tmp, val, literalSearch);\n+                    if (literalSearch === true) {\n+                        if (tmp === true) {\n+                            return true;\n+                        }\n+                        continue;\n+                    }\n+                    lev_distance = Math.min(tmp, lev_distance);\n+                    if (lev_distance === 0) {\n+                        return 0;\n+                    }\n+                }\n+            }\n+            return literalSearch === true ? false : lev_distance;\n+        }\n+\n+        function checkPath(contains, lastElem, ty) {\n+            if (contains.length === 0) {\n+                return 0;\n+            }\n+            var ret_lev = MAX_LEV_DISTANCE + 1;\n+            var path = ty.path.split(\"::\");\n+\n+            if (ty.parent && ty.parent.name) {\n+                path.push(ty.parent.name.toLowerCase());\n+            }\n+\n+            var length = path.length;\n+            var clength = contains.length;\n+            if (clength > length) {\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n+            for (var i = 0; i < length; ++i) {\n+                if (i + clength > length) {\n+                    break;\n+                }\n+                var lev_total = 0;\n+                var aborted = false;\n+                for (var x = 0; x < clength; ++x) {\n+                    var lev = levenshtein(path[i + x], contains[x]);\n+                    if (lev > MAX_LEV_DISTANCE) {\n+                        aborted = true;\n+                        break;\n+                    }\n+                    lev_total += lev;\n+                }\n+                if (aborted === false) {\n+                    ret_lev = Math.min(ret_lev, Math.round(lev_total / clength));\n+                }\n+            }\n+            return ret_lev;\n+        }\n+\n+        function typePassesFilter(filter, type) {\n+            // No filter\n+            if (filter <= NO_TYPE_FILTER) return true;\n+\n+            // Exact match\n+            if (filter === type) return true;\n+\n+            // Match related items\n+            var name = itemTypes[type];\n+            switch (itemTypes[filter]) {\n+                case \"constant\":\n+                    return name === \"associatedconstant\";\n+                case \"fn\":\n+                    return name === \"method\" || name === \"tymethod\";\n+                case \"type\":\n+                    return name === \"primitive\" || name === \"associatedtype\";\n+                case \"trait\":\n+                    return name === \"traitalias\";\n+            }\n+\n+            // No match\n+            return false;\n+        }\n+\n+        function createAliasFromItem(item) {\n+            return {\n+                crate: item.crate,\n+                name: item.name,\n+                path: item.path,\n+                desc: item.desc,\n+                ty: item.ty,\n+                parent: item.parent,\n+                type: item.type,\n+                is_alias: true,\n+            };\n+        }\n+\n+        function handleAliases(ret, query, filterCrates) {\n+            // We separate aliases and crate aliases because we want to have current crate\n+            // aliases to be before the others in the displayed results.\n+            var aliases = [];\n+            var crateAliases = [];\n+            if (filterCrates !== undefined) {\n+                if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n+                    var query_aliases = ALIASES[filterCrates][query.search];\n+                    var len = query_aliases.length;\n+                    for (var i = 0; i < len; ++i) {\n+                        aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                    }\n+                }\n+            } else {\n+                Object.keys(ALIASES).forEach(function(crate) {\n+                    if (ALIASES[crate][query.search]) {\n+                        var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                        var query_aliases = ALIASES[crate][query.search];\n+                        var len = query_aliases.length;\n+                        for (var i = 0; i < len; ++i) {\n+                            pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                        }\n+                    }\n+                });\n+            }\n+\n+            var sortFunc = function(aaa, bbb) {\n+                if (aaa.path < bbb.path) {\n+                    return 1;\n+                } else if (aaa.path === bbb.path) {\n+                    return 0;\n+                }\n+                return -1;\n+            };\n+            crateAliases.sort(sortFunc);\n+            aliases.sort(sortFunc);\n+\n+            var pushFunc = function(alias) {\n+                alias.alias = query.raw;\n+                var res = buildHrefAndPath(alias);\n+                alias.displayPath = pathSplitter(res[0]);\n+                alias.fullPath = alias.displayPath + alias.name;\n+                alias.href = res[1];\n+\n+                ret.others.unshift(alias);\n+                if (ret.others.length > MAX_RESULTS) {\n+                    ret.others.pop();\n+                }\n+            };\n+            onEach(aliases, pushFunc);\n+            onEach(crateAliases, pushFunc);\n+        }\n+\n+        // quoted values mean literal search\n+        var nSearchWords = searchWords.length;\n+        var i, it;\n+        var ty;\n+        var fullId;\n+        var returned;\n+        var in_args;\n+        var len;\n+        if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n+            val.charAt(val.length - 1) === val.charAt(0))\n+        {\n+            val = extractGenerics(val.substr(1, val.length - 2));\n+            for (i = 0; i < nSearchWords; ++i) {\n+                if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                    continue;\n+                }\n+                in_args = findArg(searchIndex[i], val, true, typeFilter);\n+                returned = checkReturned(searchIndex[i], val, true, typeFilter);\n+                ty = searchIndex[i];\n+                fullId = ty.id;\n+\n+                if (searchWords[i] === val.name\n+                    && typePassesFilter(typeFilter, searchIndex[i].ty)\n+                    && results[fullId] === undefined) {\n+                    results[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+                if (in_args === true && results_in_args[fullId] === undefined) {\n+                    results_in_args[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+                if (returned === true && results_returned[fullId] === undefined) {\n+                    results_returned[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+            }\n+            query.inputs = [val];\n+            query.output = val;\n+            query.search = val;\n+        // searching by type\n+        } else if (val.search(\"->\") > -1) {\n+            var trimmer = function(s) { return s.trim(); };\n+            var parts = val.split(\"->\").map(trimmer);\n+            var input = parts[0];\n+            // sort inputs so that order does not matter\n+            var inputs = input.split(\",\").map(trimmer).sort();\n+            for (i = 0, len = inputs.length; i < len; ++i) {\n+                inputs[i] = extractGenerics(inputs[i]);\n+            }\n+            var output = extractGenerics(parts[1]);\n+\n+            for (i = 0; i < nSearchWords; ++i) {\n+                if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                    continue;\n+                }\n+                var type = searchIndex[i].type;\n+                ty = searchIndex[i];\n+                if (!type) {\n+                    continue;\n+                }\n+                fullId = ty.id;\n+\n+                returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n+                if (output.name === \"*\" || returned === true) {\n+                    in_args = false;\n+                    var is_module = false;\n+\n+                    if (input === \"*\") {\n+                        is_module = true;\n+                    } else {\n+                        var allFound = true;\n+                        for (it = 0, len = inputs.length; allFound === true && it < len; it++) {\n+                            allFound = checkType(type, inputs[it], true);\n+                        }\n+                        in_args = allFound;\n+                    }\n+                    if (in_args === true) {\n+                        results_in_args[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (returned === true) {\n+                        results_returned[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (is_module === true) {\n+                        results[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                }\n+            }\n+            query.inputs = inputs.map(function(input) {\n+                return input.name;\n+            });\n+            query.output = output.name;\n+        } else {\n+            query.inputs = [val];\n+            query.output = val;\n+            query.search = val;\n+            // gather matching search results up to a certain maximum\n+            val = val.replace(/\\_/g, \"\");\n+\n+            var valGenerics = extractGenerics(val);\n+\n+            var paths = valLower.split(\"::\");\n+            removeEmptyStringsFromArray(paths);\n+            val = paths[paths.length - 1];\n+            var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n+\n+            var lev, j;\n+            for (j = 0; j < nSearchWords; ++j) {\n+                ty = searchIndex[j];\n+                if (!ty || (filterCrates !== undefined && ty.crate !== filterCrates)) {\n+                    continue;\n+                }\n+                var lev_add = 0;\n+                if (paths.length > 1) {\n+                    lev = checkPath(contains, paths[paths.length - 1], ty);\n+                    if (lev > MAX_LEV_DISTANCE) {\n+                        continue;\n+                    } else if (lev > 0) {\n+                        lev_add = lev / 10;\n+                    }\n+                }\n+\n+                returned = MAX_LEV_DISTANCE + 1;\n+                in_args = MAX_LEV_DISTANCE + 1;\n+                var index = -1;\n+                // we want lev results to go lower than others\n+                lev = MAX_LEV_DISTANCE + 1;\n+                fullId = ty.id;\n+\n+                if (searchWords[j].indexOf(split[i]) > -1 ||\n+                    searchWords[j].indexOf(val) > -1 ||\n+                    ty.normalizedName.indexOf(val) > -1)\n+                {\n+                    // filter type: ... queries\n+                    if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n+                        index = ty.normalizedName.indexOf(val);\n+                    }\n+                }\n+                if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n+                    if (typePassesFilter(typeFilter, ty.ty) === false) {\n+                        lev = MAX_LEV_DISTANCE + 1;\n+                    } else {\n+                        lev += 1;\n+                    }\n+                }\n+                in_args = findArg(ty, valGenerics, false, typeFilter);\n+                returned = checkReturned(ty, valGenerics, false, typeFilter);\n+\n+                lev += lev_add;\n+                if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n+                    if (val.length < 6) {\n+                        lev -= 1;\n+                    } else {\n+                        lev = 0;\n+                    }\n+                }\n+                if (in_args <= MAX_LEV_DISTANCE) {\n+                    if (results_in_args[fullId] === undefined) {\n+                        results_in_args[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: in_args,\n+                        };\n+                    }\n+                    results_in_args[fullId].lev =\n+                        Math.min(results_in_args[fullId].lev, in_args);\n+                }\n+                if (returned <= MAX_LEV_DISTANCE) {\n+                    if (results_returned[fullId] === undefined) {\n+                        results_returned[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: returned,\n+                        };\n+                    }\n+                    results_returned[fullId].lev =\n+                        Math.min(results_returned[fullId].lev, returned);\n+                }\n+                if (index !== -1 || lev <= MAX_LEV_DISTANCE) {\n+                    if (index !== -1 && paths.length < 2) {\n+                        lev = 0;\n+                    }\n+                    if (results[fullId] === undefined) {\n+                        results[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: lev,\n+                        };\n+                    }\n+                    results[fullId].lev = Math.min(results[fullId].lev, lev);\n+                }\n+            }\n+        }\n+\n+        var ret = {\n+            \"in_args\": sortResults(results_in_args, true),\n+            \"returned\": sortResults(results_returned, true),\n+            \"others\": sortResults(results),\n+        };\n+        handleAliases(ret, query, filterCrates);\n+        return ret;\n+    }\n+\n+    /**\n+     * Validate performs the following boolean logic. For example:\n+     * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n+     * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n+     * (name || path )\n+     *\n+     * This could be written functionally, but I wanted to minimise\n+     * functions on stack.\n+     *\n+     * @param  {[string]} name   [The name of the result]\n+     * @param  {[string]} path   [The path of the result]\n+     * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n+     * @param  {[object]} parent [The parent of the result]\n+     * @return {[boolean]}       [Whether the result is valid or not]\n+     */\n+    function validateResult(name, path, keys, parent) {\n+        for (var i = 0, len = keys.length; i < len; ++i) {\n+            // each check is for validation so we negate the conditions and invalidate\n+            if (!(\n+                // check for an exact name match\n+                name.indexOf(keys[i]) > -1 ||\n+                // then an exact path match\n+                path.indexOf(keys[i]) > -1 ||\n+                // next if there is a parent, check for exact parent match\n+                (parent !== undefined && parent.name !== undefined &&\n+                    parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                // lastly check to see if the name was a levenshtein match\n+                levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function getQuery(raw) {\n+        var matches, type, query;\n+        query = raw;\n+\n+        matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n+        if (matches) {\n+            type = matches[1].replace(/^const$/, \"constant\");\n+            query = query.substring(matches[0].length);\n+        }\n+\n+        return {\n+            raw: raw,\n+            query: query,\n+            type: type,\n+            id: query + type\n+        };\n+    }\n+\n+    function initSearchNav() {\n+        var hoverTimeout;\n+\n+        var click_func = function(e) {\n+            var el = e.target;\n+            // to retrieve the real \"owner\" of the event.\n+            while (el.tagName !== \"TR\") {\n+                el = el.parentNode;\n+            }\n+            var dst = e.target.getElementsByTagName(\"a\");\n+            if (dst.length < 1) {\n+                return;\n+            }\n+            dst = dst[0];\n+            if (window.location.pathname === dst.pathname) {\n+                searchState.hideResults();\n+                document.location.href = dst.href;\n+            }\n+        };\n+        var mouseover_func = function(e) {\n+            if (searchState.mouseMovedAfterSearch) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== \"TR\") {\n+                    el = el.parentNode;\n+                }\n+                clearTimeout(hoverTimeout);\n+                hoverTimeout = setTimeout(function() {\n+                    onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+                        onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                            removeClass(i_e, \"highlighted\");\n+                        });\n+                    });\n+                    addClass(el, \"highlighted\");\n+                }, 20);\n+            }\n+        };\n+        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                i_e.onclick = click_func;\n+                i_e.onmouseover = mouseover_func;\n+            });\n+        });\n+\n+        searchState.input.onkeydown = function(e) {\n+            // \"actives\" references the currently highlighted item in each search tab.\n+            // Each array in \"actives\" represents a tab.\n+            var actives = [[], [], []];\n+            // \"current\" is used to know which tab we're looking into.\n+            var current = 0;\n+            onEachLazy(document.getElementById(\"results\").childNodes, function(e) {\n+                onEachLazy(e.getElementsByClassName(\"highlighted\"), function(h_e) {\n+                    actives[current].push(h_e);\n+                });\n+                current += 1;\n+            });\n+\n+            var currentTab = searchState.currentTab;\n+            if (e.which === 38) { // up\n+                if (e.ctrlKey) { // Going through result tabs.\n+                    printTab(currentTab > 0 ? currentTab - 1 : 2);\n+                } else {\n+                    if (!actives[currentTab].length ||\n+                        !actives[currentTab][0].previousElementSibling) {\n+                        return;\n+                    }\n+                    addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n+                    removeClass(actives[currentTab][0], \"highlighted\");\n+                }\n+                e.preventDefault();\n+            } else if (e.which === 40) { // down\n+                if (e.ctrlKey) { // Going through result tabs.\n+                    printTab(currentTab > 1 ? 0 : currentTab + 1);\n+                } else if (!actives[currentTab].length) {\n+                    var results = document.getElementById(\"results\").childNodes;\n+                    if (results.length > 0) {\n+                        var res = results[currentTab].getElementsByClassName(\"result\");\n+                        if (res.length > 0) {\n+                            addClass(res[0], \"highlighted\");\n+                        }\n+                    }\n+                } else if (actives[currentTab][0].nextElementSibling) {\n+                    addClass(actives[currentTab][0].nextElementSibling, \"highlighted\");\n+                    removeClass(actives[currentTab][0], \"highlighted\");\n+                }\n+                e.preventDefault();\n+            } else if (e.which === 13) { // return\n+                if (actives[currentTab].length) {\n+                    document.location.href =\n+                        actives[currentTab][0].getElementsByTagName(\"a\")[0].href;\n+                }\n+            } else if (e.which === 16) { // shift\n+                // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n+            } else if (actives[currentTab].length > 0) {\n+                removeClass(actives[currentTab][0], \"highlighted\");\n+            }\n+        };\n+    }\n+\n+    function buildHrefAndPath(item) {\n+        var displayPath;\n+        var href;\n+        var type = itemTypes[item.ty];\n+        var name = item.name;\n+        var path = item.path;\n+\n+        if (type === \"mod\") {\n+            displayPath = path + \"::\";\n+            href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n+                   name + \"/index.html\";\n+        } else if (type === \"primitive\" || type === \"keyword\") {\n+            displayPath = \"\";\n+            href = window.rootPath + path.replace(/::/g, \"/\") +\n+                   \"/\" + type + \".\" + name + \".html\";\n+        } else if (type === \"externcrate\") {\n+            displayPath = \"\";\n+            href = window.rootPath + name + \"/index.html\";\n+        } else if (item.parent !== undefined) {\n+            var myparent = item.parent;\n+            var anchor = \"#\" + type + \".\" + name;\n+            var parentType = itemTypes[myparent.ty];\n+            var pageType = parentType;\n+            var pageName = myparent.name;\n+\n+            if (parentType === \"primitive\") {\n+                displayPath = myparent.name + \"::\";\n+            } else if (type === \"structfield\" && parentType === \"variant\") {\n+                // Structfields belonging to variants are special: the\n+                // final path element is the enum name.\n+                var enumNameIdx = item.path.lastIndexOf(\"::\");\n+                var enumName = item.path.substr(enumNameIdx + 2);\n+                path = item.path.substr(0, enumNameIdx);\n+                displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n+                anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n+                pageType = \"enum\";\n+                pageName = enumName;\n+            } else {\n+                displayPath = path + \"::\" + myparent.name + \"::\";\n+            }\n+            href = window.rootPath + path.replace(/::/g, \"/\") +\n+                   \"/\" + pageType +\n+                   \".\" + pageName +\n+                   \".html\" + anchor;\n+        } else {\n+            displayPath = item.path + \"::\";\n+            href = window.rootPath + item.path.replace(/::/g, \"/\") +\n+                   \"/\" + type + \".\" + name + \".html\";\n+        }\n+        return [displayPath, href];\n+    }\n+\n+    function escape(content) {\n+        var h1 = document.createElement(\"h1\");\n+        h1.textContent = content;\n+        return h1.innerHTML;\n+    }\n+\n+    function pathSplitter(path) {\n+        var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n+        if (tmp.endsWith(\"<span>\")) {\n+            return tmp.slice(0, tmp.length - 6);\n+        }\n+        return tmp;\n+    }\n+\n+    function addTab(array, query, display) {\n+        var extraStyle = \"\";\n+        if (display === false) {\n+            extraStyle = \" style=\\\"display: none;\\\"\";\n+        }\n+\n+        var output = \"\";\n+        var duplicates = {};\n+        var length = 0;\n+        if (array.length > 0) {\n+            output = \"<table class=\\\"search-results\\\"\" + extraStyle + \">\";\n+\n+            array.forEach(function(item) {\n+                var name, type;\n+\n+                name = item.name;\n+                type = itemTypes[item.ty];\n+\n+                if (item.is_alias !== true) {\n+                    if (duplicates[item.fullPath]) {\n+                        return;\n+                    }\n+                    duplicates[item.fullPath] = true;\n+                }\n+                length += 1;\n+\n+                output += \"<tr class=\\\"\" + type + \" result\\\"><td>\" +\n+                          \"<a href=\\\"\" + item.href + \"\\\">\" +\n+                          (item.is_alias === true ?\n+                           (\"<span class=\\\"alias\\\"><b>\" + item.alias + \" </b></span><span \" +\n+                              \"class=\\\"grey\\\"><i>&nbsp;- see&nbsp;</i></span>\") : \"\") +\n+                          item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" +\n+                          name + \"</span></a></td><td>\" +\n+                          \"<a href=\\\"\" + item.href + \"\\\">\" +\n+                          \"<span class=\\\"desc\\\">\" + item.desc +\n+                          \"&nbsp;</span></a></td></tr>\";\n+            });\n+            output += \"</table>\";\n+        } else {\n+            output = \"<div class=\\\"search-failed\\\"\" + extraStyle + \">No results :(<br/>\" +\n+                \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n+                encodeURIComponent(\"rust \" + query.query) +\n+                \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n+                \"Or try looking in one of these:<ul><li>The <a \" +\n+                \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n+                \" for technical details about the language.</li><li><a \" +\n+                \"href=\\\"https://doc.rust-lang.org/rust-by-example/index.html\\\">Rust By \" +\n+                \"Example</a> for expository code examples.</a></li><li>The <a \" +\n+                \"href=\\\"https://doc.rust-lang.org/book/index.html\\\">Rust Book</a> for \" +\n+                \"introductions to language features and the language itself.</li><li><a \" +\n+                \"href=\\\"https://docs.rs\\\">Docs.rs</a> for documentation of crates released on\" +\n+                \" <a href=\\\"https://crates.io/\\\">crates.io</a>.</li></ul></div>\";\n+        }\n+        return [output, length];\n+    }\n+\n+    function makeTabHeader(tabNb, text, nbElems) {\n+        if (searchState.currentTab === tabNb) {\n+            return \"<button class=\\\"selected\\\">\" + text +\n+                   \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n+        }\n+        return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n+    }\n+\n+    function showResults(results) {\n+        var search = searchState.outputElement();\n+        if (results.others.length === 1\n+            && getSettingValue(\"go-to-only-result\") === \"true\"\n+            // By default, the search DOM element is \"empty\" (meaning it has no children not\n+            // text content). Once a search has been run, it won't be empty, even if you press\n+            // ESC or empty the search input (which also \"cancels\" the search).\n+            && (!search.firstChild || search.firstChild.innerText !== searchState.loadingText))\n+        {\n+            var elem = document.createElement(\"a\");\n+            elem.href = results.others[0].href;\n+            elem.style.display = \"none\";\n+            // For firefox, we need the element to be in the DOM so it can be clicked.\n+            document.body.appendChild(elem);\n+            elem.click();\n+            return;\n+        }\n+        var query = getQuery(searchState.input.value);\n+\n+        currentResults = query.id;\n+\n+        var ret_others = addTab(results.others, query);\n+        var ret_in_args = addTab(results.in_args, query, false);\n+        var ret_returned = addTab(results.returned, query, false);\n+\n+        // Navigate to the relevant tab if the current tab is empty, like in case users search\n+        // for \"-> String\". If they had selected another tab previously, they have to click on\n+        // it again.\n+        var currentTab = searchState.currentTab;\n+        if ((currentTab === 0 && ret_others[1] === 0) ||\n+                (currentTab === 1 && ret_in_args[1] === 0) ||\n+                (currentTab === 2 && ret_returned[1] === 0)) {\n+            if (ret_others[1] !== 0) {\n+                currentTab = 0;\n+            } else if (ret_in_args[1] !== 0) {\n+                currentTab = 1;\n+            } else if (ret_returned[1] !== 0) {\n+                currentTab = 2;\n+            }\n+        }\n+\n+        var output = \"<h1>Results for \" + escape(query.query) +\n+            (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n+            \"<div id=\\\"titles\\\">\" +\n+            makeTabHeader(0, \"In Names\", ret_others[1]) +\n+            makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n+            makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n+            \"</div><div id=\\\"results\\\">\" +\n+            ret_others[0] + ret_in_args[0] + ret_returned[0] + \"</div>\";\n+\n+        search.innerHTML = output;\n+        searchState.showResults(search);\n+        initSearchNav();\n+        var elems = document.getElementById(\"titles\").childNodes;\n+        elems[0].onclick = function() { printTab(0); };\n+        elems[1].onclick = function() { printTab(1); };\n+        elems[2].onclick = function() { printTab(2); };\n+        printTab(currentTab);\n+    }\n+\n+    function execSearch(query, searchWords, filterCrates) {\n+        function getSmallest(arrays, positions, notDuplicates) {\n+            var start = null;\n+\n+            for (var it = 0, len = positions.length; it < len; ++it) {\n+                if (arrays[it].length > positions[it] &&\n+                    (start === null || start > arrays[it][positions[it]].lev) &&\n+                    !notDuplicates[arrays[it][positions[it]].fullPath]) {\n+                    start = arrays[it][positions[it]].lev;\n+                }\n+            }\n+            return start;\n+        }\n+\n+        function mergeArrays(arrays) {\n+            var ret = [];\n+            var positions = [];\n+            var notDuplicates = {};\n+\n+            for (var x = 0, arrays_len = arrays.length; x < arrays_len; ++x) {\n+                positions.push(0);\n+            }\n+            while (ret.length < MAX_RESULTS) {\n+                var smallest = getSmallest(arrays, positions, notDuplicates);\n+\n+                if (smallest === null) {\n+                    break;\n+                }\n+                for (x = 0; x < arrays_len && ret.length < MAX_RESULTS; ++x) {\n+                    if (arrays[x].length > positions[x] &&\n+                            arrays[x][positions[x]].lev === smallest &&\n+                            !notDuplicates[arrays[x][positions[x]].fullPath]) {\n+                        ret.push(arrays[x][positions[x]]);\n+                        notDuplicates[arrays[x][positions[x]].fullPath] = true;\n+                        positions[x] += 1;\n+                    }\n+                }\n+            }\n+            return ret;\n+        }\n+\n+        var queries = query.raw.split(\",\");\n+        var results = {\n+            \"in_args\": [],\n+            \"returned\": [],\n+            \"others\": [],\n+        };\n+\n+        for (var i = 0, len = queries.length; i < len; ++i) {\n+            query = queries[i].trim();\n+            if (query.length !== 0) {\n+                var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n+\n+                results.in_args.push(tmp.in_args);\n+                results.returned.push(tmp.returned);\n+                results.others.push(tmp.others);\n+            }\n+        }\n+        if (queries.length > 1) {\n+            return {\n+                \"in_args\": mergeArrays(results.in_args),\n+                \"returned\": mergeArrays(results.returned),\n+                \"others\": mergeArrays(results.others),\n+            };\n+        }\n+        return {\n+            \"in_args\": results.in_args[0],\n+            \"returned\": results.returned[0],\n+            \"others\": results.others[0],\n+        };\n+    }\n+\n+    function getFilterCrates() {\n+        var elem = document.getElementById(\"crate-search\");\n+\n+        if (elem && elem.value !== \"All crates\" && hasOwnProperty(rawSearchIndex, elem.value)) {\n+            return elem.value;\n+        }\n+        return undefined;\n+    }\n+\n+    function search(e, forced) {\n+        var params = searchState.getQueryStringParams();\n+        var query = getQuery(searchState.input.value.trim());\n+\n+        if (e) {\n+            e.preventDefault();\n+        }\n+\n+        if (query.query.length === 0) {\n+            return;\n+        }\n+        if (forced !== true && query.id === currentResults) {\n+            if (query.query.length > 0) {\n+                searchState.putBackSearch(searchState.input);\n+            }\n+            return;\n+        }\n+\n+        // Update document title to maintain a meaningful browser history\n+        searchState.title = \"Results for \" + query.query + \" - Rust\";\n+\n+        // Because searching is incremental by character, only the most\n+        // recent search query is added to the browser history.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            var newURL = getNakedUrl() + \"?search=\" + encodeURIComponent(query.raw) +\n+                window.location.hash;\n+            if (!history.state && !params.search) {\n+                history.pushState(query, \"\", newURL);\n+            } else {\n+                history.replaceState(query, \"\", newURL);\n+            }\n+        }\n+\n+        var filterCrates = getFilterCrates();\n+        showResults(execSearch(query, index, filterCrates));\n+    }\n+\n+    function buildIndex(rawSearchIndex) {\n+        searchIndex = [];\n+        var searchWords = [];\n+        var i, word;\n+        var currentIndex = 0;\n+        var id = 0;\n+\n+        for (var crate in rawSearchIndex) {\n+            if (!hasOwnProperty(rawSearchIndex, crate)) { continue; }\n+\n+            var crateSize = 0;\n+\n+            searchWords.push(crate);\n+            var normalizedName = crate.indexOf(\"_\") === -1\n+                ? crate\n+                : crate.replace(/_/g, \"\");\n+            // This object should have exactly the same set of fields as the \"row\"\n+            // object defined below. Your JavaScript runtime will thank you.\n+            // https://mathiasbynens.be/notes/shapes-ics\n+            var crateRow = {\n+                crate: crate,\n+                ty: 1, // == ExternCrate\n+                name: crate,\n+                path: \"\",\n+                desc: rawSearchIndex[crate].doc,\n+                parent: undefined,\n+                type: null,\n+                id: id,\n+                normalizedName: normalizedName,\n+            };\n+            id += 1;\n+            searchIndex.push(crateRow);\n+            currentIndex += 1;\n+\n+            // an array of (Number) item types\n+            var itemTypes = rawSearchIndex[crate].t;\n+            // an array of (String) item names\n+            var itemNames = rawSearchIndex[crate].n;\n+            // an array of (String) full paths (or empty string for previous path)\n+            var itemPaths = rawSearchIndex[crate].q;\n+            // an array of (String) descriptions\n+            var itemDescs = rawSearchIndex[crate].d;\n+            // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n+            var itemParentIdxs = rawSearchIndex[crate].i;\n+            // an array of (Object | null) the type of the function, if any\n+            var itemFunctionSearchTypes = rawSearchIndex[crate].f;\n+            // an array of [(Number) item type,\n+            //              (String) name]\n+            var paths = rawSearchIndex[crate].p;\n+            // a array of [(String) alias name\n+            //             [Number] index to items]\n+            var aliases = rawSearchIndex[crate].a;\n+\n+            // convert `rawPaths` entries into object form\n+            var len = paths.length;\n+            for (i = 0; i < len; ++i) {\n+                paths[i] = {ty: paths[i][0], name: paths[i][1]};\n+            }\n+\n+            // convert `item*` into an object form, and construct word indices.\n+            //\n+            // before any analysis is performed lets gather the search terms to\n+            // search against apart from the rest of the data.  This is a quick\n+            // operation that is cached for the life of the page state so that\n+            // all other search operations have access to this cached data for\n+            // faster analysis operations\n+            len = itemTypes.length;\n+            var lastPath = \"\";\n+            for (i = 0; i < len; ++i) {\n+                // This object should have exactly the same set of fields as the \"crateRow\"\n+                // object defined above.\n+                if (typeof itemNames[i] === \"string\") {\n+                    word = itemNames[i].toLowerCase();\n+                    searchWords.push(word);\n+                } else {\n+                    word = \"\";\n+                    searchWords.push(\"\");\n+                }\n+                var normalizedName = word.indexOf(\"_\") === -1\n+                    ? word\n+                    : word.replace(/_/g, \"\");\n+                var row = {\n+                    crate: crate,\n+                    ty: itemTypes[i],\n+                    name: itemNames[i],\n+                    path: itemPaths[i] ? itemPaths[i] : lastPath,\n+                    desc: itemDescs[i],\n+                    parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n+                    type: itemFunctionSearchTypes[i],\n+                    id: id,\n+                    normalizedName: normalizedName,\n+                };\n+                id += 1;\n+                searchIndex.push(row);\n+                lastPath = row.path;\n+                crateSize += 1;\n+            }\n+\n+            if (aliases) {\n+                ALIASES[crate] = {};\n+                var j, local_aliases;\n+                for (var alias_name in aliases) {\n+                    if (!aliases.hasOwnProperty(alias_name)) { continue; }\n+\n+                    if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n+                        ALIASES[crate][alias_name] = [];\n+                    }\n+                    local_aliases = aliases[alias_name];\n+                    for (j = 0, len = local_aliases.length; j < len; ++j) {\n+                        ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                    }\n+                }\n+            }\n+            currentIndex += crateSize;\n+        }\n+        return searchWords;\n+    }\n+\n+    function registerSearchEvents() {\n+        var searchAfter500ms = function() {\n+            searchState.clearInputTimeout();\n+            if (searchState.input.value.length === 0) {\n+                if (searchState.browserSupportsHistoryApi()) {\n+                    history.replaceState(\"\", window.currentCrate + \" - Rust\",\n+                        getNakedUrl() + window.location.hash);\n+                }\n+                searchState.hideResults();\n+            } else {\n+                searchState.timeout = setTimeout(search, 500);\n+            }\n+        };\n+        searchState.input.onkeyup = searchAfter500ms;\n+        searchState.input.oninput = searchAfter500ms;\n+        document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n+            e.preventDefault();\n+            searchState.clearInputTimeout();\n+            search();\n+        };\n+        searchState.input.onchange = function(e) {\n+            if (e.target !== document.activeElement) {\n+                // To prevent doing anything when it's from a blur event.\n+                return;\n+            }\n+            // Do NOT e.preventDefault() here. It will prevent pasting.\n+            searchState.clearInputTimeout();\n+            // zero-timeout necessary here because at the time of event handler execution the\n+            // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n+            // change, though.\n+            setTimeout(search, 0);\n+        };\n+        searchState.input.onpaste = searchState.input.onchange;\n+\n+        var selectCrate = document.getElementById(\"crate-search\");\n+        if (selectCrate) {\n+            selectCrate.onchange = function() {\n+                updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n+                search(undefined, true);\n+            };\n+        }\n+\n+        // Push and pop states are used to add search results to the browser\n+        // history.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            // Store the previous <title> so we can revert back to it later.\n+            var previousTitle = document.title;\n+\n+            window.addEventListener(\"popstate\", function(e) {\n+                var params = searchState.getQueryStringParams();\n+                // Revert to the previous title manually since the History\n+                // API ignores the title parameter.\n+                document.title = previousTitle;\n+                // When browsing forward to search results the previous\n+                // search will be repeated, so the currentResults are\n+                // cleared to ensure the search is successful.\n+                currentResults = null;\n+                // Synchronize search bar with query string state and\n+                // perform the search. This will empty the bar if there's\n+                // nothing there, which lets you really go back to a\n+                // previous state with nothing in the bar.\n+                if (params.search && params.search.length > 0) {\n+                    searchState.input.value = params.search;\n+                    // Some browsers fire \"onpopstate\" for every page load\n+                    // (Chrome), while others fire the event only when actually\n+                    // popping a state (Firefox), which is why search() is\n+                    // called both here and at the end of the startSearch()\n+                    // function.\n+                    search(e);\n+                } else {\n+                    searchState.input.value = \"\";\n+                    // When browsing back from search results the main page\n+                    // visibility must be reset.\n+                    searchState.hideResults();\n+                }\n+            });\n+        }\n+\n+        // This is required in firefox to avoid this problem: Navigating to a search result\n+        // with the keyboard, hitting enter, and then hitting back would take you back to\n+        // the doc page, rather than the search that should overlay it.\n+        // This was an interaction between the back-forward cache and our handlers\n+        // that try to sync state between the URL and the search input. To work around it,\n+        // do a small amount of re-init on page show.\n+        window.onpageshow = function(){\n+            var qSearch = searchState.getQueryStringParams().search;\n+            if (searchState.input.value === \"\" && qSearch) {\n+                searchState.input.value = qSearch;\n+            }\n+            search();\n+        };\n+    }\n+\n+    index = buildIndex(rawSearchIndex);\n+    registerSearchEvents();\n+    // If there's a search term in the URL, execute the search now.\n+    if (searchState.getQueryStringParams().search) {\n+        search();\n+    }\n+};\n+\n+if (window.searchIndex !== undefined) {\n+  initSearch(window.searchIndex);\n+}\n+\n+})();"}, {"sha": "2b73bd5d52ee614988b79b14eea08600ed5f2f5d", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -24,6 +24,9 @@ crate static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n /// including search behavior and docblock folding, among others.\n crate static MAIN_JS: &str = include_str!(\"static/main.js\");\n \n+/// The file contents of `search.js`, which contains the search behavior.\n+crate static SEARCH_JS: &str = include_str!(\"static/search.js\");\n+\n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n crate static SETTINGS_JS: &str = include_str!(\"static/settings.js\");"}, {"sha": "e583bd225a9eb164fe9901e3353712faeda67d9b", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/b5ce9c44a3137ee26a23228bc83cd8929438a3cf/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=b5ce9c44a3137ee26a23228bc83cd8929438a3cf", "patch": "@@ -246,7 +246,7 @@ function lookForEntry(entry, data) {\n     return null;\n }\n \n-function loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate) {\n+function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     if (searchIndex[searchIndex.length - 1].length === 0) {\n         searchIndex.pop();\n     }\n@@ -270,9 +270,9 @@ function loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate) {\n     ALIASES = {};\n     finalJS += 'window = { \"currentCrate\": \"' + crate + '\", rootPath: \"../\" };\\n';\n     finalJS += loadThings([\"hasOwnProperty\", \"onEach\"], 'function', extractFunction, storageJs);\n-    finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, mainJs);\n-    finalJS += loadThings(variablesToLoad, 'variable', extractVariable, mainJs);\n-    finalJS += loadThings(functionsToLoad, 'function', extractFunction, mainJs);\n+    finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, searchJs);\n+    finalJS += loadThings(variablesToLoad, 'variable', extractVariable, searchJs);\n+    finalJS += loadThings(functionsToLoad, 'function', extractFunction, searchJs);\n \n     var loaded = loadContent(finalJS);\n     var index = loaded.buildIndex(searchIndex.rawSearchIndex);\n@@ -382,12 +382,12 @@ function runChecks(testFile, loaded, index) {\n }\n \n function load_files(doc_folder, resource_suffix, crate) {\n-    var mainJs = readFile(path.join(doc_folder, \"main\" + resource_suffix + \".js\"));\n+    var searchJs = readFile(path.join(doc_folder, \"search\" + resource_suffix + \".js\"));\n     var storageJs = readFile(path.join(doc_folder, \"storage\" + resource_suffix + \".js\"));\n     var searchIndex = readFile(\n         path.join(doc_folder, \"search-index\" + resource_suffix + \".js\")).split(\"\\n\");\n \n-    return loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate);\n+    return loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate);\n }\n \n function showHelp() {"}]}