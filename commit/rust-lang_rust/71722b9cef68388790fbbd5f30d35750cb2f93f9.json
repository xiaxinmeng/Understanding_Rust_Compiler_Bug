{"sha": "71722b9cef68388790fbbd5f30d35750cb2f93f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNzIyYjljZWY2ODM4ODc5MGZiYmQ1ZjMwZDM1NzUwY2IyZjkzZjk=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T10:54:46Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T15:15:56Z"}, "message": "Fix rebase issues", "tree": {"sha": "3e2b7ce5729a7b70d6d0b6d6b22cdc5a196b0fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e2b7ce5729a7b70d6d0b6d6b22cdc5a196b0fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71722b9cef68388790fbbd5f30d35750cb2f93f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71722b9cef68388790fbbd5f30d35750cb2f93f9", "html_url": "https://github.com/rust-lang/rust/commit/71722b9cef68388790fbbd5f30d35750cb2f93f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71722b9cef68388790fbbd5f30d35750cb2f93f9/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0209c44a620fa63d2e95d0752ef24f8f0d73ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0209c44a620fa63d2e95d0752ef24f8f0d73ceb", "html_url": "https://github.com/rust-lang/rust/commit/d0209c44a620fa63d2e95d0752ef24f8f0d73ceb"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "e9d65caf08743ac486b4624c8b3d516e53af04da", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -647,7 +647,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n-        ty::TyChar if exhaustive_integer_patterns => {\n+        ty::Char if exhaustive_integer_patterns => {\n             let endpoint = |c: char| {\n                 let ty = ty::ParamEnv::empty().and(cx.tcx.types.char);\n                 ty::Const::from_bits(cx.tcx, c as u128, ty)\n@@ -658,7 +658,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n             ]\n         }\n-        ty::TyInt(ity) if exhaustive_integer_patterns => {\n+        ty::Int(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n@@ -668,7 +668,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                ty::Const::from_bits(cx.tcx, max as u128, ty),\n                                RangeEnd::Included)]\n         }\n-        ty::TyUint(uty) if exhaustive_integer_patterns => {\n+        ty::Uint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n@@ -861,7 +861,7 @@ impl<'tcx> IntRange<'tcx> {\n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n-            ty::TyInt(ity) => {\n+            ty::Int(ity) => {\n                 let bits = Integer::from_attr(tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n@@ -1382,7 +1382,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     if tcx.features().exhaustive_integer_patterns {\n         if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n-            if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n+            if let ty::Char | ty::Int(_) | ty::Uint(_) = value.ty.sty {\n                 return true;\n             }\n         }"}, {"sha": "0c5dbf9a0f63e8c642753df59f5efee3022cc345", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -15,9 +15,9 @@ use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n-            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n+            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::Ref(_, ty, _) => !self.type_is_sized(ty),\n+            ty::Adt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n             _ => false,\n         }\n     }\n@@ -313,19 +313,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+            (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_value(src)?.to_scalar_ptr()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Value::new_slice(ptr, length.unwrap_usize(self.tcx.tcx), self.tcx.tcx);\n                 self.write_value(val, dest)\n             }\n-            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+            (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n                 self.copy_op(src, dest)\n             }\n-            (_, &ty::TyDynamic(ref data, _)) => {\n+            (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let trait_ref = data.principal().unwrap().with_self_ty(\n                     *self.tcx,\n@@ -348,13 +348,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n-            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n-            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n-            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n-             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+            (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |\n+            (&ty::Ref(_, s, _), &ty::RawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::RawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::RawPtr(TypeAndMut { ty: d, .. })) => {\n                 self.unsize_into_ptr(src, dest, s, d)\n             }\n-            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+            (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {"}, {"sha": "1795548d81c773a510be41cb97b09dd718f02ffd", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -236,15 +236,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n         let mplace = match self.tcx.struct_tail(pointee_type).sty {\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n                 MemPlace {\n                     ptr,\n                     align: layout.align,\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n-            ty::TyStr | ty::TySlice(_) => {\n+            ty::Str | ty::Slice(_) => {\n                 let (ptr, len) = val.to_scalar_slice(self)?;\n                 MemPlace {\n                     ptr,\n@@ -358,9 +358,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Compute extra and new layout\n         let inner_len = len - to - from;\n         let (extra, ty) = match base.layout.ty.sty {\n-            ty::TyArray(inner, _) =>\n+            ty::Array(inner, _) =>\n                 (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n-            ty::TySlice(..) =>\n+            ty::Slice(..) =>\n                 (PlaceExtra::Length(inner_len), base.layout.ty),\n             _ =>\n                 bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),"}, {"sha": "a446a534624ba911dea5a70819d6bdea23a3f347", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n         // has no special checks for chars\n         match ty.sty {\n-            ty::TyChar => {\n+            ty::Char => {\n                 debug_assert_eq!(size.bytes(), 4);\n                 if ::std::char::from_u32(bits as u32).is_none() {\n                     return validation_failure!(\n@@ -323,23 +323,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n         match ty.sty {\n             // generators and closures.\n-            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n                 PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n             }\n \n             // tuples\n-            ty::TyTuple(_) => PathElem::TupleElem(field),\n+            ty::Tuple(_) => PathElem::TupleElem(field),\n \n             // enums\n-            ty::TyAdt(def, ..) if def.is_enum() => {\n+            ty::Adt(def, ..) if def.is_enum() => {\n                 let variant = &def.variants[variant];\n                 PathElem::Field(variant.fields[field].ident.name)\n             }\n \n             // other ADTs\n-            ty::TyAdt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n \n             // nothing else has an aggregate layout\n             _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),"}, {"sha": "d094497e246d0deff28f0c35a38540b6370493a7", "filename": "src/test/ui/issues/issue-46332.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Ftest%2Fui%2Fissues%2Fissue-46332.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Ftest%2Fui%2Fissues%2Fissue-46332.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46332.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -11,9 +11,9 @@\n // Original Levenshtein distance for both of this is 1. We improved accuracy with\n // additional case insensitive comparison.\n \n-struct Uint {}\n+struct TyUint {}\n \n-struct Int {}\n+struct TyInt {}\n \n fn main() {\n     TyUInt {};"}, {"sha": "ba8b3d1810a05dc605c62a152113d23d4b811604", "filename": "src/test/ui/privacy/private-inferred-type-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71722b9cef68388790fbbd5f30d35750cb2f93f9/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-1.rs?ref=71722b9cef68388790fbbd5f30d35750cb2f93f9", "patch": "@@ -11,15 +11,15 @@\n trait Arr0 {\n     fn arr0_secret(&self);\n }\n-trait Param {\n+trait TyParam {\n     fn ty_param_secret(&self);\n }\n \n mod m {\n     struct Priv;\n \n     impl ::Arr0 for [Priv; 0] { fn arr0_secret(&self) {} }\n-    impl ::Param for Option<Priv> { fn ty_param_secret(&self) {} }\n+    impl ::TyParam for Option<Priv> { fn ty_param_secret(&self) {} }\n }\n \n fn main() {"}]}