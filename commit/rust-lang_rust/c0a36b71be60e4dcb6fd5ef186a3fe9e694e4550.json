{"sha": "c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYTM2YjcxYmU2MGU0ZGNiNmZkNWVmMTg2YTNmZTllNjk0ZTQ1NTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T00:48:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T01:07:36Z"}, "message": "rustc: Eliminate metadata's dependency on session", "tree": {"sha": "ef7ac129f2b00af03f79ead0737796ad6f1b27f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef7ac129f2b00af03f79ead0737796ad6f1b27f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "html_url": "https://github.com/rust-lang/rust/commit/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98b93b6c86d6dc3db7e057866bb8a29a38cc7a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/98b93b6c86d6dc3db7e057866bb8a29a38cc7a3a", "html_url": "https://github.com/rust-lang/rust/commit/98b93b6c86d6dc3db7e057866bb8a29a38cc7a3a"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "655a6f82b784cbc9655bc843a79465c9f33539ec", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "patch": "@@ -162,7 +162,11 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         time(time_passes, \"ast indexing\",\n              bind syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n     time(time_passes, \"external crate/lib resolution\",\n-         bind creader::read_crates(sess, *crate));\n+         bind creader::read_crates(\n+             sess.diagnostic(), *crate, sess.cstore,\n+             sess.filesearch,\n+             session::sess_os_to_meta_os(sess.targ_cfg.os),\n+             sess.opts.static));\n     let {def_map, exp_map, impl_map} =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));"}, {"sha": "272c3b0e5612d7ff163b2c11cb36aee062ff28e2", "filename": "src/rustc/metadata.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata.rs?ref=c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "patch": "@@ -14,8 +14,6 @@ mod back {\n }\n \n mod driver {\n-    import session = driver_::session;\n-    export session;\n }\n \n mod util {"}, {"sha": "0fadf1b1f68f315b8d9151142967ec102190eb19", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "patch": "@@ -4,22 +4,28 @@ Validates all used crates and native libraries and loads their metadata\n \n \"];\n \n-import driver::session;\n-import session::session;\n+import syntax::diagnostic::span_handler;\n import syntax::{ast, ast_util};\n import syntax::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import std::map::{hashmap, int_hash};\n import syntax::print::pprust;\n+import util::filesearch::filesearch;\n import common::*;\n \n export read_crates;\n \n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n-fn read_crates(sess: session::session, crate: ast::crate) {\n-    let e = @{sess: sess,\n+fn read_crates(diag: span_handler, crate: ast::crate,\n+               cstore: cstore::cstore, filesearch: filesearch,\n+               os: loader::os, static: bool) {\n+    let e = @{diag: diag,\n+              filesearch: filesearch,\n+              cstore: cstore,\n+              os: os,\n+              static: static,\n               mut crate_cache: [],\n               mut next_crate_num: 1};\n     let v =\n@@ -29,7 +35,7 @@ fn read_crates(sess: session::session, crate: ast::crate) {\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(sess, copy e.crate_cache);\n+    warn_if_multiple_versions(diag, copy e.crate_cache);\n }\n \n type cache_entry = {\n@@ -54,7 +60,7 @@ fn dump_crates(crate_cache: [cache_entry]) {\n     }\n }\n \n-fn warn_if_multiple_versions(sess: session::session,\n+fn warn_if_multiple_versions(diag: span_handler,\n                              crate_cache: [cache_entry]) {\n     import either::*;\n \n@@ -73,21 +79,26 @@ fn warn_if_multiple_versions(sess: session::session,\n         assert matches.is_not_empty();\n \n         if matches.len() != 1u {\n-            sess.warn(#fmt(\"using multiple versions of crate `%s`\", name));\n+            diag.handler().warn(\n+                #fmt(\"using multiple versions of crate `%s`\", name));\n             for matches.each {|match|\n-                sess.span_note(match.span, \"used here\");\n+                diag.span_note(match.span, \"used here\");\n                 let attrs = [\n                     attr::mk_attr(attr::mk_list_item(\"link\", *match.metas))\n                 ];\n-                loader::note_linkage_attrs(sess, attrs);\n+                loader::note_linkage_attrs(diag, attrs);\n             }\n         }\n \n-        warn_if_multiple_versions(sess, non_matches);\n+        warn_if_multiple_versions(diag, non_matches);\n     }\n }\n \n-type env = @{sess: session::session,\n+type env = @{diag: span_handler,\n+             filesearch: filesearch,\n+             cstore: cstore::cstore,\n+             os: loader::os,\n+             static: bool,\n              mut crate_cache: [cache_entry],\n              mut next_crate_num: ast::crate_num};\n \n@@ -96,7 +107,7 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n       ast::view_item_use(ident, meta_items, id) {\n         #debug(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n         let cnum = resolve_crate(e, ident, meta_items, \"\", i.span);\n-        cstore::add_use_stmt_cnum(e.sess.cstore, id, cnum);\n+        cstore::add_use_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ { }\n     }\n@@ -110,15 +121,15 @@ fn visit_item(e: env, i: @ast::item) {\n             if abi != ast::native_abi_cdecl &&\n                abi != ast::native_abi_stdcall { ret; }\n           }\n-          either::left(msg) { e.sess.span_fatal(i.span, msg); }\n+          either::left(msg) { e.diag.span_fatal(i.span, msg); }\n         }\n \n-        let cstore = e.sess.cstore;\n+        let cstore = e.cstore;\n         let native_name =\n             alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n               some(nn) {\n                 if nn == \"\" {\n-                    e.sess.span_fatal(\n+                    e.diag.span_fatal(\n                         i.span,\n                         \"empty #[link_name] not allowed; use #[nolink].\");\n                 }\n@@ -132,7 +143,7 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n         let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n         if vec::len(link_args) > 0u && already_added {\n-            e.sess.span_fatal(i.span, \"library '\" + native_name +\n+            e.diag.span_fatal(i.span, \"library '\" + native_name +\n                               \"' already added: can't specify link_args.\");\n         }\n         for link_args.each {|a|\n@@ -180,13 +191,14 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n     alt existing_match(e, metas, hash) {\n       none {\n         let load_ctxt: loader::ctxt = {\n-            sess: e.sess,\n+            diag: e.diag,\n+            filesearch: e.filesearch,\n             span: span,\n             ident: ident,\n             metas: metas,\n             hash: hash,\n-            os: session::sess_os_to_meta_os(e.sess.targ_cfg.os),\n-            static: e.sess.opts.static\n+            os: e.os,\n+            static: e.static\n         };\n         let cinfo = loader::load_library_crate(load_ctxt);\n \n@@ -214,7 +226,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n-        let cstore = e.sess.cstore;\n+        let cstore = e.cstore;\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;"}, {"sha": "3994d9fa722a55472dbafadea31e8ce2768c6835", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "patch": "@@ -6,8 +6,8 @@ import syntax::ast_util;\n import syntax::ast_map;\n import middle::ty;\n import option::{some, none};\n-import driver::session;\n-import driver::session::expect;\n+import syntax::diagnostic::span_handler;\n+import syntax::diagnostic::expect;\n import common::*;\n import std::map::hashmap;\n \n@@ -82,7 +82,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n }\n \n fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n@@ -103,14 +103,14 @@ enum found_ast {\n fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n                       decode_inlined_item: decoder::decode_inlined_item)\n     -> found_ast {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     ret decoder::get_enum_variants(cdata, def.node, tcx)\n }\n@@ -125,35 +125,35 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n }\n \n fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_class_fields(cdata, def.node)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     #debug(\"Looking up %?\", class_id);\n-    let class_doc = expect(tcx.sess,\n+    let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            {|| #fmt(\"get_field_type: class ID %? not found\",\n                      class_id)});\n     #debug(\"looking up %? : %?\", def, class_doc);\n-    let the_field = expect(tcx.sess,\n+    let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n         {|| #fmt(\"get_field_type: in class %?, field ID %? not found\",\n                  class_id, def)});\n@@ -165,7 +165,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n // Given a def_id for an impl or class, return the iface it implements,\n // or none if it's not for an impl or for a class that implements ifaces\n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_iface(cdata, def.node, tcx)\n }"}, {"sha": "da991ec0c2acdd4c3b06e8353b4ace58e9b6bd95", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=c0a36b71be60e4dcb6fd5ef186a3fe9e694e4550", "patch": "@@ -4,13 +4,13 @@ Finds crate binaries and loads their metadata\n \n \"];\n \n-import driver::session;\n-import session::session;\n+import syntax::diagnostic::span_handler;\n import syntax::{ast, attr};\n import syntax::print::pprust;\n import syntax::codemap::span;\n import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n-import util::{filesearch};\n+import util::filesearch;\n+import filesearch::filesearch;\n import io::writer_util;\n \n export os;\n@@ -30,7 +30,8 @@ enum os {\n }\n \n type ctxt = {\n-    sess: session,\n+    diag: span_handler,\n+    filesearch: filesearch,\n     span: span,\n     ident: ast::ident,\n     metas: [@ast::meta_item],\n@@ -43,15 +44,15 @@ fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]} {\n     alt find_library_crate(cx) {\n       some(t) { ret t; }\n       none {\n-        cx.sess.span_fatal(\n+        cx.diag.span_fatal(\n             cx.span, #fmt[\"can't find crate for '%s'\", cx.ident]);\n       }\n     }\n }\n \n fn find_library_crate(cx: ctxt) -> option<{ident: str, data: @[u8]}> {\n-    attr::require_unique_names(cx.sess.diagnostic(), cx.metas);\n-    find_library_crate_aux(cx, libname(cx), cx.sess.filesearch)\n+    attr::require_unique_names(cx.diag, cx.metas);\n+    find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n fn libname(cx: ctxt) -> {prefix: str, suffix: str} {\n@@ -106,15 +107,15 @@ fn find_library_crate_aux(cx: ctxt,\n     } else if matches.len() == 1u {\n         some(matches[0])\n     } else {\n-        cx.sess.span_err(\n+        cx.diag.span_err(\n             cx.span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n-        cx.sess.note(\"candidates:\");\n+        cx.diag.handler().note(\"candidates:\");\n         for matches.each {|match|\n-            cx.sess.note(#fmt(\"path: %s\", match.ident));\n+            cx.diag.handler().note(#fmt(\"path: %s\", match.ident));\n             let attrs = decoder::get_crate_attributes(match.data);\n-            note_linkage_attrs(cx.sess, attrs);\n+            note_linkage_attrs(cx.diag, attrs);\n         }\n-        cx.sess.abort_if_errors();\n+        cx.diag.handler().abort_if_errors();\n         none\n     }\n }\n@@ -134,9 +135,9 @@ fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n     }\n }\n \n-fn note_linkage_attrs(sess: session::session, attrs: [ast::attribute]) {\n+fn note_linkage_attrs(diag: span_handler, attrs: [ast::attribute]) {\n     for attr::find_linkage_attrs(attrs).each {|attr|\n-        sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n+        diag.handler().note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n     }\n }\n "}]}