{"sha": "ec1312ef38092a4c8f49b57185707c95e00129fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMTMxMmVmMzgwOTJhNGM4ZjQ5YjU3MTg1NzA3Yzk1ZTAwMTI5ZmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-17T14:42:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-17T14:42:02Z"}, "message": "Merge pull request #3582 from kiljacken/out-dir-from-check\n\nUpdate OUT_DIR based on `cargo check` output", "tree": {"sha": "4a8011773870657b0573d2ea587745999bb14d98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8011773870657b0573d2ea587745999bb14d98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec1312ef38092a4c8f49b57185707c95e00129fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecOG6CRBK7hj4Ov3rIwAAdHIIAIagnjfYqDKvX8JRWwagLZdg\nxA0AMbPQT+LUw6PGhW7lkADE0uq5FYRROQWx7jUTT0RvbKYymTMMPVrytprY+T4e\nhS59CVXE2Q12dy6ecvTzFYRyRW333h/lyutmk+4LmSsfBD8cX8uSIrBJWWpqwFtZ\n2Atp3A1eaE0w/O5AHITxUrYT65PV1HICeyZlh8xIqxXVb/tYpNdpbekL8YO68EbD\nOm6hWQ5qiKVOxp3IFX6IcTtc+9IfZpHnNJP0IKSRZCRKbWv+RSQ9zO9eBWaX/jVj\nsodMs8EQSX4tzacQyIXTdo/KvSaMmDfjEwSnM2CSTKQI7HRmJr899BnBS8DI5Gw=\n=x3Nn\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a8011773870657b0573d2ea587745999bb14d98\nparent 2720e2374be951bb762ff2815dd67c7ffe3419b7\nparent 2dd887de4761e2493f4df56233b0e11185d74d63\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1584456122 +0100\ncommitter GitHub <noreply@github.com> 1584456122 +0100\n\nMerge pull request #3582 from kiljacken/out-dir-from-check\n\nUpdate OUT_DIR based on `cargo check` output"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1312ef38092a4c8f49b57185707c95e00129fa", "html_url": "https://github.com/rust-lang/rust/commit/ec1312ef38092a4c8f49b57185707c95e00129fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec1312ef38092a4c8f49b57185707c95e00129fa/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2720e2374be951bb762ff2815dd67c7ffe3419b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2720e2374be951bb762ff2815dd67c7ffe3419b7", "html_url": "https://github.com/rust-lang/rust/commit/2720e2374be951bb762ff2815dd67c7ffe3419b7"}, {"sha": "2dd887de4761e2493f4df56233b0e11185d74d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd887de4761e2493f4df56233b0e11185d74d63", "html_url": "https://github.com/rust-lang/rust/commit/2dd887de4761e2493f4df56233b0e11185d74d63"}], "stats": {"total": 491, "additions": 315, "deletions": 176}, "files": [{"sha": "f7685772485701ba3b02dd83b0cf517f909b6891", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -1092,6 +1092,7 @@ dependencies = [\n  \"cargo_metadata\",\n  \"log\",\n  \"ra_arena\",\n+ \"ra_cargo_watch\",\n  \"ra_cfg\",\n  \"ra_db\",\n  \"rustc-hash\","}, {"sha": "bffe5eb00a0c1fe14bec46abc23078c34d0ea484", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 96, "deletions": 79, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -9,8 +9,8 @@ use lsp_types::{\n };\n use std::{\n     io::{BufRead, BufReader},\n-    path::PathBuf,\n-    process::{Command, Stdio},\n+    path::{Path, PathBuf},\n+    process::{Child, Command, Stdio},\n     thread::JoinHandle,\n     time::Instant,\n };\n@@ -246,102 +246,119 @@ enum CheckEvent {\n     End,\n }\n \n+pub fn run_cargo(\n+    args: &[String],\n+    current_dir: Option<&Path>,\n+    on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,\n+) -> Child {\n+    let mut command = Command::new(\"cargo\");\n+    if let Some(current_dir) = current_dir {\n+        command.current_dir(current_dir);\n+    }\n+\n+    let mut child = command\n+        .args(args)\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::null())\n+        .stdin(Stdio::null())\n+        .spawn()\n+        .expect(\"couldn't launch cargo\");\n+\n+    // We manually read a line at a time, instead of using serde's\n+    // stream deserializers, because the deserializer cannot recover\n+    // from an error, resulting in it getting stuck, because we try to\n+    // be resillient against failures.\n+    //\n+    // Because cargo only outputs one JSON object per line, we can\n+    // simply skip a line if it doesn't parse, which just ignores any\n+    // erroneus output.\n+    let stdout = BufReader::new(child.stdout.take().unwrap());\n+    for line in stdout.lines() {\n+        let line = match line {\n+            Ok(line) => line,\n+            Err(err) => {\n+                log::error!(\"Couldn't read line from cargo: {}\", err);\n+                continue;\n+            }\n+        };\n+\n+        let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n+        let message = match message {\n+            Ok(message) => message,\n+            Err(err) => {\n+                log::error!(\"Invalid json from cargo check, ignoring ({}): {:?} \", err, line);\n+                continue;\n+            }\n+        };\n+\n+        if !on_message(message) {\n+            break;\n+        }\n+    }\n+\n+    child\n+}\n+\n impl WatchThread {\n     fn dummy() -> WatchThread {\n         WatchThread { handle: None, message_recv: never() }\n     }\n \n-    fn new(options: &CheckOptions, workspace_root: &PathBuf) -> WatchThread {\n+    fn new(options: &CheckOptions, workspace_root: &Path) -> WatchThread {\n         let mut args: Vec<String> = vec![\n             options.command.clone(),\n             \"--workspace\".to_string(),\n             \"--message-format=json\".to_string(),\n             \"--manifest-path\".to_string(),\n-            format!(\"{}/Cargo.toml\", workspace_root.to_string_lossy()),\n+            format!(\"{}/Cargo.toml\", workspace_root.display()),\n         ];\n         if options.all_targets {\n             args.push(\"--all-targets\".to_string());\n         }\n         args.extend(options.args.iter().cloned());\n \n         let (message_send, message_recv) = unbounded();\n-        let enabled = options.enable;\n-        let handle = std::thread::spawn(move || {\n-            if !enabled {\n-                return;\n-            }\n-\n-            let mut command = Command::new(\"cargo\")\n-                .args(&args)\n-                .stdout(Stdio::piped())\n-                .stderr(Stdio::null())\n-                .stdin(Stdio::null())\n-                .spawn()\n-                .expect(\"couldn't launch cargo\");\n-\n-            // If we trigger an error here, we will do so in the loop instead,\n-            // which will break out of the loop, and continue the shutdown\n-            let _ = message_send.send(CheckEvent::Begin);\n-\n-            // We manually read a line at a time, instead of using serde's\n-            // stream deserializers, because the deserializer cannot recover\n-            // from an error, resulting in it getting stuck, because we try to\n-            // be resillient against failures.\n-            //\n-            // Because cargo only outputs one JSON object per line, we can\n-            // simply skip a line if it doesn't parse, which just ignores any\n-            // erroneus output.\n-            let stdout = BufReader::new(command.stdout.take().unwrap());\n-            for line in stdout.lines() {\n-                let line = match line {\n-                    Ok(line) => line,\n-                    Err(err) => {\n-                        log::error!(\"Couldn't read line from cargo: {}\", err);\n-                        continue;\n-                    }\n-                };\n-\n-                let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n-                let message = match message {\n-                    Ok(message) => message,\n-                    Err(err) => {\n-                        log::error!(\n-                            \"Invalid json from cargo check, ignoring ({}): {:?} \",\n-                            err,\n-                            line\n-                        );\n-                        continue;\n+        let workspace_root = workspace_root.to_owned();\n+        let handle = if options.enable {\n+            Some(std::thread::spawn(move || {\n+                // If we trigger an error here, we will do so in the loop instead,\n+                // which will break out of the loop, and continue the shutdown\n+                let _ = message_send.send(CheckEvent::Begin);\n+\n+                let mut child = run_cargo(&args, Some(&workspace_root), &mut |message| {\n+                    // Skip certain kinds of messages to only spend time on what's useful\n+                    match &message {\n+                        Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n+                        Message::BuildScriptExecuted(_) => return true,\n+                        Message::Unknown => return true,\n+                        _ => {}\n                     }\n-                };\n-\n-                // Skip certain kinds of messages to only spend time on what's useful\n-                match &message {\n-                    Message::CompilerArtifact(artifact) if artifact.fresh => continue,\n-                    Message::BuildScriptExecuted(_) => continue,\n-                    Message::Unknown => continue,\n-                    _ => {}\n-                }\n \n-                match message_send.send(CheckEvent::Msg(message)) {\n-                    Ok(()) => {}\n-                    Err(_err) => {\n-                        // The send channel was closed, so we want to shutdown\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // We can ignore any error here, as we are already in the progress\n-            // of shutting down.\n-            let _ = message_send.send(CheckEvent::End);\n-\n-            // It is okay to ignore the result, as it only errors if the process is already dead\n-            let _ = command.kill();\n-\n-            // Again, we don't care about the exit status so just ignore the result\n-            let _ = command.wait();\n-        });\n-        WatchThread { handle: Some(handle), message_recv }\n+                    match message_send.send(CheckEvent::Msg(message)) {\n+                        Ok(()) => {}\n+                        Err(_err) => {\n+                            // The send channel was closed, so we want to shutdown\n+                            return false;\n+                        }\n+                    };\n+\n+                    true\n+                });\n+\n+                // We can ignore any error here, as we are already in the progress\n+                // of shutting down.\n+                let _ = message_send.send(CheckEvent::End);\n+\n+                // It is okay to ignore the result, as it only errors if the process is already dead\n+                let _ = child.kill();\n+\n+                // Again, we don't care about the exit status so just ignore the result\n+                let _ = child.wait();\n+            }))\n+        } else {\n+            None\n+        };\n+        WatchThread { handle, message_recv }\n     }\n }\n "}, {"sha": "e371f849dff95edd8db4e0b1950ef1725a68da52", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -6,7 +6,11 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, ops, str::FromStr};\n+use std::{\n+    fmt, ops,\n+    path::{Path, PathBuf},\n+    str::FromStr,\n+};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n@@ -144,7 +148,7 @@ pub struct Env {\n // crate. We store a map to allow remap it to ExternSourceId\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct ExternSource {\n-    extern_paths: FxHashMap<String, ExternSourceId>,\n+    extern_paths: FxHashMap<PathBuf, ExternSourceId>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -294,13 +298,10 @@ impl Env {\n }\n \n impl ExternSource {\n-    pub fn extern_path(&self, path: &str) -> Option<(ExternSourceId, RelativePathBuf)> {\n+    pub fn extern_path(&self, path: impl AsRef<Path>) -> Option<(ExternSourceId, RelativePathBuf)> {\n+        let path = path.as_ref();\n         self.extern_paths.iter().find_map(|(root_path, id)| {\n-            if path.starts_with(root_path) {\n-                let mut rel_path = &path[root_path.len()..];\n-                if rel_path.starts_with(\"/\") {\n-                    rel_path = &rel_path[1..];\n-                }\n+            if let Ok(rel_path) = path.strip_prefix(root_path) {\n                 let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n                 Some((id.clone(), rel_path))\n             } else {\n@@ -309,8 +310,8 @@ impl ExternSource {\n         })\n     }\n \n-    pub fn set_extern_path(&mut self, root_path: &str, root: ExternSourceId) {\n-        self.extern_paths.insert(root_path.to_owned(), root);\n+    pub fn set_extern_path(&mut self, root_path: &Path, root: ExternSourceId) {\n+        self.extern_paths.insert(root_path.to_path_buf(), root);\n     }\n }\n "}, {"sha": "22300548a7ffd323f356d6a618e0d9d773eef853", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -16,6 +16,7 @@ cargo_metadata = \"0.9.1\"\n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n+ra_cargo_watch = { path = \"../ra_cargo_watch\" }\n \n serde = { version = \"1.0.104\", features = [\"derive\"] }\n serde_json = \"1.0.48\""}, {"sha": "10ecfa9513d154744ee84f32e7d8074f29b851a0", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -3,8 +3,9 @@\n use std::path::{Path, PathBuf};\n \n use anyhow::{Context, Result};\n-use cargo_metadata::{CargoOpt, MetadataCommand};\n+use cargo_metadata::{CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_cargo_watch::run_cargo;\n use ra_db::Edition;\n use rustc_hash::FxHashMap;\n use serde::Deserialize;\n@@ -35,11 +36,19 @@ pub struct CargoFeatures {\n     /// List of features to activate.\n     /// This will be ignored if `cargo_all_features` is true.\n     pub features: Vec<String>,\n+\n+    /// Runs cargo check on launch to figure out the correct values of OUT_DIR\n+    pub load_out_dirs_from_check: bool,\n }\n \n impl Default for CargoFeatures {\n     fn default() -> Self {\n-        CargoFeatures { no_default_features: false, all_features: true, features: Vec::new() }\n+        CargoFeatures {\n+            no_default_features: false,\n+            all_features: true,\n+            features: Vec::new(),\n+            load_out_dirs_from_check: false,\n+        }\n     }\n }\n \n@@ -60,6 +69,7 @@ struct PackageData {\n     dependencies: Vec<PackageDependency>,\n     edition: Edition,\n     features: Vec<String>,\n+    out_dir: Option<PathBuf>,\n }\n \n #[derive(Debug, Clone)]\n@@ -131,6 +141,9 @@ impl Package {\n     ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n         ws.packages[self].dependencies.iter()\n     }\n+    pub fn out_dir(self, ws: &CargoWorkspace) -> Option<&Path> {\n+        ws.packages[self].out_dir.as_ref().map(PathBuf::as_path)\n+    }\n }\n \n impl Target {\n@@ -173,6 +186,12 @@ impl CargoWorkspace {\n         let meta = meta.exec().with_context(|| {\n             format!(\"Failed to run `cargo metadata --manifest-path {}`\", cargo_toml.display())\n         })?;\n+\n+        let mut out_dir_by_id = FxHashMap::default();\n+        if cargo_features.load_out_dirs_from_check {\n+            out_dir_by_id = load_out_dirs(cargo_toml, cargo_features);\n+        }\n+\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n         let mut targets = Arena::default();\n@@ -193,6 +212,7 @@ impl CargoWorkspace {\n                 edition,\n                 dependencies: Vec::new(),\n                 features: Vec::new(),\n+                out_dir: out_dir_by_id.get(&id).cloned(),\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n@@ -252,3 +272,46 @@ impl CargoWorkspace {\n         &self.workspace_root\n     }\n }\n+\n+pub fn load_out_dirs(\n+    cargo_toml: &Path,\n+    cargo_features: &CargoFeatures,\n+) -> FxHashMap<PackageId, PathBuf> {\n+    let mut args: Vec<String> = vec![\n+        \"check\".to_string(),\n+        \"--message-format=json\".to_string(),\n+        \"--manifest-path\".to_string(),\n+        format!(\"{}\", cargo_toml.display()),\n+    ];\n+\n+    if cargo_features.all_features {\n+        args.push(\"--all-features\".to_string());\n+    } else if cargo_features.no_default_features {\n+        // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+        // https://github.com/oli-obk/cargo_metadata/issues/79\n+        args.push(\"--no-default-features\".to_string());\n+    } else if !cargo_features.features.is_empty() {\n+        for feature in &cargo_features.features {\n+            args.push(feature.clone());\n+        }\n+    }\n+\n+    let mut res = FxHashMap::default();\n+    let mut child = run_cargo(&args, cargo_toml.parent(), &mut |message| {\n+        match message {\n+            Message::BuildScriptExecuted(message) => {\n+                let package_id = message.package_id;\n+                let out_dir = message.out_dir;\n+                res.insert(package_id, out_dir);\n+            }\n+\n+            Message::CompilerArtifact(_) => (),\n+            Message::CompilerMessage(_) => (),\n+            Message::Unknown => (),\n+        }\n+        true\n+    });\n+\n+    let _ = child.wait();\n+    res\n+}"}, {"sha": "336446e58c3941fb3f566dbd85e4ff74dbd3aca3", "filename": "crates/ra_project_model/src/json_project.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -22,6 +22,7 @@ pub struct Crate {\n     pub(crate) deps: Vec<Dep>,\n     pub(crate) atom_cfgs: FxHashSet<String>,\n     pub(crate) key_value_cfgs: FxHashMap<String, String>,\n+    pub(crate) out_dir: Option<PathBuf>,\n }\n \n #[derive(Clone, Copy, Debug, Deserialize)]"}, {"sha": "081b1fec2f55481925fe3fbb52153c91497c1faa", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -150,6 +150,29 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn out_dirs(&self) -> Vec<PathBuf> {\n+        match self {\n+            ProjectWorkspace::Json { project } => {\n+                let mut out_dirs = Vec::with_capacity(project.crates.len());\n+                for krate in &project.crates {\n+                    if let Some(out_dir) = &krate.out_dir {\n+                        out_dirs.push(out_dir.to_path_buf());\n+                    }\n+                }\n+                out_dirs\n+            }\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => {\n+                let mut out_dirs = Vec::with_capacity(cargo.packages().len());\n+                for pkg in cargo.packages() {\n+                    if let Some(out_dir) = pkg.out_dir(&cargo) {\n+                        out_dirs.push(out_dir.to_path_buf());\n+                    }\n+                }\n+                out_dirs\n+            }\n+        }\n+    }\n+\n     pub fn n_packages(&self) -> usize {\n         match self {\n             ProjectWorkspace::Json { project } => project.crates.len(),\n@@ -162,7 +185,7 @@ impl ProjectWorkspace {\n     pub fn to_crate_graph(\n         &self,\n         default_cfg_options: &CfgOptions,\n-        outdirs: &FxHashMap<String, (ExternSourceId, String)>,\n+        extern_source_roots: &FxHashMap<PathBuf, ExternSourceId>,\n         load: &mut dyn FnMut(&Path) -> Option<FileId>,\n     ) -> CrateGraph {\n         let mut crate_graph = CrateGraph::default();\n@@ -187,6 +210,16 @@ impl ProjectWorkspace {\n                             opts\n                         };\n \n+                        let mut env = Env::default();\n+                        let mut extern_source = ExternSource::default();\n+                        if let Some(out_dir) = &krate.out_dir {\n+                            // FIXME: We probably mangle non UTF-8 paths here, figure out a better solution\n+                            env.set(\"OUT_DIR\", out_dir.to_string_lossy().to_string());\n+                            if let Some(&extern_source_id) = extern_source_roots.get(out_dir) {\n+                                extern_source.set_extern_path(&out_dir, extern_source_id);\n+                            }\n+                        }\n+\n                         // FIXME: No crate name in json definition such that we cannot add OUT_DIR to env\n                         crates.insert(\n                             crate_id,\n@@ -196,8 +229,8 @@ impl ProjectWorkspace {\n                                 // FIXME json definitions can store the crate name\n                                 None,\n                                 cfg_options,\n-                                Env::default(),\n-                                Default::default(),\n+                                env,\n+                                extern_source,\n                             ),\n                         );\n                     }\n@@ -235,13 +268,8 @@ impl ProjectWorkspace {\n                             opts\n                         };\n \n-                        let mut env = Env::default();\n-                        let mut extern_source = ExternSource::default();\n-                        if let Some((id, path)) = outdirs.get(krate.name(&sysroot)) {\n-                            env.set(\"OUT_DIR\", path.clone());\n-                            extern_source.set_extern_path(&path, *id);\n-                        }\n-\n+                        let env = Env::default();\n+                        let extern_source = ExternSource::default();\n                         let crate_id = crate_graph.add_crate_root(\n                             file_id,\n                             Edition::Edition2018,\n@@ -292,9 +320,12 @@ impl ProjectWorkspace {\n                             };\n                             let mut env = Env::default();\n                             let mut extern_source = ExternSource::default();\n-                            if let Some((id, path)) = outdirs.get(pkg.name(&cargo)) {\n-                                env.set(\"OUT_DIR\", path.clone());\n-                                extern_source.set_extern_path(&path, *id);\n+                            if let Some(out_dir) = pkg.out_dir(cargo) {\n+                                // FIXME: We probably mangle non UTF-8 paths here, figure out a better solution\n+                                env.set(\"OUT_DIR\", out_dir.to_string_lossy().to_string());\n+                                if let Some(&extern_source_id) = extern_source_roots.get(out_dir) {\n+                                    extern_source.set_extern_path(&out_dir, extern_source_id);\n+                                }\n                             }\n                             let crate_id = crate_graph.add_crate_root(\n                                 file_id,"}, {"sha": "3cf394bb41ff2043487410dda6c34df4096ab7c4", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -28,10 +28,12 @@ pub(crate) enum Command {\n         only: Option<String>,\n         with_deps: bool,\n         path: PathBuf,\n+        load_output_dirs: bool,\n     },\n     Bench {\n         path: PathBuf,\n         what: BenchWhat,\n+        load_output_dirs: bool,\n     },\n     RunServer,\n     Version,\n@@ -136,8 +138,9 @@ USAGE:\n     rust-analyzer analysis-stats [FLAGS] [OPTIONS] [PATH]\n \n FLAGS:\n-    -h, --help            Prints help information\n+    -h, --help              Prints help information\n         --memory-usage\n+        --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n     -v, --verbose\n     -q, --quiet\n \n@@ -154,6 +157,7 @@ ARGS:\n                 let memory_usage = matches.contains(\"--memory-usage\");\n                 let only: Option<String> = matches.opt_value_from_str([\"-o\", \"--only\"])?;\n                 let with_deps: bool = matches.contains(\"--with-deps\");\n+                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n                 let path = {\n                     let mut trailing = matches.free()?;\n                     if trailing.len() != 1 {\n@@ -162,7 +166,7 @@ ARGS:\n                     trailing.pop().unwrap().into()\n                 };\n \n-                Command::Stats { randomize, memory_usage, only, with_deps, path }\n+                Command::Stats { randomize, memory_usage, only, with_deps, path, load_output_dirs }\n             }\n             \"analysis-bench\" => {\n                 if matches.contains([\"-h\", \"--help\"]) {\n@@ -174,7 +178,8 @@ USAGE:\n     rust-analyzer analysis-bench [FLAGS] [OPTIONS]\n \n FLAGS:\n-    -h, --help        Prints help information\n+    -h, --help          Prints help information\n+    --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n     -v, --verbose\n \n OPTIONS:\n@@ -201,7 +206,8 @@ ARGS:\n                         \"exactly one of  `--highlight`, `--complete` or `--goto-def` must be set\"\n                     ),\n                 };\n-                Command::Bench { path, what }\n+                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n+                Command::Bench { path, what, load_output_dirs }\n             }\n             _ => {\n                 eprintln!("}, {"sha": "a744a6695ddc6029229a4e3aa9354202a8162e75", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -19,19 +19,25 @@ fn main() -> Result<()> {\n         args::Command::Parse { no_dump } => cli::parse(no_dump)?,\n         args::Command::Symbols => cli::symbols()?,\n         args::Command::Highlight { rainbow } => cli::highlight(rainbow)?,\n-        args::Command::Stats { randomize, memory_usage, only, with_deps, path } => {\n-            cli::analysis_stats(\n-                args.verbosity,\n-                memory_usage,\n-                path.as_ref(),\n-                only.as_ref().map(String::as_ref),\n-                with_deps,\n-                randomize,\n-            )?\n-        }\n-\n-        args::Command::Bench { path, what } => {\n-            cli::analysis_bench(args.verbosity, path.as_ref(), what)?\n+        args::Command::Stats {\n+            randomize,\n+            memory_usage,\n+            only,\n+            with_deps,\n+            path,\n+            load_output_dirs,\n+        } => cli::analysis_stats(\n+            args.verbosity,\n+            memory_usage,\n+            path.as_ref(),\n+            only.as_ref().map(String::as_ref),\n+            with_deps,\n+            randomize,\n+            load_output_dirs,\n+        )?,\n+\n+        args::Command::Bench { path, what, load_output_dirs } => {\n+            cli::analysis_bench(args.verbosity, path.as_ref(), what, load_output_dirs)?\n         }\n \n         args::Command::RunServer => run_server()?,"}, {"sha": "7164b0adeb26faffd28a8ba5bae20e498f6f4799", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -42,12 +42,17 @@ fn rsplit_at_char(s: &str, c: char) -> Result<(&str, &str)> {\n     Ok((&s[..idx], &s[idx + 1..]))\n }\n \n-pub fn analysis_bench(verbosity: Verbosity, path: &Path, what: BenchWhat) -> Result<()> {\n+pub fn analysis_bench(\n+    verbosity: Verbosity,\n+    path: &Path,\n+    what: BenchWhat,\n+    load_output_dirs: bool,\n+) -> Result<()> {\n     ra_prof::init();\n \n     let start = Instant::now();\n     eprint!(\"loading: \");\n-    let (mut host, roots) = load_cargo(path)?;\n+    let (mut host, roots) = load_cargo(path, load_output_dirs)?;\n     let db = host.raw_database();\n     eprintln!(\"{:?}\\n\", start.elapsed());\n "}, {"sha": "27459be8c871c8b289ecd0a8e64a7182333c1ed2", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -23,9 +23,10 @@ pub fn analysis_stats(\n     only: Option<&str>,\n     with_deps: bool,\n     randomize: bool,\n+    load_output_dirs: bool,\n ) -> Result<()> {\n     let db_load_time = Instant::now();\n-    let (mut host, roots) = load_cargo(path)?;\n+    let (mut host, roots) = load_cargo(path, load_output_dirs)?;\n     let db = host.raw_database();\n     println!(\"Database loaded, {} roots, {:?}\", roots.len(), db_load_time.elapsed());\n     let analysis_time = Instant::now();"}, {"sha": "54e2fa1a7c8b38bfce938a9a047218d5ae9b0278", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -1,13 +1,13 @@\n //! Loads a Cargo project into a static instance of analysis, without support\n //! for incorporating changes.\n \n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use anyhow::Result;\n use crossbeam_channel::{unbounded, Receiver};\n-use ra_db::{CrateGraph, FileId, SourceRootId};\n+use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n-use ra_project_model::{get_rustc_cfg_options, PackageRoot, ProjectWorkspace};\n+use ra_project_model::{get_rustc_cfg_options, CargoFeatures, PackageRoot, ProjectWorkspace};\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -22,10 +22,21 @@ fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n \n pub(crate) fn load_cargo(\n     root: &Path,\n+    load_out_dirs_from_check: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let ws = ProjectWorkspace::discover(root.as_ref(), &Default::default())?;\n-    let project_roots = ws.to_roots();\n+    let ws = ProjectWorkspace::discover(\n+        root.as_ref(),\n+        &CargoFeatures { load_out_dirs_from_check, ..Default::default() },\n+    )?;\n+\n+    let mut extern_dirs = FxHashSet::default();\n+    extern_dirs.extend(ws.out_dirs());\n+\n+    let mut project_roots = ws.to_roots();\n+    project_roots\n+        .extend(extern_dirs.iter().map(|path| PackageRoot::new(path.to_path_buf(), false)));\n+\n     let (sender, receiver) = unbounded();\n     let sender = Box::new(move |t| sender.send(t).unwrap());\n     let (mut vfs, roots) = Vfs::new(\n@@ -44,24 +55,6 @@ pub(crate) fn load_cargo(\n         Watch(false),\n     );\n \n-    // FIXME: cfg options?\n-    let default_cfg_options = {\n-        let mut opts = get_rustc_cfg_options();\n-        opts.insert_atom(\"test\".into());\n-        opts.insert_atom(\"debug_assertion\".into());\n-        opts\n-    };\n-\n-    // FIXME: outdirs?\n-    let outdirs = FxHashMap::default();\n-\n-    let crate_graph = ws.to_crate_graph(&default_cfg_options, &outdirs, &mut |path: &Path| {\n-        let vfs_file = vfs.load(path);\n-        log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n-        vfs_file.map(vfs_file_to_id)\n-    });\n-    log::debug!(\"crate graph: {:?}\", crate_graph);\n-\n     let source_roots = roots\n         .iter()\n         .map(|&vfs_root| {\n@@ -74,23 +67,24 @@ pub(crate) fn load_cargo(\n             (source_root_id, project_root)\n         })\n         .collect::<FxHashMap<_, _>>();\n-    let host = load(&source_roots, crate_graph, &mut vfs, receiver);\n+    let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs);\n     Ok((host, source_roots))\n }\n \n pub(crate) fn load(\n     source_roots: &FxHashMap<SourceRootId, PackageRoot>,\n-    crate_graph: CrateGraph,\n+    ws: ProjectWorkspace,\n     vfs: &mut Vfs,\n     receiver: Receiver<VfsTask>,\n+    extern_dirs: FxHashSet<PathBuf>,\n ) -> AnalysisHost {\n     let lru_cap = std::env::var(\"RA_LRU_CAP\").ok().and_then(|it| it.parse::<usize>().ok());\n     let mut host = AnalysisHost::new(lru_cap);\n     let mut analysis_change = AnalysisChange::new();\n-    analysis_change.set_crate_graph(crate_graph);\n \n     // wait until Vfs has loaded all roots\n     let mut roots_loaded = FxHashSet::default();\n+    let mut extern_source_roots = FxHashMap::default();\n     for task in receiver {\n         vfs.handle_task(task);\n         let mut done = false;\n@@ -110,6 +104,11 @@ pub(crate) fn load(\n                         source_roots[&source_root_id].path().display().to_string(),\n                     );\n \n+                    let vfs_root_path = vfs.root2path(root);\n+                    if extern_dirs.contains(&vfs_root_path) {\n+                        extern_source_roots.insert(vfs_root_path, ExternSourceId(root.0));\n+                    }\n+\n                     let mut file_map = FxHashMap::default();\n                     for (vfs_file, path, text) in files {\n                         let file_id = vfs_file_to_id(vfs_file);\n@@ -136,6 +135,23 @@ pub(crate) fn load(\n         }\n     }\n \n+    // FIXME: cfg options?\n+    let default_cfg_options = {\n+        let mut opts = get_rustc_cfg_options();\n+        opts.insert_atom(\"test\".into());\n+        opts.insert_atom(\"debug_assertion\".into());\n+        opts\n+    };\n+\n+    let crate_graph =\n+        ws.to_crate_graph(&default_cfg_options, &extern_source_roots, &mut |path: &Path| {\n+            let vfs_file = vfs.load(path);\n+            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n+            vfs_file.map(vfs_file_to_id)\n+        });\n+    log::debug!(\"crate graph: {:?}\", crate_graph);\n+    analysis_change.set_crate_graph(crate_graph);\n+\n     host.apply_change(analysis_change);\n     host\n }\n@@ -149,7 +165,7 @@ mod tests {\n     #[test]\n     fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n-        let (host, _roots) = load_cargo(path).unwrap();\n+        let (host, _roots) = load_cargo(path, false).unwrap();\n         let n_crates = Crate::all(host.raw_database()).len();\n         // RA has quite a few crates, but the exact count doesn't matter\n         assert!(n_crates > 20);"}, {"sha": "103b2b53c456fa83d35d0b316b41fd99e46d398b", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -48,9 +48,6 @@ pub struct ServerConfig {\n     /// Fine grained feature flags to disable specific features.\n     pub feature_flags: FxHashMap<String, bool>,\n \n-    /// Fine grained controls for additional `OUT_DIR` env variables\n-    pub additional_out_dirs: FxHashMap<String, String>,\n-\n     pub rustfmt_args: Vec<String>,\n \n     /// Cargo feature configurations.\n@@ -76,7 +73,6 @@ impl Default for ServerConfig {\n             cargo_watch_all_targets: true,\n             with_sysroot: true,\n             feature_flags: FxHashMap::default(),\n-            additional_out_dirs: FxHashMap::default(),\n             cargo_features: Default::default(),\n             rustfmt_args: Vec::new(),\n             vscode_lldb: false,"}, {"sha": "a8a5894d2f52122969c3b738c438a874c170b1b3", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -204,7 +204,6 @@ pub fn main_loop(\n             Watch(!config.use_client_watching),\n             options,\n             feature_flags,\n-            config.additional_out_dirs,\n         )\n     };\n "}, {"sha": "c4244fee24e049335910ec41b3ce68ec0e9c621b", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -82,7 +82,6 @@ impl WorldState {\n         watch: Watch,\n         options: Options,\n         feature_flags: FeatureFlags,\n-        additional_out_dirs: FxHashMap<String, String>,\n     ) -> WorldState {\n         let mut change = AnalysisChange::new();\n \n@@ -105,11 +104,14 @@ impl WorldState {\n             }));\n         }\n \n-        let extern_dirs: FxHashSet<_> =\n-            additional_out_dirs.iter().map(|(_, path)| (PathBuf::from(path))).collect();\n+        let mut extern_dirs = FxHashSet::default();\n+        for ws in workspaces.iter() {\n+            extern_dirs.extend(ws.out_dirs());\n+        }\n+\n         let mut extern_source_roots = FxHashMap::default();\n \n-        roots.extend(additional_out_dirs.iter().map(|(_, path)| {\n+        roots.extend(extern_dirs.iter().map(|path| {\n             let mut filter = RustPackageFilterBuilder::default().set_member(false);\n             for glob in exclude_globs.iter() {\n                 filter = filter.exclude(glob.clone());\n@@ -148,17 +150,9 @@ impl WorldState {\n             vfs_file.map(|f| FileId(f.0))\n         };\n \n-        let mut outdirs = FxHashMap::default();\n-        for (name, path) in additional_out_dirs {\n-            let path = PathBuf::from(&path);\n-            if let Some(id) = extern_source_roots.get(&path) {\n-                outdirs.insert(name, (id.clone(), path.to_string_lossy().replace(\"\\\\\", \"/\")));\n-            }\n-        }\n-\n         workspaces\n             .iter()\n-            .map(|ws| ws.to_crate_graph(&default_cfg_options, &outdirs, &mut load))\n+            .map(|ws| ws.to_crate_graph(&default_cfg_options, &extern_source_roots, &mut load))\n             .for_each(|graph| {\n                 crate_graph.extend(graph);\n             });"}, {"sha": "b9e0ffd2be45beecf901dfb5bab0b2fba17ffce4", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -237,11 +237,6 @@\n                     \"default\": true,\n                     \"description\": \"Whether to ask for permission before downloading any files from the Internet\"\n                 },\n-                \"rust-analyzer.additionalOutDirs\": {\n-                    \"type\": \"object\",\n-                    \"default\": {},\n-                    \"markdownDescription\": \"Fine grained controls for OUT_DIR `env!(\\\"OUT_DIR\\\")` variable. e.g. `{\\\"foo\\\":\\\"/path/to/foo\\\"}`, \"\n-                },\n                 \"rust-analyzer.serverPath\": {\n                     \"type\": [\n                         \"null\",\n@@ -362,6 +357,11 @@\n                     },\n                     \"default\": [],\n                     \"description\": \"List of features to activate\"\n+                },\n+                \"rust-analyzer.cargoFeatures.loadOutDirsFromCheck\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": false,\n+                    \"markdownDescription\": \"Run `cargo check` on startup to get the correct value for package OUT_DIRs\"\n                 }\n             }\n         },"}, {"sha": "08d821dd0a86e8003afc0093b0b7fccc5a9ba075", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -42,7 +42,6 @@ export async function createClient(config: Config, serverPath: string): Promise<\n             excludeGlobs: config.excludeGlobs,\n             useClientWatching: config.useClientWatching,\n             featureFlags: config.featureFlags,\n-            additionalOutDirs: config.additionalOutDirs,\n             withSysroot: config.withSysroot,\n             cargoFeatures: config.cargoFeatures,\n             rustfmtArgs: config.rustfmtArgs,"}, {"sha": "b45b14bef38d5f69f45a6f12e69b4d9e29fb4d9f", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ec1312ef38092a4c8f49b57185707c95e00129fa/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=ec1312ef38092a4c8f49b57185707c95e00129fa", "patch": "@@ -22,6 +22,7 @@ export interface CargoFeatures {\n     noDefaultFeatures: boolean;\n     allFeatures: boolean;\n     features: string[];\n+    loadOutDirsFromCheck: boolean;\n }\n \n export const enum UpdatesChannel {\n@@ -202,8 +203,8 @@ export class Config {\n     get excludeGlobs() { return this.cfg.get(\"excludeGlobs\") as string[]; }\n     get useClientWatching() { return this.cfg.get(\"useClientWatching\") as boolean; }\n     get featureFlags() { return this.cfg.get(\"featureFlags\") as Record<string, boolean>; }\n-    get additionalOutDirs() { return this.cfg.get(\"additionalOutDirs\") as Record<string, string>; }\n     get rustfmtArgs() { return this.cfg.get(\"rustfmtArgs\") as string[]; }\n+    get loadOutDirsFromCheck() { return this.cfg.get(\"loadOutDirsFromCheck\") as boolean; }\n \n     get cargoWatchOptions(): CargoWatchOptions {\n         return {\n@@ -219,6 +220,7 @@ export class Config {\n             noDefaultFeatures: this.cfg.get(\"cargoFeatures.noDefaultFeatures\") as boolean,\n             allFeatures: this.cfg.get(\"cargoFeatures.allFeatures\") as boolean,\n             features: this.cfg.get(\"cargoFeatures.features\") as string[],\n+            loadOutDirsFromCheck: this.cfg.get(\"cargoFeatures.loadOutDirsFromCheck\") as boolean,\n         };\n     }\n "}]}