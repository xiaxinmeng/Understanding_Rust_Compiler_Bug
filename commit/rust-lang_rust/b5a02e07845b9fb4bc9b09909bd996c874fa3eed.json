{"sha": "b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YTAyZTA3ODQ1YjlmYjRiYzliMDk5MDliZDk5NmM4NzRmYTNlZWQ=", "commit": {"author": {"name": "Do Nhat Minh", "email": "mrordinaire@gmail.com", "date": "2013-09-19T04:03:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:22:35Z"}, "message": "wrapping libuv signal for use in Rust\ndescriptive names\neasier-to-use api\nreorganize and document", "tree": {"sha": "92d0986b83e14ca4b637cb933d11e46b272c5fc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d0986b83e14ca4b637cb933d11e46b272c5fc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "html_url": "https://github.com/rust-lang/rust/commit/b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/comments", "author": null, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816e46dd633cf4cc5741dde6ce3bffd4a9ba67a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/816e46dd633cf4cc5741dde6ce3bffd4a9ba67a7", "html_url": "https://github.com/rust-lang/rust/commit/816e46dd633cf4cc5741dde6ce3bffd4a9ba67a7"}], "stats": {"total": 392, "additions": 392, "deletions": 0}, "files": [{"sha": "758c97791658f878094960a97298377f34bdd999", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -326,6 +326,9 @@ pub mod native {\n /// Mock implementations for testing\n mod mock;\n \n+/// Signal handling\n+pub mod signal;\n+\n /// The default buffer size for various I/O operations\n static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n "}, {"sha": "d3c260d361c63da63c158726dac29b855a0a2864", "filename": "src/libstd/rt/io/signal.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use comm::{Port, SharedChan, stream};\n+use hashmap;\n+use option::{Some, None};\n+use result::{Err, Ok};\n+use rt::io::io_error;\n+use rt::local::Local;\n+use rt::rtio::{EventLoop, RtioSignalObject};\n+use rt::sched::Scheduler;\n+\n+#[deriving(Eq, IterBytes)]\n+pub enum Signum {\n+    /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n+    Break = 21i,\n+    /// Equivalent to SIGHUP, delivered when the user closes the terminal\n+    /// window. On delivery of HangUp, the program is given approximately\n+    /// 10 seconds to perfom any cleanup. After that, Windows will\n+    /// unconditionally terminate it.\n+    HangUp = 1i,\n+    /// Equivalent to SIGINT, delivered when the user presses Ctrl-c.\n+    Interrupt = 2i,\n+    /// Equivalent to SIGQUIT, delivered when the user presses Ctrl-\\.\n+    Quit = 3i,\n+    /// Equivalent to SIGTSTP, delivered when the user presses Ctrl-z.\n+    StopTemporarily = 20i,\n+    /// Equivalent to SIGUSR1.\n+    User1 = 10i,\n+    /// Equivalent to SIGUSR2.\n+    User2 = 12i,\n+    /// Equivalent to SIGWINCH, delivered when the console has been resized.\n+    /// WindowSizeChange may not be delivered in a timely manner; size change\n+    /// will only be detected when the cursor is being moved.\n+    WindowSizeChange = 28i,\n+}\n+\n+/// Listener provides a port to listen for registered signals.\n+///\n+/// Listener automatically unregisters its handles once it is out of scope.\n+/// However, clients can still unregister signums manually.\n+///\n+/// Example usage:\n+///\n+/// ```rust\n+/// use std::rt::io::signal;\n+/// use std::task;\n+///\n+/// let mut listener = signal::Listener();\n+/// listener.register(signal::Interrupt);\n+///\n+/// do task::spawn {\n+///     loop {\n+///         match listener.recv() {\n+///             signal::Interrupt => println(\"Got Interrupt'ed\"),\n+///             _ => (),\n+///         }\n+///     }\n+/// }\n+///\n+/// ```\n+pub struct Listener {\n+    /// A map from signums to handles to keep the handles in memory\n+    priv handles: hashmap::HashMap<Signum, ~RtioSignalObject>,\n+    /// chan is where all the handles send signums, which are received by\n+    /// the clients from port.\n+    priv chan: SharedChan<Signum>,\n+    /// Clients of Listener can `recv()` from this port\n+    port: Port<Signum>,\n+}\n+\n+impl Listener {\n+    pub fn new() -> Listener {\n+        let (port, chan) = stream();\n+        Listener {\n+            chan: SharedChan::new(chan),\n+            port: port,\n+            handles: hashmap::HashMap::new(),\n+        }\n+    }\n+\n+    /// Listen for a signal, returning true when successfully registered for\n+    /// signum. Signals can be received using `recv()`.\n+    pub fn register(&mut self, signum: Signum) -> bool {\n+        match self.handles.find(&signum) {\n+            Some(_) => true, // self is already listening to signum, so succeed\n+            None => {\n+                let chan = self.chan.clone();\n+                let handle = unsafe {\n+                    rtdebug!(\"Listener::register: borrowing io to init UvSignal\");\n+                    let sched: *mut Scheduler = Local::unsafe_borrow();\n+                    rtdebug!(\"about to init handle\");\n+                    (*sched).event_loop.signal(signum, chan)\n+                };\n+                match handle {\n+                    Ok(w) => {\n+                        self.handles.insert(signum, w);\n+                        true\n+                    },\n+                    Err(ioerr) => {\n+                        rtdebug!(\"Listener::register: failed to init: {:?}\", ioerr);\n+                        io_error::cond.raise(ioerr);\n+                        false\n+                    },\n+                }\n+            },\n+        }\n+    }\n+\n+    /// Unregister a signal.\n+    pub fn unregister(&mut self, signum: Signum) {\n+        self.handles.pop(&signum);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use libc;\n+    use rt::io::timer;\n+    use super::*;\n+\n+    // kill is only available on Unixes\n+    #[cfg(unix)]\n+    #[fixed_stack_segment]\n+    fn sigint() {\n+        unsafe {\n+            libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_signal_smoketest() {\n+        let mut signal = Listener::new();\n+        signal.register(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        match signal.port.recv() {\n+            Interrupt => (),\n+            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_signal_two_signal_one_signum() {\n+        let mut s1 = Listener::new();\n+        let mut s2 = Listener::new();\n+        s1.register(Interrupt);\n+        s2.register(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        match s1.port.recv() {\n+            Interrupt => (),\n+            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+        match s1.port.recv() {\n+            Interrupt => (),\n+            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_signal_unregister() {\n+        let mut s1 = Listener::new();\n+        let mut s2 = Listener::new();\n+        s1.register(Interrupt);\n+        s2.register(Interrupt);\n+        s2.unregister(Interrupt);\n+        sigint();\n+        timer::sleep(10);\n+        if s2.port.peek() {\n+            fail2!(\"Unexpected {:?}\", s2.port.recv());\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    #[test]\n+    fn test_io_signal_invalid_signum() {\n+        let mut s = Listener::new();\n+        if s.register(User1) {\n+            fail2!(\"Unexpected successful registry of signum {:?}\", User1);\n+        }\n+    }\n+}"}, {"sha": "528be59c54fc77be4d3d94e2b2a862cb28ca719f", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -11,11 +11,13 @@\n use libc;\n use option::*;\n use result::*;\n+use comm::SharedChan;\n use libc::c_int;\n use c_str::CString;\n \n use ai = rt::io::net::addrinfo;\n use rt::io::IoError;\n+use rt::io::signal::Signum;\n use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use path::Path;\n@@ -100,6 +102,8 @@ pub trait IoFactory {\n     fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;\n+    fn signal(&mut self, signal: Signum, channel: SharedChan<Signum>)\n+        -> Result<~RtioSignal, IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -192,3 +196,5 @@ pub trait PausibleIdleCallback {\n     fn resume(&mut self);\n     fn close(&mut self);\n }\n+\n+pub trait RtioSignal {}"}, {"sha": "c92a54425bf4f2962ee08e4fde04527d93101bcb", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -48,6 +48,7 @@ use cast::transmute;\n use ptr::null;\n use unstable::finally::Finally;\n use rt::io::net::ip::SocketAddr;\n+use rt::io::signal::Signum;\n \n use rt::io::IoError;\n \n@@ -60,6 +61,7 @@ pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n pub use self::process::Process;\n pub use self::pipe::Pipe;\n+pub use self::signal::SignalWatcher;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -76,6 +78,7 @@ pub mod addrinfo;\n pub mod process;\n pub mod pipe;\n pub mod tty;\n+pub mod signal;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -146,6 +149,7 @@ pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n+pub type SignalCallback = ~fn(SignalWatcher, Signum);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n@@ -162,6 +166,7 @@ struct WatcherData {\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n     exit_cb: Option<ExitCallback>,\n+    signal_cb: Option<SignalCallback>,\n }\n \n pub trait WatcherInterop {\n@@ -197,6 +202,7 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 udp_recv_cb: None,\n                 udp_send_cb: None,\n                 exit_cb: None,\n+                signal_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}, {"sha": "70ea8e399d587074282c61c1b41d207552e5dc30", "filename": "src/libstd/rt/uv/signal.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use option::Some;\n+use libc::{c_int, c_void};\n+use result::{Err, Ok, Result};\n+use rt::io::IoError;\n+use rt::io::signal::Signum;\n+use rt::uv::{Loop, NativeHandle, NullCallback, SignalCallback, UvError, Watcher};\n+use rt::uv::uv_error_to_io_error;\n+use rt::uv::uvll;\n+\n+pub struct SignalWatcher(*uvll::uv_signal_t);\n+\n+impl Watcher for SignalWatcher { }\n+\n+impl SignalWatcher {\n+    pub fn new(loop_: &mut Loop) -> SignalWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::signal_init(loop_.native_handle(), handle));\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, signum: Signum, callback: SignalCallback) -> Result<(), IoError> {\n+        {\n+            let data = self.get_watcher_data();\n+            data.signal_cb = Some(callback);\n+        }\n+\n+        let ret = unsafe {\n+            uvll::signal_start(self.native_handle(), signal_cb, signum as c_int)\n+        };\n+\n+        return match ret {\n+            0 => Ok(()),\n+            _ => Err(uv_error_to_io_error(UvError(ret))),\n+        };\n+\n+        extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.signal_cb.get_ref();\n+            (*cb)(watcher, unsafe { cast::transmute(signum as i64) });\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::signal_stop(self.native_handle());\n+        }\n+    }\n+\n+    pub fn close(self, cb: NullCallback) {\n+        let mut watcher = self;\n+        {\n+            let data = watcher.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::close(watcher.native_handle(), close_cb);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_signal_t) {\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let data = watcher.get_watcher_data();\n+                data.close_cb.take_unwrap()();\n+            }\n+            watcher.drop_watcher_data();\n+            unsafe {\n+                uvll::free_handle(handle as *c_void);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {\n+    fn from_native_handle(handle: *uvll::uv_signal_t) -> SignalWatcher {\n+        SignalWatcher(handle)\n+    }\n+\n+    fn native_handle(&self) -> *uvll::uv_signal_t {\n+        match self { &SignalWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "48f4dbe43d6f4f0e2d3340bc3e008fd5287ed613", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -13,6 +13,7 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n+use comm::{SendDeferred, SharedChan};\n use libc::{c_int, c_uint, c_void, pid_t};\n use ops::Drop;\n use option::*;\n@@ -40,6 +41,7 @@ use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n              CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n              FileStat};\n+use rt::io::signal::Signum;\n use task;\n use ai = rt::io::net::addrinfo;\n \n@@ -861,6 +863,17 @@ impl IoFactory for UvIoFactory {\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n+\n+    fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n+        -> Result<~RtioSignalObject, IoError> {\n+        let watcher = SignalWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        let mut signal = ~UvSignal::new(watcher, home);\n+        match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n+            Ok(()) => Ok(signal),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n+        }\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -1811,6 +1824,38 @@ impl RtioUnixAcceptor for UvUnixAcceptor {\n     }\n }\n \n+pub struct UvSignal {\n+    watcher: signal::SignalWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvSignal {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvSignal {\n+    fn new(w: signal::SignalWatcher, home: SchedHandle) -> UvSignal {\n+        UvSignal { watcher: w, home: home }\n+    }\n+}\n+\n+impl RtioSignal for UvSignal {}\n+\n+impl Drop for UvSignal {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            rtdebug!(\"closing UvSignal\");\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}, {"sha": "fa4083657d59125e95da05f7baa46c6344449a85", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -132,6 +132,7 @@ pub type uv_getaddrinfo_t = c_void;\n pub type uv_process_t = c_void;\n pub type uv_pipe_t = c_void;\n pub type uv_tty_t = c_void;\n+pub type uv_signal_t = c_void;\n \n pub struct uv_timespec_t {\n     tv_sec: libc::c_long,\n@@ -219,6 +220,8 @@ pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n                                     exit_status: c_int,\n                                     term_signal: c_int);\n+pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n+                                      signum: c_int);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n@@ -991,6 +994,21 @@ pub unsafe fn guess_handle(fd: c_int) -> uv_handle_type {\n     rust_uv_guess_handle(fd)\n }\n \n+pub unsafe fn signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_init(loop_, handle);\n+}\n+pub unsafe fn signal_start(handle: *uv_signal_t,\n+                           signal_cb: uv_signal_cb,\n+                           signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_start(handle, signal_cb, signum);\n+}\n+pub unsafe fn signal_stop(handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_stop(handle);\n+}\n+\n pub struct uv_err_data {\n     priv err_name: ~str,\n     priv err_msg: ~str,\n@@ -1160,4 +1178,10 @@ extern {\n     //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n     //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n     //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n+\n+    fn rust_uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n+    fn rust_uv_signal_start(handle: *uv_signal_t,\n+                            signal_cb: uv_signal_cb,\n+                            signum: c_int) -> c_int;\n+    fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n }"}, {"sha": "c463cf039d3061be537b01a027a202ced0c269a5", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -673,3 +673,18 @@ extern \"C\" uv_handle_type\n rust_uv_guess_handle(int fd) {\n     return uv_guess_handle(fd);\n }\n+\n+extern \"C\" int\n+rust_uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {\n+  return uv_signal_init(loop, handle);\n+}\n+\n+extern \"C\" int\n+rust_uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {\n+  return uv_signal_start(handle, signal_cb, signum);\n+}\n+\n+extern \"C\" int\n+rust_uv_signal_stop(uv_signal_t* handle) {\n+  return uv_signal_stop(handle);\n+}"}, {"sha": "3c10e42f74384d1f2784d48680080b521340afc5", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b5a02e07845b9fb4bc9b09909bd996c874fa3eed/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "patch": "@@ -191,6 +191,9 @@ rust_set_stdio_container_fd\n rust_set_stdio_container_stream\n rust_uv_process_pid\n rust_uv_pipe_init\n+rust_uv_signal_init\n+rust_uv_signal_start\n+rust_uv_signal_stop\n sdhtml_renderer\n sd_markdown_new\n sd_markdown_render"}]}