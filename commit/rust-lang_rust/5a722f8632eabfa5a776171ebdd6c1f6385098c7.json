{"sha": "5a722f8632eabfa5a776171ebdd6c1f6385098c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNzIyZjg2MzJlYWJmYTVhNzc2MTcxZWJkZDZjMWY2Mzg1MDk4Yzc=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2015-02-01T17:15:44Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2015-02-01T17:15:44Z"}, "message": "box: into_raw, from_raw functions\n\nFunctions are needed for safety and convenience.\n\nIt is a common pattern to use `mem::transmute` to convert between\n`Box` and raw pointer, like this:\n\n```\nlet b = Box::new(3);\nlet p = mem::transmute(b);\n// pass `p` to some C library\n```\n\nAfter this commit, conversion can be written as:\n\n```\nlet p = boxed::into_raw(b);\n```\n\n`into_raw` and `from_raw` functions are still unsafe, but they are\nmuch safer than `mem::transmute`, because *raw functions do not\nconvert between incompatible pointers. For example, this likely\nincorrect code can be successfully compiled:\n\n```\nlet p: *mut u64 = ...\nlet b: Box<u32> = mem::transmute(p);\n```\n\nUsing `from_raw` results in compile-time error:\n\n```\nlet p: *mut u64 = ...\nlet b: Box<u32> = Box::from_raw(p); // compile-time error\n```\n\n`into_raw` and `from_raw` functions are similar to C++ `std::unique_ptr`\n`release` function [1] and constructor from pointer [2].\n\n[1] http://en.cppreference.com/w/cpp/memory/unique_ptr/release\n[2] http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr", "tree": {"sha": "26d25ba59daf1b74e534f79e08d5b45720c7a7e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d25ba59daf1b74e534f79e08d5b45720c7a7e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a722f8632eabfa5a776171ebdd6c1f6385098c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a722f8632eabfa5a776171ebdd6c1f6385098c7", "html_url": "https://github.com/rust-lang/rust/commit/5a722f8632eabfa5a776171ebdd6c1f6385098c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a722f8632eabfa5a776171ebdd6c1f6385098c7/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "html_url": "https://github.com/rust-lang/rust/commit/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "504b58d8ad1058886fee5672cc9925e5bbd36c9c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a722f8632eabfa5a776171ebdd6c1f6385098c7/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a722f8632eabfa5a776171ebdd6c1f6385098c7/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5a722f8632eabfa5a776171ebdd6c1f6385098c7", "patch": "@@ -102,6 +102,52 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T : ?Sized> Box<T> {\n+    /// Constructs a box from the raw pointer.\n+    ///\n+    /// After this function call, pointer is owned by resulting box.\n+    /// In particular, it means that `Box` destructor calls destructor\n+    /// of `T` and releases memory. Since the way `Box` allocates and\n+    /// releases memory is unspecified, so the only valid pointer to\n+    /// pass to this function is the one taken from another `Box` with\n+    /// `box::into_raw` function.\n+    ///\n+    /// Function is unsafe, because improper use of this function may\n+    /// lead to memory problems like double-free, for example if the\n+    /// function is called twice on the same raw pointer.\n+    #[unstable(feature = \"alloc\",\n+               reason = \"may be renamed or moved out of Box scope\")]\n+    pub unsafe fn from_raw(raw: *mut T) -> Self {\n+        mem::transmute(raw)\n+    }\n+}\n+\n+/// Consumes the `Box`, returning the wrapped raw pointer.\n+///\n+/// After call to this function, caller is responsible for the memory\n+/// previously managed by `Box`, in particular caller should properly\n+/// destroy `T` and release memory. The proper way to do it is to\n+/// convert pointer back to `Box` with `Box::from_raw` function, because\n+/// `Box` does not specify, how memory is allocated.\n+///\n+/// Function is unsafe, because result of this function is no longer\n+/// automatically managed that may lead to memory or other resource\n+/// leak.\n+///\n+/// # Example\n+/// ```\n+/// use std::boxed;\n+///\n+/// let seventeen = Box::new(17u32);\n+/// let raw = unsafe { boxed::into_raw(seventeen) };\n+/// let boxed_again = unsafe { Box::from_raw(raw) };\n+/// ```\n+#[unstable(feature = \"alloc\",\n+           reason = \"may be renamed\")]\n+pub unsafe fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n+    mem::transmute(b)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f7ddfcb09d7fb92be762db1c8b7fec57ca582a8d", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a722f8632eabfa5a776171ebdd6c1f6385098c7/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a722f8632eabfa5a776171ebdd6c1f6385098c7/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=5a722f8632eabfa5a776171ebdd6c1f6385098c7", "patch": "@@ -15,6 +15,7 @@ use core::ops::Deref;\n use core::result::Result::{Ok, Err};\n use core::clone::Clone;\n \n+use std::boxed;\n use std::boxed::Box;\n use std::boxed::BoxAny;\n \n@@ -73,3 +74,44 @@ fn deref() {\n     fn homura<T: Deref<Target=i32>>(_: T) { }\n     homura(Box::new(765i32));\n }\n+\n+#[test]\n+fn raw_sized() {\n+    unsafe {\n+        let x = Box::new(17i32);\n+        let p = boxed::into_raw(x);\n+        assert_eq!(17, *p);\n+        *p = 19;\n+        let y = Box::from_raw(p);\n+        assert_eq!(19, *y);\n+    }\n+}\n+\n+#[test]\n+fn raw_trait() {\n+    trait Foo {\n+        fn get(&self) -> u32;\n+        fn set(&mut self, value: u32);\n+    }\n+\n+    struct Bar(u32);\n+\n+    impl Foo for Bar {\n+        fn get(&self) -> u32 {\n+            self.0\n+        }\n+\n+        fn set(&mut self, value: u32) {\n+            self.0 = value;\n+        }\n+    }\n+\n+    unsafe {\n+        let x: Box<Foo> = Box::new(Bar(17));\n+        let p = boxed::into_raw(x);\n+        assert_eq!(17, (*p).get());\n+        (*p).set(19);\n+        let y: Box<Foo> = Box::from_raw(p);\n+        assert_eq!(19, y.get());\n+    }\n+}"}]}