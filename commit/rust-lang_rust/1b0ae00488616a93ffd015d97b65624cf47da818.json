{"sha": "1b0ae00488616a93ffd015d97b65624cf47da818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMGFlMDA0ODg2MTZhOTNmZmQwMTVkOTdiNjU2MjRjZjQ3ZGE4MTg=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-11-22T12:45:51Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-11-22T12:45:51Z"}, "message": "Extract fn rewrite methods from RewriteVisitor", "tree": {"sha": "c2dbcf92c297a1bb601a890228d26d71dc816e5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2dbcf92c297a1bb601a890228d26d71dc816e5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b0ae00488616a93ffd015d97b65624cf47da818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0ae00488616a93ffd015d97b65624cf47da818", "html_url": "https://github.com/rust-lang/rust/commit/1b0ae00488616a93ffd015d97b65624cf47da818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b0ae00488616a93ffd015d97b65624cf47da818/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a871405f45b68dd43660163f9d799e69092dded7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a871405f45b68dd43660163f9d799e69092dded7", "html_url": "https://github.com/rust-lang/rust/commit/a871405f45b68dd43660163f9d799e69092dded7"}], "stats": {"total": 1627, "additions": 820, "deletions": 807}, "files": [{"sha": "48cb212e76d8ef07438cd3d960def64bd1b87557", "filename": "src/items.rs", "status": "modified", "additions": 795, "deletions": 787, "changes": 1582, "blob_url": "https://github.com/rust-lang/rust/blob/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=1b0ae00488616a93ffd015d97b65624cf47da818", "patch": "@@ -113,20 +113,21 @@ impl<'a> FmtVisitor<'a> {\n         match item.node {\n             ast::ForeignItem_::ForeignItemFn(ref fn_decl, ref generics) => {\n                 let indent = self.block_indent;\n-                let rewrite = self.rewrite_fn_base(indent,\n-                                                   item.ident,\n-                                                   fn_decl,\n-                                                   None,\n-                                                   generics,\n-                                                   ast::Unsafety::Normal,\n-                                                   ast::Constness::NotConst,\n-                                                   // These are not actually rust functions,\n-                                                   // but we format them as such.\n-                                                   abi::Abi::Rust,\n-                                                   item.vis,\n-                                                   span,\n-                                                   false,\n-                                                   false);\n+                let rewrite = rewrite_fn_base(&self.get_context(),\n+                                              indent,\n+                                              item.ident,\n+                                              fn_decl,\n+                                              None,\n+                                              generics,\n+                                              ast::Unsafety::Normal,\n+                                              ast::Constness::NotConst,\n+                                              // These are not actually rust functions,\n+                                              // but we format them as such.\n+                                              abi::Abi::Rust,\n+                                              item.vis,\n+                                              span,\n+                                              false,\n+                                              false);\n \n                 match rewrite {\n                     Some((new_fn, _)) => {\n@@ -180,20 +181,22 @@ impl<'a> FmtVisitor<'a> {\n                       span: Span,\n                       block: &ast::Block)\n                       -> Option<String> {\n-        let mut newline_brace = self.newline_for_brace(&generics.where_clause);\n-\n-        let (mut result, force_newline_brace) = try_opt!(self.rewrite_fn_base(indent,\n-                                                                              ident,\n-                                                                              fd,\n-                                                                              explicit_self,\n-                                                                              generics,\n-                                                                              unsafety,\n-                                                                              constness,\n-                                                                              abi,\n-                                                                              vis,\n-                                                                              span,\n-                                                                              newline_brace,\n-                                                                              true));\n+        let mut newline_brace = newline_for_brace(self.config, &generics.where_clause);\n+        let context = self.get_context();\n+\n+        let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n+                                                                         indent,\n+                                                                         ident,\n+                                                                         fd,\n+                                                                         explicit_self,\n+                                                                         generics,\n+                                                                         unsafety,\n+                                                                         constness,\n+                                                                         abi,\n+                                                                         vis,\n+                                                                         span,\n+                                                                         newline_brace,\n+                                                                         true));\n \n         if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n@@ -224,20 +227,22 @@ impl<'a> FmtVisitor<'a> {\n                                -> Option<String> {\n         // Drop semicolon or it will be interpreted as comment\n         let span = mk_sp(span.lo, span.hi - BytePos(1));\n+        let context = self.get_context();\n \n         // FIXME: silly formatting of the `.0`.\n-        let mut result = try_opt!(self.rewrite_fn_base(indent,\n-                                                       ident,\n-                                                       &sig.decl,\n-                                                       Some(&sig.explicit_self),\n-                                                       &sig.generics,\n-                                                       sig.unsafety,\n-                                                       sig.constness,\n-                                                       sig.abi,\n-                                                       ast::Visibility::Inherited,\n-                                                       span,\n-                                                       false,\n-                                                       false))\n+        let mut result = try_opt!(rewrite_fn_base(&context,\n+                                                  indent,\n+                                                  ident,\n+                                                  &sig.decl,\n+                                                  Some(&sig.explicit_self),\n+                                                  &sig.generics,\n+                                                  sig.unsafety,\n+                                                  sig.constness,\n+                                                  sig.abi,\n+                                                  ast::Visibility::Inherited,\n+                                                  span,\n+                                                  false,\n+                                                  false))\n                              .0;\n \n         // Re-attach semicolon\n@@ -246,210 +251,7 @@ impl<'a> FmtVisitor<'a> {\n         Some(result)\n     }\n \n-    // Return type is (result, force_new_line_for_brace)\n-    fn rewrite_fn_base(&mut self,\n-                       indent: Indent,\n-                       ident: ast::Ident,\n-                       fd: &ast::FnDecl,\n-                       explicit_self: Option<&ast::ExplicitSelf>,\n-                       generics: &ast::Generics,\n-                       unsafety: ast::Unsafety,\n-                       constness: ast::Constness,\n-                       abi: abi::Abi,\n-                       vis: ast::Visibility,\n-                       span: Span,\n-                       newline_brace: bool,\n-                       has_body: bool)\n-                       -> Option<(String, bool)> {\n-        let mut force_new_line_for_brace = false;\n-        // FIXME we'll lose any comments in between parts of the function decl, but\n-        // anyone who comments there probably deserves what they get.\n-\n-        let where_clause = &generics.where_clause;\n-\n-        let mut result = String::with_capacity(1024);\n-        // Vis unsafety abi.\n-        result.push_str(format_visibility(vis));\n-\n-        if let ast::Unsafety::Unsafe = unsafety {\n-            result.push_str(\"unsafe \");\n-        }\n-        if let ast::Constness::Const = constness {\n-            result.push_str(\"const \");\n-        }\n-        if abi != abi::Rust {\n-            result.push_str(\"extern \");\n-            result.push_str(&abi.to_string());\n-            result.push(' ');\n-        }\n-\n-        // fn foo\n-        result.push_str(\"fn \");\n-        result.push_str(&ident.to_string());\n-\n-        // Generics.\n-        let generics_indent = indent + result.len();\n-        let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n-        let generics_str = try_opt!(self.rewrite_generics(generics,\n-                                                          indent,\n-                                                          generics_indent,\n-                                                          generics_span));\n-        result.push_str(&generics_str);\n-\n-        let context = self.get_context();\n-        // Note that if the width and indent really matter, we'll re-layout the\n-        // return type later anyway.\n-        let ret_str = fd.output\n-                        .rewrite(&context, self.config.max_width - indent.width(), indent)\n-                        .unwrap();\n-\n-        let multi_line_ret_str = ret_str.contains('\\n');\n-        let ret_str_len = if multi_line_ret_str {\n-            0\n-        } else {\n-            ret_str.len()\n-        };\n-\n-        // Args.\n-        let (mut one_line_budget, multi_line_budget, mut arg_indent) =\n-            self.compute_budgets_for_args(&result, indent, ret_str_len, newline_brace);\n-\n-        debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n-               one_line_budget,\n-               multi_line_budget,\n-               arg_indent);\n-\n-        // Check if vertical layout was forced by compute_budget_for_args.\n-        if one_line_budget <= 0 {\n-            if self.config.fn_args_paren_newline {\n-                result.push('\\n');\n-                result.push_str(&arg_indent.to_string(self.config));\n-                arg_indent = arg_indent + 1; // extra space for `(`\n-                result.push('(');\n-            } else {\n-                result.push_str(\"(\\n\");\n-                result.push_str(&arg_indent.to_string(self.config));\n-            }\n-        } else if self.config.fn_args_layout == StructLitStyle::Block {\n-            arg_indent = indent.block_indent(self.config);\n-            result.push_str(\"(\\n\");\n-            result.push_str(&arg_indent.to_string(self.config));\n-        } else {\n-            result.push('(');\n-        }\n-\n-        if multi_line_ret_str {\n-            one_line_budget = 0;\n-        }\n-\n-        // A conservative estimation, to goal is to be over all parens in generics\n-        let args_start = generics.ty_params\n-                                 .last()\n-                                 .map(|tp| end_typaram(tp))\n-                                 .unwrap_or(span.lo);\n-        let args_span = mk_sp(span_after(mk_sp(args_start, span.hi), \"(\", self.codemap),\n-                              span_for_return(&fd.output).lo);\n-        let arg_str = try_opt!(self.rewrite_args(&fd.inputs,\n-                                                 explicit_self,\n-                                                 one_line_budget,\n-                                                 multi_line_budget,\n-                                                 indent,\n-                                                 arg_indent,\n-                                                 args_span,\n-                                                 fd.variadic));\n-        result.push_str(&arg_str);\n-        if self.config.fn_args_layout == StructLitStyle::Block {\n-            result.push('\\n');\n-        }\n-        result.push(')');\n-\n-        // Return type.\n-        if !ret_str.is_empty() {\n-            // If we've already gone multi-line, or the return type would push\n-            // over the max width, then put the return type on a new line.\n-            // Unless we are formatting args like a block, in which case there\n-            // should always be room for the return type.\n-            let ret_indent = if (result.contains(\"\\n\") || multi_line_ret_str ||\n-                                 result.len() + indent.width() + ret_str_len >\n-                                 self.config.max_width) &&\n-                                self.config.fn_args_layout != StructLitStyle::Block {\n-                let indent = match self.config.fn_return_indent {\n-                    ReturnIndent::WithWhereClause => indent + 4,\n-                    // Aligning with non-existent args looks silly.\n-                    _ if arg_str.len() == 0 => {\n-                        force_new_line_for_brace = true;\n-                        indent + 4\n-                    }\n-                    // FIXME: we might want to check that using the arg indent\n-                    // doesn't blow our budget, and if it does, then fallback to\n-                    // the where clause indent.\n-                    _ => arg_indent,\n-                };\n-\n-                result.push('\\n');\n-                result.push_str(&indent.to_string(self.config));\n-                indent\n-            } else {\n-                result.push(' ');\n-                Indent::new(indent.width(), result.len())\n-            };\n-\n-            if multi_line_ret_str {\n-                // Now that we know the proper indent and width, we need to\n-                // re-layout the return type.\n-\n-                let budget = try_opt!(self.config.max_width.checked_sub(ret_indent.width()));\n-                let ret_str = fd.output\n-                                .rewrite(&context, budget, ret_indent)\n-                                .unwrap();\n-                result.push_str(&ret_str);\n-            } else {\n-                result.push_str(&ret_str);\n-            }\n-\n-            // Comment between return type and the end of the decl.\n-            let snippet_lo = fd.output.span().hi;\n-            if where_clause.predicates.is_empty() {\n-                let snippet_hi = span.hi;\n-                let snippet = self.snippet(mk_sp(snippet_lo, snippet_hi));\n-                let snippet = snippet.trim();\n-                if !snippet.is_empty() {\n-                    result.push(' ');\n-                    result.push_str(snippet);\n-                }\n-            } else {\n-                // FIXME it would be nice to catch comments between the return type\n-                // and the where clause, but we don't have a span for the where\n-                // clause.\n-            }\n-        }\n-\n-        let where_density = if (self.config.where_density == Density::Compressed &&\n-                                (!result.contains('\\n') ||\n-                                 self.config.fn_args_layout == StructLitStyle::Block)) ||\n-                               (self.config.fn_args_layout == StructLitStyle::Block &&\n-                                ret_str.is_empty()) ||\n-                               (self.config.where_density == Density::CompressedIfEmpty &&\n-                                !has_body) {\n-            Density::Compressed\n-        } else {\n-            Density::Tall\n-        };\n-\n-        // Where clause.\n-        let where_clause_str = try_opt!(self.rewrite_where_clause(where_clause,\n-                                                                  self.config,\n-                                                                  indent,\n-                                                                  where_density,\n-                                                                  \"{\",\n-                                                                  Some(span.hi)));\n-        result.push_str(&where_clause_str);\n-\n-        Some((result, force_new_line_for_brace))\n-    }\n-\n     fn single_line_fn(&self, fn_str: &str, block: &ast::Block) -> Option<String> {\n-\n         if fn_str.contains('\\n') {\n             return None;\n         }\n@@ -495,206 +297,26 @@ impl<'a> FmtVisitor<'a> {\n         None\n     }\n \n-    fn rewrite_args(&self,\n-                    args: &[ast::Arg],\n-                    explicit_self: Option<&ast::ExplicitSelf>,\n-                    one_line_budget: usize,\n-                    multi_line_budget: usize,\n-                    indent: Indent,\n-                    arg_indent: Indent,\n-                    span: Span,\n-                    variadic: bool)\n-                    -> Option<String> {\n-        let context = self.get_context();\n-        let mut arg_item_strs = try_opt!(args.iter()\n-                                             .map(|arg| {\n-                                                 arg.rewrite(&context,\n-                                                             multi_line_budget,\n-                                                             arg_indent)\n-                                             })\n-                                             .collect::<Option<Vec<_>>>());\n-\n-        // Account for sugary self.\n-        // FIXME: the comment for the self argument is dropped. This is blocked\n-        // on rust issue #27522.\n-        let min_args = explicit_self.and_then(|explicit_self| {\n-                                        rewrite_explicit_self(explicit_self, args)\n-                                    })\n-                                    .map(|self_str| {\n-                                        arg_item_strs[0] = self_str;\n-                                        2\n-                                    })\n-                                    .unwrap_or(1);\n-\n-        // Comments between args.\n-        let mut arg_items = Vec::new();\n-        if min_args == 2 {\n-            arg_items.push(ListItem::from_str(\"\"));\n-        }\n-\n-        // FIXME(#21): if there are no args, there might still be a comment, but\n-        // without spans for the comment or parens, there is no chance of\n-        // getting it right. You also don't get to put a comment on self, unless\n-        // it is explicit.\n-        if args.len() >= min_args || variadic {\n-            let comment_span_start = if min_args == 2 {\n-                span_after(span, \",\", self.codemap)\n-            } else {\n-                span.lo\n-            };\n-\n-            enum ArgumentKind<'a> {\n-                Regular(&'a ast::Arg),\n-                Variadic(BytePos),\n-            }\n-\n-            let variadic_arg = if variadic {\n-                let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n-                let variadic_start = span_after(variadic_span, \"...\", self.codemap) - BytePos(3);\n-                Some(ArgumentKind::Variadic(variadic_start))\n-            } else {\n-                None\n-            };\n-\n-            let more_items = itemize_list(self.codemap,\n-                                          args[min_args - 1..]\n-                                              .iter()\n-                                              .map(ArgumentKind::Regular)\n-                                              .chain(variadic_arg),\n-                                          \")\",\n-                                          |arg| {\n-                                              match *arg {\n-                                                  ArgumentKind::Regular(arg) => {\n-                                                      span_lo_for_arg(arg)\n-                                                  }\n-                                                  ArgumentKind::Variadic(start) => start,\n-                                              }\n-                                          },\n-                                          |arg| {\n-                                              match *arg {\n-                                                  ArgumentKind::Regular(arg) => arg.ty.span.hi,\n-                                                  ArgumentKind::Variadic(start) => {\n-                                                      start + BytePos(3)\n-                                                  }\n-                                              }\n-                                          },\n-                                          |arg| {\n-                                              match *arg {\n-                                                  ArgumentKind::Regular(..) => None,\n-                                                  ArgumentKind::Variadic(..) => {\n-                                                      Some(\"...\".to_owned())\n-                                                  }\n-                                              }\n-                                          },\n-                                          comment_span_start,\n-                                          span.hi);\n-\n-            arg_items.extend(more_items);\n-        }\n-\n-        for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n-            item.item = Some(arg);\n-        }\n-\n-        let indent = match self.config.fn_arg_indent {\n-            BlockIndentStyle::Inherit => indent,\n-            BlockIndentStyle::Tabbed => indent.block_indent(self.config),\n-            BlockIndentStyle::Visual => arg_indent,\n-        };\n-\n-        let tactic = definitive_tactic(&arg_items,\n-                                       self.config.fn_args_density.to_list_tactic(),\n-                                       one_line_budget);\n-        let budget = match tactic {\n-            DefinitiveListTactic::Horizontal => one_line_budget,\n-            _ => multi_line_budget,\n-        };\n-\n-        let fmt = ListFormatting {\n-            tactic: tactic,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: indent,\n-            width: budget,\n-            ends_with_newline: false,\n-            config: self.config,\n-        };\n-\n-        write_list(&arg_items, &fmt)\n-    }\n-\n-    fn compute_budgets_for_args(&self,\n-                                result: &str,\n-                                indent: Indent,\n-                                ret_str_len: usize,\n-                                newline_brace: bool)\n-                                -> (usize, usize, Indent) {\n-        // Try keeping everything on the same line\n-        if !result.contains(\"\\n\") {\n-            // 3 = `() `, space is before ret_string\n-            let mut used_space = indent.width() + result.len() + ret_str_len + 3;\n-            if !newline_brace {\n-                used_space += 2;\n-            }\n-            let one_line_budget = if used_space > self.config.max_width {\n-                0\n-            } else {\n-                self.config.max_width - used_space\n-            };\n-\n-            // 2 = `()`\n-            let used_space = indent.width() + result.len() + 2;\n-            let max_space = self.config.max_width;\n-            debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n-                   used_space,\n-                   max_space);\n-            if used_space < max_space {\n-                return (one_line_budget,\n-                        max_space - used_space,\n-                        indent + result.len() + 1);\n-            }\n-        }\n-\n-        // Didn't work. we must force vertical layout and put args on a newline.\n-        let new_indent = indent.block_indent(self.config);\n-        let used_space = new_indent.width() + 2; // account for `(` and `)`\n-        let max_space = self.config.max_width;\n-        if used_space <= max_space {\n-            (0, max_space - used_space, new_indent)\n-        } else {\n-            // Whoops! bankrupt.\n-            // FIXME: take evasive action, perhaps kill the indent or something.\n-            panic!(\"in compute_budgets_for_args\");\n-        }\n-    }\n-\n-    fn newline_for_brace(&self, where_clause: &ast::WhereClause) -> bool {\n-        match self.config.fn_brace_style {\n-            BraceStyle::AlwaysNextLine => true,\n-            BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn visit_enum(&mut self,\n                       ident: ast::Ident,\n                       vis: ast::Visibility,\n                       enum_def: &ast::EnumDef,\n                       generics: &ast::Generics,\n                       span: Span) {\n-        let header_str = self.format_header(\"enum \", ident, vis);\n+        let header_str = format_header(\"enum \", ident, vis);\n         self.buffer.push_str(&header_str);\n \n         let enum_snippet = self.snippet(span);\n         let body_start = span.lo + BytePos(enum_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n-        let generics_str = self.format_generics(generics,\n-                                                \"{\",\n-                                                \"{\",\n-                                                self.config.item_brace_style,\n-                                                enum_def.variants.is_empty(),\n-                                                self.block_indent,\n-                                                self.block_indent.block_indent(self.config),\n-                                                mk_sp(span.lo, body_start))\n+        let generics_str = format_generics(&self.get_context(),\n+                                           generics,\n+                                           \"{\",\n+                                           \"{\",\n+                                           self.config.item_brace_style,\n+                                           enum_def.variants.is_empty(),\n+                                           self.block_indent,\n+                                           self.block_indent.block_indent(self.config),\n+                                           mk_sp(span.lo, body_start))\n                                .unwrap();\n         self.buffer.push_str(&generics_str);\n \n@@ -780,17 +402,19 @@ impl<'a> FmtVisitor<'a> {\n             result.push_str(&indent.to_string(self.config));\n         }\n \n+        let context = self.get_context();\n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) |\n             ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n-                self.format_struct(\"\",\n-                                   field.node.name,\n-                                   ast::Visibility::Inherited,\n-                                   &field.node.data,\n-                                   None,\n-                                   field.span,\n-                                   indent)\n+                format_struct(&context,\n+                              \"\",\n+                              field.node.name,\n+                              ast::Visibility::Inherited,\n+                              &field.node.data,\n+                              None,\n+                              field.span,\n+                              indent)\n             }\n             ast::VariantData::Unit(..) => {\n                 let tag = if let Some(ref expr) = field.node.disr_expr {\n@@ -813,371 +437,212 @@ impl<'a> FmtVisitor<'a> {\n             None\n         }\n     }\n+}\n \n-    pub fn format_struct(&self,\n-                         item_name: &str,\n-                         ident: ast::Ident,\n-                         vis: ast::Visibility,\n-                         struct_def: &ast::VariantData,\n-                         generics: Option<&ast::Generics>,\n-                         span: Span,\n-                         offset: Indent)\n-                         -> Option<String> {\n-        match *struct_def {\n-            ast::VariantData::Unit(..) => self.format_unit_struct(item_name, ident, vis),\n-            ast::VariantData::Tuple(ref fields, _) => {\n-                self.format_tuple_struct(item_name, ident, vis, fields, generics, span, offset)\n-            }\n-            ast::VariantData::Struct(ref fields, _) => {\n-                self.format_struct_struct(item_name, ident, vis, fields, generics, span, offset)\n-            }\n+pub fn format_struct(context: &RewriteContext,\n+                     item_name: &str,\n+                     ident: ast::Ident,\n+                     vis: ast::Visibility,\n+                     struct_def: &ast::VariantData,\n+                     generics: Option<&ast::Generics>,\n+                     span: Span,\n+                     offset: Indent)\n+                     -> Option<String> {\n+    match *struct_def {\n+        ast::VariantData::Unit(..) => format_unit_struct(item_name, ident, vis),\n+        ast::VariantData::Tuple(ref fields, _) => {\n+            format_tuple_struct(context,\n+                                item_name,\n+                                ident,\n+                                vis,\n+                                fields,\n+                                generics,\n+                                span,\n+                                offset)\n         }\n-    }\n-\n-    fn format_unit_struct(&self,\n-                          item_name: &str,\n-                          ident: ast::Ident,\n-                          vis: ast::Visibility)\n-                          -> Option<String> {\n-        let mut result = String::with_capacity(1024);\n-\n-        let header_str = self.format_header(item_name, ident, vis);\n-        result.push_str(&header_str);\n-        result.push(';');\n-\n-        Some(result)\n-    }\n-\n-    fn format_struct_struct(&self,\n-                            item_name: &str,\n-                            ident: ast::Ident,\n-                            vis: ast::Visibility,\n-                            fields: &[ast::StructField],\n-                            generics: Option<&ast::Generics>,\n-                            span: Span,\n-                            offset: Indent)\n-                            -> Option<String> {\n-        let mut result = String::with_capacity(1024);\n-\n-        let header_str = self.format_header(item_name, ident, vis);\n-        result.push_str(&header_str);\n-\n-        let body_lo = span_after(span, \"{\", self.codemap);\n-\n-        let generics_str = match generics {\n-            Some(g) => {\n-                try_opt!(self.format_generics(g,\n-                                              \"{\",\n-                                              \"{\",\n-                                              self.config.item_brace_style,\n-                                              fields.is_empty(),\n-                                              offset,\n-                                              offset + header_str.len(),\n-                                              mk_sp(span.lo, body_lo)))\n-            }\n-            None => {\n-                if self.config.item_brace_style == BraceStyle::AlwaysNextLine &&\n-                   !fields.is_empty() {\n-                    format!(\"\\n{}{{\", self.block_indent.to_string(self.config))\n-                } else {\n-                    \" {\".to_owned()\n-                }\n-            }\n-        };\n-        result.push_str(&generics_str);\n-\n-        // FIXME: properly format empty structs and their comments.\n-        if fields.is_empty() {\n-            result.push_str(&self.snippet(mk_sp(body_lo, span.hi)));\n-            return Some(result);\n+        ast::VariantData::Struct(ref fields, _) => {\n+            format_struct_struct(context,\n+                                 item_name,\n+                                 ident,\n+                                 vis,\n+                                 fields,\n+                                 generics,\n+                                 span,\n+                                 offset)\n         }\n-\n-        let item_indent = offset.block_indent(self.config);\n-        // 2 = \",\"\n-        let item_budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 1));\n-\n-        let context = self.get_context();\n-        let items = itemize_list(self.codemap,\n-                                 fields.iter(),\n-                                 \"}\",\n-                                 |field| {\n-                                     // Include attributes and doc comments, if present\n-                                     if !field.node.attrs.is_empty() {\n-                                         field.node.attrs[0].span.lo\n-                                     } else {\n-                                         field.span.lo\n-                                     }\n-                                 },\n-                                 |field| field.node.ty.span.hi,\n-                                 |field| field.rewrite(&context, item_budget, item_indent),\n-                                 span_after(span, \"{\", self.codemap),\n-                                 span.hi);\n-        // 1 = ,\n-        let budget = self.config.max_width - offset.width() + self.config.tab_spaces - 1;\n-        let fmt = ListFormatting {\n-            tactic: DefinitiveListTactic::Vertical,\n-            separator: \",\",\n-            trailing_separator: self.config.struct_trailing_comma,\n-            indent: item_indent,\n-            width: budget,\n-            ends_with_newline: true,\n-            config: self.config,\n-        };\n-        Some(format!(\"{}\\n{}{}\\n{}}}\",\n-                     result,\n-                     offset.block_indent(self.config).to_string(self.config),\n-                     try_opt!(write_list(items, &fmt)),\n-                     offset.to_string(self.config)))\n     }\n+}\n \n-    fn format_tuple_struct(&self,\n-                           item_name: &str,\n-                           ident: ast::Ident,\n-                           vis: ast::Visibility,\n-                           fields: &[ast::StructField],\n-                           generics: Option<&ast::Generics>,\n-                           span: Span,\n-                           offset: Indent)\n-                           -> Option<String> {\n-        assert!(!fields.is_empty(), \"Tuple struct with no fields?\");\n-        let mut result = String::with_capacity(1024);\n-\n-        let header_str = self.format_header(item_name, ident, vis);\n-        result.push_str(&header_str);\n-\n-        let body_lo = fields[0].span.lo;\n-\n-        let (generics_str, where_clause_str) = match generics {\n-            Some(ref generics) => {\n-                let generics_str = try_opt!(self.rewrite_generics(generics,\n-                                                                  offset,\n-                                                                  offset + header_str.len(),\n-                                                                  mk_sp(span.lo, body_lo)));\n-\n-                let where_clause_str = try_opt!(self.rewrite_where_clause(&generics.where_clause,\n-                                                                          self.config,\n-                                                                          self.block_indent,\n-                                                                          Density::Compressed,\n-                                                                          \";\",\n-                                                                          None));\n+fn format_unit_struct(item_name: &str,\n+                      ident: ast::Ident,\n+                      vis: ast::Visibility)\n+                      -> Option<String> {\n+    let mut result = String::with_capacity(1024);\n \n-                (generics_str, where_clause_str)\n-            }\n-            None => (\"\".to_owned(), \"\".to_owned()),\n-        };\n-        result.push_str(&generics_str);\n-        result.push('(');\n+    let header_str = format_header(item_name, ident, vis);\n+    result.push_str(&header_str);\n+    result.push(';');\n \n-        let item_indent = self.block_indent + result.len();\n-        // 2 = \");\"\n-        let item_budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 2));\n+    Some(result)\n+}\n \n-        let context = self.get_context();\n-        let items = itemize_list(self.codemap,\n-                                 fields.iter(),\n-                                 \")\",\n-                                 |field| {\n-                                     // Include attributes and doc comments, if present\n-                                     if !field.node.attrs.is_empty() {\n-                                         field.node.attrs[0].span.lo\n-                                     } else {\n-                                         field.span.lo\n-                                     }\n-                                 },\n-                                 |field| field.node.ty.span.hi,\n-                                 |field| field.rewrite(&context, item_budget, item_indent),\n-                                 span_after(span, \"(\", self.codemap),\n-                                 span.hi);\n-        let body = try_opt!(format_item_list(items, item_budget, item_indent, self.config));\n-        result.push_str(&body);\n-        result.push(')');\n-\n-        if where_clause_str.len() > 0 && !where_clause_str.contains('\\n') &&\n-           (result.contains('\\n') ||\n-            self.block_indent.width() + result.len() + where_clause_str.len() + 1 >\n-            self.config.max_width) {\n-            // We need to put the where clause on a new line, but we didn'to_string\n-            // know that earlier, so the where clause will not be indented properly.\n-            result.push('\\n');\n-            result.push_str(&(self.block_indent + (self.config.tab_spaces - 1))\n-                                 .to_string(self.config));\n+fn format_struct_struct(context: &RewriteContext,\n+                        item_name: &str,\n+                        ident: ast::Ident,\n+                        vis: ast::Visibility,\n+                        fields: &[ast::StructField],\n+                        generics: Option<&ast::Generics>,\n+                        span: Span,\n+                        offset: Indent)\n+                        -> Option<String> {\n+    let mut result = String::with_capacity(1024);\n+\n+    let header_str = format_header(item_name, ident, vis);\n+    result.push_str(&header_str);\n+\n+    let body_lo = span_after(span, \"{\", context.codemap);\n+\n+    let generics_str = match generics {\n+        Some(g) => {\n+            try_opt!(format_generics(context,\n+                                     g,\n+                                     \"{\",\n+                                     \"{\",\n+                                     context.config.item_brace_style,\n+                                     fields.is_empty(),\n+                                     offset,\n+                                     offset + header_str.len(),\n+                                     mk_sp(span.lo, body_lo)))\n         }\n-        result.push_str(&where_clause_str);\n-\n-        Some(result)\n-    }\n-\n-    fn format_header(&self, item_name: &str, ident: ast::Ident, vis: ast::Visibility) -> String {\n-        format!(\"{}{}{}\", format_visibility(vis), item_name, ident)\n-    }\n-\n-    fn format_generics(&self,\n-                       generics: &ast::Generics,\n-                       opener: &str,\n-                       terminator: &str,\n-                       brace_style: BraceStyle,\n-                       force_same_line_brace: bool,\n-                       offset: Indent,\n-                       generics_offset: Indent,\n-                       span: Span)\n-                       -> Option<String> {\n-        let mut result = try_opt!(self.rewrite_generics(generics, offset, generics_offset, span));\n-\n-        if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-            let where_clause_str = try_opt!(self.rewrite_where_clause(&generics.where_clause,\n-                                                                      self.config,\n-                                                                      self.block_indent,\n-                                                                      Density::Tall,\n-                                                                      terminator,\n-                                                                      Some(span.hi)));\n-            result.push_str(&where_clause_str);\n-            if !force_same_line_brace &&\n-               (brace_style == BraceStyle::SameLineWhere ||\n-                brace_style == BraceStyle::AlwaysNextLine) {\n-                result.push('\\n');\n-                result.push_str(&self.block_indent.to_string(self.config));\n-            } else {\n-                result.push(' ');\n-            }\n-            result.push_str(opener);\n-        } else {\n-            if !force_same_line_brace && brace_style == BraceStyle::AlwaysNextLine {\n-                result.push('\\n');\n-                result.push_str(&self.block_indent.to_string(self.config));\n+        None => {\n+            if context.config.item_brace_style == BraceStyle::AlwaysNextLine && !fields.is_empty() {\n+                format!(\"\\n{}{{\", context.block_indent.to_string(context.config))\n             } else {\n-                result.push(' ');\n+                \" {\".to_owned()\n             }\n-            result.push_str(opener);\n         }\n+    };\n+    result.push_str(&generics_str);\n \n-        Some(result)\n-    }\n-\n-    fn rewrite_generics(&self,\n-                        generics: &ast::Generics,\n-                        offset: Indent,\n-                        generics_offset: Indent,\n-                        span: Span)\n-                        -> Option<String> {\n-        // FIXME: convert bounds to where clauses where they get too big or if\n-        // there is a where clause at all.\n-        let lifetimes: &[_] = &generics.lifetimes;\n-        let tys: &[_] = &generics.ty_params;\n-        if lifetimes.is_empty() && tys.is_empty() {\n-            return Some(String::new());\n-        }\n-\n-        let offset = match self.config.generics_indent {\n-            BlockIndentStyle::Inherit => offset,\n-            BlockIndentStyle::Tabbed => offset.block_indent(self.config),\n-            // 1 = <\n-            BlockIndentStyle::Visual => generics_offset + 1,\n-        };\n-\n-        let h_budget = self.config.max_width - generics_offset.width() - 2;\n-        // FIXME: might need to insert a newline if the generics are really long.\n-\n-        // Strings for the generics.\n-        let context = self.get_context();\n-        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset));\n-        let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(&context, h_budget, offset));\n-\n-        // Extract comments between generics.\n-        let lt_spans = lifetimes.iter().map(|l| {\n-            let hi = if l.bounds.is_empty() {\n-                l.lifetime.span.hi\n-            } else {\n-                l.bounds[l.bounds.len() - 1].span.hi\n-            };\n-            mk_sp(l.lifetime.span.lo, hi)\n-        });\n-        let ty_spans = tys.iter().map(span_for_ty_param);\n-\n-        let items = itemize_list(self.codemap,\n-                                 lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n-                                 \">\",\n-                                 |&(sp, _)| sp.lo,\n-                                 |&(sp, _)| sp.hi,\n-                                 // FIXME: don't clone\n-                                 |&(_, ref str)| str.clone(),\n-                                 span_after(span, \"<\", self.codemap),\n-                                 span.hi);\n-        let list_str = try_opt!(format_item_list(items, h_budget, offset, self.config));\n-\n-        Some(format!(\"<{}>\", list_str))\n+    // FIXME: properly format empty structs and their comments.\n+    if fields.is_empty() {\n+        result.push_str(&context.snippet(mk_sp(body_lo, span.hi)));\n+        return Some(result);\n     }\n \n-    fn rewrite_where_clause(&self,\n-                            where_clause: &ast::WhereClause,\n-                            config: &Config,\n-                            indent: Indent,\n-                            density: Density,\n-                            terminator: &str,\n-                            span_end: Option<BytePos>)\n-                            -> Option<String> {\n-        if where_clause.predicates.is_empty() {\n-            return Some(String::new());\n-        }\n-\n-        let extra_indent = match self.config.where_indent {\n-            BlockIndentStyle::Inherit => Indent::empty(),\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => {\n-                Indent::new(config.tab_spaces, 0)\n-            }\n-        };\n-\n-        let context = self.get_context();\n-\n-        let offset = match self.config.where_pred_indent {\n-            BlockIndentStyle::Inherit => indent + extra_indent,\n-            BlockIndentStyle::Tabbed => indent + extra_indent.block_indent(config),\n-            // 6 = \"where \".len()\n-            BlockIndentStyle::Visual => indent + extra_indent + 6,\n-        };\n-        // FIXME: if where_pred_indent != Visual, then the budgets below might\n-        // be out by a char or two.\n-\n-        let budget = self.config.max_width - offset.width();\n-        let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n-        // If we don't have the start of the next span, then use the end of the\n-        // predicates, but that means we miss comments.\n-        let len = where_clause.predicates.len();\n-        let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n-        let span_end = span_end.unwrap_or(end_of_preds);\n-        let items = itemize_list(self.codemap,\n-                                 where_clause.predicates.iter(),\n-                                 terminator,\n-                                 |pred| span_for_where_pred(pred).lo,\n-                                 |pred| span_for_where_pred(pred).hi,\n-                                 |pred| pred.rewrite(&context, budget, offset),\n-                                 span_start,\n-                                 span_end);\n-        let item_vec = items.collect::<Vec<_>>();\n-        // FIXME: we don't need to collect here if the where_layout isn't\n-        // HorizontalVertical.\n-        let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n+    let item_indent = offset.block_indent(context.config);\n+    // 2 = \",\"\n+    let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 1));\n+\n+    let items = itemize_list(context.codemap,\n+                             fields.iter(),\n+                             \"}\",\n+                             |field| {\n+                                 // Include attributes and doc comments, if present\n+                                 if !field.node.attrs.is_empty() {\n+                                     field.node.attrs[0].span.lo\n+                                 } else {\n+                                     field.span.lo\n+                                 }\n+                             },\n+                             |field| field.node.ty.span.hi,\n+                             |field| field.rewrite(context, item_budget, item_indent),\n+                             span_after(span, \"{\", context.codemap),\n+                             span.hi);\n+    // 1 = ,\n+    let budget = context.config.max_width - offset.width() + context.config.tab_spaces - 1;\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \",\",\n+        trailing_separator: context.config.struct_trailing_comma,\n+        indent: item_indent,\n+        width: budget,\n+        ends_with_newline: true,\n+        config: context.config,\n+    };\n+    Some(format!(\"{}\\n{}{}\\n{}}}\",\n+                 result,\n+                 offset.block_indent(context.config).to_string(context.config),\n+                 try_opt!(write_list(items, &fmt)),\n+                 offset.to_string(context.config)))\n+}\n \n-        let fmt = ListFormatting {\n-            tactic: tactic,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            width: budget,\n-            ends_with_newline: true,\n-            config: self.config,\n-        };\n-        let preds_str = try_opt!(write_list(&item_vec, &fmt));\n-\n-        // 9 = \" where \".len() + \" {\".len()\n-        if density == Density::Tall || preds_str.contains('\\n') ||\n-           indent.width() + 9 + preds_str.len() > self.config.max_width {\n-            Some(format!(\"\\n{}where {}\",\n-                         (indent + extra_indent).to_string(self.config),\n-                         preds_str))\n-        } else {\n-            Some(format!(\" where {}\", preds_str))\n+fn format_tuple_struct(context: &RewriteContext,\n+                       item_name: &str,\n+                       ident: ast::Ident,\n+                       vis: ast::Visibility,\n+                       fields: &[ast::StructField],\n+                       generics: Option<&ast::Generics>,\n+                       span: Span,\n+                       offset: Indent)\n+                       -> Option<String> {\n+    assert!(!fields.is_empty(), \"Tuple struct with no fields?\");\n+    let mut result = String::with_capacity(1024);\n+\n+    let header_str = format_header(item_name, ident, vis);\n+    result.push_str(&header_str);\n+\n+    let body_lo = fields[0].span.lo;\n+\n+    let (generics_str, where_clause_str) = match generics {\n+        Some(ref generics) => {\n+            let generics_str = try_opt!(rewrite_generics(context,\n+                                                         generics,\n+                                                         offset,\n+                                                         offset + header_str.len(),\n+                                                         mk_sp(span.lo, body_lo)));\n+\n+            let where_clause_str = try_opt!(rewrite_where_clause(context,\n+                                                                 &generics.where_clause,\n+                                                                 context.config,\n+                                                                 context.block_indent,\n+                                                                 Density::Compressed,\n+                                                                 \";\",\n+                                                                 None));\n+\n+            (generics_str, where_clause_str)\n         }\n+        None => (\"\".to_owned(), \"\".to_owned()),\n+    };\n+    result.push_str(&generics_str);\n+    result.push('(');\n+\n+    let item_indent = context.block_indent + result.len();\n+    // 2 = \");\"\n+    let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 2));\n+\n+    let items = itemize_list(context.codemap,\n+                             fields.iter(),\n+                             \")\",\n+                             |field| {\n+                                 // Include attributes and doc comments, if present\n+                                 if !field.node.attrs.is_empty() {\n+                                     field.node.attrs[0].span.lo\n+                                 } else {\n+                                     field.span.lo\n+                                 }\n+                             },\n+                             |field| field.node.ty.span.hi,\n+                             |field| field.rewrite(context, item_budget, item_indent),\n+                             span_after(span, \"(\", context.codemap),\n+                             span.hi);\n+    let body = try_opt!(format_item_list(items, item_budget, item_indent, context.config));\n+    result.push_str(&body);\n+    result.push(')');\n+\n+    if where_clause_str.len() > 0 && !where_clause_str.contains('\\n') &&\n+       (result.contains('\\n') ||\n+        context.block_indent.width() + result.len() + where_clause_str.len() + 1 >\n+        context.config.max_width) {\n+        // We need to put the where clause on a new line, but we didn'to_string\n+        // know that earlier, so the where clause will not be indented properly.\n+        result.push('\\n');\n+        result.push_str(&(context.block_indent + (context.config.tab_spaces - 1))\n+                             .to_string(context.config));\n     }\n+    result.push_str(&where_clause_str);\n+\n+    Some(result)\n }\n \n impl Rewrite for ast::StructField {\n@@ -1369,3 +834,546 @@ fn span_for_where_pred(pred: &ast::WherePredicate) -> Span {\n         ast::WherePredicate::EqPredicate(ref p) => p.span,\n     }\n }\n+\n+// Return type is (result, force_new_line_for_brace)\n+fn rewrite_fn_base(context: &RewriteContext,\n+                   indent: Indent,\n+                   ident: ast::Ident,\n+                   fd: &ast::FnDecl,\n+                   explicit_self: Option<&ast::ExplicitSelf>,\n+                   generics: &ast::Generics,\n+                   unsafety: ast::Unsafety,\n+                   constness: ast::Constness,\n+                   abi: abi::Abi,\n+                   vis: ast::Visibility,\n+                   span: Span,\n+                   newline_brace: bool,\n+                   has_body: bool)\n+                   -> Option<(String, bool)> {\n+    let mut force_new_line_for_brace = false;\n+    // FIXME we'll lose any comments in between parts of the function decl, but\n+    // anyone who comments there probably deserves what they get.\n+\n+    let where_clause = &generics.where_clause;\n+\n+    let mut result = String::with_capacity(1024);\n+    // Vis unsafety abi.\n+    result.push_str(format_visibility(vis));\n+\n+    if let ast::Unsafety::Unsafe = unsafety {\n+        result.push_str(\"unsafe \");\n+    }\n+    if let ast::Constness::Const = constness {\n+        result.push_str(\"const \");\n+    }\n+    if abi != abi::Rust {\n+        result.push_str(\"extern \");\n+        result.push_str(&abi.to_string());\n+        result.push(' ');\n+    }\n+\n+    // fn foo\n+    result.push_str(\"fn \");\n+    result.push_str(&ident.to_string());\n+\n+    // Generics.\n+    let generics_indent = indent + result.len();\n+    let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n+    let generics_str = try_opt!(rewrite_generics(context,\n+                                                 generics,\n+                                                 indent,\n+                                                 generics_indent,\n+                                                 generics_span));\n+    result.push_str(&generics_str);\n+\n+    // Note that if the width and indent really matter, we'll re-layout the\n+    // return type later anyway.\n+    let ret_str = fd.output\n+                    .rewrite(&context, context.config.max_width - indent.width(), indent)\n+                    .unwrap();\n+\n+    let multi_line_ret_str = ret_str.contains('\\n');\n+    let ret_str_len = if multi_line_ret_str {\n+        0\n+    } else {\n+        ret_str.len()\n+    };\n+\n+    // Args.\n+    let (mut one_line_budget, multi_line_budget, mut arg_indent) =\n+        compute_budgets_for_args(context, &result, indent, ret_str_len, newline_brace);\n+\n+    debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n+           one_line_budget,\n+           multi_line_budget,\n+           arg_indent);\n+\n+    // Check if vertical layout was forced by compute_budget_for_args.\n+    if one_line_budget <= 0 {\n+        if context.config.fn_args_paren_newline {\n+            result.push('\\n');\n+            result.push_str(&arg_indent.to_string(context.config));\n+            arg_indent = arg_indent + 1; // extra space for `(`\n+            result.push('(');\n+        } else {\n+            result.push_str(\"(\\n\");\n+            result.push_str(&arg_indent.to_string(context.config));\n+        }\n+    } else if context.config.fn_args_layout == StructLitStyle::Block {\n+        arg_indent = indent.block_indent(context.config);\n+        result.push_str(\"(\\n\");\n+        result.push_str(&arg_indent.to_string(context.config));\n+    } else {\n+        result.push('(');\n+    }\n+\n+    if multi_line_ret_str {\n+        one_line_budget = 0;\n+    }\n+\n+    // A conservative estimation, to goal is to be over all parens in generics\n+    let args_start = generics.ty_params\n+                             .last()\n+                             .map(|tp| end_typaram(tp))\n+                             .unwrap_or(span.lo);\n+    let args_span = mk_sp(span_after(mk_sp(args_start, span.hi), \"(\", context.codemap),\n+                          span_for_return(&fd.output).lo);\n+    let arg_str = try_opt!(rewrite_args(context,\n+                                        &fd.inputs,\n+                                        explicit_self,\n+                                        one_line_budget,\n+                                        multi_line_budget,\n+                                        indent,\n+                                        arg_indent,\n+                                        args_span,\n+                                        fd.variadic));\n+    result.push_str(&arg_str);\n+    if context.config.fn_args_layout == StructLitStyle::Block {\n+        result.push('\\n');\n+    }\n+    result.push(')');\n+\n+    // Return type.\n+    if !ret_str.is_empty() {\n+        // If we've already gone multi-line, or the return type would push\n+        // over the max width, then put the return type on a new line.\n+        // Unless we are formatting args like a block, in which case there\n+        // should always be room for the return type.\n+        let ret_indent = if (result.contains(\"\\n\") || multi_line_ret_str ||\n+                             result.len() + indent.width() + ret_str_len >\n+                             context.config.max_width) &&\n+                            context.config.fn_args_layout != StructLitStyle::Block {\n+            let indent = match context.config.fn_return_indent {\n+                ReturnIndent::WithWhereClause => indent + 4,\n+                // Aligning with non-existent args looks silly.\n+                _ if arg_str.len() == 0 => {\n+                    force_new_line_for_brace = true;\n+                    indent + 4\n+                }\n+                // FIXME: we might want to check that using the arg indent\n+                // doesn't blow our budget, and if it does, then fallback to\n+                // the where clause indent.\n+                _ => arg_indent,\n+            };\n+\n+            result.push('\\n');\n+            result.push_str(&indent.to_string(context.config));\n+            indent\n+        } else {\n+            result.push(' ');\n+            Indent::new(indent.width(), result.len())\n+        };\n+\n+        if multi_line_ret_str {\n+            // Now that we know the proper indent and width, we need to\n+            // re-layout the return type.\n+\n+            let budget = try_opt!(context.config.max_width.checked_sub(ret_indent.width()));\n+            let ret_str = fd.output\n+                            .rewrite(context, budget, ret_indent)\n+                            .unwrap();\n+            result.push_str(&ret_str);\n+        } else {\n+            result.push_str(&ret_str);\n+        }\n+\n+        // Comment between return type and the end of the decl.\n+        let snippet_lo = fd.output.span().hi;\n+        if where_clause.predicates.is_empty() {\n+            let snippet_hi = span.hi;\n+            let snippet = context.snippet(mk_sp(snippet_lo, snippet_hi));\n+            let snippet = snippet.trim();\n+            if !snippet.is_empty() {\n+                result.push(' ');\n+                result.push_str(snippet);\n+            }\n+        } else {\n+            // FIXME it would be nice to catch comments between the return type\n+            // and the where clause, but we don't have a span for the where\n+            // clause.\n+        }\n+    }\n+\n+    let where_density = if (context.config.where_density == Density::Compressed &&\n+                            (!result.contains('\\n') ||\n+                             context.config.fn_args_layout == StructLitStyle::Block)) ||\n+                           (context.config.fn_args_layout == StructLitStyle::Block &&\n+                            ret_str.is_empty()) ||\n+                           (context.config.where_density == Density::CompressedIfEmpty &&\n+                            !has_body) {\n+        Density::Compressed\n+    } else {\n+        Density::Tall\n+    };\n+\n+    // Where clause.\n+    let where_clause_str = try_opt!(rewrite_where_clause(context,\n+                                                         where_clause,\n+                                                         context.config,\n+                                                         indent,\n+                                                         where_density,\n+                                                         \"{\",\n+                                                         Some(span.hi)));\n+    result.push_str(&where_clause_str);\n+\n+    Some((result, force_new_line_for_brace))\n+}\n+\n+fn rewrite_args(context: &RewriteContext,\n+                args: &[ast::Arg],\n+                explicit_self: Option<&ast::ExplicitSelf>,\n+                one_line_budget: usize,\n+                multi_line_budget: usize,\n+                indent: Indent,\n+                arg_indent: Indent,\n+                span: Span,\n+                variadic: bool)\n+                -> Option<String> {\n+    let mut arg_item_strs = try_opt!(args.iter()\n+                                         .map(|arg| {\n+                                             arg.rewrite(&context, multi_line_budget, arg_indent)\n+                                         })\n+                                         .collect::<Option<Vec<_>>>());\n+\n+    // Account for sugary self.\n+    // FIXME: the comment for the self argument is dropped. This is blocked\n+    // on rust issue #27522.\n+    let min_args = explicit_self.and_then(|explicit_self| {\n+                                    rewrite_explicit_self(explicit_self, args)\n+                                })\n+                                .map(|self_str| {\n+                                    arg_item_strs[0] = self_str;\n+                                    2\n+                                })\n+                                .unwrap_or(1);\n+\n+    // Comments between args.\n+    let mut arg_items = Vec::new();\n+    if min_args == 2 {\n+        arg_items.push(ListItem::from_str(\"\"));\n+    }\n+\n+    // FIXME(#21): if there are no args, there might still be a comment, but\n+    // without spans for the comment or parens, there is no chance of\n+    // getting it right. You also don't get to put a comment on self, unless\n+    // it is explicit.\n+    if args.len() >= min_args || variadic {\n+        let comment_span_start = if min_args == 2 {\n+            span_after(span, \",\", context.codemap)\n+        } else {\n+            span.lo\n+        };\n+\n+        enum ArgumentKind<'a> {\n+            Regular(&'a ast::Arg),\n+            Variadic(BytePos),\n+        }\n+\n+        let variadic_arg = if variadic {\n+            let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n+            let variadic_start = span_after(variadic_span, \"...\", context.codemap) - BytePos(3);\n+            Some(ArgumentKind::Variadic(variadic_start))\n+        } else {\n+            None\n+        };\n+\n+        let more_items = itemize_list(context.codemap,\n+                                      args[min_args - 1..]\n+                                          .iter()\n+                                          .map(ArgumentKind::Regular)\n+                                          .chain(variadic_arg),\n+                                      \")\",\n+                                      |arg| {\n+                                          match *arg {\n+                                              ArgumentKind::Regular(arg) => span_lo_for_arg(arg),\n+                                              ArgumentKind::Variadic(start) => start,\n+                                          }\n+                                      },\n+                                      |arg| {\n+                                          match *arg {\n+                                              ArgumentKind::Regular(arg) => arg.ty.span.hi,\n+                                              ArgumentKind::Variadic(start) => start + BytePos(3),\n+                                          }\n+                                      },\n+                                      |arg| {\n+                                          match *arg {\n+                                              ArgumentKind::Regular(..) => None,\n+                                              ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n+                                          }\n+                                      },\n+                                      comment_span_start,\n+                                      span.hi);\n+\n+        arg_items.extend(more_items);\n+    }\n+\n+    for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n+        item.item = Some(arg);\n+    }\n+\n+    let indent = match context.config.fn_arg_indent {\n+        BlockIndentStyle::Inherit => indent,\n+        BlockIndentStyle::Tabbed => indent.block_indent(context.config),\n+        BlockIndentStyle::Visual => arg_indent,\n+    };\n+\n+    let tactic = definitive_tactic(&arg_items,\n+                                   context.config.fn_args_density.to_list_tactic(),\n+                                   one_line_budget);\n+    let budget = match tactic {\n+        DefinitiveListTactic::Horizontal => one_line_budget,\n+        _ => multi_line_budget,\n+    };\n+\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: indent,\n+        width: budget,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n+\n+    write_list(&arg_items, &fmt)\n+}\n+\n+fn compute_budgets_for_args(context: &RewriteContext,\n+                            result: &str,\n+                            indent: Indent,\n+                            ret_str_len: usize,\n+                            newline_brace: bool)\n+                            -> (usize, usize, Indent) {\n+    // Try keeping everything on the same line\n+    if !result.contains(\"\\n\") {\n+        // 3 = `() `, space is before ret_string\n+        let mut used_space = indent.width() + result.len() + ret_str_len + 3;\n+        if !newline_brace {\n+            used_space += 2;\n+        }\n+        let one_line_budget = if used_space > context.config.max_width {\n+            0\n+        } else {\n+            context.config.max_width - used_space\n+        };\n+\n+        // 2 = `()`\n+        let used_space = indent.width() + result.len() + 2;\n+        let max_space = context.config.max_width;\n+        debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n+               used_space,\n+               max_space);\n+        if used_space < max_space {\n+            return (one_line_budget,\n+                    max_space - used_space,\n+                    indent + result.len() + 1);\n+        }\n+    }\n+\n+    // Didn't work. we must force vertical layout and put args on a newline.\n+    let new_indent = indent.block_indent(context.config);\n+    let used_space = new_indent.width() + 2; // account for `(` and `)`\n+    let max_space = context.config.max_width;\n+    if used_space <= max_space {\n+        (0, max_space - used_space, new_indent)\n+    } else {\n+        // Whoops! bankrupt.\n+        // FIXME: take evasive action, perhaps kill the indent or something.\n+        panic!(\"in compute_budgets_for_args\");\n+    }\n+}\n+\n+fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n+    match config.fn_brace_style {\n+        BraceStyle::AlwaysNextLine => true,\n+        BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n+        _ => false,\n+    }\n+}\n+\n+fn rewrite_generics(context: &RewriteContext,\n+                    generics: &ast::Generics,\n+                    offset: Indent,\n+                    generics_offset: Indent,\n+                    span: Span)\n+                    -> Option<String> {\n+    // FIXME: convert bounds to where clauses where they get too big or if\n+    // there is a where clause at all.\n+    let lifetimes: &[_] = &generics.lifetimes;\n+    let tys: &[_] = &generics.ty_params;\n+    if lifetimes.is_empty() && tys.is_empty() {\n+        return Some(String::new());\n+    }\n+\n+    let offset = match context.config.generics_indent {\n+        BlockIndentStyle::Inherit => offset,\n+        BlockIndentStyle::Tabbed => offset.block_indent(context.config),\n+        // 1 = <\n+        BlockIndentStyle::Visual => generics_offset + 1,\n+    };\n+\n+    let h_budget = context.config.max_width - generics_offset.width() - 2;\n+    // FIXME: might need to insert a newline if the generics are really long.\n+\n+    // Strings for the generics.\n+    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset));\n+    let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(&context, h_budget, offset));\n+\n+    // Extract comments between generics.\n+    let lt_spans = lifetimes.iter().map(|l| {\n+        let hi = if l.bounds.is_empty() {\n+            l.lifetime.span.hi\n+        } else {\n+            l.bounds[l.bounds.len() - 1].span.hi\n+        };\n+        mk_sp(l.lifetime.span.lo, hi)\n+    });\n+    let ty_spans = tys.iter().map(span_for_ty_param);\n+\n+    let items = itemize_list(context.codemap,\n+                             lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n+                             \">\",\n+                             |&(sp, _)| sp.lo,\n+                             |&(sp, _)| sp.hi,\n+                             // FIXME: don't clone\n+                             |&(_, ref str)| str.clone(),\n+                             span_after(span, \"<\", context.codemap),\n+                             span.hi);\n+    let list_str = try_opt!(format_item_list(items, h_budget, offset, context.config));\n+\n+    Some(format!(\"<{}>\", list_str))\n+}\n+\n+fn rewrite_where_clause(context: &RewriteContext,\n+                        where_clause: &ast::WhereClause,\n+                        config: &Config,\n+                        indent: Indent,\n+                        density: Density,\n+                        terminator: &str,\n+                        span_end: Option<BytePos>)\n+                        -> Option<String> {\n+    if where_clause.predicates.is_empty() {\n+        return Some(String::new());\n+    }\n+\n+    let extra_indent = match context.config.where_indent {\n+        BlockIndentStyle::Inherit => Indent::empty(),\n+        BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => Indent::new(config.tab_spaces, 0),\n+    };\n+\n+    let offset = match context.config.where_pred_indent {\n+        BlockIndentStyle::Inherit => indent + extra_indent,\n+        BlockIndentStyle::Tabbed => indent + extra_indent.block_indent(config),\n+        // 6 = \"where \".len()\n+        BlockIndentStyle::Visual => indent + extra_indent + 6,\n+    };\n+    // FIXME: if where_pred_indent != Visual, then the budgets below might\n+    // be out by a char or two.\n+\n+    let budget = context.config.max_width - offset.width();\n+    let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+    // If we don't have the start of the next span, then use the end of the\n+    // predicates, but that means we miss comments.\n+    let len = where_clause.predicates.len();\n+    let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n+    let span_end = span_end.unwrap_or(end_of_preds);\n+    let items = itemize_list(context.codemap,\n+                             where_clause.predicates.iter(),\n+                             terminator,\n+                             |pred| span_for_where_pred(pred).lo,\n+                             |pred| span_for_where_pred(pred).hi,\n+                             |pred| pred.rewrite(&context, budget, offset),\n+                             span_start,\n+                             span_end);\n+    let item_vec = items.collect::<Vec<_>>();\n+    // FIXME: we don't need to collect here if the where_layout isn't\n+    // HorizontalVertical.\n+    let tactic = definitive_tactic(&item_vec, context.config.where_layout, budget);\n+\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset,\n+        width: budget,\n+        ends_with_newline: true,\n+        config: context.config,\n+    };\n+    let preds_str = try_opt!(write_list(&item_vec, &fmt));\n+\n+    // 9 = \" where \".len() + \" {\".len()\n+    if density == Density::Tall || preds_str.contains('\\n') ||\n+       indent.width() + 9 + preds_str.len() > context.config.max_width {\n+        Some(format!(\"\\n{}where {}\",\n+                     (indent + extra_indent).to_string(context.config),\n+                     preds_str))\n+    } else {\n+        Some(format!(\" where {}\", preds_str))\n+    }\n+}\n+\n+fn format_header(item_name: &str, ident: ast::Ident, vis: ast::Visibility) -> String {\n+    format!(\"{}{}{}\", format_visibility(vis), item_name, ident)\n+}\n+\n+fn format_generics(context: &RewriteContext,\n+                   generics: &ast::Generics,\n+                   opener: &str,\n+                   terminator: &str,\n+                   brace_style: BraceStyle,\n+                   force_same_line_brace: bool,\n+                   offset: Indent,\n+                   generics_offset: Indent,\n+                   span: Span)\n+                   -> Option<String> {\n+    let mut result = try_opt!(rewrite_generics(context, generics, offset, generics_offset, span));\n+\n+    if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n+        let where_clause_str = try_opt!(rewrite_where_clause(context,\n+                                                             &generics.where_clause,\n+                                                             context.config,\n+                                                             context.block_indent,\n+                                                             Density::Tall,\n+                                                             terminator,\n+                                                             Some(span.hi)));\n+        result.push_str(&where_clause_str);\n+        if !force_same_line_brace &&\n+           (brace_style == BraceStyle::SameLineWhere || brace_style == BraceStyle::AlwaysNextLine) {\n+            result.push('\\n');\n+            result.push_str(&context.block_indent.to_string(context.config));\n+        } else {\n+            result.push(' ');\n+        }\n+        result.push_str(opener);\n+    } else {\n+        if !force_same_line_brace && brace_style == BraceStyle::AlwaysNextLine {\n+            result.push('\\n');\n+            result.push_str(&context.block_indent.to_string(context.config));\n+        } else {\n+            result.push(' ');\n+        }\n+        result.push_str(opener);\n+    }\n+\n+    Some(result)\n+}"}, {"sha": "1d991bb81da0284e3ec2fa802c9bdf30bce114c6", "filename": "src/types.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=1b0ae00488616a93ffd015d97b65624cf47da818", "patch": "@@ -492,13 +492,14 @@ impl Rewrite for ast::Ty {\n                     None\n                 }\n             }\n-            ast::TyBareFn(..) => {\n-                wrap_str(pprust::ty_to_string(self),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            }\n+            ast::TyBareFn(ref bare_fn) => bare_fn.rewrite(context, width, offset),\n             ast::TyMac(..) | ast::TyTypeof(..) => unreachable!(),\n         }\n     }\n }\n+\n+impl Rewrite for ast::BareFnTy {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        None\n+    }\n+}"}, {"sha": "6448ccbabbc8507b4dcd799a6910c3a28623e5b1", "filename": "src/visitor.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0ae00488616a93ffd015d97b65624cf47da818/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=1b0ae00488616a93ffd015d97b65624cf47da818", "patch": "@@ -220,20 +220,24 @@ impl<'a> FmtVisitor<'a> {\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemStruct(ref def, ref generics) => {\n-                let indent = self.block_indent;\n-                let rewrite = self.format_struct(\"struct \",\n-                                                 item.ident,\n-                                                 item.vis,\n-                                                 def,\n-                                                 Some(generics),\n-                                                 item.span,\n-                                                 indent)\n-                                  .map(|s| {\n-                                      match *def {\n-                                          ast::VariantData::Tuple(..) => s + \";\",\n-                                          _ => s,\n-                                      }\n-                                  });\n+                let rewrite = {\n+                    let indent = self.block_indent;\n+                    let context = self.get_context();\n+                    ::items::format_struct(&context,\n+                                           \"struct \",\n+                                           item.ident,\n+                                           item.vis,\n+                                           def,\n+                                           Some(generics),\n+                                           item.span,\n+                                           indent)\n+                        .map(|s| {\n+                            match *def {\n+                                ast::VariantData::Tuple(..) => s + \";\",\n+                                _ => s,\n+                            }\n+                        })\n+                };\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {"}]}