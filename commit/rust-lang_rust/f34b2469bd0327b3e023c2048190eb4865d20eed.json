{"sha": "f34b2469bd0327b3e023c2048190eb4865d20eed", "node_id": "C_kwDOAAsO6NoAKGYzNGIyNDY5YmQwMzI3YjNlMDIzYzIwNDgxOTBlYjQ4NjVkMjBlZWQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-20T22:09:35Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-14T18:20:44Z"}, "message": "lint incoherent inherent impls", "tree": {"sha": "6dd71fdcb4f80ee6bf8bc2d867ce3aec43b8cdf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd71fdcb4f80ee6bf8bc2d867ce3aec43b8cdf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f34b2469bd0327b3e023c2048190eb4865d20eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f34b2469bd0327b3e023c2048190eb4865d20eed", "html_url": "https://github.com/rust-lang/rust/commit/f34b2469bd0327b3e023c2048190eb4865d20eed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f34b2469bd0327b3e023c2048190eb4865d20eed/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15335c8b02dbc0ccc04f04c56d6471120db1bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15335c8b02dbc0ccc04f04c56d6471120db1bd2", "html_url": "https://github.com/rust-lang/rust/commit/c15335c8b02dbc0ccc04f04c56d6471120db1bd2"}], "stats": {"total": 335, "additions": 284, "deletions": 51}, "files": [{"sha": "f2bbf91835ca736391280da7ef56c54c8f42de5c", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -35,6 +35,7 @@ pub struct FunctionData {\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n     pub legacy_const_generics_indices: Box<[u32]>,\n+    pub rustc_allow_incoherent_impl: bool,\n     flags: FnFlags,\n }\n \n@@ -84,13 +85,14 @@ impl FunctionData {\n             }\n         }\n \n-        let legacy_const_generics_indices = item_tree\n-            .attrs(db, krate, ModItem::from(loc.id.value).into())\n+        let attrs = item_tree.attrs(db, krate, ModItem::from(loc.id.value).into());\n+        let legacy_const_generics_indices = attrs\n             .by_key(\"rustc_legacy_const_generics\")\n             .tt_values()\n             .next()\n             .map(parse_rustc_legacy_const_generics)\n             .unwrap_or_default();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n@@ -108,6 +110,7 @@ impl FunctionData {\n             abi: func.abi.clone(),\n             legacy_const_generics_indices,\n             flags,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n \n@@ -171,6 +174,7 @@ pub struct TypeAliasData {\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub rustc_allow_incoherent_impl: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -189,17 +193,22 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(\n+            db,\n+            loc.container.module(db).krate(),\n+            ModItem::from(loc.id.value).into(),\n+        );\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n             rustc_has_incoherent_inherent_impls,\n+            rustc_allow_incoherent_impl,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -450,6 +459,7 @@ pub struct ConstData {\n     pub name: Option<Name>,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub rustc_allow_incoherent_impl: bool,\n }\n \n impl ConstData {\n@@ -463,10 +473,16 @@ impl ConstData {\n             item_tree[konst.visibility].clone()\n         };\n \n+        let rustc_allow_incoherent_impl = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_allow_incoherent_impl\")\n+            .exists();\n+\n         Arc::new(ConstData {\n             name: konst.name.clone(),\n             type_ref: konst.type_ref.clone(),\n             visibility,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n }"}, {"sha": "121b25c6c9722fcd7f6a7566db460601790e0504", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -120,6 +120,8 @@ pub struct DefMap {\n     registered_tools: Vec<SmolStr>,\n     /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n     unstable_features: FxHashSet<SmolStr>,\n+    /// #[rustc_coherence_is_core]\n+    rustc_coherence_is_core: bool,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -292,6 +294,7 @@ impl DefMap {\n             registered_tools: Vec::new(),\n             unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n+            rustc_coherence_is_core: false,\n         }\n     }\n \n@@ -325,6 +328,10 @@ impl DefMap {\n         self.unstable_features.contains(feature)\n     }\n \n+    pub fn is_rustc_coherence_is_core(&self) -> bool {\n+        self.rustc_coherence_is_core\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -337,7 +344,7 @@ impl DefMap {\n         self.proc_macro_loading_error.as_deref()\n     }\n \n-    pub(crate) fn krate(&self) -> CrateId {\n+    pub fn krate(&self) -> CrateId {\n         self.krate\n     }\n \n@@ -502,6 +509,7 @@ impl DefMap {\n             krate: _,\n             prelude: _,\n             root: _,\n+            rustc_coherence_is_core: _,\n         } = self;\n \n         extern_prelude.shrink_to_fit();"}, {"sha": "ddcee77ec4ccfa3327c4d56cf024243878df7b41", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -296,6 +296,11 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                    self.def_map.rustc_coherence_is_core = true;\n+                    continue;\n+                }\n+\n                 if *attr_name == hir_expand::name![feature] {\n                     let features =\n                         attr.parse_path_comma_token_tree().into_iter().flatten().filter_map("}, {"sha": "4b147b99707c15ad6c71a171307b605cec108fe6", "filename": "crates/hir-ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -11,3 +11,9 @@ pub use crate::diagnostics::{\n     },\n     unsafe_check::{missing_unsafe, unsafe_expressions, UnsafeExpr},\n };\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct IncoherentImpl {\n+    pub file_id: hir_expand::HirFileId,\n+    pub impl_: syntax::AstPtr<syntax::ast::Impl>,\n+}"}, {"sha": "df698e3c745e04efdfa51c0eab4b9ebda93af513", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 102, "deletions": 7, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -19,7 +19,7 @@ use stdx::never;\n use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n-    from_foreign_def_id,\n+    from_chalk_trait_id, from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n@@ -266,11 +266,12 @@ impl TraitImpls {\n #[derive(Debug, Eq, PartialEq)]\n pub struct InherentImpls {\n     map: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    invalid_impls: Vec<ImplId>,\n }\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n         impls.collect_def_map(db, &crate_def_map);\n@@ -283,7 +284,7 @@ impl InherentImpls {\n         db: &dyn HirDatabase,\n         block: BlockId,\n     ) -> Option<Arc<Self>> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n         if let Some(block_def_map) = db.block_def_map(block) {\n             impls.collect_def_map(db, &block_def_map);\n             impls.shrink_to_fit();\n@@ -306,11 +307,17 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n-                if let Some(fp) = fp {\n-                    self.map.entry(fp).or_default().push(impl_id);\n+                let self_ty = self_ty.skip_binders();\n+\n+                match is_inherent_impl_coherent(db, def_map, &data, self_ty) {\n+                    true => {\n+                        // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n+                        if let Some(fp) = TyFingerprint::for_inherent_impl(self_ty) {\n+                            self.map.entry(fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                    false => self.invalid_impls.push(impl_id),\n                 }\n-                // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n             }\n \n             // To better support custom derives, collect impls in all unnamed const items.\n@@ -334,6 +341,10 @@ impl InherentImpls {\n     pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n         self.map.values().flat_map(|v| v.iter().copied())\n     }\n+\n+    pub fn invalid_impls(&self) -> &[ImplId] {\n+        &self.invalid_impls\n+    }\n }\n \n pub(crate) fn incoherent_inherent_impl_crates(\n@@ -775,6 +786,90 @@ fn find_matching_impl(\n     }\n }\n \n+fn is_inherent_impl_coherent(\n+    db: &dyn HirDatabase,\n+    def_map: &DefMap,\n+    impl_data: &ImplData,\n+    self_ty: &Ty,\n+) -> bool {\n+    let self_ty = self_ty.kind(Interner);\n+    let impl_allowed = match self_ty {\n+        TyKind::Tuple(_, _)\n+        | TyKind::FnDef(_, _)\n+        | TyKind::Array(_, _)\n+        | TyKind::Never\n+        | TyKind::Raw(_, _)\n+        | TyKind::Ref(_, _, _)\n+        | TyKind::Slice(_)\n+        | TyKind::Str\n+        | TyKind::Scalar(_) => def_map.is_rustc_coherence_is_core(),\n+\n+        &TyKind::Adt(AdtId(adt), _) => adt.module(db.upcast()).krate() == def_map.krate(),\n+        // FIXME: Factor out the principal trait fetching into a function\n+        TyKind::Dyn(it) => it\n+            .bounds\n+            .skip_binders()\n+            .interned()\n+            .get(0)\n+            .and_then(|b| match b.skip_binders() {\n+                crate::WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+                _ => None,\n+            })\n+            .map_or(false, |trait_ref| {\n+                from_chalk_trait_id(trait_ref.trait_id).module(db.upcast()).krate()\n+                    == def_map.krate()\n+            }),\n+\n+        _ => true,\n+    };\n+    impl_allowed || {\n+        let rustc_has_incoherent_inherent_impls = match self_ty {\n+            TyKind::Tuple(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Never\n+            | TyKind::Raw(_, _)\n+            | TyKind::Ref(_, _, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Str\n+            | TyKind::Scalar(_) => true,\n+\n+            &TyKind::Adt(AdtId(adt), _) => match adt {\n+                hir_def::AdtId::StructId(it) => {\n+                    db.struct_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(it) => {\n+                    db.union_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(it) => db.enum_data(it).rustc_has_incoherent_inherent_impls,\n+            },\n+            // FIXME: Factor out the principal trait fetching into a function\n+            TyKind::Dyn(it) => it\n+                .bounds\n+                .skip_binders()\n+                .interned()\n+                .get(0)\n+                .and_then(|b| match b.skip_binders() {\n+                    crate::WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+                    _ => None,\n+                })\n+                .map_or(false, |trait_ref| {\n+                    db.trait_data(from_chalk_trait_id(trait_ref.trait_id))\n+                        .rustc_has_incoherent_inherent_impls\n+                }),\n+\n+            _ => false,\n+        };\n+        rustc_has_incoherent_inherent_impls\n+            && !impl_data.items.is_empty()\n+            && impl_data.items.iter().copied().all(|assoc| match assoc {\n+                AssocItemId::FunctionId(it) => db.function_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::ConstId(it) => db.const_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::TypeAliasId(it) => db.type_alias_data(it).rustc_allow_incoherent_impl,\n+            })\n+    }\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "378d478336102f0c2399e7d2b2aedfd7531a0503", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -9,6 +9,7 @@ fn infer_slice_method() {\n     check_types(\n         r#\"\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -35,6 +36,7 @@ fn test() {\n //- /lib.rs crate:other_crate\n mod foo {\n     impl f32 {\n+        #[rustc_allow_incoherent_impl]\n         pub fn foo(self) -> f32 { 0. }\n     }\n }\n@@ -47,6 +49,7 @@ fn infer_array_inherent_impl() {\n     check_types(\n         r#\"\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -1437,6 +1440,7 @@ fn resolve_const_generic_array_methods() {\n         r#\"\n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n@@ -1445,6 +1449,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1468,6 +1473,7 @@ struct Const<const N: usize>;\n \n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, U, const X: usize>(self, f: F, c: Const<X>) -> [U; X]\n     where\n         F: FnMut(T) -> U,\n@@ -1476,6 +1482,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, const X: usize, U>(self, f: F, c: Const<X>) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1874,14 +1881,14 @@ fn incoherent_impls() {\n pub struct Box<T>(T);\n use core::error::Error;\n \n-#[rustc_allow_incoherent_impl]\n impl dyn Error {\n+    #[rustc_allow_incoherent_impl]\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         loop {}\n     }\n }\n-#[rustc_allow_incoherent_impl]\n impl dyn Error + Send {\n+    #[rustc_allow_incoherent_impl]\n     /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;"}, {"sha": "13cc3fea52d16281c33419c4788ab94f27f38222", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -1116,21 +1116,22 @@ fn infer_inherent_method() {\n fn infer_inherent_method_str() {\n     check_infer(\n         r#\"\n-        #[lang = \"str\"]\n-        impl str {\n-            fn foo(&self) -> i32 {}\n-        }\n+#![rustc_coherence_is_core]\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n \n-        fn test() {\n-            \"foo\".foo();\n-        }\n-        \"#,\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#,\n         expect![[r#\"\n-            39..43 'self': &str\n-            52..54 '{}': i32\n-            68..88 '{     ...o(); }': ()\n-            74..79 '\"foo\"': &str\n-            74..85 '\"foo\".foo()': i32\n+            67..71 'self': &str\n+            80..82 '{}': i32\n+            96..116 '{     ...o(); }': ()\n+            102..107 '\"foo\"': &str\n+            102..113 '\"foo\".foo()': i32\n         \"#]],\n     );\n }\n@@ -2640,6 +2641,7 @@ impl<T> [T] {}\n \n #[lang = \"slice_alloc\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n         unimplemented!()\n     }\n@@ -2655,22 +2657,22 @@ struct Astruct;\n impl B for Astruct {}\n \"#,\n         expect![[r#\"\n-            569..573 'self': Box<[T], A>\n-            602..634 '{     ...     }': Vec<T, A>\n-            648..761 '{     ...t]); }': ()\n-            658..661 'vec': Vec<i32, Global>\n-            664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n-            664..691 '<[_]>:...1i32])': Vec<i32, Global>\n-            680..690 'box [1i32]': Box<[i32; 1], Global>\n-            684..690 '[1i32]': [i32; 1]\n-            685..689 '1i32': i32\n-            701..702 'v': Vec<Box<dyn B, Global>, Global>\n-            722..739 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n-            722..758 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n-            740..757 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n-            744..757 '[box Astruct]': [Box<dyn B, Global>; 1]\n-            745..756 'box Astruct': Box<Astruct, Global>\n-            749..756 'Astruct': Astruct\n+            604..608 'self': Box<[T], A>\n+            637..669 '{     ...     }': Vec<T, A>\n+            683..796 '{     ...t]); }': ()\n+            693..696 'vec': Vec<i32, Global>\n+            699..714 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n+            699..726 '<[_]>:...1i32])': Vec<i32, Global>\n+            715..725 'box [1i32]': Box<[i32; 1], Global>\n+            719..725 '[1i32]': [i32; 1]\n+            720..724 '1i32': i32\n+            736..737 'v': Vec<Box<dyn B, Global>, Global>\n+            757..774 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n+            757..793 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n+            775..792 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n+            779..792 '[box Astruct]': [Box<dyn B, Global>; 1]\n+            780..791 'box Astruct': Box<Astruct, Global>\n+            784..791 'Astruct': Astruct\n         \"#]],\n     )\n }"}, {"sha": "253d62dafc60b20ec3845e7cd7c189112d6a8e48", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -3,6 +3,8 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n+pub use hir_ty::diagnostics::{IncoherentImpl, IncorrectCase};\n+\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n@@ -35,6 +37,7 @@ diagnostics![\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n+    IncoherentImpl,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n@@ -220,5 +223,3 @@ pub struct NeedMut {\n pub struct UnusedMut {\n     pub local: Local,\n }\n-\n-pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "35424feec8b29b294220be299c6ecaab1e1594cf", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -85,10 +85,10 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n+        IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n+        MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n+        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n@@ -604,11 +604,23 @@ impl Module {\n             }\n         }\n \n+        let inherent_impls = db.inherent_impls_in_crate(self.id.krate());\n+\n         for impl_def in self.impl_defs(db) {\n             for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n                 emit_def_diagnostic(db, acc, diag);\n             }\n \n+            if inherent_impls.invalid_impls().contains(&impl_def.id) {\n+                let loc = impl_def.id.lookup(db.upcast());\n+                let tree = loc.id.item_tree(db.upcast());\n+                let node = &tree[loc.id.value];\n+                let file_id = loc.id.file_id();\n+                let ast_id_map = db.ast_id_map(file_id);\n+\n+                acc.push(IncoherentImpl { impl_: ast_id_map.get(node.ast_id()), file_id }.into())\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),"}, {"sha": "72af9ebfcbb62e48a6c110bfaa5bbcca21b2b2cc", "filename": "crates/ide-diagnostics/src/handlers/incoherent_impl.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -0,0 +1,77 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: incoherent-impl\n+//\n+// This diagnostic is triggered if the targe type of an impl is from a foreign crate.\n+pub(crate) fn incoherent_impl(ctx: &DiagnosticsContext<'_>, d: &hir::IncoherentImpl) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incoherent-impl\",\n+        format!(\"cannot define inherent `impl` for foreign type\"),\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file_id, d.impl_.clone().into())).range,\n+    )\n+    .severity(Severity::Error)\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn primitive() {\n+        check_diagnostics(\n+            r#\"\n+  impl bool {}\n+//^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+impl bool {\n+    #[rustc_allow_incoherent_impl]\n+    fn falsch(self) -> Self { false }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+impl foo::S {\n+    #[rustc_allow_incoherent_impl]\n+    fn func(self) {}\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { #[rustc_allow_incoherent_impl] fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "71f136b8c9030c0e85f9de909eb11b18368496e7", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -29,6 +29,7 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n+    pub(crate) mod incoherent_impl;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n@@ -254,6 +255,7 @@ pub fn diagnostics(\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),"}, {"sha": "ca6de4061a4b8d24c8ced00e423c72e9e9d511f2", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34b2469bd0327b3e023c2048190eb4865d20eed/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=f34b2469bd0327b3e023c2048190eb4865d20eed", "patch": "@@ -44,6 +44,8 @@\n //!     try: infallible\n //!     unsize: sized\n \n+#![rustc_coherence_is_core]\n+\n pub mod marker {\n     // region:sized\n     #[lang = \"sized\"]"}]}