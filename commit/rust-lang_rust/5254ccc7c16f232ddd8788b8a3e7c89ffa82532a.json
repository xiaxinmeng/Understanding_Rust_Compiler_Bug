{"sha": "5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNTRjY2M3YzE2ZjIzMmRkZDg3ODhiOGEzZTdjODlmZmE4MjUzMmE=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-29T20:45:26Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-30T16:54:03Z"}, "message": "Update after the fall out from the syntax::ptr changes", "tree": {"sha": "db7e6a84d48507636001d3dd7093d53f5fa4fef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db7e6a84d48507636001d3dd7093d53f5fa4fef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "html_url": "https://github.com/rust-lang/rust/commit/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a/comments", "author": null, "committer": null, "parents": [{"sha": "e53f4a6b94623076a912df0c770c591d710c5de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53f4a6b94623076a912df0c770c591d710c5de0", "html_url": "https://github.com/rust-lang/rust/commit/e53f4a6b94623076a912df0c770c591d710c5de0"}], "stats": {"total": 70, "additions": 38, "deletions": 32}, "files": [{"sha": "de9125ec44918419319650d7fac240e9a0c44f74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "patch": "@@ -267,8 +267,8 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                             // We don't want two, that's just confusing.\n                         } else {\n                             // find the first arm pattern so we can use its span\n-                            let &(ref first_arm_pats, _) = &arms[0]; // we know there's at least 1 arm\n-                            let first_pat = first_arm_pats.get(0); // and it's safe to assume 1 pat\n+                            let &(ref first_arm_pats, _) = &arms[0];\n+                            let first_pat = first_arm_pats.get(0);\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n                             printed_if_let_err = true;"}, {"sha": "fa3ccc8cf326e369bcec8fc5845ba3dfde6b14ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5254ccc7c16f232ddd8788b8a3e7c89ffa82532a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5254ccc7c16f232ddd8788b8a3e7c89ffa82532a", "patch": "@@ -70,8 +70,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         // Desugar ExprIfLet\n         // From: `if let <pat> = <expr> <body> [<elseopt>]`\n         ast::ExprIfLet(pat, expr, body, mut elseopt) => {\n-            let span = e.span;\n-\n             // to:\n             //\n             //   match <expr> {\n@@ -90,23 +88,33 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let else_if_arms = {\n                 let mut arms = vec![];\n                 loop {\n-                    // NOTE: replace with 'if let' after snapshot\n-                    match elseopt {\n-                        Some(els) => match els.node {\n-                            // else if\n-                            ast::ExprIf(cond, then, elseopt_) => {\n-                                let pat_under = fld.cx.pat_wild(span);\n-                                elseopt = elseopt_;\n-                                arms.push(ast::Arm {\n-                                    attrs: vec![],\n-                                    pats: vec![pat_under],\n-                                    guard: Some(cond),\n-                                    body: fld.cx.expr_block(then)\n-                                });\n-                            }\n-                            _ => break\n-                        },\n-                        None => break\n+                    let elseopt_continue = elseopt\n+                        .and_then(|els| els.and_then(|els| match els.node {\n+                        // else if\n+                        ast::ExprIf(cond, then, elseopt) => {\n+                            let pat_under = fld.cx.pat_wild(span);\n+                            arms.push(ast::Arm {\n+                                attrs: vec![],\n+                                pats: vec![pat_under],\n+                                guard: Some(cond),\n+                                body: fld.cx.expr_block(then)\n+                            });\n+                            elseopt.map(|elseopt| (elseopt, true))\n+                        }\n+                        _ => Some((P(els), false))\n+                    }));\n+                    match elseopt_continue {\n+                        Some((e, true)) => {\n+                            elseopt = Some(e);\n+                        }\n+                        Some((e, false)) => {\n+                            elseopt = Some(e);\n+                            break;\n+                        }\n+                        None => {\n+                            elseopt = None;\n+                            break;\n+                        }\n                     }\n                 }\n                 arms\n@@ -115,10 +123,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // `_ => [<elseopt> | ()]`\n             let else_arm = {\n                 let pat_under = fld.cx.pat_wild(span);\n-                let else_expr = match elseopt {\n-                    Some(els) => els,\n-                    None => fld.cx.expr_lit(span, ast::LitNil)\n-                };\n+                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_lit(span, ast::LitNil));\n                 fld.cx.arm(span, vec![pat_under], else_expr)\n             };\n \n@@ -133,23 +138,24 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n         // Desugar support for ExprIfLet in the ExprIf else position\n         ast::ExprIf(cond, blk, elseopt) => {\n-            let elseopt = elseopt.map(|els| match els.node {\n+            let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n                 ast::ExprIfLet(..) => {\n                     // wrap the if-let expr in a block\n+                    let span = els.span;\n                     let blk = P(ast::Block {\n                         view_items: vec![],\n                         stmts: vec![],\n-                        expr: Some(els),\n+                        expr: Some(P(els)),\n                         id: ast::DUMMY_NODE_ID,\n                         rules: ast::DefaultBlock,\n-                        span: els.span\n+                        span: span\n                     });\n                     fld.cx.expr_block(blk)\n                 }\n-                _ => els\n-            });\n-            let if_expr = fld.cx.expr(e.span, ast::ExprIf(cond, blk, elseopt));\n-            noop_fold_expr(if_expr, fld)\n+                _ => P(els)\n+            }));\n+            let if_expr = fld.cx.expr(span, ast::ExprIf(cond, blk, elseopt));\n+            if_expr.map(|e| noop_fold_expr(e, fld))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {"}]}