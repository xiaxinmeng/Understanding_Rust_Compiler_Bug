{"sha": "c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "node_id": "C_kwDOAAsO6NoAKGM1Y2VhZWZhMDllNTJlM2VhNjUxMzJlYmM0NDEwNjkzMWM5NWUyYTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-30T19:36:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-30T19:44:56Z"}, "message": "Restructure syntax element highlighting", "tree": {"sha": "38f08b48e8561757a088b48d8e2b473a87b9c6c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38f08b48e8561757a088b48d8e2b473a87b9c6c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "html_url": "https://github.com/rust-lang/rust/commit/c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c7ea0c9a1b60780ff20ab8e099085a7d4a41769", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7ea0c9a1b60780ff20ab8e099085a7d4a41769", "html_url": "https://github.com/rust-lang/rust/commit/0c7ea0c9a1b60780ff20ab8e099085a7d4a41769"}], "stats": {"total": 401, "additions": 211, "deletions": 190}, "files": [{"sha": "cb23fec3c7c382d29c1c74295700c3258d703b5d", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "patch": "@@ -309,6 +309,7 @@ fn traverse(\n                     match (token.kind(), parent.kind()) {\n                         (T![ident], NAME | NAME_REF) => parent.into(),\n                         (T![self] | T![super] | T![crate], NAME_REF) => parent.into(),\n+                        (INT_NUMBER, NAME_REF) => parent.into(),\n                         _ => token.into(),\n                     }\n                 }"}, {"sha": "65705d303c677aa22a7b19b321a4c4dd64f82b30", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 206, "deletions": 188, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "patch": "@@ -8,7 +8,7 @@ use ide_db::{\n };\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast, AstNode, AstToken, NodeOrToken, SyntaxElement,\n+    ast, match_ast, AstNode, AstToken, NodeOrToken, SyntaxElement,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n@@ -25,202 +25,220 @@ pub(super) fn element(\n     syntactic_name_ref_highlighting: bool,\n     element: SyntaxElement,\n ) -> Option<(Highlight, Option<u64>)> {\n-    let mut binding_hash = None;\n-    let highlight: Highlight = match element.kind() {\n-        FN => {\n-            bindings_shadow_count.clear();\n-            return None;\n-        }\n-        // Highlight definitions depending on the \"type\" of the definition.\n-        NAME => {\n-            let name = element.into_node().and_then(ast::Name::cast).unwrap();\n-            highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n-        }\n-        // Highlight references like the definitions they resolve to\n-        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n-            // FIXME: We highlight paths in attributes slightly differently to work around this module\n-            // currently not knowing about tool attributes and rustc builtin attributes as\n-            // we do not want to resolve those to functions that may be defined in scope.\n-            let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            highlight_name_ref_in_attr(sema, name_ref)\n+    match element {\n+        NodeOrToken::Node(it) => {\n+            node(sema, krate, bindings_shadow_count, syntactic_name_ref_highlighting, it)\n         }\n-        NAME_REF => {\n-            let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            highlight_name_ref(\n-                sema,\n-                krate,\n-                bindings_shadow_count,\n-                &mut binding_hash,\n-                syntactic_name_ref_highlighting,\n-                name_ref,\n-            )\n-        }\n-        // Simple token-based highlighting\n-        COMMENT => {\n-            let comment = element.into_token().and_then(ast::Comment::cast)?;\n-            let h = HlTag::Comment;\n-            match comment.kind().doc {\n-                Some(_) => h | HlMod::Documentation,\n-                None => h.into(),\n-            }\n-        }\n-        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n-        ATTR => HlTag::Attribute.into(),\n-        INT_NUMBER if element.ancestors().nth(1).map_or(false, |it| it.kind() == FIELD_EXPR) => {\n-            SymbolKind::Field.into()\n-        }\n-        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n-        BYTE => HlTag::ByteLiteral.into(),\n-        CHAR => HlTag::CharLiteral.into(),\n-        QUESTION => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n-        LIFETIME => {\n-            let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n-\n-            match NameClass::classify_lifetime(sema, &lifetime) {\n-                Some(NameClass::Definition(def)) => {\n-                    highlight_def(sema, krate, def) | HlMod::Definition\n-                }\n-                None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n-                    Some(NameRefClass::Definition(def)) => highlight_def(sema, krate, def),\n-                    _ => SymbolKind::LifetimeParam.into(),\n-                },\n-                _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n-            }\n-        }\n-        IDENT if parent_matches::<ast::TokenTree>(&element) => {\n-            if let Some((attr, token)) =\n-                element.ancestors().nth(2).and_then(ast::Attr::cast).zip(element.as_token())\n-            {\n-                match try_resolve_derive_input_at(sema, &attr, token) {\n-                    Some(makro) => highlight_def(sema, krate, Definition::Macro(makro)),\n-                    None => HlTag::None.into(),\n-                }\n-            } else {\n-                HlTag::None.into()\n-            }\n+        NodeOrToken::Token(it) => Some((token(sema, krate, it)?, None)),\n+    }\n+}\n+\n+fn token(\n+    sema: &Semantics<RootDatabase>,\n+    krate: Option<hir::Crate>,\n+    token: SyntaxToken,\n+) -> Option<Highlight> {\n+    let highlight: Highlight = if let Some(comment) = ast::Comment::cast(token.clone()) {\n+        let h = HlTag::Comment;\n+        match comment.kind().doc {\n+            Some(_) => h | HlMod::Documentation,\n+            None => h.into(),\n         }\n-        p if p.is_punct() => match p {\n-            T![&] if parent_matches::<ast::BinExpr>(&element) => HlOperator::Bitwise.into(),\n-            T![&] => {\n-                let h = HlTag::Operator(HlOperator::Other).into();\n-                let is_unsafe = element\n-                    .parent()\n-                    .and_then(ast::RefExpr::cast)\n-                    .map_or(false, |ref_expr| sema.is_unsafe_ref_expr(&ref_expr));\n-                if is_unsafe {\n-                    h | HlMod::Unsafe\n+    } else {\n+        match token.kind() {\n+            STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n+            INT_NUMBER if token.ancestors().nth(1).map_or(false, |it| it.kind() == FIELD_EXPR) => {\n+                SymbolKind::Field.into()\n+            }\n+            INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n+            BYTE => HlTag::ByteLiteral.into(),\n+            CHAR => HlTag::CharLiteral.into(),\n+            T![?] => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n+            IDENT if parent_matches::<ast::TokenTree>(&token) => {\n+                if let Some(attr) = token.ancestors().nth(2).and_then(ast::Attr::cast) {\n+                    match try_resolve_derive_input_at(sema, &attr, &token) {\n+                        Some(makro) => highlight_def(sema, krate, Definition::Macro(makro)),\n+                        None => HlTag::None.into(),\n+                    }\n                 } else {\n-                    h\n+                    HlTag::None.into()\n                 }\n             }\n-            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlOperator::Other.into(),\n-            T![!] if parent_matches::<ast::MacroCall>(&element) => SymbolKind::Macro.into(),\n-            T![!] if parent_matches::<ast::NeverType>(&element) => HlTag::BuiltinType.into(),\n-            T![!] if parent_matches::<ast::PrefixExpr>(&element) => HlOperator::Logical.into(),\n-            T![*] if parent_matches::<ast::PtrType>(&element) => HlTag::Keyword.into(),\n-            T![*] if parent_matches::<ast::PrefixExpr>(&element) => {\n-                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                let expr = prefix_expr.expr()?;\n-                let ty = sema.type_of_expr(&expr)?.original;\n-                if ty.is_raw_ptr() {\n-                    HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n-                } else if let Some(ast::UnaryOp::Deref) = prefix_expr.op_kind() {\n+            p if p.is_punct() => match p {\n+                T![&] if parent_matches::<ast::BinExpr>(&token) => HlOperator::Bitwise.into(),\n+                T![&] => {\n+                    let h = HlTag::Operator(HlOperator::Other).into();\n+                    let is_unsafe = token\n+                        .parent()\n+                        .and_then(ast::RefExpr::cast)\n+                        .map_or(false, |ref_expr| sema.is_unsafe_ref_expr(&ref_expr));\n+                    if is_unsafe {\n+                        h | HlMod::Unsafe\n+                    } else {\n+                        h\n+                    }\n+                }\n+                T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => {\n                     HlOperator::Other.into()\n-                } else {\n-                    HlPunct::Other.into()\n                 }\n-            }\n-            T![-] if parent_matches::<ast::PrefixExpr>(&element) => {\n-                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                let expr = prefix_expr.expr()?;\n-                match expr {\n-                    ast::Expr::Literal(_) => HlTag::NumericLiteral,\n-                    _ => HlTag::Operator(HlOperator::Other),\n+                T![!] if parent_matches::<ast::MacroCall>(&token) => SymbolKind::Macro.into(),\n+                T![!] if parent_matches::<ast::NeverType>(&token) => HlTag::BuiltinType.into(),\n+                T![!] if parent_matches::<ast::PrefixExpr>(&token) => HlOperator::Logical.into(),\n+                T![*] if parent_matches::<ast::PtrType>(&token) => HlTag::Keyword.into(),\n+                T![*] if parent_matches::<ast::PrefixExpr>(&token) => {\n+                    let prefix_expr = token.parent().and_then(ast::PrefixExpr::cast)?;\n+\n+                    let expr = prefix_expr.expr()?;\n+                    let ty = sema.type_of_expr(&expr)?.original;\n+                    if ty.is_raw_ptr() {\n+                        HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n+                    } else if let Some(ast::UnaryOp::Deref) = prefix_expr.op_kind() {\n+                        HlOperator::Other.into()\n+                    } else {\n+                        HlPunct::Other.into()\n+                    }\n                 }\n-                .into()\n-            }\n-            _ if parent_matches::<ast::PrefixExpr>(&element) => HlOperator::Other.into(),\n-            T![+] | T![-] | T![*] | T![/] if parent_matches::<ast::BinExpr>(&element) => {\n-                HlOperator::Arithmetic.into()\n-            }\n-            T![+=] | T![-=] | T![*=] | T![/=] if parent_matches::<ast::BinExpr>(&element) => {\n-                Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n-            }\n-            T![|] | T![&] | T![!] | T![^] if parent_matches::<ast::BinExpr>(&element) => {\n-                HlOperator::Bitwise.into()\n-            }\n-            T![|=] | T![&=] | T![^=] if parent_matches::<ast::BinExpr>(&element) => {\n-                Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n-            }\n-            T![&&] | T![||] if parent_matches::<ast::BinExpr>(&element) => {\n-                HlOperator::Logical.into()\n-            }\n-            T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=]\n-                if parent_matches::<ast::BinExpr>(&element) =>\n-            {\n-                HlOperator::Comparison.into()\n-            }\n-            _ if parent_matches::<ast::BinExpr>(&element) => HlOperator::Other.into(),\n-            _ if parent_matches::<ast::RangeExpr>(&element) => HlOperator::Other.into(),\n-            _ if parent_matches::<ast::RangePat>(&element) => HlOperator::Other.into(),\n-            _ if parent_matches::<ast::RestPat>(&element) => HlOperator::Other.into(),\n-            _ if parent_matches::<ast::Attr>(&element) => HlTag::Attribute.into(),\n-            kind => match kind {\n-                T!['['] | T![']'] => HlPunct::Bracket,\n-                T!['{'] | T!['}'] => HlPunct::Brace,\n-                T!['('] | T![')'] => HlPunct::Parenthesis,\n-                T![<] | T![>] => HlPunct::Angle,\n-                T![,] => HlPunct::Comma,\n-                T![:] => HlPunct::Colon,\n-                T![;] => HlPunct::Semi,\n-                T![.] => HlPunct::Dot,\n-                _ => HlPunct::Other,\n-            }\n-            .into(),\n-        },\n+                T![-] if parent_matches::<ast::PrefixExpr>(&token) => {\n+                    let prefix_expr = token.parent().and_then(ast::PrefixExpr::cast)?;\n \n-        k if k.is_keyword() => {\n-            let h = Highlight::new(HlTag::Keyword);\n-            match k {\n-                T![await] => h | HlMod::Async | HlMod::ControlFlow,\n-                T![break]\n-                | T![continue]\n-                | T![else]\n-                | T![if]\n-                | T![in]\n-                | T![loop]\n-                | T![match]\n-                | T![return]\n-                | T![while]\n-                | T![yield] => h | HlMod::ControlFlow,\n-                T![for] if !is_child_of_impl(&element) => h | HlMod::ControlFlow,\n-                T![unsafe] => h | HlMod::Unsafe,\n-                T![true] | T![false] => HlTag::BoolLiteral.into(),\n-                // self is handled as either a Name or NameRef already\n-                T![self] => return None,\n-                T![ref] => element\n-                    .parent()\n-                    .and_then(ast::IdentPat::cast)\n-                    .and_then(|ident_pat| {\n-                        if sema.is_unsafe_ident_pat(&ident_pat) {\n-                            Some(HlMod::Unsafe)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|modifier| h | modifier)\n-                    .unwrap_or(h),\n-                T![async] => h | HlMod::Async,\n-                _ => h,\n+                    let expr = prefix_expr.expr()?;\n+                    match expr {\n+                        ast::Expr::Literal(_) => HlTag::NumericLiteral,\n+                        _ => HlTag::Operator(HlOperator::Other),\n+                    }\n+                    .into()\n+                }\n+                _ if parent_matches::<ast::PrefixExpr>(&token) => HlOperator::Other.into(),\n+                T![+] | T![-] | T![*] | T![/] if parent_matches::<ast::BinExpr>(&token) => {\n+                    HlOperator::Arithmetic.into()\n+                }\n+                T![+=] | T![-=] | T![*=] | T![/=] if parent_matches::<ast::BinExpr>(&token) => {\n+                    Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n+                }\n+                T![|] | T![&] | T![!] | T![^] if parent_matches::<ast::BinExpr>(&token) => {\n+                    HlOperator::Bitwise.into()\n+                }\n+                T![|=] | T![&=] | T![^=] if parent_matches::<ast::BinExpr>(&token) => {\n+                    Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n+                }\n+                T![&&] | T![||] if parent_matches::<ast::BinExpr>(&token) => {\n+                    HlOperator::Logical.into()\n+                }\n+                T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=]\n+                    if parent_matches::<ast::BinExpr>(&token) =>\n+                {\n+                    HlOperator::Comparison.into()\n+                }\n+                _ if parent_matches::<ast::BinExpr>(&token) => HlOperator::Other.into(),\n+                _ if parent_matches::<ast::RangeExpr>(&token) => HlOperator::Other.into(),\n+                _ if parent_matches::<ast::RangePat>(&token) => HlOperator::Other.into(),\n+                _ if parent_matches::<ast::RestPat>(&token) => HlOperator::Other.into(),\n+                _ if parent_matches::<ast::Attr>(&token) => HlTag::Attribute.into(),\n+                kind => match kind {\n+                    T!['['] | T![']'] => HlPunct::Bracket,\n+                    T!['{'] | T!['}'] => HlPunct::Brace,\n+                    T!['('] | T![')'] => HlPunct::Parenthesis,\n+                    T![<] | T![>] => HlPunct::Angle,\n+                    T![,] => HlPunct::Comma,\n+                    T![:] => HlPunct::Colon,\n+                    T![;] => HlPunct::Semi,\n+                    T![.] => HlPunct::Dot,\n+                    _ => HlPunct::Other,\n+                }\n+                .into(),\n+            },\n+            k if k.is_keyword() => {\n+                let h = Highlight::new(HlTag::Keyword);\n+                match k {\n+                    T![await] => h | HlMod::Async | HlMod::ControlFlow,\n+                    T![break]\n+                    | T![continue]\n+                    | T![else]\n+                    | T![if]\n+                    | T![in]\n+                    | T![loop]\n+                    | T![match]\n+                    | T![return]\n+                    | T![while]\n+                    | T![yield] => h | HlMod::ControlFlow,\n+                    T![for] if !is_child_of_impl(&token) => h | HlMod::ControlFlow,\n+                    T![unsafe] => h | HlMod::Unsafe,\n+                    T![true] | T![false] => HlTag::BoolLiteral.into(),\n+                    // self is handled as either a Name or NameRef already\n+                    T![self] => return None,\n+                    T![ref] => token\n+                        .parent()\n+                        .and_then(ast::IdentPat::cast)\n+                        .and_then(|ident_pat| {\n+                            (sema.is_unsafe_ident_pat(&ident_pat)).then(|| HlMod::Unsafe)\n+                        })\n+                        .map_or(h, |modifier| h | modifier),\n+                    T![async] => h | HlMod::Async,\n+                    _ => h,\n+                }\n             }\n+            _ => return None,\n         }\n-\n-        _ => return None,\n     };\n+    Some(highlight)\n+}\n \n-    return Some((highlight, binding_hash));\n+fn node(\n+    sema: &Semantics<RootDatabase>,\n+    krate: Option<hir::Crate>,\n+    bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n+    syntactic_name_ref_highlighting: bool,\n+    node: SyntaxNode,\n+) -> Option<(Highlight, Option<u64>)> {\n+    let mut binding_hash = None;\n+    let highlight = match_ast! {\n+        match node {\n+            ast::Fn(__) => {\n+                bindings_shadow_count.clear();\n+                return None;\n+            },\n+            ast::Attr(__) => {\n+                HlTag::Attribute.into()\n+            },\n+            // Highlight definitions depending on the \"type\" of the definition.\n+            ast::Name(name) => {\n+                highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n+            },\n+            // Highlight references like the definitions they resolve to\n+            ast::NameRef(name_ref) => {\n+                if node.ancestors().any(|it| it.kind() == ATTR) {\n+\n+                    // FIXME: We highlight paths in attributes slightly differently to work around this module\n+                    // currently not knowing about tool attributes and rustc builtin attributes as\n+                    // we do not want to resolve those to functions that may be defined in scope.\n+                    highlight_name_ref_in_attr(sema, name_ref)\n+                } else {\n+                    highlight_name_ref(\n+                        sema,\n+                        krate,\n+                        bindings_shadow_count,\n+                        &mut binding_hash,\n+                        syntactic_name_ref_highlighting,\n+                        name_ref,\n+                    )\n+                }\n+            },\n+            ast::Lifetime(lifetime) => {\n+                match NameClass::classify_lifetime(sema, &lifetime) {\n+                    Some(NameClass::Definition(def)) => {\n+                        highlight_def(sema, krate, def) | HlMod::Definition\n+                    }\n+                    None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n+                        Some(NameRefClass::Definition(def)) => highlight_def(sema, krate, def),\n+                        _ => SymbolKind::LifetimeParam.into(),\n+                    },\n+                    _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n+                }\n+            },\n+            _ => return None,\n+        }\n+    };\n+    Some((highlight, binding_hash))\n }\n \n fn highlight_name_ref_in_attr(sema: &Semantics<RootDatabase>, name_ref: ast::NameRef) -> Highlight {\n@@ -715,12 +733,12 @@ fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[Sy\n }\n \n #[inline]\n-fn parent_matches<N: AstNode>(element: &SyntaxElement) -> bool {\n-    element.parent().map_or(false, |it| N::can_cast(it.kind()))\n+fn parent_matches<N: AstNode>(token: &SyntaxToken) -> bool {\n+    token.parent().map_or(false, |it| N::can_cast(it.kind()))\n }\n \n-fn is_child_of_impl(element: &SyntaxElement) -> bool {\n-    match element.parent() {\n+fn is_child_of_impl(token: &SyntaxToken) -> bool {\n+    match token.parent() {\n         Some(e) => e.kind() == IMPL,\n         _ => false,\n     }"}, {"sha": "91587b11f534d0781010bc4910d0ba68af92f0ab", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "patch": "@@ -12,11 +12,10 @@ use syntax::{\n \n use crate::{\n     doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n+    syntax_highlighting::{highlights::Highlights, injector::Injector},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n-use super::{highlights::Highlights, injector::Injector};\n-\n pub(super) fn ra_fixture(\n     hl: &mut Highlights,\n     sema: &Semantics<RootDatabase>,"}, {"sha": "211dc54f2b6af8e943f3806e37a8faf25f11ecb6", "filename": "crates/ide/src/syntax_highlighting/injector.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ceaefa09e52e3ea65132ebc44106931c95e2a1/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs?ref=c5ceaefa09e52e3ea65132ebc44106931c95e2a1", "patch": "@@ -17,9 +17,11 @@ impl Injector {\n         assert_eq!(len, source_range.len());\n         self.add_impl(text, Some(source_range.start()));\n     }\n+\n     pub(super) fn add_unmapped(&mut self, text: &str) {\n         self.add_impl(text, None);\n     }\n+\n     fn add_impl(&mut self, text: &str, source: Option<TextSize>) {\n         let len = TextSize::of(text);\n         let target_range = TextRange::at(TextSize::of(&self.buf), len);\n@@ -30,6 +32,7 @@ impl Injector {\n     pub(super) fn text(&self) -> &str {\n         &self.buf\n     }\n+\n     pub(super) fn map_range_up(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {\n         equal_range_by(&self.ranges, |&(r, _)| TextRange::ordering(r, range)).filter_map(move |i| {\n             let (target_range, delta) = self.ranges[i];"}]}