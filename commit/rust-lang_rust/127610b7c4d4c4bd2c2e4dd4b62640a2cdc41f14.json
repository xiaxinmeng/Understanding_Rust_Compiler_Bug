{"sha": "127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNzYxMGI3YzRkNGM0YmQyYzJlNGRkNGI2MjY0MGEyY2RjNDFmMTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-02T10:31:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-04T08:31:13Z"}, "message": "Go back to just passing MemoryExtra to the machine-level allocation hooks\n\nThis is needed to avoid doing unnecessary global alloc_map lookups", "tree": {"sha": "33c0bdc4cd64370a7cdcf7452e2fc2f556f13179", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33c0bdc4cd64370a7cdcf7452e2fc2f556f13179"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "html_url": "https://github.com/rust-lang/rust/commit/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ad28cd2cb77758cc0a77555db5c03648fc8cd3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad28cd2cb77758cc0a77555db5c03648fc8cd3f", "html_url": "https://github.com/rust-lang/rust/commit/8ad28cd2cb77758cc0a77555db5c03648fc8cd3f"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "2d07103d5ee30198b6ee8b6372fb50ade36bbea0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "patch": "@@ -23,7 +23,7 @@ use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n-    Allocation, AllocId, MemoryKind, Memory,\n+    Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n@@ -406,7 +406,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn tag_allocation<'b>(\n-        _memory: &Memory<'mir, 'tcx, Self>,\n+        _memory_extra: &(),\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<!>>,\n@@ -417,7 +417,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn tag_static_base_pointer(\n-        _memory: &Memory<'mir, 'tcx, Self>,\n+        _memory_extra: &(),\n         _id: AllocId,\n     ) -> Self::PointerTag {\n         ()"}, {"sha": "f283cacb792d38420cdeb53f09a63d8e0c90ce44", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "patch": "@@ -174,7 +174,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// For static allocations, the tag returned must be the same as the one returned by\n     /// `tag_static_base_pointer`.\n     fn tag_allocation<'b>(\n-        memory: &Memory<'mir, 'tcx, Self>,\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n@@ -186,7 +186,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n     /// for cyclic statics!\n     fn tag_static_base_pointer(\n-        memory: &Memory<'mir, 'tcx, Self>,\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n     ) -> Self::PointerTag;\n "}, {"sha": "0171325e5e3a48693bd0009a063c8424c84e5bd7", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=127610b7c4d4c4bd2c2e4dd4b62640a2cdc41f14", "patch": "@@ -117,7 +117,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        ptr.with_tag(M::tag_static_base_pointer(&self, ptr.alloc_id))\n+        ptr.with_tag(M::tag_static_base_pointer(&self.extra, ptr.alloc_id))\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n@@ -150,7 +150,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        let (alloc, tag) = M::tag_allocation(&self, id, Cow::Owned(alloc), Some(kind));\n+        let (alloc, tag) = M::tag_allocation(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n     }\n@@ -368,9 +368,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// contains a reference to memory that was created during its evaluation (i.e., not to\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n-        id: AllocId,\n+        memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n-        memory: &Memory<'mir, 'tcx, M>,\n+        id: AllocId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n@@ -414,7 +414,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // We got tcx memory. Let the machine figure out whether and how to\n         // turn that into memory with the right pointer tag.\n         Ok(M::tag_allocation(\n-            memory,\n+            memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::STATIC_KIND.map(MemoryKind::Machine),\n@@ -430,7 +430,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(id, self.tcx, &self).map_err(Err)?;\n+            let alloc = Self::get_static_alloc(&self.extra, self.tcx, id).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -459,11 +459,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n-        let alloc = Self::get_static_alloc(id, tcx, &self);\n+        let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = alloc?;\n+            let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n                 return err!(ModifiedConstantMemory);\n             }"}]}