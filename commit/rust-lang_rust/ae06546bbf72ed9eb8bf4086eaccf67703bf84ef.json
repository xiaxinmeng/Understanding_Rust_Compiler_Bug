{"sha": "ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDY1NDZiYmY3MmVkOWViOGJmNDA4NmVhY2NmNjc3MDNiZjg0ZWY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-28T06:09:51Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-28T06:09:51Z"}, "message": "Replace more vector + (issue #2719)", "tree": {"sha": "017518fabfda8abf92c61ba03872d6a39f735ec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/017518fabfda8abf92c61ba03872d6a39f735ec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "html_url": "https://github.com/rust-lang/rust/commit/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b84437b68f4b54e05eb4639230c46b925abf902", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b84437b68f4b54e05eb4639230c46b925abf902", "html_url": "https://github.com/rust-lang/rust/commit/0b84437b68f4b54e05eb4639230c46b925abf902"}], "stats": {"total": 147, "additions": 82, "deletions": 65}, "files": [{"sha": "fc222bf33b2f02004f19e2806114378e08fb2aaf", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -1888,7 +1888,7 @@ mod tests {\n         let mut results: [[int]/~]/~;\n \n         results = []/~;\n-        permute([]/~) {|v| results += [v]/~; }\n+        permute([]/~) {|v| vec::push(results, v); }\n         assert results == [[]/~]/~;\n \n         results = []/~;"}, {"sha": "c01c03bcd460a4b44fb0dcfd15376431e6c63fda", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -77,7 +77,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: [ast::attribute]/~) -> [@ast::meta_item]/~ {\n     let mut mitems = []/~;\n-    for attrs.each {|a| mitems += [attr_meta(a)]/~; }\n+    for attrs.each {|a| vec::push(mitems, attr_meta(a)); }\n     ret mitems;\n }\n \n@@ -303,7 +303,7 @@ fn find_linkage_attrs(attrs: [ast::attribute]/~) -> [ast::attribute]/~ {\n     let mut found = []/~;\n     for find_attrs_by_name(attrs, \"link\").each {|attr|\n         alt attr.node.value.node {\n-          ast::meta_list(_, _) { found += [attr]/~ }\n+          ast::meta_list(_, _) { vec::push(found, attr) }\n           _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n         }\n     }"}, {"sha": "06fb6b94f6e67ebb294b4034b1630b5b4fd82f28", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -103,12 +103,14 @@ fn expand(cx: ext_ctxt,\n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps, _) {\n-            [filter_attrs(in_item)]/~ + ty_fns(cx, in_item.ident, ty, tps)\n+            vec::append([filter_attrs(in_item)]/~,\n+                        ty_fns(cx, in_item.ident, ty, tps))\n           }\n \n           ast::item_enum(variants, tps, _) {\n-            [filter_attrs(in_item)]/~ + enum_fns(cx, in_item.ident,\n-                                               in_item.span, variants, tps)\n+            vec::append([filter_attrs(in_item)]/~,\n+                        enum_fns(cx, in_item.ident,\n+                                 in_item.span, variants, tps))\n           }\n \n           _ {\n@@ -126,7 +128,8 @@ impl helpers for ext_ctxt {\n                    helper_name: str) -> @ast::path {\n         let head = vec::init(base_path.idents);\n         let tail = vec::last(base_path.idents);\n-        self.path(base_path.span, head + [@(helper_name + \"_\" + *tail)]/~)\n+        self.path(base_path.span,\n+                  vec::append(head, [@(helper_name + \"_\" + *tail)]/~))\n     }\n \n     fn path(span: span, strs: [ast::ident]/~) -> @ast::path {\n@@ -301,7 +304,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n     [cx.stmt(\n         cx.expr(\n             path.span,\n-            ast::expr_call(callee, [s, v]/~ + ty_args, false)))]/~\n+            ast::expr_call(callee, vec::append([s, v]/~, ty_args), false)))]/~\n }\n \n fn ser_variant(cx: ext_ctxt,\n@@ -502,15 +505,15 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n \n \n     let ser_inputs: [ast::arg]/~ =\n-        [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [@\"__S\"]/~, []/~),\n-          ident: @\"__s\",\n-          id: cx.next_id()},\n-         {mode: ast::expl(ast::by_ref),\n-          ty: v_ty,\n-          ident: @\"__v\",\n-          id: cx.next_id()}]/~\n-        + tp_inputs;\n+        vec::append([{mode: ast::expl(ast::by_ref),\n+                      ty: cx.ty_path(span, [@\"__S\"]/~, []/~),\n+                      ident: @\"__s\",\n+                      id: cx.next_id()},\n+                     {mode: ast::expl(ast::by_ref),\n+                      ty: v_ty,\n+                      ident: @\"__v\",\n+                      id: cx.next_id()}]/~,\n+                    tp_inputs);\n \n     let tps_map = map::str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n@@ -531,10 +534,10 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n                                     []/~))]/~;\n \n     let ser_tps: [ast::ty_param]/~ =\n-        [{ident: @\"__S\",\n-          id: cx.next_id(),\n-          bounds: ser_bnds}]/~ +\n-        vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n+        vec::append([{ident: @\"__S\",\n+                      id: cx.next_id(),\n+                      bounds: ser_bnds}]/~,\n+                    vec::map(tps) {|tp| cx.clone_ty_param(tp) });\n \n     let ser_output: @ast::ty = @{id: cx.next_id(),\n                                  node: ast::ty_nil,\n@@ -575,7 +578,8 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n \n-    cx.expr(path.span, ast::expr_call(callee, [d]/~ + ty_args, false))\n+    cx.expr(path.span, ast::expr_call(callee, vec::append([d]/~, ty_args),\n+                                      false))\n }\n \n fn deser_lambda(cx: ext_ctxt, tps: deser_tps_map, ty: @ast::ty,\n@@ -712,11 +716,11 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n     let deser_inputs: [ast::arg]/~ =\n-        [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [@\"__D\"]/~, []/~),\n-          ident: @\"__d\",\n-          id: cx.next_id()}]/~\n-        + tp_inputs;\n+        vec::append([{mode: ast::expl(ast::by_ref),\n+                      ty: cx.ty_path(span, [@\"__D\"]/~, []/~),\n+                      ident: @\"__d\",\n+                      id: cx.next_id()}]/~,\n+                    tp_inputs);\n \n     let tps_map = map::str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n@@ -740,7 +744,9 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n           id: cx.next_id(),\n           bounds: deser_bnds}]/~ + vec::map(tps) {|tp|\n         let cloned = cx.clone_ty_param(tp);\n-        {bounds: @(*cloned.bounds + [ast::bound_copy]/~) with cloned}\n+        {bounds: @(vec::append(*cloned.bounds,\n+                               [ast::bound_copy]/~))\n+         with cloned}\n     };\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));"}, {"sha": "13b5d9cbc18a5ddbfdc89920f7f2b5387f11c076", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -82,7 +82,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n         let val = field.ex;\n         let astfield =\n             {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n-        astfields += [astfield]/~;\n+        vec::push(astfields, astfield);\n     }\n     let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n     ret @{id: cx.next_id(), node: recexpr, span: sp};"}, {"sha": "c324455e6cc662a07d9e78dc6363b2c686fe161c", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -60,7 +60,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                   flag_sign_always { fstr = \"flag_sign_always\"; }\n                   flag_alternate { fstr = \"flag_alternate\"; }\n                 }\n-                flagexprs += [make_rt_path_expr(cx, sp, @fstr)]/~;\n+                vec::push(flagexprs, make_rt_path_expr(cx, sp, @fstr));\n             }\n             ret mk_uniq_vec_e(cx, sp, flagexprs);\n         }"}, {"sha": "dedd95551f2eba7dbe69d99a9258ac0a6588de71", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -104,7 +104,7 @@ fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]/~) ->\n    option<[U]/~> {\n     let mut res = []/~;\n     for v.each {|elem|\n-        alt f(elem) { none { ret none; } some(fv) { res += [fv]/~; } }\n+        alt f(elem) { none { ret none; } some(fv) { vec::push(res, fv); } }\n     }\n     ret some(res);\n }\n@@ -309,16 +309,16 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                 /* Whew, we now know how how many times to repeat */\n                 let mut idx: uint = 0u;\n                 while idx < rc {\n-                    *idx_path += [idx]/~;\n-                    res += [recur(repeat_me)]/~; // whew!\n+                    vec::push(*idx_path, idx);\n+                    vec::push(res, recur(repeat_me)); // whew!\n                     vec::pop(*idx_path);\n                     idx += 1u;\n                 }\n               }\n             }\n           }\n         }\n-        res += vec::map(post, recur);\n+        res = vec::append(res, vec::map(post, recur));\n         ret res;\n       }\n     }\n@@ -718,9 +718,9 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                       none { cx.span_fatal(mac.span,\n                                            \"macro must have arguments\")}\n                     };\n-                    clauses +=\n-                        [@{params: pattern_to_selectors(cx, arg),\n-                           body: elts[1u]}]/~;\n+                    vec::push(clauses,\n+                              @{params: pattern_to_selectors(cx, arg),\n+                                body: elts[1u]});\n \n                     // FIXME (#2251): check duplicates (or just simplify\n                     // the macro arg situation)"}, {"sha": "b63335b00c901513b5cc48f55839b2d0e8cfe51f", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -84,7 +84,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     ret @ast_util::respan(ast_util::mk_sp(lo, hi),\n                           {directives: cdirs,\n                            module: m,\n-                           attrs: crate_attrs + attrs,\n+                           attrs: vec::append(crate_attrs, attrs),\n                            config: /* FIXME (#2543) */ copy p.cfg});\n }\n "}, {"sha": "a349621091bab706e14712a6b6f92bbce9736304", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -21,8 +21,8 @@ impl parser_attr for parser {\n                 self.bump();\n                 let first_attr =\n                     self.parse_attribute_naked(ast::attr_outer, lo);\n-                ret some(left([first_attr]/~ +\n-                              self.parse_outer_attributes()));\n+                ret some(left(vec::append([first_attr]/~,\n+                                          self.parse_outer_attributes())));\n             } else if !(self.look_ahead(1u) == token::LT\n                         || self.look_ahead(1u) == token::LBRACKET\n                         || self.look_ahead(1u) == token::POUND\n@@ -38,7 +38,7 @@ impl parser_attr for parser {\n         let mut attrs: [ast::attribute]/~ = []/~;\n         while self.token == token::POUND\n             && self.look_ahead(1u) == token::LBRACKET {\n-            attrs += [self.parse_attribute(ast::attr_outer)]/~;\n+            vec::push(attrs, self.parse_attribute(ast::attr_outer));\n         }\n         ret attrs;\n     }\n@@ -76,13 +76,13 @@ impl parser_attr for parser {\n             let attr = self.parse_attribute(ast::attr_inner);\n             if self.token == token::SEMI {\n                 self.bump();\n-                inner_attrs += [attr]/~;\n+                vec::push(inner_attrs, attr);\n             } else {\n                 // It's not really an inner attribute\n                 let outer_attr =\n                     spanned(attr.span.lo, attr.span.hi,\n                             {style: ast::attr_outer, value: attr.node.value});\n-                next_outer_attrs += [outer_attr]/~;\n+                vec::push(next_outer_attrs, outer_attr);\n                 break;\n             }\n         }"}, {"sha": "efae13342c0f1569bddca6c331c8f0b19e292aa9", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -28,8 +28,8 @@ fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive]/~,\n     let mut view_items: [@ast::view_item]/~ = []/~;\n     let mut items: [@ast::item]/~ = []/~;\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n-    ret ({view_items: view_items + cview_items,\n-          items: items + citems},\n+    ret ({view_items: vec::append(view_items, cview_items),\n+          items: vec::append(items, citems)},\n          cattrs);\n }\n \n@@ -100,7 +100,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let (p0, r0) =\n             new_parser_etc_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = attrs + inner_attrs.inner;\n+        let mod_attrs = vec::append(attrs, inner_attrs.inner);\n         let first_item_outer_attrs = inner_attrs.next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n@@ -110,7 +110,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = r0.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n-        items += [i]/~;\n+        vec::push(items, i);\n       }\n       ast::cdir_dir_mod(id, cdirs, attrs) {\n         let path = cdir_path_opt(id, attrs);\n@@ -122,15 +122,15 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n             cx, cdirs, full_path, none);\n         let i =\n             @{ident: /* FIXME (#2543) */ copy id,\n-              attrs: attrs + a0,\n+              attrs: vec::append(attrs, a0),\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),\n               vis: ast::public,\n               span: cdir.span};\n         cx.sess.next_id += 1;\n-        items += [i]/~;\n+        vec::push(items, i);\n       }\n-      ast::cdir_view_item(vi) { view_items += [vi]/~; }\n+      ast::cdir_view_item(vi) { vec::push(view_items, vi); }\n       ast::cdir_syntax(pth) { }\n     }\n }"}, {"sha": "f8d1f0386657796880d288edda37055bf828732b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae06546bbf72ed9eb8bf4086eaccf67703bf84ef/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ae06546bbf72ed9eb8bf4086eaccf67703bf84ef", "patch": "@@ -1030,7 +1030,9 @@ class parser {\n                 let blk = self.parse_fn_block_expr();\n                 alt e.node {\n                   expr_call(f, args, false) {\n-                    e = pexpr(@{node: expr_call(f, args + [blk]/~, true)\n+                    e = pexpr(@{node: expr_call(f,\n+                                                vec::append(args, [blk]/~),\n+                                                true)\n                                 with *self.to_expr(e)});\n                   }\n                   _ {\n@@ -1088,10 +1090,13 @@ class parser {\n         ret alt self.token {\n           token::LPAREN | token::LBRACE | token::LBRACKET {\n             let ket = flip(self.token);\n-            tt_delim([parse_tt_flat(self, true)]/~ +\n-                     self.parse_seq_to_before_end(ket, seq_sep_none(),\n-                                                  {|p| p.parse_token_tree()})\n-                     + [parse_tt_flat(self, true)]/~)\n+            tt_delim(vec::append(\n+                [parse_tt_flat(self, true)]/~,\n+                vec::append(\n+                    self.parse_seq_to_before_end(\n+                        ket, seq_sep_none(),\n+                        {|p| p.parse_token_tree()}),\n+                    [parse_tt_flat(self, true)]/~)))\n           }\n           _ { parse_tt_flat(self, false) }\n         };\n@@ -1357,7 +1362,7 @@ class parser {\n             let b_arg = vec::last(args);\n             let last = self.mk_expr(b_arg.span.lo, b_arg.span.hi,\n                                     ctor(b_arg));\n-            @{node: expr_call(f, vec::init(args) + [last]/~, true)\n+            @{node: expr_call(f, vec::append(vec::init(args), [last]/~), true)\n               with *call}\n           }\n           _ {\n@@ -1655,7 +1660,7 @@ class parser {\n               }\n             }\n \n-            let item_attrs = first_item_attrs + item_attrs;\n+            let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n             alt self.parse_item(item_attrs, public) {\n               some(i) {\n@@ -1914,7 +1919,7 @@ class parser {\n         let tps = self.parse_ty_params();\n         let (decl, _) = self.parse_fn_decl(pur, {|p| p.parse_arg()});\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        let attrs = attrs + inner_attrs;\n+        let attrs = vec::append(attrs, inner_attrs);\n         @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n           id: self.get_id(), span: mk_sp(lo, body.span.hi),\n           self_id: self.get_id(), vis: pr}\n@@ -2026,7 +2031,7 @@ class parser {\n               dtor_decl(blk, s) {\n                 the_dtor = some((blk, s));\n               }\n-              members(mms) { ms += mms; }\n+              members(mms) { ms = vec::append(ms, mms); }\n             }\n         }\n         let actual_dtor = option::map(the_dtor) {|dtor|\n@@ -2127,7 +2132,10 @@ class parser {\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n-            if first { attrs = attrs_remaining + attrs; first = false; }\n+            if first {\n+                attrs = vec::append(attrs_remaining, attrs);\n+                first = false;\n+            }\n             #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n             let vis = self.parse_visibility(private);\n             alt self.parse_item(attrs, vis) {\n@@ -2206,7 +2214,8 @@ class parser {\n         let mut items: [@foreign_item]/~ = []/~;\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n-            let attrs = initial_attrs + self.parse_outer_attributes();\n+            let attrs = vec::append(initial_attrs,\n+                                    self.parse_outer_attributes());\n             initial_attrs = []/~;\n             vec::push(items, self.parse_foreign_item(attrs));\n         }\n@@ -2383,7 +2392,7 @@ class parser {\n         } else { ret none; };\n         some(self.mk_item(lo, self.last_span.hi, ident, item_, vis,\n                           alt extra_attrs {\n-                              some(as) { attrs + as }\n+                              some(as) { vec::append(attrs, as) }\n                               none { attrs }\n                           }))\n     }\n@@ -2498,7 +2507,8 @@ class parser {\n     fn parse_view(+first_item_attrs: [attribute]/~,\n                   only_imports: bool) -> {attrs_remaining: [attribute]/~,\n                                           view_items: [@view_item]/~} {\n-        let mut attrs = first_item_attrs + self.parse_outer_attributes();\n+        let mut attrs = vec::append(first_item_attrs,\n+                                    self.parse_outer_attributes());\n         let mut items = []/~;\n         while if only_imports { self.is_keyword(\"import\") }\n         else { self.is_view_item() } {\n@@ -2540,7 +2550,8 @@ class parser {\n         crate_directive {\n \n         // Collect the next attributes\n-        let outer_attrs = first_outer_attr + self.parse_outer_attributes();\n+        let outer_attrs = vec::append(first_outer_attr,\n+                                      self.parse_outer_attributes());\n         // In a crate file outer attributes are only going to apply to mods\n         let expect_mod = vec::len(outer_attrs) > 0u;\n \n@@ -2559,7 +2570,7 @@ class parser {\n               token::LBRACE {\n                 self.bump();\n                 let inner_attrs = self.parse_inner_attrs_and_next();\n-                let mod_attrs = outer_attrs + inner_attrs.inner;\n+                let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n                 let next_outer_attr = inner_attrs.next;\n                 let cdirs = self.parse_crate_directives(token::RBRACE,\n                                                         next_outer_attr);"}]}