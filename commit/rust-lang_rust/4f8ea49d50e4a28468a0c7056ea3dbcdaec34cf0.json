{"sha": "4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOGVhNDlkNTBlNGEyODQ2OGEwYzcwNTZlYTNkYmNkYWVjMzRjZjA=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-10T06:23:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-10T06:23:54Z"}, "message": "Rollup merge of #47835 - Mark-Simulacrum:remove-data-structs, r=nikomatsakis\n\nRemove unused data structures\n\nCleanup; as far as I can tell the compiler no longer uses these.", "tree": {"sha": "44e95ba0c0bf5b38371678fedf2eaba3ca1962ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44e95ba0c0bf5b38371678fedf2eaba3ca1962ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJafo/7CRBK7hj4Ov3rIwAAdHIIAKIQofQuK1SIOptx6zODWbHY\n2Qrx6Ttwz8CTHVPsyugQnMdN9Top/823ekMudeCftwc6tDSjwtw4+nzYK2pnjZU4\neek90hnAwHtMs/WIU1HrPK4ap1rFmEQEKzCAtiuQZK1+zfBKL++iz2hkYyFvnNwf\nTuyQnW4klrRhbMKQBdRfELlckYsoZIMPTp+EQPMOkN+PJjLGQwxa/UT49ZFwmG50\n5LThSbYDvQht4s1fZ3LA4/zHIaQ6fN6Ovc1F0Ne1kWrq/mpo5uQbNyRXZ5nuY+g9\nu6XIuht4DUh9DLOVaN+KunbUDZlMNPNJlN/EGO3M6xoephHxyNHXGSadTc7+qLg=\n=nBZl\n-----END PGP SIGNATURE-----\n", "payload": "tree 44e95ba0c0bf5b38371678fedf2eaba3ca1962ac\nparent 6bbee8de86b54b9e3ea45f60477e994934c84187\nparent caa42e11bb6b7aea210ced552a157fa7de100d68\nauthor kennytm <kennytm@gmail.com> 1518243834 +0800\ncommitter GitHub <noreply@github.com> 1518243834 +0800\n\nRollup merge of #47835 - Mark-Simulacrum:remove-data-structs, r=nikomatsakis\n\nRemove unused data structures\n\nCleanup; as far as I can tell the compiler no longer uses these.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0", "html_url": "https://github.com/rust-lang/rust/commit/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bbee8de86b54b9e3ea45f60477e994934c84187", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbee8de86b54b9e3ea45f60477e994934c84187", "html_url": "https://github.com/rust-lang/rust/commit/6bbee8de86b54b9e3ea45f60477e994934c84187"}, {"sha": "caa42e11bb6b7aea210ced552a157fa7de100d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/caa42e11bb6b7aea210ced552a157fa7de100d68", "html_url": "https://github.com/rust-lang/rust/commit/caa42e11bb6b7aea210ced552a157fa7de100d68"}], "stats": {"total": 412, "additions": 0, "deletions": 412}, "files": [{"sha": "6b8bf8df0d33f0832e24aeefc673c946c1276982", "filename": "src/librustc_data_structures/blake2b.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/6bbee8de86b54b9e3ea45f60477e994934c84187/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbee8de86b54b9e3ea45f60477e994934c84187/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=6bbee8de86b54b9e3ea45f60477e994934c84187", "patch": "@@ -1,363 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// An implementation of the Blake2b cryptographic hash function.\n-// The implementation closely follows: https://tools.ietf.org/html/rfc7693\n-//\n-// \"BLAKE2 is a cryptographic hash function faster than MD5, SHA-1, SHA-2, and\n-//  SHA-3, yet is at least as secure as the latest standard SHA-3.\"\n-// according to their own website :)\n-//\n-// Indeed this implementation is two to three times as fast as our SHA-256\n-// implementation. If you have the luxury of being able to use crates from\n-// crates.io, you can go there and find still faster implementations.\n-\n-use std::mem;\n-use std::slice;\n-\n-#[repr(C)]\n-struct Blake2bCtx {\n-    b: [u8; 128],\n-    h: [u64; 8],\n-    t: [u64; 2],\n-    c: usize,\n-    outlen: u16,\n-    finalized: bool,\n-\n-    #[cfg(debug_assertions)]\n-    fnv_hash: u64,\n-}\n-\n-#[cfg(debug_assertions)]\n-impl ::std::fmt::Debug for Blake2bCtx {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        write!(fmt, \"{:x}\", self.fnv_hash)\n-    }\n-}\n-\n-#[cfg(not(debug_assertions))]\n-impl ::std::fmt::Debug for Blake2bCtx {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        write!(fmt, \"Enable debug_assertions() for more info.\")\n-    }\n-}\n-\n-#[inline(always)]\n-fn b2b_g(v: &mut [u64; 16],\n-         a: usize,\n-         b: usize,\n-         c: usize,\n-         d: usize,\n-         x: u64,\n-         y: u64)\n-{\n-    v[a] = v[a].wrapping_add(v[b]).wrapping_add(x);\n-    v[d] = (v[d] ^ v[a]).rotate_right(32);\n-    v[c] = v[c].wrapping_add(v[d]);\n-    v[b] = (v[b] ^ v[c]).rotate_right(24);\n-    v[a] = v[a].wrapping_add(v[b]).wrapping_add(y);\n-    v[d] = (v[d] ^ v[a]).rotate_right(16);\n-    v[c] = v[c].wrapping_add(v[d]);\n-    v[b] = (v[b] ^ v[c]).rotate_right(63);\n-}\n-\n-// Initialization vector\n-const BLAKE2B_IV: [u64; 8] = [\n-   0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n-   0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n-   0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n-   0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n-];\n-\n-fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n-\n-    const SIGMA: [[usize; 16]; 12] = [\n-        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n-        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ],\n-        [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 ],\n-        [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 ],\n-        [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 ],\n-        [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 ],\n-        [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 ],\n-        [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 ],\n-        [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 ],\n-        [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 ],\n-        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n-        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ]\n-    ];\n-\n-    let mut v: [u64; 16] = [\n-        ctx.h[0],\n-        ctx.h[1],\n-        ctx.h[2],\n-        ctx.h[3],\n-        ctx.h[4],\n-        ctx.h[5],\n-        ctx.h[6],\n-        ctx.h[7],\n-\n-        BLAKE2B_IV[0],\n-        BLAKE2B_IV[1],\n-        BLAKE2B_IV[2],\n-        BLAKE2B_IV[3],\n-        BLAKE2B_IV[4],\n-        BLAKE2B_IV[5],\n-        BLAKE2B_IV[6],\n-        BLAKE2B_IV[7],\n-    ];\n-\n-    v[12] ^= ctx.t[0]; // low 64 bits of offset\n-    v[13] ^= ctx.t[1]; // high 64 bits\n-    if last {\n-        v[14] = !v[14];\n-    }\n-\n-    {\n-        // Re-interpret the input buffer in the state as an array\n-        // of little-endian u64s, converting them to machine\n-        // endianness. It's OK to modify the buffer in place\n-        // since this is the last time  this data will be accessed\n-        // before it's overwritten.\n-\n-        let m: &mut [u64; 16] = unsafe {\n-            let b: &mut [u8; 128] = &mut ctx.b;\n-            ::std::mem::transmute(b)\n-        };\n-\n-        if cfg!(target_endian = \"big\") {\n-            for word in &mut m[..] {\n-                *word = u64::from_le(*word);\n-            }\n-        }\n-\n-        for i in 0 .. 12 {\n-            b2b_g(&mut v, 0, 4,  8, 12, m[SIGMA[i][ 0]], m[SIGMA[i][ 1]]);\n-            b2b_g(&mut v, 1, 5,  9, 13, m[SIGMA[i][ 2]], m[SIGMA[i][ 3]]);\n-            b2b_g(&mut v, 2, 6, 10, 14, m[SIGMA[i][ 4]], m[SIGMA[i][ 5]]);\n-            b2b_g(&mut v, 3, 7, 11, 15, m[SIGMA[i][ 6]], m[SIGMA[i][ 7]]);\n-            b2b_g(&mut v, 0, 5, 10, 15, m[SIGMA[i][ 8]], m[SIGMA[i][ 9]]);\n-            b2b_g(&mut v, 1, 6, 11, 12, m[SIGMA[i][10]], m[SIGMA[i][11]]);\n-            b2b_g(&mut v, 2, 7,  8, 13, m[SIGMA[i][12]], m[SIGMA[i][13]]);\n-            b2b_g(&mut v, 3, 4,  9, 14, m[SIGMA[i][14]], m[SIGMA[i][15]]);\n-        }\n-    }\n-\n-    for i in 0 .. 8 {\n-        ctx.h[i] ^= v[i] ^ v[i + 8];\n-    }\n-}\n-\n-fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n-    assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n-\n-    let mut ctx = Blake2bCtx {\n-        b: [0; 128],\n-        h: BLAKE2B_IV,\n-        t: [0; 2],\n-        c: 0,\n-        outlen: outlen as u16,\n-        finalized: false,\n-\n-        #[cfg(debug_assertions)]\n-        fnv_hash: 0xcbf29ce484222325,\n-    };\n-\n-    ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n-\n-    if key.len() > 0 {\n-       blake2b_update(&mut ctx, key);\n-       ctx.c = ctx.b.len();\n-    }\n-\n-    ctx\n-}\n-\n-fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8]) {\n-    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n-\n-    let mut bytes_to_copy = data.len();\n-    let mut space_in_buffer = ctx.b.len() - ctx.c;\n-\n-    while bytes_to_copy > space_in_buffer {\n-        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], space_in_buffer);\n-\n-        ctx.t[0] = ctx.t[0].wrapping_add(ctx.b.len() as u64);\n-        if ctx.t[0] < (ctx.b.len() as u64) {\n-            ctx.t[1] += 1;\n-        }\n-        blake2b_compress(ctx, false);\n-        ctx.c = 0;\n-\n-        data = &data[space_in_buffer .. ];\n-        bytes_to_copy -= space_in_buffer;\n-        space_in_buffer = ctx.b.len();\n-    }\n-\n-    if bytes_to_copy > 0 {\n-        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], bytes_to_copy);\n-        ctx.c += bytes_to_copy;\n-    }\n-\n-    #[cfg(debug_assertions)]\n-    {\n-        // compute additional FNV hash for simpler to read debug output\n-        const MAGIC_PRIME: u64 = 0x00000100000001b3;\n-\n-        for &byte in data {\n-            ctx.fnv_hash = (ctx.fnv_hash ^ byte as u64).wrapping_mul(MAGIC_PRIME);\n-        }\n-    }\n-}\n-\n-fn blake2b_final(ctx: &mut Blake2bCtx)\n-{\n-    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n-\n-    ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n-    if ctx.t[0] < ctx.c as u64 {\n-        ctx.t[1] += 1;\n-    }\n-\n-    while ctx.c < 128 {\n-        ctx.b[ctx.c] = 0;\n-        ctx.c += 1;\n-    }\n-\n-    blake2b_compress(ctx, true);\n-\n-    // Modify our buffer to little-endian format as it will be read\n-    // as a byte array. It's OK to modify the buffer in place since\n-    // this is the last time this data will be accessed.\n-    if cfg!(target_endian = \"big\") {\n-        for word in &mut ctx.h {\n-            *word = word.to_le();\n-        }\n-    }\n-\n-    ctx.finalized = true;\n-}\n-\n-#[inline(always)]\n-fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n-    let from_size = from.len() * mem::size_of::<T1>();\n-    let to_size = to.len() * mem::size_of::<T2>();\n-    assert!(from_size >= byte_count);\n-    assert!(to_size >= byte_count);\n-    let from_byte_ptr = from.as_ptr() as * const u8;\n-    let to_byte_ptr = to.as_mut_ptr() as * mut u8;\n-    unsafe {\n-        ::std::ptr::copy_nonoverlapping(from_byte_ptr, to_byte_ptr, byte_count);\n-    }\n-}\n-\n-pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n-{\n-    let mut ctx = blake2b_new(out.len(), key);\n-    blake2b_update(&mut ctx, data);\n-    blake2b_final(&mut ctx);\n-    checked_mem_copy(&ctx.h, out, ctx.outlen as usize);\n-}\n-\n-pub struct Blake2bHasher(Blake2bCtx);\n-\n-impl ::std::hash::Hasher for Blake2bHasher {\n-    fn write(&mut self, bytes: &[u8]) {\n-        blake2b_update(&mut self.0, bytes);\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        assert!(self.0.outlen == 8,\n-                \"Hasher initialized with incompatible output length\");\n-        u64::from_le(self.0.h[0])\n-    }\n-}\n-\n-impl Blake2bHasher {\n-    pub fn new(outlen: usize, key: &[u8]) -> Blake2bHasher {\n-        Blake2bHasher(blake2b_new(outlen, key))\n-    }\n-\n-    pub fn finalize(&mut self) -> &[u8] {\n-        if !self.0.finalized {\n-            blake2b_final(&mut self.0);\n-        }\n-        debug_assert!(mem::size_of_val(&self.0.h) >= self.0.outlen as usize);\n-        let raw_ptr = (&self.0.h[..]).as_ptr() as * const u8;\n-        unsafe {\n-            slice::from_raw_parts(raw_ptr, self.0.outlen as usize)\n-        }\n-    }\n-}\n-\n-impl ::std::fmt::Debug for Blake2bHasher {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{:?}\", self.0)\n-    }\n-}\n-\n-#[cfg(test)]\n-fn selftest_seq(out: &mut [u8], seed: u32)\n-{\n-   let mut a: u32 = 0xDEAD4BADu32.wrapping_mul(seed);\n-   let mut b: u32 = 1;\n-\n-   for i in 0 .. out.len() {\n-       let t: u32 = a.wrapping_add(b);\n-       a = b;\n-       b = t;\n-       out[i] = ((t >> 24) & 0xFF) as u8;\n-   }\n-}\n-\n-#[test]\n-fn blake2b_selftest()\n-{\n-    use std::hash::Hasher;\n-\n-    // grand hash of hash results\n-    const BLAKE2B_RES: [u8; 32] = [\n-        0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n-        0x10, 0xF5, 0x06, 0xC6, 0x1E, 0x29, 0xDA, 0x56,\n-        0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E, 0x73,\n-        0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n-    ];\n-\n-    // parameter sets\n-    const B2B_MD_LEN: [usize; 4] = [20, 32, 48, 64];\n-    const B2B_IN_LEN: [usize; 6] = [0, 3, 128, 129, 255, 1024];\n-\n-    let mut data = [0u8; 1024];\n-    let mut md = [0u8; 64];\n-    let mut key = [0u8; 64];\n-\n-    let mut hasher = Blake2bHasher::new(32, &[]);\n-\n-    for i in 0 .. 4 {\n-       let outlen = B2B_MD_LEN[i];\n-       for j in 0 .. 6 {\n-            let inlen = B2B_IN_LEN[j];\n-\n-            selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n-            blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n-            hasher.write(&md[.. outlen]); // hash the hash\n-\n-            selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n-            blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n-            hasher.write(&md[.. outlen]); // hash the hash\n-       }\n-    }\n-\n-    // compute and compare the hash of hashes\n-    let md = hasher.finalize();\n-    for i in 0 .. 32 {\n-        assert_eq!(md[i], BLAKE2B_RES[i]);\n-    }\n-}"}, {"sha": "33d760d0a1482f3d365d830c39ca719a360bbaf6", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=4f8ea49d50e4a28468a0c7056ea3dbcdaec34cf0", "patch": "@@ -57,7 +57,6 @@ pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n pub mod bitvec;\n-pub mod blake2b;\n pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n@@ -70,7 +69,6 @@ pub mod transitive_relation;\n pub mod unify;\n pub mod fx;\n pub mod tuple_slice;\n-pub mod veccell;\n pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;"}, {"sha": "054eee8829a4a73e0b38599ba2b3b058359b0b63", "filename": "src/librustc_data_structures/veccell/mod.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6bbee8de86b54b9e3ea45f60477e994934c84187/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbee8de86b54b9e3ea45f60477e994934c84187/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs?ref=6bbee8de86b54b9e3ea45f60477e994934c84187", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cell::UnsafeCell;\n-use std::mem;\n-\n-pub struct VecCell<T> {\n-    data: UnsafeCell<Vec<T>>,\n-}\n-\n-impl<T> VecCell<T> {\n-    pub fn with_capacity(capacity: usize) -> VecCell<T> {\n-        VecCell { data: UnsafeCell::new(Vec::with_capacity(capacity)) }\n-    }\n-\n-    #[inline]\n-    pub fn push(&self, data: T) -> usize {\n-        // The logic here, and in `swap` below, is that the `push`\n-        // method on the vector will not recursively access this\n-        // `VecCell`. Therefore, we can temporarily obtain mutable\n-        // access, secure in the knowledge that even if aliases exist\n-        // -- indeed, even if aliases are reachable from within the\n-        // vector -- they will not be used for the duration of this\n-        // particular fn call. (Note that we also are relying on the\n-        // fact that `VecCell` is not `Sync`.)\n-        unsafe {\n-            let v = self.data.get();\n-            (*v).push(data);\n-            (*v).len()\n-        }\n-    }\n-\n-    pub fn swap(&self, mut data: Vec<T>) -> Vec<T> {\n-        unsafe {\n-            let v = self.data.get();\n-            mem::swap(&mut *v, &mut data);\n-        }\n-        data\n-    }\n-}"}]}