{"sha": "702b45e409495a41afcccbe87a251a692b0cefab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMmI0NWU0MDk0OTVhNDFhZmNjY2JlODdhMjUxYTY5MmIwY2VmYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T07:56:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T07:56:52Z"}, "message": "Auto merge of #64946 - Centril:rollup-66mj5o0, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #63674 (syntax: Support modern attribute syntax in the `meta` matcher)\n - #63931 (Stabilize macros in some more positions)\n - #64887 (syntax: recover trailing `|` in or-patterns)\n - #64895 (async/await: improve not-send errors)\n - #64896 (Remove legacy grammar)\n - #64907 (A small amount of tidying-up factored out from PR #64648)\n - #64928 (Add tests for some issues)\n - #64930 (Silence unreachable code lint from await desugaring)\n - #64935 (Improve code clarity)\n - #64937 (Deduplicate closure type errors)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6dbfa88da0422f72926f0352a968d79bf84e8464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbfa88da0422f72926f0352a968d79bf84e8464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/702b45e409495a41afcccbe87a251a692b0cefab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab", "html_url": "https://github.com/rust-lang/rust/commit/702b45e409495a41afcccbe87a251a692b0cefab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42ec6831b019114a4b6f6b58bfb5bc2927d70388", "url": "https://api.github.com/repos/rust-lang/rust/commits/42ec6831b019114a4b6f6b58bfb5bc2927d70388", "html_url": "https://github.com/rust-lang/rust/commit/42ec6831b019114a4b6f6b58bfb5bc2927d70388"}, {"sha": "46bf6ad416cf922c410fed11e9f73c03c0015bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/46bf6ad416cf922c410fed11e9f73c03c0015bcd", "html_url": "https://github.com/rust-lang/rust/commit/46bf6ad416cf922c410fed11e9f73c03c0015bcd"}], "stats": {"total": 5866, "additions": 1291, "deletions": 4575}, "files": [{"sha": "4501d74073e900846f0bcf13196bfca39f6e9484", "filename": "src/doc/grammar.md", "status": "modified", "additions": 4, "deletions": 809, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,812 +1,7 @@\n % Grammar\n \n-# Introduction\n+The Rust grammar may now be found in the [reference]. Additionally, the [grammar\n+working group] is working on producing a testable grammar.\n \n-This document is the primary reference for the Rust programming language grammar. It\n-provides only one kind of material:\n-\n-  - Chapters that formally define the language grammar.\n-\n-This document does not serve as an introduction to the language. Background\n-familiarity with the language is assumed. A separate [guide] is available to\n-help acquire such background.\n-\n-This document also does not serve as a reference to the [standard] library\n-included in the language distribution. Those libraries are documented\n-separately by extracting documentation attributes from their source code. Many\n-of the features that one might expect to be language features are library\n-features in Rust, so what you're looking for may be there, not here.\n-\n-[guide]: guide.html\n-[standard]: std/index.html\n-\n-# Notation\n-\n-Rust's grammar is defined over Unicode codepoints, each conventionally denoted\n-`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n-confined to the ASCII range of Unicode, and is described in this document by a\n-dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n-supported by common automated LL(k) parsing tools such as `llgen`, rather than\n-the dialect given in ISO 14977. The dialect can be defined self-referentially\n-as follows:\n-\n-```antlr\n-grammar : rule + ;\n-rule    : nonterminal ':' productionrule ';' ;\n-productionrule : production [ '|' production ] * ;\n-production : term * ;\n-term : element repeats ;\n-element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n-repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-```\n-\n-Where:\n-\n-- Whitespace in the grammar is ignored.\n-- Square brackets are used to group rules.\n-- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n-  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode codepoint `U+00QQ`.\n-- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n-- The `repeat` forms apply to the adjacent `element`, and are as follows:\n-  - `?` means zero or one repetition\n-  - `*` means zero or more repetitions\n-  - `+` means one or more repetitions\n-  - NUMBER trailing a repeat symbol gives a maximum repetition count\n-  - NUMBER on its own gives an exact repetition count\n-\n-This EBNF dialect should hopefully be familiar to many readers.\n-\n-## Unicode productions\n-\n-A few productions in Rust's grammar permit Unicode codepoints outside the ASCII\n-range. We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range codepoints. The\n-section [Special Unicode Productions](#special-unicode-productions) lists these\n-productions.\n-\n-## String table productions\n-\n-Some rules in the grammar &mdash; notably [unary\n-operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), and [keywords](#keywords) &mdash; are\n-given in a simplified form: as a listing of a table of unquoted, printable\n-whitespace-separated strings. These cases form a subset of the rules regarding\n-the [token](#tokens) rule, and are assumed to be the result of a\n-lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n-disjunction of all such string table entries.\n-\n-When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n-it is an implicit reference to a single member of such a string table\n-production. See [tokens](#tokens) for more information.\n-\n-# Lexical structure\n-\n-## Input format\n-\n-Rust input is interpreted as a sequence of Unicode codepoints encoded in UTF-8.\n-Most Rust grammar rules are defined in terms of printable ASCII-range\n-codepoints, but a small number are defined in terms of Unicode properties or\n-explicit codepoint lists. [^inputformat]\n-\n-[^inputformat]: Substitute definitions for the special Unicode productions are\n-  provided to the grammar verifier, restricted to ASCII range, when verifying the\n-  grammar in this document.\n-\n-## Special Unicode Productions\n-\n-The following productions in the Rust grammar are defined in terms of Unicode\n-properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n-`non_double_quote`.\n-\n-### Identifiers\n-\n-The `ident` production is any nonempty Unicode string of\n-the following form:\n-\n-- The first character is in one of the following ranges `U+0041` to `U+005A`\n-(\"A\" to \"Z\"), `U+0061` to `U+007A` (\"a\" to \"z\"), or `U+005F` (\"\\_\").\n-- The remaining characters are in the range `U+0030` to `U+0039` (\"0\" to \"9\"),\n-or any of the prior valid initial characters.\n-\n-as long as the identifier does _not_ occur in the set of [keywords](#keywords).\n-\n-### Delimiter-restricted productions\n-\n-Some productions are defined by exclusion of particular Unicode characters:\n-\n-- `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is any single Unicode character aside from `U+000A` (`'\\n'`)\n-- `non_single_quote` is any single Unicode character aside from `U+0027`  (`'`)\n-- `non_double_quote` is any single Unicode character aside from `U+0022` (`\"`)\n-\n-## Comments\n-\n-```antlr\n-comment : block_comment | line_comment ;\n-block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : [block_comment | character] * ;\n-line_comment : \"//\" non_eol * ;\n-```\n-\n-**FIXME:** add doc grammar?\n-\n-## Whitespace\n-\n-```antlr\n-whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n-whitespace : [ whitespace_char | comment ] + ;\n-```\n-\n-## Tokens\n-\n-```antlr\n-simple_token : keyword | unop | binop ;\n-token : simple_token | ident | literal | symbol | whitespace token ;\n-```\n-\n-### Keywords\n-\n-<p id=\"keyword-table-marker\"></p>\n-\n-|          |          |          |          |          |\n-|----------|----------|----------|----------|----------|\n-| _        | abstract | alignof  | as       | become   |\n-| box      | break    | const    | continue | crate    |\n-| do       | else     | enum     | extern   | false    |\n-| final    | fn       | for      | if       | impl     |\n-| in       | let      | loop     | macro    | match    |\n-| mod      | move     | mut      | offsetof | override |\n-| priv     | proc     | pub      | pure     | ref      |\n-| return   | Self     | self     | sizeof   | static   |\n-| struct   | super    | trait    | true     | type     |\n-| typeof   | unsafe   | unsized  | use      | virtual  |\n-| where    | while    | yield    |          |          |\n-\n-\n-Each of these keywords has special meaning in its grammar, and all of them are\n-excluded from the `ident` rule.\n-\n-Not all of these keywords are used by the language. Some of them were used\n-before Rust 1.0, and were left reserved once their implementations were\n-removed. Some of them were reserved before 1.0 to make space for possible\n-future features.\n-\n-### Literals\n-\n-```antlr\n-lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit | bool_lit ] lit_suffix ?;\n-```\n-\n-The optional `lit_suffix` production is only used for certain numeric literals,\n-but is reserved for future extension. That is, the above gives the lexical\n-grammar, but a Rust parser will reject everything but the 12 special cases\n-mentioned in [Number literals](reference/tokens.html#number-literals) in the\n-reference.\n-\n-#### Character and string literals\n-\n-```antlr\n-char_lit : '\\x27' char_body '\\x27' ;\n-string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n-\n-char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n-\n-string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n-raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n-\n-common_escape : '\\x5c'\n-              | 'n' | 'r' | 't' | '0'\n-              | 'x' hex_digit 2\n-unicode_escape : 'u' '{' hex_digit+ 6 '}';\n-\n-hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n-          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-          | dec_digit ;\n-oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n-dec_digit : '0' | nonzero_dec ;\n-nonzero_dec: '1' | '2' | '3' | '4'\n-           | '5' | '6' | '7' | '8' | '9' ;\n-```\n-\n-#### Byte and byte string literals\n-\n-```antlr\n-byte_lit : \"b\\x27\" byte_body '\\x27' ;\n-byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n-\n-byte_body : ascii_non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n-\n-byte_string_body : ascii_non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n-raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n-\n-```\n-\n-#### Number literals\n-\n-```antlr\n-num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] +\n-              | 'o'   [ oct_digit | '_' ] +\n-              | 'x'   [ hex_digit | '_' ] +  ] ;\n-\n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n-\n-exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n-dec_lit : [ dec_digit | '_' ] + ;\n-```\n-\n-#### Boolean literals\n-\n-```antlr\n-bool_lit : [ \"true\" | \"false\" ] ;\n-```\n-\n-The two values of the boolean type are written `true` and `false`.\n-\n-### Symbols\n-\n-```antlr\n-symbol : \"::\" | \"->\"\n-       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n-       | ',' | ';' ;\n-```\n-\n-Symbols are a general class of printable [tokens](#tokens) that play structural\n-roles in a variety of grammar productions. They are cataloged here for\n-completeness as the set of remaining miscellaneous printable tokens that do not\n-otherwise appear as [unary operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), or [keywords](#keywords).\n-\n-## Paths\n-\n-```antlr\n-expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n-expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | expr_path ;\n-\n-type_path : ident [ type_path_tail ] + ;\n-type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | \"::\" type_path ;\n-```\n-\n-# Syntax extensions\n-\n-## Macros\n-\n-```antlr\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ';'\n-                 | \"macro_rules\" '!' ident '{' macro_rule * '}' ;\n-macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n-matcher : '(' matcher * ')' | '[' matcher * ']'\n-        | '{' matcher * '}' | '$' ident ':' ident\n-        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n-        | non_special_token ;\n-transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n-            | '{' transcriber * '}' | '$' ident\n-            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n-            | non_special_token ;\n-```\n-\n-# Crates and source files\n-\n-**FIXME:** grammar? What production covers #![crate_id = \"foo\"] ?\n-\n-# Items and attributes\n-\n-**FIXME:** grammar?\n-\n-## Items\n-\n-```antlr\n-item : vis ? mod_item | fn_item | type_item | struct_item | enum_item\n-     | const_item | static_item | trait_item | impl_item | extern_block_item ;\n-```\n-\n-### Type Parameters\n-\n-**FIXME:** grammar?\n-\n-### Modules\n-\n-```antlr\n-mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : [ view_item | item ] * ;\n-```\n-\n-#### View items\n-\n-```antlr\n-view_item : extern_crate_decl | use_decl ';' ;\n-```\n-\n-##### Extern crate declarations\n-\n-```antlr\n-extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( ident \"as\" ident )\n-```\n-\n-##### Use declarations\n-\n-```antlr\n-use_decl : vis ? \"use\" [ path \"as\" ident\n-                        | path_glob ] ;\n-\n-path_glob : ident [ \"::\" [ path_glob\n-                          | '*' ] ] ?\n-          | '{' path_item [ ',' path_item ] * '}' ;\n-\n-path_item : ident | \"self\" ;\n-```\n-\n-### Functions\n-\n-**FIXME:** grammar?\n-\n-#### Generic functions\n-\n-**FIXME:** grammar?\n-\n-#### Unsafety\n-\n-**FIXME:** grammar?\n-\n-##### Unsafe functions\n-\n-**FIXME:** grammar?\n-\n-##### Unsafe blocks\n-\n-**FIXME:** grammar?\n-\n-#### Diverging functions\n-\n-**FIXME:** grammar?\n-\n-### Type definitions\n-\n-**FIXME:** grammar?\n-\n-### Structures\n-\n-**FIXME:** grammar?\n-\n-### Enumerations\n-\n-**FIXME:** grammar?\n-\n-### Constant items\n-\n-```antlr\n-const_item : \"const\" ident ':' type '=' expr ';' ;\n-```\n-\n-### Static items\n-\n-```antlr\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n-```\n-\n-#### Mutable statics\n-\n-**FIXME:** grammar?\n-\n-### Traits\n-\n-**FIXME:** grammar?\n-\n-### Implementations\n-\n-**FIXME:** grammar?\n-\n-### External blocks\n-\n-```antlr\n-extern_block_item : \"extern\" '{' extern_block '}' ;\n-extern_block : [ foreign_fn ] * ;\n-```\n-\n-## Visibility and Privacy\n-\n-```antlr\n-vis : \"pub\" ;\n-```\n-### Re-exporting and Visibility\n-\n-See [Use declarations](#use-declarations).\n-\n-## Attributes\n-\n-```antlr\n-attribute : '#' '!' ? '[' meta_item ']' ;\n-meta_item : ident [ '=' literal\n-                  | '(' meta_seq ')' ] ? ;\n-meta_seq : meta_item [ ',' meta_seq ] ? ;\n-```\n-\n-# Statements and expressions\n-\n-## Statements\n-\n-```antlr\n-stmt : decl_stmt | expr_stmt | ';' ;\n-```\n-\n-### Declaration statements\n-\n-```antlr\n-decl_stmt : item | let_decl ;\n-```\n-\n-#### Item declarations\n-\n-See [Items](#items).\n-\n-#### Variable declarations\n-\n-```antlr\n-let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n-init : [ '=' ] expr ;\n-```\n-\n-### Expression statements\n-\n-```antlr\n-expr_stmt : expr ';' ;\n-```\n-\n-## Expressions\n-\n-```antlr\n-expr : literal | path | tuple_expr | unit_expr | struct_expr\n-     | block_expr | method_call_expr | field_expr | array_expr\n-     | idx_expr | range_expr | unop_expr | binop_expr\n-     | paren_expr | call_expr | lambda_expr | while_expr\n-     | loop_expr | break_expr | continue_expr | for_expr\n-     | if_expr | match_expr | if_let_expr | while_let_expr\n-     | return_expr ;\n-```\n-\n-#### Lvalues, rvalues and temporaries\n-\n-**FIXME:** grammar?\n-\n-#### Moved and copied types\n-\n-**FIXME:** Do we want to capture this in the grammar as different productions?\n-\n-### Literal expressions\n-\n-See [Literals](#literals).\n-\n-### Path expressions\n-\n-See [Paths](#paths).\n-\n-### Tuple expressions\n-\n-```antlr\n-tuple_expr : '(' [ expr [ ',' expr ] * | expr ',' ] ? ')' ;\n-```\n-\n-### Unit expressions\n-\n-```antlr\n-unit_expr : \"()\" ;\n-```\n-\n-### Structure expressions\n-\n-```antlr\n-struct_expr_field_init : ident | ident ':' expr ;\n-struct_expr : expr_path '{' struct_expr_field_init\n-                      [ ',' struct_expr_field_init ] *\n-                      [ \"..\" expr ] '}' |\n-              expr_path '(' expr\n-                      [ ',' expr ] * ')' |\n-              expr_path ;\n-```\n-\n-### Block expressions\n-\n-```antlr\n-block_expr : '{' [ stmt | item ] *\n-                 [ expr ] '}' ;\n-```\n-\n-### Method-call expressions\n-\n-```antlr\n-method_call_expr : expr '.' ident paren_expr_list ;\n-```\n-\n-### Field expressions\n-\n-```antlr\n-field_expr : expr '.' ident ;\n-```\n-\n-### Array expressions\n-\n-```antlr\n-array_expr : '[' \"mut\" ? array_elems? ']' ;\n-\n-array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n-```\n-\n-### Index expressions\n-\n-```antlr\n-idx_expr : expr '[' expr ']' ;\n-```\n-\n-### Range expressions\n-\n-```antlr\n-range_expr : expr \"..\" expr |\n-             expr \"..\" |\n-             \"..\" expr |\n-             \"..\" ;\n-```\n-\n-### Unary operator expressions\n-\n-```antlr\n-unop_expr : unop expr ;\n-unop : '-' | '*' | '!' ;\n-```\n-\n-### Binary operator expressions\n-\n-```antlr\n-binop_expr : expr binop expr | type_cast_expr\n-           | assignment_expr | compound_assignment_expr ;\n-binop : arith_op | bitwise_op | lazy_bool_op | comp_op\n-```\n-\n-#### Arithmetic operators\n-\n-```antlr\n-arith_op : '+' | '-' | '*' | '/' | '%' ;\n-```\n-\n-#### Bitwise operators\n-\n-```antlr\n-bitwise_op : '&' | '|' | '^' | \"<<\" | \">>\" ;\n-```\n-\n-#### Lazy boolean operators\n-\n-```antlr\n-lazy_bool_op : \"&&\" | \"||\" ;\n-```\n-\n-#### Comparison operators\n-\n-```antlr\n-comp_op : \"==\" | \"!=\" | '<' | '>' | \"<=\" | \">=\" ;\n-```\n-\n-#### Type cast expressions\n-\n-```antlr\n-type_cast_expr : value \"as\" type ;\n-```\n-\n-#### Assignment expressions\n-\n-```antlr\n-assignment_expr : expr '=' expr ;\n-```\n-\n-#### Compound assignment expressions\n-\n-```antlr\n-compound_assignment_expr : expr [ arith_op | bitwise_op ] '=' expr ;\n-```\n-\n-### Grouped expressions\n-\n-```antlr\n-paren_expr : '(' expr ')' ;\n-```\n-\n-### Call expressions\n-\n-```antlr\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-```\n-\n-### Lambda expressions\n-\n-```antlr\n-ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '|' expr ;\n-```\n-\n-### While loops\n-\n-```antlr\n-while_expr : [ lifetime ':' ] ? \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n-### Infinite loops\n-\n-```antlr\n-loop_expr : [ lifetime ':' ] ? \"loop\" '{' block '}';\n-```\n-\n-### Break expressions\n-\n-```antlr\n-break_expr : \"break\" [ lifetime ] ?;\n-```\n-\n-### Continue expressions\n-\n-```antlr\n-continue_expr : \"continue\" [ lifetime ] ?;\n-```\n-\n-### For expressions\n-\n-```antlr\n-for_expr : [ lifetime ':' ] ? \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n-### If expressions\n-\n-```antlr\n-if_expr : \"if\" no_struct_literal_expr '{' block '}'\n-          else_tail ? ;\n-\n-else_tail : \"else\" [ if_expr | if_let_expr\n-                   | '{' block '}' ] ;\n-```\n-\n-### Match expressions\n-\n-```antlr\n-match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n-\n-match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n-\n-match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-```\n-\n-### If let expressions\n-\n-```antlr\n-if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n-               else_tail ? ;\n-```\n-\n-### While let loops\n-\n-```antlr\n-while_let_expr : [ lifetime ':' ] ? \"while\" \"let\" pat '=' expr '{' block '}' ;\n-```\n-\n-### Return expressions\n-\n-```antlr\n-return_expr : \"return\" expr ? ;\n-```\n-\n-# Type system\n-\n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n-\n-## Types\n-\n-### Primitive types\n-\n-**FIXME:** grammar?\n-\n-#### Machine types\n-\n-**FIXME:** grammar?\n-\n-#### Machine-dependent integer types\n-\n-**FIXME:** grammar?\n-\n-### Textual types\n-\n-**FIXME:** grammar?\n-\n-### Tuple types\n-\n-**FIXME:** grammar?\n-\n-### Array, and Slice types\n-\n-**FIXME:** grammar?\n-\n-### Structure types\n-\n-**FIXME:** grammar?\n-\n-### Enumerated types\n-\n-**FIXME:** grammar?\n-\n-### Pointer types\n-\n-**FIXME:** grammar?\n-\n-### Function types\n-\n-**FIXME:** grammar?\n-\n-### Closure types\n-\n-```antlr\n-closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n-                [ ':' bound-list ] [ '->' type ]\n-lifetime-list := lifetime | lifetime ',' lifetime-list\n-arg-list := ident ':' type | ident ':' type ',' arg-list\n-```\n-\n-### Never type\n-An empty type\n-\n-```antlr\n-never_type : \"!\" ;\n-```\n-\n-### Object types\n-\n-**FIXME:** grammar?\n-\n-### Type parameters\n-\n-**FIXME:** grammar?\n-\n-### Type parameter bounds\n-\n-```antlr\n-bound-list := bound | bound '+' bound-list '+' ?\n-bound := ty_bound | lt_bound\n-lt_bound := lifetime\n-ty_bound := ty_bound_noparen | (ty_bound_noparen)\n-ty_bound_noparen := [?] [ for<lt_param_defs> ] simple_path\n-```\n-\n-### Self types\n-\n-**FIXME:** grammar?\n-\n-## Type kinds\n-\n-**FIXME:** this is probably not relevant to the grammar...\n-\n-# Memory and concurrency models\n-\n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n-\n-## Memory model\n-\n-### Memory allocation and lifetime\n-\n-### Memory ownership\n-\n-### Variables\n-\n-### Boxes\n-\n-## Threads\n-\n-### Communication between threads\n-\n-### Thread lifecycle\n+[reference]: https://doc.rust-lang.org/reference/\n+[grammar working group]: https://github.com/rust-lang/wg-grammar"}, {"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "src/grammar/.gitignore", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,3 +0,0 @@\n-*.class\n-*.java\n-*.tokens"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "src/grammar/lexer.l", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,350 +0,0 @@\n-%{\n-#include <stdio.h>\n-#include <ctype.h>\n-\n-static int num_hashes;\n-static int end_hashes;\n-static int saw_non_hash;\n-\n-%}\n-\n-%option stack\n-%option yylineno\n-\n-%x str\n-%x rawstr\n-%x rawstr_esc_begin\n-%x rawstr_esc_body\n-%x rawstr_esc_end\n-%x byte\n-%x bytestr\n-%x rawbytestr\n-%x rawbytestr_nohash\n-%x pound\n-%x shebang_or_attr\n-%x ltorchar\n-%x linecomment\n-%x doc_line\n-%x blockcomment\n-%x doc_block\n-%x suffix\n-\n-ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n-\n-%%\n-\n-<suffix>{ident}            { BEGIN(INITIAL); }\n-<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n-\n-[ \\n\\t\\r]             { }\n-\n-\\xef\\xbb\\xbf {\n-  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n-  if (yyget_lineno() != 1) {\n-    return -1;\n-  }\n-}\n-\n-\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n-<doc_line>\\n          { BEGIN(INITIAL);\n-                        yyleng--;\n-                        yytext[yyleng] = 0;\n-                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-                      }\n-<doc_line>[^\\n]*      { yymore(); }\n-\n-\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n-<linecomment>\\n       { BEGIN(INITIAL); }\n-<linecomment>[^\\n]*   { }\n-\n-\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n-<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n-<doc_block>\\*\\/       {\n-    yy_pop_state();\n-    if (yy_top_state() == doc_block) {\n-        yymore();\n-    } else {\n-        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-    }\n-}\n-<doc_block>(.|\\n)     { yymore(); }\n-\n-\\/\\*                  { yy_push_state(blockcomment); }\n-<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n-<blockcomment>\\*\\/    { yy_pop_state(); }\n-<blockcomment>(.|\\n)   { }\n-\n-_        { return UNDERSCORE; }\n-abstract { return ABSTRACT; }\n-alignof  { return ALIGNOF; }\n-as       { return AS; }\n-become   { return BECOME; }\n-box      { return BOX; }\n-break    { return BREAK; }\n-catch    { return CATCH; }\n-const    { return CONST; }\n-continue { return CONTINUE; }\n-crate    { return CRATE; }\n-default  { return DEFAULT; }\n-do       { return DO; }\n-else     { return ELSE; }\n-enum     { return ENUM; }\n-extern   { return EXTERN; }\n-false    { return FALSE; }\n-final    { return FINAL; }\n-fn       { return FN; }\n-for      { return FOR; }\n-if       { return IF; }\n-impl     { return IMPL; }\n-in       { return IN; }\n-let      { return LET; }\n-loop     { return LOOP; }\n-macro    { return MACRO; }\n-match    { return MATCH; }\n-mod      { return MOD; }\n-move     { return MOVE; }\n-mut      { return MUT; }\n-offsetof { return OFFSETOF; }\n-override { return OVERRIDE; }\n-priv     { return PRIV; }\n-proc     { return PROC; }\n-pure     { return PURE; }\n-pub      { return PUB; }\n-ref      { return REF; }\n-return   { return RETURN; }\n-self     { return SELF; }\n-sizeof   { return SIZEOF; }\n-static   { return STATIC; }\n-struct   { return STRUCT; }\n-super    { return SUPER; }\n-trait    { return TRAIT; }\n-true     { return TRUE; }\n-type     { return TYPE; }\n-typeof   { return TYPEOF; }\n-union    { return UNION; }\n-unsafe   { return UNSAFE; }\n-unsized  { return UNSIZED; }\n-use      { return USE; }\n-virtual  { return VIRTUAL; }\n-where    { return WHERE; }\n-while    { return WHILE; }\n-yield    { return YIELD; }\n-\n-{ident}  { return IDENT; }\n-\n-0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-7_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n-0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n-\n-[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n-[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n-\n-;      { return ';'; }\n-,      { return ','; }\n-\\.\\.\\. { return DOTDOTDOT; }\n-\\.\\.   { return DOTDOT; }\n-\\.     { return '.'; }\n-\\(     { return '('; }\n-\\)     { return ')'; }\n-\\{     { return '{'; }\n-\\}     { return '}'; }\n-\\[     { return '['; }\n-\\]     { return ']'; }\n-@      { return '@'; }\n-#      { BEGIN(pound); yymore(); }\n-<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n-<shebang_or_attr>\\[ {\n-  BEGIN(INITIAL);\n-  yyless(2);\n-  return SHEBANG;\n-}\n-<shebang_or_attr>[^\\[\\n]*\\n {\n-  // Since the \\n was eaten as part of the token, yylineno will have\n-  // been incremented to the value 2 if the shebang was on the first\n-  // line. This yyless undoes that, setting yylineno back to 1.\n-  yyless(yyleng - 1);\n-  if (yyget_lineno() == 1) {\n-    BEGIN(INITIAL);\n-    return SHEBANG_LINE;\n-  } else {\n-    BEGIN(INITIAL);\n-    yyless(2);\n-    return SHEBANG;\n-  }\n-}\n-<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n-\n-\\~     { return '~'; }\n-::     { return MOD_SEP; }\n-:      { return ':'; }\n-\\$     { return '$'; }\n-\\?     { return '?'; }\n-\n-==    { return EQEQ; }\n-=>    { return FAT_ARROW; }\n-=     { return '='; }\n-\\!=   { return NE; }\n-\\!    { return '!'; }\n-\\<=   { return LE; }\n-\\<\\<  { return SHL; }\n-\\<\\<= { return SHLEQ; }\n-\\<    { return '<'; }\n-\\>=   { return GE; }\n-\\>\\>  { return SHR; }\n-\\>\\>= { return SHREQ; }\n-\\>    { return '>'; }\n-\n-\\x27                                      { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n-\n-b\\x22              { BEGIN(bytestr); yymore(); }\n-<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n-\n-<bytestr><<EOF>>                     { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n-<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n-<bytestr>(.|\\n)                      { yymore(); }\n-\n-br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n-<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n-<rawbytestr_nohash>(.|\\n)   { yymore(); }\n-<rawbytestr_nohash><<EOF>>  { return -1; }\n-\n-br/# {\n-    BEGIN(rawbytestr);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-<rawbytestr># {\n-    if (!saw_non_hash) {\n-        num_hashes++;\n-    } else if (end_hashes != 0) {\n-        end_hashes++;\n-        if (end_hashes == num_hashes) {\n-            BEGIN(INITIAL);\n-            return LIT_BYTE_STR_RAW;\n-        }\n-    }\n-    yymore();\n-}\n-<rawbytestr>\\x22# {\n-    end_hashes = 1;\n-    if (end_hashes == num_hashes) {\n-        BEGIN(INITIAL);\n-        return LIT_BYTE_STR_RAW;\n-    }\n-    yymore();\n-}\n-<rawbytestr>(.|\\n) {\n-    if (!saw_non_hash) {\n-        saw_non_hash = 1;\n-    }\n-    if (end_hashes != 0) {\n-        end_hashes = 0;\n-    }\n-    yymore();\n-}\n-<rawbytestr><<EOF>> { return -1; }\n-\n-b\\x27                           { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n-\n-r\\x22           { BEGIN(rawstr); yymore(); }\n-<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n-<rawstr>(.|\\n)  { yymore(); }\n-<rawstr><<EOF>> { return -1; }\n-\n-r/#             {\n-    BEGIN(rawstr_esc_begin);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-\n-<rawstr_esc_begin># {\n-    num_hashes++;\n-    yymore();\n-}\n-<rawstr_esc_begin>\\x22 {\n-    BEGIN(rawstr_esc_body);\n-    yymore();\n-}\n-<rawstr_esc_begin>(.|\\n) { return -1; }\n-\n-<rawstr_esc_body>\\x22/# {\n-  BEGIN(rawstr_esc_end);\n-  yymore();\n- }\n-<rawstr_esc_body>(.|\\n) {\n-  yymore();\n- }\n-\n-<rawstr_esc_end># {\n-  end_hashes++;\n-  if (end_hashes == num_hashes) {\n-    BEGIN(INITIAL);\n-    return LIT_STR_RAW;\n-  }\n-  yymore();\n- }\n-<rawstr_esc_end>[^#] {\n-  end_hashes = 0;\n-  BEGIN(rawstr_esc_body);\n-  yymore();\n- }\n-\n-<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n-\n-\\x22                     { BEGIN(str); yymore(); }\n-<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n-\n-<str><<EOF>>                     { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n-<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n-<str>(.|\\n)                      { yymore(); }\n-\n-\\<-  { return LARROW; }\n--\\>  { return RARROW; }\n--    { return '-'; }\n--=   { return MINUSEQ; }\n-&&   { return ANDAND; }\n-&    { return '&'; }\n-&=   { return ANDEQ; }\n-\\|\\| { return OROR; }\n-\\|   { return '|'; }\n-\\|=  { return OREQ; }\n-\\+   { return '+'; }\n-\\+=  { return PLUSEQ; }\n-\\*   { return '*'; }\n-\\*=  { return STAREQ; }\n-\\/   { return '/'; }\n-\\/=  { return SLASHEQ; }\n-\\^   { return '^'; }\n-\\^=  { return CARETEQ; }\n-%    { return '%'; }\n-%=   { return PERCENTEQ; }\n-\n-<<EOF>> { return 0; }\n-\n-%%"}, {"sha": "6348190cc140bc8ae496ec99a9000ef4d934c334", "filename": "src/grammar/parser-lalr-main.c", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,193 +0,0 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern int yylex();\n-extern int rsparse();\n-\n-#define PUSHBACK_LEN 4\n-\n-static char pushback[PUSHBACK_LEN];\n-static int verbose;\n-\n-void print(const char* format, ...) {\n-  va_list args;\n-  va_start(args, format);\n-  if (verbose) {\n-    vprintf(format, args);\n-  }\n-  va_end(args);\n-}\n-\n-// If there is a non-null char at the head of the pushback queue,\n-// dequeue it and shift the rest of the queue forwards. Otherwise,\n-// return the token from calling yylex.\n-int rslex() {\n-  if (pushback[0] == '\\0') {\n-    return yylex();\n-  } else {\n-    char c = pushback[0];\n-    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n-    pushback[PUSHBACK_LEN - 1] = '\\0';\n-    return c;\n-  }\n-}\n-\n-// Note: this does nothing if the pushback queue is full. As long as\n-// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n-// in an action, this shouldn't be a problem.\n-void push_back(char c) {\n-  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n-    if (pushback[i] == '\\0') {\n-      pushback[i] = c;\n-      break;\n-    }\n-  }\n-}\n-\n-extern int rsdebug;\n-\n-struct node {\n-  struct node *next;\n-  struct node *prev;\n-  int own_string;\n-  char const *name;\n-  int n_elems;\n-  struct node *elems[];\n-};\n-\n-struct node *nodes = NULL;\n-int n_nodes;\n-\n-struct node *mk_node(char const *name, int n, ...) {\n-  va_list ap;\n-  int i = 0;\n-  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n-  struct node *nn, *nd = (struct node *)malloc(sz);\n-\n-  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n-\n-  nd->own_string = 0;\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  if (nodes) {\n-    nodes->prev = nd;\n-  }\n-  nodes = nd;\n-\n-  nd->name = name;\n-  nd->n_elems = n;\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[i++] = nn;\n-  }\n-  va_end(ap);\n-  n_nodes++;\n-  return nd;\n-}\n-\n-struct node *mk_atom(char *name) {\n-  struct node *nd = mk_node((char const *)strdup(name), 0);\n-  nd->own_string = 1;\n-  return nd;\n-}\n-\n-struct node *mk_none() {\n-  return mk_atom(\"<none>\");\n-}\n-\n-struct node *ext_node(struct node *nd, int n, ...) {\n-  va_list ap;\n-  int i = 0, c = nd->n_elems + n;\n-  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n-  struct node *nn;\n-\n-  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n-        nd->n_elems, c, nd->name, nd);\n-\n-  if (nd->next) {\n-    nd->next->prev = nd->prev;\n-  }\n-  if (nd->prev) {\n-    nd->prev->next = nd->next;\n-  }\n-  nd = realloc(nd, sz);\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  nodes->prev = nd;\n-  nodes = nd;\n-\n-  print(\" ==> %p\\n\", nd);\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[nd->n_elems++] = nn;\n-    ++i;\n-  }\n-  va_end(ap);\n-  return nd;\n-}\n-\n-int const indent_step = 4;\n-\n-void print_indent(int depth) {\n-  while (depth) {\n-    if (depth-- % indent_step == 0) {\n-      print(\"|\");\n-    } else {\n-      print(\" \");\n-    }\n-  }\n-}\n-\n-void print_node(struct node *n, int depth) {\n-  int i = 0;\n-  print_indent(depth);\n-  if (n->n_elems == 0) {\n-    print(\"%s\\n\", n->name);\n-  } else {\n-    print(\"(%s\\n\", n->name);\n-    for (i = 0; i < n->n_elems; ++i) {\n-      print_node(n->elems[i], depth + indent_step);\n-    }\n-    print_indent(depth);\n-    print(\")\\n\");\n-  }\n-}\n-\n-int main(int argc, char **argv) {\n-  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n-    verbose = 1;\n-  } else {\n-    verbose = 0;\n-  }\n-  int ret = 0;\n-  struct node *tmp;\n-  memset(pushback, '\\0', PUSHBACK_LEN);\n-  ret = rsparse();\n-  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n-  if (nodes) {\n-    print_node(nodes, 0);\n-  }\n-  while (nodes) {\n-    tmp = nodes;\n-    nodes = tmp->next;\n-    if (tmp->own_string) {\n-      free((void*)tmp->name);\n-    }\n-    free(tmp);\n-  }\n-  return ret;\n-}\n-\n-void rserror(char const *s) {\n-  fprintf(stderr, \"%s\\n\", s);\n-}"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "src/grammar/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,1982 +0,0 @@\n-%{\n-#define YYERROR_VERBOSE\n-#define YYSTYPE struct node *\n-struct node;\n-extern int yylex();\n-extern void yyerror(char const *s);\n-extern struct node *mk_node(char const *name, int n, ...);\n-extern struct node *mk_atom(char *text);\n-extern struct node *mk_none();\n-extern struct node *ext_node(struct node *nd, int n, ...);\n-extern void push_back(char c);\n-extern char *yytext;\n-%}\n-%debug\n-\n-%token SHL\n-%token SHR\n-%token LE\n-%token EQEQ\n-%token NE\n-%token GE\n-%token ANDAND\n-%token OROR\n-%token SHLEQ\n-%token SHREQ\n-%token MINUSEQ\n-%token ANDEQ\n-%token OREQ\n-%token PLUSEQ\n-%token STAREQ\n-%token SLASHEQ\n-%token CARETEQ\n-%token PERCENTEQ\n-%token DOTDOT\n-%token DOTDOTDOT\n-%token MOD_SEP\n-%token RARROW\n-%token LARROW\n-%token FAT_ARROW\n-%token LIT_BYTE\n-%token LIT_CHAR\n-%token LIT_INTEGER\n-%token LIT_FLOAT\n-%token LIT_STR\n-%token LIT_STR_RAW\n-%token LIT_BYTE_STR\n-%token LIT_BYTE_STR_RAW\n-%token IDENT\n-%token UNDERSCORE\n-%token LIFETIME\n-\n-// keywords\n-%token SELF\n-%token STATIC\n-%token ABSTRACT\n-%token ALIGNOF\n-%token AS\n-%token BECOME\n-%token BREAK\n-%token CATCH\n-%token CRATE\n-%token DO\n-%token ELSE\n-%token ENUM\n-%token EXTERN\n-%token FALSE\n-%token FINAL\n-%token FN\n-%token FOR\n-%token IF\n-%token IMPL\n-%token IN\n-%token LET\n-%token LOOP\n-%token MACRO\n-%token MATCH\n-%token MOD\n-%token MOVE\n-%token MUT\n-%token OFFSETOF\n-%token OVERRIDE\n-%token PRIV\n-%token PUB\n-%token PURE\n-%token REF\n-%token RETURN\n-%token SIZEOF\n-%token STRUCT\n-%token SUPER\n-%token UNION\n-%token UNSIZED\n-%token TRUE\n-%token TRAIT\n-%token TYPE\n-%token UNSAFE\n-%token VIRTUAL\n-%token YIELD\n-%token DEFAULT\n-%token USE\n-%token WHILE\n-%token CONTINUE\n-%token PROC\n-%token BOX\n-%token CONST\n-%token WHERE\n-%token TYPEOF\n-%token INNER_DOC_COMMENT\n-%token OUTER_DOC_COMMENT\n-\n-%token SHEBANG\n-%token SHEBANG_LINE\n-%token STATIC_LIFETIME\n-\n- /*\n-   Quoting from the Bison manual:\n-\n-   \"Finally, the resolution of conflicts works by comparing the precedence\n-   of the rule being considered with that of the lookahead token. If the\n-   token's precedence is higher, the choice is to shift. If the rule's\n-   precedence is higher, the choice is to reduce. If they have equal\n-   precedence, the choice is made based on the associativity of that\n-   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n-   Bison) says how each conflict was resolved\"\n- */\n-\n-// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n-// all potential ambiguities are scrutinized and eliminated manually.\n-%expect 0\n-\n-// fake-precedence symbol to cause '|' bars in lambda context to parse\n-// at low precedence, permit things like |x| foo = bar, where '=' is\n-// otherwise lower-precedence than '|'. Also used for proc() to cause\n-// things like proc() a + b to parse as proc() { a + b }.\n-%precedence LAMBDA\n-\n-%precedence SELF\n-\n-// MUT should be lower precedence than IDENT so that in the pat rule,\n-// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n-%precedence MUT\n-\n-// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n-// trying to decide if we've got a struct-construction expr (esp. in\n-// contexts like 'if foo { .')\n-//\n-// IDENT also needs to be lower precedence than '<' so that '<' in\n-// 'foo:bar . <' is shifted (in a trait reference occurring in a\n-// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n-%precedence IDENT\n- // Put the weak keywords that can be used as idents here as well\n-%precedence CATCH\n-%precedence DEFAULT\n-%precedence UNION\n-\n-// A couple fake-precedence symbols to use in rules associated with +\n-// and < in trailing type contexts. These come up when you have a type\n-// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n-// has to be shifted so the parser keeps trying to parse a type, even\n-// though it might well consider reducing the type \"bar\" and then\n-// going on to \"<\" as a subsequent binop. The \"+\" case is with\n-// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n-%precedence SHIFTPLUS\n-\n-%precedence MOD_SEP\n-%precedence RARROW ':'\n-\n-// In where clauses, \"for\" should have greater precedence when used as\n-// a higher ranked constraint than when used as the beginning of a\n-// for_in_type (which is a ty)\n-%precedence FORTYPE\n-%precedence FOR\n-\n-// Binops & unops, and their precedences\n-%precedence '?'\n-%precedence BOX\n-%nonassoc DOTDOT\n-\n-// RETURN needs to be lower-precedence than tokens that start\n-// prefix_exprs\n-%precedence RETURN YIELD\n-\n-%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n-%right LARROW\n-%left OROR\n-%left ANDAND\n-%left EQEQ NE\n-%left '<' '>' LE GE\n-%left '|'\n-%left '^'\n-%left '&'\n-%left SHL SHR\n-%left '+' '-'\n-%precedence AS\n-%left '*' '/' '%'\n-%precedence '!'\n-\n-%precedence '{' '[' '(' '.'\n-\n-%precedence RANGE\n-\n-%start crate\n-\n-%%\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 1: Items and attributes\n-////////////////////////////////////////////////////////////////////////\n-\n-crate\n-: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n-| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n-;\n-\n-maybe_shebang\n-: SHEBANG_LINE\n-| %empty\n-;\n-\n-maybe_inner_attrs\n-: inner_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-inner_attrs\n-: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n-| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-inner_attr\n-: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n-| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n-;\n-\n-maybe_outer_attrs\n-: outer_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-outer_attrs\n-: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n-| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-outer_attr\n-: '#' '[' meta_item ']'    { $$ = $3; }\n-| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n-;\n-\n-meta_item\n-: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n-| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n-| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-;\n-\n-meta_seq\n-: %empty                   { $$ = mk_none(); }\n-| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n-| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_mod_items\n-: mod_items\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-mod_items\n-: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n-| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-attrs_and_vis\n-: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n-;\n-\n-mod_item\n-: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n-;\n-\n-// items that can appear outside of a fn block\n-item\n-: stmt_item\n-| item_macro\n-;\n-\n-// items that can appear in \"stmts\"\n-stmt_item\n-: item_static\n-| item_const\n-| item_type\n-| block_item\n-| view_item\n-;\n-\n-item_static\n-: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n-| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n-;\n-\n-item_const\n-: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n-;\n-\n-item_macro\n-: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-;\n-\n-view_item\n-: use_item\n-| extern_fn_item\n-| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n-| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n-;\n-\n-extern_fn_item\n-: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n-;\n-\n-use_item\n-: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n-;\n-\n-view_path\n-: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n-| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n-|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n-|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n-|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n-|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n-|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n-;\n-\n-block_item\n-: item_fn\n-| item_unsafe_fn\n-| item_mod\n-| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n-| item_struct\n-| item_enum\n-| item_union\n-| item_trait\n-| item_impl\n-;\n-\n-maybe_ty_ascription\n-: ':' ty_sum { $$ = $2; }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_init_expr\n-: '=' expr { $$ = $2; }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-// structs\n-item_struct\n-: STRUCT ident generic_params maybe_where_clause struct_decl_args\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n-}\n-;\n-\n-struct_decl_args\n-: '{' struct_decl_fields '}'                  { $$ = $2; }\n-| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n-;\n-\n-struct_tuple_args\n-: '(' struct_tuple_fields ')'                 { $$ = $2; }\n-| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n-;\n-\n-struct_decl_fields\n-: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_decl_field\n-: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n-;\n-\n-struct_tuple_fields\n-: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_tuple_field\n-: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n-;\n-\n-// enums\n-item_enum\n-: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n-| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n-;\n-\n-enum_defs\n-: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n-| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n-| %empty                 { $$ = mk_none(); }\n-;\n-\n-enum_def\n-: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n-;\n-\n-enum_args\n-: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| %empty                         { $$ = mk_none(); }\n-;\n-\n-// unions\n-item_union\n-: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n-| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n-\n-item_mod\n-: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n-| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n-| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n-;\n-\n-item_foreign_mod\n-: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n-| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n-;\n-\n-maybe_abi\n-: str\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_foreign_items\n-: foreign_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-foreign_items\n-: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n-| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n-;\n-\n-foreign_item\n-: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n-| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-;\n-\n-item_foreign_static\n-: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n-;\n-\n-item_foreign_fn\n-: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n-;\n-\n-fn_decl_allow_variadic\n-: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params_allow_variadic\n-: '(' ')'                      { $$ = mk_none(); }\n-| '(' params ')'               { $$ = $2; }\n-| '(' params ',' ')'           { $$ = $2; }\n-| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n-;\n-\n-visibility\n-: PUB      { $$ = mk_atom(\"Public\"); }\n-| %empty   { $$ = mk_atom(\"Inherited\"); }\n-;\n-\n-idents_or_self\n-: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n-| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ident_or_self\n-: ident\n-| SELF  { $$ = mk_atom(yytext); }\n-;\n-\n-item_type\n-: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n-;\n-\n-for_sized\n-: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n-| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n-| %empty        { $$ = mk_none(); }\n-;\n-\n-item_trait\n-: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n-{\n-  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n-}\n-;\n-\n-maybe_trait_items\n-: trait_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-trait_items\n-: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n-| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-trait_item\n-: trait_const\n-| trait_type\n-| trait_method\n-| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n-;\n-\n-trait_const\n-: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_const_default\n-: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-trait_type\n-: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n-;\n-\n-maybe_unsafe\n-: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_default_maybe_unsafe\n-: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n-| DEFAULT        { $$ = mk_atom(\"Default\"); }\n-|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-\n-trait_method\n-: type_method { $$ = mk_node(\"Required\", 1, $1); }\n-| method      { $$ = mk_node(\"Provided\", 1, $1); }\n-;\n-\n-type_method\n-: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n-}\n-| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n-}\n-| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n-}\n-;\n-\n-method\n-: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n-}\n-| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-impl_method\n-: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n-}\n-| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n-}\n-;\n-\n-// There are two forms of impl:\n-//\n-// impl (<...>)? TY { ... }\n-// impl (<...>)? TRAIT for TY { ... }\n-//\n-// Unfortunately since TY can begin with '<' itself -- as part of a\n-// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n-// should we reduce one of the early rules of TY (such as maybe_once)\n-// or shall we continue shifting into the generic_params list for the\n-// impl?\n-//\n-// The production parser disambiguates a different case here by\n-// permitting / requiring the user to provide parens around types when\n-// they are ambiguous with traits. We do the same here, regrettably,\n-// by splitting ty into ty and ty_prim.\n-item_impl\n-: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n-}\n-;\n-\n-maybe_impl_items\n-: impl_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_items\n-: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n-| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n-;\n-\n-impl_item\n-: impl_method\n-| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n-| impl_const\n-| impl_type\n-;\n-\n-maybe_default\n-: DEFAULT { $$ = mk_atom(\"Default\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_const\n-: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n-;\n-\n-impl_type\n-: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n-;\n-\n-item_fn\n-: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n-}\n-| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n-}\n-;\n-\n-item_unsafe_fn\n-: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n-}\n-| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n-}\n-| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n-}\n-;\n-\n-fn_decl\n-: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self\n-: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self_allow_anon_params\n-: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params\n-: '(' maybe_params ')'  { $$ = $2; }\n-;\n-\n-fn_anon_params\n-: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n-| '(' ')'                                            { $$ = mk_none(); }\n-;\n-\n-fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-maybe_params\n-: params\n-| params ','\n-| %empty  { $$ = mk_none(); }\n-;\n-\n-params\n-: param                { $$ = mk_node(\"Args\", 1, $1); }\n-| params ',' param     { $$ = ext_node($1, 1, $3); }\n-;\n-\n-param\n-: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-;\n-\n-inferrable_params\n-: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n-| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-inferrable_param\n-: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n-;\n-\n-maybe_comma_params\n-: ','            { $$ = mk_none(); }\n-| ',' params     { $$ = $2; }\n-| ',' params ',' { $$ = $2; }\n-| %empty         { $$ = mk_none(); }\n-;\n-\n-maybe_comma_anon_params\n-: ','                 { $$ = mk_none(); }\n-| ',' anon_params     { $$ = $2; }\n-| ',' anon_params ',' { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-maybe_anon_params\n-: anon_params\n-| anon_params ','\n-| %empty      { $$ = mk_none(); }\n-;\n-\n-anon_params\n-: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n-| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// anon means it's allowed to be anonymous (type-only), but it can\n-// still have a name\n-anon_param\n-: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-| ty\n-;\n-\n-anon_params_allow_variadic_tail\n-: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n-| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n-| %empty                                         { $$ = mk_none(); }\n-;\n-\n-named_arg\n-: ident\n-| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n-| '&' ident         { $$ = $2; }\n-| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n-| ANDAND ident      { $$ = $2; }\n-| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n-| MUT ident         { $$ = $2; }\n-;\n-\n-ret_ty\n-: RARROW '!'         { $$ = mk_none(); }\n-| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n-| %prec IDENT %empty { $$ = mk_none(); }\n-;\n-\n-generic_params\n-: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n-| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| %empty                              { $$ = mk_none(); }\n-;\n-\n-maybe_where_clause\n-: %empty                              { $$ = mk_none(); }\n-| where_clause\n-;\n-\n-where_clause\n-: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n-| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n-;\n-\n-where_predicates\n-: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n-| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n-;\n-\n-where_predicate\n-: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-;\n-\n-maybe_for_lifetimes\n-: FOR '<' lifetimes '>' { $$ = mk_none(); }\n-| %prec FORTYPE %empty  { $$ = mk_none(); }\n-\n-ty_params\n-: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n-| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with no type parameters; e.g. `foo::bar::Baz`\n-//\n-// These show up in 'use' view-items, because these are processed\n-// without respect to types.\n-path_no_types_allowed\n-: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n-| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n-| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n-| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n-| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters, with no double colons\n-// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-//\n-// These show up in \"trait references\", the components of\n-// type-parameter bounds lists, as well as in the prefix of the\n-// path_generic_args_and_bounds rule, which is the full form of a\n-// named typed expression.\n-//\n-// They do not have (nor need) an extra '::' before '<' because\n-// unlike in expr context, there are no \"less-than\" type exprs to\n-// be ambiguous with.\n-path_generic_args_without_colons\n-: %prec IDENT\n-  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n-| %prec IDENT\n-  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n-| %prec IDENT\n-  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n-;\n-\n-generic_args\n-: '<' generic_values '>'   { $$ = $2; }\n-| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n-| '<' generic_values GE    { push_back('='); $$ = $2; }\n-| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-// If generic_args starts with \"<<\", the first arg must be a\n-// TyQualifiedPath because that's the only type that can start with a\n-// '<'. This rule parses that as the first ty_sum and then continues\n-// with the rest of generic_values.\n-| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-;\n-\n-generic_values\n-: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n-;\n-\n-maybe_ty_sums_and_or_bindings\n-: ty_sums\n-| ty_sums ','\n-| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n-| bindings\n-| bindings ','\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_bindings\n-: ',' bindings { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 2: Patterns\n-////////////////////////////////////////////////////////////////////////\n-\n-pat\n-: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n-| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n-| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n-| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n-| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n-| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n-| lit_or_path\n-| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n-| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n-| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n-| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n-| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n-|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n-| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n-| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-;\n-\n-pats_or\n-: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n-| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding_mode\n-: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n-| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n-| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n-;\n-\n-lit_or_path\n-: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n-| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n-| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n-;\n-\n-pat_field\n-:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n-|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n-| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n-| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n-|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n-| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n-|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n-;\n-\n-pat_fields\n-: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n-| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_struct\n-: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n-| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n-| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n-;\n-\n-pat_tup\n-: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n-| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n-| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n-| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_tup_elts\n-: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n-| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_vec\n-: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_vec_elts\n-: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n-| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 3: Types\n-////////////////////////////////////////////////////////////////////////\n-\n-ty\n-: ty_prim\n-| ty_closure\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n-| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n-;\n-\n-ty_prim\n-: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n-| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n-| ty_bare_fn\n-| for_in_type\n-;\n-\n-ty_bare_fn\n-:                         FN ty_fn_decl { $$ = $2; }\n-| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n-|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n-| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n-;\n-\n-ty_fn_decl\n-: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n-;\n-\n-ty_closure\n-: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n-|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n-| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n-|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n-;\n-\n-for_in_type\n-: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n-;\n-\n-for_in_type_suffix\n-: ty_bare_fn\n-| trait_ref\n-| ty_closure\n-;\n-\n-maybe_mut\n-: MUT              { $$ = mk_atom(\"MutMutable\"); }\n-| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-maybe_mut_or_const\n-: MUT    { $$ = mk_atom(\"MutMutable\"); }\n-| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n-| %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-ty_qualified_path_and_generic_values\n-: ty_qualified_path maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n-}\n-| ty_qualified_path ',' ty_sums maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n-}\n-;\n-\n-ty_qualified_path\n-: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-;\n-\n-maybe_ty_sums\n-: ty_sums\n-| ty_sums ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-ty_sums\n-: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n-| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum\n-: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum_elt\n-: ty\n-| lifetime\n-;\n-\n-ty_prim_sum\n-: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_prim_sum_elt\n-: ty_prim\n-| lifetime\n-;\n-\n-maybe_ty_param_bounds\n-: ':' ty_param_bounds { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-ty_param_bounds\n-: boundseq\n-| %empty { $$ = mk_none(); }\n-;\n-\n-boundseq\n-: polybound\n-| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-polybound\n-: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n-| bound\n-| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n-| '?' bound { $$ = $2; }\n-;\n-\n-bindings\n-: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n-| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding\n-: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n-;\n-\n-ty_param\n-: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n-| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_bounds\n-: %prec SHIFTPLUS\n-  ':' bounds             { $$ = $2; }\n-| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n-;\n-\n-bounds\n-: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n-| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-bound\n-: lifetime\n-| trait_ref\n-;\n-\n-maybe_ltbounds\n-: %prec SHIFTPLUS\n-  ':' ltbounds       { $$ = $2; }\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-ltbounds\n-: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n-| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_ty_default\n-: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n-| %empty     { $$ = mk_none(); }\n-;\n-\n-maybe_lifetimes\n-: lifetimes\n-| lifetimes ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-lifetimes\n-: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n-| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n-;\n-\n-lifetime_and_bounds\n-: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n-| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-lifetime\n-: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n-| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-trait_ref\n-: %prec IDENT path_generic_args_without_colons\n-| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 4: Blocks, statements, and expressions\n-////////////////////////////////////////////////////////////////////////\n-\n-inner_attrs_and_block\n-: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n-;\n-\n-block\n-: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n-;\n-\n-maybe_stmts\n-: stmts\n-| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n-| nonblock_expr\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-// There are two sub-grammars within a \"stmts: exprs\" derivation\n-// depending on whether each stmt-expr is a block-expr form; this is to\n-// handle the \"semicolon rule\" for stmt sequencing that permits\n-// writing\n-//\n-//     if foo { bar } 10\n-//\n-// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n-// stmt). Unfortunately by permitting juxtaposition of exprs in\n-// sequence like that, the non-block expr grammar has to have a\n-// second limited sub-grammar that excludes the prefix exprs that\n-// are ambiguous with binops. That is to say:\n-//\n-//     {10} - 1\n-//\n-// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n-// is to say, two statements rather than one, at least according to\n-// the mainline rust parser.\n-//\n-// So we wind up with a 3-way split in exprs that occur in stmt lists:\n-// block, nonblock-prefix, and nonblock-nonprefix.\n-//\n-// In non-stmts contexts, expr can relax this trichotomy.\n-\n-stmts\n-: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n-| stmts stmt     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-stmt\n-: maybe_outer_attrs let     { $$ = $2; }\n-|                 stmt_item\n-|             PUB stmt_item { $$ = $2; }\n-| outer_attrs     stmt_item { $$ = $2; }\n-| outer_attrs PUB stmt_item { $$ = $3; }\n-| full_block_expr\n-| maybe_outer_attrs block   { $$ = $2; }\n-|             nonblock_expr ';'\n-| outer_attrs nonblock_expr ';' { $$ = $2; }\n-| ';'                   { $$ = mk_none(); }\n-;\n-\n-maybe_exprs\n-: exprs\n-| exprs ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_expr\n-: expr\n-| %empty { $$ = mk_none(); }\n-;\n-\n-exprs\n-: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n-| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n-;\n-\n-path_expr\n-: path_generic_args_with_colons\n-| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n-| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters with double colons before\n-// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-//\n-// These show up in expr context, in order to disambiguate from \"less-than\"\n-// expressions.\n-path_generic_args_with_colons\n-: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n-| SUPER                                              { $$ = mk_atom(\"Super\"); }\n-| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n-| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n-| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// the braces-delimited macro is a block_expr so it doesn't appear here\n-macro_expr\n-: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-;\n-\n-nonblock_expr\n-: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| nonblock_prefix_expr\n-;\n-\n-expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-expr_nostruct\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr_nostruct\n-;\n-\n-nonblock_prefix_expr_nostruct\n-: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr_nostruct\n-| MOVE lambda_expr_nostruct                 { $$ = $2; }\n-;\n-\n-nonblock_prefix_expr\n-: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr\n-| MOVE lambda_expr                 { $$ = $2; }\n-;\n-\n-expr_qualified_path\n-: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n-}\n-\n-maybe_qpath_params\n-: MOD_SEP generic_args { $$ = $2; }\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_as_trait_ref\n-: AS trait_ref { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-lambda_expr\n-: %prec LAMBDA\n-  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n-| %prec LAMBDA\n-  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n-;\n-\n-lambda_expr_no_first_bar\n-: %prec LAMBDA\n-  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n-| %prec LAMBDA\n-  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n-;\n-\n-lambda_expr_nostruct\n-: %prec LAMBDA\n-  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n-;\n-\n-lambda_expr_nostruct_no_first_bar\n-: %prec LAMBDA\n-  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n-| %prec LAMBDA\n-  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n-;\n-\n-vec_expr\n-: maybe_exprs\n-| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n-;\n-\n-struct_expr_fields\n-: field_inits\n-| field_inits ','\n-| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n-| %empty                               { $$ = mk_none(); }\n-;\n-\n-maybe_field_inits\n-: field_inits\n-| field_inits ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-field_inits\n-: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n-| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n-;\n-\n-field_init\n-: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n-| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n-| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n-;\n-\n-default_field_init\n-: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n-;\n-\n-block_expr\n-: expr_match\n-| expr_if\n-| expr_if_let\n-| expr_while\n-| expr_while_let\n-| expr_loop\n-| expr_for\n-| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n-;\n-\n-full_block_expr\n-: block_expr\n-| block_expr_dot\n-;\n-\n-block_expr_dot\n-: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-;\n-\n-expr_match\n-: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n-| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n-| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n-| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n-;\n-\n-match_clauses\n-: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n-| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n-;\n-\n-match_clause\n-: nonblock_match_clause ','\n-| block_match_clause\n-| block_match_clause ','\n-;\n-\n-nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n-;\n-\n-block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n-;\n-\n-maybe_guard\n-: IF expr_nostruct           { $$ = $2; }\n-| %empty                     { $$ = mk_none(); }\n-;\n-\n-expr_if\n-: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n-| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n-;\n-\n-expr_if_let\n-: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n-| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n-;\n-\n-block_or_if\n-: block\n-| expr_if\n-| expr_if_let\n-;\n-\n-expr_while\n-: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n-;\n-\n-expr_while_let\n-: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n-;\n-\n-expr_loop\n-: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n-;\n-\n-expr_for\n-: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n-;\n-\n-maybe_label\n-: lifetime ':'\n-| %empty { $$ = mk_none(); }\n-;\n-\n-let\n-: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 5: Macros and misc. rules\n-////////////////////////////////////////////////////////////////////////\n-\n-lit\n-: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n-| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n-| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n-| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n-| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| str\n-;\n-\n-str\n-: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n-| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n-| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n-| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n-;\n-\n-maybe_ident\n-: %empty { $$ = mk_none(); }\n-| ident\n-;\n-\n-ident\n-: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-// Weak keywords that can be used as identifiers\n-| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-;\n-\n-unpaired_token\n-: SHL                        { $$ = mk_atom(yytext); }\n-| SHR                        { $$ = mk_atom(yytext); }\n-| LE                         { $$ = mk_atom(yytext); }\n-| EQEQ                       { $$ = mk_atom(yytext); }\n-| NE                         { $$ = mk_atom(yytext); }\n-| GE                         { $$ = mk_atom(yytext); }\n-| ANDAND                     { $$ = mk_atom(yytext); }\n-| OROR                       { $$ = mk_atom(yytext); }\n-| LARROW                     { $$ = mk_atom(yytext); }\n-| SHLEQ                      { $$ = mk_atom(yytext); }\n-| SHREQ                      { $$ = mk_atom(yytext); }\n-| MINUSEQ                    { $$ = mk_atom(yytext); }\n-| ANDEQ                      { $$ = mk_atom(yytext); }\n-| OREQ                       { $$ = mk_atom(yytext); }\n-| PLUSEQ                     { $$ = mk_atom(yytext); }\n-| STAREQ                     { $$ = mk_atom(yytext); }\n-| SLASHEQ                    { $$ = mk_atom(yytext); }\n-| CARETEQ                    { $$ = mk_atom(yytext); }\n-| PERCENTEQ                  { $$ = mk_atom(yytext); }\n-| DOTDOT                     { $$ = mk_atom(yytext); }\n-| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n-| MOD_SEP                    { $$ = mk_atom(yytext); }\n-| RARROW                     { $$ = mk_atom(yytext); }\n-| FAT_ARROW                  { $$ = mk_atom(yytext); }\n-| LIT_BYTE                   { $$ = mk_atom(yytext); }\n-| LIT_CHAR                   { $$ = mk_atom(yytext); }\n-| LIT_INTEGER                { $$ = mk_atom(yytext); }\n-| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n-| LIT_STR                    { $$ = mk_atom(yytext); }\n-| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n-| IDENT                      { $$ = mk_atom(yytext); }\n-| UNDERSCORE                 { $$ = mk_atom(yytext); }\n-| LIFETIME                   { $$ = mk_atom(yytext); }\n-| SELF                       { $$ = mk_atom(yytext); }\n-| STATIC                     { $$ = mk_atom(yytext); }\n-| ABSTRACT                   { $$ = mk_atom(yytext); }\n-| ALIGNOF                    { $$ = mk_atom(yytext); }\n-| AS                         { $$ = mk_atom(yytext); }\n-| BECOME                     { $$ = mk_atom(yytext); }\n-| BREAK                      { $$ = mk_atom(yytext); }\n-| CATCH                      { $$ = mk_atom(yytext); }\n-| CRATE                      { $$ = mk_atom(yytext); }\n-| DEFAULT                    { $$ = mk_atom(yytext); }\n-| DO                         { $$ = mk_atom(yytext); }\n-| ELSE                       { $$ = mk_atom(yytext); }\n-| ENUM                       { $$ = mk_atom(yytext); }\n-| EXTERN                     { $$ = mk_atom(yytext); }\n-| FALSE                      { $$ = mk_atom(yytext); }\n-| FINAL                      { $$ = mk_atom(yytext); }\n-| FN                         { $$ = mk_atom(yytext); }\n-| FOR                        { $$ = mk_atom(yytext); }\n-| IF                         { $$ = mk_atom(yytext); }\n-| IMPL                       { $$ = mk_atom(yytext); }\n-| IN                         { $$ = mk_atom(yytext); }\n-| LET                        { $$ = mk_atom(yytext); }\n-| LOOP                       { $$ = mk_atom(yytext); }\n-| MACRO                      { $$ = mk_atom(yytext); }\n-| MATCH                      { $$ = mk_atom(yytext); }\n-| MOD                        { $$ = mk_atom(yytext); }\n-| MOVE                       { $$ = mk_atom(yytext); }\n-| MUT                        { $$ = mk_atom(yytext); }\n-| OFFSETOF                   { $$ = mk_atom(yytext); }\n-| OVERRIDE                   { $$ = mk_atom(yytext); }\n-| PRIV                       { $$ = mk_atom(yytext); }\n-| PUB                        { $$ = mk_atom(yytext); }\n-| PURE                       { $$ = mk_atom(yytext); }\n-| REF                        { $$ = mk_atom(yytext); }\n-| RETURN                     { $$ = mk_atom(yytext); }\n-| STRUCT                     { $$ = mk_atom(yytext); }\n-| SIZEOF                     { $$ = mk_atom(yytext); }\n-| SUPER                      { $$ = mk_atom(yytext); }\n-| TRUE                       { $$ = mk_atom(yytext); }\n-| TRAIT                      { $$ = mk_atom(yytext); }\n-| TYPE                       { $$ = mk_atom(yytext); }\n-| UNION                      { $$ = mk_atom(yytext); }\n-| UNSAFE                     { $$ = mk_atom(yytext); }\n-| UNSIZED                    { $$ = mk_atom(yytext); }\n-| USE                        { $$ = mk_atom(yytext); }\n-| VIRTUAL                    { $$ = mk_atom(yytext); }\n-| WHILE                      { $$ = mk_atom(yytext); }\n-| YIELD                      { $$ = mk_atom(yytext); }\n-| CONTINUE                   { $$ = mk_atom(yytext); }\n-| PROC                       { $$ = mk_atom(yytext); }\n-| BOX                        { $$ = mk_atom(yytext); }\n-| CONST                      { $$ = mk_atom(yytext); }\n-| WHERE                      { $$ = mk_atom(yytext); }\n-| TYPEOF                     { $$ = mk_atom(yytext); }\n-| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| SHEBANG                    { $$ = mk_atom(yytext); }\n-| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n-| ';'                        { $$ = mk_atom(yytext); }\n-| ','                        { $$ = mk_atom(yytext); }\n-| '.'                        { $$ = mk_atom(yytext); }\n-| '@'                        { $$ = mk_atom(yytext); }\n-| '#'                        { $$ = mk_atom(yytext); }\n-| '~'                        { $$ = mk_atom(yytext); }\n-| ':'                        { $$ = mk_atom(yytext); }\n-| '$'                        { $$ = mk_atom(yytext); }\n-| '='                        { $$ = mk_atom(yytext); }\n-| '?'                        { $$ = mk_atom(yytext); }\n-| '!'                        { $$ = mk_atom(yytext); }\n-| '<'                        { $$ = mk_atom(yytext); }\n-| '>'                        { $$ = mk_atom(yytext); }\n-| '-'                        { $$ = mk_atom(yytext); }\n-| '&'                        { $$ = mk_atom(yytext); }\n-| '|'                        { $$ = mk_atom(yytext); }\n-| '+'                        { $$ = mk_atom(yytext); }\n-| '*'                        { $$ = mk_atom(yytext); }\n-| '/'                        { $$ = mk_atom(yytext); }\n-| '^'                        { $$ = mk_atom(yytext); }\n-| '%'                        { $$ = mk_atom(yytext); }\n-;\n-\n-token_trees\n-: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n-| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-token_tree\n-: delimited_token_trees\n-| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n-;\n-\n-delimited_token_trees\n-: parens_delimited_token_trees\n-| braces_delimited_token_trees\n-| brackets_delimited_token_trees\n-;\n-\n-parens_delimited_token_trees\n-: '(' token_trees ')'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n-}\n-;\n-\n-braces_delimited_token_trees\n-: '{' token_trees '}'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n-}\n-;\n-\n-brackets_delimited_token_trees\n-: '[' token_trees ']'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n-}\n-;"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,64 +0,0 @@\n-Rust's lexical grammar is not context-free. Raw string literals are the source\n-of the problem. Informally, a raw string literal is an `r`, followed by `N`\n-hashes (where N can be zero), a quote, any characters, then a quote followed\n-by `N` hashes. Critically, once inside the first pair of quotes,\n-another quote cannot be followed by `N` consecutive hashes. e.g.\n-`r###\"\"###\"###` is invalid.\n-\n-This grammar describes this as best possible:\n-\n-    R -> 'r' S\n-    S -> '\"' B '\"'\n-    S -> '#' S '#'\n-    B -> . B\n-    B -> \u03b5\n-\n-Where `.` represents any character, and `\u03b5` the empty string. Consider the\n-string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n-accepted as one by the above grammar, using the derivation:\n-\n-    R : #\"\"#\"#\n-    S : \"\"#\"\n-    S : \"#\n-    B : #\n-    B : \u03b5\n-\n-(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n-string.) The difficulty arises from the fact that it is fundamentally\n-context-sensitive. In particular, the context needed is the number of hashes.\n-\n-To prove that Rust's string literals are not context-free, we will use\n-the fact that context-free languages are closed under intersection with\n-regular languages, and the\n-[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n-\n-Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n-context-free, then their intersection with `R`, `R'`, should also be context-free.\n-Therefore, to prove that raw string literals are not context-free,\n-it is sufficient to prove that `R'` is not context-free.\n-\n-The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n-\n-Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n-the pumping lemma applies. Consider the following string `s` in `R'`:\n-\n-`r#^p\"\"#^{p-1}\"#^p`\n-\n-e.g. for `p = 2`: `s = r##\"\"#\"##`\n-\n-Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n-`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n-\n-Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n-in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n-Consequently, of the three sequences of hashes, `v` and `x` combined\n-can only pump two of them.\n-If we ever choose the central sequence of hashes, then one of the outer sequences\n-will not grow when we pump, leading to an imbalance between the outer sequences.\n-Therefore, we must pump both outer sequences of hashes. However,\n-there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n-be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n-context-free.\n-\n-Since `R'` is not context-free, it follows that the Rust's raw string literals\n-must not be context-free."}, {"sha": "4b5a7fb9e10b5c4ce4f6d6f52932787194713d5d", "filename": "src/grammar/testparser.py", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,66 +0,0 @@\n-#!/usr/bin/env python\n-\n-# ignore-tidy-linelength\n-\n-import sys\n-\n-import os\n-import subprocess\n-import argparse\n-\n-# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n-\n-# Parsers should read from stdin and return exit status 0 for a\n-# successful parse, and nonzero for an unsuccessful parse\n-\n-parser = argparse.ArgumentParser()\n-parser.add_argument('-p', '--parser', nargs='+')\n-parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n-args = parser.parse_args(sys.argv[1:])\n-\n-total = 0\n-ok = {}\n-bad = {}\n-for parser in args.parser:\n-    ok[parser] = 0\n-    bad[parser] = []\n-devnull = open(os.devnull, 'w')\n-print(\"\\n\")\n-\n-for base, dirs, files in os.walk(args.source_dir[0]):\n-    for f in filter(lambda p: p.endswith('.rs'), files):\n-        p = os.path.join(base, f)\n-        parse_fail = 'parse-fail' in p\n-        if sys.version_info.major == 3:\n-            lines = open(p, encoding='utf-8').readlines()\n-        else:\n-            lines = open(p).readlines()\n-        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n-            continue\n-        total += 1\n-        for parser in args.parser:\n-            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n-                if parse_fail:\n-                    bad[parser].append(p)\n-                else:\n-                    ok[parser] += 1\n-            else:\n-                if parse_fail:\n-                    ok[parser] += 1\n-                else:\n-                    bad[parser].append(p)\n-        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n-        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n-                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n-\n-devnull.close()\n-\n-print(\"\\n\")\n-\n-for parser in args.parser:\n-    filename = os.path.basename(parser) + '.bad'\n-    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n-    with open(filename, \"w\") as f:\n-        for p in bad[parser]:\n-            f.write(p)\n-            f.write(\"\\n\")"}, {"sha": "297e3dc841e871502e2270c95fdf6565806f0f5a", "filename": "src/grammar/tokens.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,99 +0,0 @@\n-enum Token {\n-  SHL = 257, // Parser generators reserve 0-256 for char literals\n-  SHR,\n-  LE,\n-  EQEQ,\n-  NE,\n-  GE,\n-  ANDAND,\n-  OROR,\n-  SHLEQ,\n-  SHREQ,\n-  MINUSEQ,\n-  ANDEQ,\n-  OREQ,\n-  PLUSEQ,\n-  STAREQ,\n-  SLASHEQ,\n-  CARETEQ,\n-  PERCENTEQ,\n-  DOTDOT,\n-  DOTDOTDOT,\n-  MOD_SEP,\n-  LARROW,\n-  RARROW,\n-  FAT_ARROW,\n-  LIT_BYTE,\n-  LIT_CHAR,\n-  LIT_INTEGER,\n-  LIT_FLOAT,\n-  LIT_STR,\n-  LIT_STR_RAW,\n-  LIT_BYTE_STR,\n-  LIT_BYTE_STR_RAW,\n-  IDENT,\n-  UNDERSCORE,\n-  LIFETIME,\n-\n-  // keywords\n-  SELF,\n-  STATIC,\n-  ABSTRACT,\n-  ALIGNOF,\n-  AS,\n-  BECOME,\n-  BREAK,\n-  CATCH,\n-  CRATE,\n-  DEFAULT,\n-  DO,\n-  ELSE,\n-  ENUM,\n-  EXTERN,\n-  FALSE,\n-  FINAL,\n-  FN,\n-  FOR,\n-  IF,\n-  IMPL,\n-  IN,\n-  LET,\n-  LOOP,\n-  MACRO,\n-  MATCH,\n-  MOD,\n-  MOVE,\n-  MUT,\n-  OFFSETOF,\n-  OVERRIDE,\n-  PRIV,\n-  PUB,\n-  PURE,\n-  REF,\n-  RETURN,\n-  SIZEOF,\n-  STRUCT,\n-  SUPER,\n-  UNION,\n-  TRUE,\n-  TRAIT,\n-  TYPE,\n-  UNSAFE,\n-  UNSIZED,\n-  USE,\n-  VIRTUAL,\n-  WHILE,\n-  YIELD,\n-  CONTINUE,\n-  PROC,\n-  BOX,\n-  CONST,\n-  WHERE,\n-  TYPEOF,\n-  INNER_DOC_COMMENT,\n-  OUTER_DOC_COMMENT,\n-\n-  SHEBANG,\n-  SHEBANG_LINE,\n-  STATIC_LIFETIME\n-};"}, {"sha": "d22420e76dcd4966916949b1cce9dc5972386a81", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -410,7 +410,7 @@ impl<'a> Parser<'a> {\n         &self.input[start..self.input.len()]\n     }\n \n-    /// Parses an Argument structure, or what's contained within braces inside the format string\n+    /// Parses an `Argument` structure, or what's contained within braces inside the format string.\n     fn argument(&mut self) -> Argument<'a> {\n         let pos = self.position();\n         let format = self.format();\n@@ -464,7 +464,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a format specifier at the current position, returning all of the\n-    /// relevant information in the FormatSpec struct.\n+    /// relevant information in the `FormatSpec` struct.\n     fn format(&mut self) -> FormatSpec<'a> {\n         let mut spec = FormatSpec {\n             fill: None,\n@@ -571,7 +571,7 @@ impl<'a> Parser<'a> {\n         spec\n     }\n \n-    /// Parses a Count parameter at the current position. This does not check\n+    /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n     fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {"}, {"sha": "2238a56b29d04b150139935aed91f6deaa676067", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -988,10 +988,12 @@ impl<'a> LoweringContext<'a> {\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n         Attribute {\n+            item: AttrItem {\n+                path: attr.path.clone(),\n+                tokens: self.lower_token_stream(attr.tokens.clone()),\n+            },\n             id: attr.id,\n             style: attr.style,\n-            path: attr.path.clone(),\n-            tokens: self.lower_token_stream(attr.tokens.clone()),\n             is_sugared_doc: attr.is_sugared_doc,\n             span: attr.span,\n         }"}, {"sha": "23a2f115e05e2516fbb0acc8a38106c89812c0ac", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -196,26 +196,27 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n     }\n }\n \n+impl_stable_hash_for!(struct ::syntax::ast::AttrItem {\n+    path,\n+    tokens,\n+});\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n         debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n         debug_assert!(!self.is_sugared_doc);\n \n         let ast::Attribute {\n+            ref item,\n             id: _,\n             style,\n-            ref path,\n-            ref tokens,\n             is_sugared_doc: _,\n             span,\n         } = *self;\n \n+        item.hash_stable(hcx, hasher);\n         style.hash_stable(hcx, hasher);\n-        path.hash_stable(hcx, hasher);\n-        for tt in tokens.trees() {\n-            tt.hash_stable(hcx, hasher);\n-        }\n         span.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "b06b63455ba4bc7aa295a41654fda4cb1258ff0a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -23,7 +23,7 @@ use crate::ty::relate::RelateResult;\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, InferConst};\n use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n-use crate::util::nodemap::FxHashMap;\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n use errors::DiagnosticBuilder;\n use rustc_data_structures::sync::Lrc;\n@@ -155,6 +155,8 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n+    pub reported_closure_mismatch: RefCell<FxHashSet<(Span, Option<Span>)>>,\n+\n     /// When an error occurs, we want to avoid reporting \"derived\"\n     /// errors that are due to this original failure. Normally, we\n     /// handle this with the `err_count_on_creation` count, which\n@@ -538,6 +540,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 selection_cache: Default::default(),\n                 evaluation_cache: Default::default(),\n                 reported_trait_errors: Default::default(),\n+                reported_closure_mismatch: Default::default(),\n                 tainted_by_errors_flag: Cell::new(false),\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),"}, {"sha": "a1c97d6c68790017ed11e70740364f402f52d42a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 173, "deletions": 12, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -24,7 +24,7 @@ use crate::hir::def_id::DefId;\n use crate::infer::{self, InferCtxt};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::session::DiagnosticMessageId;\n-use crate::ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use crate::ty::GenericParamDefKind;\n use crate::ty::error::ExpectedFound;\n use crate::ty::fast_reject;\n@@ -37,7 +37,7 @@ use errors::{Applicability, DiagnosticBuilder, pluralise};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::{sym, kw};\n-use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(\n@@ -550,7 +550,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        self.note_obligation_cause(&mut err, obligation);\n+        self.note_obligation_cause_code(&mut err, &obligation.predicate, &obligation.cause.code,\n+                                        &mut vec![]);\n \n         err.emit();\n         self.tcx.sess.abort_if_errors();\n@@ -885,6 +886,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.hir().span_if_local(did)\n                 ).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n                     ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n                     _ => vec![ArgKind::empty()],\n@@ -940,7 +949,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 bug!(\"overflow should be handled before the `report_selection_error` path\");\n             }\n         };\n+\n         self.note_obligation_cause(&mut err, obligation);\n+\n         err.emit();\n     }\n \n@@ -1604,15 +1615,165 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn note_obligation_cause<T>(&self,\n-                                err: &mut DiagnosticBuilder<'_>,\n-                                obligation: &Obligation<'tcx, T>)\n-        where T: fmt::Display\n-    {\n-        self.note_obligation_cause_code(err,\n-                                        &obligation.predicate,\n-                                        &obligation.cause.code,\n-                                        &mut vec![]);\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(err, &obligation.predicate, &obligation.cause.code,\n+                                            &mut vec![]);\n+        }\n+    }\n+\n+    /// Adds an async-await specific note to the diagnostic:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// note: future does not implement `std::marker::Send` because this value is used across an\n+    ///       await\n+    ///   --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n+    ///    |\n+    /// LL |     let g = x.lock().unwrap();\n+    ///    |         - has type `std::sync::MutexGuard<'_, u32>`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n+    /// LL | }\n+    ///    | - `g` is later dropped here\n+    /// ```\n+    ///\n+    /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        debug!(\"note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+                obligation.cause.span={:?}\", obligation.predicate, obligation.cause.span);\n+        let source_map = self.tcx.sess.source_map();\n+\n+        // Look into the obligation predicate to determine the type in the generator which meant\n+        // that the predicate was not satisifed.\n+        let (trait_ref, target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(trait_predicate) =>\n+                (trait_predicate.skip_binder().trait_ref, trait_predicate.skip_binder().self_ty()),\n+            _ => return false,\n+        };\n+        debug!(\"note_obligation_cause_for_async_await: target_ty={:?}\", target_ty);\n+\n+        // Attempt to detect an async-await error by looking at the obligation causes, looking\n+        // for only generators, generator witnesses, opaque types or `std::future::GenFuture` to\n+        // be present.\n+        //\n+        // When a future does not implement a trait because of a captured type in one of the\n+        // generators somewhere in the call stack, then the result is a chain of obligations.\n+        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // future is passed as an argument to a function C which requires a `Send` type, then the\n+        // chain looks something like this:\n+        //\n+        // - `BuiltinDerivedObligation` with a generator witness (B)\n+        // - `BuiltinDerivedObligation` with a generator (B)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with a generator witness (A)\n+        // - `BuiltinDerivedObligation` with a generator (A)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BindingObligation` with `impl_send (Send requirement)\n+        //\n+        // The first obligations in the chain can be used to get the details of the type that is\n+        // captured but the entire chain must be inspected to detect this case.\n+        let mut generator = None;\n+        let mut next_code = Some(&obligation.cause.code);\n+        while let Some(code) = next_code {\n+            debug!(\"note_obligation_cause_for_async_await: code={:?}\", code);\n+            match code {\n+                ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) |\n+                ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                    debug!(\"note_obligation_cause_for_async_await: self_ty.kind={:?}\",\n+                           derived_obligation.parent_trait_ref.self_ty().kind);\n+                    match derived_obligation.parent_trait_ref.self_ty().kind {\n+                        ty::Adt(ty::AdtDef { did, .. }, ..) if\n+                            self.tcx.is_diagnostic_item(sym::gen_future, *did) => {},\n+                        ty::Generator(did, ..) => generator = generator.or(Some(did)),\n+                        ty::GeneratorWitness(_) | ty::Opaque(..) => {},\n+                        _ => return false,\n+                    }\n+\n+                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                },\n+                ObligationCauseCode::ItemObligation(_) | ObligationCauseCode::BindingObligation(..)\n+                    if generator.is_some() => break,\n+                _ => return false,\n+            }\n+        }\n+\n+        let generator_did = generator.expect(\"can only reach this if there was a generator\");\n+\n+        // Only continue to add a note if the generator is from an `async` function.\n+        let parent_node = self.tcx.parent(generator_did)\n+            .and_then(|parent_did| self.tcx.hir().get_if_local(parent_did));\n+        debug!(\"note_obligation_cause_for_async_await: parent_node={:?}\", parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(_, header, _, _),\n+            ..\n+        })) = parent_node {\n+            debug!(\"note_obligation_cause_for_async_await: header={:?}\", header);\n+            if header.asyncness != hir::IsAsync::Async {\n+                return false;\n+            }\n+        }\n+\n+        let span = self.tcx.def_span(generator_did);\n+        let tables = self.tcx.typeck_tables_of(generator_did);\n+        debug!(\"note_obligation_cause_for_async_await: generator_did={:?} span={:?} \",\n+               generator_did, span);\n+\n+        // Look for a type inside the generator interior that matches the target type to get\n+        // a span.\n+        let target_span = tables.generator_interior_types.iter()\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty::TyS::same_type(*ty, target_ty))\n+            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, .. }|\n+                 (span, source_map.span_to_snippet(*span), scope_span));\n+        if let Some((target_span, Ok(snippet), scope_span)) = target_span {\n+            // Look at the last interior type to get a span for the `.await`.\n+            let await_span = tables.generator_interior_types.iter().map(|i| i.span).last().unwrap();\n+            let mut span = MultiSpan::from_span(await_span);\n+            span.push_span_label(\n+                await_span, format!(\"await occurs here, with `{}` maybe used later\", snippet));\n+\n+            span.push_span_label(*target_span, format!(\"has type `{}`\", target_ty));\n+\n+            // If available, use the scope span to annotate the drop location.\n+            if let Some(scope_span) = scope_span {\n+                span.push_span_label(\n+                    source_map.end_point(*scope_span),\n+                    format!(\"`{}` is later dropped here\", snippet),\n+                );\n+            }\n+\n+            err.span_note(span, &format!(\n+                \"future does not implement `{}` as this value is used across an await\",\n+                trait_ref,\n+            ));\n+\n+            // Add a note for the item obligation that remains - normally a note pointing to the\n+            // bound that introduced the obligation (e.g. `T: Send`).\n+            debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                next_code.unwrap(),\n+                &mut Vec::new(),\n+            );\n+\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn note_obligation_cause_code<T>(&self,"}, {"sha": "ffe1a11e81a11e7f31c8dd8029af1c4d7a8236a7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -288,6 +288,34 @@ pub struct ResolvedOpaqueTy<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n+/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n+/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n+/// captured types that can be useful for diagnostics. In particular, it stores the span that\n+/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n+/// be used to find the await that the value is live across).\n+///\n+/// For example:\n+///\n+/// ```ignore (pseudo-Rust)\n+/// async move {\n+///     let x: T = ...;\n+///     foo.await\n+///     ...\n+/// }\n+/// ```\n+///\n+/// Here, we would store the type `T`, the span of the value `x`, and the \"scope-span\" for\n+/// the scope that contains `x`.\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, HashStable, PartialEq)]\n+pub struct GeneratorInteriorTypeCause<'tcx> {\n+    /// Type of the captured binding.\n+    pub ty: Ty<'tcx>,\n+    /// Span of the binding that was captured.\n+    pub span: Span,\n+    /// Span of the scope of the captured binding.\n+    pub scope_span: Option<Span>,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The HirId::owner all ItemLocalIds in this table are relative to.\n@@ -397,6 +425,10 @@ pub struct TypeckTables<'tcx> {\n     /// leading to the member of the struct or tuple that is used instead of the\n     /// entire variable.\n     pub upvar_list: ty::UpvarListMap,\n+\n+    /// Stores the type, span and optional scope span of all types\n+    /// that are live across the yield of this generator (if a generator).\n+    pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -422,6 +454,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             free_region_map: Default::default(),\n             concrete_opaque_types: Default::default(),\n             upvar_list: Default::default(),\n+            generator_interior_types: Default::default(),\n         }\n     }\n \n@@ -729,6 +762,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref free_region_map,\n             ref concrete_opaque_types,\n             ref upvar_list,\n+            ref generator_interior_types,\n \n         } = *self;\n \n@@ -773,6 +807,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             free_region_map.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             upvar_list.hash_stable(hcx, hasher);\n+            generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "4b9117f71be5ce0214fe1f965fed9a82f8a30057", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -75,7 +75,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, CtxtInterners, GlobalCtxt};\n+pub use self::context::{Lift, GeneratorInteriorTypeCause, TypeckTables, CtxtInterners, GlobalCtxt};\n pub use self::context::{\n     UserTypeAnnotationIndex, UserType, CanonicalUserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,"}, {"sha": "0c7aa3582ac23f096736eaab789326fb92b19c9a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 239, "deletions": 273, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -99,8 +99,8 @@ impl Margin {\n         // ```\n \n         let mut m = Margin {\n-            whitespace_left: if whitespace_left >= 6 { whitespace_left - 6 } else { 0 },\n-            span_left: if span_left >= 6 { span_left - 6 } else { 0 },\n+            whitespace_left: whitespace_left.saturating_sub(6),\n+            span_left: span_left.saturating_sub(6),\n             span_right: span_right + 6,\n             computed_left: 0,\n             computed_right: 0,\n@@ -125,7 +125,7 @@ impl Margin {\n         } else {\n             self.computed_right\n         };\n-        right < line_len && line_len > self.computed_left + self.column_width\n+        right < line_len && self.computed_left + self.column_width < line_len\n     }\n \n     fn compute(&mut self, max_line_len: usize) {\n@@ -167,12 +167,10 @@ impl Margin {\n     }\n \n     fn right(&self, line_len: usize) -> usize {\n-        if max(line_len, self.computed_left) - self.computed_left <= self.column_width {\n-            line_len\n-        } else if self.computed_right > line_len {\n+        if line_len.saturating_sub(self.computed_left) <= self.column_width {\n             line_len\n         } else {\n-            self.computed_right\n+            min(line_len, self.computed_right)\n         }\n     }\n }\n@@ -297,81 +295,82 @@ pub trait Emitter {\n                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n                                    span: &mut MultiSpan,\n                                    always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n+        let sm = match source_map {\n+            Some(ref sm) => sm,\n+            None => return false,\n+        };\n \n-        if let Some(ref sm) = source_map {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n+        let mut before_after: Vec<(Span, Span)> = vec![];\n+        let mut new_labels: Vec<(Span, String)> = vec![];\n \n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n+        // First, find all the spans in <*macros> and point instead at their use site\n+        for sp in span.primary_spans() {\n+            if sp.is_dummy() {\n+                continue;\n+            }\n+            let call_sp = sm.call_span_if_macro(*sp);\n+            if call_sp != *sp && !always_backtrace {\n+                before_after.push((*sp, call_sp));\n+            }\n+            let backtrace_len = sp.macro_backtrace().len();\n+            for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                // Only show macro locations that are local\n+                // and display them like a span_note\n+                if trace.def_site_span.is_dummy() {\n                     continue;\n                 }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n+                if always_backtrace {\n+                    new_labels.push((trace.def_site_span,\n+                                        format!(\"in this expansion of `{}`{}\",\n+                                                trace.macro_decl_name,\n+                                                if backtrace_len > 2 {\n+                                                    // if backtrace_len == 1 it'll be pointed\n+                                                    // at by \"in this macro invocation\"\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n                 }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n+                // Check to make sure we're not in any <*macros>\n+                if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                    !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                    !trace.macro_decl_name.starts_with(\"#[\") ||\n+                    always_backtrace {\n+                    new_labels.push((trace.call_site,\n+                                        format!(\"in this macro invocation{}\",\n+                                                if backtrace_len > 2 && always_backtrace {\n+                                                    // only specify order when the macro\n+                                                    // backtrace is multiple levels deep\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n+                    if !always_backtrace {\n+                        break;\n                     }\n                 }\n             }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n+        }\n+        for (label_span, label_text) in new_labels {\n+            span.push_span_label(label_span, label_text);\n+        }\n+        for sp_label in span.span_labels() {\n+            if sp_label.span.is_dummy() {\n+                continue;\n             }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n+            if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                !always_backtrace\n+            {\n+                let v = sp_label.span.macro_backtrace();\n+                if let Some(use_site) = v.last() {\n+                    before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n                 }\n             }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n+        }\n+        // After we have them, make sure we replace these 'bad' def sites with their use sites\n+        let spans_updated = !before_after.is_empty();\n+        for (before, after) in before_after {\n+            span.replace(before, after);\n         }\n \n         spans_updated\n@@ -593,9 +592,9 @@ impl EmitterWriter {\n \n         let left = margin.left(source_string.len()); // Left trim\n         // Account for unicode characters of width !=0 that were removed.\n-        let left = source_string.chars().take(left).fold(0, |acc, ch| {\n-            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n-        });\n+        let left = source_string.chars().take(left)\n+            .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+            .sum();\n \n         self.draw_line(\n             buffer,\n@@ -623,18 +622,16 @@ impl EmitterWriter {\n         // 3 | |\n         // 4 | | }\n         //   | |_^ test\n-        if line.annotations.len() == 1 {\n-            if let Some(ref ann) = line.annotations.get(0) {\n-                if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n-                        let style = if ann.is_primary {\n-                            Style::UnderlinePrimary\n-                        } else {\n-                            Style::UnderlineSecondary\n-                        };\n-                        buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n-                        return vec![(depth, style)];\n-                    }\n+        if let [ann] = &line.annotations[..] {\n+            if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n+                if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n+                    let style = if ann.is_primary {\n+                        Style::UnderlinePrimary\n+                    } else {\n+                        Style::UnderlineSecondary\n+                    };\n+                    buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n+                    return vec![(depth, style)];\n                 }\n             }\n         }\n@@ -763,11 +760,7 @@ impl EmitterWriter {\n             annotations_position.push((p, annotation));\n             for (j, next) in annotations.iter().enumerate() {\n                 if j > i  {\n-                    let l = if let Some(ref label) = next.label {\n-                        label.len() + 2\n-                    } else {\n-                        0\n-                    };\n+                    let l = next.label.as_ref().map_or(0, |label| label.len() + 2);\n                     if (overlaps(next, annotation, l) // Do not allow two labels to be in the same\n                                                      // line if they overlap including padding, to\n                                                      // avoid situations like:\n@@ -797,9 +790,7 @@ impl EmitterWriter {\n                     }\n                 }\n             }\n-            if line_len < p {\n-                line_len = p;\n-            }\n+            line_len = max(line_len, p);\n         }\n \n         if line_len != 0 {\n@@ -941,17 +932,9 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, if annotation.end_col + 1 > left {\n-                    annotation.end_col + 1 - left\n-                } else {\n-                    0\n-                })\n+                (pos + 1, (annotation.end_col + 1).saturating_sub(left))\n             } else {\n-                (pos + 2, if annotation.start_col > left {\n-                    annotation.start_col - left\n-                } else {\n-                    0\n-                })\n+                (pos + 2, annotation.start_col.saturating_sub(left))\n             };\n             if let Some(ref label) = annotation.label {\n                 buffer.puts(line_offset + pos, code_offset + col, &label, style);\n@@ -966,9 +949,9 @@ impl EmitterWriter {\n         //   | |  |\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n-        annotations_position.sort_by(|a, b| {\n-            // Decreasing order. When `a` and `b` are the same length, prefer `Primary`.\n-            (a.1.len(), !a.1.is_primary).cmp(&(b.1.len(), !b.1.is_primary)).reverse()\n+        annotations_position.sort_by_key(|(_, ann)| {\n+            // Decreasing order. When annotations share the same length, prefer `Primary`.\n+            (Reverse(ann.len()), ann.is_primary)\n         });\n \n         // Write the underlines.\n@@ -991,11 +974,7 @@ impl EmitterWriter {\n             for p in annotation.start_col..annotation.end_col {\n                 buffer.putc(\n                     line_offset + 1,\n-                    if code_offset + p > left {\n-                        code_offset + p - left\n-                    } else {\n-                        0\n-                    },\n+                    (code_offset + p).saturating_sub(left),\n                     underline,\n                     style,\n                 );\n@@ -1018,40 +997,36 @@ impl EmitterWriter {\n     }\n \n     fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n+        let sm = match self.sm {\n+            Some(ref sm) => sm,\n+            None => return 0,\n+        };\n+\n         let mut max = 0;\n-        if let Some(ref sm) = self.sm {\n-            for primary_span in msp.primary_spans() {\n-                if !primary_span.is_dummy() {\n-                    let hi = sm.lookup_char_pos(primary_span.hi());\n-                    if hi.line > max {\n-                        max = hi.line;\n-                    }\n-                }\n+        for primary_span in msp.primary_spans() {\n+            if !primary_span.is_dummy() {\n+                let hi = sm.lookup_char_pos(primary_span.hi());\n+                max = (hi.line).max(max);\n             }\n-            if !self.short_message {\n-                for span_label in msp.span_labels() {\n-                    if !span_label.span.is_dummy() {\n-                        let hi = sm.lookup_char_pos(span_label.span.hi());\n-                        if hi.line > max {\n-                            max = hi.line;\n-                        }\n-                    }\n+        }\n+        if !self.short_message {\n+            for span_label in msp.span_labels() {\n+                if !span_label.span.is_dummy() {\n+                    let hi = sm.lookup_char_pos(span_label.span.hi());\n+                    max = (hi.line).max(max);\n                 }\n             }\n         }\n+\n         max\n     }\n \n     fn get_max_line_num(&mut self, span: &MultiSpan, children: &[SubDiagnostic]) -> usize {\n-\n         let primary = self.get_multispan_max_line_num(span);\n-        let mut max = primary;\n-\n-        for sub in children {\n-            let sub_result = self.get_multispan_max_line_num(&sub.span);\n-            max = std::cmp::max(sub_result, max);\n-        }\n-        max\n+        children.iter()\n+            .map(|sub| self.get_multispan_max_line_num(&sub.span))\n+            .max()\n+            .unwrap_or(primary)\n     }\n \n     /// Adds a left margin to every line but the first, given a padding length and the label being\n@@ -1081,14 +1056,12 @@ impl EmitterWriter {\n         //    `max_line_num_len`\n         let padding = \" \".repeat(padding + label.len() + 5);\n \n-        /// Returns `true` if `style`, or the override if present and the style is `NoStyle`.\n-        fn style_or_override(style: Style, override_style: Option<Style>) -> Style {\n-            if let Some(o) = override_style {\n-                if style == Style::NoStyle {\n-                    return o;\n-                }\n+        /// Returns `override` if it is present and `style` is `NoStyle` or `style` otherwise\n+        fn style_or_override(style: Style, override_: Option<Style>) -> Style {\n+            match (style, override_) {\n+                (Style::NoStyle, Some(override_)) => override_,\n+                _ => style,\n             }\n-            style\n         }\n \n         let mut line_number = 0;\n@@ -1324,13 +1297,12 @@ impl EmitterWriter {\n                 for line in &annotated_file.lines {\n                     max_line_len = max(max_line_len, annotated_file.file\n                         .get_line(line.line_index - 1)\n-                        .map(|s| s.len())\n-                        .unwrap_or(0));\n+                        .map_or(0, |s| s.len()));\n                     for ann in &line.annotations {\n                         span_right_margin = max(span_right_margin, ann.start_col);\n                         span_right_margin = max(span_right_margin, ann.end_col);\n                         // FIXME: account for labels not in the same line\n-                        let label_right = ann.label.as_ref().map(|l| l.len() + 1).unwrap_or(0);\n+                        let label_right = ann.label.as_ref().map_or(0, |l| l.len() + 1);\n                         label_right_margin = max(label_right_margin, ann.end_col + label_right);\n                     }\n                 }\n@@ -1459,122 +1431,125 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n-        if let Some(ref sm) = self.sm {\n-            let mut buffer = StyledBuffer::new();\n+        let sm = match self.sm {\n+            Some(ref sm) => sm,\n+            None => return Ok(())\n+        };\n \n-            // Render the suggestion message\n-            let level_str = level.to_string();\n-            if !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::Level(level.clone()));\n-                buffer.append(0, \": \", Style::HeaderMsg);\n+        let mut buffer = StyledBuffer::new();\n+\n+        // Render the suggestion message\n+        let level_str = level.to_string();\n+        if !level_str.is_empty() {\n+            buffer.append(0, &level_str, Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+        }\n+        self.msg_to_buffer(\n+            &mut buffer,\n+            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+            max_line_num_len,\n+            \"suggestion\",\n+            Some(Style::HeaderMsg),\n+        );\n+\n+        // Render the replacements for each suggestion\n+        let suggestions = suggestion.splice_lines(&**sm);\n+\n+        let mut row_num = 2;\n+        for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+            // Only show underline if the suggestion spans a single line and doesn't cover the\n+            // entirety of the code output. If you have multiple replacements in the same line\n+            // of code, show the underline.\n+            let show_underline = !(parts.len() == 1\n+                && parts[0].snippet.trim() == complete.trim())\n+                && complete.lines().count() == 1;\n+\n+            let lines = sm.span_to_lines(parts[0].span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n+            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+            let mut line_pos = 0;\n+            let mut lines = complete.lines();\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                // Print the span column to avoid confusion\n+                buffer.puts(row_num,\n+                            0,\n+                            &self.maybe_anonymized(line_start + line_pos),\n+                            Style::LineNumber);\n+                // print the suggestion\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                line_pos += 1;\n+                row_num += 1;\n             }\n-            self.msg_to_buffer(\n-                &mut buffer,\n-                &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                max_line_num_len,\n-                \"suggestion\",\n-                Some(Style::HeaderMsg),\n-            );\n-\n-            // Render the replacements for each suggestion\n-            let suggestions = suggestion.splice_lines(&**sm);\n-\n-            let mut row_num = 2;\n-            for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n-                // Only show underline if the suggestion spans a single line and doesn't cover the\n-                // entirety of the code output. If you have multiple replacements in the same line\n-                // of code, show the underline.\n-                let show_underline = !(parts.len() == 1\n-                    && parts[0].snippet.trim() == complete.trim())\n-                    && complete.lines().count() == 1;\n-\n-                let lines = sm.span_to_lines(parts[0].span).unwrap();\n-\n-                assert!(!lines.lines.is_empty());\n-\n-                let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n-                draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n-                let mut line_pos = 0;\n-                let mut lines = complete.lines();\n-                for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                    // Print the span column to avoid confusion\n-                    buffer.puts(row_num,\n-                                0,\n-                                &self.maybe_anonymized(line_start + line_pos),\n-                                Style::LineNumber);\n-                    // print the suggestion\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    buffer.append(row_num, line, Style::NoStyle);\n-                    line_pos += 1;\n-                    row_num += 1;\n-                }\n \n-                // This offset and the ones below need to be signed to account for replacement code\n-                // that is shorter than the original code.\n-                let mut offset: isize = 0;\n-                // Only show an underline in the suggestions if the suggestion is not the\n-                // entirety of the code being shown and the displayed code is not multiline.\n-                if show_underline {\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    for part in parts {\n-                        let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n-                        let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n-\n-                        // Do not underline the leading...\n-                        let start = part.snippet.len()\n-                            .saturating_sub(part.snippet.trim_start().len());\n-                        // ...or trailing spaces. Account for substitutions containing unicode\n-                        // characters.\n-                        let sub_len = part.snippet.trim().chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n-                        });\n-\n-                        let underline_start = (span_start_pos + start) as isize + offset;\n-                        let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n-                        for p in underline_start..underline_end {\n+            // This offset and the ones below need to be signed to account for replacement code\n+            // that is shorter than the original code.\n+            let mut offset: isize = 0;\n+            // Only show an underline in the suggestions if the suggestion is not the\n+            // entirety of the code being shown and the displayed code is not multiline.\n+            if show_underline {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                for part in parts {\n+                    let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n+                    let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n+\n+                    // Do not underline the leading...\n+                    let start = part.snippet.len()\n+                        .saturating_sub(part.snippet.trim_start().len());\n+                    // ...or trailing spaces. Account for substitutions containing unicode\n+                    // characters.\n+                    let sub_len: usize = part.snippet.trim().chars()\n+                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum();\n+\n+                    let underline_start = (span_start_pos + start) as isize + offset;\n+                    let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n+                    for p in underline_start..underline_end {\n+                        buffer.putc(row_num,\n+                                    max_line_num_len + 3 + p as usize,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n+                    }\n+                    // underline removals too\n+                    if underline_start == underline_end {\n+                        for p in underline_start-1..underline_start+1 {\n                             buffer.putc(row_num,\n                                         max_line_num_len + 3 + p as usize,\n-                                        '^',\n-                                        Style::UnderlinePrimary);\n+                                        '-',\n+                                        Style::UnderlineSecondary);\n                         }\n-                        // underline removals too\n-                        if underline_start == underline_end {\n-                            for p in underline_start-1..underline_start+1 {\n-                                buffer.putc(row_num,\n-                                            max_line_num_len + 3 + p as usize,\n-                                            '-',\n-                                            Style::UnderlineSecondary);\n-                            }\n-                        }\n-\n-                        // length of the code after substitution\n-                        let full_sub_len = part.snippet.chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1) as isize\n-                        });\n-\n-                        // length of the code to be substituted\n-                        let snippet_len = span_end_pos as isize - span_start_pos as isize;\n-                        // For multiple substitutions, use the position *after* the previous\n-                        // substitutions have happened.\n-                        offset += full_sub_len - snippet_len;\n                     }\n-                    row_num += 1;\n-                }\n \n-                // if we elided some lines, add an ellipsis\n-                if lines.next().is_some() {\n-                    buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n-                } else if !show_underline {\n-                    draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n-                    row_num += 1;\n+                    // length of the code after substitution\n+                    let full_sub_len = part.snippet.chars()\n+                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum::<usize>() as isize;\n+\n+                    // length of the code to be substituted\n+                    let snippet_len = span_end_pos as isize - span_start_pos as isize;\n+                    // For multiple substitutions, use the position *after* the previous\n+                    // substitutions have happened.\n+                    offset += full_sub_len - snippet_len;\n                 }\n+                row_num += 1;\n             }\n-            if suggestions.len() > MAX_SUGGESTIONS {\n-                let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n-                buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+\n+            // if we elided some lines, add an ellipsis\n+            if lines.next().is_some() {\n+                buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n+            } else if !show_underline {\n+                draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n+                row_num += 1;\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         }\n+        if suggestions.len() > MAX_SUGGESTIONS {\n+            let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+            buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+        }\n+        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n     }\n \n@@ -1732,42 +1707,35 @@ impl FileWithAnnotatedLines {\n                     hi.col_display += 1;\n                 }\n \n-                let ann_type = if lo.line != hi.line {\n+                if lo.line != hi.line {\n                     let ml = MultilineAnnotation {\n                         depth: 1,\n                         line_start: lo.line,\n                         line_end: hi.line,\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label.clone(),\n+                        label: span_label.label,\n                         overlaps_exactly: false,\n                     };\n-                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n-                    AnnotationType::Multiline(ml)\n+                    multiline_annotations.push((lo.file, ml));\n                 } else {\n-                    AnnotationType::Singleline\n-                };\n-                let ann = Annotation {\n-                    start_col: lo.col_display,\n-                    end_col: hi.col_display,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: ann_type,\n-                };\n-\n-                if !ann.is_multiline() {\n+                    let ann = Annotation {\n+                        start_col: lo.col_display,\n+                        end_col: hi.col_display,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label,\n+                        annotation_type: AnnotationType::Singleline,\n+                    };\n                     add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                }\n+                };\n             }\n         }\n \n         // Find overlapping multiline annotations, put them at different depths\n         multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n-        for item in multiline_annotations.clone() {\n-            let ann = item.1;\n-            for item in multiline_annotations.iter_mut() {\n-                let ref mut a = item.1;\n+        for (_, ann) in multiline_annotations.clone() {\n+            for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one\n                 // one level to the right.\n                 if !(ann.same_span(a)) &&\n@@ -1784,9 +1752,7 @@ impl FileWithAnnotatedLines {\n \n         let mut max_depth = 0;  // max overlapping multiline spans\n         for (file, ann) in multiline_annotations {\n-            if ann.depth > max_depth {\n-                max_depth = ann.depth;\n-            }\n+            max_depth = max(max_depth, ann.depth);\n             let mut end_ann = ann.as_end();\n             if !ann.overlaps_exactly {\n                 // avoid output like"}, {"sha": "9874c0673cfc9cec7947b3b523728a10a7682b38", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -247,7 +247,7 @@ pub fn register_plugins<'a>(\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n-        time(sess, \"garbage collect incremental cache directory\", || {\n+        time(sess, \"garbage-collect incremental cache directory\", || {\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n                 warn!(\n                     \"Error while trying to garbage collect incremental \\\n@@ -318,7 +318,7 @@ fn configure_and_expand_inner<'a>(\n     crate_loader: &'a mut CrateLoader<'a>,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n-    time(sess, \"pre ast expansion lint checks\", || {\n+    time(sess, \"pre-AST-expansion lint checks\", || {\n         lint::check_ast_crate(\n             sess,\n             &krate,\n@@ -536,8 +536,8 @@ pub fn lower_to_hir(\n     dep_graph: &DepGraph,\n     krate: &ast::Crate,\n ) -> Result<hir::map::Forest> {\n-    // Lower ast -> hir\n-    let hir_forest = time(sess, \"lowering ast -> hir\", || {\n+    // Lower AST to HIR.\n+    let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n         let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver);\n \n         if sess.opts.debugging_opts.hir_stats {\n@@ -757,7 +757,7 @@ pub fn prepare_outputs(\n     if !only_dep_info {\n         if let Some(ref dir) = compiler.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n-                sess.err(\"failed to find or create the directory specified by --out-dir\");\n+                sess.err(\"failed to find or create the directory specified by `--out-dir`\");\n                 return Err(ErrorReported);\n             }\n         }\n@@ -830,8 +830,8 @@ pub fn create_global_ctxt(\n         let global_ctxt: Option<GlobalCtxt<'_>>;\n         let arenas = AllArenas::new();\n \n-        // Construct the HIR map\n-        let hir_map = time(sess, \"indexing hir\", || {\n+        // Construct the HIR map.\n+        let hir_map = time(sess, \"indexing HIR\", || {\n             hir::map::map_crate(sess, cstore, &mut hir_forest, &defs)\n         });\n \n@@ -942,7 +942,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });\n \n-    time(sess, \"dumping chalk-like clauses\", || {\n+    time(sess, \"dumping Chalk-like clauses\", || {\n         rustc_traits::lowering::dump_program_clauses(tcx);\n     });\n "}, {"sha": "0540c95d3ded382b1192e67965f3d2ef56ea524c", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,4 +1,3 @@\n-#![feature(proc_macro_hygiene)]\n #![allow(rustc::default_hash_types)]\n \n #![recursion_limit=\"128\"]"}, {"sha": "b8e2700803a5d4a16ad6dcf25db94a604a4b6317", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -952,8 +952,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         tcx.sess.span_warn(\n                             span,\n                             \"default bound relaxed for a type parameter, but \\\n-                            this does nothing because the given bound is not \\\n-                            a default. Only `?Sized` is supported\",\n+                             this does nothing because the given bound is not \\\n+                             a default; only `?Sized` is supported\",\n                         );\n                     }\n                 }"}, {"sha": "4608eb51df74e1fa192f9718647e11d3601bf1ce", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -14,7 +14,7 @@ use crate::util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    types: FxHashMap<Ty<'tcx>, usize>,\n+    types: FxHashMap<ty::GeneratorInteriorTypeCause<'tcx>, usize>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n@@ -83,7 +83,12 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             } else {\n                 // Map the type to the number of types added before it\n                 let entries = self.types.len();\n-                self.types.entry(&ty).or_insert(entries);\n+                let scope_span = scope.map(|s| s.span(self.fcx.tcx, self.region_scope_tree));\n+                self.types.entry(ty::GeneratorInteriorTypeCause {\n+                    span: source_span,\n+                    ty: &ty,\n+                    scope_span\n+                }).or_insert(entries);\n             }\n         } else {\n             debug!(\"no type in expr = {:?}, count = {:?}, span = {:?}\",\n@@ -118,8 +123,12 @@ pub fn resolve_interior<'a, 'tcx>(\n     // Sort types by insertion order\n     types.sort_by_key(|t| t.1);\n \n+    // Store the generator types and spans into the tables for this generator.\n+    let interior_types = types.iter().cloned().map(|t| t.0).collect::<Vec<_>>();\n+    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = interior_types;\n+\n     // Extract type components\n-    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| t.0));\n+    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| (t.0).ty));\n \n     // The types in the generator interior contain lifetimes local to the generator itself,\n     // which should not be exposed outside of the generator. Therefore, we replace these"}, {"sha": "2b34c24b266d0d29d4e927dcc50c0b28f667c8c1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -631,26 +631,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_valid_traits(&self,\n-                            err: &mut DiagnosticBuilder<'_>,\n-                            valid_out_of_scope_traits: Vec<DefId>) -> bool {\n+    fn suggest_valid_traits(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        valid_out_of_scope_traits: Vec<DefId>,\n+    ) -> bool {\n         if !valid_out_of_scope_traits.is_empty() {\n             let mut candidates = valid_out_of_scope_traits;\n             candidates.sort();\n             candidates.dedup();\n             err.help(\"items from traits can only be used if the trait is in scope\");\n-            let msg = format!(\"the following {traits_are} implemented but not in scope, \\\n-                               perhaps add a `use` for {one_of_them}:\",\n-                            traits_are = if candidates.len() == 1 {\n-                                \"trait is\"\n-                            } else {\n-                                \"traits are\"\n-                            },\n-                            one_of_them = if candidates.len() == 1 {\n-                                \"it\"\n-                            } else {\n-                                \"one of them\"\n-                            });\n+            let msg = format!(\n+                \"the following {traits_are} implemented but not in scope; \\\n+                 perhaps add a `use` for {one_of_them}:\",\n+                traits_are = if candidates.len() == 1 {\n+                    \"trait is\"\n+                } else {\n+                    \"traits are\"\n+                },\n+                one_of_them = if candidates.len() == 1 {\n+                    \"it\"\n+                } else {\n+                    \"one of them\"\n+                },\n+            );\n \n             self.suggest_use_candidates(err, msg, candidates);\n             true"}, {"sha": "be5723959fb222de44e19040e944ed6666521bb1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -2364,7 +2364,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // which diverges, that we are about to lint on. This gives suboptimal diagnostics.\n             // Instead, stop here so that the `if`- or `while`-expression's block is linted instead.\n             if !span.is_desugaring(DesugaringKind::CondTemporary) &&\n-                !span.is_desugaring(DesugaringKind::Async)\n+                !span.is_desugaring(DesugaringKind::Async) &&\n+                !orig_span.is_desugaring(DesugaringKind::Await)\n             {\n                 self.diverges.set(Diverges::WarnedAlways);\n "}, {"sha": "99d62d198a9fd66b5815ff7f972897bb5f8b76fd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -58,6 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n+        wbcx.visit_generator_interior_types();\n \n         let used_trait_imports = mem::replace(\n             &mut self.tables.borrow_mut().used_trait_imports,\n@@ -430,6 +431,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_generator_interior_types(&mut self) {\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        self.tables.generator_interior_types = fcx_tables.generator_interior_types.clone();\n+    }\n+\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();"}, {"sha": "c65f71fb1a4e2fc9a2899a5ebe8a73678e8d8268", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -26,6 +26,7 @@ pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T:\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"gen_future\")]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n \n // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "023952042e6d478ce13b0d3d3e1d629144a9a0b1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -2139,18 +2139,29 @@ impl rustc_serialize::Decodable for AttrId {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct AttrItem {\n+    pub path: Path,\n+    pub tokens: TokenStream,\n+}\n+\n /// Metadata associated with an item.\n /// Doc-comments are promoted to attributes that have `is_sugared_doc = true`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Attribute {\n+    pub item: AttrItem,\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub path: Path,\n-    pub tokens: TokenStream,\n     pub is_sugared_doc: bool,\n     pub span: Span,\n }\n \n+// Compatibility impl to avoid churn, consider removing.\n+impl std::ops::Deref for Attribute {\n+    type Target = AttrItem;\n+    fn deref(&self) -> &Self::Target { &self.item }\n+}\n+\n /// `TraitRef`s appear in impls.\n ///\n /// Resolution maps each `TraitRef`'s `ref_id` to its defining trait; that's all"}, {"sha": "7bef693a5be4cce1bb3fcf4d202add442587d515", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -9,7 +9,7 @@ pub use StabilityLevel::*;\n pub use crate::ast::Attribute;\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{AttrItem, AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n@@ -255,9 +255,8 @@ impl MetaItem {\n     }\n }\n \n-impl Attribute {\n-    /// Extracts the `MetaItem` from inside this `Attribute`.\n-    pub fn meta(&self) -> Option<MetaItem> {\n+impl AttrItem {\n+    crate fn meta(&self, span: Span) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n             path: self.path.clone(),\n@@ -269,9 +268,16 @@ impl Attribute {\n             } else {\n                 return None;\n             },\n-            span: self.span,\n+            span,\n         })\n     }\n+}\n+\n+impl Attribute {\n+    /// Extracts the MetaItem from inside this Attribute.\n+    pub fn meta(&self) -> Option<MetaItem> {\n+        self.item.meta(self.span)\n+    }\n \n     pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n@@ -333,10 +339,9 @@ impl Attribute {\n                 DUMMY_SP,\n             );\n             f(&Attribute {\n+                item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n                 id: self.id,\n                 style: self.style,\n-                path: meta.path,\n-                tokens: meta.kind.tokens(meta.span),\n                 is_sugared_doc: true,\n                 span: self.span,\n             })\n@@ -384,10 +389,9 @@ crate fn mk_attr_id() -> AttrId {\n \n pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) -> Attribute {\n     Attribute {\n+        item: AttrItem { path, tokens },\n         id: mk_attr_id(),\n         style,\n-        path,\n-        tokens,\n         is_sugared_doc: false,\n         span,\n     }\n@@ -408,10 +412,12 @@ pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n     let lit_kind = LitKind::Str(text, ast::StrStyle::Cooked);\n     let lit = Lit::from_lit_kind(lit_kind, span);\n     Attribute {\n+        item: AttrItem {\n+            path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n+            tokens: MetaItemKind::NameValue(lit).tokens(span),\n+        },\n         id: mk_attr_id(),\n         style,\n-        path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n-        tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n     }\n@@ -524,7 +530,7 @@ impl MetaItem {\n             }\n             Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n                 token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n-                token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n+                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,\n             },"}, {"sha": "2923cc86ba029a16c9b3cb8d6347bbd545e12b34", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -122,8 +122,8 @@ impl<'a> StripUnconfigured<'a> {\n \n             while !parser.check(&token::CloseDelim(token::Paren)) {\n                 let lo = parser.token.span.lo();\n-                let (path, tokens) = parser.parse_meta_item_unrestricted()?;\n-                expanded_attrs.push((path, tokens, parser.prev_span.with_lo(lo)));\n+                let item = parser.parse_attr_item()?;\n+                expanded_attrs.push((item, parser.prev_span.with_lo(lo)));\n                 parser.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Paren)])?;\n             }\n \n@@ -150,11 +150,10 @@ impl<'a> StripUnconfigured<'a> {\n             // `cfg_attr` inside of another `cfg_attr`. E.g.\n             //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n             expanded_attrs.into_iter()\n-            .flat_map(|(path, tokens, span)| self.process_cfg_attr(ast::Attribute {\n+            .flat_map(|(item, span)| self.process_cfg_attr(ast::Attribute {\n+                item,\n                 id: attr::mk_attr_id(),\n                 style: attr.style,\n-                path,\n-                tokens,\n                 is_sugared_doc: false,\n                 span,\n             }))"}, {"sha": "bbd8da2acef0526121c251e1fe48ff18301e21e9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n+use crate::ast::{self, AttrItem, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n use crate::source_map::respan;\n@@ -555,15 +555,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n-        let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n-        if fragment_kind == AstFragmentKind::ForeignItems && !self.cx.ecfg.macros_in_extern() {\n-            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext {} else {\n-                emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n-                                 span, GateIssue::Language,\n-                                 \"macro invocations in `extern {}` blocks are experimental\");\n-            }\n-        }\n-\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             let expn_data = self.cx.current_expansion.id.expn_data();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n@@ -578,6 +569,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             FatalError.raise();\n         }\n \n+        let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n         match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n@@ -625,9 +617,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         | Annotatable::Variant(..)\n                             => panic!(\"unexpected annotatable\"),\n                     })), DUMMY_SP).into();\n-                    let input = self.extract_proc_macro_attr_input(attr.tokens, span);\n+                    let input = self.extract_proc_macro_attr_input(attr.item.tokens, span);\n                     let tok_result = expander.expand(self.cx, span, input, item_tok);\n-                    let res = self.parse_ast_fragment(tok_result, fragment_kind, &attr.path, span);\n+                    let res =\n+                        self.parse_ast_fragment(tok_result, fragment_kind, &attr.item.path, span);\n                     self.gate_proc_macro_expansion(span, &res);\n                     res\n                 }\n@@ -757,14 +750,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n-            AstFragmentKind::Expr => \"expressions\",\n+            AstFragmentKind::Expr |\n             AstFragmentKind::OptExpr => \"expressions\",\n             AstFragmentKind::Pat => \"patterns\",\n-            AstFragmentKind::Ty => \"types\",\n             AstFragmentKind::Stmts => \"statements\",\n-            AstFragmentKind::Items => return,\n-            AstFragmentKind::TraitItems => return,\n-            AstFragmentKind::ImplItems => return,\n+            AstFragmentKind::Ty |\n+            AstFragmentKind::Items |\n+            AstFragmentKind::TraitItems |\n+            AstFragmentKind::ImplItems |\n             AstFragmentKind::ForeignItems => return,\n             AstFragmentKind::Arms\n             | AstFragmentKind::Fields\n@@ -1530,11 +1523,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n             let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n+                item: AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n                 span: at.span,\n                 id: at.id,\n                 style: at.style,\n-                path: meta.path,\n-                tokens: meta.kind.tokens(meta.span),\n                 is_sugared_doc: false,\n             };\n         } else {\n@@ -1578,9 +1570,6 @@ impl<'feat> ExpansionConfig<'feat> {\n         }\n     }\n \n-    fn macros_in_extern(&self) -> bool {\n-        self.features.map_or(false, |features| features.macros_in_extern)\n-    }\n     fn proc_macro_hygiene(&self) -> bool {\n         self.features.map_or(false, |features| features.proc_macro_hygiene)\n     }"}, {"sha": "d1c50fd85945de745e2db8b5038f68030b633bae", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -924,7 +924,7 @@ fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n             FatalError.raise()\n         }\n         sym::path => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n-        sym::meta => token::NtMeta(panictry!(p.parse_meta_item())),\n+        sym::meta => token::NtMeta(panictry!(p.parse_attr_item())),\n         sym::vis => token::NtVis(panictry!(p.parse_visibility(true))),\n         sym::lifetime => if p.check_lifetime() {\n             token::NtLifetime(p.expect_lifetime().ident)"}, {"sha": "cda1ef1436ca1c8ae2161218753c2176339f319f", "filename": "src/libsyntax/feature_gate/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -245,6 +245,8 @@ declare_features! (\n     (accepted, bind_by_move_pattern_guards, \"1.39.0\", Some(15287), None),\n     /// Allows attributes in formal function parameters.\n     (accepted, param_attrs, \"1.39.0\", Some(60406), None),\n+    // Allows macro invocations in `extern {}` blocks.\n+    (accepted, macros_in_extern, \"1.40.0\", Some(49476), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "47ee41f0adc1690b0d0de4e1437ba1906b61c1a1", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -402,9 +402,6 @@ declare_features! (\n     /// Allows infering `'static` outlives requirements (RFC 2093).\n     (active, infer_static_outlives_requirements, \"1.26.0\", Some(54185), None),\n \n-    /// Allows macro invocations in `extern {}` blocks.\n-    (active, macros_in_extern, \"1.27.0\", Some(49476), None),\n-\n     /// Allows accessing fields of unions inside `const` functions.\n     (active, const_fn_union, \"1.27.0\", Some(51909), None),\n "}, {"sha": "3923b9f297b9ffaf897feb6b3b547529853a56b8", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -550,7 +550,8 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { id: _, style: _, path, tokens, is_sugared_doc: _, span } = attr;\n+    let Attribute { item: AttrItem { path, tokens }, id: _, style: _, is_sugared_doc: _, span }\n+        = attr;\n     vis.visit_path(path);\n     vis.visit_tts(tokens);\n     vis.visit_span(span);\n@@ -681,7 +682,10 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         token::NtIdent(ident, _is_raw) => vis.visit_ident(ident),\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n-        token::NtMeta(meta) => vis.visit_meta_item(meta),\n+        token::NtMeta(AttrItem { path, tokens }) => {\n+            vis.visit_path(path);\n+            vis.visit_tts(tokens);\n+        }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => vis.visit_tt(tt),\n         token::NtImplItem(item) =>"}, {"sha": "e74f3045db80477b249c925c59f4cd033d8fe7de", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -90,7 +90,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,\n                self.token);\n-        let (span, path, tokens, style) = match self.token.kind {\n+        let (span, item, style) = match self.token.kind {\n             token::Pound => {\n                 let lo = self.token.span;\n                 self.bump();\n@@ -107,7 +107,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 self.expect(&token::OpenDelim(token::Bracket))?;\n-                let (path, tokens) = self.parse_meta_item_unrestricted()?;\n+                let item = self.parse_attr_item()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let hi = self.prev_span;\n \n@@ -142,7 +142,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                (attr_sp, path, tokens, style)\n+                (attr_sp, item, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n@@ -151,10 +151,9 @@ impl<'a> Parser<'a> {\n         };\n \n         Ok(ast::Attribute {\n+            item,\n             id: attr::mk_attr_id(),\n             style,\n-            path,\n-            tokens,\n             is_sugared_doc: false,\n             span,\n         })\n@@ -167,19 +166,19 @@ impl<'a> Parser<'a> {\n     ///     PATH `[` TOKEN_STREAM `]`\n     ///     PATH `{` TOKEN_STREAM `}`\n     ///     PATH\n-    ///     PATH `=` TOKEN_TREE\n+    ///     PATH `=` UNSUFFIXED_LIT\n     /// The delimiters or `=` are still put into the resulting token stream.\n-    pub fn parse_meta_item_unrestricted(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n-        let meta = match self.token.kind {\n+    pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n+        let item = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n-                Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n+                Nonterminal::NtMeta(ref item) => Some(item.clone()),\n                 _ => None,\n             },\n             _ => None,\n         };\n-        Ok(if let Some(meta) = meta {\n+        Ok(if let Some(item) = item {\n             self.bump();\n-            (meta.path, meta.kind.tokens(meta.span))\n+            item\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n             let tokens = if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n@@ -206,7 +205,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 TokenStream::empty()\n             };\n-            (path, tokens)\n+            ast::AttrItem { path, tokens }\n         })\n     }\n \n@@ -263,7 +262,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches the following grammar (per RFC 1559).\n     ///\n-    ///     meta_item : IDENT ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n+    ///     meta_item : PATH ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n     ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n@@ -274,9 +273,14 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        if let Some(meta) = nt_meta {\n-            self.bump();\n-            return Ok(meta);\n+        if let Some(item) = nt_meta {\n+            return match item.meta(item.path.span) {\n+                Some(meta) => {\n+                    self.bump();\n+                    Ok(meta)\n+                }\n+                None => self.unexpected(),\n+            }\n         }\n \n         let lo = self.token.span;"}, {"sha": "ac3feadce3ae60f06e971ff5c8b13ddefddb6079", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -47,7 +47,7 @@ impl<'a> StringReader<'a> {\n                source_file: Lrc<syntax_pos::SourceFile>,\n                override_span: Option<Span>) -> Self {\n         if source_file.src.is_none() {\n-            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n+            sess.span_diagnostic.bug(&format!(\"cannot lex `source_file` without source: {}\",\n                                               source_file.name));\n         }\n "}, {"sha": "7eb2a73a11a82c28664129ec9e465ef1a5cb13ee", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 79, "deletions": 26, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -18,6 +18,8 @@ type Expected = Option<&'static str>;\n /// `Expected` for function and lambda parameter patterns.\n pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n \n+const WHILE_PARSING_OR_MSG: &str = \"while parsing this or-pattern starting here\";\n+\n /// Whether or not an or-pattern should be gated when occurring in the current context.\n #[derive(PartialEq)]\n pub enum GateOr { Yes, No }\n@@ -40,7 +42,7 @@ impl<'a> Parser<'a> {\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n     pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n-        let gated_leading_vert = self.eat_or_separator() && gate_or == GateOr::Yes;\n+        let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n         let leading_vert_span = self.prev_span;\n \n         // Parse the possibly-or-pattern.\n@@ -63,7 +65,7 @@ impl<'a> Parser<'a> {\n     /// Parse the pattern for a function or function pointer parameter.\n     /// Special recovery is provided for or-patterns and leading `|`.\n     pub(super) fn parse_fn_param_pat(&mut self) -> PResult<'a, P<Pat>> {\n-        self.recover_leading_vert(\"not allowed in a parameter pattern\");\n+        self.recover_leading_vert(None, \"not allowed in a parameter pattern\");\n         let pat = self.parse_pat_with_or(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n \n         if let PatKind::Or(..) = &pat.kind {\n@@ -90,7 +92,7 @@ impl<'a> Parser<'a> {\n         gate_or: GateOr,\n         rc: RecoverComma,\n     ) -> PResult<'a, P<Pat>> {\n-        // Parse the first pattern.\n+        // Parse the first pattern (`p_0`).\n         let first_pat = self.parse_pat(expected)?;\n         self.maybe_recover_unexpected_comma(first_pat.span, rc)?;\n \n@@ -100,11 +102,12 @@ impl<'a> Parser<'a> {\n             return Ok(first_pat)\n         }\n \n+        // Parse the patterns `p_1 | ... | p_n` where `n > 0`.\n         let lo = first_pat.span;\n         let mut pats = vec![first_pat];\n-        while self.eat_or_separator() {\n+        while self.eat_or_separator(Some(lo)) {\n             let pat = self.parse_pat(expected).map_err(|mut err| {\n-                err.span_label(lo, \"while parsing this or-pattern starting here\");\n+                err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n             })?;\n             self.maybe_recover_unexpected_comma(pat.span, rc)?;\n@@ -122,28 +125,65 @@ impl<'a> Parser<'a> {\n \n     /// Eat the or-pattern `|` separator.\n     /// If instead a `||` token is encountered, recover and pretend we parsed `|`.\n-    fn eat_or_separator(&mut self) -> bool {\n+    fn eat_or_separator(&mut self, lo: Option<Span>) -> bool {\n+        if self.recover_trailing_vert(lo) {\n+            return false;\n+        }\n+\n         match self.token.kind {\n             token::OrOr => {\n                 // Found `||`; Recover and pretend we parsed `|`.\n-                self.ban_unexpected_or_or();\n+                self.ban_unexpected_or_or(lo);\n                 self.bump();\n                 true\n             }\n             _ => self.eat(&token::BinOp(token::Or)),\n         }\n     }\n \n+    /// Recover if `|` or `||` is the current token and we have one of the\n+    /// tokens `=>`, `if`, `=`, `:`, `;`, `,`, `]`, `)`, or `}` ahead of us.\n+    ///\n+    /// These tokens all indicate that we reached the end of the or-pattern\n+    /// list and can now reliably say that the `|` was an illegal trailing vert.\n+    /// Note that there are more tokens such as `@` for which we know that the `|`\n+    /// is an illegal parse. However, the user's intent is less clear in that case.\n+    fn recover_trailing_vert(&mut self, lo: Option<Span>) -> bool {\n+        let is_end_ahead = self.look_ahead(1, |token| match &token.kind {\n+            token::FatArrow // e.g. `a | => 0,`.\n+            | token::Ident(kw::If, false) // e.g. `a | if expr`.\n+            | token::Eq // e.g. `let a | = 0`.\n+            | token::Semi // e.g. `let a |;`.\n+            | token::Colon // e.g. `let a | :`.\n+            | token::Comma // e.g. `let (a |,)`.\n+            | token::CloseDelim(token::Bracket) // e.g. `let [a | ]`.\n+            | token::CloseDelim(token::Paren) // e.g. `let (a | )`.\n+            | token::CloseDelim(token::Brace) => true, // e.g. `let A { f: a | }`.\n+            _ => false,\n+        });\n+        match (is_end_ahead, &self.token.kind) {\n+            (true, token::BinOp(token::Or)) | (true, token::OrOr) => {\n+                self.ban_illegal_vert(lo, \"trailing\", \"not allowed in an or-pattern\");\n+                self.bump();\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     /// We have parsed `||` instead of `|`. Error and suggest `|` instead.\n-    fn ban_unexpected_or_or(&mut self) {\n-        self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n-            .span_suggestion(\n-                self.token.span,\n-                \"use a single `|` to separate multiple alternative patterns\",\n-                \"|\".to_owned(),\n-                Applicability::MachineApplicable\n-            )\n-            .emit();\n+    fn ban_unexpected_or_or(&mut self, lo: Option<Span>) {\n+        let mut err = self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\");\n+        err.span_suggestion(\n+            self.token.span,\n+            \"use a single `|` to separate multiple alternative patterns\",\n+            \"|\".to_owned(),\n+            Applicability::MachineApplicable\n+        );\n+        if let Some(lo) = lo {\n+            err.span_label(lo, WHILE_PARSING_OR_MSG);\n+        }\n+        err.emit();\n     }\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n@@ -198,25 +238,38 @@ impl<'a> Parser<'a> {\n     /// Recursive possibly-or-pattern parser with recovery for an erroneous leading `|`.\n     /// See `parse_pat_with_or` for details on parsing or-patterns.\n     fn parse_pat_with_or_inner(&mut self) -> PResult<'a, P<Pat>> {\n-        self.recover_leading_vert(\"only allowed in a top-level pattern\");\n+        self.recover_leading_vert(None, \"only allowed in a top-level pattern\");\n         self.parse_pat_with_or(None, GateOr::Yes, RecoverComma::No)\n     }\n \n     /// Recover if `|` or `||` is here.\n     /// The user is thinking that a leading `|` is allowed in this position.\n-    fn recover_leading_vert(&mut self, ctx: &str) {\n+    fn recover_leading_vert(&mut self, lo: Option<Span>, ctx: &str) {\n         if let token::BinOp(token::Or) | token::OrOr = self.token.kind {\n-            let span = self.token.span;\n-            let rm_msg = format!(\"remove the `{}`\", pprust::token_to_string(&self.token));\n-\n-            self.struct_span_err(span, &format!(\"a leading `|` is {}\", ctx))\n-                .span_suggestion(span, &rm_msg, String::new(), Applicability::MachineApplicable)\n-                .emit();\n-\n+            self.ban_illegal_vert(lo, \"leading\", ctx);\n             self.bump();\n         }\n     }\n \n+    /// A `|` or possibly `||` token shouldn't be here. Ban it.\n+    fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n+        let span = self.token.span;\n+        let mut err = self.struct_span_err(span, &format!(\"a {} `|` is {}\", pos, ctx));\n+        err.span_suggestion(\n+            span,\n+            &format!(\"remove the `{}`\", pprust::token_to_string(&self.token)),\n+            String::new(),\n+            Applicability::MachineApplicable,\n+        );\n+        if let Some(lo) = lo {\n+            err.span_label(lo, WHILE_PARSING_OR_MSG);\n+        }\n+        if let token::OrOr = self.token.kind {\n+            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n+        }\n+        err.emit();\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -259,7 +312,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n             }\n-            // At this point, token != &, &&, (, [\n+            // At this point, token != `&`, `&&`, `(`, `[`, `..`, `..=`, or `...`.\n             _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n                 PatKind::Wild"}, {"sha": "ca823991a2e5f25d6b4291b7d857e10e6dfa0c5c", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -114,9 +114,9 @@ impl<'a> Parser<'a> {\n     pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         let meta_ident = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref meta) => match meta.kind {\n-                    ast::MetaItemKind::Word => Some(meta.path.clone()),\n-                    _ => None,\n+                token::NtMeta(ref item) => match item.tokens.is_empty() {\n+                    true => Some(item.path.clone()),\n+                    false => None,\n                 },\n                 _ => None,\n             },"}, {"sha": "fd78a2bd53442dfe6fa3192191994db394cfb149", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -687,7 +687,7 @@ pub enum Nonterminal {\n     NtLifetime(ast::Ident),\n     NtLiteral(P<ast::Expr>),\n     /// Stuff inside brackets for attributes\n-    NtMeta(ast::MetaItem),\n+    NtMeta(ast::AttrItem),\n     NtPath(ast::Path),\n     NtVis(ast::Visibility),\n     NtTT(TokenTree),"}, {"sha": "7d4ffe493d709460cf3363e3d43ab19e6925f470", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -324,7 +324,7 @@ fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n     match *nt {\n         token::NtExpr(ref e)        => expr_to_string(e),\n-        token::NtMeta(ref e)        => meta_item_to_string(e),\n+        token::NtMeta(ref e)        => attr_item_to_string(e),\n         token::NtTy(ref e)          => ty_to_string(e),\n         token::NtPath(ref e)        => path_to_string(e),\n         token::NtItem(ref e)        => item_to_string(e),\n@@ -412,8 +412,8 @@ pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n     to_string(|s| s.print_meta_list_item(li))\n }\n \n-pub fn meta_item_to_string(mi: &ast::MetaItem) -> String {\n-    to_string(|s| s.print_meta_item(mi))\n+fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n+    to_string(|s| s.print_attr_item(ai, ai.path.span))\n }\n \n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n@@ -629,24 +629,28 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 ast::AttrStyle::Inner => self.word(\"#![\"),\n                 ast::AttrStyle::Outer => self.word(\"#[\"),\n             }\n-            self.ibox(0);\n-            match attr.tokens.trees().next() {\n-                Some(TokenTree::Delimited(_, delim, tts)) => {\n-                    self.print_mac_common(\n-                        Some(MacHeader::Path(&attr.path)), false, None, delim, tts, true, attr.span\n-                    );\n-                }\n-                tree => {\n-                    self.print_path(&attr.path, false, 0);\n-                    if tree.is_some() {\n-                        self.space();\n-                        self.print_tts(attr.tokens.clone(), true);\n-                    }\n+            self.print_attr_item(&attr.item, attr.span);\n+            self.word(\"]\");\n+        }\n+    }\n+\n+    fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n+        self.ibox(0);\n+        match item.tokens.trees().next() {\n+            Some(TokenTree::Delimited(_, delim, tts)) => {\n+                self.print_mac_common(\n+                    Some(MacHeader::Path(&item.path)), false, None, delim, tts, true, span\n+                );\n+            }\n+            tree => {\n+                self.print_path(&item.path, false, 0);\n+                if tree.is_some() {\n+                    self.space();\n+                    self.print_tts(item.tokens.clone(), true);\n                 }\n             }\n-            self.end();\n-            self.word(\"]\");\n         }\n+        self.end();\n     }\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {"}, {"sha": "203c4a834899b96aaa0c0c265f2a2689c9aa1fc1", "filename": "src/libsyntax_ext/cmdline_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcmdline_attrs.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,6 +1,6 @@\n //! Attributes injected into the crate root from command line using `-Z crate-attr`.\n \n-use syntax::ast::{self, AttrStyle};\n+use syntax::ast::{self, AttrItem, AttrStyle};\n use syntax::attr::mk_attr;\n use syntax::panictry;\n use syntax::parse::{self, token, ParseSess};\n@@ -15,7 +15,7 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let (path, tokens) = panictry!(parser.parse_meta_item_unrestricted());\n+        let AttrItem { path, tokens } = panictry!(parser.parse_attr_item());\n         let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic"}, {"sha": "6e83e1d3f8d4fc178c422b91ae42f461d4a5a905", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -884,7 +884,7 @@ pub struct OffsetOverflowError;\n /// A single source in the `SourceMap`.\n #[derive(Clone)]\n pub struct SourceFile {\n-    /// The name of the file that the source came from, source that doesn't\n+    /// The name of the file that the source came from. Source that doesn't\n     /// originate from files has names between angle brackets by convention\n     /// (e.g., `<anon>`).\n     pub name: FileName,\n@@ -922,9 +922,9 @@ impl Encodable for SourceFile {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 4, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 5, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 6, |s| {\n+            s.emit_struct_field(\"start_pos\", 3, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 4, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 5, |s| {\n                 let lines = &self.lines[..];\n                 // Store the length.\n                 s.emit_u32(lines.len() as u32)?;\n@@ -970,13 +970,13 @@ impl Encodable for SourceFile {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 7, |s| {\n+            s.emit_struct_field(\"multibyte_chars\", 6, |s| {\n                 self.multibyte_chars.encode(s)\n             })?;\n-            s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n+            s.emit_struct_field(\"non_narrow_chars\", 7, |s| {\n                 self.non_narrow_chars.encode(s)\n             })?;\n-            s.emit_struct_field(\"name_hash\", 9, |s| {\n+            s.emit_struct_field(\"name_hash\", 8, |s| {\n                 self.name_hash.encode(s)\n             })\n         })\n@@ -985,17 +985,16 @@ impl Encodable for SourceFile {\n \n impl Decodable for SourceFile {\n     fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n-\n         d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let src_hash: u128 =\n                 d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n             let start_pos: BytePos =\n-                d.read_struct_field(\"start_pos\", 4, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 5, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 6, |d| {\n+                d.read_struct_field(\"start_pos\", 3, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 4, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 5, |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -1024,18 +1023,18 @@ impl Decodable for SourceFile {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 7, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", 6, |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n-                d.read_struct_field(\"name_hash\", 9, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n                 unmapped_path: None,\n                 // `crate_of_origin` has to be set by the importer.\n-                // This value matches up with rustc::hir::def_id::INVALID_CRATE.\n-                // That constant is not available here unfortunately :(\n+                // This value matches up with `rustc::hir::def_id::INVALID_CRATE`.\n+                // That constant is not available here, unfortunately.\n                 crate_of_origin: std::u32::MAX - 1,\n                 start_pos,\n                 end_pos,"}, {"sha": "6ee33f4ab61f60c90c1db39b43d43d97a99fd569", "filename": "src/test/ui/abi/macros/macros-in-extern.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fmacros%2Fmacros-in-extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fmacros%2Fmacros-in-extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fmacros%2Fmacros-in-extern.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,30 +0,0 @@\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:26:5\n-   |\n-LL |     returns_isize!(rust_get_test_int);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:28:5\n-   |\n-LL |     takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:30:5\n-   |\n-LL |     emits_nothing!();\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "27efa44f980323a5948d336d6e88a788d3bf7959", "filename": "src/test/ui/abi/proc-macro/auxiliary/test-macros.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,112 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-// Proc macros commonly used by tests.\n-// `panic`/`print` -> `panic_bang`/`print_bang` to avoid conflicts with standard macros.\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::TokenStream;\n-\n-// Macro that return empty token stream.\n-\n-#[proc_macro]\n-pub fn empty(_: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}\n-\n-#[proc_macro_attribute]\n-pub fn empty_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}\n-\n-#[proc_macro_derive(Empty, attributes(empty_helper))]\n-pub fn empty_derive(_: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}\n-\n-// Macro that panics.\n-\n-#[proc_macro]\n-pub fn panic_bang(_: TokenStream) -> TokenStream {\n-    panic!(\"panic-bang\");\n-}\n-\n-#[proc_macro_attribute]\n-pub fn panic_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n-    panic!(\"panic-attr\");\n-}\n-\n-#[proc_macro_derive(Panic, attributes(panic_helper))]\n-pub fn panic_derive(_: TokenStream) -> TokenStream {\n-    panic!(\"panic-derive\");\n-}\n-\n-// Macros that return the input stream.\n-\n-#[proc_macro]\n-pub fn identity(input: TokenStream) -> TokenStream {\n-    input\n-}\n-\n-#[proc_macro_attribute]\n-pub fn identity_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input\n-}\n-\n-#[proc_macro_derive(Identity, attributes(identity_helper))]\n-pub fn identity_derive(input: TokenStream) -> TokenStream {\n-    input\n-}\n-\n-// Macros that iterate and re-collect the input stream.\n-\n-#[proc_macro]\n-pub fn recollect(input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}\n-\n-#[proc_macro_attribute]\n-pub fn recollect_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}\n-\n-#[proc_macro_derive(Recollect, attributes(recollect_helper))]\n-pub fn recollect_derive(input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}\n-\n-// Macros that print their input in the original and re-collected forms (if they differ).\n-\n-fn print_helper(input: TokenStream, kind: &str) -> TokenStream {\n-    let input_display = format!(\"{}\", input);\n-    let input_debug = format!(\"{:#?}\", input);\n-    let recollected = input.into_iter().collect();\n-    let recollected_display = format!(\"{}\", recollected);\n-    let recollected_debug = format!(\"{:#?}\", recollected);\n-    println!(\"PRINT-{} INPUT (DISPLAY): {}\", kind, input_display);\n-    if recollected_display != input_display {\n-        println!(\"PRINT-{} RE-COLLECTED (DISPLAY): {}\", kind, recollected_display);\n-    }\n-    println!(\"PRINT-{} INPUT (DEBUG): {}\", kind, input_debug);\n-    if recollected_debug != input_debug {\n-        println!(\"PRINT-{} RE-COLLECTED (DEBUG): {}\", kind, recollected_debug);\n-    }\n-    recollected\n-}\n-\n-#[proc_macro]\n-pub fn print_bang(input: TokenStream) -> TokenStream {\n-    print_helper(input, \"BANG\")\n-}\n-\n-#[proc_macro_attribute]\n-pub fn print_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    print_helper(input, \"ATTR\")\n-}\n-\n-#[proc_macro_derive(Print, attributes(print_helper))]\n-pub fn print_derive(input: TokenStream) -> TokenStream {\n-    print_helper(input, \"DERIVE\")\n-}"}, {"sha": "6049c2aa4482e425866b9ee60fc58137f3746fe3", "filename": "src/test/ui/abi/proc-macro/macros-in-extern.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fmacros-in-extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fmacros-in-extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fproc-macro%2Fmacros-in-extern.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,30 +0,0 @@\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:14:5\n-   |\n-LL |     #[empty_attr]\n-   |     ^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:18:5\n-   |\n-LL |     #[identity_attr]\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:22:5\n-   |\n-LL |     identity!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "898fe22fa234fc806b5aae7a73801bba9e56a62e", "filename": "src/test/ui/anonymous-higher-ranked-lifetime.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,26 +1,15 @@\n fn main() {\n     f1(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     f2(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     f3(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     f4(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     f5(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     g1(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     g2(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     g3(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     g4(|_: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     h1(|_: (), _: (), _: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n     h2(|_: (), _: (), _: (), _: ()| {}); //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n }\n \n // Basic"}, {"sha": "9be44c7f44807a8203b2affbe9c9ab1045e0afe2", "filename": "src/test/ui/anonymous-higher-ranked-lifetime.stderr", "status": "modified", "additions": 10, "deletions": 131, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -10,18 +10,7 @@ LL | fn f1<F>(_: F) where F: Fn(&(), &()) {}\n    |    --                   ------------ required by this bound in `f1`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:2:5\n-   |\n-LL |     f1(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), &()) -> _`\n-...\n-LL | fn f1<F>(_: F) where F: Fn(&(), &()) {}\n-   |    --                   ------------ required by this bound in `f1`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:4:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:3:5\n    |\n LL |     f2(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -34,17 +23,6 @@ LL | fn f2<F>(_: F) where F: for<'a> Fn(&'a (), &()) {}\n error[E0631]: type mismatch in closure arguments\n   --> $DIR/anonymous-higher-ranked-lifetime.rs:4:5\n    |\n-LL |     f2(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&'a (), &()) -> _`\n-...\n-LL | fn f2<F>(_: F) where F: for<'a> Fn(&'a (), &()) {}\n-   |    --                           --------------- required by this bound in `f2`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:6:5\n-   |\n LL |     f3(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n    |     |\n@@ -54,18 +32,7 @@ LL | fn f3<'a, F>(_: F) where F: Fn(&'a (), &()) {}\n    |    --                       --------------- required by this bound in `f3`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:6:5\n-   |\n-LL |     f3(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), &()) -> _`\n-...\n-LL | fn f3<'a, F>(_: F) where F: Fn(&'a (), &()) {}\n-   |    --                       --------------- required by this bound in `f3`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:8:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:5:5\n    |\n LL |     f4(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -76,18 +43,7 @@ LL | fn f4<F>(_: F) where F: for<'r> Fn(&(), &'r ()) {}\n    |    --                   ----------------------- required by this bound in `f4`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:8:5\n-   |\n-LL |     f4(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), &'r ()) -> _`\n-...\n-LL | fn f4<F>(_: F) where F: for<'r> Fn(&(), &'r ()) {}\n-   |    --                           --------------- required by this bound in `f4`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:10:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:6:5\n    |\n LL |     f5(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -98,18 +54,7 @@ LL | fn f5<F>(_: F) where F: for<'r> Fn(&'r (), &'r ()) {}\n    |    --                   -------------------------- required by this bound in `f5`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:10:5\n-   |\n-LL |     f5(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&'r (), &'r ()) -> _`\n-...\n-LL | fn f5<F>(_: F) where F: for<'r> Fn(&'r (), &'r ()) {}\n-   |    --                           ------------------ required by this bound in `f5`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:12:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:7:5\n    |\n LL |     g1(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -120,18 +65,7 @@ LL | fn g1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>) {}\n    |    --                   ------------------------- required by this bound in `g1`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:12:5\n-   |\n-LL |     g1(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r ()) + 'static)>) -> _`\n-...\n-LL | fn g1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>) {}\n-   |    --                   ------------------------- required by this bound in `g1`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:14:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:8:5\n    |\n LL |     g2(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -142,18 +76,7 @@ LL | fn g2<F>(_: F) where F: Fn(&(), fn(&())) {}\n    |    --                   ---------------- required by this bound in `g2`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:14:5\n-   |\n-LL |     g2(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), for<'r> fn(&'r ())) -> _`\n-...\n-LL | fn g2<F>(_: F) where F: Fn(&(), fn(&())) {}\n-   |    --                   ---------------- required by this bound in `g2`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:16:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:9:5\n    |\n LL |     g3(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -164,18 +87,7 @@ LL | fn g3<F>(_: F) where F: for<'s> Fn(&'s (), Box<dyn Fn(&())>) {}\n    |    --                   ------------------------------------ required by this bound in `g3`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:16:5\n-   |\n-LL |     g3(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&'s (), std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r ()) + 'static)>) -> _`\n-...\n-LL | fn g3<F>(_: F) where F: for<'s> Fn(&'s (), Box<dyn Fn(&())>) {}\n-   |    --                           ---------------------------- required by this bound in `g3`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:18:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:10:5\n    |\n LL |     g4(|_: (), _: ()| {});\n    |     ^^ -------------- found signature of `fn((), ()) -> _`\n@@ -186,18 +98,7 @@ LL | fn g4<F>(_: F) where F: Fn(&(), for<'r> fn(&'r ())) {}\n    |    --                   --------------------------- required by this bound in `g4`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:18:5\n-   |\n-LL |     g4(|_: (), _: ()| {});\n-   |     ^^ -------------- found signature of `fn((), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), for<'r> fn(&'r ())) -> _`\n-...\n-LL | fn g4<F>(_: F) where F: Fn(&(), for<'r> fn(&'r ())) {}\n-   |    --                   --------------------------- required by this bound in `g4`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:20:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:11:5\n    |\n LL |     h1(|_: (), _: (), _: (), _: ()| {});\n    |     ^^ ---------------------------- found signature of `fn((), (), (), ()) -> _`\n@@ -208,18 +109,7 @@ LL | fn h1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>, &(), fn(&(), &())) {}\n    |    --                   -------------------------------------------- required by this bound in `h1`\n \n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:20:5\n-   |\n-LL |     h1(|_: (), _: (), _: (), _: ()| {});\n-   |     ^^ ---------------------------- found signature of `fn((), (), (), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r ()) + 'static)>, &(), for<'r, 's> fn(&'r (), &'s ())) -> _`\n-...\n-LL | fn h1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>, &(), fn(&(), &())) {}\n-   |    --                   -------------------------------------------- required by this bound in `h1`\n-\n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:22:5\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:12:5\n    |\n LL |     h2(|_: (), _: (), _: (), _: ()| {});\n    |     ^^ ---------------------------- found signature of `fn((), (), (), ()) -> _`\n@@ -229,16 +119,5 @@ LL |     h2(|_: (), _: (), _: (), _: ()| {});\n LL | fn h2<F>(_: F) where F: for<'t0> Fn(&(), Box<dyn Fn(&())>, &'t0 (), fn(&(), &())) {}\n    |    --                   --------------------------------------------------------- required by this bound in `h2`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/anonymous-higher-ranked-lifetime.rs:22:5\n-   |\n-LL |     h2(|_: (), _: (), _: (), _: ()| {});\n-   |     ^^ ---------------------------- found signature of `fn((), (), (), ()) -> _`\n-   |     |\n-   |     expected signature of `fn(&(), std::boxed::Box<(dyn for<'r> std::ops::Fn(&'r ()) + 'static)>, &'t0 (), for<'r, 's> fn(&'r (), &'s ())) -> _`\n-...\n-LL | fn h2<F>(_: F) where F: for<'t0> Fn(&(), Box<dyn Fn(&())>, &'t0 (), fn(&(), &())) {}\n-   |    --                            ------------------------------------------------ required by this bound in `h2`\n-\n-error: aborting due to 22 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "696bd5c39d2831cbd1d22e7ce41b1d467902e09a", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -9,9 +9,9 @@ LL |     assert_send(local_dropped_before_await());\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `{impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -26,9 +26,9 @@ LL |     assert_send(non_send_temporary_in_match());\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -45,9 +45,9 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut dyn std::fmt::Write`\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n \n@@ -68,9 +68,9 @@ LL |     assert_send(non_sync_with_method_call());\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::slice::Iter<'_, std::fmt::ArgumentV1<'_>>`\n    = note: required because it appears within the type `std::fmt::Formatter<'_>`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, fn() -> impl std::future::Future {fut}, impl std::future::Future, impl std::future::Future, ()}]>`\n    = note: required because it appears within the type `impl std::future::Future`\n    = note: required because it appears within the type `impl std::future::Future`\n "}, {"sha": "1936d1a2ed56e7a0acdb8a627c773d8b8f9b2350", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,25 @@\n+// edition:2018\n+\n+use std::sync::Mutex;\n+\n+fn is_send<T: Send>(t: T) {\n+\n+}\n+\n+async fn foo() {\n+    bar(&Mutex::new(22)).await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+    let g = x.lock().unwrap();\n+    baz().await;\n+}\n+\n+async fn baz() {\n+\n+}\n+\n+fn main() {\n+    is_send(foo());\n+    //~^ ERROR `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely [E0277]\n+}"}, {"sha": "9e9fc52e30b7f069238bca70c52b289c3b1f1c3a", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,23 @@\n+error[E0277]: `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n+  --> $DIR/issue-64130-non-send-future-diags.rs:23:5\n+   |\n+LL | fn is_send<T: Send>(t: T) {\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL |     is_send(foo());\n+   |     ^^^^^^^ `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard<'_, u32>`\n+note: future does not implement `std::marker::Send` as this value is used across an await\n+  --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n+   |\n+LL |     let g = x.lock().unwrap();\n+   |         - has type `std::sync::MutexGuard<'_, u32>`\n+LL |     baz().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n+LL | }\n+   | - `g` is later dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d63d643c4e70b05dc84b03670efceabb59f1d468", "filename": "src/test/ui/async-await/unreachable-lint-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+#![deny(unreachable_code)]\n+\n+async fn foo() {\n+    return; bar().await;\n+    //~^ ERROR unreachable statement\n+}\n+\n+async fn bar() {\n+}\n+\n+fn main() { }"}, {"sha": "382581bf945547ad0a9fcdb44fa8c00c7256b292", "filename": "src/test/ui/async-await/unreachable-lint-1.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint-1.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,16 @@\n+error: unreachable statement\n+  --> $DIR/unreachable-lint-1.rs:5:13\n+   |\n+LL |     return; bar().await;\n+   |     ------  ^^^^^^^^^^^^ unreachable statement\n+   |     |\n+   |     any code following this expression is unreachable\n+   |\n+note: lint level defined here\n+  --> $DIR/unreachable-lint-1.rs:2:9\n+   |\n+LL | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ca18cfde4f2f5526d9e2f7014bbd28fefe3e1a1a", "filename": "src/test/ui/async-await/unreachable-lint.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funreachable-lint.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// edition:2018\n+#![deny(unreachable_code)]\n+\n+async fn foo() {\n+    endless().await;\n+}\n+\n+async fn endless() -> ! {\n+    loop {}\n+}\n+\n+fn main() { }"}, {"sha": "6381bb2d588770c275710e9e3ae855da5af1087c", "filename": "src/test/ui/cfg/cfg_stmt_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcfg%2Fcfg_stmt_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcfg%2Fcfg_stmt_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg_stmt_expr.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -57,7 +57,7 @@ fn main() {\n     // check that macro expanded code works\n \n     macro_rules! if_cfg {\n-        ($cfg:meta $ib:block else $eb:block) => {\n+        ($cfg:meta? $ib:block else $eb:block) => {\n             {\n                 let r;\n                 #[cfg($cfg)]\n@@ -69,7 +69,7 @@ fn main() {\n         }\n     }\n \n-    let n = if_cfg!(unset {\n+    let n = if_cfg!(unset? {\n         413\n     } else {\n         612"}, {"sha": "e71547cb89f9c7a96129477e7cd8cb7687a58b4c", "filename": "src/test/ui/coherence/coherence_inherent.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.old.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         s.the_fn();\n    |           ^^^^^^ method not found in `&Lib::TheStruct`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use Lib::TheTrait;`\n \n error: aborting due to previous error"}, {"sha": "e71547cb89f9c7a96129477e7cd8cb7687a58b4c", "filename": "src/test/ui/coherence/coherence_inherent.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent.re.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         s.the_fn();\n    |           ^^^^^^ method not found in `&Lib::TheStruct`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use Lib::TheTrait;`\n \n error: aborting due to previous error"}, {"sha": "3683943c5c819da5f7b355a3d9cbca17eacf5765", "filename": "src/test/ui/coherence/coherence_inherent_cc.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.old.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         s.the_fn();\n    |           ^^^^^^ method not found in `&coherence_inherent_cc_lib::TheStruct`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use coherence_inherent_cc_lib::TheTrait;`\n \n error: aborting due to previous error"}, {"sha": "3683943c5c819da5f7b355a3d9cbca17eacf5765", "filename": "src/test/ui/coherence/coherence_inherent_cc.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_inherent_cc.re.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         s.the_fn();\n    |           ^^^^^^ method not found in `&coherence_inherent_cc_lib::TheStruct`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use coherence_inherent_cc_lib::TheTrait;`\n \n error: aborting due to previous error"}, {"sha": "125af64fef05c7bb99dea8969773eb7806588037", "filename": "src/test/ui/feature-gates/feature-gate-macros_in_extern.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,27 +0,0 @@\n-#![feature(decl_macro)]\n-\n-macro_rules! returns_isize(\n-    ($ident:ident) => (\n-        fn $ident() -> isize;\n-    )\n-);\n-\n-macro takes_u32_returns_u32($ident:ident) {\n-    fn $ident (arg: u32) -> u32;\n-}\n-\n-macro_rules! emits_nothing(\n-    () => ()\n-);\n-\n-#[link(name = \"rust_test_helpers\", kind = \"static\")]\n-extern {\n-    returns_isize!(rust_get_test_int);\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n-    takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n-    emits_nothing!();\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n-}\n-\n-fn main() {}"}, {"sha": "e8b3ab5dda20daddd5e4d2df8552e7738936e0d7", "filename": "src/test/ui/feature-gates/feature-gate-macros_in_extern.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macros_in_extern.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,30 +0,0 @@\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/feature-gate-macros_in_extern.rs:19:5\n-   |\n-LL |     returns_isize!(rust_get_test_int);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/feature-gate-macros_in_extern.rs:21:5\n-   |\n-LL |     takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/feature-gate-macros_in_extern.rs:23:5\n-   |\n-LL |     emits_nothing!();\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n-   = help: add `#![feature(macros_in_extern)]` to the crate attributes to enable\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "736369dab83549237717f2561db9d710ce96256a", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -25,7 +25,7 @@ LL |         ().clone()\n    |            ^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use std::clone::Clone;`\n \n error: aborting due to 3 previous errors"}, {"sha": "c3ce484edf7a95a13c719eeb0f8c02c1e92135e9", "filename": "src/test/ui/hygiene/trait_items.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -8,7 +8,7 @@ LL |     pub macro m() { ().f() }\n    |                        ^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use foo::T;`\n \n error: aborting due to previous error"}, {"sha": "f0a03e1be82ac5e7c48d16725fc9e7fd8e5cf927", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |     1u32.method();\n    |          ^^^^^^ method not found in `u32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n+help: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n    |\n LL | use foo::Bar;\n    |\n@@ -23,7 +23,7 @@ LL |     std::rc::Rc::new(&mut Box::new(&1u32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&u32>>`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n+help: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n    |\n LL | use foo::Bar;\n    |\n@@ -41,7 +41,7 @@ LL |     'a'.method();\n    |         ^^^^^^ method not found in `char`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use foo::Bar;\n    |\n@@ -61,7 +61,7 @@ LL |     std::rc::Rc::new(&mut Box::new(&'a')).method();\n    |                                           ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&char>>`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use foo::Bar;\n    |\n@@ -73,7 +73,7 @@ LL |     1i32.method();\n    |          ^^^^^^ method not found in `i32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use no_method_suggested_traits::foo::PubPub;\n    |\n@@ -85,7 +85,7 @@ LL |     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&i32>>`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use no_method_suggested_traits::foo::PubPub;\n    |"}, {"sha": "80ca051ceff0df2f2529b89dd6d013e2b854dac6", "filename": "src/test/ui/issues/issue-10465.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-10465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-10465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10465.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |             b.foo();\n    |               ^^^ method not found in `&b::B`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use a::A;`\n \n error: aborting due to previous error"}, {"sha": "2ea9dcbe9d0a45ac550c8f72fb9a441ed2b2822c", "filename": "src/test/ui/issues/issue-37534.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -8,7 +8,7 @@ help: possible better candidate is found in another module, you can import it in\n LL | use std::hash::Hash;\n    |\n \n-warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default. Only `?Sized` is supported\n+warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default; only `?Sized` is supported\n   --> $DIR/issue-37534.rs:1:12\n    |\n LL | struct Foo<T: ?Hash> { }"}, {"sha": "8b173e1b50c1e9ebcc4e2046c8ccf70fbe875542", "filename": "src/test/ui/issues/issue-39175.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |     Command::new(\"echo\").arg(\"hello\").exec();\n    |                                       ^^^^ method not found in `&mut std::process::Command`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use std::os::unix::process::CommandExt;\n    |"}, {"sha": "4dae6c1cd158e49a94dd47c7df5359c67cb68ad4", "filename": "src/test/ui/issues/issue-43189.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-43189.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-43189.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43189.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |     ().a();\n    |        ^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use xcrate_issue_43189_b::xcrate_issue_43189_a::A;\n    |"}, {"sha": "728c113bdc32347849e68dbf7116862419136e60", "filename": "src/test/ui/issues/issue-50571.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-50571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-50571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50571.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,6 @@\n+trait Foo {\n+    fn foo([a, b]: [i32; 2]) {}\n+    //~^ ERROR: patterns aren't allowed in methods without bodies\n+}\n+\n+fn main() {}"}, {"sha": "834635388a0660a174ee842d658dc73d63eb10c0", "filename": "src/test/ui/issues/issue-50571.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-50571.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-50571.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50571.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,13 @@\n+error[E0642]: patterns aren't allowed in methods without bodies\n+  --> $DIR/issue-50571.rs:2:12\n+   |\n+LL |     fn foo([a, b]: [i32; 2]) {}\n+   |            ^^^^^^\n+help: give this argument a name or use an underscore to ignore it\n+   |\n+LL |     fn foo(_: [i32; 2]) {}\n+   |            ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0642`."}, {"sha": "c6dd45e6cf3e9a03cb815b2eb09cd83be0b06d1a", "filename": "src/test/ui/issues/issue-58022.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,18 @@\n+pub trait Foo: Sized {\n+    const SIZE: usize;\n+\n+    fn new(slice: &[u8; Foo::SIZE]) -> Self;\n+    //~^ ERROR: type annotations needed: cannot resolve `_: Foo`\n+}\n+\n+pub struct Bar<T: ?Sized>(T);\n+\n+impl Bar<[u8]> {\n+    const SIZE: usize = 32;\n+\n+    fn new(slice: &[u8; Self::SIZE]) -> Self {\n+        Foo(Box::new(*slice)) //~ ERROR: expected function, found trait `Foo`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "71bad7b81fa87beb11e308b6a0b92b19eefbcf62", "filename": "src/test/ui/issues/issue-58022.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,19 @@\n+error[E0423]: expected function, found trait `Foo`\n+  --> $DIR/issue-58022.rs:14:9\n+   |\n+LL |         Foo(Box::new(*slice))\n+   |         ^^^ not a function\n+\n+error[E0283]: type annotations needed: cannot resolve `_: Foo`\n+  --> $DIR/issue-58022.rs:4:25\n+   |\n+LL |     const SIZE: usize;\n+   |     ------------------ required by `Foo::SIZE`\n+LL | \n+LL |     fn new(slice: &[u8; Foo::SIZE]) -> Self;\n+   |                         ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0283, E0423.\n+For more information about an error, try `rustc --explain E0283`."}, {"sha": "99b656d74f505cdbfc81401b053180571ece910f", "filename": "src/test/ui/issues/issue-58344.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,50 @@\n+use std::ops::Add;\n+\n+trait Trait<T> {\n+    fn get(self) -> T;\n+}\n+\n+struct Holder<T>(T);\n+\n+impl<T> Trait<T> for Holder<T> {\n+    fn get(self) -> T {\n+        self.0\n+    }\n+}\n+\n+enum Either<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+impl<L, R> Either<L, R> {\n+    fn converge<T>(self) -> T where L: Trait<T>, R: Trait<T> {\n+        match self {\n+            Either::Left(val) => val.get(),\n+            Either::Right(val) => val.get(),\n+        }\n+    }\n+}\n+\n+fn add_generic<A: Add<B>, B>(lhs: A, rhs: B) -> Either<\n+    impl Trait<<A as Add<B>>::Output>,\n+    impl Trait<<A as Add<B>>::Output>\n+> {\n+    if true {\n+        Either::Left(Holder(lhs + rhs))\n+    } else {\n+        Either::Right(Holder(lhs + rhs))\n+    }\n+}\n+\n+fn add_one(\n+    value: u32,\n+) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n+    //~^ ERROR: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait<u32>`\n+    //~| ERROR: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait<u32>`\n+    add_generic(value, 1u32)\n+}\n+\n+pub fn main() {\n+    add_one(3).converge();\n+}"}, {"sha": "427d03b679d5f8daedcf05895e3c5b35408dd5c3", "filename": "src/test/ui/issues/issue-58344.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait<u32>` is not satisfied\n+  --> $DIR/issue-58344.rs:42:13\n+   |\n+LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait<u32>` is not satisfied\n+  --> $DIR/issue-58344.rs:42:52\n+   |\n+LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "afdf76b7b580fe27148de3424b699330dec3db5e", "filename": "src/test/ui/macros/issue-54441.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,5 +1,3 @@\n-#![feature(macros_in_extern)]\n-\n macro_rules! m {\n     () => {\n         let //~ ERROR expected"}, {"sha": "af0ee3ae8eca3a88e173281a1db79af2908d69da", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,5 +1,5 @@\n error: expected one of `crate`, `fn`, `pub`, `static`, or `type`, found `let`\n-  --> $DIR/issue-54441.rs:5:9\n+  --> $DIR/issue-54441.rs:3:9\n    |\n LL |         let\n    |         ^^^ unexpected token"}, {"sha": "eb2504d4bfdb7ef2024f35fc29127af189eb859a", "filename": "src/test/ui/macros/macro-first-set.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacro-first-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacro-first-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-first-set.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -252,12 +252,6 @@ test_path!(::std);\n test_path!(std::u8,);\n test_path!(any, super, super::super::self::path, X<Y>::Z<'a, T=U>);\n \n-macro_rules! test_meta_block {\n-    ($($m:meta)* $b:block) => {};\n-}\n-\n-test_meta_block!(windows {});\n-\n macro_rules! test_lifetime {\n     (1. $($l:lifetime)* $($b:block)*) => {};\n     (2. $($b:block)* $($l:lifetime)*) => {};"}, {"sha": "bc6938d4a6c9af000f0e89c35158b8e206b009a1", "filename": "src/test/ui/macros/macro-meta-items-modern.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacro-meta-items-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacro-meta-items-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-meta-items-modern.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+macro_rules! check { ($meta:meta) => () }\n+\n+check!(meta(a b c d));\n+check!(meta[a b c d]);\n+check!(meta { a b c d });\n+check!(meta);\n+check!(meta = 0);\n+\n+fn main() {}"}, {"sha": "28abef5cf4edcf488f785818e79930e92bf85b18", "filename": "src/test/ui/macros/macros-in-extern-rpass.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern-rpass.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,30 +0,0 @@\n-// run-pass\n-// ignore-wasm32\n-\n-#![feature(decl_macro, macros_in_extern)]\n-\n-macro_rules! returns_isize(\n-    ($ident:ident) => (\n-        fn $ident() -> isize;\n-    )\n-);\n-\n-macro takes_u32_returns_u32($ident:ident) {\n-    fn $ident (arg: u32) -> u32;\n-}\n-\n-macro_rules! emits_nothing(\n-    () => ()\n-);\n-\n-fn main() {\n-    assert_eq!(unsafe { rust_get_test_int() }, 1isize);\n-    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEFu32);\n-}\n-\n-#[link(name = \"rust_test_helpers\", kind = \"static\")]\n-extern {\n-    returns_isize!(rust_get_test_int);\n-    takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n-    emits_nothing!();\n-}"}, {"sha": "05002ed72c78d4a49f7a1987c52382ad37aeea9b", "filename": "src/test/ui/macros/macros-in-extern.rs", "status": "renamed", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-in-extern.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,3 +1,4 @@\n+// run-pass\n // ignore-wasm32\n \n #![feature(decl_macro)]\n@@ -16,17 +17,29 @@ macro_rules! emits_nothing(\n     () => ()\n );\n \n+macro_rules! emits_multiple(\n+    () => {\n+        fn f1() -> u32;\n+        fn f2() -> u32;\n+    }\n+);\n+\n+mod defs {\n+    #[no_mangle] extern fn f1() -> u32 { 1 }\n+    #[no_mangle] extern fn f2() -> u32 { 2 }\n+}\n+\n fn main() {\n-    assert_eq!(unsafe { rust_get_test_int() }, 0isize);\n+    assert_eq!(unsafe { rust_get_test_int() }, 1);\n     assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEFu32);\n+    assert_eq!(unsafe { f1() }, 1);\n+    assert_eq!(unsafe { f2() }, 2);\n }\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n     returns_isize!(rust_get_test_int);\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     emits_nothing!();\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n+    emits_multiple!();\n }", "previous_filename": "src/test/ui/abi/macros/macros-in-extern.rs"}, {"sha": "15cbce46f0a9b4887ae7835324ad9de36b19b3fd", "filename": "src/test/ui/maybe-bounds-where.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -34,7 +34,7 @@ error[E0203]: type parameter has more than one relaxed default bound, only one i\n LL | struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n    |           ^\n \n-warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default. Only `?Sized` is supported\n+warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default; only `?Sized` is supported\n   --> $DIR/maybe-bounds-where.rs:15:11\n    |\n LL | struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;"}, {"sha": "9035e3380b0c519e0e895474e9f1ba551189318d", "filename": "src/test/ui/mismatched_types/issue-36053-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -7,5 +7,4 @@ fn main() {\n     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n     //~^ ERROR no method named `count`\n     //~| ERROR type mismatch in closure arguments\n-    //~| ERROR type mismatch in closure arguments\n }"}, {"sha": "72f3220cc1abaaf4ca3ef1fc7a5d0dee75d29bf2", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -16,14 +16,6 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n    |                                |\n    |                                expected signature of `for<'r> fn(&'r &str) -> _`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/issue-36053-2.rs:7:32\n-   |\n-LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n-   |                                ^^^^^^ -------------- found signature of `for<'r> fn(&'r str) -> _`\n-   |                                |\n-   |                                expected signature of `fn(&&str) -> _`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0599`."}, {"sha": "181c770096a5f78063c78847294045366e6d8458", "filename": "src/test/ui/or-patterns/issue-64879-trailing-before-guard.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,15 @@\n+// In this regression test we check that a trailing `|` in an or-pattern just\n+// before the `if` token of a `match` guard will receive parser recovery with\n+// an appropriate error message.\n+\n+enum E { A, B }\n+\n+fn main() {\n+    match E::A {\n+        E::A |\n+        E::B | //~ ERROR a trailing `|` is not allowed in an or-pattern\n+        if true => {\n+            let recovery_witness: bool = 0; //~ ERROR mismatched types\n+        }\n+    }\n+}"}, {"sha": "db6670fc5b1e074ab194b4283076a1a5c982f216", "filename": "src/test/ui/or-patterns/issue-64879-trailing-before-guard.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-64879-trailing-before-guard.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,20 @@\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/issue-64879-trailing-before-guard.rs:10:14\n+   |\n+LL |         E::A |\n+   |         ---- while parsing this or-pattern starting here\n+LL |         E::B |\n+   |              ^ help: remove the `|`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-64879-trailing-before-guard.rs:12:42\n+   |\n+LL |             let recovery_witness: bool = 0;\n+   |                                          ^ expected bool, found integer\n+   |\n+   = note: expected type `bool`\n+              found type `{integer}`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c71c760b1e30374cd2571139f1ec2602f5c96b72", "filename": "src/test/ui/or-patterns/multiple-pattern-typo.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -2,37 +2,49 @@ error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:8:15\n    |\n LL |         1 | 2 || 3 => (),\n-   |               ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |         -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:13:16\n    |\n LL |         (1 | 2 || 3) => (),\n-   |                ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          |\n+   |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:18:16\n    |\n LL |         (1 | 2 || 3,) => (),\n-   |                ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          |\n+   |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:25:18\n    |\n LL |         TS(1 | 2 || 3) => (),\n-   |                  ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |            -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |            |\n+   |            while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:32:23\n    |\n LL |         NS { f: 1 | 2 || 3 } => (),\n-   |                       ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |                 -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |                 |\n+   |                 while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:37:16\n    |\n LL |         [1 | 2 || 3] => (),\n-   |                ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |          |\n+   |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n   --> $DIR/multiple-pattern-typo.rs:42:9"}, {"sha": "6d08b47c058ed09ddf32bfadf0a82b795a4b66a5", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -51,24 +51,32 @@ error: a leading `|` is only allowed in a top-level pattern\n    |\n LL |     let ( || A | B) = E::A;\n    |           ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/or-patterns-syntactic-fail.rs:48:11\n    |\n LL |     let [ || A | B ] = [E::A];\n    |           ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/or-patterns-syntactic-fail.rs:49:13\n    |\n LL |     let TS( || A | B );\n    |             ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/or-patterns-syntactic-fail.rs:50:17\n    |\n LL |     let NS { f: || A | B };\n    |                 ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: no rules expected the token `|`\n   --> $DIR/or-patterns-syntactic-fail.rs:14:15"}, {"sha": "443ef398293d9900a507149595d21e32d334508d", "filename": "src/test/ui/or-patterns/remove-leading-vert.fixed", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,4 +1,4 @@\n-// Test the suggestion to remove a leading `|`.\n+// Test the suggestion to remove a leading, or trailing `|`.\n \n // run-rustfix\n \n@@ -8,7 +8,7 @@\n fn main() {}\n \n #[cfg(FALSE)]\n-fn leading_vert() {\n+fn leading() {\n     fn fun1(  A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n     fn fun2(  A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n     let (  A): E; //~ ERROR a leading `|` is only allowed in a top-level pattern\n@@ -21,3 +21,26 @@ fn leading_vert() {\n     let NS { f:  A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n     let NS { f:  A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n }\n+\n+#[cfg(FALSE)]\n+fn trailing() {\n+    let ( A  ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let (a ,): (E,); //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let ( A | B  ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let [ A | B  ]: [E; 1]; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let S { f: B  }; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let ( A | B  ): E; //~ ERROR unexpected token `||` after pattern\n+    //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+    match A {\n+        A  => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n+        A  => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n+        A | B  => {} //~ ERROR unexpected token `||` after pattern\n+        //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+        | A | B  => {}\n+        //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+    }\n+\n+    let a  : u8 = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let a  = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let a  ; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+}"}, {"sha": "3c427a6f7b23ef9ed7656617e1968d26c70865b1", "filename": "src/test/ui/or-patterns/remove-leading-vert.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,4 +1,4 @@\n-// Test the suggestion to remove a leading `|`.\n+// Test the suggestion to remove a leading, or trailing `|`.\n \n // run-rustfix\n \n@@ -8,7 +8,7 @@\n fn main() {}\n \n #[cfg(FALSE)]\n-fn leading_vert() {\n+fn leading() {\n     fn fun1( | A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n     fn fun2( || A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n     let ( | A): E; //~ ERROR a leading `|` is only allowed in a top-level pattern\n@@ -21,3 +21,26 @@ fn leading_vert() {\n     let NS { f: | A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n     let NS { f: || A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n }\n+\n+#[cfg(FALSE)]\n+fn trailing() {\n+    let ( A | ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let (a |,): (E,); //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let ( A | B | ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let [ A | B | ]: [E; 1]; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let S { f: B | }; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let ( A || B | ): E; //~ ERROR unexpected token `||` after pattern\n+    //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+    match A {\n+        A | => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n+        A || => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n+        A || B | => {} //~ ERROR unexpected token `||` after pattern\n+        //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+        | A | B | => {}\n+        //~^ ERROR a trailing `|` is not allowed in an or-pattern\n+    }\n+\n+    let a | : u8 = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let a | = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+    let a | ; //~ ERROR a trailing `|` is not allowed in an or-pattern\n+}"}, {"sha": "53025230a63c221d99b7db8b9b874be63cb55a3d", "filename": "src/test/ui/or-patterns/remove-leading-vert.stderr", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -9,6 +9,8 @@ error: a leading `|` is not allowed in a parameter pattern\n    |\n LL |     fn fun2( || A: E) {}\n    |              ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/remove-leading-vert.rs:14:11\n@@ -21,6 +23,8 @@ error: a leading `|` is only allowed in a top-level pattern\n    |\n LL |     let ( || A): (E);\n    |           ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/remove-leading-vert.rs:16:11\n@@ -39,6 +43,8 @@ error: a leading `|` is only allowed in a top-level pattern\n    |\n LL |     let [ || A ]: [E; 1];\n    |           ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/remove-leading-vert.rs:19:13\n@@ -51,6 +57,8 @@ error: a leading `|` is only allowed in a top-level pattern\n    |\n LL |     let TS( || A ): TS;\n    |             ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n   --> $DIR/remove-leading-vert.rs:21:17\n@@ -63,6 +71,130 @@ error: a leading `|` is only allowed in a top-level pattern\n    |\n LL |     let NS { f: || A }: NS;\n    |                 ^^ help: remove the `||`\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:27:13\n+   |\n+LL |     let ( A | ): E;\n+   |           - ^ help: remove the `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:28:12\n+   |\n+LL |     let (a |,): (E,);\n+   |          - ^ help: remove the `|`\n+   |          |\n+   |          while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:29:17\n+   |\n+LL |     let ( A | B | ): E;\n+   |           -     ^ help: remove the `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:30:17\n+   |\n+LL |     let [ A | B | ]: [E; 1];\n+   |           -     ^ help: remove the `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:31:18\n+   |\n+LL |     let S { f: B | };\n+   |                - ^ help: remove the `|`\n+   |                |\n+   |                while parsing this or-pattern starting here\n+\n+error: unexpected token `||` after pattern\n+  --> $DIR/remove-leading-vert.rs:32:13\n+   |\n+LL |     let ( A || B | ): E;\n+   |           - ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:32:18\n+   |\n+LL |     let ( A || B | ): E;\n+   |           -      ^ help: remove the `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:35:11\n+   |\n+LL |         A | => {}\n+   |         - ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:36:11\n+   |\n+LL |         A || => {}\n+   |         - ^^ help: remove the `||`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+   |\n+   = note: alternatives in or-patterns are separated with `|`, not `||`\n+\n+error: unexpected token `||` after pattern\n+  --> $DIR/remove-leading-vert.rs:37:11\n+   |\n+LL |         A || B | => {}\n+   |         - ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:37:16\n+   |\n+LL |         A || B | => {}\n+   |         -      ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:39:17\n+   |\n+LL |         | A | B | => {}\n+   |           -     ^ help: remove the `|`\n+   |           |\n+   |           while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:43:11\n+   |\n+LL |     let a | : u8 = 0;\n+   |         - ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:44:11\n+   |\n+LL |     let a | = 0;\n+   |         - ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n+\n+error: a trailing `|` is not allowed in an or-pattern\n+  --> $DIR/remove-leading-vert.rs:45:11\n+   |\n+LL |     let a | ;\n+   |         - ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "15fe3804f9b4ff73c46a2784207715e90a471026", "filename": "src/test/ui/proc-macro/auxiliary/test-macros-rpass.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros-rpass.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,26 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_attribute]\n-pub fn nop_attr(_attr: TokenStream, input: TokenStream) -> TokenStream {\n-    assert!(_attr.to_string().is_empty());\n-    input\n-}\n-\n-#[proc_macro_attribute]\n-pub fn no_output(_attr: TokenStream, _input: TokenStream) -> TokenStream {\n-    assert!(_attr.to_string().is_empty());\n-    assert!(!_input.to_string().is_empty());\n-    \"\".parse().unwrap()\n-}\n-\n-#[proc_macro]\n-pub fn emit_input(input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "223c4047cb2b1e2548b9dd2fb86fcf23ad00c3a7", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -7,8 +7,6 @@\n // normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n // normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n \n-#![feature(proc_macro_hygiene)]\n-\n #[macro_use]\n extern crate test_macros;\n extern crate dollar_crate_external;"}, {"sha": "5605696715e34223efd00528a90d061e0ad7aad6", "filename": "src/test/ui/proc-macro/lifetimes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,7 +1,5 @@\n // aux-build:lifetimes.rs\n \n-#![feature(proc_macro_hygiene)]\n-\n extern crate lifetimes;\n \n use lifetimes::*;"}, {"sha": "10acd4304aa231a9536879065ee6cf631d26d03b", "filename": "src/test/ui/proc-macro/lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,5 +1,5 @@\n error: expected type, found `'`\n-  --> $DIR/lifetimes.rs:9:10\n+  --> $DIR/lifetimes.rs:7:10\n    |\n LL | type A = single_quote_alone!();\n    |          ^^^^^^^^^^^^^^^^^^^^^ this macro call doesn't expand to a type"}, {"sha": "d2751a353bd93c4b5659d02287557fba2972436e", "filename": "src/test/ui/proc-macro/macros-in-extern-derive.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,6 @@\n+extern {\n+    #[derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    fn f();\n+}\n+\n+fn main() {}"}, {"sha": "e2afb7d34c1494b676a9542f403d592354290030", "filename": "src/test/ui/proc-macro/macros-in-extern-derive.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-derive.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,8 @@\n+error: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/macros-in-extern-derive.rs:2:5\n+   |\n+LL |     #[derive(Copy)]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a30a287a1011bb4a53728211230d59975da44664", "filename": "src/test/ui/proc-macro/macros-in-extern-rpass.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern-rpass.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1,25 +0,0 @@\n-// run-pass\n-// aux-build:test-macros-rpass.rs\n-// ignore-wasm32\n-\n-#![feature(macros_in_extern)]\n-\n-extern crate test_macros_rpass as test_macros;\n-\n-use test_macros::{nop_attr, no_output, emit_input};\n-\n-fn main() {\n-    assert_eq!(unsafe { rust_get_test_int() }, 1isize);\n-    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEF);\n-}\n-\n-#[link(name = \"rust_test_helpers\", kind = \"static\")]\n-extern {\n-    #[no_output]\n-    fn some_definitely_unknown_symbol_which_should_be_removed();\n-\n-    #[nop_attr]\n-    fn rust_get_test_int() -> isize;\n-\n-    emit_input!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n-}"}, {"sha": "e2b1d55aedc282b9699053d4e35c20813a2479b6", "filename": "src/test/ui/proc-macro/macros-in-extern.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -1,24 +1,22 @@\n+// run-pass\n // aux-build:test-macros.rs\n // ignore-wasm32\n \n #[macro_use]\n extern crate test_macros;\n \n fn main() {\n-    assert_eq!(unsafe { rust_get_test_int() }, 0isize);\n+    assert_eq!(unsafe { rust_get_test_int() }, 1);\n     assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEF);\n }\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n     #[empty_attr]\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     fn some_definitely_unknown_symbol_which_should_be_removed();\n \n     #[identity_attr]\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     fn rust_get_test_int() -> isize;\n \n     identity!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n-    //~^ ERROR macro invocations in `extern {}` blocks are experimental\n }", "previous_filename": "src/test/ui/abi/proc-macro/macros-in-extern.rs"}, {"sha": "19ed58eceb9647d3e342cead2f4af6ddb39afc39", "filename": "src/test/ui/proc-macro/macros-in-type.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-type.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+const C: identity!(u8) = 10;\n+\n+fn main() {\n+    let c: u8 = C;\n+}"}, {"sha": "0096a84f14c3490a865bcfa723a6082e0ba7bf99", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -50,7 +50,6 @@ fn attrs() {\n }\n \n fn main() {\n-    let _x: identity!(u32) = 3; //~ ERROR: procedural macros cannot be expanded to types\n     if let identity!(Some(_x)) = Some(3) {}\n     //~^ ERROR: procedural macros cannot be expanded to patterns\n "}, {"sha": "14a4f8c0fbca2ba265b9577fcf15b6a46b48db19", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -94,17 +94,8 @@ LL |     let _x = #[identity_attr] println!();\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n-error[E0658]: procedural macros cannot be expanded to types\n-  --> $DIR/proc-macro-gates.rs:53:13\n-   |\n-LL |     let _x: identity!(u32) = 3;\n-   |             ^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n error[E0658]: procedural macros cannot be expanded to patterns\n-  --> $DIR/proc-macro-gates.rs:54:12\n+  --> $DIR/proc-macro-gates.rs:53:12\n    |\n LL |     if let identity!(Some(_x)) = Some(3) {}\n    |            ^^^^^^^^^^^^^^^^^^^\n@@ -113,7 +104,7 @@ LL |     if let identity!(Some(_x)) = Some(3) {}\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to statements\n-  --> $DIR/proc-macro-gates.rs:57:5\n+  --> $DIR/proc-macro-gates.rs:56:5\n    |\n LL |     empty!(struct S;);\n    |     ^^^^^^^^^^^^^^^^^^\n@@ -122,7 +113,7 @@ LL |     empty!(struct S;);\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to statements\n-  --> $DIR/proc-macro-gates.rs:58:5\n+  --> $DIR/proc-macro-gates.rs:57:5\n    |\n LL |     empty!(let _x = 3;);\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -131,7 +122,7 @@ LL |     empty!(let _x = 3;);\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to expressions\n-  --> $DIR/proc-macro-gates.rs:60:14\n+  --> $DIR/proc-macro-gates.rs:59:14\n    |\n LL |     let _x = identity!(3);\n    |              ^^^^^^^^^^^^\n@@ -140,14 +131,14 @@ LL |     let _x = identity!(3);\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to expressions\n-  --> $DIR/proc-macro-gates.rs:61:15\n+  --> $DIR/proc-macro-gates.rs:60:15\n    |\n LL |     let _x = [empty!(3)];\n    |               ^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "4b1898345a32ebe6c7536c942d5ad53136c53b9f", "filename": "src/test/ui/rust-2018/trait-import-suggestions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         x.foobar();\n    |           ^^^^^^ method not found in `u32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use crate::foo::foobar::Foobar;`\n \n error[E0599]: no method named `bar` found for type `u32` in the current scope\n@@ -15,7 +15,7 @@ LL |     x.bar();\n    |       ^^^ method not found in `u32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use crate::foo::Bar;\n    |\n@@ -33,7 +33,7 @@ LL |     let y = u32::from_str(\"33\");\n    |                  ^^^^^^^^ function or associated item not found in `u32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use std::str::FromStr;\n    |"}, {"sha": "3597cc53420aa82e5bf63d18fb44e5a79876a7c4", "filename": "src/test/ui/shadowed/shadowed-trait-methods.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-trait-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-trait-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-trait-methods.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |     ().f()\n    |        ^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use foo::T;\n    |"}, {"sha": "64a92c6b0b47860536d6d30ad45ad0a761d59a69", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -28,7 +28,7 @@ LL |     S.b();\n    |       ^ method not found in `S`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use method::B;\n    |\n@@ -62,7 +62,7 @@ LL |     S::b(&S);\n    |        ^ function or associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use method::B;\n    |\n@@ -96,7 +96,7 @@ LL |     S::B;\n    |        ^ associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use assoc_const::B;\n    |"}, {"sha": "10552acb348bee424b40958ffcafc35d14ad4b4a", "filename": "src/test/ui/traits/trait-method-private.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Ftraits%2Ftrait-method-private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Ftraits%2Ftrait-method-private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-method-private.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |     foo.method();\n    |         ^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n LL | use inner::Bar;\n    |"}, {"sha": "102c17f6f5618017da5299e4d963617c54fdd3c3", "filename": "src/test/ui/underscore-imports/shadow.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Funderscore-imports%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/702b45e409495a41afcccbe87a251a692b0cefab/src%2Ftest%2Fui%2Funderscore-imports%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fshadow.stderr?ref=702b45e409495a41afcccbe87a251a692b0cefab", "patch": "@@ -5,7 +5,7 @@ LL |         x.deref();\n    |           ^^^^^ method not found in `&()`\n    |\n    = help: items from traits can only be used if the trait is in scope\n-   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   = note: the following trait is implemented but not in scope; perhaps add a `use` for it:\n            `use std::ops::Deref;`\n \n error: aborting due to previous error"}]}