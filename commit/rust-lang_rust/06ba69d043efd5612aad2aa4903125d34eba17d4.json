{"sha": "06ba69d043efd5612aad2aa4903125d34eba17d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YmE2OWQwNDNlZmQ1NjEyYWFkMmFhNDkwMzEyNWQzNGViYTE3ZDQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-24T22:43:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-24T22:43:44Z"}, "message": "Rollup merge of #52391 - Amanieu:volatile_unaligned, r=alexcrichton\n\nAdd unaligned volatile intrinsics\n\nSurprisingly enough, it turns out that unaligned volatile loads are actually useful for certain (very niche) types of lock-free code. I included unaligned volatile stores for completeness, but I currently do not know of any use cases for them.\n\nThese are only exposed as intrinsics for now. If they turn out to be useful in practice, we can work towards stabilizing them.\n\nr? @alexcrichton", "tree": {"sha": "9ffce52d8b60a116b13a0b0c48202028f65629e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ffce52d8b60a116b13a0b0c48202028f65629e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ba69d043efd5612aad2aa4903125d34eba17d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbV6ugCRBK7hj4Ov3rIwAAdHIIAB2FywJyugb6dDYl4oFtXtLf\nmsKj2AHYBb8yvfmfTnUF81fPrQ5b1rNd6GhuqSF0TPO6nxe9CPcnGlGJOQZIJVBo\n/d3pMwjYoeP0GSzzdygxRUHmWHQoqpadsvpyaSl8wRdTFj94HlmZi39XaNJngS2/\n+X9z/gelHwDa9t+nyDj7mVanKebeOEhcL6Sj45TGNKIDNxwS1nnQTcq5IyZVviMK\nfUFVStQl3dUhrzrb4UWwe+gjgeTk2RLSHFpJviT9g+2EXGjEAJJS13WAKTZ6cv7w\nURJwtqs4cfZzQI//FyNJY69qD/A6nSKpKRionicaabKjJg9+URdvgi8O4z8hxyY=\n=MkJz\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ffce52d8b60a116b13a0b0c48202028f65629e5\nparent 487e961c6ae072d969e148def0b0856c2367ae00\nparent 303306cf5ede678719ec1324bb02d3d02c014183\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1532472224 -0600\ncommitter GitHub <noreply@github.com> 1532472224 -0600\n\nRollup merge of #52391 - Amanieu:volatile_unaligned, r=alexcrichton\n\nAdd unaligned volatile intrinsics\n\nSurprisingly enough, it turns out that unaligned volatile loads are actually useful for certain (very niche) types of lock-free code. I included unaligned volatile stores for completeness, but I currently do not know of any use cases for them.\n\nThese are only exposed as intrinsics for now. If they turn out to be useful in practice, we can work towards stabilizing them.\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ba69d043efd5612aad2aa4903125d34eba17d4", "html_url": "https://github.com/rust-lang/rust/commit/06ba69d043efd5612aad2aa4903125d34eba17d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ba69d043efd5612aad2aa4903125d34eba17d4/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "487e961c6ae072d969e148def0b0856c2367ae00", "url": "https://api.github.com/repos/rust-lang/rust/commits/487e961c6ae072d969e148def0b0856c2367ae00", "html_url": "https://github.com/rust-lang/rust/commit/487e961c6ae072d969e148def0b0856c2367ae00"}, {"sha": "303306cf5ede678719ec1324bb02d3d02c014183", "url": "https://api.github.com/repos/rust-lang/rust/commits/303306cf5ede678719ec1324bb02d3d02c014183", "html_url": "https://github.com/rust-lang/rust/commit/303306cf5ede678719ec1324bb02d3d02c014183"}], "stats": {"total": 52, "additions": 44, "deletions": 8}, "files": [{"sha": "854cb5f4e3b3f77a1791896e3f8df6d0eaba57dd", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -1085,6 +1085,15 @@ extern \"rust-intrinsic\" {\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n+    /// Perform a volatile load from the `src` pointer\n+    /// The pointer is not required to be aligned.\n+    #[cfg(not(stage0))]\n+    pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n+    /// Perform a volatile store to the `dst` pointer.\n+    /// The pointer is not required to be aligned.\n+    #[cfg(not(stage0))]\n+    pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n+\n     /// Returns the square root of an `f32`\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`"}, {"sha": "b34d0f1cd9070854c013d58fcfa43c1c7a220570", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -54,6 +54,7 @@ bitflags! {\n     pub struct MemFlags: u8 {\n         const VOLATILE = 1 << 0;\n         const NONTEMPORAL = 1 << 1;\n+        const UNALIGNED = 1 << 2;\n     }\n }\n \n@@ -602,7 +603,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n+            let align = if flags.contains(MemFlags::UNALIGNED) {\n+                1\n+            } else {\n+                align.abi() as c_uint\n+            };\n+            llvm::LLVMSetAlignment(store, align);\n             if flags.contains(MemFlags::VOLATILE) {\n                 llvm::LLVMSetVolatile(store, llvm::True);\n             }"}, {"sha": "9c5c0f730c161e8e8eb6a4fed1989a6e0c178c43", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -234,15 +234,20 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             memset_intrinsic(bx, true, substs.type_at(0),\n                              args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n-        \"volatile_load\" => {\n+        \"volatile_load\" | \"unaligned_volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n                 ptr = bx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n             }\n             let load = bx.volatile_load(ptr);\n+            let align = if name == \"unaligned_volatile_load\" {\n+                1\n+            } else {\n+                cx.align_of(tp_ty).abi() as u32\n+            };\n             unsafe {\n-                llvm::LLVMSetAlignment(load, cx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(load, align);\n             }\n             to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n@@ -251,6 +256,11 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             args[1].val.volatile_store(bx, dst);\n             return;\n         },\n+        \"unaligned_volatile_store\" => {\n+            let dst = args[0].deref(bx.cx);\n+            args[1].val.unaligned_volatile_store(bx, dst);\n+            return;\n+        },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.prefetch\"));"}, {"sha": "c433df51110e352b9cabc0b41418abd8858df37e", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -276,6 +276,10 @@ impl<'a, 'tcx> OperandValue {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n+    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n+    }\n+\n     pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }"}, {"sha": "af4356dc8de7816e1da472accfdf96903b0059c9", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -270,9 +270,9 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"roundf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n             \"roundf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n \n-            \"volatile_load\" =>\n+            \"volatile_load\" | \"unaligned_volatile_load\" =>\n                 (1, vec![ tcx.mk_imm_ptr(param(0)) ], param(0)),\n-            \"volatile_store\" =>\n+            \"volatile_store\" | \"unaligned_volatile_store\" =>\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n             \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" |"}, {"sha": "d214a20139c9ca8bfd597ed9c82247d08ebc7a8e", "filename": "src/test/run-make-fulldeps/volatile-intrinsics/main.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ba69d043efd5612aad2aa4903125d34eba17d4/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs?ref=06ba69d043efd5612aad2aa4903125d34eba17d4", "patch": "@@ -10,17 +10,24 @@\n \n #![feature(core_intrinsics, volatile)]\n \n-use std::intrinsics::{volatile_load, volatile_store};\n+use std::intrinsics::{\n+    unaligned_volatile_load, unaligned_volatile_store, volatile_load, volatile_store,\n+};\n use std::ptr::{read_volatile, write_volatile};\n \n pub fn main() {\n     unsafe {\n-        let mut i : isize = 1;\n+        let mut i: isize = 1;\n         volatile_store(&mut i, 2);\n         assert_eq!(volatile_load(&i), 2);\n     }\n     unsafe {\n-        let mut i : isize = 1;\n+        let mut i: isize = 1;\n+        unaligned_volatile_store(&mut i, 2);\n+        assert_eq!(unaligned_volatile_load(&i), 2);\n+    }\n+    unsafe {\n+        let mut i: isize = 1;\n         write_volatile(&mut i, 2);\n         assert_eq!(read_volatile(&i), 2);\n     }"}]}