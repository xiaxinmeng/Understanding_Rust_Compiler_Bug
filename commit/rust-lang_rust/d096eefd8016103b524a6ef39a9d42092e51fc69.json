{"sha": "d096eefd8016103b524a6ef39a9d42092e51fc69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOTZlZWZkODAxNjEwM2I1MjRhNmVmMzlhOWQ0MjA5MmU1MWZjNjk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-24T08:33:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-25T17:08:54Z"}, "message": "Use only the appropriate trait when looking up operator overloads.", "tree": {"sha": "797231e75509963c4722003d9ed602dc07351d19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/797231e75509963c4722003d9ed602dc07351d19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d096eefd8016103b524a6ef39a9d42092e51fc69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d096eefd8016103b524a6ef39a9d42092e51fc69", "html_url": "https://github.com/rust-lang/rust/commit/d096eefd8016103b524a6ef39a9d42092e51fc69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d096eefd8016103b524a6ef39a9d42092e51fc69/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "818203e9d25f99cb6fcdf7210c512bfb09f0956f", "url": "https://api.github.com/repos/rust-lang/rust/commits/818203e9d25f99cb6fcdf7210c512bfb09f0956f", "html_url": "https://github.com/rust-lang/rust/commit/818203e9d25f99cb6fcdf7210c512bfb09f0956f"}], "stats": {"total": 358, "additions": 198, "deletions": 160}, "files": [{"sha": "0dd0041344fdc0a17d441698d30e7363bf881e2b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 88, "deletions": 25, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d096eefd8016103b524a6ef39a9d42092e51fc69", "patch": "@@ -134,15 +134,14 @@ pub fn lookup(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_origin> {\n-    let impl_dups = @RefCell::new(HashSet::new());\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n         callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: impl_dups,\n+        impl_dups: @RefCell::new(HashSet::new()),\n         inherent_candidates: @RefCell::new(~[]),\n         extension_candidates: @RefCell::new(~[]),\n         deref_args: deref_args,\n@@ -164,11 +163,50 @@ pub fn lookup(\n \n     debug!(\"searching extension candidates\");\n     lcx.reset_candidates();\n-    lcx.push_bound_candidates(self_ty);\n+    lcx.push_bound_candidates(self_ty, None);\n     lcx.push_extension_candidates();\n     return lcx.search(self_ty);\n }\n \n+pub fn lookup_in_trait(\n+        fcx: @FnCtxt,\n+\n+        // In a call `a.b::<X, Y, ...>(...)`:\n+        expr: &ast::Expr,                   // The expression `a.b(...)`.\n+        self_expr: &ast::Expr,              // The expression `a`.\n+        callee_id: NodeId,                  /* Where to store `a.b`'s type,\n+                                             * also the scope of the call */\n+        m_name: ast::Name,                  // The name `b`.\n+        trait_did: DefId,                   // The trait to limit the lookup to.\n+        self_ty: ty::t,                     // The type of `a`.\n+        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        autoderef_receiver: AutoderefReceiverFlag)\n+     -> Option<method_origin> {\n+    let lcx = LookupContext {\n+        fcx: fcx,\n+        expr: expr,\n+        self_expr: self_expr,\n+        callee_id: callee_id,\n+        m_name: m_name,\n+        supplied_tps: supplied_tps,\n+        impl_dups: @RefCell::new(HashSet::new()),\n+        inherent_candidates: @RefCell::new(~[]),\n+        extension_candidates: @RefCell::new(~[]),\n+        deref_args: check::DoDerefArgs,\n+        check_traits: CheckTraitsOnly,\n+        autoderef_receiver: autoderef_receiver,\n+    };\n+\n+    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n+    debug!(\"method lookup_in_trait(self_ty={}, expr={}, self_expr={})\",\n+           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()));\n+\n+    lcx.push_bound_candidates(self_ty, Some(trait_did));\n+    lcx.push_extension_candidate(trait_did);\n+    lcx.search(self_ty)\n+}\n+\n pub struct LookupContext<'a> {\n     fcx: @FnCtxt,\n     expr: &'a ast::Expr,\n@@ -319,17 +357,17 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn push_bound_candidates(&self, self_ty: ty::t) {\n+    fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(self_ty, p);\n+                    self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n                 ty_self(..) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(self_ty);\n+                    self.push_inherent_candidates_from_self(self_ty, restrict_to);\n                 }\n                 _ => { /* No bound methods in these types */ }\n             }\n@@ -341,6 +379,19 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n+    fn push_extension_candidate(&self, trait_did: DefId) {\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n+\n+        // Look for explicit implementations.\n+        let trait_impls = self.tcx().trait_impls.borrow();\n+        for impl_infos in trait_impls.get().find(&trait_did).iter() {\n+            for impl_info in impl_infos.borrow().get().iter() {\n+                self.push_candidates_from_impl(\n+                    self.extension_candidates.borrow_mut().get(), *impl_info);\n+            }\n+        }\n+    }\n+\n     fn push_extension_candidates(&self) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n@@ -428,7 +479,7 @@ impl<'a> LookupContext<'a> {\n                 self.construct_transformed_self_ty_for_object(\n                     did, &rcvr_substs, &m);\n \n-            Candidate {\n+            Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n                 rcvr_substs: new_trait_ref.substs.clone(),\n                 method_ty: @m,\n@@ -438,49 +489,61 @@ impl<'a> LookupContext<'a> {\n                         method_num: method_num,\n                         real_index: vtable_index\n                     })\n-            }\n+            })\n         });\n     }\n \n     fn push_inherent_candidates_from_param(&self,\n                                            rcvr_ty: ty::t,\n+                                           restrict_to: Option<DefId>,\n                                            param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n             self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n+            restrict_to,\n             param_numbered(param_ty.idx));\n     }\n \n \n     fn push_inherent_candidates_from_self(&self,\n-                                          rcvr_ty: ty::t) {\n+                                          rcvr_ty: ty::t,\n+                                          restrict_to: Option<DefId>) {\n         debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n             [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            restrict_to,\n             param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&self,\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n+                                            restrict_to: Option<DefId>,\n                                             param: param_index) {\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n             |trait_ref, m, method_num, bound_num| {\n-            Candidate {\n-                rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n-                rcvr_substs: trait_ref.substs.clone(),\n-                method_ty: m,\n-                origin: method_param(\n-                                     method_param {\n+                match restrict_to {\n+                    Some(trait_did) => {\n+                        if trait_did != trait_ref.def_id {\n+                            return None;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                Some(Candidate {\n+                    rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n+                    rcvr_substs: trait_ref.substs.clone(),\n+                    method_ty: m,\n+                    origin: method_param(method_param {\n                         trait_id: trait_ref.def_id,\n                         method_num: method_num,\n                         param_num: param,\n                         bound_num: bound_num,\n                     })\n-            }\n+                })\n         })\n     }\n \n@@ -492,7 +555,7 @@ impl<'a> LookupContext<'a> {\n                                                             m: @ty::Method,\n                                                             method_num: uint,\n                                                             bound_num: uint|\n-                                                            -> Candidate) {\n+                                                            -> Option<Candidate>) {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -508,17 +571,17 @@ impl<'a> LookupContext<'a> {\n                 Some(pos) => {\n                     let method = trait_methods[pos];\n \n-                    let cand = mk_cand(bound_trait_ref, method,\n-                                       pos, this_bound_idx);\n-\n-                    debug!(\"pushing inherent candidate for param: {:?}\", cand);\n-                    let mut inherent_candidates = self.inherent_candidates\n-                                                      .borrow_mut();\n-                    inherent_candidates.get().push(cand);\n+                    match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n+                        Some(cand) => {\n+                            debug!(\"pushing inherent candidate for param: {:?}\", cand);\n+                            self.inherent_candidates.borrow_mut().get().push(cand);\n+                        }\n+                        None => {}\n+                    }\n                 }\n                 None => {\n                     debug!(\"trait doesn't contain method: {:?}\",\n-                    bound_trait_ref.def_id);\n+                        bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n             }"}, {"sha": "0b26bb1b218229248e78bea9d60b1ffd95a833e6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 94, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d096eefd8016103b524a6ef39a9d42092e51fc69", "patch": "@@ -96,7 +96,7 @@ use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n-use middle::typeck::check::method::{CheckTraitsOnly, DontAutoderefReceiver};\n+use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n@@ -1936,35 +1936,34 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         op_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n+                        trait_did: Option<ast::DefId>,\n                         args: &[@ast::Expr],\n-                        deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: ||,\n-                        _expected_result: Option<ty::t>\n-                       )\n-                     -> ty::t {\n-        match method::lookup(fcx, op_ex, args[0],\n-                             callee_id, opname, self_t, [],\n-                             deref_args, CheckTraitsOnly, autoderef_receiver) {\n-            Some(ref origin) => {\n+                        unbound_method: ||) -> ty::t {\n+        let origin = match trait_did {\n+            Some(trait_did) => {\n+                method::lookup_in_trait(fcx, op_ex, args[0], callee_id, opname,\n+                                        trait_did, self_t, [], autoderef_receiver)\n+            }\n+            None => None\n+        };\n+        match origin {\n+            Some(origin) => {\n                 let method_ty = fcx.node_ty(callee_id);\n                 let method_map = fcx.inh.method_map;\n-                {\n-                    let mut method_map = method_map.borrow_mut();\n-                    method_map.get().insert(op_ex.id, *origin);\n-                }\n+                method_map.borrow_mut().get().insert(op_ex.id, origin);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n-                                            args, deref_args)\n+                                            args, DoDerefArgs)\n             }\n-            _ => {\n+            None => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err();\n                 check_method_argument_types(fcx, op_ex.span,\n                                             expected_ty, op_ex,\n-                                            args, deref_args);\n+                                            args, DoDerefArgs);\n                 ty::mk_err()\n             }\n         }\n@@ -1977,10 +1976,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                    op: ast::BinOp,\n                    lhs: @ast::Expr,\n                    rhs: @ast::Expr,\n-                   // Used only in the error case\n-                   expected_result: Option<ty::t>,\n-                   is_binop_assignment: IsBinopAssignment\n-                  ) {\n+                   is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         check_expr(fcx, lhs);\n@@ -2004,12 +2000,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n-                ast::BiGt => {\n-                    ty::mk_bool()\n-                }\n-                _ => {\n-                    lhs_t\n-                }\n+                ast::BiGt => ty::mk_bool(),\n+                _ => lhs_t\n             };\n \n             fcx.write_ty(expr.id, result_t);\n@@ -2030,16 +2022,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n \n         // Check for overloaded operators if not an assignment.\n-        let result_t;\n-        if is_binop_assignment == SimpleBinop {\n-            result_t = check_user_binop(fcx,\n-                                        callee_id,\n-                                        expr,\n-                                        lhs,\n-                                        lhs_t,\n-                                        op,\n-                                        rhs,\n-                                        expected_result);\n+        let result_t = if is_binop_assignment == SimpleBinop {\n+            check_user_binop(fcx, callee_id, expr, lhs, lhs_t, op, rhs)\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n@@ -2051,8 +2035,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                    lhs_t,\n                                    None);\n             check_expr(fcx, rhs);\n-            result_t = ty::mk_err();\n-        }\n+            ty::mk_err()\n+        };\n \n         fcx.write_ty(expr.id, result_t);\n         if ty::type_is_error(result_t) {\n@@ -2066,48 +2050,54 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: @ast::Expr,\n-                       expected_result: Option<ty::t>) -> ty::t {\n+                        rhs: @ast::Expr) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n-        match ast_util::binop_to_method_name(op) {\n-            Some(ref name) => {\n-                let if_op_unbound = || {\n-                    fcx.type_error_message(ex.span, |actual| {\n-                        format!(\"binary operation `{}` cannot be applied \\\n-                              to type `{}`\",\n-                             ast_util::binop_to_str(op), actual)},\n-                            lhs_resolved_t, None)\n-                };\n-                return lookup_op_method(fcx, callee_id, ex, lhs_resolved_t,\n-                                        token::intern(*name), [lhs_expr, rhs],\n-                                        DoDerefArgs,DontAutoderefReceiver,\n-                                        if_op_unbound, expected_result);\n+        let lang = tcx.lang_items;\n+        let (name, trait_did) = match op {\n+            ast::BiAdd => (\"add\", lang.add_trait()),\n+            ast::BiSub => (\"sub\", lang.sub_trait()),\n+            ast::BiMul => (\"mul\", lang.mul_trait()),\n+            ast::BiDiv => (\"div\", lang.div_trait()),\n+            ast::BiRem => (\"rem\", lang.rem_trait()),\n+            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+            ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+            ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+            ast::BiShl => (\"shl\", lang.shl_trait()),\n+            ast::BiShr => (\"shr\", lang.shr_trait()),\n+            ast::BiLt => (\"lt\", lang.ord_trait()),\n+            ast::BiLe => (\"le\", lang.ord_trait()),\n+            ast::BiGe => (\"ge\", lang.ord_trait()),\n+            ast::BiGt => (\"gt\", lang.ord_trait()),\n+            ast::BiEq => (\"eq\", lang.eq_trait()),\n+            ast::BiNe => (\"ne\", lang.eq_trait()),\n+            ast::BiAnd | ast::BiOr => {\n+                check_expr(fcx, rhs);\n+                return ty::mk_err();\n             }\n-            None => ()\n         };\n-        check_expr(fcx, rhs);\n-\n-        ty::mk_err()\n+        lookup_op_method(fcx, callee_id, ex, lhs_resolved_t, token::intern(name),\n+                         trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n+            fcx.type_error_message(ex.span, |actual| {\n+                format!(\"binary operation `{}` cannot be applied to type `{}`\",\n+                    ast_util::binop_to_str(op), actual)\n+            }, lhs_resolved_t, None)\n+        })\n     }\n \n     fn check_user_unop(fcx: @FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n+                       trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n                        rhs_expr: @ast::Expr,\n-                       rhs_t: ty::t,\n-                       expected_t: Option<ty::t>)\n-                    -> ty::t {\n-       lookup_op_method(\n-            fcx, callee_id, ex, rhs_t, token::intern(mname),\n-            [rhs_expr], DoDerefArgs, DontAutoderefReceiver,\n-            || {\n-                fcx.type_error_message(ex.span, |actual| {\n-                    format!(\"cannot apply unary operator `{}` to type `{}`\",\n-                         op_str, actual)\n-                }, rhs_t, None);\n-            }, expected_t)\n+                       rhs_t: ty::t) -> ty::t {\n+       lookup_op_method(fcx, callee_id, ex, rhs_t, token::intern(mname),\n+                        trait_did, [rhs_expr], DontAutoderefReceiver, || {\n+            fcx.type_error_message(ex.span, |actual| {\n+                format!(\"cannot apply unary operator `{}` to type `{}`\", op_str, actual)\n+            }, rhs_t, None);\n+        })\n     }\n \n     // Resolves `expected` by a single level if it is a variable and passes it\n@@ -2631,14 +2621,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx,\n-                    callee_id,\n-                    expr,\n-                    op,\n-                    lhs,\n-                    rhs,\n-                    expected,\n-                    SimpleBinop);\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, SimpleBinop);\n \n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n@@ -2652,14 +2635,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprAssignOp(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx,\n-                    callee_id,\n-                    expr,\n-                    op,\n-                    lhs,\n-                    rhs,\n-                    expected,\n-                    BinopAssignment);\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, BinopAssignment);\n \n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -2734,18 +2710,19 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n-                        oprnd_t = check_user_unop(fcx, callee_id,\n-                            \"!\", \"not\", expr, oprnd, oprnd_t,\n-                                                  expected);\n+                        oprnd_t = check_user_unop(fcx, callee_id, \"!\", \"not\",\n+                                                  tcx.lang_items.not_trait(),\n+                                                  expr, oprnd, oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n-                        oprnd_t = check_user_unop(fcx, callee_id,\n-                            \"-\", \"neg\", expr, oprnd, oprnd_t, expected);\n+                        oprnd_t = check_user_unop(fcx, callee_id, \"-\", \"neg\",\n+                                                  tcx.lang_items.neg_trait(),\n+                                                  expr, oprnd, oprnd_t);\n                     }\n                 }\n             }\n@@ -3160,11 +3137,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                     expr,\n                                                     resolved,\n                                                     token::intern(\"index\"),\n+                                                    tcx.lang_items.index_trait(),\n                                                     [base, idx],\n-                                                    DoDerefArgs,\n                                                     AutoderefReceiver,\n-                                                    error_message,\n-                                                    expected);\n+                                                    error_message);\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }"}, {"sha": "f6066e5385d6ccfd6bde09417cfef8c43c13b9fe", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d096eefd8016103b524a6ef39a9d42092e51fc69", "patch": "@@ -79,48 +79,26 @@ pub fn def_id_of_def(d: Def) -> DefId {\n     }\n }\n \n-pub fn binop_to_str(op: BinOp) -> ~str {\n+pub fn binop_to_str(op: BinOp) -> &'static str {\n     match op {\n-      BiAdd => return ~\"+\",\n-      BiSub => return ~\"-\",\n-      BiMul => return ~\"*\",\n-      BiDiv => return ~\"/\",\n-      BiRem => return ~\"%\",\n-      BiAnd => return ~\"&&\",\n-      BiOr => return ~\"||\",\n-      BiBitXor => return ~\"^\",\n-      BiBitAnd => return ~\"&\",\n-      BiBitOr => return ~\"|\",\n-      BiShl => return ~\"<<\",\n-      BiShr => return ~\">>\",\n-      BiEq => return ~\"==\",\n-      BiLt => return ~\"<\",\n-      BiLe => return ~\"<=\",\n-      BiNe => return ~\"!=\",\n-      BiGe => return ~\">=\",\n-      BiGt => return ~\">\"\n-    }\n-}\n-\n-pub fn binop_to_method_name(op: BinOp) -> Option<~str> {\n-    match op {\n-      BiAdd => return Some(~\"add\"),\n-      BiSub => return Some(~\"sub\"),\n-      BiMul => return Some(~\"mul\"),\n-      BiDiv => return Some(~\"div\"),\n-      BiRem => return Some(~\"rem\"),\n-      BiBitXor => return Some(~\"bitxor\"),\n-      BiBitAnd => return Some(~\"bitand\"),\n-      BiBitOr => return Some(~\"bitor\"),\n-      BiShl => return Some(~\"shl\"),\n-      BiShr => return Some(~\"shr\"),\n-      BiLt => return Some(~\"lt\"),\n-      BiLe => return Some(~\"le\"),\n-      BiGe => return Some(~\"ge\"),\n-      BiGt => return Some(~\"gt\"),\n-      BiEq => return Some(~\"eq\"),\n-      BiNe => return Some(~\"ne\"),\n-      BiAnd | BiOr => return None\n+        BiAdd => \"+\",\n+        BiSub => \"-\",\n+        BiMul => \"*\",\n+        BiDiv => \"/\",\n+        BiRem => \"%\",\n+        BiAnd => \"&&\",\n+        BiOr => \"||\",\n+        BiBitXor => \"^\",\n+        BiBitAnd => \"&\",\n+        BiBitOr => \"|\",\n+        BiShl => \"<<\",\n+        BiShr => \">>\",\n+        BiEq => \"==\",\n+        BiLt => \"<\",\n+        BiLe => \"<=\",\n+        BiNe => \"!=\",\n+        BiGe => \">=\",\n+        BiGt => \">\"\n     }\n }\n "}, {"sha": "1f57c4cf93a28a098b888c17518c8efc534ab91d", "filename": "src/test/compile-fail/trait-resolution-in-overloaded-op.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d096eefd8016103b524a6ef39a9d42092e51fc69/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs?ref=d096eefd8016103b524a6ef39a9d42092e51fc69", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #12402 Operator overloading only considers the method name, not which trait is implemented\n+\n+trait MyMul<Rhs, Res> {\n+    fn mul(&self, rhs: &Rhs) -> Res;\n+}\n+\n+fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 {\n+    a * b //~ ERROR binary operation `*` cannot be applied to type `&T`\n+}\n+\n+fn main() {}"}]}