{"sha": "ac83e34dc6c2bb3b5f181f923560d810dcdb558c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODNlMzRkYzZjMmJiM2I1ZjE4MWY5MjM1NjBkODEwZGNkYjU1OGM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-06-04T20:59:57Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-06-04T21:10:08Z"}, "message": "rustc: Report unimplemented #fmt features with spans", "tree": {"sha": "f8140ecbf8629e305c52ead6d6886d0dd7a65790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8140ecbf8629e305c52ead6d6886d0dd7a65790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac83e34dc6c2bb3b5f181f923560d810dcdb558c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac83e34dc6c2bb3b5f181f923560d810dcdb558c", "html_url": "https://github.com/rust-lang/rust/commit/ac83e34dc6c2bb3b5f181f923560d810dcdb558c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac83e34dc6c2bb3b5f181f923560d810dcdb558c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd588519bdd7950c6a4c398f8fffd00fbd2238d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd588519bdd7950c6a4c398f8fffd00fbd2238d3", "html_url": "https://github.com/rust-lang/rust/commit/dd588519bdd7950c6a4c398f8fffd00fbd2238d3"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "ed9636bd163c9f8472dee75ad95886b3a9e53249", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ac83e34dc6c2bb3b5f181f923560d810dcdb558c/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac83e34dc6c2bb3b5f181f923560d810dcdb558c/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=ac83e34dc6c2bb3b5f181f923560d810dcdb558c", "patch": "@@ -149,7 +149,8 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n \n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n-    fn make_rt_conv_expr(parser p, common::span sp, &conv cnv) -> @ast::expr {\n+    fn make_rt_conv_expr(&ext_ctxt cx,\n+                         parser p, common::span sp, &conv cnv) -> @ast::expr {\n \n         fn make_flags(parser p, common::span sp, vec[flag] flags)\n                 -> @ast::expr {\n@@ -186,7 +187,8 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n             ret make_vec_expr(p, sp, flagexprs);\n         }\n \n-        fn make_count(parser p, common::span sp, &count cnt) -> @ast::expr {\n+        fn make_count(&ext_ctxt cx,\n+                      parser p, common::span sp, &count cnt) -> @ast::expr {\n             alt (cnt) {\n                 case (count_implied) {\n                     ret make_rt_path_expr(p, sp, \"count_implied\");\n@@ -198,8 +200,7 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                     ret make_call(p, sp, count_is_path, count_is_args);\n                 }\n                 case (_) {\n-                    log_err \"not implemented\";\n-                    fail;\n+                    cx.span_unimpl(sp, \"unimplemented #fmt conversion\");\n                 }\n             }\n         }\n@@ -244,8 +245,8 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n         }\n \n         auto rt_conv_flags = make_flags(p, sp, cnv.flags);\n-        auto rt_conv_width = make_count(p, sp, cnv.width);\n-        auto rt_conv_precision = make_count(p, sp, cnv.precision);\n+        auto rt_conv_width = make_count(cx, p, sp, cnv.width);\n+        auto rt_conv_precision = make_count(cx, p, sp, cnv.precision);\n         auto rt_conv_ty = make_ty(p, sp, cnv.ty);\n         ret make_conv_rec(p,\n                           sp,\n@@ -255,11 +256,11 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                           rt_conv_ty);\n     }\n \n-    fn make_conv_call(parser p, common::span sp, str conv_type,\n+    fn make_conv_call(&ext_ctxt cx, parser p, common::span sp, str conv_type,\n                       &conv cnv, @ast::expr arg) -> @ast::expr {\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n-        auto cnv_expr = make_rt_conv_expr(p, sp, cnv);\n+        auto cnv_expr = make_rt_conv_expr(cx, p, sp, cnv);\n         auto args = [cnv_expr, arg];\n         ret make_call(p, arg.span, path, args);\n     }\n@@ -292,8 +293,7 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n             case (option::none) {\n             }\n             case (_) {\n-                log_err unsupported;\n-                fail;\n+                cx.span_unimpl(sp, unsupported);\n             }\n         }\n \n@@ -316,8 +316,7 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                 case (flag_left_zero_pad) {\n                 }\n                 case (_) {\n-                    log_err unsupported;\n-                    fail;\n+                    cx.span_unimpl(sp, unsupported);\n                 }\n             }\n         }\n@@ -328,8 +327,7 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n             case (count_is(_)) {\n             }\n             case (_) {\n-                log_err unsupported;\n-                fail;\n+                cx.span_unimpl(sp, unsupported);\n             }\n         }\n \n@@ -339,43 +337,41 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n             case (count_is(_)) {\n             }\n             case (_) {\n-                log_err unsupported;\n-                fail;\n+                cx.span_unimpl(sp, unsupported);\n             }\n         }\n \n         alt (cnv.ty) {\n             case (ty_str) {\n-                ret make_conv_call(p, arg.span, \"str\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"str\", cnv, arg);\n             }\n             case (ty_int(?sign)) {\n                 alt (sign) {\n                     case (signed) {\n-                        ret make_conv_call(p, arg.span, \"int\", cnv, arg);\n+                        ret make_conv_call(cx, p, arg.span, \"int\", cnv, arg);\n                     }\n                     case (unsigned) {\n-                        ret make_conv_call(p, arg.span, \"uint\", cnv, arg);\n+                        ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n                     }\n                 }\n             }\n             case (ty_bool) {\n-                ret make_conv_call(p, arg.span, \"bool\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"bool\", cnv, arg);\n             }\n             case (ty_char) {\n-                ret make_conv_call(p, arg.span, \"char\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"char\", cnv, arg);\n             }\n             case (ty_hex(_)) {\n-                ret make_conv_call(p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n             }\n             case (ty_bits) {\n-                ret make_conv_call(p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n             }\n             case (ty_octal) {\n-                ret make_conv_call(p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n             }\n             case (_) {\n-                log_err unsupported;\n-                fail;\n+                cx.span_unimpl(sp, unsupported);\n             }\n         }\n     }"}]}