{"sha": "683197975c119e4c03588fa729dee4f87902f534", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MzE5Nzk3NWMxMTllNGMwMzU4OGZhNzI5ZGVlNGY4NzkwMmY1MzQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-01T01:13:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-01T01:59:46Z"}, "message": "rustc: Switch tuple structs to have private fields\n\nThis is a continuation of the work done in #13184 to make struct fields private\nby default. This commit finishes RFC 4 by making all tuple structs have private\nfields by default. Note that enum variants are not affected.\n\nA tuple struct having a private field means that it cannot be matched on in a\npattern match (both refutable and irrefutable), and it also cannot have a value\nspecified to be constructed. Similarly to private fields, switching the type of\na private field in a tuple struct should be able to be done in a backwards\ncompatible way.\n\nThe one snag that I ran into which wasn't mentioned in the RFC is that this\ncommit also forbids taking the value of a tuple struct constructor. For example,\nthis code now fails to compile:\n\n    mod a {\n        pub struct A(int);\n    }\n\n    let a: fn(int) -> a::A = a::A; //~ ERROR: first field is private\n\nAlthough no fields are bound in this example, it exposes implementation details\nthrough the type itself. For this reason, taking the value of a struct\nconstructor with private fields is forbidden (outside the containing module).\n\nRFC: 0004-private-fields", "tree": {"sha": "3f547b7f4bd572eda171dd378a455584e60eefed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f547b7f4bd572eda171dd378a455584e60eefed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/683197975c119e4c03588fa729dee4f87902f534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/683197975c119e4c03588fa729dee4f87902f534", "html_url": "https://github.com/rust-lang/rust/commit/683197975c119e4c03588fa729dee4f87902f534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/683197975c119e4c03588fa729dee4f87902f534/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "html_url": "https://github.com/rust-lang/rust/commit/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64"}], "stats": {"total": 301, "additions": 270, "deletions": 31}, "files": [{"sha": "8845a2acbd614ea4584f735a307e3cbac3c67cd0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -311,3 +311,11 @@ pub fn get_exported_macros(cstore: &cstore::CStore,\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_exported_macros(cdata)\n }\n+\n+pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n+                                           def_id: ast::DefId)\n+    -> Option<ast::DefId>\n+{\n+    let cdata = cstore.get_crate_data(def_id.krate);\n+    decoder::get_tuple_struct_definition_if_ctor(cdata, def_id.node)\n+}"}, {"sha": "300b8ff2da4c528031e282f81ca8499292d663b3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -962,23 +962,26 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: ast::NodeId) -> Option<ast::NodeId> {\n+                                           node_id: ast::NodeId)\n+    -> Option<ast::DefId>\n+{\n     let item = lookup_item(node_id, cdata.data());\n     let mut ret = None;\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n         ret = Some(item_reqd_and_translated_parent_item(cdata.cnum, item));\n         false\n     });\n-    ret.map(|x| x.node)\n+    ret\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n-                      node_id: ast::NodeId,\n+                      orig_node_id: ast::NodeId,\n                       f: |Vec<@ast::MetaItem> |) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n-    let node_id = get_tuple_struct_definition_if_ctor(cdata, node_id).unwrap_or(node_id);\n+    let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n+    let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n     let item = lookup_item(node_id, cdata.data());\n     reader::tagged_docs(item, tag_attributes, |attributes| {\n         reader::tagged_docs(attributes, tag_attribute, |attribute| {"}, {"sha": "9d9faee36450a4fb0e9ddae98e9938c03c06b186", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 98, "deletions": 21, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -14,6 +14,7 @@\n \n use std::mem::replace;\n \n+use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n@@ -358,6 +359,12 @@ enum PrivacyResult {\n     DisallowedBy(ast::NodeId),\n }\n \n+enum FieldName {\n+    UnnamedField(uint), // index\n+    // FIXME #6993: change type (and name) from Ident to Name\n+    NamedField(ast::Ident),\n+}\n+\n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> ~str {\n@@ -560,18 +567,23 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n \n     // Checks that a field is in scope.\n-    // FIXME #6993: change type (and name) from Ident to Name\n-    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n-        for field in ty::lookup_struct_fields(self.tcx, id).iter() {\n-            if field.name != ident.name { continue; }\n-            if field.vis == ast::Public { break }\n-            if !is_local(field.id) ||\n-               !self.private_accessible(field.id.node) {\n-                self.tcx.sess.span_err(span,\n-                                       format!(\"field `{}` is private\",\n-                                               token::get_ident(ident)))\n+    fn check_field(&mut self, span: Span, id: ast::DefId,\n+                   name: FieldName) {\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let field = match name {\n+            NamedField(ident) => {\n+                fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n-            break;\n+            UnnamedField(idx) => fields.get(idx)\n+        };\n+        if field.vis == ast::Public { return }\n+        if !is_local(field.id) || !self.private_accessible(field.id.node) {\n+            let msg = match name {\n+                NamedField(name) => format!(\"field `{}` is private\",\n+                                            token::get_ident(name)),\n+                UnnamedField(idx) => format!(\"field \\\\#{} is private\", idx + 1),\n+            };\n+            self.tcx.sess.span_err(span, msg);\n         }\n     }\n \n@@ -634,10 +646,11 @@ impl<'a> PrivacyVisitor<'a> {\n                             _ => {},\n                         }\n                     }\n-                    // If an import is not used in either namespace, we still want to check\n-                    // that it could be legal. Therefore we check in both namespaces and only\n-                    // report an error if both would be illegal. We only report one error,\n-                    // even if it is illegal to import from both namespaces.\n+                    // If an import is not used in either namespace, we still\n+                    // want to check that it could be legal. Therefore we check\n+                    // in both namespaces and only report an error if both would\n+                    // be illegal. We only report one error, even if it is\n+                    // illegal to import from both namespaces.\n                     match (value_priv, check_value, type_priv, check_type) {\n                         (Some(p), resolve::Unused, None, _) |\n                         (None, _, Some(p), resolve::Unused) => {\n@@ -701,7 +714,8 @@ impl<'a> PrivacyVisitor<'a> {\n             // is whether the trait itself is accessible or not.\n             MethodParam(MethodParam { trait_id: trait_id, .. }) |\n             MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_id, None, \"source trait\"));\n+                self.report_error(self.ensure_public(span, trait_id, None,\n+                                                     \"source trait\"));\n             }\n         }\n     }\n@@ -726,7 +740,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n                                                    &*self.method_map.borrow())).sty {\n                     ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, ident);\n+                        self.check_field(expr.span, id, NamedField(ident));\n                     }\n                     _ => {}\n                 }\n@@ -749,15 +763,16 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n-                            self.check_field(expr.span, id, field.ident.node);\n+                            self.check_field(expr.span, id,\n+                                             NamedField(field.ident.node));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get_copy(&expr.id) {\n                             ast::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n-                                                     field.ident.node);\n+                                                     NamedField(field.ident.node));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(expr.span,\n@@ -772,6 +787,46 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                                             struct type?!\"),\n                 }\n             }\n+            ast::ExprPath(..) => {\n+                let guard = |did: ast::DefId| {\n+                    let fields = ty::lookup_struct_fields(self.tcx, did);\n+                    let any_priv = fields.iter().any(|f| {\n+                        f.vis != ast::Public && (\n+                            !is_local(f.id) ||\n+                            !self.private_accessible(f.id.node))\n+                    });\n+                    if any_priv {\n+                        self.tcx.sess.span_err(expr.span,\n+                            \"cannot invoke tuple struct constructor \\\n+                             with private fields\");\n+                    }\n+                };\n+                match self.tcx.def_map.borrow().find(&expr.id) {\n+                    Some(&ast::DefStruct(did)) => {\n+                        guard(if is_local(did) {\n+                            local_def(self.tcx.map.get_parent(did.node))\n+                        } else {\n+                            // \"tuple structs\" with zero fields (such as\n+                            // `pub struct Foo;`) don't have a ctor_id, hence\n+                            // the unwrap_or to the same struct id.\n+                            let maybe_did =\n+                                csearch::get_tuple_struct_definition_if_ctor(\n+                                    &self.tcx.sess.cstore, did);\n+                            maybe_did.unwrap_or(did)\n+                        })\n+                    }\n+                    // Tuple struct constructors across crates are identified as\n+                    // DefFn types, so we explicitly handle that case here.\n+                    Some(&ast::DefFn(did, _)) if !is_local(did) => {\n+                        match csearch::get_tuple_struct_definition_if_ctor(\n+                                    &self.tcx.sess.cstore, did) {\n+                            Some(did) => guard(did),\n+                            None => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n             _ => {}\n         }\n \n@@ -821,15 +876,16 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n-                            self.check_field(pattern.span, id, field.ident);\n+                            self.check_field(pattern.span, id,\n+                                             NamedField(field.ident));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().find(&pattern.id) {\n                             Some(&ast::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n-                                                     field.ident);\n+                                                     NamedField(field.ident));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(pattern.span,\n@@ -844,6 +900,27 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                                  struct type?!\"),\n                 }\n             }\n+\n+            // Patterns which bind no fields are allowable (the path is check\n+            // elsewhere).\n+            ast::PatEnum(_, Some(ref fields)) => {\n+                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for (i, field) in fields.iter().enumerate() {\n+                            match field.node {\n+                                ast::PatWild(..) => continue,\n+                                _ => {}\n+                            }\n+                            self.check_field(field.span, id, UnnamedField(i));\n+                        }\n+                    }\n+                    ty::ty_enum(..) => {\n+                        // enum fields have no privacy at this time\n+                    }\n+                    _ => {}\n+                }\n+\n+            }\n             _ => {}\n         }\n "}, {"sha": "0f082c7e2f1f91d1c7a60e9e3fa71b28afea30ac", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -493,10 +493,10 @@ pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n-    ExprVec(Vec<@Expr> , Mutability),\n-    ExprCall(@Expr, Vec<@Expr> ),\n-    ExprMethodCall(Ident, Vec<P<Ty>> , Vec<@Expr> ),\n-    ExprTup(Vec<@Expr> ),\n+    ExprVec(Vec<@Expr>, Mutability),\n+    ExprCall(@Expr, Vec<@Expr>),\n+    ExprMethodCall(Ident, Vec<P<Ty>>, Vec<@Expr>),\n+    ExprTup(Vec<@Expr>),\n     ExprBinary(BinOp, @Expr, @Expr),\n     ExprUnary(UnOp, @Expr),\n     ExprLit(@Lit),\n@@ -508,14 +508,14 @@ pub enum Expr_ {\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, Vec<Arm> ),\n+    ExprMatch(@Expr, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n     ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, Vec<P<Ty>> ),\n+    ExprField(@Expr, Ident, Vec<P<Ty>>),\n     ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,"}, {"sha": "2fb9d9923cb76b6f50380b290485b0b5d1d77e69", "filename": "src/test/auxiliary/privacy-tuple-struct.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct A(());\n+pub struct B(int);\n+pub struct C(pub int, int);\n+pub struct D(pub int);"}, {"sha": "c057236265e94ad218c05fa6cac2671517e4a539", "filename": "src/test/compile-fail/privacy5.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/683197975c119e4c03588fa729dee4f87902f534/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683197975c119e4c03588fa729dee4f87902f534/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs?ref=683197975c119e4c03588fa729dee4f87902f534", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:privacy-tuple-struct.rs\n+// ignore-fast\n+\n+extern crate other = \"privacy-tuple-struct\";\n+\n+mod a {\n+    pub struct A(());\n+    pub struct B(int);\n+    pub struct C(pub int, int);\n+    pub struct D(pub int);\n+\n+    fn test() {\n+        let a = A(());\n+        let b = B(2);\n+        let c = C(2, 3);\n+        let d = D(4);\n+\n+        let A(()) = a;\n+        let A(_) = a;\n+        match a { A(()) => {} }\n+        match a { A(_) => {} }\n+\n+        let B(_) = b;\n+        let B(_b) = b;\n+        match b { B(_) => {} }\n+        match b { B(_b) => {} }\n+        match b { B(1) => {} B(_) => {} }\n+\n+        let C(_, _) = c;\n+        let C(_a, _) = c;\n+        let C(_, _b) = c;\n+        let C(_a, _b) = c;\n+        match c { C(_, _) => {} }\n+        match c { C(_a, _) => {} }\n+        match c { C(_, _b) => {} }\n+        match c { C(_a, _b) => {} }\n+\n+        let D(_) = d;\n+        let D(_d) = d;\n+        match d { D(_) => {} }\n+        match d { D(_d) => {} }\n+        match d { D(1) => {} D(_) => {} }\n+\n+        let a2 = A;\n+        let b2 = B;\n+        let c2 = C;\n+        let d2 = D;\n+    }\n+}\n+\n+fn this_crate() {\n+    let a = a::A(()); //~ ERROR: cannot invoke tuple struct constructor\n+    let b = a::B(2); //~ ERROR: cannot invoke tuple struct constructor\n+    let c = a::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let d = a::D(4);\n+\n+    let a::A(()) = a; //~ ERROR: field #1 is private\n+    let a::A(_) = a;\n+    match a { a::A(()) => {} } //~ ERROR: field #1 is private\n+    match a { a::A(_) => {} }\n+\n+    let a::B(_) = b;\n+    let a::B(_b) = b; //~ ERROR: field #1 is private\n+    match b { a::B(_) => {} }\n+    match b { a::B(_b) => {} } //~ ERROR: field #1 is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field #1 is private\n+\n+    let a::C(_, _) = c;\n+    let a::C(_a, _) = c;\n+    let a::C(_, _b) = c; //~ ERROR: field #2 is private\n+    let a::C(_a, _b) = c; //~ ERROR: field #2 is private\n+    match c { a::C(_, _) => {} }\n+    match c { a::C(_a, _) => {} }\n+    match c { a::C(_, _b) => {} } //~ ERROR: field #2 is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR: field #2 is private\n+\n+    let a::D(_) = d;\n+    let a::D(_d) = d;\n+    match d { a::D(_) => {} }\n+    match d { a::D(_d) => {} }\n+    match d { a::D(1) => {} a::D(_) => {} }\n+\n+    let a2 = a::A; //~ ERROR: cannot invoke tuple struct constructor\n+    let b2 = a::B; //~ ERROR: cannot invoke tuple struct constructor\n+    let c2 = a::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let d2 = a::D;\n+}\n+\n+fn xcrate() {\n+    let a = other::A(()); //~ ERROR: cannot invoke tuple struct constructor\n+    let b = other::B(2); //~ ERROR: cannot invoke tuple struct constructor\n+    let c = other::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let d = other::D(4);\n+\n+    let other::A(()) = a; //~ ERROR: field #1 is private\n+    let other::A(_) = a;\n+    match a { other::A(()) => {} } //~ ERROR: field #1 is private\n+    match a { other::A(_) => {} }\n+\n+    let other::B(_) = b;\n+    let other::B(_b) = b; //~ ERROR: field #1 is private\n+    match b { other::B(_) => {} }\n+    match b { other::B(_b) => {} } //~ ERROR: field #1 is private\n+    match b { other::B(1) => {} other::B(_) => {} } //~ ERROR: field #1 is private\n+\n+    let other::C(_, _) = c;\n+    let other::C(_a, _) = c;\n+    let other::C(_, _b) = c; //~ ERROR: field #2 is private\n+    let other::C(_a, _b) = c; //~ ERROR: field #2 is private\n+    match c { other::C(_, _) => {} }\n+    match c { other::C(_a, _) => {} }\n+    match c { other::C(_, _b) => {} } //~ ERROR: field #2 is private\n+    match c { other::C(_a, _b) => {} } //~ ERROR: field #2 is private\n+\n+    let other::D(_) = d;\n+    let other::D(_d) = d;\n+    match d { other::D(_) => {} }\n+    match d { other::D(_d) => {} }\n+    match d { other::D(1) => {} other::D(_) => {} }\n+\n+    let a2 = other::A; //~ ERROR: cannot invoke tuple struct constructor\n+    let b2 = other::B; //~ ERROR: cannot invoke tuple struct constructor\n+    let c2 = other::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let d2 = other::D;\n+}\n+\n+fn main() {}"}]}