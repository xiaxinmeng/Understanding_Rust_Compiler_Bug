{"sha": "381b445ff5751f9f39ec672b623372dff09c276e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MWI0NDVmZjU3NTFmOWYzOWVjNjcyYjYyMzM3MmRmZjA5YzI3NmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T19:25:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T19:25:10Z"}, "message": "Auto merge of #77274 - tmiasko:liveness-cnd, r=lcnr\n\nLiveness refactoring continued\n\n* Move body_owner field from IrMaps to Liveness (the only user of the field).\n* Use upvars instead of FnKind to check for closures (avoids FnKind, will be useful when checking all bodies, not just fns).\n* Use visit_param to add variables corresponding to params.\n* Store upvars_mentioned inside Liveness struct.\n* Inline visitor implementation for IrMaps, avoiding unnecessary indirection.\n* Test interaction with automatically_derived attribute (not covered by any of existing tests).\n\nNo functional changes intended.", "tree": {"sha": "5b6a16984d37853458ad3d9000df188dca01f238", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b6a16984d37853458ad3d9000df188dca01f238"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/381b445ff5751f9f39ec672b623372dff09c276e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/381b445ff5751f9f39ec672b623372dff09c276e", "html_url": "https://github.com/rust-lang/rust/commit/381b445ff5751f9f39ec672b623372dff09c276e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/381b445ff5751f9f39ec672b623372dff09c276e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b77a6a20021cb8783111c04e9260963f15b550e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b77a6a20021cb8783111c04e9260963f15b550e", "html_url": "https://github.com/rust-lang/rust/commit/9b77a6a20021cb8783111c04e9260963f15b550e"}, {"sha": "063d5e9d8bdf9f0b26817265ca90e246bb20e379", "url": "https://api.github.com/repos/rust-lang/rust/commits/063d5e9d8bdf9f0b26817265ca90e246bb20e379", "html_url": "https://github.com/rust-lang/rust/commit/063d5e9d8bdf9f0b26817265ca90e246bb20e379"}], "stats": {"total": 462, "additions": 244, "deletions": 218}, "files": [{"sha": "eb2f40a82d1f1600c86323636dc3472f32c621c7", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 191, "deletions": 218, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/381b445ff5751f9f39ec672b623372dff09c276e/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381b445ff5751f9f39ec672b623372dff09c276e/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=381b445ff5751f9f39ec672b623372dff09c276e", "patch": "@@ -138,40 +138,8 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: FnKind<'tcx>,\n-        fd: &'tcx hir::FnDecl<'tcx>,\n-        b: hir::BodyId,\n-        s: Span,\n-        id: HirId,\n-    ) {\n-        visit_fn(self, fk, fd, b, s, id);\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        visit_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        visit_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        visit_arm(self, a);\n-    }\n-}\n-\n fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(\n-        module_def_id,\n-        &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n-    );\n+    tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -227,7 +195,6 @@ enum VarKind {\n \n struct IrMaps<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body_owner: LocalDefId,\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n     capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n@@ -236,10 +203,9 @@ struct IrMaps<'tcx> {\n }\n \n impl IrMaps<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body_owner: LocalDefId) -> IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n-            body_owner,\n             live_node_map: HirIdMap::default(),\n             variable_map: HirIdMap::default(),\n             capture_info_map: Default::default(),\n@@ -302,44 +268,117 @@ impl IrMaps<'tcx> {\n     fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n         self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n-}\n \n-fn visit_fn<'tcx>(\n-    ir: &mut IrMaps<'tcx>,\n-    fk: FnKind<'tcx>,\n-    decl: &'tcx hir::FnDecl<'tcx>,\n-    body_id: hir::BodyId,\n-    sp: Span,\n-    id: hir::HirId,\n-) {\n-    debug!(\"visit_fn {:?}\", id);\n-\n-    // swap in a new set of IR maps for this function body:\n-    let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n-\n-    // Don't run unused pass for #[derive()]\n-    if let FnKind::Method(..) = fk {\n-        let parent = ir.tcx.hir().get_parent_item(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n-            if i.attrs.iter().any(|a| ir.tcx.sess.check_name(a, sym::automatically_derived)) {\n-                return;\n+    fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n+        // For struct patterns, take note of which fields used shorthand\n+        // (`x` rather than `x: x`).\n+        let mut shorthand_field_ids = HirIdSet::default();\n+        let mut pats = VecDeque::new();\n+        pats.push_back(pat);\n+        while let Some(pat) = pats.pop_front() {\n+            use rustc_hir::PatKind::*;\n+            match &pat.kind {\n+                Binding(.., inner_pat) => {\n+                    pats.extend(inner_pat.iter());\n+                }\n+                Struct(_, fields, _) => {\n+                    let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n+                    shorthand_field_ids.extend(ids);\n+                }\n+                Ref(inner_pat, _) | Box(inner_pat) => {\n+                    pats.push_back(inner_pat);\n+                }\n+                TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n+                    pats.extend(inner_pats.iter());\n+                }\n+                Slice(pre_pats, inner_pat, post_pats) => {\n+                    pats.extend(pre_pats.iter());\n+                    pats.extend(inner_pat.iter());\n+                    pats.extend(post_pats.iter());\n+                }\n+                _ => {}\n             }\n         }\n+\n+        pat.each_binding(|_, hir_id, _, ident| {\n+            self.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n+            self.add_variable(Local(LocalInfo {\n+                id: hir_id,\n+                name: ident.name,\n+                is_shorthand: shorthand_field_ids.contains(&hir_id),\n+            }));\n+        });\n     }\n+}\n \n-    debug!(\"creating fn_maps: {:p}\", &fn_maps);\n+impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n+    type Map = Map<'tcx>;\n \n-    let body = ir.tcx.hir().body(body_id);\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n \n-    if let Some(upvars) = ir.tcx.upvars_mentioned(def_id) {\n-        for (&var_hir_id, _upvar) in upvars {\n-            let var_name = ir.tcx.hir().name(var_hir_id);\n-            fn_maps.add_variable(Upvar(var_hir_id, var_name));\n+    fn visit_fn(\n+        &mut self,\n+        fk: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        sp: Span,\n+        id: HirId,\n+    ) {\n+        debug!(\"visit_fn {:?}\", id);\n+\n+        // swap in a new set of IR maps for this function body:\n+        let def_id = self.tcx.hir().local_def_id(id);\n+        let mut fn_maps = IrMaps::new(self.tcx);\n+\n+        // Don't run unused pass for #[derive()]\n+        if let FnKind::Method(..) = fk {\n+            let parent = self.tcx.hir().get_parent_item(id);\n+            if let Some(Node::Item(i)) = self.tcx.hir().find(parent) {\n+                if i.attrs.iter().any(|a| self.tcx.sess.check_name(a, sym::automatically_derived)) {\n+                    return;\n+                }\n+            }\n         }\n+\n+        debug!(\"creating fn_maps: {:p}\", &fn_maps);\n+\n+        let body = self.tcx.hir().body(body_id);\n+\n+        if let Some(upvars) = self.tcx.upvars_mentioned(def_id) {\n+            for (&var_hir_id, _upvar) in upvars {\n+                let var_name = self.tcx.hir().name(var_hir_id);\n+                fn_maps.add_variable(Upvar(var_hir_id, var_name));\n+            }\n+        }\n+\n+        // gather up the various local variables, significant expressions,\n+        // and so forth:\n+        intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n+\n+        // compute liveness\n+        let mut lsets = Liveness::new(&mut fn_maps, def_id);\n+        let entry_ln = lsets.compute(&body, sp, id);\n+        lsets.log_liveness(entry_ln, id);\n+\n+        // check for various error conditions\n+        lsets.visit_body(body);\n+        lsets.warn_about_unused_upvars(entry_ln);\n+        lsets.warn_about_unused_args(body, entry_ln);\n+    }\n+\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n+        self.add_from_pat(&local.pat);\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n+        self.add_from_pat(&arm.pat);\n+        intravisit::walk_arm(self, arm);\n     }\n \n-    for param in body.params {\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         let is_shorthand = match param.pat.kind {\n             rustc_hir::PatKind::Struct(..) => true,\n             _ => false,\n@@ -350,150 +389,83 @@ fn visit_fn<'tcx>(\n             } else {\n                 Param(hir_id, ident.name)\n             };\n-            fn_maps.add_variable(var);\n-        })\n+            self.add_variable(var);\n+        });\n+        intravisit::walk_param(self, param);\n     }\n \n-    // gather up the various local variables, significant expressions,\n-    // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n-\n-    // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n-    let entry_ln = lsets.compute(fk, &body, sp, id);\n-    lsets.log_liveness(entry_ln, id);\n-\n-    // check for various error conditions\n-    lsets.visit_body(body);\n-    lsets.warn_about_unused_upvars(entry_ln);\n-    lsets.warn_about_unused_args(body, entry_ln);\n-}\n-\n-fn add_from_pat(ir: &mut IrMaps<'_>, pat: &hir::Pat<'_>) {\n-    // For struct patterns, take note of which fields used shorthand\n-    // (`x` rather than `x: x`).\n-    let mut shorthand_field_ids = HirIdSet::default();\n-    let mut pats = VecDeque::new();\n-    pats.push_back(pat);\n-    while let Some(pat) = pats.pop_front() {\n-        use rustc_hir::PatKind::*;\n-        match &pat.kind {\n-            Binding(.., inner_pat) => {\n-                pats.extend(inner_pat.iter());\n-            }\n-            Struct(_, fields, _) => {\n-                let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n-                shorthand_field_ids.extend(ids);\n-            }\n-            Ref(inner_pat, _) | Box(inner_pat) => {\n-                pats.push_back(inner_pat);\n-            }\n-            TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n-                pats.extend(inner_pats.iter());\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        match expr.kind {\n+            // live nodes required for uses or definitions of variables:\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n+                if let Res::Local(_var_hir_id) = path.res {\n+                    self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                }\n+                intravisit::walk_expr(self, expr);\n             }\n-            Slice(pre_pats, inner_pat, post_pats) => {\n-                pats.extend(pre_pats.iter());\n-                pats.extend(inner_pat.iter());\n-                pats.extend(post_pats.iter());\n+            hir::ExprKind::Closure(..) => {\n+                // Interesting control flow (for loops can contain labeled\n+                // breaks or continues)\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+\n+                // Make a live_node for each captured variable, with the span\n+                // being the location that the variable is used.  This results\n+                // in better error messages than just pointing at the closure\n+                // construction site.\n+                let mut call_caps = Vec::new();\n+                let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+                if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                    call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                        let upvar_ln = self.add_live_node(UpvarNode(upvar.span));\n+                        CaptureInfo { ln: upvar_ln, var_hid: var_id }\n+                    }));\n+                }\n+                self.set_captures(expr.hir_id, call_caps);\n+                intravisit::walk_expr(self, expr);\n             }\n-            _ => {}\n-        }\n-    }\n-\n-    pat.each_binding(|_, hir_id, _, ident| {\n-        ir.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n-        ir.add_variable(Local(LocalInfo {\n-            id: hir_id,\n-            name: ident.name,\n-            is_shorthand: shorthand_field_ids.contains(&hir_id),\n-        }));\n-    });\n-}\n-\n-fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local<'tcx>) {\n-    add_from_pat(ir, &local.pat);\n-    intravisit::walk_local(ir, local);\n-}\n \n-fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n-    add_from_pat(ir, &arm.pat);\n-    intravisit::walk_arm(ir, arm);\n-}\n-\n-fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    match expr.kind {\n-        // live nodes required for uses or definitions of variables:\n-        hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-            debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n-            if let Res::Local(_var_hir_id) = path.res {\n-                ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+            // live nodes required for interesting control flow:\n+            hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                intravisit::walk_expr(self, expr);\n             }\n-            intravisit::walk_expr(ir, expr);\n-        }\n-        hir::ExprKind::Closure(..) => {\n-            // Interesting control flow (for loops can contain labeled\n-            // breaks or continues)\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-\n-            // Make a live_node for each captured variable, with the span\n-            // being the location that the variable is used.  This results\n-            // in better error messages than just pointing at the closure\n-            // construction site.\n-            let mut call_caps = Vec::new();\n-            let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n-            if let Some(upvars) = ir.tcx.upvars_mentioned(closure_def_id) {\n-                call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n-                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n-                    CaptureInfo { ln: upvar_ln, var_hid: var_id }\n-                }));\n+            hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n+                self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n+                intravisit::walk_expr(self, expr);\n             }\n-            ir.set_captures(expr.hir_id, call_caps);\n-            let old_body_owner = ir.body_owner;\n-            ir.body_owner = closure_def_id;\n-            intravisit::walk_expr(ir, expr);\n-            ir.body_owner = old_body_owner;\n-        }\n \n-        // live nodes required for interesting control flow:\n-        hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-            intravisit::walk_expr(ir, expr);\n-        }\n-        hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n-            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n-            intravisit::walk_expr(ir, expr);\n-        }\n-\n-        // otherwise, live nodes are not required:\n-        hir::ExprKind::Index(..)\n-        | hir::ExprKind::Field(..)\n-        | hir::ExprKind::Array(..)\n-        | hir::ExprKind::Call(..)\n-        | hir::ExprKind::MethodCall(..)\n-        | hir::ExprKind::Tup(..)\n-        | hir::ExprKind::Binary(..)\n-        | hir::ExprKind::AddrOf(..)\n-        | hir::ExprKind::Cast(..)\n-        | hir::ExprKind::DropTemps(..)\n-        | hir::ExprKind::Unary(..)\n-        | hir::ExprKind::Break(..)\n-        | hir::ExprKind::Continue(_)\n-        | hir::ExprKind::Lit(_)\n-        | hir::ExprKind::Ret(..)\n-        | hir::ExprKind::Block(..)\n-        | hir::ExprKind::Assign(..)\n-        | hir::ExprKind::AssignOp(..)\n-        | hir::ExprKind::Struct(..)\n-        | hir::ExprKind::Repeat(..)\n-        | hir::ExprKind::InlineAsm(..)\n-        | hir::ExprKind::LlvmInlineAsm(..)\n-        | hir::ExprKind::Box(..)\n-        | hir::ExprKind::Yield(..)\n-        | hir::ExprKind::Type(..)\n-        | hir::ExprKind::Err\n-        | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n-        | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n-            intravisit::walk_expr(ir, expr);\n+            // otherwise, live nodes are not required:\n+            hir::ExprKind::Index(..)\n+            | hir::ExprKind::Field(..)\n+            | hir::ExprKind::Array(..)\n+            | hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            | hir::ExprKind::Tup(..)\n+            | hir::ExprKind::Binary(..)\n+            | hir::ExprKind::AddrOf(..)\n+            | hir::ExprKind::Cast(..)\n+            | hir::ExprKind::DropTemps(..)\n+            | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Break(..)\n+            | hir::ExprKind::Continue(_)\n+            | hir::ExprKind::Lit(_)\n+            | hir::ExprKind::Ret(..)\n+            | hir::ExprKind::Block(..)\n+            | hir::ExprKind::Assign(..)\n+            | hir::ExprKind::AssignOp(..)\n+            | hir::ExprKind::Struct(..)\n+            | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::InlineAsm(..)\n+            | hir::ExprKind::LlvmInlineAsm(..)\n+            | hir::ExprKind::Box(..)\n+            | hir::ExprKind::Yield(..)\n+            | hir::ExprKind::Type(..)\n+            | hir::ExprKind::Err\n+            | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+            | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n+                intravisit::walk_expr(self, expr);\n+            }\n         }\n     }\n }\n@@ -605,8 +577,10 @@ const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n+    body_owner: LocalDefId,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     successors: IndexVec<LiveNode, LiveNode>,\n     rwu_table: RWUTable,\n \n@@ -626,9 +600,10 @@ struct Liveness<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        let typeck_results = ir.tcx.typeck(def_id);\n-        let param_env = ir.tcx.param_env(def_id);\n+    fn new(ir: &'a mut IrMaps<'tcx>, body_owner: LocalDefId) -> Liveness<'a, 'tcx> {\n+        let typeck_results = ir.tcx.typeck(body_owner);\n+        let param_env = ir.tcx.param_env(body_owner);\n+        let upvars = ir.tcx.upvars_mentioned(body_owner);\n \n         let closure_ln = ir.add_live_node(ClosureNode);\n         let exit_ln = ir.add_live_node(ExitNode);\n@@ -638,8 +613,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         Liveness {\n             ir,\n+            body_owner,\n             typeck_results,\n             param_env,\n+            upvars,\n             successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n@@ -868,13 +845,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(\n-        &mut self,\n-        fk: FnKind<'_>,\n-        body: &hir::Body<'_>,\n-        span: Span,\n-        id: hir::HirId,\n-    ) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Body<'_>, span: Span, id: hir::HirId) -> LiveNode {\n         debug!(\"compute: using id for body, {:?}\", body.value);\n \n         // # Liveness of captured variables\n@@ -893,12 +864,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // if they are live on the entry to the closure, since only the closure\n         // itself can access them on subsequent calls.\n \n-        if let Some(upvars) = self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+        if let Some(upvars) = self.upvars {\n             // Mark upvars captured by reference as used after closure exits.\n             for (&var_hir_id, upvar) in upvars.iter().rev() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: self.ir.body_owner,\n+                    closure_expr_id: self.body_owner,\n                 };\n                 match self.typeck_results.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n@@ -912,9 +883,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n-        match fk {\n-            FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n-            FnKind::Closure(..) => {}\n+        if self.upvars.is_none() {\n+            // Either not a closure, or closure without any captured variables.\n+            // No need to determine liveness of captured variables, since there\n+            // are none.\n+            return succ;\n         }\n \n         let ty = self.typeck_results.node_type(id);\n@@ -926,7 +899,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             },\n             ty::Generator(..) => return succ,\n             _ => {\n-                span_bug!(span, \"type of closure expr {:?} is not a closure {:?}\", id, ty,);\n+                span_bug!(span, \"{} has upvars so it should have a closure type: {:?}\", id, ty);\n             }\n         };\n \n@@ -1565,15 +1538,15 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n-        let upvars = match self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+        let upvars = match self.upvars {\n             None => return,\n             Some(upvars) => upvars,\n         };\n         for (&var_hir_id, upvar) in upvars.iter() {\n             let var = self.variable(var_hir_id, upvar.span);\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: self.ir.body_owner,\n+                closure_expr_id: self.body_owner,\n             };\n             match self.typeck_results.upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue(_) => {}"}, {"sha": "66d0b7090ffb59830a18b11174d8752788c57a60", "filename": "src/test/ui/liveness/liveness-derive.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/381b445ff5751f9f39ec672b623372dff09c276e/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381b445ff5751f9f39ec672b623372dff09c276e/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.rs?ref=381b445ff5751f9f39ec672b623372dff09c276e", "patch": "@@ -0,0 +1,38 @@\n+// Test for interaction between #[automatically_derived] attribute used by\n+// built-in derives and lints generated by liveness pass.\n+//\n+// edition:2018\n+// check-pass\n+#![warn(unused)]\n+\n+pub trait T: Sized {\n+    const N: usize;\n+    fn t(&self) -> Self;\n+}\n+\n+impl T for u32 {\n+    const N: usize = {\n+        let a = 0; // FIXME should warn about unused variable\n+        4\n+    };\n+\n+    fn t(&self) -> Self {\n+        let b = 16; //~ WARN unused variable: `b`\n+        0\n+    }\n+}\n+\n+#[automatically_derived]\n+impl T for i32 {\n+    const N: usize = {\n+        let c = 0;\n+        4\n+    };\n+\n+    fn t(&self) -> Self {\n+        let d = 17;\n+        0\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d4f45a0a31341e619dc3048abb0cc4204d4de5b8", "filename": "src/test/ui/liveness/liveness-derive.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/381b445ff5751f9f39ec672b623372dff09c276e/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/381b445ff5751f9f39ec672b623372dff09c276e/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-derive.stderr?ref=381b445ff5751f9f39ec672b623372dff09c276e", "patch": "@@ -0,0 +1,15 @@\n+warning: unused variable: `b`\n+  --> $DIR/liveness-derive.rs:20:13\n+   |\n+LL |         let b = 16;\n+   |             ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-derive.rs:6:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+\n+warning: 1 warning emitted\n+"}]}