{"sha": "3d05e7f9cdd76887de75f46b5e47d2685bec6520", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMDVlN2Y5Y2RkNzY4ODdkZTc1ZjQ2YjVlNDdkMjY4NWJlYzY1MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T02:21:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T02:21:33Z"}, "message": "auto merge of #13688 : alexcrichton/rust/accept-timeout, r=brson\n\nThis adds experimental support for timeouts when accepting sockets through\r\n`TcpAcceptor::accept`. This does not add a separate `accept_timeout` function,\r\nbut rather it adds a `set_timeout` function instead. This second function is\r\nintended to be used as a hard deadline after which all accepts will never block\r\nand fail immediately.\r\n\r\nThis idea was derived from Go's SetDeadline() methods. We do not currently have\r\na robust time abstraction in the standard library, so I opted to have the\r\nargument be a relative time in millseconds into the future. I believe a more\r\nappropriate argument type is an absolute time, but this concept does not exist\r\nyet (this is also why the function is marked #[experimental]).\r\n\r\nThe native support is built on select(), similarly to connect_timeout(), and the\r\ngreen support is based on channel select and a timer.\r\n\r\ncc #13523", "tree": {"sha": "56e20faec42ce4ff66a2fdf0e7d92fa8ea1e55a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56e20faec42ce4ff66a2fdf0e7d92fa8ea1e55a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d05e7f9cdd76887de75f46b5e47d2685bec6520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d05e7f9cdd76887de75f46b5e47d2685bec6520", "html_url": "https://github.com/rust-lang/rust/commit/3d05e7f9cdd76887de75f46b5e47d2685bec6520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d05e7f9cdd76887de75f46b5e47d2685bec6520/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9103301726a4d91c622f8ae3d2d10ad225a0f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9103301726a4d91c622f8ae3d2d10ad225a0f65", "html_url": "https://github.com/rust-lang/rust/commit/d9103301726a4d91c622f8ae3d2d10ad225a0f65"}, {"sha": "e5d3e5180f667f8850cdd96af60fc5511746b1bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d3e5180f667f8850cdd96af60fc5511746b1bd", "html_url": "https://github.com/rust-lang/rust/commit/e5d3e5180f667f8850cdd96af60fc5511746b1bd"}], "stats": {"total": 294, "additions": 253, "deletions": 41}, "files": [{"sha": "dbbb39b3b7b52fd5363ff30a3430857ba46e349b", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -50,9 +50,9 @@ extern \"system\" {\n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;\n     pub fn select(nfds: libc::c_int,\n-                  readfds: *mut fd_set,\n-                  writefds: *mut fd_set,\n-                  exceptfds: *mut fd_set,\n+                  readfds: *fd_set,\n+                  writefds: *fd_set,\n+                  exceptfds: *fd_set,\n                   timeout: *libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::SOCKET,\n                       level: libc::c_int,"}, {"sha": "93ec23e32ad427da60e894b85eb94b366ae05a6e", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -13,6 +13,7 @@ use std::cast;\n use std::io::net::ip;\n use std::io;\n use std::mem;\n+use std::os;\n use std::ptr;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n@@ -144,6 +145,21 @@ fn last_error() -> io::IoError {\n     super::last_error()\n }\n \n+fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::time_t,\n+        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n+    }\n+}\n+\n+fn timeout(desc: &'static str) -> io::IoError {\n+    io::IoError {\n+        kind: io::TimedOut,\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n #[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n #[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n \n@@ -271,8 +287,7 @@ impl TcpStream {\n     fn connect_timeout(fd: sock_t,\n                        addrp: *libc::sockaddr,\n                        len: libc::socklen_t,\n-                       timeout: u64) -> IoResult<()> {\n-        use std::os;\n+                       timeout_ms: u64) -> IoResult<()> {\n         #[cfg(unix)]    use INPROGRESS = libc::EINPROGRESS;\n         #[cfg(windows)] use INPROGRESS = libc::WSAEINPROGRESS;\n         #[cfg(unix)]    use WOULDBLOCK = libc::EWOULDBLOCK;\n@@ -289,12 +304,8 @@ impl TcpStream {\n                   os::errno() as int == WOULDBLOCK as int => {\n                 let mut set: c::fd_set = unsafe { mem::init() };\n                 c::fd_set(&mut set, fd);\n-                match await(fd, &mut set, timeout) {\n-                    0 => Err(io::IoError {\n-                        kind: io::TimedOut,\n-                        desc: \"connection timed out\",\n-                        detail: None,\n-                    }),\n+                match await(fd, &mut set, timeout_ms) {\n+                    0 => Err(timeout(\"connection timed out\")),\n                     -1 => Err(last_error()),\n                     _ => {\n                         let err: libc::c_int = try!(\n@@ -338,22 +349,14 @@ impl TcpStream {\n                 // Recalculate the timeout each iteration (it is generally\n                 // undefined what the value of the 'tv' is after select\n                 // returns EINTR).\n-                let timeout = timeout - (::io::timer::now() - start);\n-                let tv = libc::timeval {\n-                    tv_sec: (timeout / 1000) as libc::time_t,\n-                    tv_usec: ((timeout % 1000) * 1000) as libc::suseconds_t,\n-                };\n-                c::select(fd + 1, ptr::null(), set as *mut _ as *_,\n-                          ptr::null(), &tv)\n+                let tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n+                c::select(fd + 1, ptr::null(), &*set, ptr::null(), &tv)\n             })\n         }\n         #[cfg(windows)]\n         fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-            let tv = libc::timeval {\n-                tv_sec: (timeout / 1000) as libc::time_t,\n-                tv_usec: ((timeout % 1000) * 1000) as libc::suseconds_t,\n-            };\n-            unsafe { c::select(1, ptr::mut_null(), set, ptr::mut_null(), &tv) }\n+            let tv = ms_to_timeval(timeout);\n+            unsafe { c::select(1, ptr::null(), &*set, ptr::null(), &tv) }\n         }\n     }\n \n@@ -467,7 +470,7 @@ impl Drop for Inner {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct TcpListener {\n-    inner: UnsafeArc<Inner>,\n+    inner: Inner,\n }\n \n impl TcpListener {\n@@ -477,7 +480,7 @@ impl TcpListener {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n                 let inner = Inner { fd: fd };\n-                let ret = TcpListener { inner: UnsafeArc::new(inner) };\n+                let ret = TcpListener { inner: inner };\n                 // On platforms with Berkeley-derived sockets, this allows\n                 // to quickly rebind a socket, without needing to wait for\n                 // the OS to clean up the previous one.\n@@ -498,15 +501,12 @@ impl TcpListener {\n         }\n     }\n \n-    pub fn fd(&self) -> sock_t {\n-        // This is just a read-only arc so the unsafety is fine\n-        unsafe { (*self.inner.get()).fd }\n-    }\n+    pub fn fd(&self) -> sock_t { self.inner.fd }\n \n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(last_error()),\n-            _ => Ok(TcpAcceptor { listener: self })\n+            _ => Ok(TcpAcceptor { listener: self, deadline: 0 })\n         }\n     }\n }\n@@ -525,12 +525,16 @@ impl rtio::RtioSocket for TcpListener {\n \n pub struct TcpAcceptor {\n     listener: TcpListener,\n+    deadline: u64,\n }\n \n impl TcpAcceptor {\n     pub fn fd(&self) -> sock_t { self.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        if self.deadline != 0 {\n+            try!(self.accept_deadline());\n+        }\n         unsafe {\n             let mut storage: libc::sockaddr_storage = mem::init();\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n@@ -546,6 +550,25 @@ impl TcpAcceptor {\n             }\n         }\n     }\n+\n+    fn accept_deadline(&mut self) -> IoResult<()> {\n+        let mut set: c::fd_set = unsafe { mem::init() };\n+        c::fd_set(&mut set, self.fd());\n+\n+        match retry(|| {\n+            // If we're past the deadline, then pass a 0 timeout to select() so\n+            // we can poll the status of the socket.\n+            let now = ::io::timer::now();\n+            let ms = if self.deadline > now {0} else {self.deadline - now};\n+            let tv = ms_to_timeval(ms);\n+            let n = if cfg!(windows) {1} else {self.fd() as libc::c_int + 1};\n+            unsafe { c::select(n, &set, ptr::null(), ptr::null(), &tv) }\n+        }) {\n+            -1 => Err(last_error()),\n+            0 => Err(timeout(\"accept timed out\")),\n+            _ => return Ok(()),\n+        }\n+    }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n@@ -561,6 +584,12 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = match timeout {\n+            None => 0,\n+            Some(t) => ::io::timer::now() + t,\n+        };\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "588ec367d81769e52154faf331a680158b1375f1", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -89,6 +89,17 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n     }\n }\n \n+// returns the current time (in milliseconds)\n+pub fn now() -> u64 {\n+    let mut ticks_per_s = 0;\n+    assert_eq!(unsafe { libc::QueryPerformanceFrequency(&mut ticks_per_s) }, 1);\n+    let ticks_per_s = if ticks_per_s == 0 {1} else {ticks_per_s};\n+    let mut ticks = 0;\n+    assert_eq!(unsafe { libc::QueryPerformanceCounter(&mut ticks) }, 1);\n+\n+    return (ticks as u64 * 1000) / (ticks_per_s as u64);\n+}\n+\n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n         timer_helper::boot(helper);"}, {"sha": "f8df9263be1dbc55b4b091b46f292c8cd7656999", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -174,6 +174,9 @@ pub struct TcpListener {\n \n pub struct TcpAcceptor {\n     listener: ~TcpListener,\n+    timer: Option<TimerWatcher>,\n+    timeout_tx: Option<Sender<()>>,\n+    timeout_rx: Option<Receiver<()>>,\n }\n \n // TCP watchers (clients/streams)\n@@ -459,7 +462,12 @@ impl rtio::RtioSocket for TcpListener {\n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(~self) -> Result<~rtio::RtioTcpAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n-        let mut acceptor = ~TcpAcceptor { listener: self };\n+        let mut acceptor = ~TcpAcceptor {\n+            listener: self,\n+            timer: None,\n+            timeout_tx: None,\n+            timeout_rx: None,\n+        };\n \n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n@@ -509,7 +517,37 @@ impl rtio::RtioSocket for TcpAcceptor {\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<~rtio::RtioTcpStream:Send, IoError> {\n-        self.listener.incoming.recv()\n+        match self.timeout_rx {\n+            None => self.listener.incoming.recv(),\n+            Some(ref rx) => {\n+                use std::comm::Select;\n+\n+                // Poll the incoming channel first (don't rely on the order of\n+                // select just yet). If someone's pending then we should return\n+                // them immediately.\n+                match self.listener.incoming.try_recv() {\n+                    Ok(data) => return data,\n+                    Err(..) => {}\n+                }\n+\n+                // Use select to figure out which channel gets ready first. We\n+                // do some custom handling of select to ensure that we never\n+                // actually drain the timeout channel (we'll keep seeing the\n+                // timeout message in the future).\n+                let s = Select::new();\n+                let mut timeout = s.handle(rx);\n+                let mut data = s.handle(&self.listener.incoming);\n+                unsafe {\n+                    timeout.add();\n+                    data.add();\n+                }\n+                if s.wait() == timeout.id() {\n+                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+                } else {\n+                    self.listener.incoming.recv()\n+                }\n+            }\n+        }\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n@@ -525,6 +563,52 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n             uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 0)\n         })\n     }\n+\n+    fn set_timeout(&mut self, ms: Option<u64>) {\n+        // First, if the timeout is none, clear any previous timeout by dropping\n+        // the timer and transmission channels\n+        let ms = match ms {\n+            None => {\n+                return drop((self.timer.take(),\n+                             self.timeout_tx.take(),\n+                             self.timeout_rx.take()))\n+            }\n+            Some(ms) => ms,\n+        };\n+\n+        // If we have a timeout, lazily initialize the timer which will be used\n+        // to fire when the timeout runs out.\n+        if self.timer.is_none() {\n+            let _m = self.fire_homing_missile();\n+            let loop_ = Loop::wrap(unsafe {\n+                uvll::get_loop_for_uv_handle(self.listener.handle)\n+            });\n+            let mut timer = TimerWatcher::new_home(&loop_, self.home().clone());\n+            unsafe {\n+                timer.set_data(self as *mut _ as *TcpAcceptor);\n+            }\n+            self.timer = Some(timer);\n+        }\n+\n+        // Once we've got a timer, stop any previous timeout, reset it for the\n+        // current one, and install some new channels to send/receive data on\n+        let timer = self.timer.get_mut_ref();\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        let (tx, rx) = channel();\n+        self.timeout_tx = Some(tx);\n+        self.timeout_rx = Some(rx);\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t, status: c_int) {\n+            assert_eq!(status, 0);\n+            let acceptor: &mut TcpAcceptor = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(timer) as *mut TcpAcceptor)\n+            };\n+            // This send can never fail because if this timer is active then the\n+            // receiving channel is guaranteed to be alive\n+            acceptor.timeout_tx.get_ref().send(());\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "65ab32c6965a786fbef3f47e42d79c43f81be8e5", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -14,7 +14,7 @@ use std::rt::rtio::RtioTimer;\n use std::rt::task::BlockedTask;\n \n use homing::{HomeHandle, HomingIO};\n-use super::{UvHandle, ForbidUnwind, ForbidSwitch, wait_until_woken_after};\n+use super::{UvHandle, ForbidUnwind, ForbidSwitch, wait_until_woken_after, Loop};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -34,18 +34,21 @@ pub enum NextAction {\n \n impl TimerWatcher {\n     pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher {\n+        let handle = io.make_handle();\n+        let me = ~TimerWatcher::new_home(&io.loop_, handle);\n+        me.install()\n+    }\n+\n+    pub fn new_home(loop_: &Loop, home: HomeHandle) -> TimerWatcher {\n         let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n-        assert_eq!(unsafe {\n-            uvll::uv_timer_init(io.uv_loop(), handle)\n-        }, 0);\n-        let me = ~TimerWatcher {\n+        assert_eq!(unsafe { uvll::uv_timer_init(loop_.handle, handle) }, 0);\n+        TimerWatcher {\n             handle: handle,\n             action: None,\n             blocker: None,\n-            home: io.make_handle(),\n+            home: home,\n             id: 0,\n-        };\n-        return me.install();\n+        }\n     }\n \n     pub fn start(&mut self, f: uvll::uv_timer_cb, msecs: u64, period: u64) {"}, {"sha": "0619c89aac1c440df8c6ecf780dc66ed81362281", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -22,7 +22,7 @@ use io::IoResult;\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, Listener, Acceptor};\n use kinds::Send;\n-use option::{None, Some};\n+use option::{None, Some, Option};\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -184,13 +184,64 @@ pub struct TcpAcceptor {\n     obj: ~RtioTcpAcceptor:Send\n }\n \n+impl TcpAcceptor {\n+    /// Prevents blocking on all future accepts after `ms` milliseconds have\n+    /// elapsed.\n+    ///\n+    /// This function is used to set a deadline after which this acceptor will\n+    /// time out accepting any connections. The argument is the relative\n+    /// distance, in milliseconds, to a point in the future after which all\n+    /// accepts will fail.\n+    ///\n+    /// If the argument specified is `None`, then any previously registered\n+    /// timeout is cleared.\n+    ///\n+    /// A timeout of `0` can be used to \"poll\" this acceptor to see if it has\n+    /// any pending connections. All pending connections will be accepted,\n+    /// regardless of whether the timeout has expired or not (the accept will\n+    /// not block in this case).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(experimental)]\n+    /// use std::io::net::tcp::TcpListener;\n+    /// use std::io::net::ip::{SocketAddr, Ipv4Addr};\n+    /// use std::io::{Listener, Acceptor, TimedOut};\n+    ///\n+    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 8482 };\n+    /// let mut a = TcpListener::bind(addr).listen().unwrap();\n+    ///\n+    /// // After 100ms have passed, all accepts will fail\n+    /// a.set_timeout(Some(100));\n+    ///\n+    /// match a.accept() {\n+    ///     Ok(..) => println!(\"accepted a socket\"),\n+    ///     Err(ref e) if e.kind == TimedOut => { println!(\"timed out!\"); }\n+    ///     Err(e) => println!(\"err: {}\", e),\n+    /// }\n+    ///\n+    /// // Reset the timeout and try again\n+    /// a.set_timeout(Some(100));\n+    /// let socket = a.accept();\n+    ///\n+    /// // Clear the timeout and block indefinitely waiting for a connection\n+    /// a.set_timeout(None);\n+    /// let socket = a.accept();\n+    /// ```\n+    #[experimental = \"the type of the argument and name of this function are \\\n+                      subject to change\"]\n+    pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }\n+}\n+\n impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<TcpStream> {\n         self.obj.accept().map(TcpStream::new)\n     }\n }\n \n #[cfg(test)]\n+#[allow(experimental)]\n mod test {\n     use super::*;\n     use io::net::ip::SocketAddr;\n@@ -749,4 +800,37 @@ mod test {\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     })\n+\n+    iotest!(fn accept_timeout() {\n+        let addr = next_test_ip4();\n+        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n+\n+        a.set_timeout(Some(10));\n+\n+        // Make sure we time out once and future invocations also time out\n+        let err = a.accept().err().unwrap();\n+        assert_eq!(err.kind, TimedOut);\n+        let err = a.accept().err().unwrap();\n+        assert_eq!(err.kind, TimedOut);\n+\n+        // Also make sure that even though the timeout is expired that we will\n+        // continue to receive any pending connections.\n+        let l = TcpStream::connect(addr).unwrap();\n+        for i in range(0, 1001) {\n+            match a.accept() {\n+                Ok(..) => break,\n+                Err(ref e) if e.kind == TimedOut => {}\n+                Err(e) => fail!(\"error: {}\", e),\n+            }\n+            if i == 1000 { fail!(\"should have a pending connection\") }\n+        }\n+        drop(l);\n+\n+        // Unset the timeout and make sure that this always blocks.\n+        a.set_timeout(None);\n+        spawn(proc() {\n+            drop(TcpStream::connect(addr));\n+        });\n+        a.accept().unwrap();\n+    })\n }"}, {"sha": "5dd148346695d8606770fb6dd762c6443f570284", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d05e7f9cdd76887de75f46b5e47d2685bec6520/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=3d05e7f9cdd76887de75f46b5e47d2685bec6520", "patch": "@@ -200,6 +200,7 @@ pub trait RtioTcpAcceptor : RtioSocket {\n     fn accept(&mut self) -> IoResult<~RtioTcpStream:Send>;\n     fn accept_simultaneously(&mut self) -> IoResult<()>;\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n+    fn set_timeout(&mut self, timeout: Option<u64>);\n }\n \n pub trait RtioTcpStream : RtioSocket {"}]}