{"sha": "47de11f1ed133305a8dbd5be11b73acd0a085ba9", "node_id": "C_kwDOAAsO6NoAKDQ3ZGUxMWYxZWQxMzMzMDVhOGRiZDViZTExYjczYWNkMGEwODViYTk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-23T12:59:40Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-12T10:00:28Z"}, "message": "Use variances for defining use diag.", "tree": {"sha": "6374b9ee637ce1da4b90d4a0eaad549950a7f772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6374b9ee637ce1da4b90d4a0eaad549950a7f772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47de11f1ed133305a8dbd5be11b73acd0a085ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47de11f1ed133305a8dbd5be11b73acd0a085ba9", "html_url": "https://github.com/rust-lang/rust/commit/47de11f1ed133305a8dbd5be11b73acd0a085ba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47de11f1ed133305a8dbd5be11b73acd0a085ba9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b676fc4d8ee5a94cc4270d54005899c599b4d818", "url": "https://api.github.com/repos/rust-lang/rust/commits/b676fc4d8ee5a94cc4270d54005899c599b4d818", "html_url": "https://github.com/rust-lang/rust/commit/b676fc4d8ee5a94cc4270d54005899c599b4d818"}], "stats": {"total": 58, "additions": 5, "deletions": 53}, "files": [{"sha": "169e8e792ab245bc050c70ac5769aa4f5373a7da", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 53, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/47de11f1ed133305a8dbd5be11b73acd0a085ba9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47de11f1ed133305a8dbd5be11b73acd0a085ba9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=47de11f1ed133305a8dbd5be11b73acd0a085ba9", "patch": "@@ -1345,61 +1345,13 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n                 // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n                 // ```\n                 // we may not use `'c` in the hidden type.\n-                struct OpaqueTypeLifetimeCollector<'tcx> {\n-                    lifetimes: FxHashSet<ty::Region<'tcx>>,\n-                }\n-\n-                impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector<'tcx> {\n-                    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                        self.lifetimes.insert(r);\n-                        r.super_visit_with(self)\n-                    }\n-                }\n+                let variances = tcx.variances_of(def_id);\n+                debug!(?variances);\n \n-                let mut collector = OpaqueTypeLifetimeCollector { lifetimes: Default::default() };\n-\n-                for pred in tcx.bound_explicit_item_bounds(def_id.to_def_id()).transpose_iter() {\n-                    let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n-\n-                    trace!(pred=?pred.kind());\n-\n-                    // We only ignore opaque type substs if the opaque type is the outermost type.\n-                    // The opaque type may be nested within itself via recursion in e.g.\n-                    // type Foo<'a> = impl PartialEq<Foo<'a>>;\n-                    // which thus mentions `'a` and should thus accept hidden types that borrow 'a\n-                    // instead of requiring an additional `+ 'a`.\n-                    match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(TraitPredicate {\n-                            trait_ref: ty::TraitRef { def_id: _, substs },\n-                            constness: _,\n-                            polarity: _,\n-                        }) => {\n-                            trace!(?substs);\n-                            for subst in &substs[1..] {\n-                                subst.visit_with(&mut collector);\n-                            }\n-                        }\n-                        ty::PredicateKind::Projection(ty::ProjectionPredicate {\n-                            projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n-                            term,\n-                        }) => {\n-                            for subst in &substs[1..] {\n-                                subst.visit_with(&mut collector);\n-                            }\n-                            term.visit_with(&mut collector);\n-                        }\n-                        _ => {\n-                            pred.visit_with(&mut collector);\n-                        }\n-                    }\n-                }\n-                let lifetimes = collector.lifetimes;\n-                trace!(?lifetimes);\n                 map.filter(|(_, v)| {\n-                    let ty::GenericArgKind::Lifetime(lt) = v.unpack() else {\n-                        return true;\n-                    };\n-                    lifetimes.contains(&lt)\n+                    let ty::GenericArgKind::Lifetime(lt) = v.unpack() else { return true };\n+                    let ty::ReEarlyBound(ebr) = lt.kind() else { bug!() };\n+                    variances[ebr.index as usize] == ty::Variance::Invariant\n                 })\n                 .collect()\n             }"}]}