{"sha": "7e30ba8fc94a449e9dec8cc464875111219187ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMzBiYThmYzk0YTQ0OWU5ZGVjOGNjNDY0ODc1MTExMjE5MTg3ZmY=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-08-15T02:16:35Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-08-15T02:16:35Z"}, "message": "librustc: Don't create scratch for the base expr in function record update.", "tree": {"sha": "af6015a0334ee132a666d819a4642bda5461983a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af6015a0334ee132a666d819a4642bda5461983a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e30ba8fc94a449e9dec8cc464875111219187ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e30ba8fc94a449e9dec8cc464875111219187ff", "html_url": "https://github.com/rust-lang/rust/commit/7e30ba8fc94a449e9dec8cc464875111219187ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e30ba8fc94a449e9dec8cc464875111219187ff/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8e0ede92157995665c7caf4ae115354139be46d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8e0ede92157995665c7caf4ae115354139be46d", "html_url": "https://github.com/rust-lang/rust/commit/f8e0ede92157995665c7caf4ae115354139be46d"}], "stats": {"total": 65, "additions": 35, "deletions": 30}, "files": [{"sha": "839e6706e566b84a010a1ea8071a52b060c38535", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7e30ba8fc94a449e9dec8cc464875111219187ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e30ba8fc94a449e9dec8cc464875111219187ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7e30ba8fc94a449e9dec8cc464875111219187ff", "patch": "@@ -746,12 +746,12 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n-            trans_rec_or_struct(bcx,\n-                                fields.as_slice(),\n-                                base,\n-                                expr.span,\n-                                expr.id,\n-                                dest)\n+            trans_struct(bcx,\n+                         fields.as_slice(),\n+                         base,\n+                         expr.span,\n+                         expr.id,\n+                         dest)\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n@@ -1042,16 +1042,13 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n     }\n }\n \n-fn trans_rec_or_struct<'a>(\n-                       bcx: &'a Block<'a>,\n-                       fields: &[ast::Field],\n-                       base: Option<Gc<ast::Expr>>,\n-                       expr_span: codemap::Span,\n-                       id: ast::NodeId,\n-                       dest: Dest)\n-                       -> &'a Block<'a> {\n+fn trans_struct<'a>(bcx: &'a Block<'a>,\n+                    fields: &[ast::Field],\n+                    base: Option<Gc<ast::Expr>>,\n+                    expr_span: codemap::Span,\n+                    id: ast::NodeId,\n+                    dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_rec\");\n-    let bcx = bcx;\n \n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n@@ -1121,15 +1118,14 @@ pub struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-pub fn trans_adt<'a>(bcx: &'a Block<'a>,\n+pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n                      repr: &adt::Repr,\n                      discr: ty::Disr,\n                      fields: &[(uint, Gc<ast::Expr>)],\n                      optbase: Option<StructBaseInfo>,\n                      dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n             for &(_i, ref e) in fields.iter() {\n@@ -1148,6 +1144,28 @@ pub fn trans_adt<'a>(bcx: &'a Block<'a>,\n     // failure occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n+    // First we trans the base, if we have one, to the dest\n+    for base in optbase.iter() {\n+        assert_eq!(discr, 0);\n+\n+        match ty::expr_kind(bcx.tcx(), &*base.expr) {\n+            ty::LvalueExpr => {\n+                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n+                for &(i, t) in base.fields.iter() {\n+                    let datum = base_datum.get_element(\n+                            t, |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n+                    let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n+                    bcx = datum.store_to(bcx, dest);\n+                }\n+            },\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr => {\n+                bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n+            },\n+            ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+        }\n+    }\n+\n+    // Now, we just overwrite the fields we've explicity specified\n     for &(i, ref e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty_adjusted(bcx, &**e);\n@@ -1157,19 +1175,6 @@ pub fn trans_adt<'a>(bcx: &'a Block<'a>,\n         fcx.schedule_drop_mem(scope, dest, e_ty);\n     }\n \n-    for base in optbase.iter() {\n-        // FIXME #6573: is it sound to use the destination's repr on the base?\n-        // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n-        for &(i, t) in base.fields.iter() {\n-            let datum = base_datum.get_element(\n-                t,\n-                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n-            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, dest);\n-        }\n-    }\n-\n     adt::trans_set_discr(bcx, repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);"}]}