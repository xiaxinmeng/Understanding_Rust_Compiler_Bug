{"sha": "8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MzFhZDllNTJlNGYyMzA0M2VlYTljYzYzMDM5ZDdlNWYxZTFlZmM=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-18T19:28:04Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-19T09:20:00Z"}, "message": "std::str: Only check char boundary for end index in .slice_to()", "tree": {"sha": "26d83bd53470a21634919256b4beb61349331bbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d83bd53470a21634919256b4beb61349331bbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "html_url": "https://github.com/rust-lang/rust/commit/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc/comments", "author": null, "committer": null, "parents": [{"sha": "f33a30e7e8f22a1e438dc5b30959bb80829ee505", "url": "https://api.github.com/repos/rust-lang/rust/commits/f33a30e7e8f22a1e438dc5b30959bb80829ee505", "html_url": "https://github.com/rust-lang/rust/commit/f33a30e7e8f22a1e438dc5b30959bb80829ee505"}], "stats": {"total": 3, "additions": 2, "deletions": 1}, "files": [{"sha": "df24d8b20e23d4042fcaf001b4afe9addbdc6d36", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "patch": "@@ -1427,7 +1427,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// out of bounds.\n     #[inline]\n     fn slice_to(&self, end: uint) -> &'self str {\n-        self.slice(0, end)\n+        assert!(self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, 0, end) }\n     }\n \n     /// Returns a slice of the string from the char range"}]}