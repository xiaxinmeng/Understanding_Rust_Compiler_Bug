{"sha": "dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMjlkM2RkNzZjM2FlZDE4ZDc3MDhjNjM2YjhkMWUyNTlhNGMyOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-05T01:45:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-05T01:45:46Z"}, "message": "Auto merge of #47865 - Manishearth:cleanup-shim, r=nikomatsakis\n\nCleanup the shim code\n\n - We now write directly to `RETURN_PLACE` instead of creating intermediates\n - `tuple_like_shim` takes an iterator (used by #47867)\n - `tuple_like_shim` no longer relies on it being the first thing to create blocks, and uses relative block indexing in a cleaner way (necessary for #47867)\n - All the shim builders take `dest, src` arguments instead of hardcoding RETURN_PLACE\n\nr? @eddyb", "tree": {"sha": "f6a00708c4ab9abc82b3b0061d24fc0451c026a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a00708c4ab9abc82b3b0061d24fc0451c026a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "html_url": "https://github.com/rust-lang/rust/commit/dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd29d3dd76c3aed18d7708c636b8d1e259a4c294/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7e982ac03b496dd4d4b5c182fdcd5fb4f2b5470", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e982ac03b496dd4d4b5c182fdcd5fb4f2b5470", "html_url": "https://github.com/rust-lang/rust/commit/e7e982ac03b496dd4d4b5c182fdcd5fb4f2b5470"}, {"sha": "8a8f91b89effd9005c0ee536bcd8767304ac1363", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8f91b89effd9005c0ee536bcd8767304ac1363", "html_url": "https://github.com/rust-lang/rust/commit/8a8f91b89effd9005c0ee536bcd8767304ac1363"}], "stats": {"total": 147, "additions": 71, "deletions": 76}, "files": [{"sha": "d82691f882c7348b7ad2e1cc01cc13963c1eb945", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd29d3dd76c3aed18d7708c636b8d1e259a4c294/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd29d3dd76c3aed18d7708c636b8d1e259a4c294/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "patch": "@@ -1515,8 +1515,8 @@ pub enum AggregateKind<'tcx> {\n     Array(Ty<'tcx>),\n     Tuple,\n \n-    /// The second field is variant number (discriminant), it's equal\n-    /// to 0 for struct and union expressions. The fourth field is\n+    /// The second field is the variant index. It's equal to 0 for struct\n+    /// and union expressions. The fourth field is\n     /// active field number and is present only for union expressions\n     /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`"}, {"sha": "42ffcc194ca8c4750a8ac9d33b8668ebb56c0178", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/dd29d3dd76c3aed18d7708c636b8d1e259a4c294/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd29d3dd76c3aed18d7708c636b8d1e259a4c294/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=dd29d3dd76c3aed18d7708c636b8d1e259a4c294", "patch": "@@ -294,22 +294,25 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n-    let mut builder = CloneShimBuilder::new(tcx, def_id);\n+    let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n \n+    let dest = Place::Local(RETURN_PLACE);\n+    let src = Place::Local(Local::new(1+0)).deref();\n+\n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::TyArray(ty, len) => {\n             let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-            builder.array_shim(ty, len)\n+            builder.array_shim(dest, src, ty, len)\n         }\n         ty::TyClosure(def_id, substs) => {\n             builder.tuple_like_shim(\n-                &substs.upvar_tys(def_id, tcx).collect::<Vec<_>>(),\n-                AggregateKind::Closure(def_id, substs)\n+                dest, src,\n+                substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::TyTuple(tys, _) => builder.tuple_like_shim(&**tys, AggregateKind::Tuple),\n+        ty::TyTuple(tys, _) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }\n@@ -328,8 +331,14 @@ struct CloneShimBuilder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Self {\n-        let sig = tcx.fn_sig(def_id);\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           def_id: DefId,\n+           self_ty: Ty<'tcx>) -> Self {\n+        // we must subst the self_ty because it's\n+        // otherwise going to be TySelf and we can't index\n+        // or access fields of a Place of type TySelf.\n+        let substs = tcx.mk_substs_trait(self_ty, &[]);\n+        let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n         let sig = tcx.erase_late_bound_regions(&sig);\n         let span = tcx.def_span(def_id);\n \n@@ -377,6 +386,14 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         })\n     }\n \n+    /// Gives the index of an upcoming BasicBlock, with an offset.\n+    /// offset=0 will give you the index of the next BasicBlock,\n+    /// offset=1 will give the index of the next-to-next block,\n+    /// offset=-1 will give you the index of the last-created block\n+    fn block_index_offset(&mut self, offset: usize) -> BasicBlock {\n+        BasicBlock::new(self.blocks.len() + offset)\n+    }\n+\n     fn make_statement(&self, kind: StatementKind<'tcx>) -> Statement<'tcx> {\n         Statement {\n             source_info: self.source_info(),\n@@ -404,11 +421,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n \n     fn make_clone_call(\n         &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n         ty: Ty<'tcx>,\n-        rcvr_field: Place<'tcx>,\n         next: BasicBlock,\n         cleanup: BasicBlock\n-    ) -> Place<'tcx> {\n+    ) {\n         let tcx = self.tcx;\n \n         let substs = Substs::for_item(\n@@ -439,25 +457,21 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             })\n         );\n \n-        let loc = self.make_place(Mutability::Not, ty);\n-\n-        // `let ref_loc: &ty = &rcvr_field;`\n+        // `let ref_loc: &ty = &src;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n                 ref_loc.clone(),\n-                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, rcvr_field)\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, src)\n             )\n         );\n \n         // `let loc = Clone::clone(ref_loc);`\n         self.block(vec![statement], TerminatorKind::Call {\n             func,\n             args: vec![Operand::Move(ref_loc)],\n-            destination: Some((loc.clone(), next)),\n+            destination: Some((dest, next)),\n             cleanup: Some(cleanup),\n         }, false);\n-\n-        loc\n     }\n \n     fn loop_header(\n@@ -500,14 +514,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn array_shim(&mut self, ty: Ty<'tcx>, len: u64) {\n+    fn array_shim(&mut self, dest: Place<'tcx>, src: Place<'tcx>, ty: Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n-        let rcvr = Place::Local(Local::new(1+0)).deref();\n \n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let end = self.make_place(Mutability::Not, tcx.types.usize);\n-        let ret = self.make_place(Mutability::Mut, tcx.mk_array(ty, len));\n \n         // BB #0\n         // `let mut beg = 0;`\n@@ -537,23 +549,17 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         self.loop_header(Place::Local(beg), end, BasicBlock::new(2), BasicBlock::new(4), false);\n \n         // BB #2\n-        // `let cloned = Clone::clone(rcvr[beg])`;\n+        // `dest[i] = Clone::clone(src[beg])`;\n         // Goto #3 if ok, #5 if unwinding happens.\n-        let rcvr_field = rcvr.clone().index(beg);\n-        let cloned = self.make_clone_call(ty, rcvr_field, BasicBlock::new(3), BasicBlock::new(5));\n+        let dest_field = dest.clone().index(beg);\n+        let src_field = src.clone().index(beg);\n+        self.make_clone_call(dest_field, src_field, ty, BasicBlock::new(3),\n+                             BasicBlock::new(5));\n \n         // BB #3\n-        // `ret[beg] = cloned;`\n         // `beg = beg + 1;`\n         // `goto #1`;\n-        let ret_field = ret.clone().index(beg);\n         let statements = vec![\n-            self.make_statement(\n-                StatementKind::Assign(\n-                    ret_field,\n-                    Rvalue::Use(Operand::Move(cloned))\n-                )\n-            ),\n             self.make_statement(\n                 StatementKind::Assign(\n                     Place::Local(beg),\n@@ -568,14 +574,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         self.block(statements, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n \n         // BB #4\n-        // `return ret;`\n-        let ret_statement = self.make_statement(\n-            StatementKind::Assign(\n-                Place::Local(RETURN_PLACE),\n-                Rvalue::Use(Operand::Move(ret.clone())),\n-            )\n-        );\n-        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+        // `return dest;`\n+        self.block(vec![], TerminatorKind::Return, false);\n \n         // BB #5 (cleanup)\n         // `let end = beg;`\n@@ -600,9 +600,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n                          BasicBlock::new(7), BasicBlock::new(9), true);\n \n         // BB #7 (cleanup)\n-        // `drop(ret[beg])`;\n+        // `drop(dest[beg])`;\n         self.block(vec![], TerminatorKind::Drop {\n-            location: ret.index(beg),\n+            location: dest.index(beg),\n             target: BasicBlock::new(8),\n             unwind: None,\n         }, true);\n@@ -626,55 +626,50 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         self.block(vec![], TerminatorKind::Resume, true);\n     }\n \n-    fn tuple_like_shim(&mut self, tys: &[ty::Ty<'tcx>], kind: AggregateKind<'tcx>) {\n-        match kind {\n-            AggregateKind::Tuple | AggregateKind::Closure(..) => (),\n-            _ => bug!(\"only tuples and closures are accepted\"),\n-        };\n+    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>,\n+                          src: Place<'tcx>, tys: I)\n+            where I: Iterator<Item = ty::Ty<'tcx>> {\n+        let mut previous_field = None;\n+        for (i, ity) in tys.enumerate() {\n+            let field = Field::new(i);\n+            let src_field = src.clone().field(field, ity);\n \n-        let rcvr = Place::Local(Local::new(1+0)).deref();\n+            let dest_field = dest.clone().field(field, ity);\n \n-        let mut returns = Vec::new();\n-        for (i, ity) in tys.iter().enumerate() {\n-            let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n+            // #(2i + 1) is the cleanup block for the previous clone operation\n+            let cleanup_block = self.block_index_offset(1);\n+            // #(2i + 2) is the next cloning block\n+            // (or the Return terminator if this is the last block)\n+            let next_block = self.block_index_offset(2);\n \n             // BB #(2i)\n-            // `returns[i] = Clone::clone(&rcvr.i);`\n+            // `dest.i = Clone::clone(&src.i);`\n             // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n-            returns.push(\n-                self.make_clone_call(\n-                    *ity,\n-                    rcvr_field,\n-                    BasicBlock::new(2 * i + 2),\n-                    BasicBlock::new(2 * i + 1),\n-                )\n+            self.make_clone_call(\n+                dest_field.clone(),\n+                src_field,\n+                ity,\n+                next_block,\n+                cleanup_block,\n             );\n \n             // BB #(2i + 1) (cleanup)\n-            if i == 0 {\n-                // Nothing to drop, just resume.\n-                self.block(vec![], TerminatorKind::Resume, true);\n-            } else {\n+            if let Some((previous_field, previous_cleanup)) = previous_field.take() {\n                 // Drop previous field and goto previous cleanup block.\n                 self.block(vec![], TerminatorKind::Drop {\n-                    location: returns[i - 1].clone(),\n-                    target: BasicBlock::new(2 * i - 1),\n+                    location: previous_field,\n+                    target: previous_cleanup,\n                     unwind: None,\n                 }, true);\n+            } else {\n+                // Nothing to drop, just resume.\n+                self.block(vec![], TerminatorKind::Resume, true);\n             }\n+\n+            previous_field = Some((dest_field, cleanup_block));\n         }\n \n-        // `return kind(returns[0], returns[1], ..., returns[tys.len() - 1]);`\n-        let ret_statement = self.make_statement(\n-            StatementKind::Assign(\n-                Place::Local(RETURN_PLACE),\n-                Rvalue::Aggregate(\n-                    box kind,\n-                    returns.into_iter().map(Operand::Move).collect()\n-                )\n-            )\n-        );\n-        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+        self.block(vec![], TerminatorKind::Return, false);\n     }\n }\n "}]}