{"sha": "0b521e5c475d20b4968e2d7856c1fbacd6171165", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNTIxZTVjNDc1ZDIwYjQ5NjhlMmQ3ODU2YzFmYmFjZDYxNzExNjU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-11T19:59:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-11T19:59:05Z"}, "message": "Rollup merge of #78899 - tmiasko:inline-diverging, r=oli-obk\n\nSupport inlining diverging function calls\n\nThe existing heuristic does penalize diverging calls to some degree, but since\nit never inlined them previously it might need some further modifications.\n\nAdditionally introduce storage markers for all temporaries created by\nthe inliner. The temporary introduced for destination rebrorrow, didn't\nuse them previously.", "tree": {"sha": "b1d33bf2763a2ffb05aa408b659cf6849d9019fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1d33bf2763a2ffb05aa408b659cf6849d9019fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b521e5c475d20b4968e2d7856c1fbacd6171165", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrEKJCRBK7hj4Ov3rIwAAdHIIAFKkUsgZhRSTlvDhh0GpW7t9\nZUYlMpbDxY9WI/EpgDLJu27fR75V3r79jEw5KZ0VRncA7lTMZEZ9OP8ZMcNhB4cX\nX6OHRTlYrlLxnTaIZxD2RDx7920wcfbPVEvZ0AYSH29qR3TtdhhTQ/6AaltV+a4X\nKq90XNcPc2OUagTNRiRFjM++/QHALKGBXh5y0ZzQxR1fBJCc64692WttkuG0GjK9\n7jS0xM0t/sNIYSV5J/thkSsjRRS0uA8Svl2ZY3Su73OHyozS0QtNqENQGtPTflFB\n+8kKjYdzxJ0vvzQRTtL4WHQrztwNHiuHnDR+LALxzS2f/e6RkBpNtyP32Mt7/AY=\n=+fdr\n-----END PGP SIGNATURE-----\n", "payload": "tree b1d33bf2763a2ffb05aa408b659cf6849d9019fb\nparent 919177f7e42f7585bbc8353b942a0feb1b67705e\nparent ffa70d75c8f5925ea26697c7ca5d20fd4d85cbb2\nauthor Jonas Schievink <jonasschievink@gmail.com> 1605124745 +0100\ncommitter GitHub <noreply@github.com> 1605124745 +0100\n\nRollup merge of #78899 - tmiasko:inline-diverging, r=oli-obk\n\nSupport inlining diverging function calls\n\nThe existing heuristic does penalize diverging calls to some degree, but since\nit never inlined them previously it might need some further modifications.\n\nAdditionally introduce storage markers for all temporaries created by\nthe inliner. The temporary introduced for destination rebrorrow, didn't\nuse them previously.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b521e5c475d20b4968e2d7856c1fbacd6171165", "html_url": "https://github.com/rust-lang/rust/commit/0b521e5c475d20b4968e2d7856c1fbacd6171165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b521e5c475d20b4968e2d7856c1fbacd6171165/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "919177f7e42f7585bbc8353b942a0feb1b67705e", "url": "https://api.github.com/repos/rust-lang/rust/commits/919177f7e42f7585bbc8353b942a0feb1b67705e", "html_url": "https://github.com/rust-lang/rust/commit/919177f7e42f7585bbc8353b942a0feb1b67705e"}, {"sha": "ffa70d75c8f5925ea26697c7ca5d20fd4d85cbb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa70d75c8f5925ea26697c7ca5d20fd4d85cbb2", "html_url": "https://github.com/rust-lang/rust/commit/ffa70d75c8f5925ea26697c7ca5d20fd4d85cbb2"}], "stats": {"total": 332, "additions": 256, "deletions": 76}, "files": [{"sha": "7737672dbde66d2a7b8b04a828f12727322fbf70", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -28,7 +28,8 @@ pub struct Inline;\n #[derive(Copy, Clone, Debug)]\n struct CallSite<'tcx> {\n     callee: Instance<'tcx>,\n-    bb: BasicBlock,\n+    block: BasicBlock,\n+    target: Option<BasicBlock>,\n     source_info: SourceInfo,\n }\n \n@@ -172,8 +173,7 @@ impl Inliner<'tcx> {\n \n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        // FIXME: Handle inlining of diverging calls\n-        if let TerminatorKind::Call { func: ref op, destination: Some(_), .. } = terminator.kind {\n+        if let TerminatorKind::Call { func: ref op, ref destination, .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n@@ -187,7 +187,12 @@ impl Inliner<'tcx> {\n                     return None;\n                 }\n \n-                return Some(CallSite { callee, bb, source_info: terminator.source_info });\n+                return Some(CallSite {\n+                    callee,\n+                    block: bb,\n+                    target: destination.map(|(_, target)| target),\n+                    source_info: terminator.source_info,\n+                });\n             }\n         }\n \n@@ -399,9 +404,9 @@ impl Inliner<'tcx> {\n         caller_body: &mut Body<'tcx>,\n         mut callee_body: Body<'tcx>,\n     ) {\n-        let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n+        let terminator = caller_body[callsite.block].terminator.take().unwrap();\n         match terminator.kind {\n-            TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n+            TerminatorKind::Call { args, destination, cleanup, .. } => {\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -418,43 +423,39 @@ impl Inliner<'tcx> {\n                     false\n                 }\n \n-                let dest = if dest_needs_borrow(destination.0) {\n-                    trace!(\"creating temp for return destination\");\n-                    let dest = Rvalue::Ref(\n-                        self.tcx.lifetimes.re_erased,\n-                        BorrowKind::Mut { allow_two_phase_borrow: false },\n-                        destination.0,\n-                    );\n-\n-                    let ty = dest.ty(caller_body, self.tcx);\n-\n-                    let temp = LocalDecl::new(ty, callsite.source_info.span);\n-\n-                    let tmp = caller_body.local_decls.push(temp);\n-                    let tmp = Place::from(tmp);\n-\n-                    let stmt = Statement {\n-                        source_info: callsite.source_info,\n-                        kind: StatementKind::Assign(box (tmp, dest)),\n-                    };\n-                    caller_body[callsite.bb].statements.push(stmt);\n-                    self.tcx.mk_place_deref(tmp)\n+                let dest = if let Some((destination_place, _)) = destination {\n+                    if dest_needs_borrow(destination_place) {\n+                        trace!(\"creating temp for return destination\");\n+                        let dest = Rvalue::Ref(\n+                            self.tcx.lifetimes.re_erased,\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            destination_place,\n+                        );\n+                        let dest_ty = dest.ty(caller_body, self.tcx);\n+                        let temp = Place::from(self.new_call_temp(caller_body, &callsite, dest_ty));\n+                        caller_body[callsite.block].statements.push(Statement {\n+                            source_info: callsite.source_info,\n+                            kind: StatementKind::Assign(box (temp, dest)),\n+                        });\n+                        self.tcx.mk_place_deref(temp)\n+                    } else {\n+                        destination_place\n+                    }\n                 } else {\n-                    destination.0\n+                    trace!(\"creating temp for return place\");\n+                    Place::from(self.new_call_temp(caller_body, &callsite, callee_body.return_ty()))\n                 };\n \n-                let return_block = destination.1;\n-\n                 // Copy the arguments if needed.\n-                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, return_block);\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body);\n \n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n                     new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n                     new_blocks: BasicBlock::new(caller_body.basic_blocks().len())..,\n                     destination: dest,\n-                    return_block,\n+                    return_block: callsite.target,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n@@ -503,7 +504,7 @@ impl Inliner<'tcx> {\n                 caller_body.var_debug_info.extend(callee_body.var_debug_info.drain(..));\n                 caller_body.basic_blocks_mut().extend(callee_body.basic_blocks_mut().drain(..));\n \n-                caller_body[callsite.bb].terminator = Some(Terminator {\n+                caller_body[callsite.block].terminator = Some(Terminator {\n                     source_info: callsite.source_info,\n                     kind: TerminatorKind::Goto { target: integrator.map_block(START_BLOCK) },\n                 });\n@@ -527,7 +528,6 @@ impl Inliner<'tcx> {\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n-        return_block: BasicBlock,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -558,18 +558,8 @@ impl Inliner<'tcx> {\n         // `callee_body.spread_arg == None`, instead of special-casing closures.\n         if tcx.is_closure(callsite.callee.def_id()) {\n             let mut args = args.into_iter();\n-            let self_ = self.create_temp_if_necessary(\n-                args.next().unwrap(),\n-                callsite,\n-                caller_body,\n-                return_block,\n-            );\n-            let tuple = self.create_temp_if_necessary(\n-                args.next().unwrap(),\n-                callsite,\n-                caller_body,\n-                return_block,\n-            );\n+            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n+            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n@@ -589,13 +579,13 @@ impl Inliner<'tcx> {\n                     Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty.expect_ty()));\n \n                 // Spill to a local to make e.g., `tmp0`.\n-                self.create_temp_if_necessary(tuple_field, callsite, caller_body, return_block)\n+                self.create_temp_if_necessary(tuple_field, callsite, caller_body)\n             });\n \n             closure_ref_arg.chain(tuple_tmp_args).collect()\n         } else {\n             args.into_iter()\n-                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body, return_block))\n+                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body))\n                 .collect()\n         }\n     }\n@@ -607,46 +597,52 @@ impl Inliner<'tcx> {\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n-        return_block: BasicBlock,\n     ) -> Local {\n-        // FIXME: Analysis of the usage of the arguments to avoid\n-        // unnecessary temporaries.\n-\n+        // Reuse the operand if it is a moved temporary.\n         if let Operand::Move(place) = &arg {\n             if let Some(local) = place.as_local() {\n                 if caller_body.local_kind(local) == LocalKind::Temp {\n-                    // Reuse the operand if it's a temporary already\n                     return local;\n                 }\n             }\n         }\n \n+        // Otherwise, create a temporary for the argument.\n         trace!(\"creating temp for argument {:?}\", arg);\n-        // Otherwise, create a temporary for the arg\n-        let arg = Rvalue::Use(arg);\n-\n-        let ty = arg.ty(caller_body, self.tcx);\n-\n-        let arg_tmp = LocalDecl::new(ty, callsite.source_info.span);\n-        let arg_tmp = caller_body.local_decls.push(arg_tmp);\n-\n-        caller_body[callsite.bb].statements.push(Statement {\n+        let arg_ty = arg.ty(caller_body, self.tcx);\n+        let local = self.new_call_temp(caller_body, callsite, arg_ty);\n+        caller_body[callsite.block].statements.push(Statement {\n             source_info: callsite.source_info,\n-            kind: StatementKind::StorageLive(arg_tmp),\n+            kind: StatementKind::Assign(box (Place::from(local), Rvalue::Use(arg))),\n         });\n-        caller_body[callsite.bb].statements.push(Statement {\n+        local\n+    }\n+\n+    /// Introduces a new temporary into the caller body that is live for the duration of the call.\n+    fn new_call_temp(\n+        &self,\n+        caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Local {\n+        let local = caller_body.local_decls.push(LocalDecl::new(ty, callsite.source_info.span));\n+\n+        caller_body[callsite.block].statements.push(Statement {\n             source_info: callsite.source_info,\n-            kind: StatementKind::Assign(box (Place::from(arg_tmp), arg)),\n+            kind: StatementKind::StorageLive(local),\n         });\n-        caller_body[return_block].statements.insert(\n-            0,\n-            Statement {\n-                source_info: callsite.source_info,\n-                kind: StatementKind::StorageDead(arg_tmp),\n-            },\n-        );\n-\n-        arg_tmp\n+\n+        if let Some(block) = callsite.target {\n+            caller_body[block].statements.insert(\n+                0,\n+                Statement {\n+                    source_info: callsite.source_info,\n+                    kind: StatementKind::StorageDead(local),\n+                },\n+            );\n+        }\n+\n+        local\n     }\n }\n \n@@ -671,7 +667,7 @@ struct Integrator<'a, 'tcx> {\n     new_scopes: RangeFrom<SourceScope>,\n     new_blocks: RangeFrom<BasicBlock>,\n     destination: Place<'tcx>,\n-    return_block: BasicBlock,\n+    return_block: Option<BasicBlock>,\n     cleanup_block: Option<BasicBlock>,\n     in_cleanup_block: bool,\n     tcx: TyCtxt<'tcx>,\n@@ -817,7 +813,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Return => {\n-                terminator.kind = TerminatorKind::Goto { target: self.return_block };\n+                terminator.kind = if let Some(tgt) = self.return_block {\n+                    TerminatorKind::Goto { target: tgt }\n+                } else {\n+                    TerminatorKind::Unreachable\n+                }\n             }\n             TerminatorKind::Resume => {\n                 if let Some(tgt) = self.cleanup_block {"}, {"sha": "ae6f814c290c8ee060a81ae45844c79324e57056", "filename": "src/test/mir-opt/inline/inline-diverging.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -0,0 +1,40 @@\n+// Tests inlining of diverging calls.\n+//\n+// ignore-wasm32-bare compiled with panic=abort by default\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR inline_diverging.f.Inline.diff\n+pub fn f() {\n+    sleep();\n+}\n+\n+// EMIT_MIR inline_diverging.g.Inline.diff\n+pub fn g(i: i32) -> u32 {\n+    if i > 0 {\n+        i as u32\n+    } else {\n+        panic();\n+    }\n+}\n+\n+// EMIT_MIR inline_diverging.h.Inline.diff\n+pub fn h() {\n+    call_twice(sleep);\n+}\n+\n+#[inline(always)]\n+pub fn call_twice<R, F: Fn() -> R>(f: F) -> (R, R) {\n+    let a = f();\n+    let b = f();\n+    (a, b)\n+}\n+\n+#[inline(always)]\n+fn panic() -> ! {\n+    panic!();\n+}\n+\n+#[inline(always)]\n+fn sleep() -> ! {\n+    loop {}\n+}"}, {"sha": "6e36dc06a201e87f731dc0831205beab12007384", "filename": "src/test/mir-opt/inline/inline_diverging.f.Inline.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `f` before Inline\n++ // MIR for `f` after Inline\n+  \n+  fn f() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:7:12: 7:12\n+      let mut _1: !;                       // in scope 0 at $DIR/inline-diverging.rs:7:12: 9:2\n+      let _2: !;                           // in scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     let mut _3: !;                       // in scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     scope 1 (inlined sleep) {            // at $DIR/inline-diverging.rs:8:5: 8:12\n++     }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n+-         sleep();                         // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:8:5: 8:10\n+-                                          // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++         goto -> bb1;                     // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     }\n++ \n++     bb1: {\n++         goto -> bb1;                     // scope 1 at $DIR/inline-diverging.rs:8:5: 8:12\n+      }\n+  }\n+  "}, {"sha": "3dc33354a5a56d699a85c72c2bae44b9fb422343", "filename": "src/test/mir-opt/inline/inline_diverging.g.Inline.diff", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -0,0 +1,52 @@\n+- // MIR for `g` before Inline\n++ // MIR for `g` after Inline\n+  \n+  fn g(_1: i32) -> u32 {\n+      debug i => _1;                       // in scope 0 at $DIR/inline-diverging.rs:12:10: 12:11\n+      let mut _0: u32;                     // return place in scope 0 at $DIR/inline-diverging.rs:12:21: 12:24\n+      let mut _2: bool;                    // in scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+      let mut _3: i32;                     // in scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+      let mut _4: i32;                     // in scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+      let mut _5: !;                       // in scope 0 at $DIR/inline-diverging.rs:15:12: 17:6\n+      let _6: !;                           // in scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++     let mut _7: !;                       // in scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++     scope 1 (inlined panic) {            // at $DIR/inline-diverging.rs:16:9: 16:16\n++     }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+          _3 = _1;                         // scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+          _2 = Gt(move _3, const 0_i32);   // scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-diverging.rs:13:12: 13:13\n+          switchInt(_2) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/inline-diverging.rs:13:5: 17:6\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n+-         panic();                         // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++         StorageLive(_7);                 // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++         begin_panic::<&str>(const \"explicit panic\"); // scope 1 at $DIR/inline-diverging.rs:16:9: 16:16\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:16:9: 16:14\n+-                                          // + literal: Const { ty: fn() -> ! {panic}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/inline-diverging.rs:16:9: 16:16\n++                                          // + literal: Const { ty: fn(&str) -> ! {std::rt::begin_panic::<&str>}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n++                                          // mir::Constant\n++                                          // + span: $DIR/inline-diverging.rs:16:9: 16:16\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+          _4 = _1;                         // scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+          _0 = move _4 as u32 (Misc);      // scope 0 at $DIR/inline-diverging.rs:14:9: 14:17\n+          StorageDead(_4);                 // scope 0 at $DIR/inline-diverging.rs:14:16: 14:17\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-diverging.rs:18:1: 18:2\n+          return;                          // scope 0 at $DIR/inline-diverging.rs:18:2: 18:2\n+      }\n+  }\n+  "}, {"sha": "b728ad4b42899bd56f378988156a32a30631f615", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -0,0 +1,58 @@\n+- // MIR for `h` before Inline\n++ // MIR for `h` after Inline\n+  \n+  fn h() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n+      let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _7: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _8: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _6: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         scope 2 {\n++             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n++             scope 3 {\n++                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n++             }\n++             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++                 scope 7 (inlined sleep) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++                 }\n++             }\n++         }\n++         scope 4 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++             scope 5 (inlined sleep) {    // at $DIR/inline-diverging.rs:22:5: 22:22\n++             }\n++         }\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n+-         _1 = call_twice::<!, fn() -> ! {sleep}>(sleep) -> bb1; // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _2 = sleep;                      // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:22:5: 22:15\n+-                                          // + literal: Const { ty: fn(fn() -> ! {sleep}) -> (!, !) {call_twice::<!, fn() -> ! {sleep}>}, val: Value(Scalar(<ZST>)) }\n+-                                          // mir::Constant\n+                                           // + span: $DIR/inline-diverging.rs:22:16: 22:21\n+                                           // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_7);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _7 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n+      }\n+  \n+      bb1: {\n+-         StorageDead(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:22: 22:23\n+-         _0 = const ();                   // scope 0 at $DIR/inline-diverging.rs:21:12: 23:2\n+-         return;                          // scope 0 at $DIR/inline-diverging.rs:23:2: 23:2\n++         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n+      }\n+  }\n+  "}, {"sha": "3c0dfb4a77e1643e2830cf50a09ef5e4e5ee8461", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -18,6 +18,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _2 = Box(std::vec::Vec<u32>);    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n -         (*_2) = Vec::<u32>::new() -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _4 = &mut (*_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         ((*_4).0: alloc::raw_vec::RawVec<u32>) = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: {0x4 as *const u32}, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +                                          // ty::Const\n@@ -34,6 +35,7 @@\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0_usize; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageDead(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n           _1 = move _2;                    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           StorageDead(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n           _0 = const ();                   // scope 0 at $DIR/inline-into-box-place.rs:7:11: 9:2"}, {"sha": "a72db9cf1dc8f9bfdcf459492e63459598671dd8", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0b521e5c475d20b4968e2d7856c1fbacd6171165/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=0b521e5c475d20b4968e2d7856c1fbacd6171165", "patch": "@@ -18,6 +18,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _2 = Box(std::vec::Vec<u32>);    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n -         (*_2) = Vec::<u32>::new() -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _4 = &mut (*_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         ((*_4).0: alloc::raw_vec::RawVec<u32>) = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: {0x4 as *const u32}, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +                                          // ty::Const\n@@ -34,6 +35,7 @@\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0_usize; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageDead(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n           _1 = move _2;                    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           StorageDead(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n           _0 = const ();                   // scope 0 at $DIR/inline-into-box-place.rs:7:11: 9:2"}]}